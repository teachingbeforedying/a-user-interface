04 décembre 2020: initial morning program based on https://github.com/TomHumphries/InfiniteCanvasWhiteboard

0 create zoom loops

*	0 there is so much space, that one can hide messages in the vast infinity

05 décembre 2020:
0 échelle
  0 double flèche

0 parcours
	0 arbre
	0 notation 0-20 : nb_questions = n(n-1)/2 = 190

06 décembre 2020:

0 Arrow:
  0 "horizontal arrow" : 10 fois plus loin
  0 "vertical arrow"   : 10 fois plus grand
  0 "oblique arrow"    : itinéraire (ou mesure)

0 itinéraire:
    0 select pointA, pointB
    0 draw arrow
      0 orientation automatique de la flèche représentant l'ordre de grandeur courant en fonction de la flèche "itinéraire"
    0 find order of magnitude and "get there" (show the arrow with the "right size" wrt screen)

0 from question A to question B:
	0 create line from A to B and follow it in the direction of the arrow till you meet the next exercise
	0 warp

0 from question A,B and C to question D:
	0 triangulate

0 PAUL's vision:
  deux calculs
    L'abscisse est la réponse à la question 1
    L'ordonnée est la réponse à la question 2
    Abscisse et ordonnée par rapport au _repère courant_

    avec un repérage "A1":
    on peut utiliser les préfixes comme indicateur de colonne

  tableau d'un peintre: fractale

11 décembre 2020:

**0 import pdf

0 workflow :
		0 import mind map pdf
		0	enrich the map by adding
				0 neurohandle images : a goat, a lion,
					0 associate biome to zoomLevel
				0	content inside those neurohandles : exercices, problems, figures...

* 0 hardcore : zoom trap : when zooming out, user does not get to previous scene, but sees zoomed out current scene

14 Décembre 2020:
**Z-PUZZLE: bring object back to its corresponding slot (object can be extended, shrinked)
		0 click and scroll to change size
			0 long click| long press to lock obj selection

15 Décembre 2020:

**Z-Puzzle avec des carrés : inscrire un nombre dans le carré, avec une double flèche pour indiquer la longueur du côté, _à l'intérieur_

0 Z-Puzzle Logo : write Z-Puzzle with squares of different sizes

0 WOW effects :
  0 puzzle pieces are on a blue background : blue background is only a small (blue) part of a big piece of the puzzle
  0 puzzle pieces are on a table : the table is a part of a big piece of the puzzle

16 Décembre 2020:
	0 puzzle creation :
		0 image split
		0 create puzzle piece using cutting path

	0 commencer par un petit Z-puzzle à 4 pièces :
			initialisation : toutes les pièces sont carrés, de la même taille, de couleur différentes avec un numéro différent (1,2,3 ou 4)
			le slot pour le numéro 1 est très grand, on voit dans la vue initiale un petit morceau de bordure de 1
			le slot pour le numéro 2 est de taille initiale
			le slot pour le numéro 3 est petit mais on peut y arriver avec un resize classique
			le slot pour le numéro quatre est très petit

17 décembre 2020:

	idées:
	0 movable/unmovable objects : bg objects vs interaction objects
	0 z-index should (/may) decrease when object gets bigger (imagine an image of the universe which was contained in a house window)
	0 group/ungroup when z-scrolling inner element

	0 inno_further:
		0 double object: {front layer, back layer}
				front layer displayed when scale <= x
				back  layer displayed when scale > x
				example: closed window / open window
				=> 0 calendrier de l'avent

			0 living object: front layer may change if something has been done "inside" object (i.e. when scale > x)


	0 edu:

		0 numbers fractal :   [             9              ]
	                        [0][1][2][3][4][5][6][7][8][9]
													etc.
													il y a le zero-level : avec [0,][1,][2,][3,][4,][5,][6,][7,][8,][9,]

		0 10^n rectangles       _____________________________________________________________________________________________________
														[                                  10^n                                                             ]
														-----------------------------------------------------------------------------------------------------

														__________
	                        	[10^(n-1)]
														----------

		0 double layer numbers :
		 		front
										[             ]
										[      9      ]
										[             ]
				back
										[  1   2   3  ]
										[  4   5   6  ]
										[  7   8   9  ]


19 décembre 2020:

*	0 remanent points : center point for rotation is displayed then fades when rotation is done

*	0 complex animations :
		0 X-wing : zoom-in + centered rotate
		0 spiral staircase : zoom-in + non-centered rotate

** 0 animated objects : endless spinning wheel, endless translation
*			0 user could force software to adopt moving object's referential

** 0 temporal active objects :
		  0 calendrier de l'avent : mettre un timer dans le programme pour que les fenêtres (==double object) ne soit "ouvrables"(==pénétrables) que lorsque le jour est passé
      0 devoir maison : le sujet n'est plus accessible après
      0 interro : time frames

    0 edu:
				three sectors : course material plane is divided:
					green sector  : easy : for everyone
					orange sector : moderate : for almost everyone
					black  sector : serious : for strong pupils

					students can rotate the wheel to access to stronger content

    0 un z-puzzle simple:
			des carrés de couleur

    0 z-puzzle with reflection : negative scale

    0 snapping:
			0 move
			0 resize
			0 rotate
			0 what is the right snapping percentage ?

20 décembre 2020:
  edu:
    bien affcher la taille et la position du rectangle d'observation

  zpuzzle:
    0 droite graduée et profil affine (carré de différentes tailles)
      un humain près du 1 (1 mètre)

    0 z-puzzle : telephone
        7  8   9
        4  []  6
        1  2   3

    0 colored squares with dimensions
  			0 format : factor    x     power of ten
    			[---------]
    			[<------->]
    			[   3,8   ]
    			[    x    ]
    			[ 10^(-2) ]
    			[_________]
        0 need _reference_ arrow

    0 more complex: no reference is shown : pupil has to use relative sizes to solve puzzle

** z-scroll, r-scroll, etc. is only about placing the selected object in _a different ("hovering") layer_, and then dropping it in the original layer
    maybe code would be cleaner if it was done this way
*   => hovering layer is the player's backpack (multiple objects could travel along)


* ((double puzzle: recto / verso


*  basic exercice course:
    exercise n:
      - image (funny)
      - statement (less funny ^^)
      - answer text field:
          on right answer : open exercise n+1 door etc.

** OUR WEBSITE : students' have a website consisting of an infinishute
     every student can have its own miniverse in the infinite vastness

* animation: pov path  : from pov1 to pov2 to pov3 to pov4 etc.
    edu: séquence de mémorisation


*[
	Keyboard shortcuts:
			F: Rect          F for fabric
      Shift F: Toggle object.reactor on/off
			T: Text
      Shift T: Tag
			X: Point         "cross"  (if   nothing is selected)
         OR: sameHomeScaleClone (if something is selected)
             Shift X: geminiShade
      D: Droite                 (if   nothing is selected)
         Decoration Begin/End   (if something is selected)

      Q: Circle        Q looks like O
      W/N: Polyline    W/N is a polyline

      M:       Measurement arrow  (depends on context orientation)
        ? + M: greatest length
        ? + M: smallest length

      G: Group
         while supervessel cargoing: 
          KeyG:       operateOnActiveObject__gemini (clone + geminiLink)
		      KeyG + Alt: operateOnActiveObject__echo   (clone + echoLink)
      B: Ungroup       "Break group"
            (special: toggle .isMobile of selected composite part)
      Shift G: Compose
        Shift Alt G: Compose (special)  (je ne sais plus à quoi je pensais quand j'ai écrit ça...)
        Shift ² G: Compose: create equation
      Shift B: Decompose

      Alt G: Link
      Alt B: Unlink

      Shift + move:
            (special: force move of selected composite part (== make as if it were .isMobile == true))

      "!": Show object types (KeyDown (toggle)) (on peut voir (via une bordure spéciale par exemple) les composites, les groupes, les objets normaux, etc.)
      ",": Split active object (==object in supervessel, be it currently held (mousedown) or simply selected)
      ";": Join active objects (==objects in supervessel)
      "_": Toggle icObj.isTouchable

      A: zoom out (KeyDown (timeout))     "Away"
      Z: zoom in  (KeyDown (timeout))
      Shift A: zoom out (/10)
      Shift Z: zoom in  (x10)

			R: Rotate   (KeyDown (toggle))
			C: Color    (KeyDown (toggle))
        ² + C :         pick color at cursor (canvas "global")
        Shift + ² + C : pick color at cursor (canvas fObj in front)
        ?unknown shortcut?: pick color at cursor (document global)
      V: Opacity  (KeyDown (toggle))
      W: StrokeWidth   (KeyDown (toggle))
      "²": FreeDrawing (KeyDown (toggle))
        Shift "²": FreeDrawing group (group parts)
        <unknown shortcut>: Evanescent FreeDrawing
        <unknown shortcut>: Sticky FreeDrawing
        Alt "²": cosmetic FreeDrawing (== (.isCosmetic == true))
          maybe "isCosmetic" should have a reserved keyDownToggle, in order to spawn objects _of any type_ with .isCosmetic true or false
      <: Category (KeyDown (toggle))      (this will allow: selectNextObject(activeCategory), selectAllObjects(activeCategory)...)
      &/1: Cursor (KeyDown (toggle))      (this will allow: click on obj VS select obj and then move it)
      X: Context orientation (KeyDown (toggle))   (horizontal, vertical, ltrb diagonal, rtlb diagonal)
      "^": Landing stage (KeyDown toggle): new objects spawn in landing stage (object or infiniteCanvas, or infiniteCanvas.layerX))

      H: Homescale for new objects (KeyUp (toggle))
      Shift H: save homeScale to preset.homeScale

      CTRL + 0: move to origin pov
      digit<n> move to pov<n>

      Y: Z-Puzzle slot
      P: Create Platform
      Shift P: Create ProtoSlot

      E : Activate (maybe mouse click is more intuitive)
      E(long press): toggle reactive version

      S: Save all              (when nothing held)
         Toggle Sticky Release (when something held)
      Shift S: save selection
      L: Load

      Esc: cancel current behavior (for example Sticky Release)

      ← ↑ → ↓: move active selection

      +/-: "Time" control: accelerate, slow down (KeyDown (toggle) == as in game consoles emulators)

      debug:
        Toggle Supervessel (KeyUp (toggle))

  Keyboard+Mouse:
    rightMouseDown + zoomIn/Out   keeps screenRect centered on object while zoomingIn/Out
    Shift + scale via side controls: unitCloneScale

ET LES GAUCHERS ALORS ?...

*]

1 keyZ: zoom-in to cursor / zoom-out
  "KeyW" : get aWay
  "KeyE" : "Enter"/"Explore" : zoom-in
  1 keyDownTimeout
  0 keyDownTimeout VS keyDown: complex mgmt to only zoom once when key is "simply" down-up'd (== ? pressed ?)
**		=> problem "vanishes" when timeout delay is 17 ms (== "small enough")

** sometimes it all adds up nicely (==resulting feature): rightMouseDown + zoomIn/Out keeps screenRect centered on object (this is a nice feature which should be preserved)

* antialias "pixel fight" when zoomingIn is like Heisenberg's principle, it's more and more shaking

** edu: le petit poucet de Gulliver : semer des petits cailloux à chaque niveau de zoom pour ne pas se perdre
    => les amener à comprendre la notation décimale
**    on "remonte" un nombre comme par exemple 14758,1654873    (on part du niveau de zoom)
** avoir un affichage spécifique pour les "zéros facultatifs" (que ce soient ceux qui sont à gauche ou à droite de la virgule)
    0 affichage additif (on affiche le nombre sous la forme sigma(ai x 10^i))

    0 representations:
      0 square representation : I don't like this one because it may override what we try to teach regarding areas
      1 rectangle representation : better
**      1 "representation 74" (xylophone representation) (width does not matter, only height matters)
*         0 704 : write "0" when no column is filled
            0 fill remaining space in black and write "0" when no column is filled
*         0 add double arrow (as separator) : double arrow size depends on select number, to show that only height matters
          0 show |10^<n> sector| on top of each xyloblock
*         0 show addition of two number with this representation
            0 two "lines" (is this possible ? (yes, if all towers have same height))
            0 abaccus way
*         0 allow user to type number and draw corresponding representation
            => 0 exercise : type the number corresponding to the displayed representation
                0 easy:           183,01
                0 standard:   140 015,3
                0 hard:     1 000 000,000 028
*         0 allow user to select rectangles and show corresponding number
            => 0 exercise : select rectangles to represent the number 157,005408
                 0 show "current number: ...."
                        "target        : ...."
          0 negative numbers : upside down
            0 show addition of positive and negative number
          0 show sqrt(2)
          0 square product of two xylos
            0 show sqrt(2) * sqrt(2)
          0 xylophone number char representation: small 1, bigger 2, even bigger 3 etc.
*       0 representation "empire state building" : pile up all rectangles
          0 with rectangles
          0 with real-life objects rectangles
          0 add corresponding power of ten square [10^<n>] next to the xyloblock
*       0 representation fallen skyscraper : empire state building goes horizontal
          0 with rectangles
          0 with real-life objects rectangles
        0 animation:
          0 from xylophone to empire state building
          0 from empire state building to fallen skyscraper
**          0 Wow effect: la virgule tournée dont on ne comprend pas au départ la signification, revient dans le bon sens pour former l'écriture décimale du nombre (écriture décimale "pondérée")
        (0 representation "closest square puzzle"
      0 sum of scientific notations (sigma(ai x 10^i))
      0 exponential-carried representation (logarithmic scaleX)
      0 fractal path representation ("5,1 c'est un bonhomme et un petit poisson"): each square has BL = (0 ; 0) and BR = (10^<n> ; 0)
        0 create "trailing part" only when "tower" becomes active (or else number of objects will grow exponentially)
      0 représentation en aire: essayer de montrer un remplissage des xylorects de telle manière que le nombre représenté corresponde à la somme des aires

    0 "vous avez débloqué un nouveau secteur : partie décimale"


  0 colored numbers:
*   0 zero could have transparent color ("container")
*   0 non used level number could have very low opacity (but we could still seem them)
*     0 write "0" when no column is filled

  0 power of ten : patterns
    each power of ten has a characteristic filling pattern (example: hearts, diamonds,  ... , cars, cells, ... )



pour la multiplication de deux nombres :
  représentation en surface d'un nombre : on prend arbitrairement un des deux comme 'multiplicateur' et l'autre comme la surface à multiplier
  attention : multiplier une surface par 2 : simplement prendre deux instances de la surface initiale et les accoler

  0 mécanique de précision : trouver la pièce complémentaire

*** zoom-bound freeDrawing text reading animation

21 décembre 2020:
  une séance préparée pour 1 heure pour 24 élèves VS un programme pour x heures pour 10^n élèves

* un nombre (fini), c'est un parcours (fini) sur une fractale.

  0 show sqrt(2) * sqrt(2)

  0 make it sexy
    0 round corners
    0 "this thing is living" animations


*  0 raster and vector DUO: one window infiniteCanvas, the other paint.net : copy/paste images to and fro

  0 applications:
    0 une année de 4ème:
      0 tangram cat :
        0 translation only :
*         0 unrotatable fObj
          0 unscalable  fObj
            0 fixed scaleX|Y
            0 fixed homeScale

    0 une carte de mes voyages

    0 C-puzzle ("create objects" puzzle) : "recrée avec des formes l'image suivante"

** icObj.type = "url" : open new tab on click
      0 move to next exercise
*  icObj.type = "video"
*	 icObj.type = "webcam"

0 ne pas vouloir trop en faire pour le moment, rester sur quelque chose de simple

22 décembre 2020:
  Internet exists :
*   0 Z-puzzle : have players go find the puzzle pieces (==images to paste on canvas) on the Internet
**  0 CTRL-F on a webCanvasPage

* object wells: click and drag on object well to get an instance
    0 static
    0 animated object wells : le triangle rectangle qui tire des carrés qui disparaissent dans un portail cicatrice, on peut attraper le carré au vol

LES FAIRE FAIRE => il faut qu'ils utilisent l'éditeur à un moment donné

* représenter l'espace mental alloué dans l'infiniteCanvas : FORTNITE en gros et Mathématiques en tout tout petit

* le code informatique est lui aussi quelque chose de "moderne", dans le sens où il est porté par une fractale (à la différence du "plain text" (si on ne prend pas en compte les références littéraires ou culturelles))

* Le cours de la 4ème<X>:
    at start of class, file is opened
    during class,      content is edited
    at end of class,   file is saved

23 décembre 2020:
* La même chose avec les fractions : utiliser l'infinite canvas pour montrer les fractions
    0 enchaînements alternés de découpages verticaux puis horizontaux etc.

* "Nombres en boutons"(== xylophone, fractal rep, etc.)::Somme
    positive side is immutable : get to target number using only negative side buttons (target = negative + positive)
* Probabilités avec les nombres en boutons de fabriquer le nombre N ?

** infiniteCanvas editor is a place for students to run algorithms by hand (? ideal sandbox ?)
    example: create Koch snowflake
    example: create Sierpinski's triangle

    exemple: trier un jeu de cartes...

* skewing exists in fabric => easy parallelograms from square
* Skewing allow easy creation of "big-to-small arrows" from standard arrows

* le project, c'est peut-être augmenter la boîte à outils numériques des élèves :
    - Scratch
    - Geogebra
    - Tableur
    - Infinite Canvas Whiteboard

* visualisation/manipulation des homothéties avec un object well et le zScroll
    Z-Puzzles sur les homothéties


* icObj types:
    [
      //primitive
      rect
      text
      circle

      //composite
      group (== anonymous composite)
      groupWithBgRect (bg rect will allow stroke and fill (== border and backgroundColor))
      card
      doubleObject
    ]

* z-puzzle : user must create group with objects ( zSlot only accepts group with particular properties)

* workingHomeScale : this would allow easy drawing of architectural planes

** mScroll (est-ce que ça a la moindre utilité ?)


** light-sending (== eye-catching) objects : no matter what current infiniteCanvas.scale is, a star grows from object so that it is visible at current infiniteCanvas.scale

** marker objects (on revient au côté whiteboard): those objects are like the other canvas objects, but they are not designed to stay, they are here to ease explanations
    0 toggle show marker objects
    0 clear marker objects

* animation: décollage de fusée
* l'infiniteCanvas permet de matérialiser des expressions du genre "étudier en profondeur" ou "un savoir superficiel"
* presentation : standard "infinite fall" story carrier: each story item is displayed on a square at zoom level n

* dynamic fabric object which parts pop and destruct along with the current pov (follow the yellow road) (this way an infinite object (like an axis) still can be represented)

24 décembre 2020:
* Lien entre le xylophone et les z-puzzles : La balance: target weight / current weight  (peser une planète sur une balance, c'est irréaliste, mais bon...)
**   paradrop:
        "updward" z-scroll(the only available) momentaneously changes object homeScale but object falls down to its natural homescale when released
        sparkle indicates where small object is (if user wants to remove it from the scale(==balance))

*edu: angle pas droit: glisser un éléphant dans l'espace intersticiel et ajouter un commentaire à côté "regarde, l'angle est tellement pas droit, qu'on a pu y ajouter un éléphant"

**  student may ask for hint:
      sparkle (light-sender)
      Arrow indicator in HUD ("in this direction, there may be something useful")
        hide arrow indicator when user is "in the object surroundings"
        additionnal upward/downward arrow to avoid using too many sparkles

** Le multiplicateur :
      un objet est sélectionné
      l'utilisateur choisit le type de multiplication : longueurs ou aire
      un nouvel objet est créé selon la multiplication

** Le guide âne pour montrer les découpes de fractions

* xylophone : 10^<n> zone : "nombre sélectionné dans cette zone" : donner plusieurs écritures
    exemples:
      5 x 10^4 : 50 000
      2 x 10^(-3) = 0,002
** /!\ aux erreurs d'arrondi quand on demande à l'ordi de sommer tous les termes
    updateActiveNumber 0.7000000000000001 (when only "sharp 0.7" is active...)
      => use string type
      OR
      => use Math library

** Comment faire pour débugger quand il n'y aura plus de logs pour avoir la meilleure performance possible ?

* zéro est un nombre comme les autres : créer une autre version du xylophone avec le zéro selectionnable et pas de toggle isActive sur les xylophone towers
    (le xylophone vanilla à un zéro "absence")

** xylo abaccus: manage temporary multiple active towers in xyloZone : show timer 3,2,1 and then resolve chaos and bring back order. This can involve cascade updates.

** il y a des problèmes que la civilisation se pose à elle-même : pourquoi avoir gardé le système de position des nombres de la droite vers la gauche alors que l'on lit de gauche à droite en occident ?
    parce que du coup, on se retrouve avec une droite graduée, qui va "dans le mauvais sens"

**xyloSynth: user types number and xylo updates accordingly (though we can't see much with standard xylo) (exponential xylo will be more readable)

* black is a strong color : black zero in xylophone catches the eye a lot, is it a good idea ?

** multiplication de deux segments colorés : utiliser des gradients pour former un damier
    _[___|___|___] segment3, couleur3
   | |
   |_|   à l'intérieur, chaque rectangle (ou carré en fait) est colorié avec un gradient de manière à former un damier (on voit n x m carrés, et on voit que leur couleur c'est un mélange de couleur_n et de couleur_m)
   | |
   [_|
  segment2, couleur2

25 décembre 2020:
* xylophone: ? add sounds ? (en base 9 on peut faire do ré mi fa sol la si do)
  0 ECRIRE EN GROS : ~ 5x homeScale

  *zPuzzle: piecewise hints:
    "la pièce n°2 se trouve au coordonées : x = ...   y = ..." et la position courante est affichée dans le HUD ->> l'élève peut chercher à tatons


** all is there : everything on the same canvas (~The Witness)
      remarque: le xylophone prend déjà une bonne partie de la place
** metagame : stars: get all 20|120 stars (comme dans Mario)
      3 stars for every minigame: easy, medium, hard (ces étoiles apparaissent dans un écrin de verre qu'on enlève en réussissant l'exercice)
**    étoiles d'exploration : some starts are there for the taking

   metagame: completing exercise X gives a puzzle piece for completing exercise Y
***    par exemple des xyloTowers ("touches de xylophone") pour pouvoir écrire des nombres qu'on ne pouvait pas écrire avant (ce qui fait le lien entre (z-)puzzle et xylophone (la xyloTower ne change pas de taille (pour ne pas trop perturber le joueur (au moins au début))))
          ce qui ferait du xylophone un objet central, sur lequel le joueur reviendrait plusieurs fois,
          et qui donnerait au jeu une saveur à la The Witness (autrement dit, une saveur exceptionnelle)
          ou par exemple des xylozones incomplètes aussi, ou même des xylozones adjacentes collées entre-elles (tout un secteur de puissances)
          ou aussi des xylozones avec les xyloTowers qui sont pas mises dans le bon ordre et qu'il faut remettre dans l'ordre avant de pouvoir les utiliser

  (0 beautiful xyloZone : perroquet: oeil(zéro) et ailes(1-9)

**  units converter : user types number and (unit_from; unit_to) and:
      1. the two unit-bound xyloZones are highlighted, unit_from with red border and unit_to with green border for example
      2. each xyloZonePerception has two lines : one for the number expressed in unit_from and the other in unit_to
      so user sees it's only a shift (when units are "scalar units")

*	ne pas réinventer la roue : https://mikemcl.github.io/decimal.js/ (javascript numbers have limited precision)

** separate 10+ mantissa numbers when writing string rep: separator |, or bracketing [] (instead of having to create symbols (we don't write A for 10, we write 10| or [10]))
    + write which base is used (cela va de soi)

* remplacer le point de la notation anglo-saxone par la virgule
** toutes les zones ramenées à unitZone.homeScale: afficher des agrandissements/réductions des différentes zones (un truc avec des lignes à moitié diagonales) pour arriver à un affichage de la somme des composantes à homeScale == unitZone.homeScale

* xylophone: fading optional zeros for decimal number : zero "inside" !!= zero "outside" (==optional) (concept mathémtique: chiffres significatifs)
* xylophone: cadenas à code pour xyloShow: user inputs number via scrollable cylinders

* 0 make xylophone dynamically infinite (destroy/create zones around current scale)

*:'( 2D canvas does not allow non-parallel skewing (~"scale traversing" objects)
    => use a 3D library to have:
      -scale traversing arrows
      -"pov aware" objects (==orienting sprites (as in paper mario))

26 décembre 2020:
***( un hyperlien, c'est juste un portail (dans le sens Portal)
      tous les portails de l'infiniteCanvas sont à sens unique (impossible de se retourner dans un espace 2D et aussi: un portail n'a pas d'épaisseur)
* traverse portal while zScrolling (==while "carrying" object)

* Build Empire State Building tower (ESB tower) with xyloTowers
  =>
* size-preserving z-scroll

** power fractals:
    squares
      8 8 8 8
      8 8 8 8 etc.
      2 2 4 4
      1 1 4 4
    staircase
      1
      [1] [1]
      [2   2] [2   2]
      [4   4   4   4] [4   4   4   4]
      etc.

** 0 Flat xylophone
    0 additions
    0 multiplication: scale "multiplier xylophone" so that the result's area equals B times A's area
      flatXyloB * flatXyloA
  A->   [   1   ]
       2[   1   ]
       2[   1   ]

       ^
       |
       B

*" en fait, y'a que des fractales partout, des conteneurs dans des conteneurs dans des conteneurs, etc. etc. etc.
*" je suis pas idéaliste ; mes idées, je sais qu'elles sont réalisables. (et je le sais parce que "ça" a infusé en moi)
*" l'infiniteCanvas, c'est juste un espace dimensionné pour notre discipline (autrement dit un espace infini)

** toutes ces fractales prennent beaucoup de place, si je pouvais mettre des canvas dans des doubleObjects, ce serait moins encombré, on serait plus à l'aise. Et ce serait davantage rangé. ça ferait comme les niveaux dans Mario64.

*** OPEN YOUR MIND (== "the world from a slit" / "THIS IS UNKNOWN TERRITORY"): initially, the player can only only see a small (_yet infinite_) part of the canvas, because there is a slit and the rest is black and filled with "unknown territory" labels
      open your mind animation: move to slit pov and show user that the slit is growing to a new size (/mutating to a new shape ?)
      -idée de scène initiale:  la caverne de Platon, et ensuite la personne se retourne (grosse animation, stupeur, mydriase etc.)

* a universe in ceiling cat's left eye

** "eye in eye" sequence: reversed image in retina: someone looks to someone which looks to someone, etc.

** entire book in canvas
** entire books : the Library

** time picture frame tunnel:
      __________
      |1940
      |    ______
      |    |1941
      |    |
              ...

* 0 trouver un moyen de symboliser "cette pièce est/n'est pas z-scrollable (i.e. "cette pièce à une taille fixe")"

** z-puzzle: arbre de calcul interactif: targetNumber,currentNumber
      easy: pieces == numbers
      normal: pieces == operators
      hard : pieces == numbers & operators
      => need graph library
        ? https://github.com/anvaka/ngraph.fabric

** z-puzzle: remettre les noms d'objets au bon endroit étant données telles et telles propriétes
    exemple:

** pour le calcul mental: parcours avec un timer: il faut aller récupérer le trésor caché profond en entrant succesivement dans des portes. Si le joueur met trop de temps il est ejecté (zoom-out animation) jusqu'à la porte de départ.
      la zoom-out animation doit être un peu costaude à coder non ?
      en cas de succès : collecter automatiquement l'étoile pour ne pas frustrer le joueur qui avait réussi à la débloquer ?

*[
  mini game ideas so far:
    xylo_write
    xylo_read
    z-puzzle: classic
    (z-)puzzle: arbre de calcul
    (z-)puzzle: range les nombres dans l'ordre croissant (on peut donner une sorte d'indice en mettant un mini xylo la tête en bas pour les nombres négatifs)
    (z-)puzzle: geometry: object names
    z-puzzle: citizenship/society: remettre les choses à la bonne taille
      par exemple: on écrit en grand "MOI"    et en petit "les autres", pour représenter l'individualisme
                   on écrit en grand "DROITS" et en petit "devoirs",    pour représenter l'oubli fréquent du lien entre les deux aspects de la loi
                   le joueur doit rétablir l'équilibre, c'est-à-dire la même taille pour les deux objets

    timeout travel: standard (pour exercer la mémoire, genre "active l'interrupteur à côté de la mouche", "maintenant, active l'interrupteur à côté de Y")
      on timeout write "time expired" and "you hear a door closing" to warn player that they'll have to start again back from the start
    timeout travel: deeper and deeper: calcul mental
    c-puzzle: évaluer des expressions
      - priorités opératoires
      - nombres relatifs
      - expressions littérales
    s-puzzle: ???
    P-puzzle: géométrie
    greenMouse
    Indiana's path
    bulletMouse
    bulletGolf

  wow-effects:
    a small part of a big piece is visible on the side of the screen
    piece already in slot but very very small
    slot hidden in piece

  big-picture:
    build numbers with only 1 to start with
    xylo recomposition (== (re)compose challenge input)
    zPuzzle zTraveler recomposition: to complete z-Puzzle, you have to 'activate'/'enable' all z-Travelers
      like the laser beams opening mountain top in The Witness
      there will be a "moutain top" sensation when all z-travelers recompose the mountain top challenge
    "complete by repairing":
      "pebbles in the shoe":
        conductive operator seems broken (reason is: super small operand is inside conductive area so that apparent binary operation is actually involving three operands)
          completing another challenge may give the location of this "~hidden" (pebble) operand
          player "repairs" the operator by moving the pebble out of conductive area
          This pebble could be of use somewhere else...

    familiarisation progressive avec les "objets concepts" (comme les symboles dans The Witness)

    unlocked challenges :
      diy: when puzzle is completed, it can set up a challenge
      dust off: when covering challenge is completed, it reveals the covered challenge
      multikey: when challenge is completed, the multikey that was used is unlocked and can be used elsewhere
    unlocked recomposition component:
      unlocked challenge piece:
        movable:
          standard piece
        unmovable:
          zTraveler (unmovable yet moving)
      R-Puzzle target may be a patchwork which turns into an operator when completed
    unlocked "skills":
      object wells:
        numbers
        operators (for example: a well that generates operator "+" puzzle pieces)
        geometric figures
      transformations:
        rotate
        machines:
          x10
          /10
          clone
        keyboard shortcuts: player gradually learns "new keyboard keys"
    unlocking always happens via the same artifact (see: xylo-unlock)
    unlocked areas:
      Alice system
      "horizontal" areas (à la The Witness)

    unlocked:indirect key:
      xylo-unlock: player successfully completes a greenMouse challenge, then a number is given to them and they have to type it via the xylophone to unlock next thing

    unlocked places:
      "open your mind" system
      canvas-container double object (an entire fresh canvas in your fridge or bedroom window)
        and portals to get back to "home canvas"
      "<n> <X> required" door locks
      once Z|S|C-puzzle is complete, it transforms into a doubleObject or a portal (castle door for example)
      password (or hint or directions) hidden behind puzzle (player has to dismantle it in order to see the message behind (==l'étoile des douze coups de midi))

    geometrical puzzles inside number shapes
      ((construit un nombre 1 qui ait pour aire 1
      ((construit un nombre 2 qui ait pour aire 2

    co-challenges: challenges can only be solved by progressing alternatively in one and the other
      example: solving greenMouse challenge make sparkle appear(which indicates z-puzzle piece location) and putting piece in slot makes sparkle appear which indicates greenMouse challenge is renewed

      digitWell: a many-digit number can be transformed into nb_digits wells, each yielding the corresponding digit (exemple: de 7891, on pourra extraire [7] [8] [9] et [1])
        on peut créer des co-challenges qui font évoluer le "nombre puits" au fur et à mesure (c'est prometteur mais il va falloir se prendre la tête pour faire un "level design" qui soit goûtu)

  tool ideas so far:
    xylo_show
    ESB scroller with 'scroll increment = f(scale)'
    pythagore_show (avec des carrés)
    photograph: take picture of current rect and create puzzle piece or icImage from it
    clone tool
    repaint tool: input slot, color parameter --> output slot
    common multiples grid
    le répartiteur: user creates a partition of a 100% box and can then drag any collection or number that will be divided into different output boxes with the right proportions
    area of numbers (2 has area 2, 123 has area 123 (1 has area 100, 2 has area 20 and 3 has area 3))
    protractor
    redMouse calculator (a redMouse doesn't die when released anywhere)
    solution writer assistant: as in Scratch: writing a solution would involve selecting blocks and putting them together
    clock_simplifier: perform simplification of mathematical expression at each clock tick
    The Mirror: what happens on bottom screen happens in mirror on top screen, _in a different _representation system_ _
      example:
        bottom screen: expressions       //     top screen: bag of numbers
        bottom screen: fractions         //     top screen: colored rectangles ('fractions for kids')
    Frac_add

  edu:
    slow building of year's z-puzzle by getting puzzle piece for each part of year's course when done (slow compositing)
    difficulty gradient:
      Say we want children to try a particular challenge type 20 times, first instance will be easy, then there will be a gradient of easy/medium/hard till the last instance which will be hard
    prevent bruteforcing by increasing nb_challenges_todo when bruteforcing is detected


]*

* xylophone for hours/minutes/seconds:

* pythagore_show: show squares (use same "reference square" in all three squares)

* essayer un xylophone compact avec les chiffres en mode photo de classe (est-ce que ça va pas faire un peu abrupte ?)

* once again: make it sexy
    0 papier peint "pattern" sur les xylophoneTowers

** showing before dying : avoir un z-puzzle basique à montrer à Paul

** Hue(==anti-sparkle): object opacity getting stronger as we get closer
    trois parfums:
      glassPlaque: only scale matters, (x,y) doesn't matter
      Clameur: obj is "localized" around a particular(x,y,scale) ("nearer, we hear better")
      spook: it disappears when getting too close

** S-Puzzle: slot-only puzzle : user has to enter slot and complete task for slot to fill with completed state (typically, the slot becomes colorful, hence the name)
** C-puzzle: colorize puzzle: user has color palette and must color areas corresponding to number

27 décembre 2020:
** user created sparkles : SparkleMarker:
    - pour se repérer: "true"SparkleMarker
    - pour effectuer des mesures : l'outil mesure peut prendre en entrée des SparkleMarkers, ou créer des sparkleMarker

** edu: choix pédagogique pour les représentations: moi j'aime mon xylophone, mais d'autres préfèreront une autre représentation, libre à eux d'utiliser la représentation qui leur convient, étant donné qu'enseigner, c'est enseigner ce que l'on est.

* save game state: some objects don't need to be saved (since they are generated automatically when page loads)

*PAUL:
  un repère orthonormé pour chaque xyloZone, pourquoi pas, un seul axe en fait, l'axe important, l'axe des ordonnées avec 1 2 3 4 5 6 7 8 9
  z-puzzle: slot avec 1.47 x 10^-3 qui fait écho au papier peint des xyloTowers

* machine à x10, machine à /10 : un slot d'entrée et un slot de sortie

** écrire "taille normale: ..." et surtout _"agrandissement: ..."_ sur une zPièce pour bien montrer que ce n'est pas la taille normale de la pièce

* tous les élèves évoluant sur le même canvas: quel intérêt ? (à part du showoff client-serveur)
    compétition:
      -dynamic leaderboard (ce serait une sorte de course, on pourrait repasser 1er, ou être maintenant 3ème etc.)
    coopération:
      se partager les tâches: ~escape game (il faudrait que les élèves commencent à des endroits différents)

* photograph: take picture of current rect and create puzzle piece or icImage from it: this way user can create keyFrames to create a comic book page

* geometric puzzle: overlapping slots: pieceX has pointA, pointB, pointC labels, pieceY has pointB and pointC and pointD labels, so we know where to put it wrt pieceX
**  P-puzzle (==slotless puzzle, ==le bon vieux puzzle des familles): puzzle can only be completed by assembling adjacent pieces

*res: _DK Wonders of Nature_,  incredible source of beautiful natural objects

28 décembre 2020:
  NUIT HORRIBLE MAIS PROLIFIQUE
* create portal KeyP: select from, select to
* create canvas: a portal to another canvas
*   canvas link : move from any canvas to any canvas, example: triangle A <-> B <-> C et C <-> A
      "KeyBack": return to previous (/parent) canvas
* ? web page as fabric object ? (this way I could include a Scratch page for example), ou bien la page de l'ENT

* point and click a la Myst, from room to room: fake immersion with portal buttons (and back button) (actually, all frames are next to each other, but pov creates the immersion effect)

** Bubble sparkle (comme dans les bandes dessinées): "Hey!"
** PNJ: quêtes annexes:
    - remettre les poules dans l'enclos
    - Link(Zelda): je voudrais une épée plus grande ! "Merci, maintenant c'est moi qui ai la plus grosse."
** enemies: some enemies are wandering around and when they lock on player, scroll & move are locked until enemy is destroyed
*( Level and Xp ?

* Z-Memory: like a classic memory game but slots are big and small

* mirrored xylophone (left) + ESB tower (center) + tower fall on graduations(right)
* piano with sound for each piano key (base 8, do ré mi fa sol la si)
* challenge is there but unreadable:
    stains (need to unlock wiper)
    blur   (need to unlock glasses)

** PreviewSparkle: quand on veut embrasser d'un coup d'oeil des objets de taille très différentes

* 728,4�32�001: show empty space or unknown character for missing xylozone digit
* xkcd: put some mini characters here and there a la xkcd
* Z-Puzzle::Tangram
* NightVision/ThermalVision

* Docteur Maboule
* Z-Labyrinth => object is locked inside walls but can shrink/grow with Z-scroll to get to destination or to get out (the existence of a getout narrow passage is only blatant when zoomed):
    fabriquer un système de collision
    (fabriquer un système d'interrupteur et de portes qui s'ouvrent et se ferment (casse-tête)

* canvas world::scale world: a world with gravity which weighs a collection of objects
    target weight: ...
* Z-spook::telephone numpad (layerN is only visible for f(n)<scale<f(n+1) and opacity==1.0 for layerN.homeScale)
* Spook Challenge::constellation: challenge only appears around a certain (x,y,scale)
* (<X>-)puzzle: color on color: hide piece on top of similar object texture (like the chameleon) ("la pièce marron est cachée dans le pelage du chien")
* (color composer: compose color using R,G,B values ( (or using hexcode...))
* Angle-puzzle:telescope: user can set a precise angle (using arbitrary precision graduations) for the telescope and when the angle is the good one, a star can be fetched inside telescope's objective
* L-puzzle: link puzzle: relier les points
* Puzzles géométriques faisables/impossibles:
    faisables: avec un angle droit:
      Pythagore
      Triangle inscrit dans un cercle
    impossibles: avec un angle presque presque droit (il faut zoomer fort pour trouver pourquoi ça ne snappe pas)
      Pythagore
      Triangle inscrit dans un cercle
      ...

**Z-scroll: trace fading animation (so that user sees than the piece is growing or shrinking (or keeping its size (for non z-scrollable objects)))
* puzzle autour des fractions: Tablette de chocolat: 6 rangés de 4 carreaux (Mathieu)
* Localization challenge: select point with coordinates (x,y) or (r, theta)
    many points are put near the target point to show user that they sometimes need precision and zoom in to discriminate

* Le coin informatique:
    Algo-puzzle: user has to select to right operators to get to result
        operators:
          assignation == mutator == set
          evaluation  == accessor = get

* Make it visible:
  Addition: fusion de parcs à moutons
  Multiplication: des moutons avec des moutons à l'intérieur
    ou alors on peut dire que chaque mouton du parc A rêve du parc à moutons B, ce qui fait n x m moutons de rêvés en tout.

* Calculator: missing keys: reassemble it before being able to use it

29 décembre 2020:
  29, c'est déjà un peu plus beau de 28

* code chiffre/son:
    challenge: "712", il faut placer dans slot(=="sertir") un katana

* comptage analogique:
    challenge: "150317": il faut sertir une pièce qui possède 150317 particules dessus
    challenge  "3 jaune/4 rouge": il faut sertir une pièce avec 3 points jaunes et 4 carrés rouges
    challenge: "17": il y a écrit 17 en pointillisme mais il manque deux particules pour faire 17 (le slot est visible, mais subtilement)
    challenge "incomplete rippa: 4/?": double challenge: il y a un outerslot et un inner slot

** Revenir sur les puzzles:
    - soit parce qu'il y a encore des étoiles à récupérer
        Mécanique: correct is good, fast is better
          exemple: le joueur gagne une deuxième étoile en refaisant le z-puzzle en moins de 40 secondes
            cela permet de créer des joueurs qui maîtrisent bien le z-scroll, qui l'ont intégré
    - soit parce qu'on a trouvé la pièce pour l'indice correspondant (MonoZSlotChallenge) (au moment où on a trouvé la pièce, on sait exactement(et c'est vrai) où elle va)
    - soit parce que ça y est on a compris ce qu'il fallait faire (jusque là une(/les) pièce(s) qu'on pensait correspondre à l'indice ne donne(nt) rien: on s'est pris des râteaux)
        exemple typique: le comptage analogique: indice: "150317", pièce à trouver: une pièce qui contient 150317 particules
          le joueur a testé de mettre des objets qu'il pense faire 150317 mètres, de mettre une expression littérale dont le résultat donne peut-être 150317, mais sans succès
          on peut donner un indice au joueur en écrivant 150317 en pointillisme mais le mieux serait de faire ça plus tard

   remarque: les différentes écritures des nombres sont une mine d'or pour créer des challenges

*[
Mécaniques de déroulement: {

  mécaniques:
  couple slot/pièce (SPCouple): une fois que la bonne pièce est snappé dans le slot, le slot s'entoure de vert pour indiquer que c'est bon
  duo indice et SPCouple (MonoZSlotChallenge)
    -l'indice est à côté du SPCouple: classic (outer hint)
    -le SPCouple est dans l'indice:           (container hint)
    -l'indice est écrit dans le slot:         (contained hint)
    -l'indice est écrit dans réparti dans le slot et dans la pièce: (complex contained hint)
  collection de MonoZSlotChallenges avec une logique propre: ZPuzzle
  containerSlot: un slot pour plusieurs pièces ("enclos à poules")
  "greenMouse" piece / vials: "trempez-la dans l'huile, trempez-la dans l'eau, ça fera un escargot tout chaud" (hold click and move around while held: piece mutates while held)
    this will allow user to keep focus, focus being almost captured by the holding down mouse button
    user won't have the possibility to insert a "how about sending a text message to Y ?"-step during the transformation sequence, because _mouse button is held down_.
  fragilePiece(=="fragile greenMouse piece"): => F-Puzzle
    1.user clicks on piece well
    2._while held_, piece can be mutated via mutationAreas (+1, /10, change color, etc.)  (pièces forgées au fil des "trempages")
    3.when piece is dropped:
      if piece is above a slot and corresponds to the slot criteria: piece is kept alive in the slot (slot is filled)
      in any other conditions: piece dies
  fragilePieceTemporarySlot: un avre de paix pour la fragile piece (qui doit peut-être être encore retravaillée), en attendant de rejoindre son slot de destination
  challenge resets when player has made too many attempts (prevent bruteforcing)
  FiniteWell: well will only yield n clones (no more)

  déroulement:
    it would be nice if every new mathematical topic could be introduced by a new puzzle type (this way the user is 'delighted', and could memorize the mathematical topic by remembering the puzzle type)
      en suivant cette logique: faire un challenge mélangeant topicA et topicB serait créer un challenge avec un puzzle mélange de topicA.puzzle et topicB.puzzle

  mutations:
    challenge complété devient:
      slot
      pièce
      challenge
    mutation complexe:
      "step challenge": collection de SPCouples complétés devient une pièce et le challenge "mère" mute également

  wandering around:
    montrer où sont les challenges: NAVI(Zelda) (c'est un objet complexe fabriqué à partir de Sparkle)

  déblocage:
    request:
      from player: player presses "give hint" button
      from game: le jeu demande qu'on donne un indice au joueur
        -à partir d'un certain temps
        -quand le jeu détecte que le joueur commence à être à la traîne par rapport au "peloton"
    les indices en eux-même:
      transformer un indice pour le rendre plus explicite (exemple: pointillisme pour le comptage analogique)
      montrer c'est où:
        sparkle
        HUD arrows
        les cailloux du petit poucet
      montrer un exemple de comment faut faire:
        solution "sèche"
        animation


  revisite:
    Z-puzzle disséminé
    do it faster now / do it real fast now
    color the world: colorier tous les 123 du jeu en rouge,vert,bleu débloque des étoiles (ou une seule étoile si on veut faire un challenge "road to 100% completion")
    the top-down edu principle:
      1. nommer l'objet
      2. rentrer dedans pour étudier ses propriétés

  challenges:
    autour du chiffrement:
      codage
      décodage
    induction:
      objets répétés et emplacement vide: il faut mettre un exemplaire de l'objet répété dans l'emplacement vide
      suites logiques:
        remplir l'emplacement du terme <k>
        remplir l'emplacement du terme général
        suites logiques avec figures géométriques
      fonctions:
        expression
        graphique

  décoration:
    écrire des noms de mathématiciens autour des challenges (+ mettre la photo ?)
      exemples: Sloane pour les suites numériques
                Pascal pour le triangle de Pascal
}
*]

((je le mets histoire de dire, mais je mets pas d'étoile, et j'espère qu'on le mettra pas en place: put the right price on object (on dirait que la raison de pourquoi on l'a pas mis, c'est parce que ce n'est pas stable dans le temps, et on passerait vite à autre chose :))

**philosophie de la montagne(mathématique (ou tout autre discipline)):
    1.reconnaître qu'elle est là, c'est-à-dire la rendre réelle : arrêter de passer au travers comme si elle n'était pas là. D'une certaine manière, la respecter.
    2.Plus on la gravit, plus on peut redescendre en glissant (et prendre de plaisir ce faisant), on peut aussi maintenant faire des figures au dessus des endroits où l'on avait précédemment peiné avec les cordes et piolet et crampons. Une fois qu'on a déjà été une fois à l'altitude h, on peut prendre l'hélicoptère pour y revenir.
    3.une fois qu'on est à l'aise avec un secteur, on peut aider les petits à monter, mais bien sûr, on ne peut pas leur faire prendre l'hélicoptère, sinon pour leur montrer ce qui les attend. (est-ce que ce serait pas quand même du gros spoil bien sale ?)
    4.on peut toujours trouver du nouveau, même dans les secteurs les plus arpentés. ou une couche de neige réconfortante.


** pour les fractions: on pourra diviser par 1000: un rectangle devient 1000 petits rectangles
    combien de 'particules' le système peut-il supporter avant de crasher ?

** edu::pour les 'petits': unités, dixaines, centaines:
    demander à l'élève de construire 2,3,4,5,6,7,8,9,10
    demander à l'élève de construire 20,30,40,50,60,70,80,90,100
    demander à l'élève de construire 200,300,400,500,600,700,800,900,1000
**    bien afficher le fait que 200 contient des conteneurs qui contiennent des unités
**    c'est rébarbatif mais une fois qu'ille l'a fait, normalement, ille commence à avoir une idée du principe des décimaux, et ensuite ille peut passer au xylophone (et placer les nombres qu'ille a construit dans le xylophone)


* snapping: ? écouter la vitesse de la pièce ?

representation system is nice:
  this way the slot could mutate a piece in a blink of a eye:
    0 repaint a piece
    0 change its background texture pattern
    0 change its size
    0 rotate the piece 90° clockwise
    0 its nature
    0 its behavior (activate or deactivate eventListener code)

  0 more complex: change underlying fObj while held: fImage becomes fGroup for example

** relative number piece creation: F-puzzle
    on a un (ou plusieurs) nombre(s) de départ
    on a quelques opérateurs, _mais pas tous_
    et on doit remplir les slots avec des nombres forgés au fil des "trempages"
    exemple: si on a 4 au départ, et que l'on veut fabriquer -10, on trempe la pièce dans "+1" puis dans "x(-2)"
** trempage::équation:    même chose mais on part d'une équation
** trempage::inégalité:   même chose mais on part d'une inégalité
** trempage::encadrement: même chose mais on part d'un encadrement

**When you feel the concrete at the tip of your fingers, when you smell it, when you press your face over rough surface, you might have nice, _sharp_, "concrete-ideas". Otherwise, you might have "far perception-ideas" (which can be nice though, but are too often blurry on closer examination).
    on pourrait même se demander: qu'est-ce qu'on apprécie dans une incarnation ? l'idée qu'elle porte, avant tout ? ou plus simplement, son existence et par conséquent, son interaction avec nous ? (ENCORE UNE FOIS TU VAS TROP LOIN, CHERCHE PAS TROP A FAIRE LE MALIN, RESTE DANS LE BETON MON VIEUX. RAMENE TA FRAISE, JE VAIS TE FAIRE INTERAGIR AVEC UN SAC DE CIMENT. TU VERRAS SI LE POIDS DU SAC EST AVANT TOUT UNE IDEE.)
    Les concrete-ideas, elle se construisent progressivement, avec du concrete. Parfois ça se casse la gueule alors faut reprendre. Dans tous les cas, il faut avoir les mains dedans.
*   Ce qui fait peur, c'est quand on montre des bricolages à des gens qui sont pas du métier. (Toutes ces images complètement trafiquées...)       La réalité, c'est un nez qui coule, c'est un gamin qui pleure.

encore et encore et encore et encore des idées: prout
  est-ce qu'a un moment donné faut dire "stop, tant pis, allez vous faire voir dans un autre cerveau, je vous laisse passer, je vous retiens pas, la sortie c'est par là" ?
    onNewIdea((idea) => {
      //ignore
    })
  tout le temps parler, tout le temps parler, tout le temps parler: prout
  et si on dansait ? et si on écoutait l'Autre ?

* snapping: show that object will be snapped on release (==on drop) (so that user, being informed, chooses to drop it)
* snapping: what would be nice would be to use the norm of a transformation matrix to settle threshold
* snapping: new events: onSnapped, onUnsnapped
* snapping: asymmetrical allowed input size range: 80% - 110% (pour privilégier la fabrication de pièces qui "rentrent")

* on pourrait aussi habituer les élèves, qui savent déjà faire la conversion secondes/minutes/heures/jours/années/siècles/..., à faire la conversion mot/ligne/page/chapitre/livre/armoire/bibliothèque/...

Comme mes élèves, "ils" n'ont rien demandé. Ils se fichent complètement de savoir si la grossesse a été difficile ou pas, de pourquoi j'ai pas avorté. Le rejeton est plutôt agréable ? Tant mieux. Mais personne ne lui a demandé de venir au monde. C'est très étrange, surtout quand on pense à l'attachement que l'on peut avoir pour sa voiture, ou sa planche de skate. C'est moins fun un magasin vide.

* Plus on connaît de représentations, plus on se rapproche du backingObj.

* pov: show active object
* pov: show last action location (object may be deselected but get me to where I was when I last moved it)

** easyFill: _while held_, near enough to slot, object triggers onSnap(or 'onNearSlot', 'onNearEnough'), which leaves piece on slot, mutates held object (for example it can be a bottle of liquid, whose liquid has partially been transfered to the piece occupying slot), so we can continue filling, all in the same drag sequence.
      easyFill could be a simple "leave clone of held object in slot" ('hit and run')
** easyPaint: simple easyFill with color pieces

** bouton réinitialiser semble indispensable pour les challenges avec des effets irréversibles

j'essaye de séparer ce qui relève du jeu et ce qui relève de l'éditeur:
**icObj.snapped et icObj.type = "snapSlot" et icObj.type = "snapGrid" (si l'utilisateur veut une configuration de snap qui lui plaît mieux, il la fabrique lui même avec des snapSlot)
**layoutBag: icObj.flowLayoutBag: icObjects dropped inside automatically arrange in a "top-left if able" manner
    et tous les autres layoutBags auquel on peut naturellement penser
**snapSlot et layoutBag permettent à l'utilisateur de fabriquer des templates de présentation (==des dispositions dont on peut changer les images, les textes, etc., et montrer à l'utilisateur des variations sur un même leitmotiv visuel)
**et du coup, on pourrait relier toutes les instances de dispositions entre elles de manière à pouvoir appliquer des modifs au template qui se répercuteraient sur toutes les instances.
**presentation options: show/hide slots, show/hide layoutBags (c'est moins cracra de faire une présentation quand ils sont cachés)

* res: _Help your kids with Math_ (goldmine)
** montrer un histogramme avec les nombres entiers pour pouvoir ensuite afficher les multiples et les multiples communs
    cela va demander une construction dynamique de l'histogramme
*[
   icObj.type = "dynamicObject"
   icObj.objectsInRect = (rect) => {
    return objects;
   }
*]

** multiplication posée: highlight factors when hovering partial product

** addition de fractions: trouver un dénominateur commun avec une molette en dessous de chaque rectangle (mais attention, il faut pas que les challenge ressemblent trop à un cours de maths)
**   machine à compter les petits carrés: la machine grogne quand il y a des carrés qui ne font pas la même taille dans son "enclos" d'input

** machine à mélanger, machine à démélanger (dilutions)

***SELF-CONTAINED EDITOR: when sending the file to personX, I send the object I want to send, and its editor so personX see the object and then edit it and send me back the new file, so I can see the updated object and edit it etc.
    this would require saving the file in .html, with an object part (json) and an editor part (html/js)
    https://stackoverflow.com/questions/30563157/edit-save-self-modifying-html-document-format-generated-html-javascript
    https://www.reddit.com/r/learnprogramming/comments/4hjz1z/how_can_javascript_in_html_self_modify_and/
    https://github.com/gildas-lormeau/SingleFileZ
    https://github.com/gildas-lormeau/SingleFile
*[
  the dream:
        page.html (zip format)    //facade pour Monsieur Toutlemonde
          lib/                    //intérieur propre pour l'initié
            machin.js
            truc.js
          index.html
          data.json
*]

30 décembre 2020:
  still ideas: à chaque fois je perds du temps à tout recopier, ma pauvre chérie. comment perdre une heure tous les matins.

** flow-machine: la machine déclenche automatiquement la fabrication quand elle a les ingrédients suffisants
**flow-machine::object _fountain_: fountain = well + surrounding pool: when an object leaves the pool, machine automatically creates a new instance so that pool always keeps the same number of elements

* machine:random number machine: cette machine renvoie un nombre au hasard
* machine:random sample machine: cette machine renvoie un clone d'un élément au hazard du pool en input
* machine:random order machine:  cette machine renvoie une liste ordonnée aléatoirement à partir d'un pool en input
* edu: il faut que les machines soit faciles à utiliser, et que les {drags and drop, snap, légère animation de fonctionnement} rendent la chose ludique (__"c'est simple en fait, regarde !"__)


* challenge::chronology (dynamicConstruct timeScale needed)
   example of objects to place: cadillacs and dinosaurs
* challenge::apple tree: the apple to get to is located on a certain branch of the tree. A code is written like 4568541. The idea is to remember the code and press start. Then the player controls an ant, at the foot of the tree, and at each 'crossroads', move to the right branch (first one is 4 for example, next 5 etc.).
* challenge::homothety: select center and ratio (c'est une machine au fonctionnement un peu différent des autres machines ("à slots"))
* challenge::factory: une succession de "flow-machines", bien connectées entre-elles, permet la fabrication d'un objet complexe
    exemple: l'usine à flocons: on part d'une forme simple et on arrive à des flocons (et même une succession random>homothety pour fabriquer des flocons de tailles différentes)
** challenge: find the operator (travailler l'induction):
      il y a une zone d'input, une zone "opérator" (slot dans lequel il faut mettre la bonne pièce), et une zone d'output
      user can try putting in _any input value_, and result automatically displays in output slot
      it's by compiling those (input,ouput) couples that user finally finds the (most probable) matching operator
      greenMouse and vials could be put close, so that input attempts can be done in one held mouse click

* challenge: add parentheses (en fait ça va être assez hardcore à mettre en place je pense)
* challenge: pixel draw puzzle piece (les amener à compter les carreaux)
    easy:   grid has only "unit scale" precision graduations
    medium: grid has "unit to milli" precision graduations
    hard:   grid has arbitrary precision graduations
* challenge: line draw puzzle piece (les amener à comprendre que 1.97 en abscisses, c'est pas 2)
    line end points always snap to grid
    easy:   grid has only "unit scale" precision graduations
    medium: grid has "unit to milli" precision graduations
    hard:   grid has arbitrary precision graduations

* bizarrerie : all same-mantissa xyloTowers leading to same world (portal (montre-t-on à l'utilisateur qu'il passe un portail ou laissons ça 'seamless' ?))

* "self-contained": append datetime to filename so that savedgames look like videogames saved games (you know, when you choose 'load game')
* "self-contained":editable ==> password?
    empêcher les modifications par les petits malins: checksum
      is checksum written in self possible ?
      checksum in editor.js
      checksums everywhere :)
*"self-contained":editable: tool to show edited parts
    pour que je puisse voir si un élève s'amuse à mettre des images de X dans le monde original (bah ouais, vu qu'elle peut être arbitrairement petite faut faire gaffe)

* 9-puzzle with labyrinths: there is a frame for the 9 puzzle precising where start and end are

* edu: amener les élèves à jouer au jeu tous les jours
    exemple de système: day streak star: pour récupérer l'étoile, il faut la recomposer. Chaque jour, la challenge completion donne une fraction d'étoile (un cinquième par exemple). Il faut donc réussir le challenge cinq jours de suite.
* edu: nb max allowed errors: pour éviter que les élèves brute-forcent les exercices. (peut-être qu'il faut les laisser brute-forcer certains exos, que cette répétition peut être utile pédagogiquement, mais certainement pas tous.)
    ou alors on peut dire:
      easy:   infinite nb of attempts
      medium: 3 errors allowed
      hard:   no error allowed
* edu: montre moi que tu as compris: 5 tentatives minium et un taux de réussite supérieur à 3/5, 4/5 ?
    de cette manière: on voit que l'élève a essayé et on voit qu'il a compris ou pas compris
    0 statistiques sur chaque challenge ?

* edu: challenge habillé VS challenge "nu" (==sans aucun texte) (si y'a trop de texte, on va se croire dans un bouquin de maths)
* edu: outil pour analyser la progression de chaque élève
* edu: timestamps for challenge completion to track cheaters and headless-followers
* edu: tolérance:
    geometry: snap when close enough to answer

* edu: mécanisme pour augmenter la difficulté: montrer moins de choses, laisser un peu de calcul mental se faire
        par exemple avec la machine à homothétie: ne pas montrer la figure image intermédiaire quand on bouge le centre de l'homothétie. Indiquer seulement quand c'est bon. (pareil il faudra un peu de snapping dans ce cas, de _tolérance_).

* fractal labyrinth: some sectors are smaller than others, etc.

* sectors : on peut organiser des secteurs autour d'une même thématique
** map: quick access to sectors

* z-puzzle: que l'on soit bien clair: slots could be "z-different" too (et c'est un peu le sel du truc (parce que sinon, une fois que les pièces sont ramenés au même z, ça devient un puzzle classique))

* essayer des xylophones avec rectangles superposés pour avoir une aire valide:
    xylozone:
    [1]
    [ 2 ]
    [   3   ]
    ...
    - le 1 est par dessus le 2, qui est par dessus le 3 etc.,
    - quand on sélectionne une xylotower, elle passe devant et on voit alors que le rectangle fait telle taille
    - la hauteur de tous les rectangles est la même: si la zone est 10^3 alors tous feront 10^3 de hauteur

    0 essayer avec un léger décalage entre les xyloTowers pour qu'on voit dès le départ qu'il y a des rectangles courts et des rectangles longs

* flemme : regarder notes>"notes_a_taper__30_12_2020"

* edu: fil rouge: walking cat: complète le challenge pour que le mur soit détruit et que le chat puisse continuer d'avancer, etc.

** représentation visuelle de la racine carrée:
      fractale de racines carrées en utilisant un triangle rectangle de cathètes 1 et a: l'aire du grand carré sera 1+a².
      même chose avec 2 et a
      (? et en utilisant 10^n et a ?    10^(n/2) et a ?

** transformer un rectangle en carré:
    encore une "fractale" à la shu
      algorithme: 0: prendre le plus carré possible dans le rectangle
                  1+:avec ce qui reste, prendre le plus grand carré possible et 2 rectangles qui vont bien

(( donner comme note à un élève 10^(-2), 10^(-5),... bravo, bel esprit

** greenMouse::GLU: a particular kind of mutation
      the number 7 could be represented by 7 squares glued together
      soaking this representation inside a +2 vial would result in 9 squares glued together

* relative number: [[sign] [absolute value]]

31 décembre 2020:
* multipiece/multislot: le pendant Z game des "unrasterized" groups
    quand on place une multipiece sur un multislot, des slot peuvent être correctement remplis et d'autres non, en gros, c'est pas encore tout à fait correct.
    ça va demander une sorte de tether, de cordée, entre les "atomes"
*   => edu: construire petit à petit une réponse:  l'élève construit sa réponse avec des "atomes" _dépendants_

**_dependance_ : disons que la multipiece contient une pièce "a", et une pièce "2a", alors modifier la valeur de l'un impacte la valeur de l'autre (et réciproquement (si la relation de dépendance est bidirectionnelle))
** dependance::unidirectionnelle, bidirectionnelle

* SlideAndSnapXyloTower: on peut slider verticalement vers la valeur que l'on souhaite et la xyloTower garde la même largueur, elle snappe vers la valeur la plus proche
    cela apprend aussi à l'utilisateur qu'il va pouvoir redimensionner des objets avec les contrôles sur le contour
* "click & snap" xylotower: quand on clique dans la xylozone, elle traduit le click en un snap vers le "taquet" le plus proche
* ClickAndSnapSliderXyloTower semble être encore plus intuitive (on peut "sortir de l'ornière zéro")

* FreeSlideMonochromeXyloTower: on peut slider verticalement vers la valeur que l'on souhaite (pas de snap)
** FreeSlideColoredScalesXyloTower: la tour montre les différents "étages" nécessaires pour aller à la hauteur demandée   (les tours peuvent être ou ne pas être de même largeur)
    L'effet de couleurs changeantes qui se produit quand on déplace le slider doit valoir le coup d'oeil
    On pourrait mettre un effet sonore aussi, ça serait peut être bizarre
    => Il faut un Z-behavior aux petits oignons pour éviter de décevoir l'utilisateur (le z-scroll ne doit pas induire un changement trop important de la "valeur" de la tour)

** greenMouse: slot has countDown (say "3,2,1,0") and then triggers
    - this allows "soak cancel" (actually I wouldn't want to soak it there)
** greenMouse: the longer you stay, the more you get:
    example: the slot is a [+1] slot, then for every second you stay on it, greenMouse gains +1 (if it was 4 it is now 5 etc.)

*snapping: l'important, c'est les valeurs: il faut trouver des valeurs qui soient "juste comme il faut"
*snapping:unsnapping must be "harder" (snapping and unsnapping are asymetrical)

*snapping: snap(): la pièce écoute la version snapped, unsnap(): la pièce écoute la version free

**~mise en abyme/psyOps: dans le canvas infini, montrer des maisons, des immeubles, et quand on zoome dans une fenêtre du bâtiment, on voit un élève en train de joueur au Z-game, et en fait, c'est nous qui jouons à sa place.
    L'idée c'est de faire croire aux élèves que tout le monde joue au jeu et donc que c'est pas un truc de ringard/loser/tête d'ampoule.

***could we actually combine z-scroll and 3d canvas ? (z-scroll would zoom in current z-layer, but keeping z the same)
      (this would open the door to total madness)

*snapping: snap to any canvas 'position' (pas besoin de snapSlot, ici le "snapper" c'est le canvas lui-même)

* le système de représentations pourrait être utilisé pour retrouver un coupable (ou du moins mieux visualiser les différents points de vue)

01 janvier 2021:
* challenge mecanism: 5 seconds to complete: after clicking on start, user has 5 seconds to complete challenge
    greenMouse allows quick mutation combos : c'est rapide de glisser la souris
*   on pourrait aussi imaginer des mappings locaux de touches de clavier (valables uniquement quand le challenge est actif, pour déclencher des mutations (sous le slot il y aura marqué la touche de clavier pour le déclencher))

* challenge: related objects: mutate objects so that a relation is verified
    examples:
      mutate objB so that its area is twice as big as objA's
      mutate objB so that AC is twice as big as AB

* challenge: shmup: shoot numbers: to destroy negative numbers, you have to shoot positive numbers so their sum equals number opposite

02 janvier 2021:
around puzzles:
* polygonal piece
* rounding corners (any angle): inner/outer: courbes de Bézier (pour ne pas se prendre la tête avec les tangences) ?
* any piece shape ==> masks

* puzzle snap types:
    -shape and content-seam (le truc classique sur un puzzle)
    -shape-seam (la pièce snappe même quand les contenus ne font pas la jonction)
    -content-seam (la pièce snappe quand les contenus font la jonction, même si un des pièces déborde sur l'autre) ==> this requires complex z-index mgmt

* create pieces:
*  - machine: piece mould: input: content container (content), operator: piece mould (shape), output: piece with shape and content
** - pokéball: (single-use portable machine) (masked snapshot), user can carry along a puzzle mould, which when placed over content (this could be many objects piled up), and activated, mutates into a puzzle piece with mould shape and captured content

**machine: portable machine, machine is carried along to input location instead of input being carried to machine location
**machine: single-use portable machine: machine can only be successfully actioned once

* wearing objects: objects wear out after a certain time, and then disappear
* edu: creation d'automatismes: [
    - timeout challenges
    - wearing objects
    - focus-enlivened wearing objects: what has not been appearing in screen rect for a long time begins wearing
]

*** Paul's idea: "companion app": une application couteau-suisse qui les suit tout au long de l'année et dont les programmes ont été construit par les élèves: ils se servent de ce qu'ils ont construit

** lien entre companion app et game app:
      - use companion in game (companion 'mascot' is visible in the game)
      - unlock companion skills in game (on est moins dans la construction mais plutôt dans l'acquisition)

* edu: docimologie:
    - noter la progression dans le jeu en fin de trimestre, coeff 2 par exemple
      - progression 'notée' vs progression facultative
    - si c'est le cas, il faut empêcher les élèves de tricher

* edu: un jeu qui suit le cours de l'année: à chaque chapitre, le prof donne le code pour débloquer le secteur associé au chapitre
    et il y a un secteur 'hors-piste' qui est toujours ouvert

** take photo and then look for piece content: photographs can now have very high resolution: piece content could be fetched from photograph
* edu:
    1. on marche et on prend des photos
    2. on cherche des objets particuliers dans les photos en zoomant
    3. on fabrique des pièces et on complète le puzzle

**StickSnap: the idea is to stick two pieces together
** L-stick snap: side-length snap: the idea is to stick two pieces together, using a flat side (a "gon"): snap will trigger only if sides length are rigorously equal
    edu: the idea is to make students understand that sometimes, things have to be precise
** P-stick snap: "perfect"(/"profile"/"protein") stick snap: when trying to stick pieces together, pieceA profile must be the anti(==complementary)-profile of pieceB
    same thing: the idea is for students to observe profiles by zooming in
**    edu: il y a un problème avec ce genre d'idée: _jusqu'où s'arrêter_: une fois qu'on a compris le principe, on peut se dire qu'il peut y avoir des "imperfections" cachées n'importe où ("paranoïa de la ligne jamais droite")

** pile up objects on snap slot:
    edu: the right order: poser 1,2,3,4,5,6,7,8,9 dans cet ordre sur le slot
** fifo/lifo: snapSlot could have fifo or lifo behavior

03 janvier 2021:

**meta-challenge: challenge list: challenge<N>.onCompleted(moveToChallenge<N+1>)
  edu: un meta-challenge "prérequis" avant de commencer une nouvelle étape

** greenMouse: activateOnTouch: onEnterActivationZone/onLeaveActivationZone (un peu comme un snapSlot mais ici c'est pas un snap c'est une juste une activation)
** greenMouse: fastGrow/mediumGrow/slowGrow (same effect but different strength)

** challenge: manually create clone: given a model, player has to recreate a clone of it next to it

* mettre des images de déchetteries: d'énormes piles de déchets

edu: miner des idées dans les bouquins de maths:
*edu: decimal dot-to-dot

** Dobble avec des représentations différentes d'un même représenté
  edu: avec les nombres: 1/2 est équivalent à 0.5 qui est équivalent à 5/10, etc.

** le livre dont vous êtes le héros: zoom-in to the branch you chose
** on peut fabriquer un poème fractal avec ce système

***infiniteCanvas exoObject: the idea is this: say we create an object in fabric(which is normally a representation space for icObjects) (typical example: a freeDrawing) and we don't want to know what it is explicitly(its properties, how it works, etc.), _as long as we can serialize it_ we can create an icExoObject which will then be reenacted when fabric.unserialize(icExoObject.payload)
    un peu comme une éponge sèche, que l'on mouille et que l'on fait redevenir une éponge tout à fait valable

**keyDownToggleX + mouseClick: select object
**keyDownToggleY + mouseClick: select object just below
**keyDownToggleZ + mouseClick: select object just above
**mouseDown/up: hold/release _(previously)selected_ object

**challenge: différentes représentations d'un nombre, un nombre au centre et les autres représentations autour avec des flèches et des slots

*puzzle pieces everywhere: puzzle pieces may have a distinctive frame, or symbol, so that we know it should go in a puzzle in sector X

Les grandes étapes de développement restantes: [
  Editeur:
    serialization
    freeDrawing (exoObject)
    Groups
    polyline
    svg

  Jeu:
    Xylophone with texts
    ESB tower
    ZPuzzle:
      basic zPuzzle
      indicator slot (slot borderColor is either green or red depending on .isValidPiece(piece))
    DoubleObjects
    Sparkles
    GreenMouse:
      basic GreenMouse
    Portals
    ...
]

05 janvier 2021:
* z-puzzle: piece original container image, exemple: (bulle de champagne(pièce) dans verre de champagne (container image))

06 janvier 2021:
* square graduation to ease "piece hunt" when trying to solve a z-puzzle
* z-scroll (minification): auto-attract to puzzle area

* "square caterpillar" growth animation on challenge completion ([1] piece was the "missing part")

07 janvier 2021:
** HP::HP fountain: to recover HP, player can solve repeatedly an "easy" challenge(each time with different "problem values") to get a small amount of HP back
  harder riddles may give a greater amount of HP back
** HP may determine how fast the player can zoomIn/zoomOut

*remark: fractal drawing seems very natural (as if we were predisposed to draw some (recursion is not brain-intensive, it is quite dumb actually))

*mouseDown z-scroll: follow cursor

https://cancerberosgx.github.io/demos/misc/fabricRectangleFreeDrawing.html?d=9

* shape recognition:
  https://stackoverflow.com/questions/10463158/fabric-js-implementing-shape-recognition-on-newly-created-paths
  this would require AI-trained library
    1. freeDraw a path
    2. shapeRecognitionLibrary.getShape(path)
    3. create fabricObject for recognized shape

**dehydration/rehydration of "non-passive" objects is to be done wisely (==reactive objects(like in a chemical reaction))  (for example: slots)
    couper les tentacules avant de congeler
    puis refaire des boutures de tentacules à la décongélation
  0 imagine if some "slow attraction" process was going on when saving: recover attraction process when loaded

**protoSlot: this objects waits for user to put piece in it
  a workflow:
    1. create obj
    2. create protoSlot
    3. drag obj in protoSlot => protoSlot mutates to slot
    4. select newly created slot
      5. (while slot is selected) keyP (for example) => slot creates piece
    6. piece can be moved around

**easy object: AmorousSquare ("pixel amoureux"): un pixel facile à vivre qui se vient se L-snapper à un autre AmorousSquare
    => on peut fabriquer facilement des polyominos
    => double L-snap, triple L-snap, quadruple L-snap: when piece L-snaps for different reasons at the same time
    AmorousSquare::padding: don't snap too close, leave a spacing between glued objects

**protoAmorousSlot: creates an AmourousSlot when an object is placed inside (amourousSlots can be useful when designing a puzzle)

* slot racing pour parler de l'abscisse curviligne

* find pieces to create triangle (segments [AB] [CD] [DE] etc.)

08 janvier 2021:
* l'unité de longueur d'un nombre c'est un nombre (le nombre 1)

* diamagnetic objects: cannot be snapped/attracted by snapslot (icObj.snappable == false)

* another slot/piece creation workflow: with a CreationManager
      1. create slot (it will be given id == 1 for example)   (creationManager.startSlotAndPiecesCreation(); creationManager.slot = slot;)
      2. create another object:
          if it's a piece                                     (creationManager.slot.allowed_pieces += piece;)
          if it's any other object:                           (creationManager.endSlotAndPiecesCreation(); (if slot has no associated piece: destroy slot))
      => this way we could associate "different pieces" (for example: [1],[2],[3]) to a same slot

* challenge creation: computed object's backing graph
    user creates slots (for example: "given", operators, "answer" or target)
    for each "computed" object, puzzle maker indicates via a graph how to compute value
    puzzle maker can then hide the backing graph so that player only sees challenge "facade" (on cache les tuyaux derrière un peu de placo)
* challenge creation: computed object's backing formula (way faster!)
    "= A1 + B2"

** match object's representations using freeDrawing: player links points using freeDrawing, then freeDrawing is replaced by "pretty line" when released
      there must be a freeDrawing zone (to avoid player doing crazy things)

**O-puzzle: Overlapping puzzle: slots overlap: some part of the piece is not useful, it must be overlapped by another piece for the whole to display something nice
    => this requires complex z-index mgmt
    => this requires "slot community" (first filled slot is "send to back", then next filled slot is put over etc.)
*   slot overlap has many different flavors: TL, TR, BL, BR, center, offsetXY
    difficulty::hard: slot can be filled multiple times
                      slot can be filled with pieces of different sizes
    example: with filling order
          ______________________
          | 2      |1          |
          |   6    |  5        |
          |        |           |
          ----------------------
          | 3      |  4        |
          |    9   |    7   8  |
          |________|___________|

edu: O-Puzzle "useless zones"(==zones that will be overlapped) could be used to carry texts in order to describe object parts
  edu: easy mode: add piece orderIndex in the useless zone
edu: O-Puzzle "useless zones" could be used to display what's behind facade
  example: anatomy

**edu: O-Puzzle: "put it in right order"    (un peu comme le jeu UNO, on empile quand on peut)
    examples:
      mathematical demonstration (in geometry for example)
*       we could use a slot for the main demonstration flow and satellite slots for the lemmas used in the main flow
      geometrical construction
*       edu: feedback: add tick when the right piece has been placed (like in a todo list)
      logical sequence: cover [A->B] with [B->C] etc.
        colors and numbers (un peu comme le jeu UNO mais en mode "dominos" (il faut utiliser tous les dominos))
        dobble (sets are related by one common element)
*   on est d'accord que le mieux c'est quand l'élève part de rien et doit tout fabriquer lui-même, ici c'est un peu de la réflexion discount
**  edu: add "unfitting" pieces(==dead-end pieces) (to prevent student from bruteforcing): there are many more pieces than actually needed
      some pieces may seem fitting at first glance but then appear to be dead-ends

*O-puzzle:easy creation workflow (for a single-slot O-puzzle):
  1. maker creates protoOPuzzleSlot
  2. maker puts _in the correct order_ the different pieces they want to use
  3. maker clicks on "Done"
  4. protoOPuzzleSlot automagically paints useless zones for each piece with garbage by comparing the different pieces
  5. maker can get the painted pieces from the filled protoOPuzzleSlot and put them wherever they want

*challenge: trouve l'intrus

*challenge: lis l'algorithme de déplacement et sélectionne le point d'arrivée, ensuite appuie sur "play"
*tool: le répartiteur: user creates a partition of a 100% box and can then drag any collection or number that will be divided into different output boxes with the right proportions

*<X>-puzzle::double puzzle: pieces are linked together so when solving puzzleA, it solves puzzleB  (first puzzle could be mathematical and the other puzzle could be an image)
      and only puzzleA pieces can be selected and moved

* coins: player earns coins
    easy exercises give fewer coins than hard exercises
    player can then buy:
      hints
      keys
    say the game is playable from kindergarten to high-school,
      in kindergarten,  player will earn 1 or 2 coins
      in comprehensive, player will earn 100-999 coins
      in highschool,    player will earn 1000-9999 coins per challenge
      (player would keep the coins they have earned the previous year, keep the places they discovered, keep the challenge they completed, and also those they have not completed yet, so they can always complete them later on)

* snap objects that don't have homeScale (example: lines) => "sizeless snap"
  => sizelessSnapSlot

* createLine: rep_proto ("proto representation")

( notre point de départ ça pourrait être un solide avec un volume, parce que c'est le seul objet mathématique "qui existe vraiment"

* AmorousSegment: once pointA is snapped, pointB can be moved around in the radius circle

* on pourrait refaire une interface plus rapide pour les chiffres dans "les chiffres et les lettres" basée sur green mouse
    (dans le fond, l'esprit de l'idée de départ de green mouse c'était très proche de ça)

* greenMouse: priorités opératoires:
    we don't care about the result value:
      - answer slot is filled with full expression
      - green mouse shows growing full expression
    we do care about the result value:
      alternate display: number result / full expression

    easy:
      - only result value
      - only full expression
    medium: alternate display: number result / full expression
    hard: answer and greenMouse have different representations (one is result value and one is full expression)
    harder: answer is full expression but player cannot mimic full expression with the available vial operators: player has to match two different, _yet equivalent_, full expressions

* greenMouse: function related vials:
    derivative
    primitive
    composition with another function

09 janvier 2021:
** challenge: "show me X", "show me the thing with property Y"
*edu: Langues: repère les fautes dans ce texte
*edu: Géographie: repère les pays/capitales sur cette carte
*edu: Maths: montre moi un exemplaire ayant tel type (montre moi un triangle, montre moi une équation, montre moi une inégalité, montre moi un théorème, etc.)
*edu: construction de preuve pas à pas :
  - l'élève clique sur ce qu'il estime être l'endroit concerné par la prochaine étape de la démonstration
  - l'élève a accès à une liste de théorèmes sur lesquels il peut cliquer
  exemple:
    1. l'élève sélectionne un triangle rectangle
    2. l'élève sélection le théorème de Pythagore
    3. l'identité de Pythagore associé au triangle selectionné apparaît (_en tant que nouvel objet_ dans le canvas)

** challenge: "show me X in field (normal/mini/micro field)"
      un peu comme pour les souris vertes, on demande à l'élève de répondre rapidement
      ici il faut cliquer sur l'objet associé à la question posée
      il peut y avoir plusieurs réponses valides possibles
      Le petit twist:
        - les objets "petits" (voire minuscules) vont être assez longs à atteindre.       Les objets petits sont les réponses  "évidentes".
        - les objets de taille normale vont être accessibles pratiquement instantanément. Les objets normaux sont les réponses "pas évidentes".
      Donc:
        easy:   player has enough time to pick a small object (the small, "obvious", object)
        normal: player may have enough time to pick a small object but it requires dexterity
        hard:   player does not have enough time to pick a small object, player has to think and select valid normal object
      exemple:
        La consigne c'est [1] (==sélectionne le nombre 1).
        Dans le champ de réponses possibles,
          il y aura un [1] tout petit,
          il y aura un [2 - 1] un peu plus gros.
          il y aura un [(5 - 1)/4] encore un peu plus gros.
          etc.
      optionnel:
        Avant que l'exercice ne commence (== avant que le timer se déclenche),
        l'élève peut se balader dans le champ de réponses pour se familiariser.

**wow-effect: present stuff and use game objects during presentations, since they are just right here
*edu: j'ai envie de sortir le glisse-nombre, je le sors, même pendant ma présentation de cours
      (j'en ai besoin là maintenant, eh bien, je ne change même pas de fenêtre, je ne perds pas de temps à aller le chercher dans mes dossiers, je l'ai là, je l'ai toujours eu là, sous la main, prêt)
      => besoin de plein de raccourcis clavier
*edu: j'ai envie de sortir un exercice/jeu, je le sors

**générateurs d'exercices: ne pas réinventer la roue (au moins au début)
    0 est-ce que pyromaths est open-source ?

*challenge: place le glisse nombre au bon endroit: "le xylophone est cassé: il donne des nombres sans mettre la virgule"
*challenge: place la virgule       au bon endroit
*challenge: réparation: aide nous à remettre au bon endroit la virgule sur le xylophone

(ni tout à fait vectoriel, ni tout à fait raster, un entre-deux

* slot "endoConfig" (if you get close enough, you will see the cogs and gears) ("horlogerie")

* opacity setting same as color => "KeyV"

* l'encre invisible ! write stuff with opacity 0.0
* opacity blend: add vs fusion

* 0 acheter le nom de domaine teachingbeforedying

* protoSparkle

10 janvier 2021:
* serialize useof interactive module: module will be loaded on deserialization
    example:
      modules: {
        xylophone: {
          type: "xylophone",
          exponent_min:
          exponent_max:
        },
      }

*sparkle emitter:
  phare
  feu de camp
  candle
  lightbulb
  luciole

* reversed Z-puzzle: remettre les objets à leur taille originale

11 janvier 2021:
*greenMouse: path graph: étant donné un nombre de départ et des opérateurs,
    - il y a des nombres faciles    à atteindre (==en peu      d'étapes)
    - il y a des nombres difficiles à atteindre (==en beaucoup d'étapes)
*(greenMouse: NIM game: à chaque fois que l'on utilise un opérateur, il disparaît, l'idée est de ne pas faire le dernier mouvement  (idée encore un peu floue)

0 fabriquer une présentation de cours avec infiniteCanvas

**machine: l'agrandisseur: (basé sur le théorème de Thalès)
    on a un angle donné, par exemple 35°
    il y a un slot dans lequel on met l'objet d'entrée
    on peut ensuite faire glisser l'objet pour l'agrandir/rétrécir à l'envi
    l'objet de départ est montré et le facteur d'agrandissement aussi

*( un pulse électrique dans le bouton de souris pour faire en sorte que l'utilisateur arrête de garder le bouton appuyé quand ce n'est plus nécessaire

* protoWell
* greenMouseWell/protoGreenMouseWell

* touchSlot: user-scripted touchSlot
* protoTouchSlot:
    - facade
    - transformation script

* scriptHolder (généralisation de touchSlot) et scriptHolder.triggeringEvent voire triggeringFunc (séquence complexe d'évènements)

* greenMouse: pour le fun: faire un exemple avec la souris verte, l'huile, l'eau, et l'escargot tout chaud
** greenMouse: pathHintTouchSlot: full: toucher cet objet donne un chemin à suivre pour arriver au résultat cible
** greenMouse: pathHintTouchSlot: next: toucher cet objet donne le prochain noeud  pour arriver au résultat cible

***dynamic object::network-fetched: "tout le web dans un seul canvas" / "infiniteBrowser"
    cela demande une autre façon de coder les sites web, mais si tout le monde s'y met, ça peut être sympa
0 add network-fetched image-of-the-day to infiniteCanvas

***Z-scroll railway(==z-railway): from beginning of course to end of course
    user can select the z-railway and then, when user would scroll, they would follow z-railway's path (le prof n'a qu'à rouler la souris pour dérouler son cours)

*pathSparkle: multiple phase-shifted similar sparkles (probably better with opacity != 1) (comme si on voyait d'en haut les balles d'un jongleur)

*touchSlot: explain mutation: [1][+2][=][3]    while greenMouse is "in" touchSlot, objects appear on the sides of touchSlot to explain mutation
                               ^  ^      ^
                               |  |      |______  mutated value  (== a preview of the greenMouse when it will leave touchSlot) (==rep_touched)
    original value    _________|  |
                                  |_______ touchSlot

    this is mainly dedicated to edu purposes
*edu: show steps around variable: accessor(get) == get value out of the box, compute expression == do stuff with value, mutator(set) == put new value in the box
    gros travail d'animation

*touch-based number shoot'em'up: player starts with 1 and tries to get the biggest value possible by touching powerups (x2, x(-4) (which may be a risky strategy), +10, etc.)
    we could imagine 'sector gates' that only numbers above(/below) threshold could get through

12 janvier 2021:
* greenMouse::competitive:
    beat(==finish before) computer
    beat other player

* greenMouse: conjugaison
* greenMouse: Pythagore
    il faut trouver un moyen _fluide_ de suivre le procédé qui amène à sqrt(a²+b²)

("Sans titre" aurait été tout à fait satisfaisant pour le PCI

*(
  a well is like a reverse snapSlot
		1. on hold, create new represented
		2. on release:
		 	if out of well's recapture area, disable recapture
			if inside well's recapture area, recapture object: destroy represented
  OR
  a well is a self-refilling initially-filled snapSlot (but this requires redefining the behavior of a greenMouse (greenMouse can continue living if it was never held))
    => composite object: snapSlot + sample#000
  OR
  a well is an object refusing to move (because snapped), cloning itself instead of moving, and a "blackhole" snapSlot (destroying whatever it snaps)
*)

** touchSlot: dual touch/multi touch: a dual transformation func is triggered only when two touchSlots are touched simultaneously

**"are these operators or numbers ?": a touchSlot, if prepared with "touchable = true", can then be touched, thus mutated (this way a -1 operator can become a -2 operator, when touching a x2 operator)
  edu: this way we can blur the boundaries between "operator -1" and "number -1"

**challenge: Indiana's path: to get to target slot, greenMouse has to cross a grid of touchSlots, so player has to find the right path (we can imagine complex looping paths)
* challenge(hardcore): Indiana's room: player has to fill 4 target slots. Once a target slot has been filled, player comes back from start and previously used touchSlots are neutralized (là on est dans le casse-tête)

*challenge:goulet: there are two "operation wards" and between the two, the only passage is a [x(-1)] operator: user has to anticipate before changing room
  targetSlot is only reachable from operationWard2

*edu: greenMouse operator spam:
  - spammer le +1 ne donne pas grand chose d'intéressant
  - spammer le x2    donne quelquechose d'intéressant (pour le cours sur les puissances)

*activationPool: touchSlot.canActivate is conditionned by activationPool.nbRemainingActivations (collective behavior)

*edu: easyStar/mediumStar/hardStar: check if student only has easyStars: it would be nice if student could, at least in one domain, get a hardStar
  (que l'élève ait une compétence avancée dans au moins un domaine)
  (pour qu'on puisse ensuite s'en servir comme d'un marche pied pour avancer dans les autres domaines)

*maker:easy: referringTo: comme pour la couleur, ou l'opacité, on aurait une zone un peu comme un select, qui indiquerait ce à quoi on se réfère en ce moment
  exemple: je veux créer un snapSlot qui snappe uniquement les icTexts, eh bien, si j'ai comme reférence "icText", alors quand je créerais mon snapSlot, il sera automatiquement configuré pour ne s'intéresser qu'aux icTexts

*greenMouse::litteral operators: [+x], [-y], [*z], [^k]
  easy:   autoReduce full expression
  medium: autoReduce current expression layer
  hard:   don't autoReduce

*greenMouse::fractions:
  easy:   autoSimplify full
  medium: autoSimplify current layer
  hard:   don't autoSimplify

*greenMouse: time extended/small heal: when greenMouse is soaked, it adds a bit of time/HP to the greenMouse
    we can represented the countDown by slowly removing HP from the greenMouse

*challenge: GTA: objectHolder is a car and player can accelerate/brake/turnleft/turnright
  c'est toujours la même soupe mais là on controle une petite voiture

*greenMouse: is a transient variable: say only greenMouse.value is transferred to target slot, then greenMouse is a transient variable (it does not outlive oneself)

* variableWell (==geminiWell): mutations are shared by all representations (there is only one object)
* challenge: 2 areas, 1 variable: each area is exclusive (one cannot go from one to the other), variable is present in each area and can be mutated in either

**greenMouse::vectors: vector greenMouse, vector operators, vector target
*   edu: show vector arrow (for 2D numerical vector)

*greenMouse::collection: collection greenMouse, collection operators (map, filter, reduce), collection or anyType target

* challenge: composite object

* a composite is not a group (a composite has only 1 level of nesting, a composite does not have intrinsic position, size or homeScale): compose() flattens all objects (though it does not break inner groups)
    0 moving one part:
      0 makes all parts move 					(== "fixing")
      0 does not make all parts move  (== "mobile")  (example: well's sample)
    (0 move individual part: rearrange composite

* selection transformations:
    - compose
    - wellify
    - greenMouseWellify

*composite object: protractor (rapporteur d'angle): les aiguilles sont les parties "mobile" et le centre  est "fixing"
  => mobile parts movement is constrained
*composite object: oriented-angle protractor
*composite object: editable segment: les deux points d'extremité  sont les parties "mobile" et le segment est "fixing"
*composite object: clock

***permanent challenge: clean the world: litter regularly spawns in the infiniteCanvas. Player would better put it it the bins, or else there will be litter everywhere.
      the more litter there is, the more litter there will spawn.
***permanent challenge: upkeep: everything slowly withers, if not "refreshed".

**composite object: "[+1] [-1]", when a [+1] touches a [-1], they cancel each other and object vanishes

*snapSlot::gravity-based: player can create satellites by giving the right release impulse

*challenge: "click on point with coordinates (< >;< >)", animation: an archer shoots an arrow to the point picked by user, if user point is close enough to target, then that's fine...

13 janvier 2021:
*greenMouse: parentheses
  plusieurs mises en oeuvre possibles:
  - two areas: switching area starts new parentheses expression
    - central parentheses operator: [()]
    - central parentheses related operators: [()+()][()-()][()x()][()/()][()^()]
    - central parentheses related operators: start new expression with initial value: [+0][-0][x1][/1][^1]
  - one area and parentheses operators on top, "standard" operators at bottom

*redMouse calculator: un outil pour calculer des nombres rapidement
  (a good parentheses ux is required)
*challenge: écris la rédaction correcte en assemblant les blocs (à la Scratch)
    some blocks would have slots to fill with redMouse calculator's output
    as in Scratch: slots/blocks should resize when inserting big piece (a long number piece for example)

*greenMouse::logical expressions (sûrement pas mal de choses à gratter de ce côté là)

*xylophone calculator(juste une autre proposition d'UI pour la calculatrice): user can pick number on xylophone

*edu: ce qui est bien avec l'idée initiale de greenMouse, c'est qu'on affiche jamais une expression incomplète à l'écran

*la désillusion: dans le fond, rien d'innovant: Scratch possède des snapSlots, Scratch possède des wells, Scratch montre des exemples de L-snapping, de composites, d'object bin,

*greenMouse: undo operator (merci Willy) (et redo aussi pourquoi pas)
*greenMouse:operator preview: show preview of operator's application
*greenMouse: guess the operator

14 janvier 2021:
**greenMouse: is equality
**greenMouse: is inequality

**greenMouse::equations: rejoue les étapes à l'envers pour éfeuiller l'expression

*greenMouse:complex operator: example: [x2+1]
**operator mutation: tu voulais [x20] ? eh bien, tu prends [x2] et tu lui fais toucher [x10]
**greenMouse:reset button (put operators back to their initial value)
*greenMouse: we may reset operators on greenMouse release (if operators mutate during the "greenMouse journey" (==greenMouse transformation process))

**opérateur de conversion: exemple: [croissant <-> argent]

*edu: greenMouse on Scratch pour faire comprendre le principe un peu plus en détail

**greenMouse: parentheses operator: une autre proposition: [)x(1] [)+(0]
*greenMouse::complex numbers [+i] [xe^(i theta)]

15 janvier 2021:
*greenMouse::eval operator:
  example: operator: [eval({x = 3; y = 5;})], so when [2y] will touch it will transforms into [10]
  this could produce partial evaluations

**greenMouse::strings: string variable, string operators, string target
    - capitalize
    - remove first/last letter
    - insert letter at index
    - concatenate
    - randomString with format

**greenMouse: number dump: the whole greenMouse area is actually a dumpingSlot, so when number is dropped, its value could be:
    - auto added
    - auto multiplied
    - etc.
    to the dumpingSlot current value

**greenMouse: target is ...<[ ]<...
    edu: -2 * 10^-3 <[    ]< -10^-3
**greenMouse: variable has to match target's condition
    - inequality
    - complex condition: {{number must be odd}    and     {over  9000}     and     {its last digit must be 6}}
    etc.

icObj.cType = "<>" may actually be replaced by:
  gmObj.icObj.type = "composite"
  gmObj.type = "<>"

((*
""système des boules noires et blanches choisies par le jury"":
    on peut faire un système de note probabiliste:
      chaque membre d'un jury(très nombreux) remplit un sac avec la note qu'il attribue au candidat
      le candidat tire une note au hasard dans le sac et c'est sa note définitive
))*

*edu: greenMouse: "last operation should be a multiplication" (pour forcer l'utilisation des fractions)
***greenMouse: "value path" conditions:
    "last operation should be a multiplication"
    "third operation must be a substraction"
    "reach target in max 5 operations"
    "reach target in exactly 5 operations"
    "reach target without exceeding 100 at any step"
    "reach target without getting 42 as a step result"
    => targetSlot checks value but may also check "value path" (==the value "fabrication process")

((le problème avec la forme: quelqu'un respecte la forme, mais c'est une belle coquille vide.

*edu: greenMouse: commencer léger
      child:   nb_operators: 1-2
      pupil:   nb_operators: 3-4
      student: nb_operators: any

**greenMouse: écrire une phrase sans fautes
  operators are renewed for next word
  il y en a avec des fautes et d'autres sans
  when touching a "mistake" operator: everything resets: back to the start

**greenMouse:show greenMouse path building:
    greenMouse: writing: montrer la phrase en train de se créer
    greenMouse: numbers: montrer l'expression en train de se créer

(""visionnement d’une vidéo montrant un épisode du jeu"": WOW
**redMouse:Mario et les champignons

*edu: show/hide value tag of redMouse

((est-ce qu'il est légitime de montrer des figures avec des longueurs de côté qui ne sont pas reflétées par le dessin ?

*webpage should be lightweight for "bad connection" users
*webpage shouldn't involve two much CPU/RAM usage for "bad computer" users

*greenMouse: build a tree: leafs and nodes
    1.it starts with a leaf ([1] for example)
*   2.then you select a node operator ([+] for example), you get [1]---[+]---[?]
    3.you have to fill empty leaf space with a leaf, you select a leaf operator ([2] for example), you get [1]---[+]---[2]
    4.then you select a node operator, etc.

*greenMouse: number textual form: [un]*[+2] va donner [trois]  (* == touches)
*greenMouse: observe the decimal system "in deeds" using operators: [+1] [+10] [+100] [+1000]

16 janvier 2021:
*greenMouse: target slot is riddled:
    exemple:   1234
            + [    ]
            ________
               7894

*union libre: composite([piece,slot])  (ça donne un petit côté gemini, "si tu me tues, l'autre mourra aussi")
*try composite([compositeA, compositeB]): regarder si on peut faire des trucs subtils avec isMobile (qui est en fait isMobileWrtMyComposite)

*Z-railway: from slot to piece
*Z-railway: dot wave: a wave from src to dst is formed by static dots getting bigger, getting smaller

*machine::clone:[inputSlot][temporaryWell]
*greenMouse: cloneMachinesEverywhere: well could be replaced by a cloneMachine to give the player the ability to choose the initial value
  edu: par exemple: l'élève peut prendre son numéro fétiche      pour faire le challenge (un petit côté "choose your character")
  edu: par exemple: l'élève peut prendre ses opérateurs préférés pour faire le challenge (un petit côté "choose your weapons")

*greenMouse: round()/trunc() operators

**multimouse(many mouses in classRoom) is compatible with greenMouse
**multimouse(many mouses in classRoom) is compatible with zPuzzle

*madness: 4 player split-screen greenMouse ((many mouses in classRoom))

**dev:MAKE IT F-ING SEXY (sinon personne va y jouer, ou alors 5 min et c'est tout)
    - rounded corners
    - animations (regarder ce que font les jeux genre Candy Crush etc.)

*challenge: contrôle qualité: le joueur doit dire si la pièce doit être mise au rebut ou pas en mesurant (on peut imaginer une machine qui produit des pièces)
    des longueurs
    des angles
    des couleurs
    etc.

*greenMouse: boiling operator: il faut attendre un peu de temps sur l'opérateur avant qu'il ne s'active (on s'écarte un peu de la "philosophie greenMouse")

*challenge: "dirty glasses"-puzzle: the "key" to solving puzzle is to use piece in HUD-layer, so the puzzle is completed when all others pieces have a correct relative position
**(*)greenMouse: invisibleMouse: at some point, greenMouse is invisible, so player has to run the operations mentally
    edu: we could replace the invisibleness by a question mark symbol: [?]

*challenge: Pythagore et Thalès: une petite cuisine de nombres: length tags are redMouse wells so player can use them directly to create expressions

*easy clone: keyDownTrigger("<Key>") + hold object (en gros: keyDown + mouseDown + move)

17 Janvier 2021:
*z-well:   grow number via z-scrolling
*timeWell: grow number via waiting

*ui:numbers::colors:
  -each "broad" operation (+/-==+) is given a color:
    example:
      +: yellow
      x: cyan
  -each operation neutral number is given a color: the color for neutral
    example: [+0] could be yellow with a neutral color border

*challenge: single-operator challenge: since there is only one operation involved, numbers and operators can be considered the same thing
  in this case:
    [+] operation: [1]*[-1] = [-1]*[1] = [0]
    [x] operation: [2]*[1/2]=[1/2]*[2] = [1]
  operation symbol (and color) could be the background pattern of the challenge area (==operator as wallpaper)

*challenge mutator::now it's black and white: player is driven to reading the symbol instead of reading the color

***icObj.type = "emitter":
  - the information propagation could extremely slowed to be visually represented using a growing circle
  - the information attenuation could be visually represented with a fading effect

  edu: this way: player can visualize the cause of:
    - "negative events":
      - challenge reset (for example: the countDownTrigger triggers the resetEmitter, whose wave resets challenge)
    - "positive events":
      - challenge completion (for example: the completionTrigger triggers the completionEmitter, whose wave opens the star box/gives a key/etc.)

**E-Puzzle: emitter-based puzzle (==information propagation puzzle)

*challenge twist: touching countdown with number n adds/substracts n seconds, and number is to cross countdown (center area is narrowed not to leave any other possibility)
  (un peu une idée farfelue, mais les joueurs attendent des mécaniques farfelues)

*dev: live-shared document would be nice for brainstorming and creating exercices

*greenMouse: A*cos(w*t+phi): [0,2Pi]
*drop system: because life is also luck: when completing a challege, there may be "dropped" objects. dropped objects could be:
    numbers
    letters
    operators
    images
    quotations
    etc.

(*en fait, on parle jamais de contexte, d'espace de noms, quand on fait des maths avec des lettres mais on devrait peut-être. Je pense à l'élève qui a utilisé x = 7 dans l'exo1 et qui voit maintenant que x=-12 dans l'exo2, et qui comprend pas pourquoi il a changé.

subtract vs substract: substract is now obsolete

*tex and svg: icObj.type = "svg": double click to edit: show texCode, on stopEditing: show svg
mathematical expression <--> tex --> svg

(*résoudre une équation du premier degré, c'est de l'effeuillage.
  edu: exemple: Je note sur une feuille un mot. Je mets un scotch noir dessus. Je plie la feuille. Je la mets dans une enveloppe.
                effeuillage: ouvrir l'enveloppe, déplier la feuille, enlever le scotch.

*infiniteCanvas: classroom representation: put photographs of students
  ==> easy mgmt: click on student's photo

18 janvier 2021:
*greenMouse: tool: build expression from greenMousePath
*greenMouse: tool: build program from greenMousePath ((tu peux recoder une sorte de Scratch si tu veux mais pas maintenant))

*greenMouse: snapSlot in TeX expression: du gros dev en perspective

19 janvier:
* tex --> math
  0 Uncaught TypeError: algebra.fromTex is not a function
  Le travail a probablement déjà était fait, il faut juste le retrouver

* subtle work to adjust expression container size in order:
    - to fully contain expression
    - for expression to be readable (== 'big enough')
    - never to surprise user (size changes must be visually 'acceptable')
  OR
  we can animate expression's size adjustment: it slowly moves to target 'nice' size
  OR
  "touchable part" keeps the same size and "display part" continues growing
  OR
  we create composite: [E][=][(1+5+y)x2]
    and touchable part is [E], while growing part is right-hand side

*greenMouse: polynomials: show function graph/function shape next to expression (this way we see the 'waving effect' (== more and more roots as degree increases))

* icObj.type = "computed" (== icObj.type = "view"), createIcComputed(icObj,transformationFunc)

***z-Scroll:: 'scale defying' object: zTraveler: comme un sparkle, mais il ne clignote pas
      zTraveler gets as close as possible to infiniteCanvas.scale
      zTraveler may move along a z-railway

      edu: at level1: we see all operators, at level2 we can focus on each
        when we zoom in on a particular operator, we see that it seems to shrink, moving to its homeZone
        the operator's homeZone hosts a more specific challenge
      edu: "c'est le même opérateur"

*greenMouse: show all identities along greenMousePath: 1 + 2 = 3 ; 3 x 2 = 6; 6 x (-1) = -6 ; ...

*greenMouse::mathematical statements: sujet verbe complément subordonnée et grand-mère sur la commode
(* mathematical verbs: =, !=,  <, <=>, =>,

*greenMouse: evaluate expression:
    1. put expression in protoWell: [2x] --> [[2x]]
    2. use clones to evaluate:
          [2x] * [eval({x = 2}]  --> [4]
          [2x] * [eval({x = 10}] --> [20]
    (3. destroy protoWell to get original expression back

(* multiplier _une équation_ par 2 , c'est un peu comme mettre une phrase au pluriel.

*greenMouse: priorités opératoires: effeuillage: à chaque étape, proproser comme opérateurs les opérateurs qui constituent le chemin standard
    exemple: on demande de récupérer _le_ 8 dans l'expression (8 + 7 x 6)/50 - 1,
             pour [(8 + 7 x 6)/50 - 1]
                proposer
                  [+1]
                  [x50]
                  [-(7x6)]
                  (pourquoi pas [/6])
             ensuite pour pour [(8 + 7 x 6)/50]
                proposer
                  [x50]
                  [-(7x6)]
                  (pourquoi pas [/50])

((quand la souris accouche d'une montagne

* edu: two almost identical wells:
    a well yielding "autoSimplify:on"  nodes
    a well yielding "autoSimplify:off" nodes
    so when the student follows a greenMousePath, they will either see the "growing" _result_ or the "growing" _expression_

** edu: expression simplifies:
    - every n steps
    - at random time
    - only after student has earned the simplify skill
    - when touching _a_ simplify operator
* il y a des simplify spéciaux, par exemple quand on veut transformer (-1)x(-1) en (-1)^2 pour montrer l'exposant de (-1)

*edu: écris deux expressions égales, différentes dans leur écriture

**sparkle firework: to celebrate a challenge completion

*events:
  - circle propagation ("radio propagation")
  - wire propagation (we see the event moving along a wire)

*keep it local: icScope.icObjects = {}, pour:
  - éviter de scanner le monde entier quand on est un trigger      d'un challenge
  - éviter de spammer le monde entier quand on est un eventEmitter d'un challenge
  => là, c'est la notion de $scope qui intervient (tout existe déjà)

**composite mimic: from real-life object to mathematical model
    example: moving clock hands is "reactively" mimic'd in triangle

20 janvier 2021:
*greenMouse::invisibleMouse: question mark changes color and font when touched (touch feedback)
  edu: when greenMouse value is something x 10^30 and touches [+10], the value doesn't seem to change and yet there must be a feedback that touch happened
    (j'ai jeté une goutte d'eau dans l'océan et personne n'a remarqué).

**step by step simplification after node.evaluate("x = 3")
  => 0 "atomicSimplify" operator
  edu: l'idée par exemple, c'est un peu comme une montagne:
    on part de x,                         (pied de la montagne)
    on complexifie pas à pas l'expression (on monte)
    on fait l'évaluation                  (sommet)
    on simplifie pas à pas l'expression   (on redescend)
    on a le résultat                      (pied de la montagne)

* add a pool next to icObserver to put triggers in (or composites with triggers)

* icObj="challenge"
* icObj="challenge_generator"

**switch expression representation:
    - reduced form
    - tree
        show tree depth to get an idea of the complexity of the expression
    - "historical", unreduced form

**(*)redMouse::graph editing:
    0. there exists an empty node [empty] which can be used as an initial node
    1. user creates an operatorNode  [empty]---[+]---[empty] by touching the [+] gmOperator
    2. -THIS IS THE INTERESTING PART-  user can fill the empty nodes by
      a. selecting the empty node with the mouse and dragging it (the whole graph moves but the rest is "numb")
      b. touching a gmOperator (be it a common operator or a "valueOperator" like [1] or [2] for example)
    this can be extended to "non-math" graphs
*   increase operator arity: say the operator [+] has been touched and we have [ ]---[+]---[ ] then if we touch [+] operator again _with the [+] node_, we get:
       |---[ ]
[ ]---[+]---[ ]
    or even simpler:         say the operator [+] has been touched and we have [ ]---[+]---[ ] then if we touch a valueOperator (for example [1]) _with the [+] node_, we get:
       |---[1]
[ ]---[+]---[ ]
*   build tree: say the operator [+] has been touched and we have [ ]---[+]---[ ] then if we touch [+] operator again _with the left node_, we get:
[ ]---[+]---[ ]
       |---[+]---[ ]
**  mathNode graph: show partial result next to each operatorNode

(* en fait, les opérateurs [+2] [x(-1)] etc., sont des opérateurs unaires, qui sont en fait des currying d'opérateurs binaires. Grâce à eux, on construit l'arbre de calcul de façon séquentielle, sans "revenir en arrière".

*rect fusion: we a rect touches another rect, they fusion so that the new rect area is the sum of the two rects' areas

*ux: easy graph creation: draw a line between two objects and it creates the graph composite with the two objects as node and a link between them
    - draw a line   between the two to created an unoriented graph
    - draw an arrow between the two to created an oriented graph
    - draw the reverse direction arrow over an existing link to mutate the link to a bidirectional link

* colored value/ colored operator: operator only operates on a node with the same color
    - color assignment operator (==color change operator)

*greenMouse: target format is unsimplified expression: player does not have enough time, or does not have the operators allowing them to perfectly reproduce the target expression, they have to decode target expression and produce an equivalent expression

21 janvier 2021:

*challenge:greenMouse with only one "valueOperator": "the 4 fours", "3 nines" (refaire les premiers nombres avec des expressions contenant toujours le même chiffre)
*greenMouse: "Démonstrations folles":
  statementNode: "Je fais du sport" ou "<X> fait du sport"
  property operator: "Si je fais du sport, je transpire."
  exemple:
    Si on trempe "<X> fait du sport" dans "Si je fais du sport, alors je transpire", on obtient "<X> transpire".

*challenge::"edu countdown": countdown has a pause button near it, but, if pressed, challenge reward can't be earned
  - this way player can train
  - this way player understands that "the true thing" does not allow pausing

***greenMouse::living greenMouse: greenMouse' value updates even when there no user action: examples: countdown-greenMouse, radioactive-greenMouse, etc.
    countdown-greenMouse:
      -standard: every second, greenMouse value is removed 1
      -exponential: every 3 seconds, greenMouse value is multiplied by 10
      -random mutation: every n seconds, greenMouse value is transformed via a random operation
    countup-greenMouse: every second, greenMouse value is added 1.
    radioactive-greenMouse: after a random duration, and based on a probability density, greenMouse is mutated
      tree-senescence: operatorNode greenMouse has branches that separate from main tree (after some time)
    edu: this would provoke player into keeping the situation under control, into containing the living 'dragon blob' mouse
    edu: il faut vraiment trouver un moyen de rendre les mutations de vie visuellement différentes des mutations d'opération, pour pas que les élèves pensent que les nombres s'amusent à changer comme ça leur chante

**challenge:greenMouse:"get more than N": greenMouse value must get over target value during given time (snapping at the end is not necessary)
    -variant: countup-greenMouse: greenMouse slowly counts up, but too slowly to get over target value in time, so this plusOneing value must be operated on

(*icObj apoptosis: say there is a network of very small touchslots which send a 'continue living' signal, then, when an object is smaller than those touchslots, it will die from not having been maintained

*greenMouse: countdown timer is number too: player can use it to complete a challenge
    edu: think "out the box"

*digitWell: turn each digit of a number into a well (exemple: de 7891, on pourra extraire [7] [8] [9] et [1])
*operator: extract digits:
    edu: a way to create a collection from a single element
*machine: digitsExtractor

22 janvier 2021:
((comment ils font pour congeler du vivant dans les entreprises du jeu vidéo ? Est-ce qu'il y a une good practice ?
**  => copy paste "living object" between two applications

((en fait, en informatique, on a longtemps travaillé avec des morceaux de bois sans vie, et maintenant on commence à jouer avec des poulpes, à les faire travailler à notre place
((I think it's important, at the time being, (and, at last, to understand the lisp spirit) to consider that user written code is as important as user written "content". Data is code is data, period.

composite only needs a handle when solely composed of mobile parts

**maker/consumer: teacher creates exercise and, on the fly, students can try to complete it
  => this would allow a lot of reactivity and a lot of ^flicage^ (éducamération)
  après, tant que le flicage reste éphémère: un flicage de session, juste pour la séance...

*challenge:code chiffre-son: trouve le bon mot


* everything already exists: https://toytheater.com/category/teacher-tools/virtual-manipulatives/
  tout le concept de greenMouse est déjà là: https://toytheater.com/fraction-strips/ (lolilol, gardons le sourire, chacun sa pierre)
  (ça serait bien pour l'image de la France d'avoir une plateforme française dans ce genre là

(* composite(composite1, composite2): une vision du management hierarchique (pouvoir sacré)
*	0 fun: allow chosen non-top-level objects to be part of composite: create "funny dependencies behavior" objects
  edu: par exemple: si on bouge un nombre alors tous ses multiples bougent avec lui
    mais ça veut dire que le handle du composite est l'objet lui-même (... vive la récursion)

*edu: un scroller horizontal basique qui contrôle
  - la "zPosition" d'un zTraveler pour que l'élève arrive à l'idée de fonction
  - la taille d'un carré ou d'un rectangle ou d'un triangle
  => on peut fabriquer des machines configurables avec la valeur du scroller horizontal comme deuxième variable d'entrée

**summonSlot:
    1. user writes the name of the thing they'd like to summon,
    2. then when activating slot (press E),
    3. the infiniteCanvas checks if there is a summonable object with this name, and summons it if something was found
    example:
      1. user creates summonSlot
      2. user writes "challenge.greenMouse.numberOne" in summonSlot
      3. user can summon challenge.greenMouse.numberOne when activating the slot
    the summoned object can be easily deleted via a delete button near the object

23 janvier 2021:

**maker: composite(composite1, composite2) allows 'easy' animations (== easy creation of keyFrames)
    this would be even nicer if composites are graphs (i.e. composites with links) and if nodes and links are images

**greenMouse::shortest-path: get to targetValue in less than <n> steps (exponential may play a key role)
    easy:    20 steps
    medium:  10 steps
    hard:    6 steps

*maker: z-Index: keyDownToggle:
            -show z-indexes
            -if something is selected: mouseScroll will control z-index
            -if nothing selected:      mouseScroll will 'pierce' (voire 'peerce')

*maker: align
  - horizontally / vertically / diagonally / anyAngley
  - top/center/bottom

24 janvier 2021:
*challenge:greenMouse VS zIndex: greenMouse value is greenMouse zIndex: greenMouse must go above[50], go below[-20] (un peu un parcours du combattant)

**touchSlot::magicBox: touch only triggers when target is completely hidden behind touch slot

*spawn sequence(==egg-laying):
  - keyDown: if you stay pressed, a spawn will occur every <intervalDuration>
  - engine-based: when engine is started, sequence spawn will occur (no other user input is needed)
  keyDownCharge: you have to stay pressed the whole time
    0 chargeIndicator

*greenMouse:little squares:
    - [x2] operator adds the same arrangement next to the initial arrangement
      example:
        [][]                 [][][][]
        []    * [x2] gives:  []  []
        []                   []  []
    - squarify operator:  create closest-to-square    arrangement of little squares
      example:
        [][]                       [][]
        []    * [squarify] gives:  [][]
        []
    - rectangle operator: create closest-to-rectangle arrangement of little squares

    -divide/fraction happens in two steps:
      - prepare for divide: user has to use operators to arrange the little squares for the division to be obvious
      - divide prepared arrangement: since the arrangement has been prepared, division is obvious (== not surprising)

*gmOperator mutation:
 	Plusieurs choix se présentent:
 	- valueOperator3(value) = valueOperator2(valueOperator1(value))         (standard composition)
  [x2] * [+10] = [x2+10]
 	- valueOperator3 = (operatorOperatorify(valueOperator2))(valueOperator1) = OperatorOperator2(valueOperator1) (there is no typo here, operatorOperator means an operator which applies to operators)
  [x2] * [+10] = [x12]

*challenge:number Mahjong: there is a big heap of tiles with expressions and player has to match equal expressions to remove the tiles and gain access to the back layer challenge
    variant: face-up match-2, match-3, etc.

*greenMouse::variants
  - operator cannot be selected twice in a row (player has to 'alternate')
  - operators fall from the sky ('operator rain')

0? .bind(this) when rehydrating (when enliving)
(*les 2 clés pour des maths massifiées: animation et interaction

25 janvier 2021:
**enlivenSlot: when a dehydrated icObj touches/is snapped into/..  the enlivenSlot, the icObj becomes hydrated
  => challengeX reward may be a dehydrated object, and challengeY activation condition may be the enliving of the dehydrated object (for example a dehydrated well)
*challenge activation: any icObj can be dehydrated, so can a challenge (c'est un peu comme une pièce avec toutes les lumières éteintes)

**greenMouse operators: [²], [√]

**machine: reciprocalOperatorify: reciprocalOperatorify([x3]) = [/3]
    edu: pour expliquer la résolution d'équations (l'effeuillage), on part du set d'opérateur qui a permis la création de l'expression donnée, puis on fabrique le set d'opérateurs réciproques pour effeuiller

*challenge:machine chain: given step values (initial, final, and intermediate), player must put operators in snapSlot to create valid chain

*edu: timeout and nb_max_attempts may be counter-productive because they prevent pupil from sandboxing (l'idée de départ c'était de faire en sorte que l'élève se trompe énormément, comme il n'a jamais pu le faire auparavant)
*edu: track when an operator is spammed by pupil, and then prevent it from being spammed (Thrasher's 'area destroyed')

*telomere: each time object is rehydrated, add one to telomere (bon ok, normalement les télomères ça raccourcit mais je fais ce que je veux)

*simplify +1-1 or -1+1 when in sequence

**edu: add slider below equation for student to try solving equation (on peut imaginer un code couleur bleu-->rouge pour faire comme le jeu du chaud-froid)

26 janvier 2021:
*machine-cooked problem statements: first we generate a random expression or equation, then the machine builds a story around it

**challenge:propriétés opératoires: présenter deux expressions, et l'élève doit dire si elles sont égales ou non. _Si, oui, elles sont bien égales, il doit montrer pourquoi_.
    L'élève doit retravailler les termes pour montrer que les deux expressions sont égales:
      - commutation (a x b x c = c x a x b) (l'élève doit remettre les termes dans l'ordre)
      - parenthèses ((2) + 3 = 2 + 3 )      (l'élève doit supprimer les parenthèses qui ne sont pas nécessaires)
    ce qui va peut-être être chaud à développer: si un nombre est à une des extrémités et qu'on le déplace (ou peut-être pas si on se déplace dans l'arbre)

(*est-ce qu'il y a des chercheurs (français) qui bossent là-dessus ? (ou peut-être sont-ils passés du côté obscur de la force...)
((*à partir du 21ème siècle, il y a deux types de profs: les profs qui font cours à n ~ 100 élèves et les profs qui font cours à n ~ 100 000+ élèves. comme un MEGAPHONE silencieux.

(*equation: left hand side and right hand side are gemini, what you do to one also happens to the other

*ce qui est bien avec le fait de devoir coder les parenthèses, c'est qu'on est obligé de les considérer au même titre que les autres objets constituant une expression. On redevient élève.

***challenge:expression simplification by "touching" operatorNode with the correct simplified value:
      example: an expression is on the canvas: [2 / x + 64 - 30], user can pick [34] (from somewhere) and make it touch the '-' so that expression now becomes [2 / x + 34]
***"  from somewhere" == from a smart object pool
        smart pool should also propose letters when working with litteral expression (symbolicOperators: [xa], [-b], [/c])
      edu:
        easy: simplification wildcard: [?*] (==universal simplifier)
          sometimes the wildcard will "not work" : this is when there is another operation to consider before

        easy:   target fully-simplified expression is displayed
        medium: challenge listens to expression and completes when expression is fully reduced
        hard:   user has to click on "I think expression is fully reduced." button, and challenge completes only if expression is fully reduced (if not, expression is destroyed and user gets back to the start)

        easy/medium: smart object pool has equations in it which show simplifications calculations
          example: expression to simplify: [Y - 22 x Z x 33]
            then in smart object pool, you have [22 x 33 = 726] and [726]
        hardcore: smart pool contains deceiving objects

*challenge:get x:
  easy: x + 9 = 12
  medium: x + 50 = 2x + 12
  hard: (x+3) / (x+2) = 4

  easy:        x has first    position in the expression
  normal/hard: x has a random position in the expression

((*Pourquoi pas les automatismes d'abord ? Dans le fond, quand j'ai appris à parler, il a pas fallu m'expliquer pourquoi c'était important avant que je m'y mettes.
    D'abord on apprend à danser, et après on comprend pourquoi c'était important.

**[xylozone(0-9)] * [x10] = [xylozone(0-90)], [xylozone(0-9000)] * [/10] = [xylozone(0-900)]: value changes and so does size

**tool: display next priority: example: (12 + 4) / (5 - 3) will highlight "/" sign
**tool: simplify what user has lasso-selected

(*c'est chaud faut simplifier de façon chirurgicale

0 simplify: step by step
  0 create equality chain: initial = <simplified_step1> = <simplified_step2> = ...
    0 one line
    0 multiple lines

(*est-ce qu'il existe un symbole pour "simplifier" ?
https://www.symbolab.com/solver/trigonometric-simplification-calculator/simplify%20%5Cleft(3x%20%2Bx%20%2B50%5Cright)
  1 simplify logo, small s and "spiral arrow" (merci Cammy)

27 janvier 2021:
*mathWorkout: train 15/30?/60? min/day
  il faut au moins que l'élève essaie/se trompe 20 fois par jour

*simplification order is not really 'natural', it's like painting stripes on a tree
    [1] [2]     [3] [4]
      [5]         [6]
			      [7]

**from machine to human: "Maintenant, demande à ton voisin de faire comme l'ordinateur: simplifier l'équation étape par étape. Ensuite, compare les deux résultats."
    edu: bah ouais, si c'est l'ordi qui fait tout le temps le boulot, ça devient complètement aliénant, complètement "dépossessivant".

*edu: é"Mais comment il a fait (pour fabriquer ça) ?" (une perspective pour les élèves: é"Plus tard ("quand je serai grand"), je comprendrai comment le prof a fait.")

*icObj.type = <as_X__Y>;   exemple: icObj.type = "as_text__mathNode";
    => icObj.parser  (== icObj.fromXtoY())

*icObj.type = "editableAsY__X": composite facade is X, composite editing medium is Y
* key<X>/doubleClick: Edit

https://textext.github.io/textext/
https://docs.mathquill.com/en/latest/

28 janvier 2021:
*modèle de financement à la JBFarkas: des collectionneurs peuvent acheter les challenges, qui restent gratuitement accessible à tous
  à côté du challenge, on peut appuyer sur un petit bouton d'information (i) qui nous montre qui est le propriétaire du challenge

*first demos: obfuscate html source code


29 janvier 2021:
	0 MathQuill + Visual Keyboard: pour rester dans le bain

  0 mathField.latex() --> icObj.parse(tex)
    0 don't parse "=" into ":="
*	  0 _upgrade_ to gmOperator when writing "x50"  / downgrade to mathNode when writing "50"
    0 x VS ×: it would be nice to write what user means when they type keyX

*"Nice barrier" : . . . . .
                  .       .
                  . . . . .

**edu: est-ce que j'écris [×10] ou [× 10] ?
    0 peut-être une façon de répondre à la question: faire du volume et regarder ce qui fonctionne le mieux pour les élèves

**challenge: probability: gotta catch'em all: fill target _slots_ with correct objects: probable outcome slots will be be filled easily. It will take time to fill improbable outcome slots.
    target objects may be:
      - a 1D object:
          dice roll, d6, d10, d20, etc.
          number in finite range
      - a 2D object:
          a colored number: number is in finite range + number color is in {blue, red, green, yellow} (with different probabilities)
    variant:
    fill outcome table with correct objects:
        probable outcome appears a lot of time in the outcome table, and these cells will be easily filled

**challenge: probability: history collector: explicit path on outcome ("those two stamps look the same but I was given this one by my great-grand-father")
            [  1  |  1  ]
            [_____|_____]
            [  1  |  8  ]
          when an outcome is given, its explicit path is written on it:
            exemple: if we get 1, because the top-right sector was selected, then the [1] we get is [1 (top right)]

  edu: il vaudrait mieux faire faire d'abord "history collector" puis "gotta catch'em all"


**tool: same denominator zone: arrange all fractions inside the zone so they have the same denominator


**PAUL: multiplication d'équation: il faudrait deux opérateurs rassemblés, et il faut toucher les deux pour que le touch se déclenche
  edu: une fois que les élèves sont habitués aux deux opérateurs, on peut leur faire utiliser le duo [ [x 1] | [x (3 / 3)] ] par exemple pour simplifier le membre de droite


*challenge: logique: opérateur qui transforme une égalité en vrai ou faux suivant si l'égalité est vraie ou fausse

30 janvier 2021:
  0 gmOperator: force simplify (si gmOperator.forceSimplify alors la simplification se produit même si les mathNode impliquées n'ont pas autoSimplify)

***challenge goldmine: probas et expériences aléatoires
    -sac
      contenu visible / non visible
      animation d'une sorte de main qui prend un élément au hasard
      remise obligatoire / remise possible / sans remise
    -probabilités conditionnelles (évenements dépendants / indépendants): on pioche dans un sac un objet et le deuxième sac de pioche dépend de l'object que l'on a pioché dans sac1

(*contenu mort vs contenu deshydraté: avant ce qu'il y avait dans les livres on considérait que c'était du contenu deshydraté, qu'on devait y ajouter notre part pour le rendre à nouveau vivant.
    mais maintenant, je ne sais pas si c'est par ce qu'on n'a plus de vie en nous ou que les livres sont mauvais, on considère que c'est du contenu mort. Comme un bout de bois. D'ailleurs c'est sûrement pour ça qu'on s'en sert pour caler les meubles.
    Les contenus deshydratés de maintenant, c'est les jeux vidéos. Peut-être qu'on est toujours vivant mais différemment. Et du coup c'est pour ça qu'on a du mal à réhydrater les livres.

* simplification: accolade de "soupèsement"

**icInfiniteChronoBar / icInfiniteProgressBar:
    - chronoBar grows a square at its end every 1 second (at some point, you have to zoomOut to read elapsed time)
    - progressBar shows students accomplishments. Same principle: it has no end
        variant: textual mathematical life steps infinite progress bar.   [j'ai appris à reconnaître les chiffres. j'ai appris à compter jusqu'à 3. j'ai appris à compter jusqu'à 10.     ...         j'ai appris à intégrer sur un contour     ...  j'ai découvert un nouvel objet mathématique.
**  edu: infiniteChronoBar est sympa aussi pour faire comprendre la notion de valeur approchée: vue de loin, la chronoBar a l'air de ne pas grandir, c'est parce qu'on la voit de manière approchée: on utilise une certaine puissance de 10 et la mantisse nous paraît rester la même.
      ce qui est bien c'est qu'on a un objet apparement à la fois un peu dynamique et à la fois un peu statique
*   edu: exponential chronoBar: chronoBar x2 every second

*une représentation de l'oubli: un demi-plan complètement noir avance tranquillement, toujours à la même vitesse, vers les x positifs

**0? rep_engined: ça ferait sens. rep_free c'est la représentation contrôlée par l'utilisateur. rep_engined c'est la représentation contrôlée par le moteur.

(*toujours la même rengaine: l'obstacle majeur: c'est la mise en prod. C'est le passage du prototype à "A table les enfants."

*["text"] * [x (22/7)] = ["texttexttextt"]avec le dernier t un peu coupé:
    text_out  = text_in * Math.floor(22/7)
    width_out = width_in * (22/7)

31 janvier 2021:
***yugioh-style number card game:   (SHU: i think this idea could be really powerful)
      - turn:
          draw
          play cards
      - field:
          monster == number
          magic   == operator
      - win when first to gather all monsters (monster zone are targetSlots) (~exodia)
      - can reuse built number as stem (? or as operand?)

     (- wildcards : [x ?*] [?* 4]

     ((- single-use / finite-use / infinite-use operators

**edu: session-cooked keyboard shortcuts:
    say I want, _in a particular 1-hour class_, to show students particular challenges
    I would use the following shortcuts:
      easy level:   "Key1"
      medium level: "Key2"
      hard level:   "Key3"
    And those keys would spawn a new challenge, _each time they are pressed_,
    this way, if students don't seem to understand well after one instance,
    I can always spawn _a new instance of the same difficulty_, until they understand

*edu: if != when, si != quand, condition != property (==consequence is true if condition is true) != event (==condition is true at this moment)
    les élèves peuvent fabriquer des propriétés à la pelle en combinant un bloc [when < >] avec une instruction [machin <-- truc]

*0 "embracing tree" / onion mathNode: sqrt((x - 94)/4)
    onionNode / layerNode
*   operator chain: add parentheses when operators have same priority, or else mathNode's structure is not explicit
    simplify top layer
**  en fait, on peut définir un layer comme un ensemble d'opérateurs de même priorité
*     mettre les layers en couleur
      un layer équivalent à [x 1] ou [+ 0] (== un layer équivalent à [id( )] peut être simplifié (== retiré de l'expression)
    une étape de simplification mathNode1:
      0. repérer l'opération de plus haut niveau
      1. créer l'opération inverse: {operator2, mathNodeTerminal2}
      2. appliquer l'opération inverse: l'arbre grandit: il devient operatorNode(operator2.symbol, operator2.funcName, [mathNode1, mathNodeTerminal2])
      3. réorganiser l'arbre pour faire apparaître l'opération identité composée d'un couple {opérateur, neutre pour l'opérateur}
      4. retirer la couche avec l'opération identité

      mais, c'est bizarre, après tout, l'opérateur est pas forcément binaire, ou peut-être que si ([A] ** [Anti(A)])

01 février 2021:
*cette chance de dévelopeur: ça fait sourire
  - y + 0 doit être simplifiée en utilisant [- 0]     ^^
  - \frac{\left(y\cdot 91\right)}{0}                  normal quoi, y'a rien de choquant...
    edu: ^^
  dev: la simplification du 'zéro tout seul' va être chiante

**[s x 60 s]: gmOperator + forceSimplify top layer
    => gmOperator has the same backgroundColor as standard simplification operators (for example: light green, ou gradient red-->green, black-->white)
**gmOperator decoratorTouchSlot "gmOpDec": when a
    via gmOperator composition: transformationFunc3(x) = transformationFunc2(transformationFunc1(x))
    decoration may be applied:
      - once
          cannot decorate with decoration1 what has just been decorated with decoration1
      - multiple times
          with an "identity decorator": t --> id(t), then could create chains dec1(id(dec1(id(dec1(t)))))

**(*)edu: "I think I got it." button: when student thinks he has understood something, when "something's just happened in their brain", they can press the button to indicate to the teacher that, well, something has happened in their brain (!)
        this would be a way to check if a challenge "is really worth it" (par rapport à l'"élève moyen")

02 février 2021:
*greenMouse: display part: in order to keep the touching part the same size, a _central display part_(== at the center of challenge's area) could be used to display green mouse's current state

**edu: the whole 'simple equation' workflow:
  1. create the 'simple equation' you want to solve
      challenge 1: coat your left side expression
      challenge 2(or 'challenge transition'): create the equation (touch "=" sign and then a number)
  2. get back to your initial letter on left side:
      challenge 3: uncoat your left side expression, and see right side getting 'inverse coated'

**edu:quality control: is this expression valid ? there is an expression provider and two bins: one for the valid expressions and one for the invalid
    if player has made nb_mistakes < nb_max_mistakes then challenge is completed

(((*attention avec les func.bind(this), les arrow functions font les rebelles: il faut utiliser les bonnes vieilles function() à la place.

(*la théorie du décollage: quand le processus de développement de l'élève est entretenu par l'élève lui-même ((souvent par une passion))

(*l'avenir sombre de l'éducation: convey

*un petit goût d'usine: conveyor-belt-based challenges: il faut pas traîner sinon ça fait planter la chaîne

03 février 2021:
**edu: random everything + "I think this is not possible" button.
    le pendant du "grand" aléatoire : on ne sait pas si on peut trouver une solution
*edu: 100 points par jour
**challenge:from expression1 to expression2 via x: unfold in order to customFold
  example: sqrt((3x+1)/2) --> x --> (60 - x)/sqrt(85) + 7

(((((*maths for the perv: puzzle composed of greenMouse targetSlots which gradually untile to show beautiful lady for example

*challenge: interlock: with "intersecting composites"

*add a handle next to snapSlot for easy 'group move'
*snapSlot may be, at start, a single-object composite. It then grows with the snapping of objects.
  => "snapComp" = composite(snapSlot)

**experiment: not really a challenge, not really a tool. It is more like a "this"-dedicated sandbox.
**edu:experiment: RVB color by hand: player creates a mosaic square (or a circle, or any shape) using small colored squares, r are red, g are green and b are blue: when zoomed out: we can see that the square color we see is near RVB(r,v,b)
    pour aller plus vite: on peut imaginer:
*    -un spray avec un compteur (on spraye(== position aléatoire) des petits carrés (ou ronds) de couleur donnée)
**   -un enclos avec une fonction de mélange: on met tous les ingrédients dedans, on appuie sur mélanger et ensuite on dézoome

04 février 2021:
*challenge: équations: [relier] les différentes étapes de résolution de différentes équations proposées
    les équations de départ               eq1     eq2     eq3     eq4
    les équations un peu résolues         eq3'    eq1'    eq2'    eq4'
    les équations un peu plus résolues    eq1''   eq2''   eq3''   eq4''
    les équations résolues                eq4'''  eq1'''  eq3'''  eq2'''

*tool: dependency: créer un objet formule qui se met à jour automatiquement quand ses dépendances changent
  edu:pour ensuite les faire basculer sur le tableur

**0 engined.engines = {}

(((*how to serialize a closure ?

(((*Le problème du retard, quand il n'y a pas d'échéance...

05 février 2021:
*"exertive" operators: operator is moving and touches what to transform
  - eraser
  - randomizer
  - show/hider

*icObj.type = "2d_plank" : [plank] * [x 2] = [plankplank]  ==> icObj.type = "2d_length"
*icObj.type = "2d_tile"  : [t i]   * [x 2] = [t i t i]     ==> icObj.type = "2d_area"
                           [l e]             [l e l e]
                                             [t i t i]
                                             [l e l e]
*la logique derrière, c'est la coercion de [x 2] en [".size.width x 2"] ou en [".size.width x 2: .size.height x 2"] selon l'"argument"

*clickWell:   onclick: create instance and "put it under the mouse cursor"
  c'est presque pareil du point de vue utilisateur, par contre c'est très différent niveau implémentation
*touchTarget: onTouch: if toucher is valid: nowCompleted

*challenge: (greenMouse) rainbow: there are multiple targetSlots and the objective is to fill all of them

*challenge: randomness: on part de [""] et on a des opérateurs [append random letter]
    edu: juste en dessous de l'opérateur [append random letter], on montre le sac duquel la lettre est tirée
*   edu: il y a une zone pour mettre les rebuts et un compteur de rebuts

(* 0 simultaneous n-touch, "composite touch" ==> nTouchEngine
		  this could be a way to discriminate objects: those which trigger the n-touch and those which do not

**touchSlot hardcore transformation: from icObj.typeX to icObj.typeY
    - transformer une forme en nombre
    - transformer un texte en son
    - transformer une équation en un composite comprenant le membre de gauche et le membre de droite
    le dev doit être un peu costaud

**yielder::fromAudio : press 'start recording', speak, press 'stop recording' : recorded audio is then transformed into a number, or an operator, or whatever corresponds to what you said

**freeDrawingAnimation recorder: the whole drawing process is recorded
**AudioFreeDrawingAnimation recorder: audio is recorded as well

((*architecture::challenge: composite(well, composite(operators), target) voire composite(composite(well), composite(operators), composite(target))

06 février 2021:
((* the canTouchFunc problem :
      le problème est le suivant: un objet a besoin du contexte pour estimer une condition et il ne sait pas ce qu'est le contexte. Seul le contexte peut lui fournir les informations dont il a besoin.
      le problème est le suivant: touchSlot.canTouchFunc(above, below) n'a pas assez de above et below pour donner réponse satisfaisante, il manque des paramètres.
      plusieurs solutions :
        (1. touchSlot.will["touch"]: mutate canTouchFunc juste before it's going to be used: le contexte écoute la fonction et la mutate just in time
        2. touchSlot.canTouchFunc(above, below, context): on rajoute tout simplement un paramètre
          => touchSlotConfig.facade

07 février 2021:
  0 Paul:
    0 petit personnage qui donne les instructions

    0 deux modes d'exercices différents
**    0 calcul mental un peu comme le golf:
        scoring comme le golf: par, 18 trous
          0 bouton recommencer et pénalité de 1 point
          0 ou système de seuil comme au golf
          0 ou alors on ne peut que recommencer trois fois un challenge puis ça donne une pénalité
        0 difficulté croissante (comme le mini golf)

      0 apprentissage par le jeu, la notion de score n'a pas d'importance
        on va jouer avec l'âge de ma grand-mère, en fait je ne le connaît pas, c'est pas grave, on va dire que c'est x.
        0 première partie chaîne de caractères
          0 au départ on se trimballe la grande chaîne de caractères
          0 niveau 3: ["l'âge de ma grand mère"] * [+ "l'âge de ma grand mère"] = [2 x "l'âge de ma grand mère"]
          0 niveau 4: ["l'âge de ma grand mère"] * [x "l'âge de ma grand mère"] = ["l'âge de ma grand mère" ²]
          => utiliser une inconnue dans les coulisses

        0 ensuite l'inconnue
          0 deux niveaux enchaînés:
            0 [y] * [x 2] = [y x 2]
            0 [y] * [x 2] = [2y]

        0 "ah c'est bon je me souviens, pour avoir l'âge de ma grand-mère"

        0 au bout d'un moment, le personnage compagnon choisit de remplacer

      0 parcours 1,5 avec la règle suivante: on n'affiche pas le résultat intermédiaire simplifié mais la version parenthésée
**       0 GlanceTouchSlot: _while_ touched : simplified expression is previewed

  0 SHU: utiliser le jeu de façon répétée pour s'améliorer (un peu comme les assistants de touchTyping), un peu tous les jours ==> "I was growing up big like a Superman"
    0 parcours 0: pas de score, pas de par, on peut "se tromper" autant qu'on veut
    0 troisième parcours avec uniquement des équations pour cette fois ci faire de l'entraînement
*** 0 BlueMouse (==GolfRedMouse): _if it has been mutated_, then when dropped: the previous well is moved to the drop position
        pour l'instant on ne va pas trop s'intéresser à ce concept car il cristalise les "erreurs"

    0 en fait il y a deux pars:
        0 dans un essai spécifique: le nombre d'opérateurs touchés
        0 le nombre d'essais (== de greenMouses utilisées)

*edu::challenge "injection" (inject challenge in presentation): addNewChallenge(screenRect): compute the coordinates to fit in screen rect

**edu: client-server benefits: teacher can be real-time moderator of student room (la cybernétique: wire power)
  - big-brother: oversee what individual student is doing
  - shutdown: close all sessions if students are too much agitated
  - course MC: "sharp control" course flow
      - show exercise
      - close exercise
      - lock/unlock move in student room
  - teacher can freeDraw hints in student room

*golfCourse: ui: use golfCourse standard pattern: (ball), teeing, (fairway, green,) hole, flag
*golfStep: onComplete:
  - show arrow pointing to next course, a big fat red arrow
      0 icObjType = "arrow"
          icObj.orientTo(point)
  - fill golf course with golfStep.score (when zoomed-out, we see big numbers and arrows)
      backgroundColor(score):
        bronze: above par
        silver: par
        gold  : below par
      edu: de cette manière on peut voir comment l'élève réagit à la difficulté croissante

*sexy/sexiness:
  - greenMouse trail
  - decorations:
      associate an image to each golf course (for example, an image from ALOI 1000)
  - card aura
  - rainbow
  - card back
  - factions : grand colors
  - rare card / foil
  - stack

*greenMouse: mode: survival: (== "endless")
    time is extended by n seconds when completing challenge
    challenge is mutated with new values|operators when completed

**greenMouse: forbidden values: gmValue cannot be x or else gm dies (there are forbidden nodes on the gmAllPathsGraph)

**challenge sequence::segue: how to transition from challengeX to challengeY

08 février 2021:
*greenMouse golf: "impossible? step": gm initial value is 0, operators are [x 6] [x 7] [/ 3] [/ 42] and targetValue is 42
    - player has to think outside the box and use a [+ 1] operator, available on the _previous golfCourse_
    - the 2 golfCourses are visually fusionned (to give player a hint of what to do)

***CURSES! :)
*icObj.type = "gmRebirthWell": there is actually no real well, only the gm respawning -> icObj.type = "bornAgain_gm"
**    bornAgain is a _curse_, same as greenMouse

**fucked-up maths (== curse operators):
  - delayed operators: a delayed operator will apply _after_ another operation is applied.          [after <n> operations: x 2]
  - 'just before' operators: a 'just before' operator will apply just before operation is applied   [just before x 2: + 1]
  - doom : gm will die after n turns
  - amplification/minification/replacement: operator right-side value is mutated before operation is applied: [x 2] will for example be 'felt' as [x 20]
**- "karma curse":
      - "next life": curse which applies to the bornAgain
      - "eternal curse": curse which applies to all the replicas. One can't get rid of this curse.
  - "feed me"/apoptosis curse: If object is left without interaction for n seconds, it will die.

*bizarre ideas: no-copy curse: object cannot be copied

((*une idée c'est 100 lignes de code et 10 autres idées qui se ramènent.

*edu: c'est intéressant de proposer le même challenge mais avec l'ordre des opérateurs changé car l'élève un peu distrait va retenter son "parcours glissé" qui fonctionnait avant et va se rendre compte qu'il ne fonctionne plus maintenant.

09 février 2021:
**challenge: consume stack of targets : well does not change but top card of targets' stack is removed on completion
    edu: this would be a nice mode for training: students has everything in sight and knows it's over when stack is emptied
*challenge: consume stack of targets with finite initial stack
    edu: pour se concentrer sur la bonne gestion des ressources

*score: score is decreased by 1 for every new attempt

**modulo: greenMouse value is modulo n
***the mole: touchOperator does not trigger if greenMouse is below (zIndexWise) : we can imagine 0-assignment walls or even complete contours, from which player would have to consider using the 'mole move'
      or bird move, if we consider that touchSlot triggers when greenMouse is below (it would be more coherent with stamping and soaking)

**challenge: wall of challenges / challenge pointillism: completing a challenge colors the tile. An image slowly appears with more and more completed challenges.
    dev: how about 500 challenges ? 1000 ?

performance:
**	0 touchSlot.local_listen
**	0 canvas.local_redraw

*edu: ux: parentheses: in unsimplified expression display mode, when chaining 1 * [+ 2] * [x 3], it would be nice, just before applying [x 3], to add an animation which shows the user that 1 + 2 is now (1 + 2)
    à la limite: carrément montrer "x has a higher priority than +", ajouter les parenthèses et appliquer l'opérateur
      colorier l'expression en fonction de la priorité de son opérateur racine
      colorier les opérateurs en fonction de leur priorité
      "pour appliquer une priorité supérieure, il faut emballer"

*edu: les bons jeux edu et les mauvais jeux edu: la jungle

10 février 2021:
((*la couleur (==la composition de couleur que l'on voit) a une influence sur le moral. Suffit que le fond soit un peu trop aggressif et c'est mort, on n'a plus envie.

**edu: computer science: scope, visually: say we have a "visual local variable" [x] (~un peu comme une greenMouse) in a visual scope [S] (~a playField), then in the same way as for a classic local variable x, we could have another [x] in another scope [S'] and the two will be completely hermetic/alien.

**challenge: 'overuse golf': il faut faire un nombre de coup _supérieur ou égal_ au par pour pouvoir valider le challenge.
**challenge: 'Ratatouille golf' ou "Pourquoi faire simple quand on peut faire compliqué ?": il faut utiliser au minimum n opérateurs différents pour pouvoir valider le challenge.

(((**la vision: rendre visible l'invisible (pour faire un tremplin vers la compétence "voir l'invisible" que l'on souhaite acquérir)

(((**le moteur: toujours avoir l'impression d'être libre

**challenge (computer-science): destroy ftw: : student has to destroy the right object to be able to complete challenge
    example 1:
      every time a touchSlot touches an object, a counter increases near the touchSlot
      the player has to use the touchSlot 5 times but, for the challenge to be completed, player is only allowed to use it 3 times
      an object is responsible for the counter increase, it is a visual representation of computer logic (and the object actually _carries_ this computer logic)
      if player destroys this object, as the counter is no longer increased, player can complete the challenge

**Attempt: Evolution vs Manoeuvre:
    Evolution: greenMouse-focused       passive stance: what the world does to me
    Manoeuvre: course-focused           active  stance: what I do to the world

0 icHook : les deux frères Will et Did

(((n'empêche, tout ce caca qu'il faut écrire... : from magma to cristal, from heart shapes to trash heaps

icObj.namespace ou icObj.family, par exemple: icObj.namespace = "golfStep4", icObj.namespace = "golfCourse7"
  pour savoir quel objet "appartient à qui"

on retrouve les bonnes vieilles marmites: "label: value" ==> icObj.type = "labelValue" (==composite(label, value)) (l'informatique des dinosaures)

*edu: [score] au dessus de [par] (limite avec une barre entre les deux) pour glisser au passage un petit mot sur les fractions.
    On peut imaginer mettre à côté une progressBar qui est débordée si on dépasse le par.

**edu: flipping operators: flip animation transforms operator into inverse operator. example: [x 2] becomes, after a flip, [/ 2].
**    edu: when the golfStep challenge is completed, we flip the operators, we flip targetSlot: it becomes the well, we flip the well: it becomes the targetSlot. Student, after some attempts, will begin to understand that they have to do the reverse path.

11 février 2021:
*golf: endScreen:       nom du parcours, tableau de score et médaille
*golf: startScreen:     nom du parcours
*golf: tutorialScreen
((on s'écarte de la vision originale (== à la The Witness) mais c'est pas grave.

*autoPar / golfChallenge constraints:
    - path must stay between 0 -100 and 100
    - path must uses rich composite numbers

** "AND THEN HE YAWNED"

12 février 2021:  paralysis :(
*golf: hacker/cheater: get total_score below 10 by cheating
**edu: allow cheating but explicitly show "cheating" when cheating and on end screen

**golf cheating:
  0 "that hole seemed nearer": ball_1 in hole_7
  0 golfCourse tampering: same principle but operators are exchanged so that, at first glance, there is no cheat
edu:
  general cheating schemes:
    ugly:
    - end screen tampering
    subtle:
    - varX as inputY
    - level tampering

**challenge:factoryChain:
    on left-side:   maps      to create core process values
    on center-side: values    core
    on right-side:  reduces   to create result value

          ----[+ 1]----->    [x + 1]    ---|
          |                                [+] -> [4x+1]---|
        [x] --[* 3]----->    [3x]       ---|               [-]--->    [(4x+1)-1/x]
          |                                                |
          ----[inv()]--->    [1/x]      --------------------
    Some blocks may display an _expected_ value, and the consequent value.

    two flavors:
      type:   user types what he thinks is correct make the chain valid
      puzzle: empty slots must be filled with pieces

*endless: recycle golfCourse VS create new golfCourse

**icObj.type = "repeater": when actioned: contained operator is applied <n> times
                [R <5>       ]
                [   [x 2]    ]
                [            ]
    ? crocodile-style ui à la Scratch ?

**edu: challenge rework: on completion (or later on): challenge is proposed again, but under a new, reworked form
    - propose challenge.ver2 with different operators
        from [+ 2] [+ 2] [+ 2] [+ 2] [+ 2] spam to [R5 [+ 2]] to [+ (2 x 5)],
        from [x 2] [x 2] [x 2] [x 2] [x 2] spam to [R5 [x 2]] to [x (2 ^ 5)],
        from [/ 2] to [x (1/2)] (slight change of vision)
    - propose challenge.ver2 with ver2.input = 2 * input and ver2.target = 2 * target
        ver2.input = 10 * input and ver2.target = 10 * target, etc.
    - propose challenge.ver2 with all components' values scaled by 10
        scaled by 0.1
        scaled by 10^6


(((*l'adn, c'est le code qui a été retenu, donc normalement c'est du bonheur (par rapport à du code pourri ou du code sale)

**edu: practice: corrective feedback helping: (https://en.wikipedia.org/wiki/Control_engineering), create next step wrt previous steps attempts
    Appuyer là où ça fait mal
    dev: evolutionary computation, Resilient control systems

*edu: display evolution: show graph of greenMouse value evolution
**edu: inverse operators on top row: each bottom row operator has an inverse counterpart on top row: when student has "made a mistake", student can always cancel their mistake by applying the inverse operator

13 février 2021:
((*j'aime bien le problème de nommage de operator, quand on ne fournit seulement qu'operatorFunc. Si on connaît le code de la fonction, alors normalement on peut nommer correctement.

*edu: group-covering operator set: so that there always exists a path to the target
    - ℕ-covering operator set: to drive student into using [x (-1)]

*pretty operators: [/ 2] -> [□ / 2]

*edu: challenge.deceiving_rank: check solving paths for lasagna trees built from the super operator set: {operators} + {inverse operators}
  some students may try to solve "[48] --> [38]" using [+ 10]
*   Il y a un gros travail à faire autour de "C'est quoi un challenge difficile ? C'est quoi un challenge facile ? C'est quoi un 'bon' challenge (pédagogiquement) ? C'est quoi un 'bon' challenge (gameplay) ?"
  petit à petit (=="gradient fractal") faire passer de [+ 1] à [- (-1)] à l'indifférence [+ 1] ou [- (-1)]

*edu: est-ce que ça apporterait quelque chose que considérer des opérateurs qui acceptent seulement un certain type de valeurs d'entrée ? (par exemple: seulement des nombres, seulement des symboles, seulement des fractions, etc.)

*edu: un peu risqué: fraction as a certain number of turns (oriented unbounded angle)

0 easy composite rewrite: composite.parts["x"] = y;

*challenge: greenMouse = RangeNode: toutes les opérations sur les intervalles
*challenge: revolver operator (== operator cycle): once used, operator becomes operatorCycle[n+1]

14 février 2021:
**edu: BiggieSmalls: bigger font for what is important: artificially create a foreground and a background in TeX expression
    - solving an equation: MAKE 'LAST' OPERATION BIGGER
        ---|                   /|    /__\
           |                  / |   /    \
         --|     (x + 1)   =    |       /
           |                    |      /
        ---|                    |     /___

         ^
         |
         |___  this is the last operation that was applied

**edu: cherry-picking: [save (previous) challenge] / [copy (previous) challenge to clipboard] quand on a trouvé quelque chose d'intéressant au challenge aléatoire que l'on vient de rencontrer
((*L'approche phénoménologique: les maths interactives, ça demande de passer par l'étape (plus ou moins chiante) de _programmation_ des activités. Les maths interactives, ça tombe pas du ciel. Après on en tire les conséquences qu'on veut.

*rep_eternal VS rep_living: how it feels never to die

***0 en fait il faudrait un symbole pour chaque opération:
      unitful operation (=="node_b" is unitful):
        multiplication:      ×                A shock, like a battle between the two factors (cross swords). Some units are lost in the process. d = v * t
                                                Quantities multiply and units combine.
        quotition division:  ÷                We search the unitful quantity of unitful bottom member present in top member.
      unitless (==scalar) operation (=="node_b" is unitless, it is a "true" number):
        scaling:             · (|no symbol)   We scale by <coefficient>.                                  ("mother" unit is preserved).
        partition division:  /                We search the value of a part if we partition into n parts. ("mother" unit is preserved).

      Le langage fait apparaître des "unités invisibles": quand je dis 3 demis, je peux me dire que mon unité est le demi, et ma quantité est 3.
      Quand je dis "Trois demis fois un quart", en fait,
        - je multiplie les quantités : je fais trois fois un, ça donne 3.
        - je combine   les unités:     la moitié d'un quart c'est un huitième.
        Résultat final: 3 huitièmes.

      Trois demis divisés par un demi == Trois demis partionnés en 'un demi': Trop facile, ça fait 3.

      On peut passer de 3 demis à "1,5 uns".

*edu: "Bon je vais où maintenant, vous me montrez ?" infiniteCanvas program X clickless student multimouse

15 février 2021:
0 Atelier_<X>: zone de dev pour icObj<X> ou pour une mise en scène d'icObjs

16 février 2021:
**edu: (mainly for client/server): evanescent freeDrawing: teacher can write hints or indications which gradually vanish
**mathNode.toTex(): custom: to inject color for example
((*hack: use (x 1^id) to tag sub expression

**edu: speed evaluation: l'élève a 3 secondes pour toucher le bon target
    pour par exemple:
*     ("faire rentrer") les additions simples et moins simples (9 + 2 = 11, 9 + 8 = 17, 7 + 4 = 11, 8 + 7 = 15, ...)
      ("faire rentrer") les tables de multiplications
      ("faire rentrer") les relatifs

**0 ux: make it _readable_( {size, fontSize} )

**operands: argument operand VS parameter operand
    [x] * [+ 3]
     ^     ^ ^__ parameter operand
     |     |_ operator
     |___ argument operand

**edu: challenge: from x to expr:
    ver1: same operation set is used to create targetExpr and 'growingExpr'
		  easy:    one instance of symbol, operand order is left to right
		  normal1: one instance of symbol, random operand order          (là on est au coeur d'une difficulté des élèves: passer d'un parsing left-to-right à un parsing plus global)
      hard:    random operand order, sometimes parameter operand is an instance of symbol

    ver2: different operation sets are used to create targetExpr and 'growingExpr': student has to mentally simplify to find the right operation
      easy:   simplify one step (+ -):  [+ 2] * [- 3] into [- 1]
      normal: simplify one step (x /):  [x 2] * [/ 6] into [/ 3]
      hard: simplify two steps: [x (3 + 10/5)] into [x 5]

((*A challenge mechanics for every 'learning step': expliciter toutes les petites difficultés des élèves: transformer l'escalier à grosses marches en tremplin

(((* maintenant j'ai comme une "tendresse" pour les opérations genre [x 2]

*"operator simplification":  [x [2^4]] = [x [2 x 2 x 2 x 2]] = [x 2 x 2 x 2 x 2] (on peut retirer les [])

17 février 2021:  'INDIRECT'
* 0 indirect touch: contactArea is the only entryway for touch
  =>targetTouchSlot.facade on top, targetTouchSlot.touchSlot at the bottom,   so that player can see the two expressions distinctly when try to submit answer

* 0 indirect hold:  if I grab greenMouse's tail, I grab the whole greenMouse. Same thing with any other body part.

(0 sometimes algebrite fails to recognize that two expressions are equal

19 février 2021:
**challenge: Different ways: get to target via n different ways
    inspiré de
      2 + 2 - 2 / 2 = 5
      2 x 2 - 2 / 2 = 5
**challenge: greenMouse in tuxedo: greenMouse displays numerical expression instead of value, target displays value

*fill tool:
    0 bounded fillable
      0 find if there there is a bounded fillable around cursor
      0 create object which fills
    0 unbounded fillable
      0 create unbounded fillable (dynamic object)

*greenMouse: pure operators [+],[-],[x],[/]
    0 gm_calculator
    edu: [(x + 3)] * [-] * [(2 - 3x)]

(((("HE PUSHED A ROCK"
(((("AND THEN HE YAWNED"

20 février 2021:
**challenge: mutating target: each time greenMouse mutates, so does target. It's kind of a curse.
    example:
      linear evolution:       target := target + 2
      exponential evolution:  target := target x 2        (better be quick)
      cyclical evolution:
               target := target + 2
          then target := target -10
          then target := target + 2
          etc.

21 février 2021:
**adaptive pov(==bound pov): pov follows activeSelection size: if object is shrunk by an operator, then pov follows
**size-restricted operators: operators only trigger when greenMouse size is compatible
    edu: put [x2] or [+0,01]  size(10^-2) operators      around _or inside_    a size(10^1) [/1000] operator

*gm: test-tube operators: there is a test-tube wrapper around operator which forces greenMouse to be touched in a particular direction
        ______________
        |[2 x]  <--<--<--<-- [3 + 4]        ==> [2 x 3 + 4]
        |_____________

**bag: put/pick (==push/pull)
    push x1:  touching object pushes  1 instance  of it in the bag
    push x10: touching object pushes 10 instances of it in the bag
**  random pull (==random pick): touching operator random picks an instance in the bag
**challenge: fill bag then "random deliver" (target must be _attained via random picking_)
**challenge: multiple chained random deliveries     (one may try again, and again, and again)

**0 ustensil: operator can be dragged to touch other objects and gets back to its original place when released

**edu: easy arrowing: measure: create measurement arrow next to object

**number fonts:
    even  number: round
    odd   number: spiky
    prime number: noble
  0 tex fonts

22 février 2021:
**challenge: cube target:
    1. player can manipulate target to understand it better:  [turn left], [turn up] operators in order to know what target is
    2. player has to turn and mutate side and turn and mutate side of greenMouse cube to match target cube
    example:
      cube painting
      dice painting (paint dots)

*Scratch-like: any colour you like
  https://github.com/nicolaspoulain/scratchTeX

**greenMouse: boulangerie-pâtisserie:
    - greenMouse starts with coins
    - there are bakery operators: [get baguette (1,00 €)] [get croissant (1,20 €)]
    - each time greenMouse touches operators, greenMouse loses money but gains object
    - unavailable operators (not enough coins) are grayed
    edu: même chose: un parcours à l'endroit puis à l'envers (revente au prix coûtant) permet d'introduire les expressions littérales puis les équations avec des prix inconnus

0 regarder le travail des grands:
    Scratch: https://github.com/LLK/
      dependencies:
**      - http://paperjs.org/
        - plein de trucs de Google... (???) (!!!)

23 février 2021: Quantum Protocol is very good: supergraph, mastery, research, activationCountdown, different activation types: initialize, when <condition>, execute, ...
*supergraph (==story graph): we organize "keyGames" (~superKeyframes) in a graph
**"research": player unlocks new objects when they have enough mastery

**challenge: random in range => narrow range: every turn tick, greenMouse metamorphoses into random number in range. Yet, "source range" can be mutated using operators in order to narrow down possible outcomes.

**0 icObj.parts.curse.parts.counter, icObj.parts.curse.parts.curse_row

**a countDown curse can be put on _a challenge_
((curses for everyone :)

((*coop game: one player controls greenMouse, the other can cook operators

*benecurse: touching benecursed operator adds counters to targetValue's countdownCurse.countdown

***reactiveAnimated: mutating one property mutates the others, in order to stay on animationPath  (==lifespanObj)
      example 1:
        {
          progress: 0.12,

          index:    1,        <--- mutating index results in a progress quantization

          color:    someColor(0.12),
        }

      example 2:
        {
          progress:         0.4,

          name:             "ozij fozjf",
          wealth:           5000,
          nb_of_children:   1,
        }

24 février 2021:
  0 algebraic expressions easy unequal checks: 0, 1, -1
**greenMouse: units: [12 people] * [/ 4 people] = [3]
**greenMouse: dotted line: periodic mutation

**greenMouse: back to binary operators: operations operands can be swapped (dnd)
**redMouse: back to binary operators: three (or two) red mice as left and right operands, left operand is also "receiver"

WOW: https://mathsolver.microsoft.com/fr/solve-problem/7%20%60times%20%208x%20%20%5E%20%7B%202%20%20%7D%20%20%3D3?r=bi&ref=bi

**multistep operation/multistep inverse operation (why not trying harder ?)
    example: [x] * [(3? + 4)/5] = [(3x + 4)/5]
             [(3x + 4)/5] * [(?x5-4)/3] = [x]

((*il y a le test fonctionnel: regarder s'il y a des bugs, et il y a le test "goûteur", le test qui se demande si un humain va accrocher.

*terminalMathNode: x vs ((((((x)))))

greenMouse: expr to x:
*   medium: propose 'reduced' operator when two same-priority operators are chained
      example:  [((3x + 5)/4)*12] --> [x]: propose [x 3] instead of [x 4] or [/ 12]
*   medium: propose equivalent operation: [- (-1)] -> [+ 1]

**greenMouse: binary representation of numbers: 0110011010010
    - shift: left / right
    - invert bits (~)
    - add<n>

25 février 2021:
**challenge: greenMouse: clear target stacks in <n> turns: player has to find the path to clear target stacks in least turns
    - numbers
    - number exprs
    - litt exprs
**challenge: greenMouse: given _hypothesis_, complete challenge
    example:
      _hypothesis_ : _x = 4_,   [3x + 7] --> [74],  using operators: [+ 1] [x 4] [- 6] [- 7]

**challenge: greenMouse: suites: player starts with _n=<k>_ and [value(u_n)], operators are [u_(n+1)] [u_(n+2)] [u_2n] etc.
    touching operator [u_(n+1)] does two things: it updates greenMouse and it updates _n=.._ display: "n=<k>+1"

**ux: tablet: _dragArea_, displayArea, contactArea

((il manque un symbole pour dire c'est une expression ou c'est une opération. e3 / 2e  VS o/ 2o.

**challenge: greenMouse: from expr to x:
    medium+:  depth: 10     (ça a l'air hardcore mais en fait c'est toujours la même chose et ça permet de rendre 'acceptables' les grandes expressions)

edu: on pourrait envisager différemment les niveaux de difficulté:
    easy:     découverte                    prise de contact
    medium:   pratique courante             prise en main
    medium+:  renforcement, automatisation, prise de confiance
    hard:     désautomatisation, ouverture, prise de recul

*0 save/load gameSetup  (save/load anything (don't limit yourself to one serial type))

0 simplify: same priority == same "simplification level":  [frac((7x+3),7)x10] * [x 7] should yield [(7x+3)x10]

(((*qu'est-ce que ça va devenir tout ça ? poussière, chose publique, big money ? Should I give a fuck ? Pourquoi fait-on des enfants ?

**simplify: factorize
**simplify: animate simplifcation process: like combos in Tetris (Attack)
***  edu: tool: clock_simplifier: perform simplification at each clock tick
        Parenthesis removal step can be considered a first-class simplification step. (après on peut en débattre, mais je trouve que le mieux c'est de ne pas mettre la difficulté "parenthèses" entre parenthèses)

*yellowMouse (==chickMouse): comme le tri des poussins, on la balance là ou là
**challenge: yellowMouse: evaluate (numerical) expression
    1. player drags expr to choiceSlot
    2. the expression is drawn to the center of the challenge, in the "center stage" display zone
    3. the expression is then clock_simplified until the solution is shown
    4. player's choiceSlot then turns green if correct (or red if incorrect)
    5. challenge terminates (with success or failure)

0 class Simplifier
*icObj.type = "simplifyZone" : when icMathNode is inside, a top layer simplification is attempted every second (comme des coups de marteau, un petit côté maréchal-ferrand)

**"It's not maths, it's a card game." because the mathematical object is in your hands.

26 février 2021: a day without coding, a day of blah blah
**ux: coterie composite: this composite appears automatically when objects are close from one another and there is a legitimate relationship linking them
    the main reason of this object is to be able to move coterie objects without having to click a lot (== without having to compose or group them, then decompose or degroup)
**ux: preempt user actions: create easy objects for future actions

*card game: crack the code: find x, y and z
  - card cost depends on the "filtering power" of expr
    [z](5):       highest filtering power
    [3z+y](3):    medium  filtering power
    [5x+3y+z](1): lowest  filtering power
  - card evaluates when entering field
  - the game ends when one of the players has successfully found x, y and z

(*greenMouse: equation systems: il faut trouver un moyen de rendre ça facilement manipulable

0 tex: one color for each number place
    EN has nice words place, place value, face value

**number is composite / myCustomNumber / "mon nombre avec jantes 20 pouces": simple is already complex    (~text_destroyer: "text's not just text")
    0,271 avec
      - le 0 des unités:    noir et bold et Arial 100%,
      - le 2 des dixièmes:  rouge et italic et Liberation 80%
      - le 7 des centièmes: animated: rainbow gradient wave
      - le 1 des millièmes: curse: only appears when in invisible light area
      etc.
    http://adereth.github.io/blog/2013/11/29/colorful-equations/
  => 0 RichMathNode
     0 PositionalNumber {}
**number is banana:
  0 https://github.com/pkra/mathjax-img
  0 Xy-pic — Typesetting Graphs and Diagrams in TeX
    Xy-pic is a package for typesetting graphs and diagrams using the principle of logical composition of visual components.
    \xymatrix{ . . . }
**RichMathNode: number has a color stroke (draw in number, and this trait accompanies number (the whole thing is a composite)). If number increments, color stroke is still here.
                number has hat
                number has <anything>
(**sentence tree:
                [turbulent]
                  |
     [Il]       [très]
      |--[était]--|

27 février 2021:
**bad calculators (game on the internet): 'exact par' as "same same but different"-variant source

(((Tu rentres dans l'environnement d'une librairie et au bout d'un moment, tu comprends que c'est le gros foutoir. C'est clé en main, mais le sol est couvert de clés.
      et au bout d'un moment, dans tout ce foutoir, tu finis éventuellement par trouver ton bonheur...

((La dimension visuelle des équations: Comment faire quelque chose d'adapté pour les non-voyants ?
    on parle de membre de gauche, de membre de droite (lol genre les aveugles connaissent pas la gauche et la droite...)

((le dev c'est aussi perdre une matinée pour faire fonctionner une lib...
((*et tu te dis "putain je vais y passer la matinée", et effectivement, tu y passes __exactement__ la matinée: à 11h59, le truc tombe en marche, comme déclenché par un timer...
((*et au moment où tu crois que c'est bon, ça plante à nouveau...

*richMathNode: color gradient (when adding 2 colored numbers)
  https://tex.stackexchange.com/questions/45744/how-to-put-color-gradient-to-desired-text-only/46034

((toujours cette idée de repousser les limites, parce que c'est nul les limites.

28 février 2021:
*greenMouse: challenge multiple endings: contamination: if greenMouse is contaminated then reward is X, otherwise reward is Y.
  edu: une manière de diriger

**reactorMouse (==reduceMouse): mouse is covered with touchSlot, mouse is assigned result
    lore: elle est restée trop longtemps à côté d'un touchSlot
    ==> il va y avoir deux opérateurs pour chaque opération non commutative:
      [x-y] et [y-x]
      [x/y] et [y/x]
      [x append y] [y append x]
**versatileReactorMouse: l'opérateur de surface change quand on la trempe dans un opérateur
    l'opérateur touché est [op]
    si op est un opérateur qui commute: on met op comme opérateur actif dans la _roue des opérateurs_
    si op est un opérateur non commutatif: on bascule vers la prochaine version de l'opérateur dans la roue des opérateurs (exemple: [x-y] devient [y-x])
**turn reactor on/off
    default reactor operator is [+]
**needleMouse:  mouse destroys what it touches
***guzzlerMouse: (versatile)reactorMouse + needleMouse      (aussi appelée worldEaterMouse, gluttonMouse)

**challenge: guzzlerMouse:
    - en haut:  des opérateurs [+] [-]  [x] [/]
    - en bas:   des nombres    [4] [-1] [2] [0,18]

**greenMouse.characteristic / [.is operator]: like a curse, but it takes part of greenMouse definition
    example:
      [.is  evenNumber]
      [.is  hundreds digit is same as units digit]
      [.is  positive]
      [.is  not a multiple of 3]
**greenMouse: all possibles:
    example: let g be a 4-digit even number starting with 1
           9   9
           8   8
           7   7   8
           6   6   6
      [1 | 5 | 5 | 4 ]
           4   4   2
           3   3   0
           2   2
           1   1
           0   0

**challenge: whoami guzzlerMouse: end up with only one possibility from an all-possibles mouse

***challenge: from expr to expr:  [split top layer] [split all]
    1. split expr into components
    2. build new expr from components
  edu: expression rebuild: from expr to same expr
**  various starting stems: reactor core is randomly assigned to a node
    optional: faire travailler la mémoire: on ne raffiche plus l'expression de départ

01 Mars 2021:
**reactorMouse: when split: one component is _reactorCore_ ((==interaction stem))
**challenge: fruityMouse: each digit symbol is replaced by a fruit symbol
    so player has to:
      1. play with operators to get a grasp of which fruit corresponds to which digit
      2. using this new knowledge, use the operators to make target value
    edu: quand on applique plusieurs fois l'opération [x k], comment peut se transformer le chiffre des unités ? et avec [+ k] ? etc.
    medium:   avec des entiers
    hard:     avec des décimaux
    hardcore: avec des complexes

***splitter: output: composite       (weak splitter)
    fireworks split         [1]                   [2]
        \    |   /            \       |           /
        _ [split] _   ==>    _ [composite handle] _
        /    |   \            /       |           \
                                     [+]
      0 animation: explosion

    rect splitter| shape splitter:
      separate square into 4 pieces
      separate square into 2 triangles
      etc.
**operator: assemble: randomly assemble composite parts (arr_icMathNode) to create a single expression (icMathNode)

**clone fireworks: when <condition>:       separate into <n> clones, each following a different direction
      operators: when touching an operator: separate into 4 clones, each following a different direction
      labyrinth: at a crossroads:           separate into 4 clones, each following a different direction

**operator: next type (==morpher): [nextType]: object cycles to the next type it extends to
    example: icMathNode --> icText --> ...
**operator: "equals": [=]     (sûrement plus qu'un simple opérateur)

(((the composite hack:  ONE IS ONE IS THREE

(((Je ne fais que dérouler les possibilités qui se montrent, et ainsi de suite. Comme un enfant qui joue dans le bain.
    Si je démonte, juste après, j'ai envie de remonter.
    Si j'ai une collection, juste après, j'ai envie d'avoir un seul objet.

((déjà dit:*PolyHandle-Puzzle: puzzle created using composites created from subsets of same components set

02 Mars 2021:
***AriadneMouse (==PoopooMouse): when touching a touchSlot: untransformed mouse waits where it touched (==poo poo), while transformed mouse continues "under player's click"
    Branch-cancel PoopooMouse: moving a poop destroys all descendants from this state
    edu: this way, all intermediate states appear on screen (even the unfruitful)

03 Mars 2021:
**reactorGreenMouse: ux: non commutative operator double touch
    - when reactor is in (|y-z|) position: when touching [-] again: instead of selecting (|z-y|) reactor operator, select (|+|) and change [n] to [-n]
    - [n](|/|) becomes [1/n](|x|) when touching [/]
    edu: c'est une autre manière de présenter les choses, qui permet d'afficher un réacteur simplifié (un seul -, un seul /)

**greenMouse: operator is unsimplified: instead of showing [+ 40], show [+ 8x5], or [+ 8 x 5]
    medium: [+ 8x5]   (renforcer les tables)
    hard:   [+ 8 x 5] (renforcer les priorités opératoires)

**customerMouse: [stickman] [bank(-20 € on bank account)]     [buy oranges(2,10 €)] [buy tea(3,30 €)] ...
    edu: les équations, les relatifs (le découvert), ...

((**fabricjs: change activeObject _while dragging_    (please make it easy for future generations)
    		0 recréer les "conditions de départ" du drag
      https://github.com/fabricjs/fabric.js/issues/5820
      https://github.com/fabricjs/fabric.js/issues/2753

04 Mars 2021:
**supervessel: on move start, show supervessel.contactArea (==supervessel.contactArea.isVisible = true;)

**edu: 32bits/64bits: faire sentir la différence avec des "petites instructions" (32bits) vs des "moyennes instructions" (64bits)

**(*)challenge: split,recompose,match
    1. ClassX instance is split into components  (for example: a litteral expression is split into "component mathNode"s)
    2. components are randomly recomposed into a _new instance_ of ClassX
    3. player has to match the new instance with _something equivalent to it_ in a pool of possibilities
    edu: ça fait le lien entre les expressions littérales et les probabilités

**challenge: recycling ground: player may split many source items and put the components in a bag, and then use the components in the bag to create target item
    the idea there would be to split fewer items possible

05 Mars 2021:
supervessel: cargo
0 manage touch with supervessel
  0 the old way: business as usual, but with supervessel inclusion
  0 the new way 1: event capturing: only supervessel is touched
  0 the new way 2: event bubbling: touch bubbles up to supervessel
***infiniteCanvas::operate on active object (can be done while held :) thanks to supervessel)
    - any operation
    - associated ux: une main sur la souris, une main sur le clavier
**Split active object == split supervessel cargo
    edu(/pres): language: split a sentence
    edu(/game): maths: split a refined object, an object which is the result of many operations
**supervessel:make active object(s) touchable
    on peut rendre le truc encore plus mystique en activant cette opération quand le supervessel touche un opérateur spécifique au supervessel

**"greenMouse ex machina": while holding empty supervessel, inject a one-life-only greenMouse under it

**IcObjectTypeOverlay:  (or IcObjectTypeContainer)
    - object type symbol on topleft corner
      |---------
      | S |
      |___|
      |
      |
    - icObject type <-> border color
        mathNode        hotpink
        string          Como
        image           Rajah
        freeDrawing     Dark Violet
        shape           Gray
        video           Cola
        bag             Baker's Chocolate #553516

**challenge: simultaneous release: player must use supervessel to split an object into component and then release/snap them "simultaneously"
    because when snapping an individual component, the other slots close down

((*split void: on peut faire surgir des paires d'objets opposés du vide canvassien

(((the software psychotouch: when nothing explicitly indicates a bug, but still, you feel it under your mouse click

**(*)challenge: multiType challenge: some operators are type-specific, so user has to use morphers before using type-specific operators
    edu: renforcer l'idée de _nature_ d'un objet, et des propriétés et opérations de cette nature

06 Mars 2021:
***shard transformation: morph to typed representation == show icObj.shard<X>
    cette transformation peut être déclenchée en utilisant une touche de clavier: "operate on active object"
      - morph to text description     example: "Il y a un lac à l'arrière plan. Et au premier plan, une voiture et un chien."
***   - morph to code                 ==>This way one can modify the behavior of icObject. (==> DSL)
***   - morph to inner world          On peut zoomer dans l'inner world et intéragir dans cet inner world.

**greenMouse: fractions: colored 'lengths'
    - on touch: append to greenMouse
    easy:     no number tag is shown: only colored rectangles
    medium:   number tags are shown on every rectangle    (1/10, 1/2, 1, 1/20, etc.)
    medium+:  improper fractions: 8/3, 5/2, etc.
    hard:     target is a number (there is no target rectangle)

**collection-only operators (==bag operators): pour montrer la distributivité
**edu: The Mirror

0 l'inverse de split: join
  0 incorporate geometry:
      [                ["i"] ]
      [ ["w"]["o"]["r"]["d"] ] * [merge] = ["    i\nword\n    e\n    a"]
      [                ["e"] ]
      [                ["a"] ]
  0 animation: center attraction
**math: prevent join from creating "divide by 0" expressions
**  allowed mathNode / allowed subgraph

*que se passe-t-il quand on join() des objets de types différents ?
  0 hierarchie de types
  0 appeler ça autrement: merge, marry, unite, combine
  0 trouver le bon verbe pour chaque situation

**maths: brainfuck: use operator symbol as terminal symbol name (3+ + 4 - 4/ x 3): i think this could get funny and mad

**logical puzzle: all must be true
    - problèmes de tri
    - self referential puzzles: there are 3 objects in zone A
    edu: sur la nature des objets:
      zone A: any number inside is < -5
      zone B: any number inside is even
      zone C: any number inside is only composed of 1 and 2 as digits
      zone D: any number inside is a perfect square
      zone E: the sum of numbers inside is 20
      etc.

07 Mars 2021:
*challenge: reuse: create touchOperators by splitting expr
*join: triangles semblables

**"dropper un reset": erase the past
    principe:
      - les élèves abordent une notion via un ensemble de challenges
      - il y a des stats qui sont reliées à la notion: pour faire simple succès|échecs
      - une fois que l'élève réussit un certain nombre de fois d'affilée sans se tromper, un bouton "reset" peut apparaître pour réinitialiser ses statistiques. "'Oh, j'ai droppé un reset', s'écria-t-il."
      - cela donne la possiblité à l'élève de se la jouer en exhibant ses "flawless statistics"
** edu: on peut même jouer sur les stats pour ouvrir de nouveaux challenges: min. 10 attempts and 90% success

***greenMouse: properties: [A=>B] * [B=>C] = [A=>C], target is [A=>Z]
    edu: on peut aussi expliciter: [A=>B] * [B=>C] = [A=>B=>C]
**greenMouse: equation::equivalent equations: show <=> sign: [A=B] * [x 3] = [A=B <=> 3A=3B]
    or build a composite: with head part and trailing part
      [
        [  [A=B]
           [<=>]
                  ]   trailing
        [ [3A=3B] ]   head
                    ]
      only head can interact with other objects/be operated on

***landing stage: where a new object will be spawn in
    - default: infiniteCanvas
    - usage: new objects spawn in landing stage (object or infiniteCanvas, or infiniteCanvas.layerX))
        this is the main mechanic for object enrichment

08 Mars 2021:
**challenge: fractions: la planche à découper: on laisse des morceaux sur la planche quand on prend une fraction d'un objet
    - [x (1/3)] means we cut in three equal parts and then we pick one part
    - [x (2/3)] means we cut in three equal parts and then we pick two parts and join them together

**edu: redMouse/redMice: fractions: montrer la droite graduée au plein milieu de l'aire de challenge, disable z-scroll for redmouse

(**the taoist way of understanding numbers: numbers and operators arise mutually. L'un ne va pas sans l'autre.

*Same function, different worlds: append_left(a,b), append_right(a,b) (==append_left(b,a)) in the string world and in the math world are very different.
    quelque chose du genre: a x 10^(floor(log(b))) + b

09 Mars 2021:
(**J'aime pas les soi-disant jeux qui à la fin te disent: Bon bah tu t'es trompé 4 fois sur les 10 épreuves. On te donne 6 étoiles.
    Pour moi, "l'important c'est de passer". Peu importe le nombre d'essais, l'important c'est de franchir l'obstacle. L'important c'est de ne pas être empêché, de pouvoir voir ce qu'il y a après.
    On est pas là pour sanctionner, on est là pour faire progresser.

10 Mars 2021:
**l'"objet opérateur", du coup, il est à gauche, ou à droite ? Dans ma tête, il est parfois à gauche, parfois à droite. Ca dépend. Ca dépend des jours ?
    [1,5 x] 24 VS 14 [x 2]

**"Et ce serait dur de mettre un système d'analyse des réponses des élèves ?"(merci David)
    0 Prélever les données. Il faut mettre des capteurs de données pertinentes dans le code des challenges.
    0 Traiter les données:
        0 librairies de stats
        0 edu-tailored libs: il existe peut-être des bibliothèques "edu" toutes faites

11 Mars 2021:
**VS game (vertical split screen): green rain
    - on each player screen, it's raining operators
    - player can try to create the biggest number possible
    - sometimes, when a player has "made a good move": it's raining [x 0] operators on opponent's screen

12 Mars 2012:
***error management: keep the machine running: from player mistake to platform|runtime error
    - frame is cropped:  next challenge frame corresponds to player input: No mistake, no cropping.
    - memory error: challenges spawn regularly, if player takes too much time to solve challenge, there will be too much objects hence a memory error.
    - screen flood: previous challenge is cleaned wrt player's success: No mistake, perfect clean. So that, we mistakes accumulate, the screen is flooded with previous' challenges parts.

((**l'ensemble des nombres que l'on peut produire avec un ensemble de symboles: from graph theory to number theory

**octoMouse(==icExoSkeleton(mouse)): exoSkeleton provides "realization limbs" to value-only mouse:
      area:                         interaction:
    - grabArea                      player --> mouse
    - contactArea                   mouse  --> other objects
    - displayArea                   mouse  --> player
    - decorationArea                mouse  --> player
    - ... (?)
    - internalsArea(==valueSlot)    mouse  --> mouse  (a priori, not visible)

  => supervessel{octoMouse{value or expression}}  ... ça fait pas mal d'emballage
    supervessel, when solely cargoing an exoSkeleton, is like an "exoSpirit" possessing the exoSkeleton

*operators are "naturally" reactive: makeReactive([+]) * [n] = [+ n]

**glassMouse (curse): mouse breaks if something illegal is done
**glassMouse (curse): equations: mouse breaks if left side is mutated without having right side mutated the same way
    en fait ici, on a affaire à une octoMouse avec deux "valueSlot"s et un "decorationSlot" (pour le signe =)

**manage simulteanous touches:
    - open touch phase
    - collect all touches
    - close touch phase
    - resolve all touches

**equations: gemini-headed octoMouse: when one operations is applied to left side, it is automatically applied to right side too

13 Mars 2012:
*color gradient between exolimbs  (pour montrer les relations entre exolimbs (ce truc-là, c'est le "toucheur" de cette facade, ou plutôt des internals représentés par cette facade))
  example: yellow-blue gradient between display and contact
***3D-->2D: _canvas lock/unlock_ (à la The Witness): player moves freely in a 3D environment and can focus on boards (which are (in)finiteCanvases)
    edu: one board for each subject   (at least)
    edu: board pov stays where the player left
    fun: wormholes from one board to another (==portals)    3D.location1-->board1.position1-->board2.position2-->3D.location2
   => Ce serait bien de voir un jour ce point réalisé.
   more madness: move 2D object from canvas to 3D HUD (which is a permanent 2D space) and then back to another 2D "true" canvas
   even more madness: 3D HUD is z-cruisable: like the glasses overlay of the hi-tech military.   Write stuff in green to match the cliché.

*touchSlot (active) VS contactArea (passive, delegator)
    => touchSlot.touch(contactArea.delegate)

**compose: create equation: create equation composite from 2 icMathNodes
**poopooMouse: equations: poopoo log: when transforming an equation, the previous version is added to a log (displayZone), so we can see the equivalent equations history

14 Mars 2012:
(**Il y a déjà le concept de greenMouse dans The Witness.

16 Mars 2012: SOLVE ET COAGULA
(Il y a déjà le concept de greenMouse dans les motifs de déverrouillage des téléphones

(((*from audience to vidience: not hearing but interacting

**Z-Puzzle: find the right homeScale using "membrane markers"
    -hardcore: optional marker (marker may or may not be used)  (~téton sorti ou téton rentré)

***Black-box onion puzzle: there is a black area on the screen which contains operators, player has to discover what are those operators. The "onion trick" is that an inner-layer operator can touch greenMouse only after the outer layers have been traversed.
    bbbbbbbbbbbbbbbbbbbbbbbbb
    b[+   2][-  1][+ 7][/ 8]b
    b[+ 4][+ 1][x 9][-   8 ]b
    b[/   10][^ 2][x (-1)  ]b
    bbbbbbbbbbbbbbbbbbbbbbbbb
    the more layers the harder it gets
***Black-box onion greenMouse challenge: the goal is not to snap operators on placeholders. Rather, it is a classic greenMouse challenge. Player has to find a route to attain target. Of course, route could imply coming in and out of black box.
      there is a touch sfx to identify when a touch occurs while in the dark
    easy: operators are contoured

(((comme quoi ça peut parfois être productif d'aller traîner son skate sous la pluie

((on a besoin de mécaniques qui se marient bien avec l'"objet d'étude"

(*en fait l'idéal serait de se poser pendant un certain temps avec quelqu'un pour dépiler still_shute, pour le transformer en quelque chose de beaucoup plus lisible

17 Mars 2021:
*edu: geom greenMouse: [rect shape] * [+ 10] = [rect shape "with 10 added"]   ,  [rect shape] * [x 2] = [rect shape with doubled area]
**edu: unification via variety: _après une certaine maîtrise des concept-challenges, pris isolément_, mettre des instances (aléatoirement) de différents concept-challenges les unes à la suite des autres pour unifier tous les concepts.

(((**loups-garous avec des nombres: les impairs: loups, les pairs: villageois (C'est drôle j'ai toujours considéré les nombres pairs comme plus débiles que les nombres impairs.)

(**une salle de classe, c'est comme dans une salle de concert, t'aurais envie de sauter partout, mais tu peux pas, _y'a pas la place_. L'espace individuel est contraint.

((((FUUUU... donc là je perds du temps à cause d'erreurs du moteur, alors que j'ai envie de programmer des exercices...

0 decomposition operators:
    - prime decomposition             [decomp_product_prime]
    - digit*power sum decomposition   [decomp_sum_digpow]

**A fraction doesn't care about how it's been produced, it has no regard for its past. 1/27 does not care if it's 1/(3x3x3) or 1/(9x3) or (1/3)/9 etc.
    Whereas a litteral expression is nothing but a transformation log.
    A numerical expression is halfway between those 2 ends.

*edu: fractions
    [1 / 20] * [x 2] = [2 / 20]
    [1 / 20] * [x 2] = [1 / 10]
    Il y a deux [x 2] différents ici:
    on pourrait s'amuser à créer des rôles pour le 2 du [x 2]:
      - un qui aime monter sur la fraction   (== qui aime multiplier: [1 / 20] * [x 2] = [2 / 20])
      - un qui aime détruire le dénominateur (== qui aime diviser:    [1 / 20] * [x 2] = [1 / 10])
    et ensuite dire que c'est la même chose.

18 Mars 2021:
*can't escape from curse: split mouse must still be cursed, even when in split form
  - ? every bit is cursed ?
  - ? there is a curse halo ?

0 singleOperatorize (~flatten)
  0	[/ 3] -> [x (1/3)]
  0 [- 3] -> [+ (-3)]
  0 remonter tout le priorityShell...

**black box number challenge (==conditional simplification): what you see is not precisely true
    - [56] is displayed, but internally, number is [4 x 2 x 7]
    - when player does [56] * [/ 8], simplification does not occur, [56 / 8] is displayed (internally it's now [4 x 2 x 7 / 8])
    - when player does [56] * [/ 4], simplification does     occur, [14]     is displayed (internally it's now [2 x 7])
    (hardcore: only last term simplification is allowed: [4 x 2 x 7] * [/ 4] = [4 x 2 x 7 / 4] and [4 x 2 x 7] * [/ 7] = [4 x 2]

((c'est marrant, on peut faire new math.ConstantNode(-2) mais pas new math.ConstantNode(1/2)

((a x (b x c) = a x b x c   does not seem to have the same flavor as    f(a, f(b,c)) = f(a,b,c)   but that's what we mean sometimes. It's like the multiplication is diffused, and "x" is only a separator.
    En fait on est devenus dans tout ce qui est binaire, parce qu'on a continué à vouloir écrire sur une seule ligne et que, dans ce cas, tout élément a une extrémité gauche et une extrémité droite et c'est tout.
    La même chose pourrait être conclue avec le temps qui s'écoule "dans une seule direction seulement".

19 Mars 2021:
  (0 class PriortyShell

((comment appeler l'inverse de l'inverse ?  exverse ? deverse ? preverse ? averse ?

20 Mars 2021:
(((*"universal 7" == 7, _all representations accounted_   3+4, 2.9+4.1, -5 + 12, etc.
** 0 simplification with "keep unsimplified factors order" is not that simple to do

**redMouse: fractions:: add|subtract fraction challenge: split, rework parts, gather

**operator decoration: decorate operator function with simplification function ("same same, but different" :) )

**conductive area operator: (mainly for binary operations (add, append, ...))
    example: [6] * [+]{[4]} = [10]  and [4] is consumed
**greenMouse: temporary rest zone (==SafetyZone): when released in this zone, greenMouse is not reset

**green greenMouse(en français: souris verte écolo): objects which have been produced using greenMouse are destroyed when greenMouse is destroyed
  edu: player may produce helpful representations of greenMouse when trying to solve a puzzle (typically: fraction with prime factorized "ators")

**greenMouse: intermediate target slot (==viaTargetSlot)
    with _the same green mouse_:
      1. touch intermediate target slot(s)
      2. touch        final target slot
    => when greenMouse resets, intermediate touch slot resets too

25 Mars 2021:
**expiring mutation: object resets to previous state on expiration
    edu: fractions: decomposed version is shown for 3 seconds

0 prevent target "exopeek" version from touching target slot

26 Mars 2021:
***BulletMouse (meta-challenge): "Deterministic road to success (==TIM/Eets style)":
    edu: ROAD TO PROGRAMMING
    - Player has no control over mouse.
    - Player interactions are:
        move operators so that bulletMouse run into them
        push start button
          Bullet will then start moving and encounter operators which will mutate bullet.
          Challenge completes if bullet has the right value when touching target slot.
    première forme: "linear"
    deuxième forme: plumbing style: some operators change the direction of the mouse
      easy: value changing operators on one side, direction changing operators on the other side
      hard: {value, direction} changing operators
    troisième forme: not your average bullet: ~"polarization"
      "polarization" operators: when bullet touches a polarization operator, bullet polarization (==color) is set
        example: [* --> blue]
       polarized operators: bullet is only affected by operators which polarization matches bullet polarization
        if the bullet is blue, then a red operator will have no effect
        example: [if(red){   }]
      hardcore: polarized polarization operator: [red --> blue]
        edu: this is somewhat similar to proof construction

    quatrième forme: multiple inputs: 2 bullets, n bullets...
      edu: addition de fractions
*     use conductive area operator _[+]_
      edu: pour la soustraction, il faudra utiliser [x (-1)] sur l'un des deux opérandes
    cinquième forme: [bullet<N> start] is a touchable operator

    sixième forme: slider-controlled time   (give the user some "greenMouse feeling" back)
      only forward, for a first approach

**bulletGolf: getting closer to "real" golf: [stop] operator
    -there is a long road between tee (==bulletStart) and hole (==targetSlot)    (player has to dezoom to see targetSlot)
    -some parts of the golfCourse require the ball to have a certain value, or to have a value in a certain range
    -player has to use [stop] operator to end his shot at a certain position and prepare for a new shot, starting from there

*greenMouse::greenMice: SafetyZone conductive operators:
    fractions:
    edu: 1. challenge with one greenMouse and target slot is right after _[+]_[1/30]_   (addition is prepared)
         2. challenge with two greenMice  and target slot is right after _[+]_
         3. challenge with 3+ greenMice ( reworked(reworked(A)+B)+C )...

**parameters galore conductiveOperator ("conductiveFunction"): [set] color, value, shape
    operator has multiple parameters, _each with a different type_
    so that when operator is actioned, parameters are used:
      [conducted] or default value for the missing

*icPlatform: object released on a platform is added to the platform: when platform moves, platform and objects on it all move together, resize together, rotate together, flip together, etc. (like an adhesive board)
*dropTouchSlot: touch activates when object is dropped on slot

*equation platform:
    ----      ----
    [   ]____[   ]
    [   __=__    ]
    [___]    [___]

27 Mars 2021:
*floodTouchSlot (le contraire d'un dropTouchSlot): when _touchSlot_ is slid and released under an icObj, then touch activates
*shovelPlatform: when _platform_ is slid and released under an icObj, icObj is added to platform terrace

0 platform on a platform

((*conductive operator: there is "true input" (active input),"conducted input"(passive input == context) and output
    => "context operands",  calculer c'est d'abord parser

**snapSlot-based conductive operator: If slots are empty, displayed default values are used. If slots are filled, snapped value is used.

**challenge: cooking table: conductive operators (_[+]_,_[-]_,_[x]_,_[/]_) are in the center of the challenge area. Player has to cook target number using "raw ingredient" numbers.
*conductive operator: when operating
    settingA: consume conducted_operands (~> conducted_operands == input)
    settingB: retain  conducted_operands (~> conducted_operands == context)

(**less code could be written if "generalized proxies" i.e. inheritors, decorators, containers, composites, and any kind of "I contain that kind of thing you operate on" were all managed the same way

28 Mars 2021:
**(*)draw the operator: 1. user draws an operator, 2. system recognizes what they have drawn, 3. drawing is now considered a legit operator

*edu: impossible button: user has to press it 15 times for it to trigger
   this way, player doesn't get the habit of skipping or gets it _less likely_

**upgrade icObj to icObj2:
    upgrade [x 2] to [x 2 / x 2](fraction operator)
    upgrade [x 2] to [x 2 = x 2](equation operator)
    upgrade [x 2] to [area x 2](shape operator)

*edu: fractionOne_operators animation: every 1.5 seconds, operator display swaps (either it shows [x 1] or it shows [x 4 / x 4]). So that subliminally, student gets that value isn't changed.

*edu: gmSafetyZone could be used to "pause" (the pause being either student-initiated or teacher-initiated)

29 Mars 2021:
**challenge: in order: n "sticky" greenMice: we can start with any of them and then stick the others in order
    so that any greenMouse in this challenge is a reactorMouse which then becomes a greenMouseComposite (releasing the composite makes the greenMouse parts go back to their place, and the linker "<" parts are destroyed)
((*C'est drôle ; un truc simple à dire n'est pas forcément simple à coder.

30 Mars 2021:
**eduDemo/eduQuestion: c'est un challenge modifié pour qu'il soit présenté à la classe
    on pourrait dire que c'est le tutoriel
  1 edu: première eduDémo devant les élèves: frac add (:))

**eduQuestion: "What is the value of the GM at the end of the path ?"
**  WOW effect: GM actually follows path when [PLAY] is pressed

**[PLAY] operator is just another operator: Le bouton "Run" dans Scratch est à l'extérieur de la zone de rendu. Dans l'infiniteCanvas, il est à l'intérieur. C'est un opérateur comme les autres.

31 Mars 2021:
*edu: demo: distributivité: [1 + 3] * [x 2] = [2 + 6]
*"atomic fraction simplification" operator (example: [/2 / /2]): does not trigger if simplification by <n> is not possible

***interacting with student's writing: LET THERE BE LIFE
  1. students draws some operators on their paperbook
  2. an image capture device is used to bring the paperbook image to the infiniteCanvas
    a. image is captured (teacher's phone)
    b. image is conveyed through network to computer running infiniteCanvas
    c. image is imported to infiniteCanvas
    d. image is analyzed and parsed: drawings are now legit operators
    (a. and b. can be performed with ChingView)
  3. let's interact

** colored feynman slash
    Il y a du dev à faire à ce niveau là (custom Mathjax tex package)
      edu: each simplifiable factor pair could be slashed with a different color

**tree analysis output variety:
    - mark nodes in-place
    - spoof nodes in-place    (example: ConstantNode(1) becomes MySummerNode(1))
    - analysisOutput object   (with its a structure of its own)

((*Any step is a discovery step. Any step is a hacking step. (bricolage / make things happen). Nothing comme zizi

02 Avril 2021:
**edu: corrigé des exercices: plus facile, plus rapide
    1. importer l'image de l'exercice
    2. ramener les opérateurs adaptés
    3. capture d'écran
    OR even better:
    4. serialization

**decomposition operators: many flavors
    decompose step by step:
      output: primeA x compositeB
        in prime order
        in "easiness" order
      output: compositeA x compositeB
    random decomposition
    recompose
    recompose step by step

**fractions: rational number decimal period
    eduDemo
      gm: [x=1,517...]
      operators:
        [x 1000]
        [decomp:sum something + x]
        [- x]
        [/ 999]
        [show approximative value]
    then same thing with random decomposition
    challenge

**challenge: integer / not integer

*0 edu: any input:
  0 STT(speech to text)
  0 OCR (optical character recognition) (of selected screenArea)
    0 Math OCR lib in js ? => use Emscripten to create a js lib

**reification: "scale" representation (number "is a" thin and long rectangle): "reictangle"
**reification: "duda" representation of a numerical/litteral expression (using colored squares)
  edu: this will pave the way to the first-degree equation resolution process

**shape operator: [x k]: many flavors
    [x 2 <->]  (scaleX: x 2)
      example:
      [] * [x 2 <->] = [][]

    [     ^]
    [x 2  |]   (scaleY: x 2)
    [     v]

    [x 2 diag] (scaleX: x sqrt(2), scaleY: x sqrt(2))

    [x2 (diagonaly copy)]
      example:                  []
        [] * [x 2 diagCopy] = []

**shape operator: reshape ("gravity")
      []
    []   *   [gravity x]  = [][]

    []                    []
  []   *   [gravity y]  = []

**shape operator: reshape using wall collision
      []     |         []|
    []   >>> |   -->   []|
            wall

((*L'idée ce serait de faire passer subtilement cette idée : Si on s'intéresse à la _transformation_, alors a * [x 1] = [a], c'est très différent de [1] * [x a] = [a].
    D'un côté on a une idée plutôt arithmétique (~entiers, cardinal), de l'autre côté on a plutôt une idée géométrique (échelle).
   La commutativité, c'est quelque chose de bizarre.

**R-Puzzle: Rei-Puzzle:  from black unit-length shapes   to colored scaled shapes puzzle
    there are "rei operators" ([+ 1], [x 2], etc.)
    there are color operators ([blue], [red], etc.)     (or even [nextColor])
    the montage area is a gmSafetyZone
    edu: c'est un bon moyen de faire sentir le côté "travail sur l'échelle"(agrandissement, réduction) de [x 2]

*fraction: [x 2 / x 2] rei-edition: this subdivides the reictangle, nothing less, nothing more

*icBloom: composite({core,facets})
  [bloom] operator (==start bloom with touched as core)
  [petal<X>] operator (==createFacet and add to current bloom)
  ? bloom de bloom: à quoi ça pourrait bien servir ?

03 Avril 2021:
*challenge: assign, alloc, dealloc: faire sentir ce que c'est qu'une variable

*homebringer: z-scroll of one object also z-scrolls _related_ objects

(*0 try to have multimouse working on infiniteCanvas

04 Avril 2021:
**challenge: add digits
    this requires "welling", either via operator or using keyboard shortcut

*slotableGreenMouseWell: well has two slots: one slot for the original (input) and one slot for the clones (output)
  so that player can take back the original and put something else in the input slot
**(*)"wellSelection": wellSelected objects will _clone on drag_ and original will keep their place

**edu: keyboard keys statistics:
***IC KEY CONCEPT: "I Am Dismantling in Order to Re-mantle" / "Sorry Engine, I've got a call-up from Master User" / resource everywhere / sheep everywhere ("T'inquiète pas, ça va repousser.")
    En prenant n'importe quel morceau sur n'importe quel objet, je peux créer des compositions intéressantes.
    L'idéal étant de débrayer, si un moteur est concerné, avant de prendre un morceau sur un objet. Mais _ce n'est pas obligé_.
    Embrayer/débrayer (en anglais: engage/disengage, ce qui est cool parce que ça commence comme engine)
    => Les objets doivent être conçus pour être démontables facilement.
    exemple:
      Je tape un texte. Quand je tape la touche "e" du clavier, un objet écouteur de 'touche e pressée' incrémente un compteur et une réification du compteur en forme de rectangle se met à grandir.
      Même chose avec les autres lettres.
      Au bout d'un moment, j'ai des rectangles de différentes longueurs correspondant aux fréquences des lettres.
      J'ai envie de prendre chacun de ces rectangles pour fabriquer un histogramme.
      Je peux le faire en les déplaçant (displace) de leur objet porteur (en l'occurence de l'écouteur de touche).
      Si je n'ai pas débrayé, l'histogramme va être synchrone avec les appuis de touche ultérieurs.
      Si j'ai débrayé (disengage) avant de déplacer, les rectangles étant maintenant déconnectés de leur objet porteur, il n'y aura plus de synchronicité.
        Soit les écouteurs dépouillés (shorn) vont attendre qu'on leur glisse des rectangles de réification ([furbish]) et ils seront readyiés et on pourra alors réembrayer (engage).
        Soit les écouteurs dépouillés (shorn) vont attendre qu'on leur glisse des rectangles de réification ([furbish]) et ils seront readyiés et l'engage se fera automatiquement (.isEngageOnReady == true).
        Soit les écouteurs dépouillés (shorn) vont être réparés
             de façon automatique (.isAutoRepair == true)
          ou de façon manuelle ([repair] operator or shortcut key).
        Soit les écouteurs dépouillés vont être laissés tels quels (parce qu'on ne les utilisera plus).
      Réinitialiser les écouteurs, c'est réparer si nécessaire puis remettre les compteurs à zéro.
    TLDR:
      displace != dismantle
      dismantle = disengage, displace
      repair = furbish, engage
      reset = repair, reinit

**RCMouse: use WASD to move mouse around
    fun: joystick support

05 Avril 2021:
**colorPicker: comment n'ai-je pas pu y penser avant ?

**RCMouse _system_ (à la 'Press Ctrl'): mouse1 touches buttons which make mouse2 move, mouse2 touches buttons which make mouse1 move

**conductive operator, symbol edition: [x [...] [...]]: with this operator, we can build [x [2] [y]], [x [-1] [z]]

**greenMouse: smart additive decomposition * division
    example: [192] * [smart decomp wrt /16] = [160 + 32]
             [160 + 32] * [/ 16] = [10 + 2]
             [10 + 2] * [simplify] = [12]

***YOUR OPERATOR: ask students to imagine an operator of their own

**greenMouse: equations:
  1. classic gm challenges
    0 challenge: get to [x = v]
      0 challenge 1 : 3x + 18 = 54
      0 challenge 2:  3x + 18 = 5x + 60
      0 challenge 3: 5(x+1) - 12 = 13
        0 develop and reduce
        0 continue using the standard algorithm
  2. smart pool challenges: (student has played with the mechanism, it's now time to be a little clever)
    0 challenge: smart pool of operators: some operators are clever (multiply by fraction for example)
  3. choose answer/follow path challenges:
    0 challenge: touch the right answer: resets challenge on wrong answer
      0 challenge 4 : can only get to  5x = 25 	 using operators
      0 challenge 5 : no more operators, you have to do the maths in your head
        0 you have to follow the right path

06 Avril 2021:
*gm: relative numbers: challenge with [- 100] [- 10] [- 1] and their inverse operators
0 [show], [hide]
    show/hide composite

*edu: the equation movie: in the top area of the screen, a movie is shown with someone performing physical operations. at the bottom, play can mimic what's happening using operators.
  example: in the video, we see someone manipulating apples, putting them in bags, moving the bags, picking some apples from a bag, etc.

*edu: on peut amener de façon naturelle les opérateurs [opposé] et [inverse] ([0 -] et [1 /])
    1. on fait d'abord utiliser [+ 2] et [x 2]
    2. on fait ensuite utiliser [2 +] et [2 x] ((et on voit que ça fait la même chose, à part peut-être quand on écrit sans calculer (y × 2, ça s'écrit pas pareil que 2 × y) ))
    3. on fait utiliser [0 -]
    4. on fait utiliser [opposé]
    5. enfin, éventuellement, on pourrait envisager de ressortir des cartons le "petit moins" [-]

**curse/uncurse operators:
    - standardCurse:  curse will withdraw only when withdrawal condition is met   (example: when touching [uncurse(<X>)] operator)
    - singleUseCurse: withdrawal condition is "curse has been consumed" == curse actionates once then withdraws
    - hardCurse:      there is no withdrawal condition
    examples:
      [curse: autoSimplify]
      [curse: autoColorize]

**(*)context operators:: meaning-based operator
    example: [(2y + 10)/2]  *  [10 == 5 x 2]   = [(2y + 5x2)/2]
                              \meaning-based/
      so then [(2y + 5x2)/2] * ["simplify"] = [y + 5]
    edu/dev: this means that we have to anticipate and identify what the student would like to do.
             maybe via a pool, but it must not be cluttered
             What would be nice would be to identify common mistakes and
                propose the operator they would like to use _given their 'mistaking context'_,
                to show them that the rules of maths make it roll not as what they would expect

*greenMouse: exponent operator: [ ²](unary), [^ 2](unarified binary)

07 Avril 2021:
**(*)[meta] layout is meaning. When looking from afar, you know what it's about.
    If it is a challenge about addition, write a "+" sign with the operators/objects involved.
     []
   [][][]
     []
    If it is a challenge about multiplication, write a "x" sign, etc.
  edu: when student thinks about the challenge, subliminally, they will see the symbol perspiring from the layout.

**slice cut: cut image following slice path
    edu: pour montrer les produits de fractions: 24 * [x 1/2] * [x 1/3]

**atelier: neither a challenge nor an eduDemo, but a place where the player can tinker
**atelier::create a fraction
                    [num <- 1] [num <- 2], ...
    [fracWell: ?/?]
                    [den <- 1] [den <- 2], ...
    edu: so that there is a sense of number line, and proportions
          if player touches                                               [num <- 6]
          and then                         [den <- 3]
          player then feels that the numerator is 2 times the denominator
    edu: this seems a boring atelier at first glance but:
            - player can then generate its own fractions to turn sheet exercices into manipulations
            - player subliminally gets used to the assignment operator, and to the relative proportions
            - player does not touch keyboard

08 Avril 2021:
**(*)more kinesthetic feeling of number: touchScreen touches
    shrink/grow: pinch and spread (p-IN-ch"/"p-OUT-ch)
      player pinches/spreads a reictangle in a number bloom : number shrinks/grow accordingly
    2-finger pinch for 1D-scale
    3-finger pinch and 2D-scale

12 Avril 2021:
***ic digitalBootstrap: from basic skills (move the mouse) to advanced skills (spawn, copy/paste, group/compose, protoSlots, ...)
      1. use the mouse:: leftclick
        challenge1: player must handdraw a line from A to B
          this challenge is "greenMoused": if leftclick is released before reaching B, handdrawn line is erased
        challenge2: same thing with obstacles: if an obstacle is touched, handdrawn line is erased
      2. use the mouse:: move object to touch other object
      4. use the mouse:: rightclick
        challenge3: player must handdraw a line from A to B, but point B is not visible on the screen: player must rightclick to pan current visible area
        challenge4: line is a redMouse: player must draw, pan, draw, pan, etc. to reach point B
      5. use the mouse:: scroll
        challenge3: player must handdraw a line from A to B, but point B is not visible on the screen: player must rightclick to pan current visible area

      6. use the keyboard:: spawn object
      7. use the keyboard:: copy/paste object
      8. use the keyboard:: group/ungroup objects
      9. use the keyboard:: compose/decompose objects
      etc.

**mixed-selection copy, paste in outer software (specially Writer, Calc, Draw, etc. (==standard office software))

13 Avril 2021:
**flyTag: when an object enters flyTag's area (range or specific region) and flyTag's text matches object (object type, value, ...) then flyTag will stick to the object, as long as it remains in its covered area.
    edu: on peut imaginer une zone bizarre, pleine de mouchétiquettes, qui servirait à faire un rappel du type d'objet que l'on est en train de manipuler (nombre, opérateur, nom, verbe, adjectif, ...)

** single/multi management: there is a big area where player can choose how they want to play : single or multi
    player creates a round avatar and then manipulates it, as any other icObject, if it is dragged into a roomConnection slot:
    then players' active avatar spawn in a bounded-yet-infinite multiplayerArea
    .____                 __________________
    .  o |               ||o             o ||
    .____|               ||you           p2||
    roomConnectionSlot   ||________________||
                            multiplayerArea
    edu: some challenge may be multi only / single only

**curveLength challenge: Player has to draw a curve from A to B with length in given range
    variant: A to B to C to D, each portion within a given range

*the "* [operator]" process:
    for a mathNode-based operator:
      1. findMathNodePathInObject(icObj)
      2. if a path was found: apply transformation using path
      3. return transformationOutput

14 Avril 2021:
**(*) (madness) ic operating system: "everything is there"
    Sur le même modèle que l'OS dans lequel on se déplace en 3D et dans lequel le bureau, c'est vraiment un bureau.
    Mais ici, y'a pas de bureau, juste un gigantesque tapis d'enfant pour adulte, un bac à sable d'étoiles de travail.

*V-scroll: change selected object opacity

15 Avril 2021:
*(freeDrawn) overlay operator: connect different objects with (drawn) overlay operator, then release
      [     ]  #  [     ]
      [  A ######### B  ] = [A + B]
      [     ]  #  [     ]

*operator: pixel-of-color counter

***eduDemo::spawn wrt context:
    context can be:
      - active selection
      - current location:
        - current pov bounds
        - current subworld (example: the fractions world, the equations world, the adjectives world, the colors world, ...)
      - current activity ("active ity")
      - current time:
        - current "sequence" (example: little red riding hood)
        - current "frame"    (example: the wolf is about to win)
    examples:
      spawn a 2x2 table with cell proportions: my active object
      spawn a multiplication table with starting number: my active object
      spawn the next sentence/the next character of the story

***eduDemo::switch to edudemo keyboard shortcuts: DSI (domain specific input), the input equivalent of DSL (domain specific language)
    edudemoX.automaticallySwitchToDomainSpecificInput = false;
    design: il va falloir définir les touches qui ne changent pas et les touches qui accueillent le DSI


**(*)scripted operator: write your own code in operator's icText field,
      example: if() {} else {}
***scripted template operator: "don't write, just drag"
    snapSlots or platforms to host objects
      example: if(input is [<>]) {} else {}
    operator is functional when all its parts have been filled
    This is a 3-star idea because it enacts "code is data, data is code"
*   truth-value operators: [== 2], [> 2]
      slot-based truth-value operators: [== [<>]], [> [<>]]

16 Avril 2021:
*undo/redo keyboard shortcuts
    dev: this part may not be fun

**greenMouse: create sentence for the image.
    at each step, there is only one valid spelling, but there is no mistakeBomb ("Oh my god you made a mistake"). The sentence simply does not validate at the end.
    Releasing mouse resets sentence.
    examples: [[El] [niño] [esta] [jugando] [en] [la] [calle]].
              [[Le] [chapeau] [de] [la] [dame] [s'envole]]

17 Avril 2021:
**what is "to manipulate" ? use hands and handtools
    - slice (with or without sawcut)
    - tape/glue together
    - fold
    - press/pressure (varying intensity --> varying response)
    - make holes
    - rotate/scale/flip
    - arrange/dispose (move, align, center, ...)
    - superimpose
    - decorate/paint/draw/write
    - bend
    - pin
    - attract/repel
    - copy/cut/paste
    - bag/unbag
    - intrinsic manipulation (shake, press, etc.)
    - capture: photos, videos
    - hoard (i like it, i'll keep it)
    - build worlds, build stories
    - share
    - "make it roll" (domino effect) (display an intrinsic property of an "external composite" ("outrinsic" property)) ((what is in, what is out ?))
    - repeat: same conditions, same results ?
    - "gong" (tap and listen to the sound) ((y'a pas que l'image dans la vie))

**(*)slice anything:: slice mathematical expressions
    a sliced mathNode would create an expression and a "cutout operator" which can be seen as an _incomplete expression_
    edu: this "cutout operator" could be used to try the operator against different values
                .
      [(x + 12) . / 3 + 5] --> [x + 12]   ;    [... / 3 + 5]
                .                              ^_ cutout operator (== half an expression, half an operator)
    dev:
      here the medium is the image representation of the mathematical object
        slice(mathNode.representations.2dImage, imageSliceProps) --> slice(mathNode, mathNodeSliceProps) --> array of mathNodes
        OR
        slice(mathNode.representations.2dImage, imageSliceProps) --> array of images --> array of mathNodes
      but we can do the same thing with the audio representation of the mathematical object
        example: someone saying "three p minus four times z"
          the slice could be done via:
            pausing the player at the desired time
            saying "slice"     at the desired time
          and then we may process the 2 resulting parts

((*edu: objectives: allow _patterns_ ownershipping

**paint: only paint inside activeSelection

18 Avril 2021:
*textured path = svg (shape) + bitmap (texture)

**sliceWell: slice something from the sliceWell and it's automatically cloned
    example: slice a letter in an alphabet board  [ABCDE]
                                                  [FGHIJ]
**sliceClone(): command: slice something and it's cloned

**edu: project: create a comic strip
    pick a sprite sheet on the internet (and maybe create a sliceWell or sliceClone from it)

**edu: solar system (true scale):
    side view
    top view

19 Avril 2021:
dev: il reste beaucoup de travail autour des doubleObjects

***examine,edit,promote: edit code using icObjects  (give a way for people "very far from code" to tinker a bit)
  examine: bring some part of code to the infinite canvas in an ic-displayable form
  edit: play with icObjects to edit logic
  promote: when you're done editing or creating, transfer the object as code in the page script
  dev: forcément, y'a des composants de coeur qu'il vaudrait mieux laisser en lecture seule

***x's island: load the icWorld of other people into yours (be it offline or online)
    if you like someone then you add its world to yours so you can visit it sometimes to see what has changed (some kind of fa-iC-e book)
    there might be a giant hub connecting all worlds (iC-nternet)
    when you add someone's icWorld it could be only a proxy of it, so that when you access it, the true owner, if at home, sees you in and can interact with you
    dev: il faudra des protocoles tout ça tout ça

20 Avril 2021:
**greenMouse:: vectors
    vector transformations are displayed (we can see the 2D path followed by vector's end point)
    [(x ]  *  [  (0 ]  = [(x   ]
    [   ]     [+    ]    [     ]
    [ y)]     [   4)]    [ y+4)]

**greenMouse:: fractions and images: [img1] * [x (2/5) _vert] * [x (7/13) _horiz] = [img2]   How many times img2 is img1 ?

0 setHomeScale so that, at "scale0", object appears to have this size

**(*) img operator: convert to unit clones (img has been scaled and we want to know how much of the original it has become)
    [convert:uc _horiz]: horizontally aligned unit clones + horiz-scaled fractional part clone
    [convert:uc _vert]:   vertically   aligned unit clones + vert-scaled  fractional part clone
    [convert:uc _prop]:   diagonally   aligned unit clones + prop-scaled  fractional part clone
    [convert:uc _rect]: rect of clones displayed in horiz(scale.X (int + frac)) * vert(scale.Y (int + frac)) (four regions)
    [convert:uc _square]: square of clones (total: sqrt(scale.X * scale.Y)) displayed in horiz(int + frac) * vert(int + frac) (four regions)

**anytime there is a math operation to do, use mathNode and operators

**img operator: split   into color component "rects": each "rect" size corresponds to color size in original image (rect can contain transparent pixel if necessary)
**img operator: convert into colorComponent-ordered image
    edu: use image with few colors (3 to 5) to show that when scaling, scaling is distributed to each color

21 Avril 2021:
**click&drag unitCloneScale: grab side control and drag, it instantaneously shows the unitCloneScaled object (== unitClone-converted scaled object)
    dev/ux: outche
     /!\ when doing proportional unitCloneScale: clones will 'overflow' the grabbed diagonal point
      => ? rep_orig / rep_ucs ?
    unitCloneScaled = composite({[unitClone] + fractionalPart}) ...
    edu: so then we can manipulate the "unit-bounded" parts
**icObj.type = "xyloNumber": semi-xylophone which "depth" can be increased by click&dragging while zoomed
  edu: this gives another way of specifying/setting a number

**greenMouse: scale challenge: target is a scaled version of the original object, operators are scale operators
    edu: create a challenge that seems impossible: player has to rotate the object to complete the challenge (and player has to find out this 'solution' by themself)

**vert/horiz scale:
    - wrt object intrinsic coords
    - wrt coords in canvas (=> boundingBox...)
    - wrt operator coord system

*snapRotate: allow only 0,45,90,135,180, etc.

**keyDownSelect: keyDownToggle + select object (then you can keyUp it's okay): scroll now mutates object
    - color: select object while KeyC is down (now you can release KeyC), scroll mutates object color
    so zScroll is the default keyDownSelect

**strokeWidthScroll

((there are ideas,
    then there is development
      which brings the ideas down in the real world
      so there is this discussion between vision persons and preparation persons
      "This may seem easy, looking at it from the clouds, but down there it's a bit more difficult."
      "We discovered this while coding, what do you think about it? Does it inspire you new ideas?"
    then there is actualUse (for example using the software for demos while teaching)
      which brings the features down in the real² world
      so there is this discussion between preparation persons and activation persons
      "The dancefloor is nice but maybe we could add sofas on the side, and bubblegum-scent diffusers."

**machine: distribution board: output is expressed using clones of input zone "vocabulary" objects, each represented the number of times specified in factor zone
        |                                     |
  input |  output zone                 factor | output zone
   zone |                                zone |
      --------------                        ----------------
        |  factor zone                        | input zone
      ver1: input is on left-side           ver2:input is on bottom-side

21 Avril 2021:
**edu: greenMouse: back to good old {[+ 1] [+ 10] [x 2] [x (-1)]}
    propose challenges in which, all else unchanged ("Ceteris paribus"):
      - target  changes
      - initial changes
    this way the students will start mastering this operator set
    then, _when grinded enough_, we can propose another operator set

**Monte-Carlo: spawn disk at random position in rect...

((There is that standing position in The Witness which is important. Students should be standing (more) in classrooms.

23 Avril 2021:
*greenMouse: challenge: distances: when dragging the greenMouse, a carried variable is updated as the greenMouse moves from its starting point. Using [+] and [-] operators, the goal is to attain [target] value.
    when touching a [+] or [-] operator, the starting point becomes the position of the last touch.
    if [-] has been touched, the new distance is subtracted from the previous variable value.
    edu: this could be used to move from hypotenuse to vectors.

24 Avril 2021:
  0 create tutorial directly using the software features
**0 id collisions  !!!

25 Avril 2021:
**serialization: load infinishutes (==serialized states) programatically, treat them as first class objects
    edu: this way teachers could create specific classes quickly, by arranging existing material
    dev: il y aura du travail pour tout organiser, sauf si les composites deviennent robustes

((*faciliter la vie des profs (fabrication aisée de corrigés par exemple) et des élèves (possiblité d'écrire sur l'énoncé numérique (ce qui est très difficile avec un pdf) par exemple)

26 Avril 2021:
((Baba Is You   is a great game: game mechanics + level design + aesthetics (no need to be too pretty, simply be consistant)

**"touchable as a whole": composite.isTouchable == true    and   composite.parts.some(.isTouchable) == false

*edudemo: from 1x1 square to 2x1 rectangle to sqrt(2)xsqrt(2) square : scale, split, join

*image transformation: toColorHistogram(), param: nb_color_boxes for coarse/fine analysis

**3d classroom:: 2d 'infinities'
    - every student has an infiniteCanvas on their table (this is their notebook)
    - every whiteboard in the classroom is an infiniteCanvas
**3d classroom:: extension rooms: those rooms are tailored for the current course: students can leave the classroom and play around in those extension rooms

((*j'ai l'impression qu'en faisant du freedrawing à la souris, j'écris à peu près à la vitesse de mes élèves

*draw over font and then define the result as custom font

28 Avril 2021:
*edu: on bakery operators: It MUST be emphasized that, for human life to be worth it, human life practices are MORE than operations.
       You MAY MODEL them AS operations, but there will always be more in such practices.

29 Avril 2021:
**scale-aware selection (cannot select something whose homeScale is too far from current scale)
**probabilistic operator: [× ¿1-10?]

(suite à l'envie de créer un opérateur "o:scale" avec scale proportionnel en réutilisant les opérateurs o:scale horiz et o:scale vert :
**operator.type == "comp" (operation is a composite of other operation)
    this composition may be sequential or parallel

**"compoper": compositing operator: this operator pipes the operators inside it
  2 flavors: sequential and parallel
    - sequential may have an arrow to precise the order (default orientation: left to right)
      dev: this would mean projecting a key point of each operator on the arrow to determine the order
      edu: this operator would go along well with morphers ([math --> text] [append "!"] [text --> math])
    - when in parallel mode, conductive composition operator may check if operator are compatible (== orthogonal)

***supereasy operator composition: conductive-platform compositing operator
    and, on top of that, supereasy facading: to hide the implementation
    edu: on peut ouvrir le capot et regarder comment ça marche
**(*) spawn "ready to tinker" compositing operator with inner operators (== non-empty compositing operator)

***operator crafting / smart facade : supereasy compositing operator has a smart engine which allows it to facade what its inner arrangement of operators is equivalent to
    bad recipes (with incompatible output / input types for example) would be facaded as "bad recipe"
    edu: [[+ 2] then [x 3]] could be smartFacaded as [x 3 + 6]
    edu: [[+ ¿2-5?] then [x ¿3-6?]] could be smartFacaded as [x ¿3-6? + ¿6-30?] (though we lose information when displaying it that way)

**snap-based compositing operator: un peu moins naturel que le conductive
**text-based compoper: for creating compoper programmatically

**'Z-fallback' operator: when operator2 is slid under operator1 (via zIndex) , if operator1 does not return "success", then operator2 activates

*class Operation {}

30 Avril 2021:
*ux: selectAll / removeAll
     selectAllInPov / removeAllInPov

**modifiers: objects that change the behavior of another object
  dev: this may require a lot a work around platforms

**modifier:: activation condition modifier

**greenMouse X compositing:  "2 and 2 only"-modified compositing operator: compoper is working only when this condition is fulfilled
  3 and 3 only...
  So the game setup is like this:
    |---------------------------------------------------------------------------------|
    |  [1]               [---->]      [---->]      [---->]         [42]               |
    |  initial value         compositing operators                 target slot        |
    |                                                                                 |
    |        [+ 2] [+ 10] [- 1] [x 2] [+ 12] [/ 2] [+ 7] [+ 40] [- (-1)] [/ (-3)]     |
    |                      operators to be composed                                   |
    -----------------------------------------------------------------------------------
  another interesting activation condition modifier: all compositing operators must be filled for target value to be 'touchable'

**edu: randomness has drawbacks, BUT it has this key feature: players cannot "paste" the solution to the other players, they have to explain the mechanics,... which make them teachers :)

**(*)conductive-platform activating operator: "actop": a platform whose sole purpose is to forward the touch to the operator that's inside (which could not be touched without doing this). That's what is meant with the word "activating".

**modifier:: transparencer/obscurizer: an operator with these modifiers mutates what it touches into something transparent or obscure (== we can no longer see what it is)
  different flavors: when touched (permanent) / while touched (temporary)
  edu: a obscurizer actop would require the player to remember what the conducted operator is, when holding the greenmouse (look at the game setup above and replace the compopers with obscurizer actops)
      the player may pick the obscured operator out of the actop to give it back its natural appearance, but the player won't be able to do it when holding the greenmouse

(edu: we could imagine a practice phase in which the player can fail a lot and then a course phase in which the player tries to have lowest overall golfwise score

01 Mai 2021:
**(*)literal compositing operator: operator priorities are taken into account
  edu: to make a link between the "operator mindset" and the "literal expression mindset"
  edu: [[+ 2] then [x 3]] could be smartFacaded as [+ 6]
                                                or [+ 2x3] with 2x3 appearing in a different color
  edu: [[+ ¿2-5?] then [x ¿3-6?]] could be smartFacaded as [+ ¿{6-30}?] (though we lose information when displaying it that way)
                                                                      6 8 10 12
                                                                           9 12 15 18
                                                                             12   16    20  24
                                                                                15      20       25    30

02 Mai 2021:
*presets (for users who don't like z-scroll by default)
    presetA: selected + scroll       = z-scroll

    presetB: selected + scroll       = scroll
             selected + shift-scroll = z-scroll

    for users who prefer selecting with right click, ...
    etc.

*(*)from group-based multiSelection to composite-based multiSelection
      highlight cargo objects
        icObj.isCargo
        highlight parts when cargo object is composite

**show fading border animation when trying to select an object whose homeScale is too far from current pov scale
  so that user understands that their selection attempt failed

(composites, over and again:
***Sticky release: when sticky-releasing an object S over an object O, a composite is created whose parts are: [O, S]
    this way we can create complex composite very easily
    target recipient is highlighted
    ux: keyboard shortcut is: S
      first press activates sticky release behavior
      next presses cycle to next target recipient
      (Esc key cancels sticky release behavior
    dev: all this ux could be then reused when editing ngraph.tree

    0 find an easy way to show/hide composite handle (because a lot of them will be created)
    0 toggle composite recursive move amplification

**(*)Sticky FreeDrawing: drawing over an object in "Sticky" mode creates a composite whose parts are: [object (original), freeDrawing (decoration)]
      edu: this way we can type text, and then decorate the symbols by freeDrawing over them, and then move the decorated text around, all in one go.
      edu: same principle for geometrical figures, which we would enrich via freeDrawing

**Replace release: when replace-releasing an object R over an object O, R "now replaces" object O
    - in a composite C containing O: O is removed and R is added. R's 'space properties' are set to O's.
    - elsewhere: same principle (we consider canvas as root composite)

**Decoration "Frame" (Begin/End):
    1. user select an object O
    2. user begins decorating (==decoration_begin())
    3. user creates objects
    4. user ends decorating   (==decoration_end())
        a composite D is created, whose parts are [O, ...created objects]
        if O was part of a composite C, D now replaces O in C

*Bloom decoration: add representation to a bloom object via decorating: i.e. decorate + bind

(0 organiser un concours de création de 'peinture profonde'

***(*)inner recording: start recording, move stuff around, do operations, stop recording: a record object will be created. It is an "animation" operator (it operates on canvas objects to recreate the recorded animation)
      recorded animation == actionSequence
      multiple flavors for the recording:
        pov:
          - pov is part of the recording
          - pov is not part of the recording
        frames:
         - discrete interval frame recording --> tick tick tick...
         - meaningful keypoints recording    --> bezier curve interpolation
      multiple flavors for the operator:
        - video-like
        - slider-based
      edu: this way we can roll the film back and forth to the students
      dev: this is gonna be tough
        eventSourcing
        compress moves: FourierTransform, Bezier curves
      game: we can then create challenges in which a greenMouse can press play button so that it makes other objects move and then greenMouse can interact with those moving objects and attain target
      we can record the activation of an animation operator, etc. omg
      we can split an actionSequence and join actionSequence chunks
    (Braid in iC, lolilol
    Event sourcing vs Command sourcing
    actionSequence may not be playable if objects are "too far" from the record initial configuration (== initial "revision")
    [rec reset] operator to put back objects in record initial configuration (== "update to revision"), so that actionSequence can be played
    Red dot on top left HUD to indicate that recording is ongoing
    edu: experiments with periodicity: Does this actionSequence comes back to the initial state when repeated a certain number of times ?
    semantic-recording: system analyzes what has been done and only stores "semantics":
      example: "smallest number was added to greatest number"
      so if you play it in another context, it will try to apply its semantic program on the working objects
    game: record then stay pressed on [activate] then some operators will be active when record is played
**polysync recording: until the recording has ended, all object moves "start at 'time zero'"
    this allows keyframing multiple objects: {1,2,3} --> {1',2',3'} --> {1'',2'',3''}
**"almost time zero"(== "time zero +") syncing:
    example:
      recording 1 : obj1 split into {obj2 + piece1} and move piece1
      recording 2 : obj2 split into {obj3 + piece2} and move piece2
      when the two recording are "time zero +" sync'ed, what we see happening is:
                    obj1 split into {obj3 + piece1 + piece2} and move piece1 and move piece2
      there are sync'ed but recording1 still starts before recording2: recording 2 is brought "as close as possible" to recording1: recording2 starts as soon as obj2 is available

04 Mai 2021:
**(*)program by tagging: Baba #[is greenMouse], rock #[is operator], flag #[is target] (à la Baba is You)
    tags are sticky by default
    programming happens in 2 phases:
      1. create objects   (==spawn)
      2. assign behavior  (==tag)
    edu: this way, teachers and students can easily create challenges

**scale tracks: an object following the track (==part of a function plot) will scale along accordingly
    example: linear track, exponential track
    many flavors:
      - hovered  track: the track is below, but it's not physical, it's more like an idea, it can be ignored if crossed orthogonally
      - clinging track: the track is physical, and when getting too close, you are clung to it and must follow it till you find an "untrack opportunity" (like a Y)
    those tracks may convey a particular scale flavor: scaleX, scaleY, propScale, etc.
    edu: that would be a way to become familiar with function plots and variations
    dev: une sorte de snap dynamique

(Maths DJ: when enough challenges, edudemos, features and worlds will be available, maths deejaying will become available (propose circuits in compositions)

05 Mai 2021:
*3D virtual classroom:: group fork: 4 students fork the current classroom: same room but other students are no longer visible
    then at some point we could merge the different forks (for example: each group has a dedicated whiteboard to write on, a dedicated area to build things in)

**sticky tentacle: click on point in object then drag, a sticky freedrawing starts with the pointed color at clicked point (=="tentacle")

**top-right corner button: toggleTouchDevice (switch controls to touchDevice mode)

*icObj.type = "pov";
  edu: easily create transitions: move from pov1 to pov2
**icObj.type = "link";  A link is simply a line between the 2 objects
**easyLink: freeDraw a line between 2 objects and then proper link is created

**conductive link: when an object is operated on, all "conductive-link"ed objects are operated on too.
**challenge: link, operate, link, operate...

**composite-link: link is composite handle

**area link: link between 3+ objects

06 Mai 2021:
edu::chemistry: using conductive operators (example: [+ [CO2]])

07 Mai 2021:
user-initiated command (user --> obj) VS obj-initiated command (obj --> obj)
    example: user moving obj via holding  VS  touchSlot operating on obj when touched

0 local eventstore: "connect to oneself"

((the vision is to provide everyone easy-to-use powerful tools:
    provide easy animation recording to everyone would be so nice

**(*)oob clone (==out-of-body clone): when grabbing object, you don't move it but instead you extract and move an out-of-body clone of it which can then interact with [move] operators, which operate on "real-body" obj
  =>=> statueMouse

10 Mai 2021:
*burning (m/h)ouse: raisonnement par l'absurde: when the chain of equivalent transformations gets to a statement we know is false, all the poopoo statements burn backwards to end up "destroying" the hypothesis we now know was supposed wrongly.
*[x2 / x2] operator applied on fraction reictangles: numerator is multiplied and denominator is multiplied so that the bloom now appears bigger, but it's the same fraction.

11 Mai 2021:
(expliciter la subtilité: lever les ambiguïtés:
  opérateurs de séquence VS opérateurs d'expression
    avec les opérateurs de séquence,  la priorité des opérateurs est décroissante suivant le sens de lecture
      3 +S 4 xS 5 -S 1 = 34
    avec les opérateurs d'expression, la priorité de chaque opérateur est fixe
      3 +E 4 xE 5 -E 1= 22
  "petit moins" (unaire) et "grand moins" (binaire)
  (ça vaudrait peut-être le coup d'essayer sur quelques élèves

12 Mai 2021:
**time composition of icReplay objects: we display a spatial representation of time
**ghost-based programmable [record/replay] operator: ("oob clone meets record"): user can grab a ghost from the operator and produce a path with it, then any 'free' object(==unheld, user-aloof (nothing to do with "free" representation)) touching the operator will follow the recorded path

13 Mai 2021:
**poopoo path:
    - manual (record{ grab move poop move poop move poop move release }) where poop actions are user-initiated
    - auto (==throttled)
      - every <length>, poop action is triggered (be it a spatial length or a time length)
**poopoo vector path: poopoo_{n} orientation is determined by vector(from: poopoo_{n-1} position, to: poopoo_{n} position)

**"keyframe programming": polysync-recording sequence: record_start/{next_keyframe_start}*/record_end
    edu: easy creation of complex animations:
      example:    on top: [1] --> [ 1 ][ 1 ][ 1 ]
               at bottom: [1] --> [<---- 3 ---->]
    edu: pour expliquer les tris aussi, ce sera bien. On pourra enchaîner chaque étape.

**(*)"define" operator via recording (=="def by i/o[]" programming) (Inductive Logic Programming)
        let's suppose it's a unary operator, whose behavior we want the machine to understand
          1. we prepare an object in a desired state: inputX
          2. we record our making the object interact with the operator, and then we edit the object so that it's in the desired outputX state
          3. we end the recording and some magic configures the operator so that it now transforms inputX to outputX
        we may do multiple recordings to disambiguate: inputY * [op] = outputY, etc.
      edu: teach relative numbers: define operator via 4 * [op] = 3 and see what 0 * [op] equals to.

*contextual operation (=="injustice" operators): what if 2 objects are similar, but as one is grabbed from the blue area, while the other is grabbed from the green area, they now, when operated on, yield different outputs.

**le glitch du replay while recording: "object is somewhere along that path": on peut surement faire quelque chose de sympa avec cette bugfeature

**activate(==enable) VS actionate(==trigger)

**(*)machineGunReplay: replay 1000 times, and all that, in 5 seconds (==supereasy iteration)
    edu: pour montrer des tirages au sort: au début on le fait doucement, puis on enregistre une transformation et on la refait plein de fois
        on peut mettre un écouteur sur la valeur produite pour générer des histogrammes
    edu: pour montrer des évolutions de systèmes non-linéaires
        on peut mettre un écouteur sur la valeur produite pour générer un graphe de fonction
    ux: peut-être gérer le cas où ça crashe, essayer de contenir l'explosion. Cloisonner la zone pour protéger les objets autour au cas où.
**edu: pretty loop: replay (n-1) times then, for last iteration, replay cropped chunk(==from start to destination keyframe (which was marked during recording))
          when recording the sample, ensure that "nothing happens" when in the "moving back to the start"-phase

**conditionally-activating conductive platform: operators inside it can touch incoming object if and only if the condition of the platform is met by incoming object
conditionally-activated operators:
**[break] operator: when in the "moving back to the start"-phase, touching this operator will end the loop prematurely
    the breaking of the loop is reified by the object being left next to the break operator, like a poopoo

*[continue] operator: go back to loop starting position
    dev: find a path which is short, safe (==without any operator on the way) and pretty(== round-edged) to go back to the starting position

**(*)[move] operator:
  many flavors:
  - exo-level [move] operator => miniScene transformation: in order to depict a [move] operator, we can use a miniScene in which, when touched by the [move] operator, an inner object (the "performer") will move according to the [move] operator (the miniScene has its own coordinate system)
      edu: when introducing this concept, it would be nice to use a small and simple miniScene in which the performer is almost alone (you may put a few rocks and trees, or the coordinate system axes, in order to notice the performer move)
  - same-level [move] operator:
      - when touching a non-part-of-a-composite object: object is moved accordingly
      - when touching a composite object and one part of it is the performer: performer is moved accordingly
          consequence: when touching the supervessel: performer cargo object is moved accordingly in supervessel. So the general impression is that the held object still moves, even if held.

**[loop move] operator, [pretty loop move] operator

14 mai 2021:
**[poopoo-path move]
    many flavors:
      - consuming: path is erased as perfomer moves
      - permanent: path stays there and many objects can follow it simultaneously

**cart move/cart controller: object is in the cart (==platform). Cart follows track. A scrollbar based on a small representation of the track (for example: a straight line or a loop) allows user to control cart move along the track.

**stepmania-like pace line: the "now" line progressing on a music partition
  edu: build choreographies with students
  edu: a bloom petal for the object "time". The pace line reifies the passing of time.

15 mai 2021:
**[if] operator/[switch] operator in railway track (=="program")
    - highlight the "chosen" track and darken the others

(la notion de variable ou d'objet (==espace mémoire, rétention) est plus ou moins déjà présente chez les élèves.
    Quand ils écrivent 4 / 2 = 2 / 2 = 1, en fait ils voudraient écrire: [[4]] / 2 --> [[2]] / 2 --> [[1]]. C'est-à-dire une séquence de mutations d'un même objet. Ils veulent décrire un morceau de vie de l'objet.
    Peut-être que cette notation ("avec cadre et flèche") leur permettrait de faire la différence entre :
      les 'performances'(auxquelles ils sont habitués): Maintenant, je fait bidule sur truc et il devient machin.     ((Relié : utilisation,  action,   évènement,    exécution,    instance,   apply(f, args),   now,       vie courante
        sémantique séquentielle
      les égalités                                                                                                    ((Relié : propriété,    règle,    opérateur,    programme,    classe,     f,                anytime,   loi
        sémantique arborescente
    Une autre façon de faire des maths, c'est de regarder ces allers-retours entre performances et égalités.
    Petit à petit dans la scolarité, on passe d'un système de notation {performance: A signe égal B (qui est bancal), propriété: Si X alors Y}, à un système de notation {performance: la double flèche d'équivalence (ce qui est toujours un peu bancal), propriété: quantificateurs et relations (dont le signe égal fait partie)}
    En fait, c'est pas très clair toute cette histoire. Du coup, c'est normal que ce soit pas clair pour les élèves.
      On devrait peut-être noter op_symbol__sequential avec une flèche dessinée en dessous ((et l'autre avec un arbre en dessous mais ce serait peut-être un peu trop)).

**zeroperator (=="side-effect"-ator, ==procedure, ==non-args function, ==arg-insensitive operator): what it does is side-effect only.
    edu: on pourra toujours me dire qu'en fait il y a un argument: l'espace entier (voire même l'espace-temps entier (quand on joue de la musique par exemple)),
          puisque les effets de bord reviennent à des mutations de l'espace qui contient l'objet "touché" et le zéropérateur.
         il est bon de le préciser, pour planter un cadre fonctionnel serein dans la tête des élèves ("all functions are one-argument functions").

*actionator segment: this pace line actionates any actionable object it touches
  edu: build choreographies _for the machine to perform_ (or, more likely, for students and machine)

**game: Anisotropic music partition: the partition is a 2d arrangement of music playing zeroperators.
    an actionator segment can traverse the partition following any slice path the user wants: each traversal will result in its own music
    The game is to find the right path.
    different flavors:
      straight path
      curvy    path
    edu: this game is close but not exactly about dot-product
    this game can have a lot of variants:
      visual:
        superposing images instead of playing music, display fireworks animation, etc.
      audiovisual:
        sync image displaying with sound playing

16 mai 2021:
**replays, many flavors:
    from now:
    - telekinesis:     replay only moves, inner interactions can happen
    - mutationStory:   replay only 'operator encounters'
    - oldtimes:        replay all but ignore elements that were not there when recording was done
    from the past:
    - closureRollback: rollback to record starting event and replay all (== everything "in closure" is rolled back, (==related side-effects))
                          everything outside this spacetime closure is kept the same

17 mai 2021:
**pov-capturing object: moving object also moves pov    ((c'est un peu la mécanique inverse du z-scroll))

**populator: when actioned, populator spawns object(s) in the canvas
    la diversité des populateurs est a priori très grande:
      - certains vont être des zéropérateurs
      - d'autres vont prendre en paramètre l'actionnateur pour faire naître des objects
          donc on peut imaginer du clonage, de l'anisotropie, ...

**(*)autogen system: "when actionator meets populator":
    while(something interesting may happen)
      0. actionator moves and meets populator
      1. actionator actionates populator
      2. populator creates a new object, for example another populator, hopefully in front of the moving actionator
    edu: this system will allow emergence

**"different-different but same": enforce equality of icObjects by "composite binding" them   ("Tous dans le même sac.")
    example:
      Dynamic geometry
        Say we have:
          segmentAB: {pointA, rectAB, pointB}
          segmentCD: {pointC, rectCD, pointD}
        We can implement the requirement "pointA is the same as pointC":
          - assign the same coordinates to pointA and pointC    ("align")
          - create a composite
              which contains pointA and pointC
              which contains another point, pointX, above pointA and pointC, with pointX.isMobile == false
        Now when user moves pointX, pointA and pointC move as if they were a single entity

18 mai 2021:
(tree == state, sequential == event-sourcing
**icObj insensible au roulis: l'objet s'oriente de manière à garder son bottom dirigé vers le bas de l'écran

**[sym: <X>]     operators: apply symmetry to obj
**[timeReversal] operator: apply time reverse symmetry to obj

**"dessine moi une horloge":
    0. spawn a [+ 1] operator and a [[0]] mathNode
    1. record mathNode move: sideA --> * [+ 1] --> sideB,
      and generate [forward] and [reverse] replays
        default [forward] may spawn at first
        then to get [reverse]: clone [forward] and  symmetrical
    2. create a sequence operator [[forward] [reverse]]
    3. create a loop [loop: [sequence]]
    dev:
      sequence and loop operators may ease the animations

((dreams as another event track, the innerEvents, the "semantic" events
(body evergoing reconstruction is functional, rebuild_cell(rebuild_cell(rebuild_cell(...))) => event sourcing, and yet we consider ourselves as a state

(((Is it necessary to run the courses in that way, in order to grasp the full thing ?
    1. be taught things the wrong way
    2. realize they were wrong
    En particulier:
      la précision quand on utilise un langage: au départ, on dit les choses de façon grossière
      l'orienté-objet pour finalement revenir vers le fonctionnel

(edu: il faudrait que [2 x] [[3]] et [[3]] [x 2] aient des significations différentes
  proposition:
    [2 x] [[3]] serait la signification "clonage": 2 pommes                 (application d'un adjectif numéral)
    [[3]] [x 2] serait la signification "échelle": 1 pomme agrandie 2 fois  (application d'un adjectif qualificatif d'échelle)

19 mai 2021:
**edu: le "multiplier numéral" VS le "multiplier échelle":
  on peut créer une représentation spéciale pour les fractions:
    en bas:  un bloc tout seul, avec un nom : le _bloc nommé_.
    en haut: des blocs, sans nom, mais de la même taille que le bloc nommé. Il y en a un certain _nombre_.
  L'important pour cette bloom c'est la longueur des blocs. Un _bloc nommé_ [1/3] devra avoir une longueur trois fois plus petite qu'un _bloc nommé unité_ [1].
    exemple:
      Une représentation de 4/3 :
      [     [   ][   ][   ][   ]    ]
      [     [1/3]                   ]

  Avec cette représentation, on ramène deux types d'opérateurs:
    les opérateur   numéraux:   qui agissent sur le numérateur.
    les opérateurs "nominaux":  qui agissent sur le _nominateur_.   (ou on pourrait dire opérateurs "escals" (==d'échelle))
      d'un point de vue mathématique, pour les fractions, on a nominateur == 1 / dénominateur  (ici le préfixe "dé-" est interprété comme inversif : si on multiplie par le dénominateur, la fraction n'a plus de nom (==le nom par défaut (=="unité")))
    exemple:
      [     [   ][   ][   ][   ]    ]     *   [x 2: via num]   =  [     [   ][   ][   ][   ][   ][   ][   ][   ]    ]
      [     [1/3]                   ]                             [     [1/3]                                       ]

      [     [   ][   ][   ][   ]    ]     *   [x 2: via nom]   =  [     [        ][        ][        ][        ]    ]
      [     [1/3]                   ]                             [     [   2/3  ]                                  ]

    et
    les opérateurs de conversion ("to"):
      [     [   ][   ][   ][   ]    ]
      [     [1/3]                   ]
      *
      [nom: to [2/3]]
      =
      [     [        ][        ]    ]
      [     [   2/3  ]              ]

  En fait, cette bloom a un énorme inconvénient: dans cette notation, on met le nominateur en bas alors que dans la notation fraction, c'est le dénominateur qu'on met en bas.
  Peut-être qu'une version gauche droite serait plus adaptée:
    [ [1/3] [   ][   ][   ][   ] ]
    pour petit à petit passer vers
    [ [1/3] * [x 4]]
    et arriver à [4/3]
  Un autre inconvénient: on utilise une fraction pour le nominateur...
    On peut s'en sortir si on définit proprement [1/n]

    [     [        ][        ][        ][        ]    ]
    [     [   2/3  ]                                  ]
    peut être déplié de cette façon :
    [     [        ][        ][        ][        ]    ]
    [     [   ][   ]                                  ]
    [     [1/3]                                       ]

  Je ne sais pas pourquoi mais, toujours est-il, j'aime bien cette notation.
  Notation sur papier:
    on met un nombre entier en haut, une fraction en bas et entre les deux une barre qui aurait la forme d'un "sigma orthogonal aplati"
  exemple:

                                                 xx
                                                 x
                                               xx
                                              xx
                                             xx
                                            xx
                                           xx       x
                                          xx        x
                                          xxxxxxxxxxxxxxxx
                                                    x
                                                    x
                                                    x
                                                    x

      ┌────────────────────────────┬─────────────────────────────────
      │                            │
      │                            │
      │                            │
      └────────────────────────────┘

                   xx
                  xxx
                xx  x
              xx    x
                    x
                    x
                    x
                    x


             xxxxxxxxxxxxxxx


                 xxxxxxxx
                        x
                        x
                    xxxxx
                       xxxx
                          x
                        xxx
                  xxxxxxx

    ((ou peut-être qu'un sigma miroir orthogonal aplati serait mieux car on lirait directement 4 "1/3" : quatre tiers.
        4
        _______
            |_|
            1/3
      mais du coup ça commencerait pareil qu'une fraction visuellement...

("sémantique syntaxique": quand je veux faire comprendre quelque chose à propos de la notation elle-même

**draw content VS draw meaning: one can switch between two input modes: user wants to create content (==objects) or user wants to create behavior(==moves, operations,...)
    example: user could tell the computer to create a [replay] in reverse from a [replay] "going forward" by drawing an arrow that shows an object movement that is the reverse of the normal "forward" object movement

20 mai 2021:
(Some researcher is actually named Shute!: Valerie J. Shute, https://myweb.fsu.edu/vshute/

**ghost-path greenMouse: for deferred feedback: student draws the path and _afterwise_ the mouse follows the path
**Braid-like reverse (==keyDown reverse): "hot-reverse" a grabbed greenMouse
    0 à essayer pour voir ce que ça donne
    dev: mouse pointer may shift wrt physical mouse position

****pathmade operator: create operator from path (path == move-events-only replay)
        operator does this: make object follow path, making it encounter existing operators
        yet, we don't see the object moving when touching this operator, we see the mutations on anything but the object position
        for simplicity, path start is where operator will spawn
        after it has been created, pathmade operator's path shows on mouse hover (or on two-finger hover for touchscreens)
        encountered operators may be loop operators
      edu: this way, we can create operators in a blink, and use them to build other operators, etc.
      edu: we may create specific applications (== apply) using a cart loader : arguments are put in the cart and the loaded cart encounters the operator we want to apply to the args
      edu: this way, we can create functions of functions (operators taking operator as an arg)
      edu: this paves the way to creating a new programming language
      dev: this is gonna be tough, but this is gonna be it
      2 flavors:
        - off-ground: path is parsed into a function when operator is created
              if encountered operators are moved or replaced: the operator still plays as if the original encountered operators were there
        - grounded == path-treading
          2 flavors:
            - conveyor: touched object is moved along the path
                operator leaves performer at end of path
                so it's like "function + goto"
                2 flavors:
                  - original object conveyor
                  - clone conveyor
            -"possessed_geminiShade"-based: a gemini shade moves along the path and its mutations (everything but position) are forwarded to the original touched object
                if encountered operators are moved or replaced: it will result in the pathmade operator behaving differently
                (here Papert's idea of "screen as a data type" is realized
                we could replay:
                  - at original speed                (==timing does matter):     to explain, to debug, or to reify async operations
                  - way faster (== as fast as possible, timing does not matter): to use it productively, even it makes us somehow forget how it works internally

              edu: we can then create trees of pathmadeOperators, and maybe treer things
      sync/async:
        sync : waits for any operator along the path to complete
        async: does not wait for completion, mutations may happen anytime

      procedure/function:
        procedure:        object is mutated along the way
        "pure" function:  object is replaced by function's output when function has finished
        edu: this way we can explain state and the different between state-based and functional programming

    0 from svg path to move events sequence
    0 from move events sequence to svg path

      edu: "ghost-path greenMouse" can now be put one step further: "tailored pathmade operator creation"   ("Donne moi une fonction qui résout ce problème")

      ((The Witness meets Braid ^^))

      edu: we can change function parameters by equipping the performer ghost_rep with a reactor
      edu: recursion can be enacted by making pathmade operator be encountered along its own path
      edu: recursion could also be done via cloning "everything needed" into a lower area, and continue execution there, etc.

**conveyor seam: if two conveyors operate simultaneously on the same object, ignore the conveyor which is closest to its end

*event injection: inject add1 in move move move... sequence
  0 inject an event which stalls the object for 1 second

21 mai 2021:
0 dessine moi un mouton de fonctions (using visible path pathmade operators)

*music: frequency gradient operator:
    top, red:      treble
    bottom, brown: bass
*music: notes circle: 12 operators are disposed on circle, to play a note one may:
  - cross the circle:
    - from inside  to outside
    - from outside to inside
  - bounce:
    - stay inside
    - stay outside

**icEngined.engine = ProjectileEngine()
**icObject.type = "projectileThrower"
    ? when wrapped in a pathmade operator: where should we the projectile be shot from ?

**icObject.type = "eraser"
    single-use vs everlasting
    projectile eraser:
      example: destroy possesed_ghost_rep of pathmade operator while it is running by throwing an icEraser on it

**edu: 0 pathmake all operators using [clone] and [-], and [[0]] and [[1]]

**my deck of operators: student chooses or creates a deck of operators and then tries to complete the challenges using them (of course pathmade operators can be 'raised' from the starting set)

**icObj teleportation: while moving icObj, enter freeDrawing mode, the icObj does not move but the cursor moves, then leave freeDrawing mode: icObj teleports to cursor

22 mai 2021:
**modifier: inject condition inside looping conveyor to transform it into a while loop

**behavior:pickAndDrop: pick object X and drop on object Y
**icObj.type = "pickAndDrop"  (une version incarnée du comportement pick and drop)

**(*)le ramassage des pommes: réapprovisionner le canvas avec de nouvelles pommes et relancer
    tant qu'il reste des pommes:
      le pickAndDrop performer ramasse une pomme à chaque tour de boucle (la pomme se colle à lui et il la ramène au début du parcours où il la dépose dans un panier)
      quand le performer a tout ramassé la boucle s'arrête
      On peut alors
        ajouter à nouveau des pommes sur le parcours et relancer une nouvelle exécution
        ou enlever des pommes avec la souris et regarder qu'il s'arrête bien quand il n'y a plus de pommes
      many flavors:
        - condition is local (==performer-related): performer knows that there isn't any apple left to pick (because it has not found any on the path)
        - condition is global:                      "global" knows that there are apples to pick
    tant qu'il y a moins de 5 pommes dans le panier
    edu: pour expliquer la complétude: mettre une pomme à un endroit qui est dans l'enclos mais qui n'est pas sur le trajet du performer: le trajet n'est pas couvrant

**function::showstopper: any process involving object X must stop now
    so this may be used to terminate a looping conveyor operating

**challenge: show me a path/ show me the shortest path: draw a path to transform X in Y
    pleins d'opérateurs éparpillés, un objet de départ et l'objet qu'il faut obtenir
   edu: pour aller vers les fonctions (voire les polynômes): draw a path to transform X in X', Y in Y' and Z in Z'
   edu: pour aller vers le calcul littéral: find 2 different yet equivalent paths

**whileTouch slots: comme quand on reste appuyé sur une touche d'un sampler, le sample continue de jouer tant qu'on relâche pas la touche

*[tupler] creates tuple [[{A:, B:}]]

***graph by inputting: [pathmade op] then [graphConveyor]:
    when [pathmade op] touches [[input]], [graphConveyor] sets its path to put [[output]] at coordinates corresponding to [[input]]
    dev: ça va encore être un peu sportif dans les coulisses
    edu: pour expliquer entre autres la linéarité, la non-linéarité, la fonction exponentielle
    edu: avec cette façon de faire, on reste très proche de la réalité "calculer reporter" que l'on peut faire avec une calculatrice et une feuille de papier

    (a more explicit yet more complicated version:
      [conveyor]         }
                         }  then [tupler] then [graphConveyor]
      ["input" conveyor] }

23 mai 2021:
**write the function on the object:
    example: perimeter conveyor
      ----[+ 5]----
      |           |
    [+ 5]       [+ 5]
      |           |
      ----[+ 5]----

*edu: EXPERIMENTS before EXERCISES: before giving them exercises to do, give them experiments to do
  l'apport de l'ordi est le suivant: cette activité, qui devrait normalement être une activité un peu barbante à la calculette, devient une activité facile et rapide à faire
  exemple: faire [[5]] * [+ 3], faire [[-5]] * [+ 3], faire [[5]] * [+ (-3)], faire [[-5]] * [+ (-3)]
  Si on veut faire une expérience du genre "faire [[5]] * [- 3] * [- 7] * [- 5] * [- 10]", on peut déjà avoir disposé les opérateurs de manière à ce qu'on puisse tout faire en un seul mouvement
    (peut-être pas forcément une ligne droite pour prendre le temps de voir ce qu'il se passe à chaque étape)

**icObj.type = "pen"
    penUp, penDown etc.
    edu: pen + conveyor(s) can be nice

**magnetic generation: mousedown with empty supervessel and touch generator operator: generated object is now in supervessel cargo, which will be dropped on mouseup

*operator's own supervessel / disposable supervessel: maybe, at some point, we'll want differentiate supervessel and platform, by giving them slightly different meanings and behaviors
    supervessel is like a the magnet  of a magnet crane
    platform    is like a the flatbed of a flatbed truck

(OMG: I'm such a copy! Seymour Papert last week, now Ivan Sutherland: https://www.youtube.com/watch?v=6orsmFndx_o
  (so funny actually, all that is so old, so bright, yet nobody seems to have cared! (except some people of that distant time)

**constraints / constraintsSolver: comme dans la vidéo de Sketchpad, on met des contraintes sur une figure puis on la fait toucher un opérateur [solve constraints] qui nous donne la version résolue
    - deux nouveaux types opérateurs: [constraints::add] et [constraints::solve]
    edu: bien sûr, on peut cloner la figure avec les contraintes avant de la résoudre pour afficher les deux versions
    - une nouvelle représentation: rep_constraintsSolved

praised be thy Doug:
**easy editing of documents by diving inside, editing (for example drawing) and then moving outside
    there is a quantization of zoom levels
**Database of links: either click links or portals
**Networking: allow collaboration on the same location in the canvas

24 mai 2021:
**"full spectrum" composite: all representations or all shades, r_official excluded, are parts of a full spectrum composite
    so when you destroy the composite, you destroy the full spectrum of objects

(((is the shade of a shade still a shade of the original ?

25 mai 2021:
*pov, superpov, pov conveyor: a way to create transition in presentations
**"become the object": when pov moves as if it were the object
*easy orientation via dragging
*for quick 'handmade' anims: freeDrawing.isTouchable = true after it has been created

*la supercouche interprétative: quand une computer vision interprète l'espace d'interaction
  exemple: des objets superposés seront peut-être interprétés comme étant le même objet

**Narwhal numbers: multiplayer canvas, operators and their inverses are disseminated around, each player has a starting value and a goal, winner is the first to attain their goal
    variant: each player also has an operator attached to them (that's a way to somehow keep the joust mechanic)
      so the narwhal number player has its operator on the front and its value on the back
      example:  -=([[3]]   [x  2])>>
  edu: I know that's gamification... (but maybe it's gonna be ok still)

**shade.im_dying_now
		2 flavors:
			- bring original down
			- don't affect original

26 mai 2021:
*var: [create: number], [assign: 0], ...operations..., [destroy]

**turtle: operations are forwarded to a third-party object (the two first being [[obj]] and [operator]): [[obj]] * [operator] = [[turtle]] * [operator]
    edu: c'est vrai que Mathland sans turtle(s), ç'aurait été un peu triste.
**pen(== turtle) drawing: record pen drawing: create [pathmade:penDraw] operator. Touching this operator will command pen to draw.
    edu: this way we can draw crenellations by looping on this operator
**penDrawing: relativeOrientation => roses: record pen's ending orientation so that looping on curve drawings will result in roses

**in the steps of giants:
    https://fr.wikipedia.org/wiki/Squeak
    https://en.wikipedia.org/wiki/Croquet_Project
    Lively kernel

29 mai 2021:
*katamari operator: [stick [<obj>]]: touching this operator sticks a clone of <obj> on you
    2 flavors:
      directional: the clone sticks where touching
      random:      the clone sticks anywhere on the border
*katamari generation loop: loop [stick [<obj>]]
    edu: emerging structures

***pathmade:triggered pathmade: user draws paths for each argument and conveyors will be triggered to start altogether.
  this allows support for multiple arguments
  [[firestarter]] obj: this is like a "gogogo" argument: this will trigger the operator
  Result is last drawn conveyor's output.
  Result is cargoed in supervessel.
  2 different implementations:
    - vacuum conveyors: trigger is a pure trigger and, when actioned, all conveyors will try to vacuum an argument near their starting point and then start conveying
*** - embark pathmade: pathmade is a platform operator and each time an argument is put on it, it is mapped to the corresponding conveyor.
        mapping to conveyor can be done using order, type, ...
        Trigger happens:
          - when all arguments are here
          - if actioned by a [[firestarter]]
  2 flavors:
    - 2+ args:
        - optional arguments
        - required arguments
    - only 1 argument and the rest are parameters
      edu: also, we _see_ the difference between an argument an a parameter:
        argument is consumed
        parameters are not consumed

  triggered pathmade can be conveyor ("multiConveyor"), shadePossessor ("multiPossessor"), etc.
  edu/fun: with multiConveyor, we can create an [arrange as face] operator which puts #1 arg as left eye, #2 as right eye, #3 as nose, #4 as mouth
    and then we can wonder what is actually a face, is it the arrangement or the arranging (==the result or the process)

  0 show location of #1 when drawing #2
  variant: superhot mode: to move in space is to move in time

  user may decide whether he wants the touched object to be conveyed or shadePossessed (== choice between kind of a procedure and kind of a function)
    depending on the glove color of their grabbing hand

  user may configure whether a path is:
    - a dead end (==performer will not be given back to user)
    - an outlet  (==performer will     be given back to user)

  edu: pour que ça soit vraiment *edu* (et aussi pour que ça soit vraiment utile),
        - il faut qu'on puisse éditer la fonction (==le chemin) après qu'on l'a créée
        - il faut que ça reste rond et courbe
        - il faut qu'on puisse changer la vitesse d'éxécution, de façon continue de figé à rapide, jusqu'au saut quantique: "hardwired"(==compilé, ==le plus vite possible, ==on n'affiche plus l'exécution)
    dev: encore du sport à venir

**pathmade:await: wait for operator to finish before going forward
  dev: this is the hard part

**pathmade:custom generators:
    2 different implementations:
      - generator path: when drawing a path, if the starting point is on a generator, this means we want to create an object and make it follow that path
          we can then create custom generators using generator paths pulled out from _elementary_ generators
      - generator as arg: when the triggered pathmade triggers: the output obj from the generator is used as working argument
    edu: generator path may be a little bit easier to understand than generator as arg

30 mai 2021:
*easy multiargfunc: type "3x + 2y -5z" and it automatically creates an embark operator
  "[[1]] x 3 + [[2]] x 2 + [[3]] x (-5)" should be parsed the same way

*?(the path is the operation

31 mai 2021:
*embark operator:named slots (==renamable slots)
  slots corresponding to each arg are named "#1", "#2", etc. but then you can rename them
**embark operator: add support for bag input (bag contains all the args)

*a program for every theorem
**0 fabriquer un additionneur de fractions avec les outils existants

*global pool: this pool contains words, numbers, shapes, ... (un peu comme une chambre d'enfant)
*global pool: operators: grep: this would allow easy finding of
**condition-based magnet: wave the magnet over a dense area: objects satisfying the condition will stick to the magnet

*bloom: morph into next representation
    edu: pour passer facilement de 10 à [1,1,1,1,1,1,1,1,1,1], et inversement

*create Heider Simmel -like stories
    edu: maybe a little happier

01 juin 2021:
* "a + b x c"
  0 have it working
  0 parse tree-formatted expression into tree-arranged paths implementation

*trueGolf: randomStroke/manualStroke
  there are multiple stages for each hole: {stage 0} --> {stage 1} --> {stage 2} --> {stage 3}
  each stage partitions the hole course into areas in a specific way: {stage n} --> {stage n+1} with probability P(s_n+1), {HoleCourse \ stage n+1} with probability (1 - P(s_n+1))
  randomStroke moves the ball to each zone with probability P(zone)

*shadeConveyors <~> multiOutput

**(*)temporal builder(==temporal form): build anything by specifying one property at a time
    1. I declare that I start creating an obj
    2. while i'm not done, I specify another property of the obj I'm building
    3. I declare that I'm done: the obj is built
    These buildings can be nested.
    It would be nice to show the hierarchy of the object we're building and the properties we have specified so far.
    edu: this is a simple -yet powerful- way to build complex objects
    example:
      temporal composite builder: (generalization of multipathmade)
        1. I declare that I start creating a composite
        2. I create the parts of the obj, one part at a time
        3. I declare that I'm done creating the parts: the composite is built

02 juin 2021:
*stages inside a function:
    mapping
    twingling
    outputting

(codage géométrique: contraintes en puissance VS contraintes en acte

*"Copies, clones & replicants": many flavors of "they are the same":
    - gemini      (still "in touch")  (something I am)  (limb)
    - copy        (objects are apart) (something I was) (poopoo)
      - shallow
      - deep
    - impersonator                    (something trying to be me)
      - stateImpersonator
      - behaviorImpersonator

**composite: rearrange parts using conveyors:
    [up 50], [down 50], [left 50], [right 50]
    edu: un mélange de tortue et de translation
    edu: on peut fabriquer des obliques en mettant le début d'un opérateur à la fin d'un autre

**ecological poopoo: poopoo stays in the composite
    edu: this way, composite's inner turtle can penDown, without polluting global context

(algèbre des chemins

(en informatique, y'a ce double décalage (temporel et "productionnel") entre la vision qu'on a et sa réalisation. Parfois c'est près, parfois c'est loin.

**composite: [objectAtIndex:<index>] operator
    [[{1 2 3}]] * [objectAtIndex: 0] = [[1]]

**WASD-controlled obj, open world: numbers adventure game (/!\attention à ne pas faire une gamification merdique/!\)
    edu: créer un petit monde avec des portes et des clés et des portails laser avec des conditions logiques ("all must be > 12", "any equals 5")
    edu: quand on a pas beaucoup de mana (==motivation), on peut toujours jouer à la manette. La souris demande un peu plus de motivation.

03 juin 2021:
*edu: small stroke for mathNode pour différencier "ajouter" et "mettre dans le même sac"
*edu: créer des exercices avec des cailloux de couleur pour commencer à maîtriser les fonctions

**[objectAtIndex:]: multiple flavors
  - destroy container and keep part at index (==pure-function way)
      edu: this behavior has a nice advantage: working space stays clean
  - don't mutate container: simply gain control of part at index
  - mutate container: remove part at index from container
  some of those behaviors may only be possible when using supervessel

**[pickme <obj>] operator: when an object becomes an operator
    to ease function drawing, we can store an object in an operator, waiting to be used later
    object touching operator:
      - if it's a container, obj will be added to it
      - if it's an obj,      a container will be created containing the two objects
      - if it's an emptyObj, obj will replace emptyObj

**edu: tranquillement aller vers l'abstraction (et "l'équivoque"): du spécifique au générique
    commencer par les opérateurs spécifiques [c:objectAtIndex:] [str:charAtIndex:] etc.
    pour aller vers les opérateurs génériques [g:elementAtIndex:]

04 juin 2021:
**pathmade: vesseler: convey objects using a disposable vessel
    either we make the vessel touchable and mutate it directly
    or     we make the vessel untouchable and we get it back from the touched object (-"Are you being vesseled ?" -"Yes, I do" -"Kay, thanks")
    shu: I prefer the second way

**transformationFunc("new"): coords__icObj_new = coords__vessel
*?transformationFunc("append"): keep old and add new

***pathmade:part#nPath
    the idea: easily draw paths to _dispatch_ composite parts (==vesseled objects)
      draw part#1Path by pressing "1" and drawing
      draw part#2Path by pressing "2" and drawing
      you can choose to draw only part#2Path if you don't want to do anything with part#1
      you can draw part#2Path before part#1Path, drawing order does not matter
      when used, if performer has only one part, part#2 path will simply be unused
    shu: l'idée vient de la confrontation avec cette envie de dessiner des fonctions (facilement)
    dev: encore du sport

**[<- [1,2,3]]: touching this operator adds 3 objects to current vessel
**[store: linear]: any object touched by this operator will be added to a collection just under the operator
    the collection is either:
    - a composite
    - an arrangement (objects parent is canvas) and the collection is an inner variable of the operator

**[vessel] and [unvessel] in order to try operators manually

05 juin 2021:
**curse::unique: ==not clonable
    as it is a restriction, there are as many flavors as there are clone flavors

**walls: isFloating while conveyed: use paths to get over walls   (inspiration: BABA IS YOU)
    edu: this compels students to use paths

***pathmade: seaming:
    when perfomer is touched by another pathmadeOp:
      1. prematurely terminate current pathmadeOp
      2. perform for new pathmadeOp
    loop: newest has priority over its old self
    edu: la règle est assez simple en fait, c'est comme quand on a une copine
    example:
      while loop = draw [loop] pathmadeOp, draw [if] pathmadeOp which exits loop path
**pathmade::loop: system automatically sets facade name as "loop" when end of path intersects operator's touchSlot

(*Not simply draw, but draw in time, draw in space & time

**write condition script in [if <condition>] pathmadeOp

*[join("+")]

**store commands: "clone and store", "create store", "set active store"

**path merge: [if] pathmadeOp goes back to original path
      ====[if]========>=================
            \--------->----------/

*edudemo: build operator: [^ <exponent>]
    there will be many ways to build it:
      - loop + exits
      - whileLoop
      - repeatLoop

**edudemo: les deux formes de la multiplication
  - repeat(+)
  - scale(bloom)
  edu: ces deux formes sont équivalentes (c'est un peu comme le principe d'équivalence d'Einstein)
  edu: on peut peut-être fabriquer une edudemo intermédiaire qui ferait le lien entre les deux

07 juin 2021:
**another operator behavior: imprintable: on first touch(es), operator's behavior gets fully specified
    example:
      imprintable counter: count all like this one (one touch to fully specify behavior)
      imprintable combo counter: count all combos like this combo (multiple touches to fully specify behavior)
    like an EEPROM, but it's an operator

**challenge::dictation: touch mistakes in the text with the correct [mistake] obj

*value-wise store/counter: only store or count when touching an object with an expected value

**histogram store: must touch with the expected value
**histogram counter: store + counter reictangle
**histogram loop: since we use value-wise counters, performer can try all counters for a valid touch
    example workflow: random sample: build single   histogram  : loop { get_random_value, try all counters for a valid touch}
    example workflow: random sample: build multiple histograms : loop { get_random_value, try all counters for a valid touch in random events partition #1, try all counters for a valid touch in random events partition #2, etc.}

08 juin 2021:
**edu: constructionism: any object that the student has managed to create is then available in a dedicated well
    - as a snapshot version:    this version contains all the pain and trouble that the student has overcome
    - as an "instant" version:  this version is the most efficient version

**Theorem as a function: meta-theorem as a function generator     ("functions all the way down")
  edu: [bag with conditions] * [theorem] = [bag with conclusions]

11 juin 2021:
**icObj.type = "magnifier"
    edu: pour mettre en avant une zone spéficique dans une présentation dynamique
    edu: pour regarder ce qui se passe dans un processus "profond"
          et pour pouvoir débugger par exemple

store: layout: gridLayout
  layoutEngine

**icObj.type = "layout"
    this object is like a composite but parts are arranged using specific rules (==provide position, size, scale and zIndex)
    (fun: include handle in the objects we layout ("icLayout layouting itself")
    dev: first, static layout
    dev: then, dynamic layout (allow dnd reordering etc.) 
	  0 icLayout = icComposite([...arr_obj, ...arr_layout_obj]) + LayoutEngine
	  0 icGridLayout: icLayout with arr_layout_obj == [baseRect] and LayoutEngine == GridLayoutEngine

**"Time" control: accelerate, slow down
    edu: when repeating random experiments, after having shown a few outcomes, accelerate to build histograms

**value-wise counter: 2DGrid: we specify two sets A and B, and we then count objects in AxB

**(*)store: many flavors:
    copyStore: [[obj]] * [store] = [[obj]]  + side effect: copy of [[obj]] is put in depot
        shallowCopy
          dev: dans ce cas on crée rep_stored et on met rep_stored au dépot ?
        deepCopy
    hardStore: [[obj]] * [store] = [[*]]    + side effect:         [[obj]] is put in depot
      [[*]] means an activator (empty) object
    edu: la shallow copy peut être très utile pour représenter des partitions: si tu es petit, je te peins en bleu, si tu es grand, je te peins en rouge

**edu: use a loop to create counters: [iterator: possible_outcomes]/[iterator generator: create possible_outcomes iterator]
                                        icObj generator            /  generator generator
  dev: pour cela, on a besoin de connaître l'ensemble des issues possibles

**edu: show stack: encountering a shadePossessor along the path must be treated as: push next path on the stack
**icObj.type = "futuring"
    icObj.futuring
    mutate current futuring, as if it were any other property, like position or fill color
    icObj.futuring = ttFunc(icObj.futuring)
    [speed:fast], [speed:slow], [speed:normal]
    [speed:faster], [speed:slower]
    we may also track down the transformation process of the transformation process, etc. (== the futuring of the futuring)

**edu: show stackless execution: encountering a conveyor along the path is treated as: abort previous pathOperator and follow the new one

**edu: show tree evaluation: starting at the bottom, make shadePossessor halfloops to compute which reduced object the tree is equivalent to

**edu: Z-tree: each depth level has its own homeScale so that you have to zoom in to see what is inside the node, etc.

**icObj.isTouchable -> icObj.isTouchableDict
    this will allow complex routing: two objects may follow the same path, and yet, interact with different operators along the way

**(*)AI objects create their own pathmade operators: this may be funny to see, all the more if they achieve something non trivial

12 juin 2021:
**the admin way of drawing: multidimensional color == {color + recipients}
    this way, the admin may specify things to specific players
    admin is able to see what all players see: either all merged or specific projections
    typical use case: adminDraw a codenames game: draw blue and red borders only for tellers

**theorem operators: [[hypothesis]] * [theorem:<your_theorem>] = [[conclusions]]
    example: {[[a<b]], [[b<c]]} * [< is transitive] = [[a<c]]

**pathsnapping: snap operator on path
  dev: outche

**dynamically (re)define font: font adapts to your editing it: you can draw over a character and character adapts
  (=> "supereasy" font creation)

13 juin 2021:
(intention vs implementation

**supereasy::number creation: type a numpad number (a timeout resets after each key press) and an icMathNode is created with your number as constantNode's value
    edu: because it's primarily created for kids to manipulate numbers
    edu: maybe we should also add this shortcut: KeyX: create an icMathNode with "x" as symbolNode's symbol
    0 number builder
      0 manage builder timeout
      0 manage -12
        0 infinite wait for -
      0 manage 3/4
        0 infinite wait for /

14 juin 2021:
(x  |--> "x" |--> lf("x") |--> f(x)    VS  x |--> f(x)
   to_litt  litteral_f   from_litt             f
   on pourrait faire un carré mais l'idée est la suivante: est-ce qu'on ne mélange pas trop souvent les deux ?
   et on pourrait ajouter une phase de simplification, si on considère que l'objet non simplifié et l'objet simplifié sont tout de même différents l'un de l'autre
    lf("x") |--> nsf(x)          |-->     sf(x)
              not simplified   simplify   simplified

15 juin 2021:
***le transformé comme sujet VS le transformeur comme sujet: ajouter le comportement "dual": j'attrape un opérateur et je touche(/me fais toucher par ?) ce que je veux transformer
    edu: peut-être que les deux comportements sont complémentaires pour faire comprendre telle ou telle opération
         l'avantage du transformé comme sujet, c'est qu'il permet les enchaînements de transformations
    edu: et puis ça ouvre la voie vers les opérateurs d'operateurs etc.

(("Le graphe pour le graphe" (Ducrot dans la tête): notre réseau de neurones dans la tête serait là pour calquer les graphes qui existent dans la nature
    de manière à avoir une sorte de "toy copy" dans la tête
    Un des graphes les plus utiles à "toy copier" est le graphe du langage (en fait il y en a plusieurs, le graphe langagier et le(s) graphe(s) linguistique(s)).
      Si on considère que le sens d'un mot n'est que le graphe des connexions qui shadowent un mot, et que, c'est uniquement cette structure abstraite qui donne le goût du mot, alors on a juste besoin d'une machine à fabriquer des graphes pour, partant de rien, petit à petit comprendre des trucs.
      Le graphe de notre réseau de neurones serait donc un super graphe ("toy copy") et une fonction de génération de graphe.
      La fonction de génération de graphe doit sûrement dépendre, au bout d'un moment, du super graphe lui-même (mais là ça devient hardcore).
      Le super graphe, bien qu'il soit tentant de le considérer comme une construction physique statique, comme un tas d'argile modelée,
      est en fait un graphe performé (et donc surtout _performable_): quand le sens d'un mot est vécu,
      les relations entre éléments du graphe sont effectivement réalisées, à chaque fois,
      par des circulations, comme une relecture (très rapide) de tout ce qui fait ce sens,
      ou du moins tant que le super graphe n'a pas lui-même bâtit un mini graphe "compilé" qui réalise tout cela de manière encore plus accélérée.
    Un dictionnaire, c'est une version "rétention tertiaire"(livre) du graphe du langage.

(*l'algèbre des carreaux: [2x (horiz)] et [2x (vert)]    [[5 horiz]] / [[10 horiz]] = [[3 vert]] / [[6 vert]]
  [[1 horiz]] == [[1 vert]] == [[1 square]] == [[1]]
  [[6 vert]] == [[1]] * [x6 (vert)]

***iCClassroom (==iC + colyseus): on imagine qu'on reconstitue une classe en partant d'un grand rectangle qu'on divise en sous-rectangles
  chaque élève a son sous-rectangle dans lequel il peut travailler,
    ce qui est cool, c'est que cet espace, quoique borné, est infini.
  Le prof a un sous-rectangle de présentation, et plus important, il voit chaque sous-rectangle de sa classe.
    est-ce qu'il peut voir tous les objets ? même ceux que l'élève cache profondément, genre des petits dessins, des trucs comme ça ? (avec un focus_to_next_object() en appuyant sur TAB)
  Les élèves peuvent voir ou ne pas voir ce que font les autres élèves en fonction de l'activité.
  En phase de travail:
    mode fermé:  l'élève ne voit que son espace
      edu: pour faire en sorte que l'élève puisse se concentrer
    mode ouvert: les élèves peuvent voir les espaces des autres
      edu: pour confronter différentes idées, différents résultats
  En phase de cours magistral:
    les élèves peuvent écrire dans leur espace mais de façon exceptionnelle: quand le tableau blanc n'est plus dans leur point de vue, un compte à rebours s'active qui les ramènent au tableau blanc.
  edu/dev: wow, y'a plein de choses à faire, y'a du potentiel

16 juin 2021:
**24-sourced controller: from 24 inputs to 1 input: every frame, input is avg input
    => The Wisdom of crowds

**pathmade operator: throwing exceptions: _any_ operator may throw an exception, which results in stopping the current pathmade
    examples:
      when encountering an empty vessel
      when trying to divide by zero

**[filter:<condition>]: filter removes cargo from vessel when condition is not satisfied

**conductive operator: allow [generator] to be used in place of [[instantiated collection]]
    ([randInBag {} with .isConsume = false] is a generator (?)

18 juin 2021:
**symbol: "on top of", "put over": /_
**stacks: [[0]] /_ [[+ 2]] /_ [+ 3] /_ [/ 5]
    {[[0]], [[2]]} /_ [+] /_ [+ 3]

**[eval:inner] operator: [[*]] * [eval:inner {[[3]], [+ 2]}] = [[5]]
   edu: pour pouvoir montrer la différence entre une expression non-évaluée et une expression évaluée
   this operator creates an inner no-interaction zone, so that we can set up a stack inside it [eval:inner <stack>]

**exothermic reactions: [[A]] * [B] = [[C]] + {[[exoParticleD]], [[exoParticleE]], ...}
  edu: this would be used to show chain reactions
  edu: I don't know what endothermic reactions would be like ?

**[occurences]: [[collection]] * [occurences] = [dict__occurences]
*edu: loto: faire plusieurs tirages de loto (boucle de boucle5 et store de store5) et ensuite analyser les différents tirages de 5 numéros
  prendre le store et lui faire toucher des opérateurs, [occurences], [unique], etc.

**edu: randInBag: bag.parts = {bag_drawing, ...bag_contents}
    bag_drawing.isCosmetic = true;

(*revolving randomness: are we still in the "random experiment" theoretical boundaries?
    example: rand( revolving(1,2,3,4,5,6), revolving(7,8,9) ) which would yield, at first, 1 or 7, then 2 or 8, then 3 or 9, then 4 or 7, etc.

(**"TRY HARDER" VER: on reprend tout, en gardant ce qui est bon, en corrigeant ce qui doit être corrigé, et tout ça, sur des fondations différentes, _a priori_ meilleures

19 juin 2021:
**named object(=> references): if [[2]].name is "x", then [["x"]] * [get named] = [[2]]
**evocator (== [get [[*x]] ]): get existing _long-living_ object
    this brings state in this otherwise functional landscape

**operator evocation: when almost every [[+ 2]] mean: "get the one and only [[+ 2]] thing, and do it"
    there is a pathmade way to do operator evocation: when pathmade is simply a "passthrough operator", with the path only passing through one operator (the one we want to evoke)

**t[icWorld]t (==file object (or folder)): when you doubleclick on this object, its contents are loaded so that its biggest scale is the scale in which you enter it (==it is framed)
    a world can contain itself, either as a dive (==go deeper) or as a reboot (==go back to entrance)

**edu: iC to specify a language: some typical human situations, and their contexts, are set up and the user can write the words of his language, or record the sounds of his language which are related to the situation, when it is relevant.

20 juin 2021:
**transformationOutput.cfg.isKeepPosition

21 juin 2021:
**dot operator: get property named: [. [[propName]] ]
  example: [. [["color"]] ]

**randomMultipathmade: parts-to-paths mapping is random
  like a 2-D shuffler
**quantum-like: "all possibles"-multipath travels
    collection object covers all possible paths by cloning

***edu::teamChallenge: "right in front of you": hide a key near a geometrical point (we can do it since the canvas is infinite) + transmission of information
    1. a student, the "witness", is shown a geometrical construction sequence
          at the very end of the sequence, a geometrical point is highlighted, this is where lies the challenge completion key
    2. the witness has to write down, in his own words, how to reproduce the sequence
    3. then these instructions are handed to the rest of the team
    4. the team has to reproduce the original construction which will make the key spawn
    5. the team has to find the key which lies near the end point

**randInBag: manage the case where the picked object is put back in the bag

**edu: functionamer operator: [["x"]] * [functionamer [["f"]]] = [["f(x)"]]
    [wrap ["f("] <your_obj> [")"]]
    et là on se dit qu'il nous faudrait quelque chose qui ressemble à du texte, mais dans le lequel on pourrait mettre n'importe quel objet : une sorte de texte++.

**edu: proportionality lab: different ways of responding to [x 2]
    [[2,7]]       * [x 2] = [[5,4]]
    [[baguette]]  * [x 2] = {[[baguette]], [[baguette]]}
    [[<-rect->]]  * [x 2] = [[<-----rect----->]]
    [[square(2)]] * [x 2] = [[square(4)]]
    [["hello"]]   * [x 2] = "hellohello"


22 juin 2021:
**edu(/tech): ensure that students all experience the same (when possible)
    - scroll-speed automatic calibration
    "etc."

**draw movement/draw on wrt something moving:
    lock pov on moving object, then draw in that local coordinate system
    example:
      draw earth movement around the sun then draw moon movement around the earth
    edu: if student can draw a solar system in, say, 5 minutes, then they may understand it better

23 juin 2021:
**edu: late evaluation curse: [[5]] * [+ 1] = [[5 + 1]]
                                                cursed,     after 1 second transforms into [[6]]
    multiple flavors:
      - a separate curse for every interaction
          example:
            [[5]]     * [+ 1] = [[5 + 1]]       + curse1
            [[5 + 1]] * [+ 1] = [[5 + 1 + 1]]   + curse2
            [[5 + 1 + 1]] --curse1--> [[6 + 1]]
            [[6 + 1]]     --curse2--> [[7]]
      - reset timeout if an interaction has occured before the curse trigger
          example:
            [[5]]     * [+ 1] = [[5 + 1]]       + curse
            [[5 + 1]] * [+ 1] = [[5 + 1 + 1]]   + reset timeout for curse
            [[5 + 1 + 1]] --curse--> [[7]]

    the idea is to create a connection between:
      1. the interaction between the number and the operator
      2. the unevaluated expression
      3. the   evaluated expression

**game::treasure hunt:: "recalled" curse: when clicking on the found object, it is recalled back to its destination slot in the "collected objects" area
    2 flavors: isPovLock (true or false)

26 juin 2021:
**kids have smartphones, kids don't have desktop PCs
  => ergonomy: add major scale buttons in the back of the phone, to enable zooming while keeping thumbs available for pushing stuff on the screen

27 juin 2021:
**bande dessinée animée: mi-bande dessinée mi-dessin animé et re mi-ours derrière
**icObj.type = "disk_portion"
    user can change angle by dragging
    edu: [[+30°]] * [+ [[-20°]] ] = [[+10°]]
**edu: ghostSnap  (from raw input to "exact" input)
    example: "build a circle" eduDemo: when creating a point, it is snapped to an invisible circle so that, when putting multiple points here and there, a circle made of dots appears when zooming out
**edu: walking friend
    example: "build a circle" eduDemo: a character starts from the center and walks a given distance in a straight line

**explain homothety with Mario mushrooms

30 juin 2021:
into a practictal use of the infiniteCanvas:
**practical::temporary portal(s): when Picasso works on a painting, Picasso has to move away from the painting to see it as a whole, and then move in, etc.
**practical::isMovable spawn modifier
    workflow: (when creating treasure hunts for example) first draw an unmovable object, then draw a movable object and place it over it
**practical::doubleObject spawn modifier:
    workflow: first draw the back object, then draw the front object (at its toggle scale)

**edu: globetrotter: loop{ask a question to the students about current location, let answerer choose next location}
    3D-infiniteCanvas (à la GoogleEarth): move from country to country
    2D-infiniteCanvas => flat map

(edu:liquid Sissa: square glasses on the chessboard

*symbolism::reference length: say we have a triangle with lengths 3 cm , 4 cm, 5 cm, if we choose the 5 cm length to be the reference, then the other length could be written 3/5 and 4/5.
    on the geometrical figure, we would indicate that 5cm is the reference length by writing it with a double bar (like a segment but doubled) (or any other clear and distinct way of specializing the side we choose as a reference)

01 juillet 2021:
**Line, Point and other geometrical entities have this interesting property: they are Z-scroll proof: Z-scroll leave them unchanged
    edu: this is a nice property to play with: "is this a point, or is this a disk?"

05 juillet 2021:
**challenge: blackbox reconstruct: next to the "subject" blackbox, there is a an empty blackbox for the user to specify what is inside
    edu: be progressive:
        first, only on the surface                  3 operators then 4 operators etc.
        then with something in the core             4 operators then 5 operators etc.

**operator interaction type: sunburn (=="projective interaction"): operator can only burn (==operate) _once_ each object
    edu: so that the user, starting with a typical input set, can create the/a corresponding output set, in order to get a grasp on the way the operator transforms objects

**operator: decimal splitter
    many flavors:
      with "decimal places units"
        [[1234]] * [split::decimal] = {[[1 millier]], [[2 centaines]], [[3 dizaines]], [[4 unités]]}
      with zeroed numbers:
        [[1234]] * [split::decimal] = {[[1000]], [[200]], [[30]], [[4]]}
      with powers of ten:
        [[1234]] * [split::decimal] = {[[1 x 10^3]], [[2 x 10^2]], [[3 x 10^1]], [[4 x 10^0]]}

08 juillet 2021:
**edu: many ways to solve a challenge: design challenges so that there are many ways to solve them
    the schooly   way
        [[7]] * [- 5] * [x 5] * [+ 2] = [[12]]
    the hacky     way
      the solution seems there for the taking, yet there is an obstacle to work around
        [[12 (locked)]] when the target is [[12]]       : you have to unlock
        [[12 (blue)]]   when the target is [[12 (red)]] : you have to change the color
        so that it is no longer an arithmetic problem but an object transformation problem
    the unthought way: there may be some times when students will discover solutions of their own
    It would be nice to design the hacky way to make student think almost as much as for the schooly way

***operator: 'same as previous': this is a weird operator since it depends on context. Still it may be a funny operator.
    [[7]] * [+ 2] * [same as previous] = [[11]]
    ...

(*game with students: last man standing in [[0;100]]: Roll a dice, choose an op in {+,-,x,/} and move to [[current]] * [[op roll]]. Player who cannot move loses.
  ...

**challenge: get somewhere: specify target position using word cloud or word graph
    some words, images, etc. are in the canvas. You have to come up with a "semantic" position.
    At each pov change, update word enlightening to drive user to target.
    example:
      Say the hint is [HOT, wet] then I'd better search on the segment which joins the image of the sun and the word "lake", closer to the sun because the word HOT is bigger

(***cn: iC interface: menuing: select by moving in, go back by moving out
(***cn: hidden letters: the goal is not to have the guesser select the correct tiles, but to drive the guesser to collect the letters hidden in the tiles
    teller  has the letters highlighted
    guesser must zoom-in, at the locations carefully hinted by their teller, to discover the hidden letters
    maybe, then, there is an anagram solving step in order to win the match
(***(*)cn: hidden tiles: we keep the "guesser must click on stuff" rule, but the clickable objects are "Z-crimped" in a scene
  so everything is like a standard codenames game but there are more tiles and they are Z-crimped

09 juillet 2021:
**supereasy::measuringScoop: collect a definite number of elements in a pool
    edu: divide 239 marbles in 11-marble groups: how many groups will we have? Will there be leftovers ?

((edu: introduire les nombres négatifs en faisant un jeu avec des opérateurs [+ 4], [- 5] [+ 3], etc. , et "on joue sur [[0,20]]"
  1. atteindre 9  en utilisant des op
  2. atteindre 19 en passant par 21  (il faut sortir des limites)
  3. atteindre  1 en passant par -1  (il faut sortir des limites par l'autre côté)

10 juillet 2021:
**relationship: materialize the relationship between two objects.
    Enter relationMode, select obj1, select obj2, leave relationMode.
    examples:
      2 similar triangles: ABC --similar_triangle--> DEF
                                  scale_factor:
                                  rotation:
                                  is_flipped:
                                  (translation:)
      between 2 bloom petals:  123 --as_text--> "123",  123 --digits--> [1,2,3]

18 juillet 2021:
**iC mutation journey: history by manipulating famous historical personalities
    animations may be:
      - user-manipulated object being mutated   (getting older, getting murdered, killing someone, becoming king, etc.)
      - "world" objects moving or being mutated (borders moving, troups moving, king and queens laughing or fleeing, etc.)
    episodes: one journey for each historical moment
      Napoleon went there, Napoleon did that, etc.

***boxed notation: """la notation encadrée""" -shu
    instead of using parentheses, we really do box items

***iC over Maps: put a transparent-bg infiniteCanvas in front of a Maps element and synchronize z scrolls, so that you can now draw over the map
    Any Maps provider would do
    there could be a calibration step in which user would contour a map object at different z levels
      for example a country or a city
    dev: this would mean transfering top layer move to bottom layer (right mouse pan vs left mouse pan)

***iC over video: same thing with maps but there should be a time synchronization component

20 juillet 2021:
***Z-meaning: zoom inside a word to get synonyms (wordy "Z cloud") and Z-scroll the synonym you want to replace the original word with
    workflow: enter meaning mode, zoom-in, Z-scroll synonym, leave meaning mode
    example:
      My [cat] is on the car. -> My [pet] is on the car.
      My pet is on the [car]. -> My pet is on the [hotrod].
    This can be used with images too.

21 juillet 2021:
**object name/content flip/flap
    say we have an object with name "a" and with content 3x5+12, it is either displayed [[a]] or [[3x5+12]]
      [[a]] * [flip::to_content] = [[3x5+12]]
      [[3x5+12]] * [flip::to_name] = [[a]]
      [[a]] * [projection::value] = [[27]]
      [[a]] * [+ 1] = [[a + 1]]             hahaha, this is were fun begins

24 juillet 2021:
**post-naming:
    1. draw a pathmade operator
    2. spawn a [[x]] object
    3. apply pathmade to it: you now have something like [[(50x + 18)/2]]
    4. [[(50x + 18)/2]] * [to_string] = [["(50x + 18)/2"]]
    5. use that string to name your operator: drag [["(50x + 18)/2"]] into the pathmade slot

**(*)challenge: blackbox destruction: [[0]] is a 1-second timebomb, explode in core
    1. there is an area to prepare objects: user may create [[0]], [[1]], [[2]], [[-5/12]], etc.
    2. [[0]] is automagically cursed: it explodes after 1 second
    3. the idea is to use the blackbox operators to end up having [[0]] at the very core of the blackbox, so that the blackbox (or only the blackbox veil) is destroyed
    edu: the delay is to prevent students from scribbling (this is a very important thing to keep in mind)

**scribbling::hard limiter: when scribbling is detected by the system, the GUI is blocked for 5 seconds

29 juillet 2021:
**(*)result is collection: [[9]] * [+ 9] = {[[8]], [[1(carry)]]}
  edu: to programmadraw an addition algorithm
  each output element may have its own type (to ease further use)

**neutron bomb (== size-based chain reaction):
    each particle grows wrt its value
      [[<-1->]] * [reaction] = [[<--2-->]]
    a particle is consumed by the reaction, but, overall, more particles are produced
      [[12]] * [reaction] = {[[11(input is a bit consumed)]], [[2(output is generated)]]}

31 juillet 2021:
**1D photograph of a sector angle pov
    or maybe a slightly more complex photograph (foreground, background etc.)
    1D cam (dynamic photograph)
      edu: pour expliquer le passage des jours, une fois dessinés le Soleil, la Terre et la Lune, et une fois choisi un point de vue

03 août 2021:
**(*)edulab: decimal numeration: putting dots in boxes, putting boxes in boxes
    there is a dot well
    there is a box well
    1. student can put dots in a box which is a bloom (there is an associated number displayed below the box)
    2. when the box is full, student can put it in another box
    there is a shrink animation when, say, a full 10-capacity box enters a 100-capacity box, so that it looks the same as a dot in a 10-capacity box
    edu: we can then ask: what if dots were actually boxes ?
    edu: we may create an algorithm using automatic overflow throwing boxes
      1. "self-correcting" (== auto-simplifying) box-based number
      2. addition algorithm: fusion of 2 box-based numbers

***programmadrawn cellular automaton: a localized i/o machine
    example:
      10-capacity box: if box is full, it emits a shrunk full 10-capacity box via its output tentacle, which would be received by its connected 100-capacity box neighbor
    such an automaton could be copied and pasted
    and then eventually modified
    edu: on arrive au concept de classe / d'instance
    et à tous les problèmes de "est-ce que cette màj concerne toutes les instances ou seulement celle-ci ?"...

04 août 2021:
**protective shell/[protect] operator: a protected obj will consume its shell instead of being operated on
    [[2]] * [protect] = [p[[2]]p]
    [p[[2]]p] * [x 3] = [[2]]

(1984!: https://robotodyssey.online/#
  Warren Robinett!

05 août 2021:
**Toolbox: operator wells in a box
    zoom in to get operator wells
    auto dezoom when dragging operator out of toolbox
    invoke/revoke toolbox
    edu: this would promote user autonomy (== sandbox, editor,...)

**(*)programmadraw: press space for "sticky moment": any object touching the vessel when it is having that moment will be captured by the vessel
    this makes dummy growbounce a bit (animation)

**capteurs et activation: à la Rocky's boots
    Execution is triggered by a sensor
    edu: this could lead to: function creation challenge: trigger function only when both inputs have been provided

**2-input assignement operator: [ [  ] <- [  ] ]
    edu: user takes a variable and puts it on the left spot, then user takes another variable and puts it in the right spot, which triggers the assignment

***The Hidden Layer: in order for students to create interactive situations without showing the plumbing (==neat interactive), the underlying code is written in the Hidden Layer (~the flip side of the coin)
    user can enter/leave the hidden layer using a keyboard shortcut
    some elements have a isShown property so that we know that they will be displayed in the neat layer

08 août 2021:
**Math Adventure: an Adventure-like game with math riddles
    equation lock system:
      1. player enters a room in which there is an incomplete equation with an empty slot to be filled
        example: [[3]] + ... = [[7]]
      2. player finds the [[4]] object and places it in the empty slot: the door opens
      3. at some point, beside this door, the player needs the [[4]] object to continue
          the player has to pick up the [[3]] and/or [[7]] and create another equation with the numbers they have in the inventory: the door is open again
      edu: cette mise en scène met bien en valeur le concept d'équation
    The world has to contain areas which are completed by small increments, so the player comes back, again and again and again and gradually grasps the whole world

09 août 2021:
((madness: resident evil save game system: combine(ink_ribbon, red_ink): the saved game will be in an altered form when loaded

10 août 2021:
**User & Adventure (== "God and Ball"): the game is played by alternate controlling of each character: mouse and keyboard "omniscient roaming" of God vs "joystick control" earthbound roaming of Adventure avatar
    some parts can only be done by God or by Ball

**canvas pieces: some canvas area can be grabbed and put in slots
**canvas pieces connections: multiscale circuit-seaming
    some circuits would be big and some very small, yet they all would have to be connected to go further in the game

**(*)function easy drawing area: in this area, the user is asked to draw some function to complete the challenge
    user would try many different drawings
    workflow is:
      1. drawing
      2. testing
    previous function is automatically erased when starting drawing a new one

01 Septembre 2021:
**challenge:Des chiffres et des lettres
    layout:
                    safe area for combined elements       goal
        operators
                        base elements                     reset
    a combined element has two visual parts:
        top    (square): litteral expression
        bottom (circle): simplified/evaluated value

06 Septembre 2021:
**edudemo/edulab: DND addition posée avec la retenue qu'il faut emmener au bon endroit
    dev: gestion du layout
**edudemo/edulab: DND multiplication posée avec la distributivité qu'il faut faire à la main et qui fait apparaître une addition posée en dessous

10 Septembre 2021:
**challenge: stats: find the objects given: their count, their mean, their span, their median
    easy:        1D: x coordinate
    medium/hard: 2D coords
**challenge: stats: find the mean, find the median: they are very small so that the student must compute the value before searching

11 Septembre 2021:
***idée de jeu: jeu de guerre un peu à la Clash Royale
    Soit au tour à tour, soit en temps réel.
    Deux châteaux s'affrontent, le camp A et le camp B.
    A et B se tirent dessus en s'envoyant des nombres.
    Le nombre qui touche est retiré aux points de vie du château.
    Chaque joueur peut construire des symboles d'opérations sur le terrain, pour amplifier les tirs ([+], [x]) ou minimiser les tirs ennemis ([-], [/])
    Il y a un système de coût pour tirs et les constructions.
    Des expressions grossissent petit à petit au fil de leur course.
    On peut mettre des miroirs pour dévier les tirs ou pour les renvoyer.
    Si une expression est incomplète quand elle touche le château ennemi, alors elle ne fait pas de dégâts.
    Si une expression incomplète avec une vitesse Vy(A->B) = 1 rencontre un nombre avec Vy(B->A) = 1 alors les deux se fusionnent en un nombre qui a Vy(A->B) = 0
    Si une expression incomplète avec une vitesse Vy(A->B) = 1 rencontre un nombre avec Vy(B->A) = 0 et Vx != 0 alors l'expression résultante a Vy(A->B) = 1 et Vx = 0
    On peut enrichir une expression
      avec un quantum de momentum (symbolisé *, ou >>): S'il y a une collision alors le nombre résultat hérite du momentum total (et peut donc potentiellement continuer sa route)
        De cette manière, on "résiste" aux collisions.
      avec un quantum de traversée de miroirs (symbolisé -]->), pour ne pas subir l'effet du prochain miroir rencontré
    On peut imaginer des champs de bataille avec des châteaux en forme de U, pour inciter les joueurs à utiliser les miroirs.

22 Septembre 2021:
**0? créer un script qui se rajoute un bloc à lui-même quand il est executé
**0 ScratchScratch (comme ScratchGGB mais ici on a deux Scratch qui se contrôlent l'un l'autre)
      on peut donc écrire du code qui écrit du code

**edulab: addition posée avec des horloges à 10 chiffres (chaque chiffre de chaque nombre est représenté par une horloge 0-9)

Fractions: représentation Prime climb des inverses
***	0 représentation "PICS" (étoile avec espacements réguliers)

25 Septembre 2021:
**bloom: représentation textuelle
    exemple:
      3 - 2 x 0,80 + 10    "J'avais 3 euros. J'ai acheté 2 baguettes à 80 centimes chacune. Ensuite on m'a donné 10 euros."
      (5 + 2)/4            "On acheté une pizza et une bouteille de jus d'orange et pour payer, on partage en 4."

27 Septembre 2021:
*arbre de calcul: "V operator": représenter un opérateur binaire par un objet en V
    exemple:
      opérateur x :
                \   /
                  x
      qu'on peut utiliser avec [[3]] et [[2]], _que l'on touche en même temps_,
      pour former
               3     2
                \   /
                  x

03 octobre 2021:
**function scope variables:
    variables |spawn     along with the function execution
              |move
              |update
              |die

06 octobre 2021:
**Follower/binding: bind a model object [[]] to a representation object
    example: bind a number object [[]] to a number line which displays a marker for the bound object
  (This idea may have already been written down. Still,
  edu: the "number and number line" version seems very promising

11 octobre 2021:
**outil "Simplifier la sélection entourée":
    Simplifier une branche d'arbre en l'entourant
    Simplifier un morceau d'expression
**icObj::Concat reactor : any object touched by the reactor is .concat(.toStr())'d, so the object grows with every touch
***tree vs zoom level : as you zoom out, nodes are simplified (font corresponds to the current zoom level == tree level)

14 octobre 2021:
**player gets penalty each time they use "eval" operator

**prevent held object to grow outside prison when Z-scaled

(*fun: edu: Little video show as in Zanki Zero (bunny and boy)), this time with math...

18 octobre 2021:
***supereasy collection creation: fromto ".." symbol:   type 1..30 to get {1,..,30} collection
    dev: this implies interpreting input from user
**force string input: use double quotes: type "<your_text>"
**[count[<filter>]] operator:
    [count[<filter>]] is a platform operator waiting for a [filter] operator to be put on
    [count[filter]] is a standard touch operator waiting for a collection to touch it
    [[collection]] * [count[filter]] = [[number of filtered elements]]
    example:
    [[1..10]] * [count(is_prime)] = [[4]]   (primes below 10 are 2,3,5,7)
    [[1..10]] * [count(is_element)] = [[10]]   (is_element returns true for any input)
**edu: [strikethrough[filter]]: strikethrough elements that have been filtered
    edu: le crible d'Eratosthène, en mode iC:
      [[1..100]] * [strikethrough[is_2n]] = [[1..100 with even numbers struck-through]]
      [[1..100 with even numbers struck-through]] * [strikethrough[is_3n]] = [[1..100 with 2n and 3n struck-through]]
      etc.
    dev: this means decorating each element of the collection so that they can be struck-through

19 octobre 2021:
**collection: layout wrt gesture
    By dragging here and there (interpret velocity and acceleration changes)
    OR
    By drawing
      1. hold key and draw layout
      2. the chosen layout is applied to the collection
      examples:
        draw 3 columns
        draw a box
        draw a rectangle
        draw a circle
        draw a disk

***edu: many examples at the same time! (using a collection)
    Instead of showing [[2]] * [inverse] = [[1/2]], then [[3]] * [inverse] = [[1/3]], etc.
      show: [[{2,3,4,5,6}]] * [c:inverse] = [[{1/2, 1/3, 1/4, 1/5, 1/6}]]

21 octobre 2O21:
**[partition[filter]]: partition collection in 2 subcollections using filter
    edu: pour montrer les étapes successives du crible d'Eratosthène

26 octobre 2021:
**select and move via temporary composite:
    1. select multiple objects
        => a temporary composite handle spawns
    2. move objects using the handle
    3. when clicking out of the handle, the temporary composite is destroyed

**city-like number: number appearance depends on zoom level:
    _100_, 2 x _50_, 2x5 x _10_, 2x5 x _2x5_
    -----  zoom level  --->

02 novembre 2021:
**button::draw:  [draw a circle at: x<...>, y <...>]
**stamp: stamp any object: create image containing the appearance of the object

05 novembre 2021:
**progression circles à la Duolingo/Blockly games: cercles et arcs de cercles

(*edu(/et utilisation du numérique en général): les utilisateurs veulent
  1.pouvoir fabriquer des images facilement     (composants paramétrés)
  2.avoir des images qui s'adaptent au contenu  (composants réactifs)

**icObj.type = 'pixel'    : constant homeScale and scale = 1, width=height=1, integer coordinates

06 novembre 2021:
**icObj.type = 'cursor'   : a temporary hud indicates the coords of the point

***railroad tracks "reach" riddle: player has to select(or forge) the correct starting number which will end at target destination
    there are many tracks
    each track is composed that way: a transformation area and an examination area (==switch) which is linked to other tracks
    each track has its own color (edu)
    example:
              [  ]=========[/ 3]======[is_even]--yes--> ========[+ 7]=======[mod 3]--0-->[destination]
                                      |                                         |--1-->[destination] *target destination
                                      |                                         |--2-->[destination]
                                      |--no--> ========[- 4]=======[> 6 ?]--yes-->[destination]
                                                                      |--no-->[destination]

    target destination may change once the correct destination has been reached

**railroad tracks "fill" riddle: each destination has a number attached to it, meaning the number of times it must be reached
    you cannot use the same number twice at the start of the railroad tracks

07 novembre 2021:
**edu::highlight: highlight means dimming other things and shedding light on the highlighted
    This would be useful when working with collections
    example: when working with [[1..100]], highlight all multiples of 5
      all multiples of 3
      all prime numbers, etc.

08 novembre 2021:
**size ranges for each type of number representation
    size range ("center"): integer numbers in -100..100
    size range ("small"): fractions
    size range ("big"): big sci numbers
    size range ("anywhere"): any sci number
    edu: basé sur la réflexion sur la taille optimale de chaque espèce vivante (les humains font entre telle et telle taille, les fourmis entre telle et telle taille, etc.)

12 novembre 2021:
    0 create lesson (==front logo double-object + linked challenges)
  	0 create portal between lessons

*edu/dream: student can grab a challenge and Z-drag it (via portals, etc.) to another place where it can also be useful
  => challenge is no longer a challenge, challenge is now a tool: "challenge hack"

13 novembre 2021:
(*autour du "dive-in": on pourrait imaginer un codenames dans lequel on pourrait plonger dans les mots pour voir tout l'univers lexical associé, pour nous donner des idées de connexions

**quest of pi: on commence avec 3 puis petit à petit on récupère les décimales
    étape 1: on commmence avec 3    et il faut se transformer pour atteindre un certain nombre cible
    étape 2: on commence avec 3,1   et il faut se transformer pour atteindre un certain nombre cible
    étape 3: on commence avec 3,14  et il faut se transformer pour atteindre un certain nombre cible
    etc.

28 novembre 2021:
**PPPPLLLAAAASSSMMMMAAA!!! hint:
    Comme dans Mystical Ninja Starring Goemon, il y a un endroit qui peut nous donner un indice
    Il faut parfois faire beaucoup de chemin pour retourner voir Plasma mais c'est pas grave, ça réactive

***gamepad control/gamepad feel:
    RT/LT: zoom in/zoom out
    greenMouse: pour commencer un challenge greenMouse, il faut rester appuyé sur le bouton A quand on touche la valeur de départ
                  et rester appuyé jusqu'à la fin du challenge
                quand on lâche le bouton A, on revient devant la "porte d'entrée" du challenge
                dans une SafetyZone, on peut lâcher le bouton A
    B pour "courir"

29 novembre 2021:
**greenMouse challenge sausage: challenges are put together in a row, which will result in a sausage-look
    from a sausage ch1>ch2>ch3, we can build a harder challenge, requiring the use of more operators,
      by going back to start#1 and ending at end #3
      this challenge would be a way to combine all we learned so far in ch1, ch2 and ch3

***dessin à la manette: à la sketchful.io mais on dessine à la manette

11 décembre 2021:
**quand deux collections se touchent / attributs de collection

17 décembre 2021:
***morpher: from/to pebbles (relative numbers)
    edu: pour faciliter la transition cailloux -> symboles

18 décembre 2021:
***Z-pebble-tree: a way to represent the commutative law for multiplication
    as for organisms, each zoom layer has its own "organumber" (i.e. number of components inside an individual cell)
    edu: la commutativité de la multiplication comme échange de motifs à 2 niveau de zoom différents
		  3 x 4 x 2 = 2 x 4 x 3

29 décembre 2021:
(***hexMaps generation : use zscroll to shrink a grid so that it's now in a frame ("forest" frame for instance) which paints its cells in a "forest" way
                          one frame for each map type so big maps can be made by assembling grids

07 février 2022:
***object configuration via "parameter touchSlots"
      touchSlot which change the value of a property in the held object,
      but an "OK" touchslot must be touched to confirm the change
      dropping the object without confirmation will cancel the change

08 février 2022:
***anyshape touchslot
**Gutter touchslot (=="wrapping" touchslot)
    challenge border belongs to target touchslot
    so when you have the correct result you can validate it even more easily

03 mars 2022:
**n-step'd multipathmade: record: obj1: move1 then move2 then moveN, then obj2: mov1 then mov2 then movN then objN: ...

08 mars 2022:
***writing pad
    Pick a placeholder, write digits sequencially or whole number at once : placeholder is now the written number
    Associated challenge : write then 2 ops then target (for example : find what to write in order to complete operation sequence :
    [[< >]] [+12] [+16] == [[73]]
    The ops _must be used_ (red light for unused and green light for used) for target to be touchable
    Last written number is kept as pad background

**(*)step-by-step 'reveal' along computing (Pythagore):
    1. A geometrical situation is displayed and some labels are wells (example : a and b in the canonical Pythagore config)
    2. when a^2 is created via [[a]] * [^2], the square with area a^2 is revealed
    3. etc

challenge avec arrondi (opérateurs d'arrondi)

**workZone/submitZone
    En haut on triture, on travaille
    En bas, on répond

**edu:vérifier une fois une solution trouvée

***Time control / time picker/setter pour l'écriture/édition de fonctions complexes

**fun/experience: Dizzy POV: pov's scaleX and scaleY oscillate around the mean value
                             so that current scale is not precise, only mean scale is experienced

**semantic disposition of text: main ideas in front, sub ideas are deeper (really "sub")
    autoread: keyframing reading povs
      there would be different degrees of reading:
        shallow: only front words
        full depth
        semi-deep
easy: no-brainer textual pov keyframe animation:
  1. some pov contain "title" icTexts
  2. user types the sequence of words in a textConstructor: [povAnim:  ["corbeau","renard","fromage","mare"]]
    => a keyframe animation is created, moving from titled pov to titled pov

14 mars 2022:
***scroll to control what is target in expression
      navigate expression tree by scrolling
      current target is highlighted
      when operated on, new target is operation result

18 mars 2022:
**challenge:: (x;y) coordinates:
    1.student grabs the point for which to determine coordinates
    2.cross can only move vertically and when it has reached x-axis, then it becomes free
    3.cross can then touch the appropriate x-coordinate, in an operator cloud around the grid
    4.student has then to move back to the point so that it fills the x-coordinate slot
    5.cross can now only move horizontally and when it has reached y-axis, then it becomes free
    6.cross can then touch the appropriate y-coordinate, in an operator cloud around the grid
    7.student has then to move back to the point so that it fills the y-coordinate slot
    8.done

21 mars 2022:
  0 refaire des maths complexes en essayant de les coder dans iC

11 avril 2022:
**Voice control: greenMouse moves to perform the operations told by user
    trajectory is controlled so that no unwanted middle-man operation is performed

Quand on fait rightClick pendant un drag, ça fait un draglock (on peut lacher le leftClick)
  et quand on rappuie sur le leftClick, ça reprend le drag comme d'habitude

**"dragCancel": rightClick when dragging cancels last operation
      or simply ctrl+z while dragging

26 avril 2022:
*pathmade:"draw below"/"instant trigger":
  1. pathmade path drawing can start where an object [[x]] lies
  2. when path drawing is done: pathmade touchSlot spawns right below [[x]]
      so that [[x]] * [pathmade] occurs immediately after end of path drawing

**gm/pathmade challenge: draw function and start: function and gm are reset if target is not equalled

27 avril 2022:
((*en "recherche créative", il y a une inspiration qui vient du fait de vivre dans l'environnement des objets.
    C'est par la connivence avec les objets que viennent de nouvelles idées.
    Les objets, par notre intermédiaire, donnent naissance à d'autres, et etc.

29 avril 2022:
edu: le fait de devoir se débrouiller avec moins d'opérateurs que prévu est une situation pédagogique forte

30 avril 2022:
dump:
IC::Weight and price: player must take the right weight of each product and get total price as target (correct target is not displayed):
      a pricedObject is taken from a drag well then we
      display = image (tomato) + weight + price,
      starting object weight is 1kg

IC::pathmade:: operator level: when object follows path, its level is also downgraded to the path level (level of operators crossed along the path)
                so that user functions are well separated from primitive operators

IC::gm: first with x, then with 5, 15,...

Ic::edudemo avec segment coupé en 10 morceaux (Z-scroll pour montrer les dixièmes,centièmes...)
  Et aussi les dizaines, centaines, etc.
IC::growing ruler : starts at 1grad and then grows or shrinks : unit1 is kept visible

**IC::(rei) challenges: target is cryptic (3/2 * x + 3/2 * x + 5) (coming from another operator set)

**IC::gm VS (2 players): two sides of operators, one shared target

IC::incarnated number
  Lock and key :
    Object is key and incomplete door to perfectly fill
      Line
      Square
      ...

**challenge: Que va faire ce chemin ?
      On peut suivre le chemin pour avoir la réponse
      On gagne plus de points si on trouve sans manipuler

02 mai 2022:
**challenge:gm:numeration [+ 10^6,..,+ 10^-6]: "rootScaled" operators: [+ 10^6] is at big scale, [+ 10^-6] is at tiny scale
    z-scroll is at the heart of the gameplay: contactArea and "contact scale" allow scale-specific interactions

**challenge:gm:prime decomp: [x 2,x 3,x 5,x 7, x 11, x 13, ...]
**edudemo:gm:prime decomp "by hand" (try / 2, then try / 3, ...) (use inverse operators or undo when "it does not work")

03 mai 2022:
((le temps de la récolte
*[
0 numération:
    0 opérateurs dans le désordre (random on operators order)
        exemple: [+10,+1,+1000,+100]
    1 [+10^3, +10^2, +10^1, +10^0]
      1 valid display
    0 paires [+k * 10^(n+1), - 10^n] pour voir s'ils ont bien compris (il faut qu'ils arrivent à se débrouiller)

    0 version longue: [+10^6, ..., 10^-6]
      0 version semi-longue: 7 opérateurs
      0 version longue: avec opérateurs au dessus

    1 ensure target is integer when working with [+ 0.5]-like operators
      (0 operator must be used nk times

0 relatifs
    0 [+10,+1,+0.1,+0.01]
        start dans [ -5; 0] et target dans [0;5]
        start dans [-10;-5] et target dans [0;10]

        start dans [-15;-10] et target dans [-10;-5]
**  0 display graduations at center with initial/current and target

0 approximate
0 sqsqrtpow
0 relations
    order
0 misc
*]

04 mai 2022:
***challenge::gm::révise tables:
              [x 6] [x 7] [x 8] [x 9]
        [[1]]                         [t t]
              [x 2] [x 3] [x 4] [x 5]
      simplifier 1 x 4
      mais ne pas simplifier 4 x 4

challenge::gm:pow [t 2^3 x 5^4 x 7^2 t]

challenge::gm:functions
        [[5]]          [t t]
            [f] [g] [h]
            label: f(x) = 3x +  2
            label: g(x) = 5x -  1
            label: h(x) =  x + 10

        [[5]] * [f] = [[f(5)]]
        [[f(5)]]  * [g] = [[g(f(5))]]

**challenge::gm:système d'équations: each equation object is also a substitution operator for the active equations object
    [[x + 5y = 8] * [[x = 2y]] = [[2y + 5y = 8]]
    [[2y + 5y = 8]] * [réduire] = [[7y = 8]]

**la soustraction "sobre" (la soustraction des petits): faire une transformation nulle quand on essaye de retirer plus que possible

05 mai 2022:
challenge::gm:units
  [grow unit]/[shrink unit]
  0 m
    [/ 10 (number) x 10 (unit)]
  0 m²
    [/ 100 (number) x 10 (unit)]
  0 m^3
    [/ 1000 (number) x 1000 (unit)]

**display mathsteps step by step solving with ic::gm moves and interactions (make it a-live)
    https://github.com/google/mathsteps

06 mai 2022:
**(*)gm::stained gm: if you use a red operator, gm is stained red
    [[1]] * [+3 {red}] = [[4 {red}]]
      colored target: if target is blue and gm is red, it won't validate
  edu: c'est un levier pour amener les élèves à n'utiliser que certains opérateurs, ou alors pour les amener à chercher d'autres opérateurs, même s'ils sont _loin_

**structure:challenge::ping pong: validated target becomes initial, player continues holding gm,
    operators are changed, old initial is set to new target
    so gm goes right, then left, then right, etc.
  edu: this allow chain-testing different skills (one skill ->, another skill <-, etc.)
  edu: cela habitue l'élève à des enchaînements de transformations (comme dans les longs programmes de calcul, ou dans les longues séquences de déduction)

07 mai 2022:
**gm::composite operators:
    tree-like:
      [x 2 x 3] <=> [x 6]
      [+ 3 x 4] <=> [+ 12]
    sequential:
      [+ 3) x 4] <=> [+ 3] then [x 4]
    use them for
      frac
      pow
      numexp
      litexp

*gm::"out_of_the_box": player has to transform target instead of initial (there's no other way)

***gm::teleport-spread challenge: challenge is spread on many courses : using a teleport-modified operator teleports to "same position but on a different course"
   edu: units: one course per measure unit
   course-shift operators:   [<--]   [-->]
      [    ]    [    ]   [     ]   [   ]
      [  km]    [  hm]   [  dam]   [  m]
      [    ]    [    ]   [     ]   [   ]

**zone unit-projector: zone is operator which converts incoming object's unit to zone's unit

edudemo: function "painting": dragged is operator
    starting configuration : a collection of numbers along the x-axis, each corresponding to their x-axis coord
    when user touches an x-axis [[number]] with the [f] dragged operator, [[number]] transforms into [[f(number)]] and moves to its corresponding y-axis coord
      [f]_dragged * [[x_value]] = [[y_value]]

(champ d'innovation interactive

08 mai 2022:
edudemo: units: legend-scroll: unit segment adapts to scale (à la kookleMaps)
**units-bloom: show different segmentations of object wrt different units

**fractal operator/shared isTouched:
    a big [x 2] operator contains smaller operators inside [+ 3] [x 4] [/ 5] [x 2]
    [[object]]_small * [x 2]_small = [[object]]_big
    but [[object]]_big does not immediately react with [x 2]_big, since isTouched is shared
  edu: this allows progressive growth of number

09 mai 2022:
(delirium: true-scale piano: use ic::xylophone keys as true piano keys to make music with
  il faudrait trouver un moyen de se déplacer rapidement dans le scale: ?"scale gloves"? (se recompliquer la vie pour le plaisir)

**create a collection of equivalent operators: [/ 2] <=> [x 1/2] <=> [x 2^(-1)] <=> [x 0.5] ...
  edu: equivalent operators to create advanced challenges

*[creation]"randomness à la rescousse": générer des challenges aléatoires à partir d'une grande collection d'ingrédients et garder la recette quand c'est bon

11 mai 2022:
***![gm::challenges]: _different rewrites_ for initial/target and operators (!THIS IS ACTUALLY VERY IMPORTANT!)
  edu: étant donné que la réécriture/simplification est le vecteur principal de transmission, en fait, c'est là que tout se joue !
    (Du pareil au même, il y a une infinité de réécritures !
  dev: "dynamic rewrites"
    il faudrait programmer des réécritures qui s'adaptent au niveau de compréhension de l'élève
      élève en cours de compréhension: mettre des réécritures "explicitantes"
      élève qui a compris comment ça fonctionne: réécriture "cible"

15 mai 2022:
(idée bizarre à essayer: "random eval" operator: [[3x² + 8x + 9]] * [random_eval(x) {1,2,3,4,5}] =_exmpl [[3(3)² + 8(5) + 9]]
  each math.SymbolNode(x) appearing in the expr tree has its own evaluation

(eval inverse operator: deval [[3*2² + 8*2 + 9]] * [deval 2] = [[3x² + 8x + 9]]

17 mai 2022:
*edu: the more the student understands, the less we can simplify/rewrite the expressions
    because the number is less and less a writing but more and more an idea

(2d-array of challenges for compound units:   m   m/s  m/s²

18 mai 2022:
gm::challenge::stats: user can grow a collection of values and then use an operator to get to target
                            [add value] [add value] [add value]
                                      (may be random)
  [[initial collection]]                                                          [[target value]]
  (may be empty)
                            [statitistical operator (== collection operator)]

  0 moyenne
  0 frequence
  0 étendue

(((idée farfelue: avec 2 écrans: affichage inversé: l'affichage correct des opérateurs est sur l'autre écran,
                                                     il faut regarder l'écran de l'autre,
                                                    et l'attendre avant de valider car sinon ses opérateurs sont rafraîchis
                                                    (P1.operator.display is on P2.screen)

gm::challenge:geometry: soul-moving mouse: gm's body does not move but gm's soul does, and this activates the operators which transform gm's body
  edu: this allows transformations such as translations, rotations, homotheties, ...

20 mai 2022:
**gm::challenge::litexp: operation combination: [x 2] [/ 6] for target, [/ 3] for op

0 litexp: operation combination: [x 2] [/ 6] for target, [/ 3] for op

0 sqrt:
    sqrt1: racines faciles
    sqrt2: racines et [x (-3)] (afficher brièvement [["erreur!"]] ou [["impossible"]] quand on veut faire sqrt(-3) )
    sqrt3: réécriture de racines

0 développement automatique:
  [[(1 + 2)]] * [x 3] = [[(3 + 6)]]

0 [estampiller motif en haut à gauche] [sym horiz] [sym vert] [rotation] [colorier en rouge] [protéger]
  (à la color balls)

0 carrés colorés (ou chaîne de caractères): multiplication qui recopie le motif à la fin VS multiplication qui multiplie chaque carré
    [[abc]] * [x 2 "copy"] = [[abcabc]]
    [[abc]] * [x 2 "map"]  = [[aabbcc]]

0 dessine quelque chose : des opérateurs [coordonnées 2D] sont donnés en haut, et rafraîchis après chaque touch,
    [[crayon]] * [coordonnées 2D] = un point est inscrit dans le repère à droite

((faire un truc avec les nombres en écriture à l'envers (symétrie axiale pour introduire les nombres négatifs)

0 cycle 2/3:
[[000]]																																													[[549]]
        [changer chiffre des centaines] [changer chiffre des dizaines] [changer chiffre des unités]

23 mai 2022:
gm::challenge:litexp: écrire l'expression littérale qui correspond au programme de calcul

0 eq1b: use close-to-0 rhs
    [[x - 67 == 1]]
    [[x - 38 == -2]]

0 eq2_add: +/- magic
  0 [[x + 13 == 22]] should become [[x == 22 - 13]]
    rhs__start must be kept as is, in order to demonstrate the +/- magic
      => rhs starting value should be treated as symbol
**edu: "symbole numérique"

0 eq3_magic: make them use magic
** magic operators: [- = --> = +] [+ = --> = -] [✕ = --> = ÷] [÷ = --> = ✕]

26 mai 2022:
**symbolify(mathNode): use random generated string for symbol name
    (on peut rendre symbolique n'importe quelle node)

27 mai 2022:
ic::gm::"target by tests" challenge: built gm must pass all target tests
  target test is gray at start
  target test becomes green when passed, red when not passed

ic::gm::ghost denial
ic::gm::par break: gm dies if above par
    ctrl-z can bring gm back to life if drag is still on

30 mai 2022:
*[structure]gm::challenge:en 4 opérations _exactement_
      [- ]  [- ]  [- ]    [x ]

  [[initial]]                 [[target]]

      [+ ]  [+ ] [+ ]     [x ]

*gm::challenge:vecteurs
    v1: [[initial]] et [[target]] et [[current]]: montrer le vecteur et ses coordonnées
    v2: [+ vecteur], [- vecteur]: montrer le vecteur et ses coordonnées
    v3: there is a [norm] operator and target is a number


**gm::challenge::numexp:edu: réutiliser les "nombres expressions" des réussites précédentes dans les nouvelles instances des opérateurs
  au lieu d'écrire [x 4] on écrira [x (13 - 5)/2]

**gm::challenge::numexp:tables de multiplication en nombres expressions (on rafraîchit les opérateurs toutes les 10 questions)

**gm::challenge: moving operator changes its effect (its "node_b" if it's a binary operator):
      |-----------------------------------|
      |zone(1)          |zone(2)          |
      |                 | [+ 2]   [/ 2]   |
      |-----------------------------------|
      |zone(3)          |zone(4)          |
      |      [x 3]      |     [- 4]       |
      ------------------------------------|
      on peut faire la même chose avec des node_b en litexp   [x (4 - <?>)]
    fun: bouger le gm well change la valeur initiale et bouger le target change la valeur cible

    challenge:zone(+10) to zone(-10) in lines
        zone(+10)
        ---------
        zone(+9)
        -------
        ...
      edu: this would be used as a summary of the use of relative numbers with [+][-][x][/]
        this could be displayed with a gradient: positive : red, zero: white, negative: blue

**[structure]gm::challenge: use each operator at least once before challenge refreshes
    user accomplishes initial --> target many times, so that they end up having used at least once each operator of the challenge
    already used operators are highlighted so that user knows which one remains
    an operator that has been already used can still be used
    edu: les amener à pratiquer tous les chemins, même ceux qui sont chiants

**(*)gm::challenge::numexp: fabriquer des "morceaux équivalables" dans le target, que l'utilisateur devra équivaloir en utilisant les opérateurs

**gm::challenge::conversion/equations:
    [[initial: 1 blue gem]]                       [[target: 22 red gem]]
          [x 2] [+ 5] ... [conversion operator: 3 blue gems = 1 red gem]
    conversion operator is always "last move"

***tables X decimal:
    variante 1:
          [x 6] ...  [x 9]    [/ 10]
      [[1]]                             [[0,32]]
          [x 2] ...  [x 5]    [x 10]

    variante 2:
          [x 0,6] ... [x 0,9]
      [[1]]                   [[0,04]]
          [x 0,2] ... [x 0,5]


**gm::challenge:proportionnal: target is missing cell in a proportionnality table

**[display]gm: object as string: show [[un]] instead of [[1]], [[deux]] instead of [[2]]
      [[un]] * [+ 5] = [[six]]

**[display]gm: operator as string:
    [ajouter deux]
    [soustraire le nombre de départ] (initial banner displays what was initial object)

**[display]gm: target as string: [[somme de 32 et 4]], [[différence entre 4 et le produit de 5 par 10]]
    edu: pour faire assimiler le vocabulaire, on demande uniquement des cibles du genre
      [somme de < > et de 4]
      [différence entre < > et 4]
      [produit de < > par 4]
      [quotient de < > par 4]
      avec une zone de challenge:
            []  []  []  []
              composer le nombre de gauche
      [[]]                                      [[]]
          [+ 4] [- 4] [x 4] [/ 4]

**tree scroll(==highlight scroll): scrolling changes which part of active litexp object will be operated on
    [[3 + _1_]] * [x 2] = [[3 + _1 x 2_]]
    [[_3 + 1_]] * [x 2] = [[_(3 + 1) x 2_]]

**edu: tables: réactivation instantanée: au tour n, afficher dans banner2 (au dessus de target) l'égalité que l'élève vient de réussir au tour n-1
    une image statique qui va potentiellement se fixer dans la tête de l'élève

fun: chiffre de César:
          [.a] [.b] [.c] [.d]
    [[""]]                  [[xtyz]]
            [<<3] [>>3]

**gm:challenge::fractions: utiliser indiféremment [/ 2] et [x (1/2)] dans le challenge


**gm:challenge::fractions: montrer avec des visuels (coeurs à la Zelda par exemple) que [/ 2] et [x (1/2)], c'est différent mais ça revient au même
    [/ 2]     = on applique / 2   à l'ensemble
    [x (1/2)] = on applique x 1/2 à chacun

    [[3 coeurs]] * [/ 2]   = [[1,5 coeurs remplis et 1,5 coeurs vides]]
    [[3 coeurs]] * [x 1/2] = [[3 coeurs à moitié pleins]]

((Is [( )] the same operator as [symbolify] ?

01 juin 2022:
gm::challenge::frac:: frac stacks

**[structure]gm::challenge:color collection: bottom operators are actually buttons that switch between top operators collections
**gm::challenge:color sequence: player must reach [[target]] using operators and respecting colors order
                     []   []   []   []
                    color collection operators

    [[initial]]     color order: green;red;blue;red;white   [[target]]

                [blue] [white] [red] [green]

**gm::challenge::numexp: 3 [eval]s allowed: allow player to evaluate its numexp 3 times
      [=] operator

(there exists: saturating addition/subtraction: result is clamped to stay in [min;max]

**gm::probabilities: blinking operator: pour montrer [x X(w)]: afficher des réalisations à chaque tick: RandomNode(arr_values, arr_weights)
    operator is constantly blinking with possible outcome values
**gm::probabilities: static operator + temporary blinking output (Mariokart-style):
    output blinks in the probability-style during 0.777 seconds before locking on a value
**gm::probabilities: permanently blinking object: [x 2] [+ 3] and such operators change random range but object continues being random

02 juin 2022:
**gm::range:
    [[range]]                                   [[target range]]
        [∪ [2;3]] [∩ [-1;1]] [complementary] [∩ ℤ]
    1. easy range
    2.
    [x 2] can be interpreted as grow any component by 2

**gm::sets

03 juin 2022:
gm::challenge:: obstacle waterfall: [operator] will be applied in <n> turns
  edu: il faut prévoir à l'avance l'effet de l'opérateur

06 juin 2022:
**gm::challenge:dec_to_sci
    [[target]] == [[2 x 10^2 + 4 x 10^1 + 3 x 10^(-1)]]
      1. small exponents
      2. all exponents
      (3. shuffle terms --> edu: may bring confusion
      3. sum of minisci       4,6 x 10 ^3 + 1,2 x 10^1

**(*)gm::challenge:money: [[target]] is a certain amount of bills and coins and operators are [+ 5€]
      [[current]] is displayed in bills and coins too
      1. [+ 1€] [+ 5€] [+ 10€] [+ 50€]
      2. subtract operator
      3. mult operator
      4. divide operator
      5. transition vers les équations: utiliser deux monnaies avec un taux de change facile  (5 reals = 1 euro)
      6. transition vers les équations: acheter quelque chose

**gm::opérateurs conditionnés: [if input>100: x 10] [if input<0: + 25]: il faut trouver un chemin pour aller de [[initial]] à [[target]]
    edu: this way player practices arithmetic as well as logic

07 juin 2022:
gm::challenge::numexp/litexp: factorize/develop
    i:[[0]], o: [+ 2(x + 1)] [- 3(x + 4)] [+ 6x] [- 4x], t: [[5x - 10]]
    1. with step simplify
    2. without step simplify
    3. develop/factorize gymnastic
          [factorize] [develop]
    [[0]]                         [[2(x + 2) + 3(y + 4) + 5]]
          [+ x] [+ y] [+ 1]

**gm::new argument building workflow:
      [[0]]          * [+ 2]     = [[0]__+ 2_   (proto object)
      [[0]__+ 2_     * [x 3]     = [[0]__+ 2 x 3_
      [[0]__+ 2 x 3_ * [realize] = [[0 + 2 x 3]]

***[structure]gm::"super" gm: a super challenge is proposed, and in order to activate one of its operators, the operator's sub challenge must be completed
      [[super initial]]                                   [[super target]]
               [[super op]]
              []           []       etc.
                [] [] [] []
            super op's challenge

      edu: this structure is interesting
        because it promotes decision making
        because it can grow scale-invariantly
        because it shows the moving back and forth from top-level to low-level
        because user can complete all sub challenge if they have no clue on how to solve super challenge
        because solving a sub challenge may give ideas on how to solve the super challenge

09 mai 2022:
**gm::at least images: for unsupported browsers, provides a few images of each challenge to display in classroom

**gm::different types of target slot:
    "writing": expression must match exactly
    value:     expressions can differ as long as evaluation is the same

***gm:teintures de franchissement:  i:0     o: [+ 25] [- 25] [if>100: paint red]    t: [red -50]
        edu: cela oblige les élèves à passer par certaines valeurs
***   on peut complexifier encore en mettant la couleur comme condition: [if(red): x (-1)]
        edu: on mélange arithmétique et logique
      remarque: technique de game design à l'ancienne (Super Metroid, ...)

12 juin 2022:
**gm::challenge::frac: simplify(n)  [[frac{5x6x7}{6x8x9}]] * [simplify(6)] = [[frac{5x7}{8x9}]]
    operator display: [frac{stroke(6)}{stroke(6)}]

(?**symbolification levels:  [[symbolified(level 2)]] * [operator working on symbolified(level 1)] = [[symbolified(level 2)]]

17 juin 2022:
**gm::challenge::litexp: expression as arg: banner: A = 3x + 2 , B = 5x - 4,  i:[[0]]  o:[+ A] [- A] [+ B] [-B]  t:[[11x]]

**gm::challenge::num: make a number which reaches inside of cloudy area
      the number line is diplayed
      a part is cloudy
      a bloom is displayed (segment bound to [[current]])
      target touchslot still exists
      player can validate when segment end is inside cloudy area
      edu: this is to make link number as segment of length -> number as point on the number line

20 juin 2022:
**gm::motifs bitmap et opérateurs sur les bitmaps
		inverser les couleurs
		inverser le bit central
		décaler gauche/droite
		projecteurs:
			rouges deviennent verts
			colonne de droite devient entièrement noire

**gm::mathador touch

***gm::"l'Atelier": système d'équations
    i:[[10x + 9y = 2]]   o:[platform +]               t: [[x = ?]]
      [[5x + y = 1]]       [x 2] [x 3] ... [x (-1)]      [[y = ?]]
                           [+ 2] [+ 3] ...

**gm::π::
    broken line/curve bloom:
      when doing * [+ 1]: a segment is appended to the broken line/curve
      when doing * [+ π]: a half-square curve is appended to the broken line/curve
      when doing * [+ π] * [+ π]: curvature is reversed so that the line does not close itself

23 juin 2022:
***gm::clear dying curse when reaching target in order to show different solutions
    edu: this way we can display different equivalent expressions
   gm::challenge: many ways : challenge renews when player has found n different possible solutions

27 juin 2022:
**edu:: key: next display mode: pour passer facilement de [+ 3] [✕ 2] à [x ↦ x + 3] [x ↦ 2x]
    et montrer que l'opérateur ne change pas, seulement la façon de l'écrire

28 juin 2022:
**gm::challenge::sequence operators: snap the sequence
    there is a snap slotted platform operator in the center
    bottom and top operators only work when snapped in platform operator
                [+ 2]  [✕ 3]  [- 8]  [+ 4]
    [[i]]  [platform with snapslots: [] [] [] [] []]    [[t]]
                [-1] [+ 10] [✕ 7] [/ 2]

**gm::challenge::litexp: build then eval
       [+ 3x] [✕ 4x] [x 3] [- x]
  [[x]]                           [[12]]
        [x <-- 2]  [x <-- 3]

30 juin 2022:
**[structure]gm::challenge: 3 targets with chests: reward is operator which may help to open the other chests

*[mechanic]gm::Merge: [+ 2] *merge [+ 3] = [+ 5]

**(*)curse: diminishing number: [[1]] -time> [[0.98]] -time> [[0.96]]
    edu: this is to insist on the fact that numbers have neighbors, that the number line is full of numbers
    [[-1]] -time> [[-1.02]] -time> [[-1.04]]
**diminishing curse operator: [curse: diminish]

**"glass" curse: must stay pair

***Interface: PAUSE: freeze GM and free mouse cursor
      GM.state = Frozen
      edu: this is to enable conversations with students at the middle of an attempt

**gm::challenge:litexp: build a litexp which satisfies the transformations in target banner
      example:                  {3 -> 4 ; 12 -> 15; 20 -> 21}
      [[0]]                       []
          [+ x] [- 2x] [✕ 4] [/ 5]

***edu: concept introduction: concrete situations challenge mix
      mix standard number transformation challenges separated by similar transformations challenges of not-number things
      example:
      i:[[pizza drawing]]             [[quarter of a pizza drawing]]
                [- 1] [+ 2] [✕ 5] [/ 4]
      edu: operators _may stay numerical_ to promote a discussion around _units_
      in some case,     [[pizza]] * [- 1] = [[7/8 of a pizza]]
      in another case,  [[pizza]] * [- 1] = [[1/4 of a pizza]]
      in another one,   [[pizza]] * [- 1] = [[nothing]]

**[structure]gm::challenge: make 0
    edu: use number symbol so that [[current]] is [[i +/- arg (+/- arg...)]]
    numer::analog computing:
        i: [[29 x 42]]                      t:[[0]]
              [- 1218] [- 8112] [- 128] [- 12184]
    edu: pour habituer à la relation entre [[- 50]] (nombre négatif) et [- 50] (soustraire 50)
    negat: [[50 + 12]]                  [[0]]
              [- 50] [- 62] [+ 52] [- 3]

26 juillet 2022:
**iC::TH (TreasureHunt): mettre des chasses au trésor dans une partie /fun du site (qui peut servir de tutoriel)
**iC.obj: followMe: one-way screen-pushed voyager

***(*)paper user interface: QRCode-cardback
    usecases:
      paper jukebox: user has a deck of cards with song names, which will play as soon as their qrcode is scanned
      paper zoo: child has a deck of animal cards, which will spawn in ic

***GM as card game:
    cartes opérateur ([x 2], [+ 4], etc.)
    qrcode sur le dos de la carte
    objet sur le téléphone [[3]]
    pour appliquer l'opérateur, on passe la carte opérateur sur le téléphone, dont l'objet va se mettre à jour

***ic for tablets:
    left half: pan/zoom
    right half: draw

**Twinstick drawing:
    LeftJoy   Pan
    RightJoy  Move/Draw
    RTLT      zoom/dezoom

**on drop addition: [[2]] *d [[3]] = [[5]]

***edu: calcul mental en 2 temps:
    1. montrer des objets, plus ou moins mélangés, chacun en un certain nombre d'exemplaires
    2. Donner le prix unitaire de chaque objet et demander combien ça fait
    Rq: on peut ajouter des billets qui fonctionneront comme des objets à prix négatif

**create patterns using probabilities: [[100X + Y]] is represented as a comb
***dynamic bloom (==bloom X probas): dynamic segments and colors

**gm:challenge: partie entière/partie décimale: Target is some part of initial, player has to CLAMP using [x 10], [/ 10], [floor], [decimal_part], ...

**gm:challenge::functions:
    1. [d/dx], [* x], [+ 1]
    2. [intégrer avec une constante aléatoire]

**gm:challenge: last thing is to evaluate:
    1. player creates litexp
    2. player uses [x <- 3] operator to transform litexp into value
      Using assignment operator transforms all operator into [id]

gm:challenge:solution/no_solution:
  player has to choose if there is or not a solution (-1 point if they say there is no sol when one exists)

gm:opérateurs de grignotage de tablette de chocolat: [-1 sur 2], [-1 à la fin], [x2 horiz], [x2 vert]
  (validation sur le principe des serrures)

**easy: this.qrcode: show qrcode of current url for others to join

27 juillet 2022:
**easy: construction/mutation from text object: iCTextConstructor
    example: to generate QRCode image:
      1. create iCTextConstructor
      2. write "qrcode myFabulousInputText" as args
          then iCTextConstructor mutates into icQRCode or icImage
    example: to generate video object: "video https://myAwesomeVideos.lol/vid1.mp4"

(**game: time puzzle: pieces are videos and user has to find the right frame for each of them in order to recreate puzzle (some of them may be static in order to give a little hint)

01 août 2022:
**easy: vitrifier: lock all objects
    scope vitrifier: lock all objects fully inside screen rect boundary

02 août 2022:
**(*)(TH)timewise double-object: front object is video and back object is shown only when video.currentTime is valid
      this way, player has to concentrate on the video content in order to determine where in time is the back object
      edu:this way we can associate an exercise/challenge with a special moment in the video

**drag-and-drop heliport: this object waits for user to dnd content in it
    it may be data, link, text...

05 août 2022:
***to record a recording (!= record):
      in order to create tutorials that show record creation and use

****functions which output functions (pathmade which outputs pathmade):
      in order to have functions as first-class objects

**Th:rainbow anagram of rebus: rainbowify(arr_symbol)

edu: autosum(collection of objects and their prices)
  show intermediate numerical expression
  show result

**(*)challenge sausage with [uncurse] and p[GM_dropslot]p intermediate challenge sections
    p[GM_dropslot]p allows to pause for a while, and to work with a intermediate result
    [reset] operator brings back to start
          |  [+ 4] [- 3] [+ 1] [uncurse]                    | [+ 4] [- 3] [+ 1] [uncurse]                    |  [] [] [] [reset]
    [[i]] |                               p[GM_dropslot]p   |                           p[GM_dropslot]p      |              [target]
          |  [- 1] [+ 5] [+ 10] [+ 6]                       | [- 1] [+ 5] [+ 10] [+ 6]                       |  [] [] [] []
    edu: this system allows the making of very complex problems

***TH:ICU (à la pokémon snap):
      player has to take captures of items in a list inside the ic
      photos are automagically placed on the side of the corresponding list item, along with a checkmark

**Z-index for paths: OOO: last created is followed first
    many ways to do it but "remember previous 'owner'", so that paths are env-agnostic, seems elegant

*ic::video:controls:fun: slider is far away from video, or too big/too small

**iMc: infiniteMusicalCanvas: music contains different scales of content ('zooming' == 'reducing playing speed' )

**ic:calendar: one cell for each day, which may contain a lot of information

***ic:p2p: no master server, only a web of clients

***easy: portal creation ('echo' portal (==object-based portal)):
    1.select in canvas the object to portal into
    2.create echo portal
    3.move the echo portal at the desired spot
    now, entering the echo portal will do the same as entering the original object

**[structure]ic::challenge:experience impermanence: when any operator triggers, it also affects all other operators (and [[initial]], and [[target]])
    example that is actually useful: [MAJ]* {[.a] [.b]} = {[.A] [.B]}
      activation of MAJ operator transforms [.a] and [.b] operators into their uppercase equivalents

07 août 2022:
**ic::time portals: portal drives you to videoObj _at time x_

10 août 2022:
**serialize as .js: const <name> = {};
    + textConstructor(infinishute <name>)
    in order to create maps or webpages: textConstructor(infinishute house), textConstructor(infinishute road)...

11 août 2022:
**edu: th for maths: this could be used as homework
      answer should be a generator so that each student has a different solution (prevent cheating):
        generator example: a word starting with the 2nd letter of your firstname
        generator example: (last digit of your birthyear) x 100 + (last digit of your birthday)

14 août 2022:
**ic:hardsplitter: destroy image into shards

vocabulary:endoTouch (==inner touch)

***ic::control bloom: long press on icobject makes the _control bloom_ appear. Then you can pick and drag one anywhere you like.
    Typical usecase: icVideo: play, pause, slider,...
    Other usecase: icImage: endoTouch hardSplitter for gunshot animation
***searchbar portal popper: search results are portals and there is a gobacktosearchresults keyboard shortcut


**ic:spatialized audio

**ic::eyetoy: object generation is triggered by particular webcam patterns (for example: bubbles come out of the mouth)

**easy input: white is transparent: white (or detected bg color) is 'alpha:0'

**TH:hidden objects: click to collect

**[concept]ic: les différents niveaux de publicité (pris au sens premier du terme): plus profond, plus intime

**ic::growing blob: object bounds grow like tentacles till it reaches a growth-stopping object

***p2p canvas kaleidoscope: no main server, only a myriad of client environments

15 août 2022:
(keyboard + touch: even more possibilities !!!

***textConstructor + "bud object": create clickMe "bud object" which will then require config steps to fully deploy
    example with cart edudemo (which requires an image selection step):
    1. textconstructor: "edudemo cart" --> a clickMe bud object is created
    2. clicking on bud object spawns the "import images" fileExplorer, user chooses images
    3. edudemo instance fully deploys

***textConstructor: spawning keyword can be registered in TextConstructor directly inside iC
    workflow:
      1. user creates a group of objects (which we could call a miniEnv)
      2. user selects the group
      3. keyboardShortcut: register in textConstructor --> <user inputs the keyword they like> (say "potato")
            so that  textconstructor: "potato"  now spawns a clone of the original miniEnv
    remark: the miniEnv could be more structure than content (something with snapslots or paths for example)

17 août 2022:
**portal paths: path goes through portal
    usecase: self-destructive programs: portal gets to rect containing program and erases it

***icObj.type="attractor": object attracts surrounding .isAttractable elements
    usecase 1: snapslot + attractor
      there is a question on canvas and a webcam input to answer
      kid spawns [[4]] with his fingers (via webcam input) ("ultra easy input") and [[4]] is slowly attracted to answer snapslot
        if [[4]] is the correct answer, answer snapslot will color green and [[4]] will stay in place
        if [[4]] is not the answer,     answer snapslot will flash red and destroy [[4]]

**from canvas to HUD: clicking on canvas object makes HUD element appear/disappear
**contextual HUD: entering/leaving canvas area makes HUD element(s) appear/disappear

*bounded spread: spread in enclosed area by smallScaling elements
  remark: encore une fois, l'idée, c'est de bien faire comprendre que c'est pas parce que c'est borné que c'est pas infini. Il suffit juste de "regarder plus fin".

**(*)zIndex reverser: if zIndex reverser is on area, all zIndex priorities are reversed (though zIndex reverser stays on front)
    edu: this object may act as a revealer for grid-based riddles

25 août 2022:
**easy: clone(n): instead of yielding 1 clone, user specifies how much they want
    2 main flavors:
      - "let me see what i'm doing":
        clone command via keyboard, arguments are on board:
          user wants to create 30 clones of objectX:
            1. user creates a mathNode [[30]]
            2. user grabs objectX
            3. user "keynitiates" clone command
            4. user touches [[30]] with activated objectX
            5. clones are created near [[30]]
        OR
        arguments are transformed into clone operator via keyboard:
            1. user creates a mathNode [[30]]
            2. user "keynitiates" transformation of [[30]] into [clone: 30]
            3. user touches [clone: 30] with objectX
            4. clones are created near [clone: 30]
      - "don't let them see what i'm doing":
            1. user grabs objectX
            2. user "keynitiates" clone command
            3. user types in required arguments
            4. clones are created near cursor

**icTrail: pathmade + trail: when activated, path draws itself
    this could be used to create romantic writings or drawings

infinishute::infinitePortrait: draw an ic of yourself, so that others can browse and discover you

***HUD portals: HUD object behaves like HUD when cursor is outside object rect
                but behaves like a portal when cursor is inside
      this allows to create always-accessible, always-near areas
      (if there are other HUD objects at 'same level', they may stay at this level and not be transported into the portal area)
      (but the contrary may also be possible)
      (as well as any situation between these 2 boundaries (==some follow, some stay))

***HUD portals::browse and collect:
    if getting close enough of a new collectible hud portal, it automagically snaps to HUD
      (a 'world' may have, say, 10 such portals to collect and then complete)
    a completed hud portal challenge will have a different appearance on screen (no more in HUD, or greyed, or, if containing nested portals, may indicate '10%', '50%', and a progress indicator)

**easy: mindmap: icText/icSegmentedLine --> icSegmentedComposite (or icTree)
    feature: be able to export the tree/graph structure in textual form

**edu: reactor: euclidian subtractor:
    [-12]    * [[135]] = [-12]{1} , [[123]]
    [-12]{1} * [[123]] = [-12]{2} , [[111]]

29 août 2022:
  0 Ic-ized web : create proof of concept web navigation
    (For a start, spawn ichtmlElement when clicking on URL)

IC storyboarding : create application storyboard in IC
  Example : put next screen storyboard inside button

**IcBegin<Tool>:
  Example: click on icBeginRuler begins a ruler session in which the standard tool keyboard shortcut activates the ruler (HUD indicates that the current tool is ruler)
  Edu: [icBeginToolX] is located in an exercise area dedicated to toolX practice

**(*)Multiscale handwriting:
    start writing at scale:1, then, _as you continue writing_, zoom to scale:10, so that the line is thick at start and then thin, and then maybe thick again
    combine it with a pov animation and the text line thickness stays the same but the rest zooms in/out
    this is like writing in a dimensional shift

**[store] operator as simple 'layouter': objects 'in' store are simply laid out (horizontally, vertically, anything).
    They are close-to-not coupled with the store : group select laid-out objects and then do what you want with them
    (any moving of stored objects kills their bind with the store)

**(*)[Repeat(n)]/[end_repeat]: autopath between loop bounds
  2 balises: une pour le début et une pour la fin : un chemin est automatiquement tracé entre les deux.
  Bouger les balises bouge le chemin avec.
  Toutes les structures de contrôle peuvent être faite en suivant ce principe
  edu : répéter un programme de calcul avec les élèves pour leur montrer que c'est la même structure qui se répète plusieurs fois (entourer d'une couleur différente chaque morceau 'racine', pour chaque itération)

**iCRandomBranch: on dessine d'abord puis on assigne les poids
edu: Arbre de probabilité avec trait d'épaisseur proportionnelle au poids et démonstration de tirages aléatoires sous la forme de parcours de l'arbre : on voit que le plus probable c'est le passage par les gros traits

**iCConditionnalBranch : on dessine d'abord puis on assigne les conditions

Mathgame.fr : créer une catégorie   activités élève,
                et  une catégorie   activités prof

    Pour chaque activité prof :
      un petit texte pour expliquer les contrôles clavier,
      un petit texte pour le déroulement de l'activité

**IC:solar system: draw path relatively to other object (moon around earth)
    example:
      1. draw sun-centered earth trajectory around sun
      2. draw earth-centered moon trajectory around earth
      3. animation will allow moon around sun 'resulting trajectory' to be seen

30 août 2022:
***easy:define object properties by touching core object
    example:
      1. user imports 5 [[image: strawberry]] (they all have the same image src)
      2. user picks one [[image: strawberry]] and transforms it into an object core
            [[image: strawberry]] --> [[core]]
      3. user creates [[3]] and makes it touch [[core]]
          now, [[core [[3]] ]] is a more complex object, it has the property: .value=3
               the other [[image: strawberry]] instance objects are transformed into composites
      4. if we select the 4 instance objects, and sum their .value property, the result will be 12
      5. 2 display flavors:
          -instance objects don't change: they all look like a simple [[image:strawberry]] (yet they have properties)
          -instance objects get the same visual surroundings as [[core]] and follow [[core]] as it mutates
      6. 3 editing flavors:
          - we may turn any instance into [[core]]
              as a result, the previous core becomes an instance (there can only be one core)
          - [[core]] never changes:
              keyboard shortcut + click on instance brings to [[core]]
              then one can edit [[core]]
              keyboard shortcut + click on [[core]] brings back to instance
          - we may turn any instance into [[core2 extends core]] (inheritance...)
***easy:object methods by touching core object
    it is the same as for properties, except now, we touch [[core]] with [operator]
    so now, polymorphism can happen:
      say we have [[strawberry [[3]] [x 2] ]]
      then [[strawberry]] * [strawberry] = [[6]]
    [operator] can be anything: for example, a pathmade operator (this may get tricky)
**edu: cart path: cart items have [+ <price>] method
  to get cart total price, you make [[0]] follow a path along the items

**[[hitbox_extension]]: a property which is not really a property
    in order to add properties to [[core]], it is nice to extend [[core]]'s hitbox, and [[hitbox_extension]] does exactly that
    then any object touching [[hitbox_extension]] will be added as a new property

Considering all instances as 'references' of the same object, then the object can be mutated at different places using pathmade procedures
  (atomic) pathmade procedure: a pathmade which ends on a property-to-be: the conveyed object will be conveyed to this new property (because it will land on it)
  edu: but this is not pretty functional programming, and should be considered only anecdotically

**layout: 'cart arrange': create lines/columns of identical objects
    edu: comme ça c'est plus facile à calculer
**layout: inline cart: create 1 line consisting of different segments of identical objects
    so that the cart path is straightforward

**(*)icEye (==screenRectImageListener): this object reads image input of given screen rect and reacts to particular image input
    output may then be redirected via a path to outputArea, to become the input of something else
    edu: qrCodeScreenRectImageListener over webcamStream = webcam qrcode reader
    edu: blueColorScreenRectImageListener: output [[1]] if blue color is detected inside, [[0]] if it is another color. (Don't output anything if there is no object inside rect)
    edu: le développement autour de la webcam est facilité car on peut d'abord passer par une étape où l'on glisse des images dans la zone du listener

31 août 2022:
edu: challenges simples: _puzzles en mosaïque_ basés sur la symétrie
  juste à prendre des icRect colorés et les replacer au bon endroit

01 septembre 2022:
operator bullet: [x 3] * [[2]] = [[6]], and [x 3] is consumed

03 septembre 2022:
*GET100 game: pretty physical cards' cardbacks by spreading tentacles from qrcode
    ? will this hinder qrcode recognition ?

*(*)GET100 game: bg gradient following gameState: 0 is blue and 100 is red
  example:
    if the gameState is current 45 and target 100: bg gradient will be yellow --> red

04 septembre 2022:
*GET100 game: card front could show a visual representation of the operator
    example:  ___________
             |           |
             |  ° --> °° |
             |           |
             |   [x  2]  |
             |___________|

08 septembre 2022:
*colorPicker palette-painting:
    1. import image of painter's color palette
    2. use colorPicker to pick colors from palette (as if it were a true palette)

09 septembre 2022:
*[  on coreify:
    when core is designated:
      no alike object has yet been informed to the system, and the system finds alike objects (there is a filter for likeliness)
        => "legitimate" alike
      OR
      alike objects have been previously "forced-informed" to the system: they may not be particularly similar to core
        => forced alike

    createIcGhost object and put it next to core
      ghost is a composite
      touching core with property object adds it to ghost
      once property object has been added to ghost, it can freely untouch core
      ghost can be moved away from its related core
      ghostLink:
        core.ghost -----> alike0.ghost (echo)
                   -----> alike1.ghost (echo)
          echo allows overriding inheritance: "alike0 extends core"
      destroying core.ghost destroys all the forwarding from core to alike

    we can imagine a geminiLink between all objects ("everyone is core")
        core.ghost (gemini) <-----> alike0.ghost (gemini) <-----> alike1.ghost (gemini)

    (? if empty core is coreified again, then its previous ghost should be destroyed
    coreify(empty core) = uncoreify(empty core) == original, "simple" object

    supereasy look and feel:
      all icGhost should stay hidden
      core should be hightlighted: stroke, strokeWidth...
      if property object untouches core, then it is removed from ghost

    easy look and feel:
      core ghost is shown, alike ghosts are hidden
      if property object touches core, then it can move away from core (it is now a ghost property)
      if ghost property object touches ghost(==composite handle), then it is removed from ghost
]*

**(*)"pathmadeFunction1.output --> pathmadeFunction2.input" link can be created by using ghostlinked duo
    pathmadeFunction1.output touches ghostLinkedObj1
    ghostLinkedObj1 ghostlinks to ghostLinkedObj2
    ghostLinkedObj2 touches pathmadeFunction2.input

    when the object which is following the paths untouches ghostLinkedObj2, it automatically removes from ghostLinkedObj1 and ghostLinkedObj2
      the ghostlinked duo is a serving hatch, a tunnel

**(*)ghostLineage: coreify(ghostlinked)
      to achieve proper inheritance, one may coreify an already ghostlinked object:
        1. select forced-alike
        2. coreify(ghostlinked):
              ghostlinked which had ghost1 is now core2 with ghost2 (and it keeps having ghost1)
        3. select ghost1 and touch core2 with it: ghost1 is now a property of ghost2
              forced-alike ghosts now have ghost1 and all its contents as props

10 septembre 2022:
edu: easy: build answer: record answer (GM) and when student clicks on icRecord, it plays answer record

12 septembre 2022:
(dump:
IC::qrcode user input/qrcode recomposition: icEye:
  this slot awaits for the right camera input (qrcode for example)
  or simply awaits for user to tap to capture current camera frame ("to-be-filled slot") (example: rally checkpoint validation frame (player must take photo at spot X carrying object Y))

IC:: angle et force (location aware touchoperators)
IC::angles et longueurs (le zéro du rapporteur change, le zéro de la longueur change) : connect dots

IC::will(_touch)/did(_untouch) modifiers

Create pattern using probabilities
  100X + Y donne un peigne
***Dynamic bloom : bloom X probas : dynamic segments and colors

Exp et log:
	[exp] [log] [sin] [cos] [tan]
	edu: l'utilisation du tree scroll est pratiquement incontournable (to easily edit expression)

**IC::gm::hidden value interaction: show that change happened but don't show object
  différents points d'interrogation pour montrer qu'il y a eu interaction mais ne pas montrer le résultat

**easy: ondrop addition: [[2]] *d [[3]] = [[5]]

(**easy: icMode
    this object is an immortal singleton (like Supervessel)
    available modes: "easy", "std", "supereasy"
    change mode by clicking on it
(**easy: swap to easy mode: icTextConstructor("mode: easy") (so you don't have to know where icMode is)
(**easy: background color changes with mode:
    easy:      blue
    std:       green
    supereasy: pink
remark: ça sent le menu tout ça, en plus un menu complêtement éclaté et dispersé...
  autrement dit: si icMode n'est n'est jamais implémenté, c'est peut-être pas si mal.

**easy: (x;y) tuple: using "on touch set property" engine
    [[(x;y)]] is a composite and [[x]] and [[y]] are cores
    if you want to associate value [[7]] to [[x]], you simply touch [[x]] with [[7]]
      [[7]] *_core_touch([[x]]) [[(x;y)]] = [[(x:7 ; y)]]

**machine: cartesian coordinate plane with [[(x;y)]] input
    [[(x:7 ; y:3)]] * [[machine: cc plane]] = point (7;3) is added to plane (and [[(x:7 ; y:3)]] may be consumed)

***edu: function plot pathmade manufactory:
    a manufactory is a pathmade interlocking of functions and machines
    0. user creates a collection of value_x
    loop(value_x) {
      1. put [[value_x]] as input of pathmade function f and get [[value_output]]
      1.5 [[value_x]] is retrieved using a bypass path around function f     ((pathmade function: identity)) ((==a simple wire))
      2. create [[(x:value_x;y:value_output)]]
      3. put it in cartesian coordinate plane machine to plot point
    }
      edu: l'idée est de montrer toutes les étapes, et de montrer la construction du graphe de la fonction au fur et à mesure

15 septembre 2022:
** gm:challenge (with exploration part): find function general formula
		1. system spawns blackbox function (each time with a different color and a different name (f,g,h,...))
        [f (orange)] ([x -> 3x + 4])
		2. there are many values available to try on function: [[0]], [[1]], [[2]], ..., [[10]], ...
        [[0]] * [f (orange)] = [[4]]
		3. gm is [[x]], and there are platform operators to create litexp to try on target touchslot

*one could create unremovable properties with coreConfig.canUntouchFunc
    (what would they be used for ?)

**(*)gm:spaghetti challenge: user can only draw 1 path to bring [[initial]] to [[target]] value, operators are scattered here and there
    this is the same idea as line 5041 "challenge: show me a path", but this time with loops as the primary concern
    pattern art with sequences of color patterns would be a nice variant of this challenge 
    edu: of course, user can draw loops and go back again to using left screen side operators
    edu: the interaction is so simple that it would be attractive
    edu: there is also a nice side effect with pathdrawing: 
      if player stalls the path while pathdrawing, to think about what to do next, the attempt will take more time when finally triggered
      so they may better prepare the path mentally before drawing it 
    => prérequis impératif: corriger les problèmes de double touch qui soulent
    => prérequis impératif: la GM (ou au moins sa contact_area) devra toujours garder la même taille

16 septembre 2022:
**edu: use growing icEngined to have a talk with students around speed and length
**edu: use rivetedSegment and HUDSegment to have a talk with students around fractions
    for example: show 1/3 1/3 1/3 with HUD Segment and show different lengths with rivetedSegment

17 septembre 2022:
**edu: gemini/echo (and computed/composition) can be used to create "reactive" eduDemos
    eduDemo: x=<a>, f(x)=f(<a>)=...: we use an echo of [[x]] in f([[x]]) so that, when updating [[x]], f([[x]]) updates automatically
    eduDemo: show [[x]] and create a big spread collection of reactive computed([[x]]): 2 * [[x]], 20% * [[x]], [[x]]^2, 10 * [[x]], ...  
      edu: pour donner "la sensation du nombre"

18 septembre 2022:
**(*)GM(composite): GM is a composite and target is a composite
  [structure] GM(composite)::challenge: sequence of transformations: we create [[ [[x]] [[f(x)]] [[g(f(x))]] ...]]
    edu: cette idée est bonne car elle montre les différentes étapes de transformation
      example:
  GM(composite)::challenge: "factor quest": target is a sequence of values, many [x ...] and [/ ...] operators are available
    examples: [[target]] = [[ [[1]] [[2]] [[6]] [[36]] [[12]] ]]
              [[target]] = [[ [[1]] [[10]] [[100]] [[25]] [[5]] ]]
    edu: the idea is to have a mental factor decomposition of basic numbers
  [structure] GM(composite)::challenge: append elements
    example:
      GM(composite)::challenge: sequence of colored rects: target is [[ [[blue]] [[blue]] [[red]] [[blue]] [[blue]] [[red]] ]]
        => this could be upgraded to challenge: draw path: sequence of colored rects 
      GM(composite)::challenge: "ascending order": gm is a store reactor and target is to have all values sorted in ascending order

**GET100::variant: Volley: team1 area is [0, 50[, team2 area is ]50, 100], 50 is net, the rest is out of bounds
    (Service may be random
    the goal is to send the ball back to the other side, using the operator cards
    we may have 3 touches on each side, or else it will be too difficult to send the ball back
    Smashing player may use special [protect] operator, that will force the other side to use 1 touch to [unprotect] 

**(*)[loop]: a path-targetting operator: [loop_begin(3)]     [loop_end]
    comme sur une partition de musique
    cet opérateur _crée un chemin qui boucle_, par dessus le chemin hôte qu'il shunte
    le chemin créé prend la priorité qu'il redonne une fois que la boucle est terminée

*edudemo/challenge: place object near its correct length (ruler or arrow): use zScroll to scale object
    1. 1 instance of each object:         to work on orders of magnitude
    2. multiple instances of each object: to work on fractions
    3. composition of objects: arrow.length = object1.length + object2.length: to work on sums of decimal numbers

21 septembre 2022:
**easy: use mouse to define gemini/echo 
	example: 0. press key to begin definition session	 
		 	 1. click on icText1: gemini source
			 2. click on icText2: echo
				DONE!

**easy: icComputed: "= this (clicked) + that (clicked)"
  	Computed is composite(icText__formula, icMathNode__result)
    clicked objects in formula may be icMathNode or icComputed
    edu: pour introduire les formules de tableur

**easy: assign value to symbol [[x]] by putting [[4]] over it
    [[x]] should now be considered [[4]]
    edu: [[x]] should now be slightly dimmed:   opacity: 0.5, or grayed 
          so that we see that [[4]] is the value to consider

**edu: reified spawned objects:
    to spawn a [[perimeter]], you have to select the target polygon
      then what happens, is that polygon side lengths objects are created
      and [[perimeter]] is simply a computed of the objects that are already on canvas (sum of side lengths)
      so that destroying a side length object should either:
        not be possible before removing [[perimeter]] object
        OR
        destroy [[perimeter]] object as a side effect
    edu: comme ça on voit d'où ça sort, on montre à chaque fois comment on a fait et ce dont on a besoin pour le fabriquer

**icGeminiLink: between obj1 and obj2, and carrying the gemini engine
    visually: we can show the link between the 2 objects
      gemini: 2-sided arrow
      echo: 	1-sided arrow
    destroying the geminiLink destroys the gemini behavior

22 septembre 2022:
*edudemo: function evaluation:
    top:     [[1]] [[2]] [[3]] [[4]] ...
                   [ ]
    middle:       /   "forwarder"
                 /
    bottom:    [ ]
        f([[x(core)]]) = [[<result>]]

gm:challenges: relative numbers
    0 target: [[ +3 ]], gm rewrite: [[ [[+1]] ]] * [+ 1] = [[ [[+1]] + [[+1]] ]]
    0 target: [[ +3 ]], gm rewrite:       [[+1]] * [+ 1] = [[ (+1) + (+1) ]]
    0 target: [[ [[+1]] + [[+1]] + [[-1]] ]]
		0 simple additions: [+1] [+ (-1)]
      edu: use color__positive, color__negative (for example: red and white)
**	0 use non-consuming platform operators like: [+ [[-1]] [[-1]] [[-1]] ]
		0 operator mix: [+2] [+3] [-2] [-3]
    0 transform initial with [+ 0] operators, target is [[?]] 
        initial: [[ [[+ 30]] + [[- 14]] ]]
        [[ [[+ 30]] + [[- 14]] ]] * [+ (-1) - (-1)] = [[ [[+ 29]] + [[- 13]] ]] 
		0 faraway additions: target: [[97]], operators: [+4] [+6] [+3] [-1] and inverse
		0 relative: htu
		0 relative: dec
    0 use [[opposite of 6]] instead of [[-6]]
**  0 target is [[opposite(initial)]] 

challenge::key challenge: player must manipulate the objects to make a "key" appear ("key" is likely to be a mathNode, to validate at [[target]])
  edu: typical example: manipulate a pool of [[+1]] and [[-1]] until only result remains


23 septembre 2022:
edu: grayed operator (==no effect operator) only to show effective inverse operator
    grayed([+ 1])      has effective inverse operator [- 1]
    grayed([+ (-1)])   has effective inverse operator [- (-1)]

25 septembre 2022:
*(*)touchSlot.isEnabled --> locked icObj.state[touchSlot0] = .Touched
    0. touchSlot0.isEnabled == true     and     icObj.state[touchSlot0] == .Untouched 
    1.        icObj * [touchSlot0]      -->     icObj.state[touchSlot0] == .Touched
    2. touchSlot0.isEnabled = false     -->     icObj.state[touchSlot0] == .Touched (locked) 
    this lock mechanism may have a nice purpose
      => forced sequence of operator use
            tutorial
            "learning" step

**edu: relative numbers: [smart additive split] 
    we have to do [[+3]] + [[-8]] 
    [[-8]] * [smart additive split] = { [[-3]] ; [[-5]] }
    [[+3]] + { [[-3]] ; [[-5]] } = [[-5]]  

    [random additive split]: 
      [[-8]] * [random additive split] = { [[+5]] ; [[-13]] }

27 septembre 2022:
***GET100: physical board game: gameboard is a [0;100] or [-100;100] number cell line
    initial: there is a pawn at 0
    when player plays card, they move the pawn to the result number cell
    when pawn reaches 100, team wins the pawn and a new pawn is put on 100: now target is 0 
    (number cells may have a circle decomp area)
    edu: [-100;100] is obviously the most interesting gameboard
    each operator has a corresponding color:
      +: orange
      -: blue
      x: yellow
      /: violet
    edu: players may have a calculator next to them to check result
    edu: players may use a ruler when multiplying:
        1. measure distance from zero
        2. move away from zero by repeating it n times

  variants:
    [protect(<color>)] operator: next card should be of the specified color to remove protection
      example: [protect(blue)] should be followed by [- ...]
      a protected pawn should be put aside (so that we understand it's protected)
    combo card: effect + protection:
      example: [+ 1, protect:violet]
    
    [assign(<value>)] operator: [assign(27)] --> value current becomes 27
      edu: pour la notion de variable en algorithmique
    
***GM:challenge: from point A to zone B (using (at most/exactly) n operators):
    example: 1D: initial: [[value: -7]]    target: [[interval: [10;15[ ]]
      edu: faire comprendre "le passage du 0"  
    example: 2D: initial: [[point: (-7;-3)]]    target: [[rect: (TL:(5;5), BR:(10;1)) ]]
    

**iC:copy handle (FR: poignée de recopie): same behavior as in a calc sheet
    formulas should be shifted, etc.

**(*)edu: gang dots(like _Exploding dots_, but clearer): putting dots close to each other automagically creates a gang
    putting gangs close to each other automagically creates a supergang, etc.
    edu: zooming in lets you see inner content
      so the 10 times 10 times ... is more obvious

29 septembre 2022:
***(*)get100::VOLLEY: [-100 ; 100] and 0 is the net
    max 3 touches, player cannot touch ball twice in a row
    Team1 is in [-100 ; 0[
      say the ball arrives at [[-88]]
      typical turn is
      1. reception: bring the ball close to zero, but stay on team's half-plane
          [[-88]] * [/ 11] = [[-8]]
      2. pass: get over 0
          [[-8]] * [+ 13] = [[+5]]
      3. smash: get as far a possible, but do not go out of other team's bounds
          [[+5]] * [x 9] = [[+45]]
      
      it is also possible to go out of one's bounds for convenience
      1. reception: 
          [[-88]] * [- 20] = [[-108]]
      2. pass: 
          [[-108]] * [- 2] = [[-110]]
      3. smash: get as far a possible, but do not go out of other team's bounds
          [[-110]] * [+ 180] = [[+70]]
          OR
          [[-110]] * [x (-0.5)] = [[+55]]

    receiving team sees _incoming ball as numexp_ and must decide if they receive or if they let the ball touch the floor
      for example [[((-55 / 11) + 20) * 8]] may be off-bounds
      numexp may be shuffled for more challenge: [[8 * ((-55 / 11) + 20)]]
      receiving team may only have <10> seconds to determine if they take it or not
      then numexp is evaluated
      if receiving team has decided to receive an off-bounds ball, team must take care of it 
      if receiving team has refused to receive an off-bounds ball, receiving team wins the point
      if receiving team has refused to receive an  in-bounds ball, other     team wins the point 

    each team has 
      a draw pile,
      a discard pile
    if team2 not able to bring the ball back to the other side, team1 scores 1 point
      each player in team2 can then choose to discard one card in their hand and draw another
    service:
      3 flavors: 
        - initial value is (side ]0; 100]: [[-50]],side [-100; 0[: [[+50]]) and player doing the service plays an action card
        - there is a service value on each card
        - there is a service value on some cards. If player can't serve, the point is given to the other team. 

        - there is a service operator on each card
        - there is a service operator on some cards. If player can't serve, the point is given to the other team. 
            side ]0; 100]: service operator could be [- 157], [/ (-2)], [x (-0.33333...)], [+ (-130)], ...

          => maybe service operator is just standard card operator 
              this would induce more "back play" (== ball going out of bounds on team's side only for convenience)

    0 rules: cards in hand, cards of each type...
      0 2V2
      0 3V3
      0? 1V1

    division: if result is not a whole number: 
      2 flavors: 
         - that's ok and continue with fractions
         - action is invalid and nothing happens but action count is still incremented
            show colored division marker segment for each card divisor

    0 play against computer
    0 show volleyball pitch, players and animations when playing cards

    0 madness: game hosting phone moves along [-100;100] physical game board using a wheeled robot module

    TODO:
      0 fine tune a standard card set for each team

    3 flavors:
      - one common draw pile for the team
      - each action has their own draw pile:
          reception (side ]0; 100]): [/ 2] [/ 3] ... [- 30] [- 40] [- 50] ... [x 30%]
          pass      (side ]0; 100]): [-5] [-10] [-15] ... [x (-1)] [/ (-2)] ... [- 120%]
          smash     (side ]0; 100]): [x 2] [x 3] [x 10] ... [- 15] [- 25] [- 30] ... [x 300%]

    [[0]] is counted as not crossing the net

    advanced:
      [+ 1+] [+ 1-]: 
        if ball is on [- 1] then [[-1]] * [+ 1+] = [[0+]] is now on ]0;100] side   
        if ball is on [- 1] then [[-1]] * [+ 1-] = [[0-]] keeps being on [-100;0[ side
      rotate: 1 player in pass slot, 2 players in reception slots:
        player in pass slot cannot perform reception
      injury: all actions are 50% less effective
      charge shot: shot is 100% more effective
        consumes 2 actions
        cannot be used when receiving
      perfect pass:
        consumes 0 actions
        next move can only be:
          smash
          charge smash
          nothing (other team's reception)
      running:
        consumes 1 action
        next shot _performed by running teammate and only this turn_ is 100% more effective
      random smash:           smash result = original smash result + rand_in([-5;+5])
      to_nearest_prime smash: smash result = nearest_prime(original smash result)
      blocking counter:
        before smash, receiving team may put a card face down (scan card front qrcode)
          if smash result is in blocking counter interval, then counter smash is blocked
            then again, many flavors for follow up


30 septembre 2022:
**volley100:
    action pile symbol only on card back

03 octobre 2022:
**volley100:
    advanced: 
      literals [+ x] [× x] [x <- 3]
        rule: last team hit must end with a numerical value (all symbols must have been evaluated before next team plays)
              or else playing team loses current point
***   [poll] (==noActionify next action)
        [poll] then [/ 7] helps receiver check if [/ 7] is valid
        [poll] then [x 5] helps smasher see if smash is block-countered with the result of [x 5]
        this operator could be extended for any iC use. It's the "what-if" operator. One polls consequences.

    
05 octobre 2022:
*easy: challenge creation: specify target template using instances and computer extrapolates automagically
    example: "target could be for example   3x²+4 or 3x+4 or x²+6x ... , __you get it ?__"  

**edu: litexp: color gradient animation for x and above
    x:   blue   color gradient animation
    x²:  orange color gradient animation
    x^3: purple color gradient animation
    edu: animation is there to show that it is a variable, that the value is not known yet
    edu: next step in learning process is to slowly get rid of the colors

gm::challenge: litexp: build [[3x²+4]] (and other x² litexps) using [+ x] [× x] [× 3] [+ 4]
  edu: this challenge is rich, it proposes many different situations and strategies

**(*)[structure]gm::challenge: user-triggered simplification step via simplification operator
  examples:
    [distribute]
      gm::challenge: distribute: initial: [[3x+4]], target: [[30x+40]], via [x 10] and [develop] operator
        [[3x+4]] * [× 10] = [[10 × (3x+4)]]
        [[10 × (3x+4)]] * [develop] = [[30x+40]]
    [reduce]
      gm::challenge: reduce: initial: [[3x+4]], target: [[5x+2]], via [+ 2x] [- 2] and [reduce] operator
        [[(3x+4) + 2x - 2]] * [reduce] = [[5x+2]]
      gm::challenge: reduce: initial: [[3x+4]], target: [[5x+2]], via [+ (2x-2)] and [reduce] operator

**(*)edu: "troup algebra": [× x] as level up operator, [+ x] as add level 1 troup, [+ 1] as add level 0 troup
    each level may have a color:
      level 0: gray
      level 1: blue
      level 2: orange
      level 3: purple
    there is a column for every level
    sort columns in level descending order
    edu: comme pour les relatifs avec les cailloux blancs et noirs, juste avant de faire, le calcul littéral 

**icPreciseSlider: slider knob can be zScrolled for extra precision when sliding it, then it autoScrolls back to its "slider aesthetic" size

*edu: number line:
    bound slider:   |-------------------------|-------X-----------------|
    value:                            [[26]]
    unbound slider: |-------------------------|-------------------------|
      for students to try and place value

**edu: slider resize VS slider extend (extend shortcut: shift + resize):
    what happens if slider resizes horizontally ?
    work with rulers and slider clones
**icSlider.smartExtend: when going out of bounds, slider extends accordingly


08 octobre 2022:
**eduDemo/challenge: TargetM100100 ((road to volley100))
    ui:
      1. slider on top with:
        [[initial]]     marker
        [[previous]]    marker
        [[target zone]] zone
        (?an arrow going from [[previous]] to [[initial]] with operation written on it
      2. [[previous]] * [op_previous operand_previous] = [[initial]]  (smaller than 3.)
      3. [[initial]]  * [op_current <operand_input>] =

      initial, previous and target slide in a 3-color window 
      if operand_input is valid { previous = initial ; initial = result; op_current = random(+,-,x,/) ;  }
      if operand_input is invalid {show operation result, it is out of target zone}

      alternate display: 
        instead of displaying   [[A]] * [x <input>] =  
          we could display      [[A]] * [x <input>] ∈ [value_min__zone ; value_max__zone]
            for students to get used to "∈"
      we could also use a _finite set_ for target zone
    

09 octobre 2022:
**icTextConstructor X webSearch: [textConstructor: q(<your_query_type>, <your_query_string>)]
    examples: 
      [textConstructor: q(image, banana)]
      [textConstructor: q(synonym, hope)]
    web search engine is set in iC params

12 octobre 2022:
edu: comme on voir avec le slider, le plus important n'est pas le résultat mais l'outil
  il faudrait concevoir des challenges dans lequels les outils sont sur le devant de la scène
    0 un challenge avec un rapporteur en plein milieu
    0 un challenge avec un compas plein milieu
    0 un challenge avec un repère en plein milieu
    0 un challenge avec un énoncé en plein milieu, c'est écrit en gros et ça évolue en fonction
        des soulignages, des barrés, des entourés, des encadrés, etc.
    0 un challenge avec un stylo en plein milieu (durée de vie)

edu: slider::arc_of_circle

**icMultiSlider: a slider with a dynamic number of knobs: creating a knob is like creating a variable

edu: time based progress-indicator trigger on machines: when placing input on machine, machine does not start instantly
    machine starts after input has kept still for the duration of the progress-indicator trigger 
    edu: with such machines, we can create eduDemos in which time is left for student to perform computation, before moving to next step

**icPoint (==without homeScale) (==exact) / icSpotPoint (==with a homeScale) (==precise only up to a certain scale)
    geometry                              /     presentation
    both icPoint and icSpotPoint are metaObjects: there can be crosses, circles, squares, ...

14 octobre 2022:
***game: PriOpera: rebuild target exp (numexp or litexp) using 10 operator cards
    always the same 10 cards
    [[target]] is : [[initial]] *+ {cards}
    2 flavors: 
      - player's [[initial]] is chosen by game
      - player has to choose the correct [[initial]] (there are also [[initial]] cards)

    this game can be built around qrcode physical cards
    or around pure virtual display
      a click-only interface would be :
        [ [[]] [[]] [[]] [[]]  ]  initials
        [     exp__current     ]  
        [ [  ] [  ] [  ] [  ]  ]  operators
        [ [  ] [  ] [  ] [  ]  ]
        [ [  ] [  ] [  ] [  ]  ]
        [     exp__target      ]

    to create more complex expressions,
    there could be "breakers": [ ... + ... ] [ ... - ... ] [ ... × ... ] [ ... ÷ ... ]
      which create 2 expression slots

**(*)game: EqNinja: like FruitNinja, but here you turn = into ≠
      = should only be slashed when necessary
      game tempo accelerates with player's success

15 octobre 2022:
(*)(*)(*)from thing to concept:
    1. user drags a "concrete" icMathNode and drops it on an icSlider.knob
    2. icSlider.knob configures with icMathNode's .mathNode "formal" object
          icMathNode is the default reification of mathNode
    to be more precise, reification-dedicated icMathNode could be named icReiMathNode 
    in deeds:
      icReiMathNode.mathNode = geminiSource(mathNode)
      icSlider.knob.mathNode = icReiMathNode.mathNode.echo()

      icReiMathNode's "interactive setValue" should not overwrite geminiSource(mathNode) with a new math.ConstantNode
      icReiMathNode's "interactive setValue" should keep existing geminiSource(mathNode) and mutate its insides

**game: TargetM100100::cards version: player has 6 cards in hand and must choose correct card(/card sequence)
     ui:
        1. slider on top with:
          [[initial]]     marker    with number label
          [[target zone]] zone      with number labels for [min, max]
        2. GM::[[initial]] icMathNode 
        3. GM::operators (player's hand) 
        4. button: [declare impossible] 
        5. timer (top-right)
        6. label: score (top-right)
      rules:
        si on réussit à atteindre la zone cible:
          a fresh randomly picked operator replaces the operator that has been used  
  		  si on pense qu'on ne peut pas jouer en 1 coup:
          2 flavors:
            - soit on déclare que c'est impossible en 1 coup et 
                si c'est vrai, le système donne un point  et une nouvelle main
                si c'est faux, le système enlève un point et laisse la main inchangée 
            - si le système détecte que c'est possible en maximum <n> coups: 
                on doit trouver une séquence d'opérations correcte, 
              sinon il donne automatiquement une nouvelle main
        
      variants:
        [[target zone]] is now [[target set]] (could be [-5;1] U [10;30] U {51} U {90})

        there is a [[poller]] icMathNode input which only accepts constant values, to check where [[poller]] is placed on the number line
          edu: to help player while they ponder

**gm::challenge: TargetM100100
    [[initial]] * [op] = [[numexp1]]
    ...
    [[numexp<N>]] * [targetTouchSlot]

**mixedScale objects: objects which cannot get too big 
    if ic.scale < obj.homeScale: object behaves like any object           -->   object is small         and can get smaller
    if ic.scale > obj.homeScale: object behaves like a scaleless object   -->   object has maximum size and cannot get bigger
    typical usecases: 
      segment number labels
      any label that describes something inside an object

09 novembre 2022:
***game: Thunderstruck
    context: points and lines
    mechanic: every <n> seconds
      1. a transformation of player's current position (later marked by a cross)
          OR
         a particular location on the field (intersection of (AB) and (CD))
         is given
      2. player has <n> seconds to get to target position
      3. when time is out, only a small area around target position is safe, the rest is thunderstruck
           if player is thunderstruck, they lose HP
      player has to survive has long as possible
    ui: keyboard or controller ((or mouse))
    ux: it has to be fast paced and fun

10 novembre 2022:
**(*)TargetM100100:variant: From A to B (via C(<->1))  
      when students start to get how to go from A to zone Z, 
        gradually reduce zone Z length  
        and then 
        it's time to get from A to B (zone has length:0)
        to show that B = A x B/A,   point C, with x position == 1, could be used
          A / A = C
          C * B = B

**show sum dynamically, on selection:
      when selecting an area containing objects, dynamically show sum on the side
      objects may be fruits, numbers, symbols...

***core replace(==replace all):
     1. activate core replace
     2. [[x]] *cr [[strawberry]] = [[x]] (all strawberries are now [[x]])

**eduDemo: spread: [[x]] is segment, [[x²]] is square, [[x^3]] is cube

**eduDemo: factorize:
    factoriser, c'est équipartitionner un groupe hétérogène
    0 [factorize active selection]

**eduDemo: move and rotate axes:
    context:
      2 axes: (Ox) and (Oy) 
      5 labeled points, with their coordinates written below: A(+2,+1), B(1;10), ...
    the coordinates of a point are updated when the point is dragged
    if the axes are moved or rotated, the coordinates of the points are updated
    there could even be blue coordinates and red coordinates, with different axes, (O x y) and (O x' y')

('zone' is a sub-object in the 'segment' environment
    'segment' is a particular object-construction context 
    all objects created in this environment are related to the root 'segment' object
    it is a 'planetary' dependency
    zone has no meaning without underlying segment

11 novembre 2022:
**game:Right and Down: Numbers Edition:
    6x6 grid with start at top left and end at bottom right
    grid is filled with operators such as [+ 5] or [× (-1)]
    player controls [[<number>]] initially at top left
    target condition is at bottom right
      examples:
        [> 0]
        [< 0]
        [> 20]
        [< -20]
    [[<number>]] keeps its value from level to level
    edu: every step involves calculation. So the student may retain some of them (for example: [[7]] * [+ 4] = [[11]])
    variants:
      [fill red] to change the color of [[<number>]], as target has also a color condition [> 0, red]
      locks and keys as in the original game 
      ...

icSegment::[divide in <n>] (==[equipart <n>])
    [divide in <n>]              --> modal to input <n>
    [divide more], [divide less] --> no modal  :)
        blink/fade divisions when transforming: (1/4, 1/4, 1/4, 1/4)
    
**(*)pathdrawing + keyboard arrows = squarePathDrawing
      challenge: use squarePathmade operators to get through a maze (the same operator may be used multiple times)

17 novembre 2022:
**volley100: ball display is mathNode
TargetM100100: numpad popover

21 novembre 2022:
**(*)game: Cards of Ops (2 player game) 
    rules: each player must play a card so that   [[current]] * [c] > [[current]]
    operator cards: [■ (-10)] ... [■ (+10)], with ■ in {+,-,×,/} ([/ 0] is not in game) ==> 43 cards
    setup: deal all cards: 22 cards for P1, 21 cards for P2 
    when starting a new round, starting value is [[0]]
    scoring:
      2 flavors:
        - sudden death (à la CardsOfSpirits): game only has 1 round
        - many rounds: player with most points wins

((C'est l'adjectif qui fait le nom. Avec l'adjectif numéral "un" ([1 x]), je peux créer le nom "1" ([[1]]), en disant simplement "un un" ("[1 x] [1 x]" devient "[1 x] [[1]]"). Ca y est, on a invoqué [[1]].  

22 novembre 2022:
**0 drag'n'drop equations (depuis le temps que quelqu'un aurait dû le faire...)

24 novembre 2022:
***gm::litexp: rajouter une [safetyZone] et un [platform +] (safetyZone également) pour que les élèves puissent fabriquer chaque terme séparément
    it brings a whole new field of possible challenges which is _way more complex_

(**when objects will be able to manage other objects, _in any form_, be it proxies or wrappers, then things will evolve.

(*(hack)if GM, while in safetyZone, has its curse disabled, then using a teleport inside safetyZone would allow GM to roam free, uncursed

**game: multiplayer factory: each player has its own factory room, with its own machines and wells and stuff.
          There are pipes connecting the different factory rooms
          Each player has a narrow vision: they only see their room
          Players can communicate by voice and using game's inner communication system
          There is an input pipe and an output pipe
          Every 2 minutes: there is a new challenge, and players must cooperate to provide the correct output 
          A player may have a room full of operators, which they should bring to the others players
          A player may have a room full of numbers, symbols, etc.

25 novembre 2022:
**conductive operator:bag: put objects on its platform, click and hold the operator (bag) symbol: you are now holding all the objects that where put in the bag
    edu: pour faire des challenges sur l'aléatoire

* icObj.hp / icObj.shield
refactor greenMouse curse behavior using gm.hp:
  at start: gm.hp == 1
  gm drops on non safety floor: - 1 hp
  when gm.hp == 0: gm.im_dying_now
  => there is a singleton to manage all death certificates: DeathSecretary
  when gm dies: DeathSecretary creates a death certificate, which may contain a death curse clause
  when DeathSecretary reads the death certificate: it resolves all contained death curse clauses
  
**challenge:gm:priop: 
    layout:
      top row: expression rewriting operators: [( )]      [﴾ ﴿]           [♺]                   [⧢]
                                                add_paren   remove_paren    circular_permutation    shuffle
      mid row: [[initial]]                                               [[target]]
      bottom row: [+ 2] [+ 5] [× 2] [× 3]
                  "rightmost-only operators"
    in this challenge, only rightmost part of expression is operated on:
      [3x + _2_] * [× 3] = [3x + _2 × 3_]
    edu: understand the priority of operations 

**challenge:gm:"full atelier"
    layout:
      [[1]]                                               [[target]]
          [platform +] [platform -] [platform x] [platform /]
    easy:   [[initial]] == [[1]]
    normal: [[initial]] == [[100]]
    hard:   [[initial]] == [[math.pi]]  and target is [[a × math.pi + b]]

*holding a composite: all composite must be .isHeld when holding a non-mobile part of it

**(*)translation gm-based controller: gmified composite handle can serve as a controller
  when releasing handle, handle goes back to origin but controlled object keeps its position
  by repeating handle hold-then-release movements (each of them being equivalent to a translation), 
    we can control an object's position
  edu: show "vector history" with opacity 0.33
  challenges: get out of a maze 
    tr1. constrain handle to move only along x-axis and y-axis
    tr2. constrain handle to move only inside a shaped-box (it may be a cross, a heart, etc.)

**rotation challenges: a few(3<n<10) red points are set on the challenge area
    initial is a black point, target is a "coarse" green point
    gameplay:
      1. user selects a red point
            the selected red point is now the center for a rotation
      2. user can now hold/release the black point and make it rotate around red point
      edu: show "rotation history"(==traces) with opacity 0.33
      by repeating these steps, player may reach target

**(*)translation pointArray-based controller: point array defines a set of available vectors
    goal: initial must reach target, target is an area which may be narrow, there may be a maze to go through
    edu: there is a group of points close to one another, which allow precise movements
      this group of points may be conveniently placed near target, so that a zoom-in shows everything in screen area    
    gameplay: 
      1. user holds a point and moves to another point
            a vector is dynamically shown while moving
            user holds the vector's arrow 
      2. user releases the vector's arrow
            the vector now connects the 2 points
            the controlled object is translated using this vector
      3. the vector connecting the 2 points is erased and the vector applied to the controlled object is shown
      edu: we show "vector history" with opacity 0.33
      by repeating these steps, player may reach target

    it could be coupled with a scale selector: [× 0.5 | × 1 | × 2]
      pointArray-based vector would be multiplied by scaleFactor before being applied to controlled object

28 novembre 2022:
**onDrop(/"onInject) default handlers (==polymorphic onDrop): 
    like core mechanism but it's not adding a property, it's triggering a method based on type of dropped object
    example with Segment:
      Segment onDrop default handlers:
        onDrop([[constantNode_in]]): set length to mathNode_in.value
        onDrop([[symbolNode_in]]): create reference to segment length with name symbolNode_in.name
        onDrop([[color_in]]): set segment color to color_in
    edu: this would be used to create simple interaction to set a value to a segment-length variable for example
      drop [[4]] on [[x]] (segment-length): segment has now length x==4
      then 
      drop [[5]] on [[x]] (segment-length): segment has now length x==5 (and no longer 4)
    edu: this would be used to create simple interaction to create a relationship between 2 segment-length variables for example
      drop [[y]] (segment-length) on [[x]] (segment-length): the 2 segments are now related: x==y
      then drop [[7]] on [[x]]: everything is updated to match the relationships: x==y and x==7
    challenges:
      create instance of abcd-model by assigning the correct values to a,b,c and d (via drag'n'drop)
    and even more: handle infiniteCanvas function call
      example: if ic.floodFill() is called at point inside a Polygon object: trigger polygon.fill() instead 

**easy: segment tick-marking: enterTickMarkDrawing, draw above segment, leaveTickMarkDrawing  
    parse drawing: 
      detect single stroke, double strokes, etc.
      detect circle
**easy: angle tick-marking

30 novembre 2022:
edu:core is very nice to check if a value is a solution of an equation: just drop value on variable and see if relationship is "==" or "!="
    and even with multiple variables ([[x]], [[y]], etc...)

* keyboard-controlled supervessel: recycle gm challenges with this new interaction mode
    supervessel is always active
    space: hold/release

**easy:trailDrawing(==customBrush)
    0.select an object (it could be a freeDrawing, a text, an image, ...)
    1.give the object the trailDrawing trait
    2.hold it and move it: object acts like a brush

01 décembre 2022:
***edu: déplacement asymétrique: pour faire comprendre des calculs comme 3 - 5 = -2
  gameplay example: 
    pressing left  moves  3 spaces left
    pressing right moves 14 spaces right
    gameCourse: numberLine
    initial context: [[2]]  drawn on top number line
    target context:  [[10]] drawn on bottom number line
    each time a button is pressed: current context is drawn, between initial and target, and slightly below previous context
  edu:
    start with positive targets then move to negative targets, then mix

edu: la différence entre l'opérateur - et le signe - peut être apparente, en utilisant des espaces:
    pas d'espace => signe moins: 
      exemples: -2 ; -(2 + x)
    une espace => opérateur moins:
      exemples: 2 - 3 = -1 ; 2 - (3 + x) = -1 - x

***2 player cooperation on the same computer: one controls mouse, and the other controls keyboard
    mouse:    click and drag          /flying
    keyboard: supervessel "crane"     /floating (== just above floor)
    restricted areas: 
      mouse-only: as keyboard moves are grid-constrained, we can put operators that supervessel can't reach
      keyboard-only: we can define areas that can't be reached by mouse drag: ice domes (cyan transparent layer)
        (this part may be difficult to code

    challenge (2 == 1 + 1):
      double target: each target has its own target
    

***vibrating segments: [[x]] and [[y]] can be represented as segments, which vibrate with unique patterns
  constants, such as [[15]], do not vibrate: they are constants
  segments with length [[x]] and [[x]] has been assigned to [[2]] no longer vibrates : its color still vibrates though  
  vibrating segment stops still when hovered by mouse : so we can grab it or select one of its endpoints 
  edu: visualize [[2x + y + 15]] as a vibrating segment: |~~x~~|~~x~~|~#~y~#~|--15--|
  edu: show visually that [[2x + y + 15]] == [[15 + x + y + x]] 
                            |~~x~~|~~x~~|~#~y~#~|--15--|
                            |~~15~~|~~x~~|~#~y~#~|~~x~~|
    segments are equal, though their lengths are always changing
  edu: show visually that [[2x]] is twice as long as [[x]]
             |~~x~~| * [× 2] = |~~x~~|~~x~~|
  edu: vibrating areas:
    xy:              (x+2)(y+3):
      +~~x~~+           ...
      §     §
      y     y
      §     §
      +~~x~~+
  edu: build objects with vibrating segments !!!
    value-assigned vibrating segment clone: create vibrating segment immaculate clone and then assign same value
      clone(vS([[x]]<-2)) = clone(vS([[x]])<-2
  ui: "Singapore" vibrating segments: chain of rectangles 
    even though the backing object is a polyLine, don't show points to user but simply a chain of rectangles  
    don't show: o~x~o~x~o--5--o but |~x~|~x~|--5--| 
    ux: rectangles must be easily grabbed to change the order in the chain
    |~x~|--5--|~x~| --easy dnd--> |~x~|~x~|--5--|
  challenge: "Singapore" vibrating segments:
      show that x + 5 + x = 2x + 5:   
      initial |~x~|--5--|~x~|
      target: |~x~|~x~|--5--|
             
*game: num pong:
    ball is mathNode
    there are operators spread on the court
    ball will touch any operator on its trajectory
    player has to use L/R buttons to change racket sign:
      negative ball will only bounce on negative racket
    the more time passes, the more operators spawn on the court

04 décembre 2022: 
game: reorder:
  challenge ver1 (simple):
  layout
    mid row:  [[a]] + [[b]] × [[c]] - [[d]]   !=   [[target]] 
                    ^       ^       ^          ^  
                    unmovable operators       != then == symbol (when target reached)
  gameplay:
    reorder objects to reach target

  challenge ver2 (more complex):
  layout:
      top row: w[[x]]w w[[3x]]w w[[2]]w w[[10]]w (object wells)      
      mid row:     [+]     [×]      [-]       !=   [[target]]
                  movable operators (switch pairs via dnd)
  gameplay: 
    fill holes and reorder operators to reach target

*size-related appearance for operators: [+ 100] is big, [+ 10] is small, [+1] is very small
  edu: relier la numérique de position avec l'analogique de taille

**gm:challenge: make it zero: target is always [[0]], many different operators are available
    expression may not be not simplified after operator touch
    examples: 
    initial: [[(x+3)(x-4)]]     ops: [- x] [× 4] [+ 3] [x ← (-3)]    target: [[0]]
    initial: [[2(x+2) - 10]]    ops: [- x] [× 4] [+ 3] [x ←   3 ]    target: [[0]]

edu: l'idée principale est de créer des _accélérateurs de compréhension_, pour les mettre dans le bain, les plonger dans un nouvel environnement
  commencer à faire germer les idées, commencer à les habituer à certaines mécaniques/fonctionnements

**game: the layout game: target is a collection arranged in a particular way (==with a particular layout)
  loop: 
    (1.) add object to collection
    (2.) reorder objects
    (3.) use appropriate layout
  many layouts may be nested
  edu: pour amener aux structures en arbre

05 décembre 2022:
**[structure]gm:challenge: 2+ inputs and platform operators: transition from unary operators to binary operators
  edu: user has now to use platform (==binary) operators, alongside classic unary operators, to reach targets
  example:  i:[[x]] [[2]] [[y]]   ops: [+10] [- 4] [x 3] [x 4] [platform +]   target: [[3x+4y-6]]

**[structure]gm:challenge: 2+ "single-use" inputs and 2+ targets: find the correct input to transform for each output
  one input should be able to reach 2 targets, whereas the other should only have one reachable target
  there is a button to reset challenge back to its immaculate form (as always player should be able to make mistakes and correct them, without any retribution) 
  example:
    inputs:  [[x+3]] [[x+2]]
    ops:     [- 3] [x 2] [- 4]
    targets: [[x]] [[2x]]
  
**game: factory exprs: same as _Factory balls_ but with math exprs
    edu: the goal is to enact priority of operations
    edu: after priop has been acquired, other challenges, with "special" operators, involving more logical reasoning, may be served
    special operators:
      masks: only operate on unprotected part of expr
        [[3x + 2]]     * [mask_left(toggle)] = [[|3x| + 2]]
        [[|3x| + 2]]   * [/ 3]               = [[|3x| + 2/3]]
        [[|3x| + 2/3]] * [mask_left(toggle)] = [[3x + 2/3]]
        mask_top, mask_bottom (for fractions)
        mask_center, mask_center_big 
      colors
      grow: t becomes t+1, x becomes x+1, y+1 becomes y+2,...
        [[3t² - t + 4]] * [grow] = [[3(t+1)² - (t+1) + 4]] 
      letter specific operator: [[t+4x+1]] * [x: x -> 2x] = [[t+8x]]  
      all letters operator:     [[t+4x+1]] * [*: * -> 2*] = [[2t+8x+1]]
      conditional number operators:
        [[3t -   4 ]] * [>0: n -> 2n] = [[6t -   8 ]]
        [[3t + (-4)]] * [>0: n -> 2n] = [[6t + (-4)]]
        is_pair, is_odd, is_prime, ... 

**gm:challenge: symbolic constants: math.pi, sqrt(2), f(-1), ...
    edu: manipulate those symbols as if it were [[x]] or [[y]]

**gm:challenge: sqrt(2):
    [[sqrt(2)]] * [x sqrt(2)] = [[2]]
    [[2]]       * [/ sqrt(2)] = [[sqrt(2)]]
  
**gm:challenge: math.pi:
    [[math.pi]]     * [cos(...)] = -1
    [[math.pi / 2]] * [sin(...)] = 1

**gm:challenge: iterative f: f(f(1)), f(f(f(-2)))
    "simple":
        i: [[1]] [[2]] [[10]]   ops: [f(...)]                            target:[[<some_value>]]
    "complex":
        i: [[1]]                ops: [f(...)] [+ 2] [- 5] [x 4] [/ 7]    target:[[<some_value>]]

**challenge: egg hunt: find objects in space and put them on platform to match target platform
    this requires the execution of a complex move with the mouse: z-scroll while holding the object
    edu: no way back should be precised so that players are driven to put marks in space and create their way back (Petit Poucet)

06 décembre 2022:
game: quality check: if an operator doesn't work as expected, put it away and take a new one.
  edu: 1er  objectif pédagogique: avec l'informatique: attention aux apparences, et attention aux bugs
  edu: 2eme objectif pédagogique: anticiper l'action des opérateurs
  variant: ecological: if an operator doesn't work as expected, dive into it and repair it.

**(*)game: parameterized key shape: target is a slot with a particular shape, key is composed of segments with length == [[parameter]]
    many segments have same parameter: coupled variables
    layout:
        _   _                     ______
      _| |_| |_             _____|      |
              _|                        |
             |_                         |__
      _   _   _|            ___          __|
       |_| |_|                 |________|
        key                     shape
    gameplay:
      it is a logic game in which player must assign valid values to parameters step by step  
      example: target.someSegment.length == 2 and current.[AB].length == [[x]] => player should do: [[x]] <- 2  
    challenge1: key's segments have pure or constant parameter values: 
      key.[AB].length = [[x]], key.[BC].length = [[2]], [CD].length = [[x]], [DE].length = [[y]]...
      difficulty can be increased by increasing the number of segments
      gameplay1: segment length assignation is only possible via coreification
        edu: pour insister sur le côté: "une variable, c'est une longueur qu'on peut rendre réelle"
      gameplay2: segment length assignation is done via click and drag (==object stretch)
        edu: pour insister sur le côté: "si je vais bouger ici, je fais bouger là, car c'est la même variable"
    edu: répondre à la question "Mais c'est quoi x ?"
    challenge2: key's segments may have composite parameter values: [AB].length = [[3x + y]], [BC].length = [[y]], [CD].length = [[x]],...  
      dev: attention à créer des challenges qui ne soient pas trop insurmontables    
      edu: montrer que certains problèmes, qui ont l'air solubles en manipulant, requièrent une résolution "papier crayon", en les posant proprement

09 décembre 2022:
***vibrating blooms: [[4 + x]] can be a reprensented with a constant reictangle and a vibrating reictangle
  edu: visualize equations: an equation has a solution when both side have same length (vibrating segments scan values in a certain range)
***flash when equal: pause(0,7 sec) and highlight both sides when both side amount to the same value ("a solution has been found")
  sides can be represented as: 
    lengths
    areas
    numerical evaluations

11 décembre 2022:
**assignment operator: used on litexpr: [[(3x+4)/5]] * [<- 2] = [[(3x+4)/5(==2)]]
    edu: show that it affects [[x]], and that it amounts to solving equation: (3x+4)/5 = 2 
    careful:
      (∃n / expr_1 <- n => expr_2 -> n)  ⇏  expr_1 == expr_2
      (∀n / expr_1 <- n => expr_2 -> n)  ⇒  expr_1 == expr_2
gm:challenge: proportionnality:
    i:[[3x]]      ops: [[<- 3]] [[<- (-30)]] [[<- (-2)]] [[<- 5]]    target: [[2x(==-20)]]
    variant:
      with geometric shapes areas:
        i:[[shape(triangle).area]]      ops: [[<- 3]] [[<- (-30)]] [[<- (-2)]] [[<- 5]]    target: [[shape(square).area(==10)]]

**gm:challenge:do your sqrt yourself: player has to use right triangle machine to create sqrt-valued gm then used to reach target 
    layout:
      i1: [[1]] [[2]] [[3]] [[5]]   op1: right triangle machine with <[[input1]]> and <[[input2]]> and [[gm__output]] 
        op2: [+ 1] [- 2] [× 3] [/ 4]     target: [[3 sqrt(34) + 2]]
    variant 1: hypotenuse machine:       gm__output.value = sqrt(input1.value² + input2.value²)
    variant 2: right angle side machine  gm__output.value = sqrt(inputH.value² - inputRAS.value²)

gameplay: view map by scrolling while continuing to move "hero" (there is no map screen, map display is only dezoomed-display)
  there still can be fog of war == undiscovered greyed areas 
  "Supreme Commander meets Adventure" 

17 décembre 2022:
**(*)game: tennis100:
  layout: -----|------------|------------|---->
              -20           0           20
            Player A's side | Player B's side
  gameplay:
    service: Player A: play a service card
    game:
      Player <X>:
      1. play an interval card (interval must contain ball value not to lose point)
      2. play an operator card (ball must go on the other side without leaving court)
    Player's hands are semi-visible:
        half of player's hand is visible to the opponent, so that they try to put the ball where the opponent cannot go   
  (?every player "sees" themselves in the [0;20] area, and opponent is in [-20; 0] area
    edu: insister sur la symétrie centrée en 0 des nombres relatifs
      variants:
    [+ 1+] vs [+ 1-] card: 
      if ball is in [[-1]], [+ 1+] will     go on the other side
      if ball is in [[-1]], [+ 1-] will not go on the other side

**challenge: tennis against a wall:
    layout:         ^
          wall -----|-----------------------------
                    |              ^|
                    |              ||
                    |      ball   + |
                    |               v
                   0-               [] target
    gameplay:
    challenge1:
      given [[initial]] and <strength>, 
        user must click on the spot so that [[initial]] * [+ <strength>] = [[clicked spot]] /modulo wall/ 
    challenge2:
      user must choose a strength value so that: [[initial]] * [+ <strength>] = [[target]] /modulo wall/
    difficulty:
      easy:      [[0]] is before wall, and wall is at [[10]],   [[initial]] is around [[0]]
      normal:    [[0]] is after wall,  and wall is at [[-10]],  [[initial]] is around [[-20]]
      normal+1:  [[0]] is before wall, and wall is at [[100]],  [[initial]] is around [[90]]
      normal+2:  [[0]] is after wall,  and wall is at [[-100]], [[initial]] is around [[-110]]
        
**(*)[structure]qrcode game: 3-phone way: no physical qrcode cards, virtual cards are shown by players' phones (en route vers la dématérialisation)
      PhoneA              PhoneG              PhoneB
      gameInit:
        PhoneG creates new game and generates 2 qrcodes, one for PlayerA and one for PlayerB
        _GameState is only hold by PhoneG_
        PlayerA scans their qrcode
          PlayerA gameArea is init'd
        PlayerB scans their qrcode
          PlayerB gameArea is init'd
        game can start
      game:
        PhoneG awaits for qrcode
        PlayerA chooses card and a qrcode shows on PhoneA's screen
        PhoneG reads PlayerA's qrcode
          gameState is updated
          _GameState is only hold by PhoneG, which knows exactly playerAState and playerBState_
        then PlayerB chooses card...
    remark:
**    if phones had 2 screens: front and back,
        selected object(==card) would be shown on front
        qrcode                  would be shown on back
        and scan on PhoneG wouldn't require the clunky flip/scan/flip

18 décembre 2022:
(***game of games: a game to cover the history of video games
  there is a roms' path (graph of nodes, each node is a video game)
  we start at foundation games: pong, space invaders, pac man, ...
  player has to 
      play game for a certain time (say 10 or 20 minutes) 
      OR
      finish level 2 (or kill boss X or ...)
    to unlock next game in the tree
  dev: this is a super-layer to build over emulators+roms
  it would be nice to code it as an html page that has permissions over user's filesystem,
  and which would only require user to have a compatible installed base of emulator+roms    

**vibrating segments:: x²-"unit"-squares
         2x
    +~~x~~+~~x~~+
    s     s     s             
    x  x² x  x² x
    s     s     s
 2x +~~x~~+~~x~~+
    s     s     s
    x  x² x  x² x
    s     s     s
    +~~x~~+~~x~~+

*ui: easy spawn (for 
**(*)"spontaneous" edudemos(==teaching situations created on the fly))
  Key1:  0.1unit-sized segment 
  Key2   1.0unit-sized segment
  Key3  10.0unit-sized segment

**gm:litexp::japanese symbols: instead of [[x]], use a japanese symbol (example: [[あ]])

04 janvier 2023:
*edudemo: réduire une expression littérale: les x² sont des carrés, les x sont des rectangles fins et les unités des petits carrés 
    réduire une expression littérale, c'est faire un tas pour chaque famille 

**vibrating segments allow the creation of "variables without a name"
    indeed, there is, primarily, no need to name the segment we use. It simply is "this".
    and we can clone this unnamed segment to create multiple instances of "this undefined variable thing", _all varying the same way_
    edu: then we can eventually assign a variable with a name to ease later reference
    dev: vibrating segments _internally_ have a variable (in order to vibrate), 
          which can then be coupled with a _external_ symbolic variable
    => 2 flavors: 
      "pure" vibratingSegment:      no external symbol is attached to it when spawned
      pre-coupled vibratingSegment: an external symbol(example: [[x]]) is already attached to it when spawned 

**floodFill X vibrating segments: floodFill of a vibrating area creates a vibrating floodFilled object 

**(*)color gradient segment: a 1D-gradient color pattern extends from end to end
  this is a another way of representing the difference between variable segment and constant segment, but without movement this time (more quiet)
  edu: this allows the display of [[x²]] as a 2D-gradient colored square
       0 1 2 1
       _______
    0 |0 1 2 1 
    1 |1 2 3 4
    2 |2 3 4 3 
    1 |1 4 3 2
**vibrating color gradient segment
edu: length vibrating segment is to emphasize ontologic difference between [[x]] and [[2]] (one is variable, the other is constant)
edu:  color vibrating segment is to emphasize ontologic similarity between [[x]] and [[2]] (both are numbers)

**(*)challenge:gm:units: [[mm]] to [[km]] by using [x 10] [x 100] [x 1000] operators
    initial and target are units
    [[mm]] * [× 10] = [[cm]]

05 janvier 2023:
**vibrating segment: both ends must vibrate (differently) in order to truly feel the variable nature of the segment
    if the segment has one end pinned to a fixed point, then only the other(==free) end should vibrate

**polyLine: composite(segment1, segment2, ...) by sticking ends (==polyLineEngine)
**polygon = polyLine + 	polyLine.point_start == polyLine.point_end

**PolygonMosaic: group of polygons, each sharing at least one side with at least another polygon 
  edu: vibratingSegment-based polygonMosaic: what would you choose for [[x]], [[y]], [[z]], to make a house ? to make a tree ? etc...  
**PolygonQuasiMosaic: polygonMosaics linked by polyLines

***variable segments 1D-polyLine resize
***eduDemo: 2x + 5 = 14 solving by resizing variable segment polyLine: 
    |~x~|~x~|--5--|     (before resize)
    |~~x~~|~~x~~|--5--| ( after resize)
    |-------14--------|
    then user can hover [[x]] to get its value
    or there may be a little [[<value>]] box next to [[x]], dynamically displaying its value
***challenge: 2x + 5 = 14 "Singapore solving" workflow:
    |~~x~~|~~x~~|--5--|                |~~x~~|~~x~~|                  |~~x~~|~~x~~| (                |~~x~~| )
    |-------14--------|  ==[cut(5)]==> |-----9-----|   ==[comb(2)]==> |-4.5-|-4.5-| (==[keep(x)]==>  |-4.5-| )

*|~~x~~|~~y~~|--5--| resizing ? ==> use blue points / black points as in Geogebra

**(*)game: variable segments + constants segments: build target shape using initial collection of segments
  variable segments can be resized, constants segments cannot be resized
  a logic game could be built using this game mechanic

**(*)game: build to satisfy constraints:
  there is a set of constraints: A ∈ [BC], C ∈ insideOf(Triangle(D,E,F)), etc.
  initial is a set of objects: points, segments, squares, circles, etc.
  target is "objects have been assembled so that the set of constraints is realized"
  2 flavors:
    dynamic (fit for learning): 
      solved constraint is painted green when realized
      challenge is completed when all constraints are realized
    asynchronous (fit for examination): 
      pressing [CHECK] button paints realized constraints in green
      challenge is completed when pressing [CHECK] button with all constraints realized

(before giving students paper and ink "mindful" challenges, it's better to ensure that the universe we are refering to is somehow known if not well grasped.
(so the preliminary "visualization" step helps students to build in their mind their own replica of this universe  

07 janvier 2023:
*polyLine making/unmaking: 
  making: release segment end when close to another segment's end
  unmaking: select inner joint and Shift-B to separate parts

composite segment controls:
  on an end point:
    single click and hold: move all
    double click and hold: move end point (if segment has fixed length, move end point in allowed circle)

11 janvier 2023:
**(*)gm:spaghetti challenge: polyLinePath: the path is not a handDrawn curve but a polyLine
  => the polyLine may be edited if the target is not reached
        edu: keep what is OK and change what is NOK

**polyLineGraph: polyLine with branches and loops
  2 flavors: oriented and not-oriented

****pathMade programming: polyLineGraph / branch synching (=> pathMade programming is now fully achievable)
  path is made of oriented polyLineGraph
  if 2+ branches end up at a crossroads, their carriers are synchronized to yield the carriages at the same time, 
                                         so that a multi-argument operator can then trigger

*curve: Bézier, spline...
**polyCurve: composite(curve1, curve2, ...) by sticking ends

*icObj.type = "uniformSConveyor"
	  can be touched anywhere
		on touch:
				1. object center = closest straight conveyor point
				2. move object center along conveyor points at conveyor's speed (same speed along all path)

(*icObj.type = "customSConveyor": custom speed function can be specified along the path 
(**game: cannons: at sConveyor's end, object keeps its velocity
    so the player could put operators along cannon's path, so that the boulder becomes bigger (boulder could be mathNode)
    but it then gets closer to a physics game    

**(*)game: circle targets:
  gameplay:
    0.there are 5 targets put on an outer circle (all in [[0;360[[ integer number interval)
        target.value == angle at which it is put on the outer circle
    while there is an unshot target:
      player builds mathNode projectile via standard greenMouse interface: challenge right side slot is the cannon slot 
      player then moves cannon and shoots mathNode projectile on target (there is a [shoot button])
  edu: have students used to angles in degrees on a circle

**floodFill: square fill: flood fill by recursively filling with squares of decreasing power size
**(square) collection: sort by size
    edu: show a way of measuring areas

15 janvier 2023:
*comfort: key<?>: get back to main scene pos and scale 

**inputProperties.number (same as inputProperties.color and inputProperties.opacity)
		inputProperties.number == 3 => spawn_regularPolygon() ==> triangle
		inputProperties.number == 4 => spawn_regularPolygon() ==> square
    easy: keep the same behavior as for color: change value by scrolling, show when setting, fade when set
      range: [[-10, 30]]
**inputProperties.symbol
		inputProperties.symbol == x => 
      spawn_vibratingSegment() =>       a segment with external variable [[x]] 
      spawn_vibratingSegment() => another segment with external variable [[x]]
      resizing first segment auto resizes second segment because they share same length(==[[x]])
    easy: keep the same behavior as for color: change value by scrolling, show when setting, fade when set
      set: {"x", "y", "z", "t", "a", "b", "c", "d"}

19 janvier 2023:
toxicode's "/progress generator" is a very powerful tool
  if players answers well, repeatedly, player lifts to upper difficulty level
  if players answers wrong, player falls down to lower difficulty level
  edu: this smart staircase should be used to get closer to student's true own current "state"
  ==> "trial-tailored" interactive learning (comme un tailleur qui prendrait les mensurations du client, en essayant de le faire passer dans des pochoirs géants (gabarits))

BACK TO BASICS:
**challenge: carry:
    challenge area:                           sandbox area:
         1        4                                     4                  
    + [slot1]  [slot2]        and next to it: +      [slot3]
    ___________________                       ______________   
         3        1                               .     .
    sandbox area:
    if player puts [[8]] in [slot3] then 
      1. a carry is written in the valid column
      2. 1   2  is written as the result of the operation
    challenge area:
    if player puts [[8]] in [slot2] then 
      1. a carry is written in the valid column
      2. 1 (==expected result) is stroked and 2(==result of operation) is written

**challenge: from tree to litexp: indirect GM
  [[initial]] is gm leaf node
  [[target]]  is litexp
  1.player builds tree from gm leaf node
  2.player drops tree in a safetyzone when they think it's ok
  3.an indirect litexp greenMouse slot is then updated with the tree's corresponding litexp    
  4.player picks up the indirect gm and completes challenge by moving it to target touch slot
  edu: insister sur le lien arbre de calcul <--> litexp

**(*)challenge: Singapore building of litexp: multi-options GM: player has to choose the right gm to start with
  target is a vibrating segment corresponding to a displayed litexp
  player must build vibrating segment corresponding to litexp using operators
  example:
    [[target]]: |~~x~~|-2-|~~x~~|-2-|~~x~~|-2-|    litexp: 3(x+2)
    [[inital]]: [[x]] [[2]] [[3]] [[3x]]
    arr_op: [+ 2] [+ x] [× 3] [× 2]
  difficulty:
    easy:   many ways
    normal:    2 ways
    hard:      1 way

**challenge: relative numbers: place number list on number line, one by one:
  initial: [[ [-5;-9;2;7;-1] ]]
  1. [[-5]] should be grabbed from list and put at the correct spot on the number line
  2. loop:
     [[-5]] should be grabbed from number line and dragged to [[-9]] correct spot
     etc.
  dynamic display of operation being built: if player is at [[-8]], starting from [[-5]] then show [-3] arrow on top of number line, from [[-5]] to [[-8]] 
  edu: have player experience [[-5]] * [move 4 units to the left] = [[-9]] (<=> [[-5]] * [- 4] = [[-9]])

01 février 2023:
easy: pov:
  1. shift + KeyP + 1: save pov1
  2. KeyP + 1:         spawn goto pov1 button  

**challenge: equations: make [[x]] from litexp: target has value label, initial is litexp, user must "unpack" [[x]] 
    every time current litexp is transformed, target's value label updates accordingly

02 février 2023:    
***pov-scope'd button behavior: button behaviour is different with each pov scope 
  edu: this allows up-down-left-right interactive presentation, using pov-scope'd [gotopov] buttons
    for example: virtual visit of a site using key pictures

**pov-based hinting for treasure hunts: if user is stuck, user presses button and is brought to "next step's" pov

**easy: pov (alternative)
    1. KeyP: create pov with [[<id_pov> label]]
    2. [icTextContructor: gotopov <id_pov>] --> creates gotopov button

**supereasy: pov
    1. KeyP: create pov   (this creates a narrow-bordered rect)
    2. right-click on pov: copy link to pov
    3. CTRL-V: paste link to pov (== [gotopov] button)

**icObj.type = "popping": when cursor hovers this object, object gets a little bigger

**(*)cursor-based zoom: when cursor in on popping object, zoom occurs on popping object 
  dev: imagine a world map with popping pictures on each capital, if cursor is out of popping object, zooming on capital is still possible 

03 février 2023:    
**a map and a visit: if each site is a popping with a bound pov, one can create a map (which can still be used as a map) and in which a visit can happen (via gotopov sequence)
**a map and many visits: map can be covered by many visit trees, which can intersect





.
