04 décembre : initial morning program based on https://github.com/TomHumphries/InfiniteCanvasWhiteboard

0 create zoom loops

*	0 there is so much space, that one can hide messages in the vast infinity

05 décembre 2020:
0 échelle
  0 double flèche

0 parcours
	0 arbre
	0 notation 0-20 : nb_questions = n(n-1)/2 = 190

06 décembre 2020:

0 Arrow:
  0 "horizontal arrow" : 10 fois plus loin
  0 "vertical arrow"   : 10 fois plus grand
  0 "oblique arrow"    : itinéraire (ou mesure)

0 "les deux amoureux" (each is on a planet)
0 itinéraire:
    0 select pointA, pointB
    0 draw arrow
      0 orientation automatique de la flèche représentant l'ordre de grandeur courant en fonction de la flèche "itinéraire"
    0 find order of magnitude and "get there" (show the arrow with the "right size" wrt screen)

0 from question A to question B:
	0 create line from A to B and follow it in the direction of the arrow till you meet the next exercise
	0 warp

0 from question A,B and C to question D:
	0 triangulate

0 PAUL's vision:
  deux calculs
    L'abscisse est la réponse à la question 1
    L'ordonnée est la réponse à la question 2
    Abscisse et ordonnée par rapport au _repère courant_

    avec un repérage "A1":
    on peut utiliser les préfixes comme indicateur de colonne

  tableau d'un peintre: fractale

11 décembre 2020:

**0 import pdf

0 workflow :
		0 import mind map pdf
		0	enrich the map by adding
				0 neurohandle images : a goat, a lion,
					0 associate biome to zoomLevel
				0	content inside those neurohandles : exercices, problems, figures...

* 0 hardcore : zoom trap : when zooming out, user does not get to previous scene, but sees zoomed out current scene

14 Décembre 2020:
**Z-PUZZLE: bring object back to its corresponding slot (object can be extended, shrinked)
		0 click and scroll to change size
			0 long click| long press to lock obj selection

15 Décembre 2020:

**Z-Puzzle avec des carrés : inscrire un nombre dans le carré, avec une double flèche pour indiquer la longueur du côté, _à l'intérieur_

0 Z-Puzzle Logo : write Z-Puzzle with squares of different sizes

0 WOW effects :
  0 puzzle pieces are on a blue background : blue background is only a small (blue) part of a big piece of the puzzle
  0 puzzle pieces are on a table : the table is a part of a big piece of the puzzle

16 Décembre 2020:
	0 puzzle creation :
		0 image split
		0 create puzzle piece using cutting path

	0 commencer par un petit Z-puzzle à 4 pièces :
			initialisation : toutes les pièces sont carrés, de la même taille, de couleur différentes avec un numéro différent (1,2,3 ou 4)
			le slot pour le numéro 1 est très grand, on voit dans la vue initiale un petit morceau de bordure de 1
			le slot pour le numéro 2 est de taille initiale
			le slot pour le numéro 3 est petit mais on peut y arriver avec un resize classique
			le slot pour le numéro quatre est très petit

17 décembre 2020:

	idées:
	0 movable/unmovable objects : bg objects vs interaction objects
	0 z-index should (/may) decrease when object gets bigger (imagine an image of the universe which was contained in a house window)
	0 group/ungroup when z-scrolling inner element

	0 inno_further:
		0 double object: {front layer, back layer}
				front layer displayed when scale <= x
				back  layer displayed when scale > x
				example: closed window / open window
				=> 0 calendrier de l'avent

			0 living object: front layer may change if something has been done "inside" object (i.e. when scale > x)


	0 edu:

		0 numbers fractal :   [             9              ]
	                        [0][1][2][3][4][5][6][7][8][9]
													etc.
													il y a le zero-level : avec [0,][1,][2,][3,][4,][5,][6,][7,][8,][9,]

		0 10^n rectangles       _____________________________________________________________________________________________________
														[                                  10^n                                                             ]
														-----------------------------------------------------------------------------------------------------

														__________
	                        	[10^(n-1)]
														----------

		0 double layer numbers :
		 		front
										[             ]
										[      9      ]
										[             ]
				back
										[  1   2   3  ]
										[  4   5   6  ]
										[  7   8   9  ]


19 décembre 2020:

*	0 remanent points : center point for rotation is displayed then fades when rotation is done

*	0 complex animations :
		0 X-wing : zoom-in + centered rotate
		0 spiral staircase : zoom-in + non-centered rotate

** 0 animated objects : endless spinning wheel, endless translation
*			0 user could force software to adopt moving object's referential

** 0 temporal active objects :
		  0 calendrier de l'avent : mettre un timer dans le programme pour que les fenêtres (==double object) ne soit "ouvrables"(==pénétrables) que lorsque le jour est passé
      0 devoir maison : le sujet n'est plus accessible après
      0 interro : time frames

    0 edu:
				three sectors : course material plane is divided:
					green sector  : easy : for everyone
					orange sector : moderate : for almost everyone
					black  sector : serious : for strong pupils

					students can rotate the wheel to access to stronger content

    0 un z-puzzle simple:
			des carrés de couleur

    0 z-puzzle with reflection : negative scale

    0 snapping:
			0 move
			0 resize
			0 rotate
			0 what is the right snapping percentage ?

20 décembre 2020:
  edu:
    bien affcher la taille et la position du rectangle d'observation

  zpuzzle:
    0 droite graduée et profil affine (carré de différentes tailles)
      un humain près du 1 (1 mètre)

    0 z-puzzle : telephone
        7  8   9
        4  []  6
        1  2   3

    0 colored squares with dimensions
  			0 format : factor    x     power of ten
    			[---------]
    			[<------->]
    			[   3,8   ]
    			[    x    ]
    			[ 10^(-2) ]
    			[_________]
        0 need _reference_ arrow

    0 more complex: no reference is shown : pupil has to use relative sizes to solve puzzle

** z-scroll, r-scroll, etc. is only about placing the selected object in _a different ("hovering") layer_, and then dropping it in the original layer
    maybe code would be cleaner if it was done this way
*   => hovering layer is the player's backpack (multiple objects could travel along)


* ((double puzzle: recto / verso


*  basic exercice course:
    exercise n:
      - image (funny)
      - statement (less funny ^^)
      - answer text field:
          on right answer : open exercise n+1 door etc.

** OUR WEBSITE : students' have a website consisting of an infinishute
     every student can have its own miniverse in the infinite vastness

* animation: pov path  : from pov1 to pov2 to pov3 to pov4 etc.
    edu: séquence de mémorisation


*[
	Keyboard shortcuts:
			F: Rect          F for fabric
			T: Text
      Shift T: Tag
			X: Point         "cross"
      D: Droite

      Q: Circle        Q looks like O
      W/N: Polyline    W/N is a polyline

      M:       Measurement arrow  (depends on context orientation)
        ? + M: greatest length
        ? + M: smallest length

      G: Group
      B: Ungroup       "Break group"
            (special: toggle .isMobile of selected composite part)
      Shift G: Compose
      Shift B: Decompose
      Shift Alt G: Compose (special)

      Shift + move:
            (special: force move of selected composite part (== make as if it were .isMobile == true))

      ";": Show object types (KeyDown (toggle)) (on peut voir (via une bordure spéciale par exemple) les composites, les groupes, les objets normaux, etc.)

      A: zoom out (KeyDown (timeout))     "Away"
      Z: zoom in  (KeyDown (timeout))
      Shift A: zoom out (/10)
      Shift Z: zoom in  (x10)

			R: Rotate   (KeyDown (toggle))
			C: Color    (KeyDown (toggle))
      V: Opacity  (KeyDown (toggle))
      <: Category (KeyDown (toggle))      (this will allow: selectNextObject(activeCategory), selectAllObjects(activeCategory)...)
      &/1: Cursor (KeyDown (toggle))      (this will allow: click on obj VS select obj and then move it)
      X: Context orientation (KeyDown (toggle))   (horizontal, vertical, ltrb diagonal, rtlb diagonal)

      H: Homescale for new objects (KeyUp (toggle))
      Shift H: save homeScale to preset.homeScale

      key: "²", code: "Backquote" move to origin pov
      digit<n> move to pov<n>

      Y: Z-Puzzle slot
      P: Create protoSlot

      E : Activate (maybe mouse click is more intuitive)

      S: Save all
      Shift S: save selection
      L: Load

  Keyboard+Mouse:
    rightMouseDown + zoomIn/Out   keeps screenRect centered on object while zoomingIn/Out

ET LES GAUCHERS ALORS ?...
*]

1 keyZ: zoom-in to cursor / zoom-out
  "KeyW" : get aWay
  "KeyE" : "Enter"/"Explore" : zoom-in
  1 keyDownTimeout
  0 keyDownTimeout VS keyDown: complex mgmt to only zoom once when key is "simply" down-up'd (== ? pressed ?)
**		=> problem "vanishes" when timeout delay is 17 ms (== "small enough")

** sometimes it all adds up nicely (==resulting feature): rightMouseDown + zoomIn/Out keeps screenRect centered on object (this is a nice feature which should be preserved)

* antialias "pixel fight" when zoomingIn is like Heisenberg's principle, it's more and more shaking

** edu: le petit poucet de Gulliver : semer des petits cailloux à chaque niveau de zoom pour ne pas se perdre
    => les amener à comprendre la notation décimale
**    on "remonte" un nombre comme par exemple 14758,1654873    (on part du niveau de zoom)
** avoir un affichage spécifique pour les "zéros facultatifs" (que ce soient ceux qui sont à gauche ou à droite de la virgule)
    0 affichage additif (on affiche le nombre sous la forme sigma(ai x 10^i))

    0 representations:
      0 square representation : I don't like this one because it may override what we try to teach regarding areas
      1 rectangle representation : better
**      1 "representation 74" (xylophone representation) (width does not matter, only height matters)
*         0 704 : write "0" when no column is filled
            0 fill remaining space in black and write "0" when no column is filled
*         0 add double arrow (as separator) : double arrow size depends on select number, to show that only height matters
          0 show |10^<n> sector| on top of each xyloblock
*         0 show addition of two number with this representation
            0 two "lines" (is this possible ? (yes, if all towers have same height))
            0 abaccus way
*         0 allow user to type number and draw corresponding representation
            => 0 exercise : type the number corresponding to the displayed representation
                0 easy:           183,01
                0 standard:   140 015,3
                0 hard:     1 000 000,000 028
*         0 allow user to select rectangles and show corresponding number
            => 0 exercise : select rectangles to represent the number 157,005408
                 0 show "current number: ...."
                        "target        : ...."
          0 negative numbers : upside down
            0 show addition of positive and negative number
          0 show sqrt(2)
          0 square product of two xylos
            0 show sqrt(2) * sqrt(2)
          0 xylophone number char representation: small 1, bigger 2, even bigger 3 etc.
*       0 representation "empire state building" : pile up all rectangles
          0 with rectangles
          0 with real-life objects rectangles
          0 add corresponding power of ten square [10^<n>] next to the xyloblock
*       0 representation fallen skyscraper : empire state building goes horizontal
          0 with rectangles
          0 with real-life objects rectangles
        0 animation:
          0 from xylophone to empire state building
          0 from empire state building to fallen skyscraper
**          0 Wow effect: la virgule tournée dont on ne comprend pas au départ la signification, revient dans le bon sens pour former l'écriture décimale du nombre (écriture décimale "pondérée")
        (0 representation "closest square puzzle"
      0 sum of scientific notations (sigma(ai x 10^i))
      0 exponential-carried representation (logarithmic scaleX)
      0 fractal path representation ("5,1 c'est un bonhomme et un petit poisson"): each square has BL = (0 ; 0) and BR = (10^<n> ; 0)
        0 create "trailing part" only when "tower" becomes active (or else number of objects will grow exponentially)
      0 représentation en aire: essayer de montrer un remplissage des xylorects de telle manière que le nombre représenté corresponde à la somme des aires

    0 "vous avez débloqué un nouveau secteur : partie décimale"


  0 colored numbers:
*   0 zero could have transparent color ("container")
*   0 non used level number could have very low opacity (but we could still seem them)
*     0 write "0" when no column is filled

  0 power of ten : patterns
    each power of ten has a characteristic filling pattern (example: hearts, diamonds,  ... , cars, cells, ... )



pour la multiplication de deux nombres :
  représentation en surface d'un nombre : on prend arbitrairement un des deux comme 'multiplicateur' et l'autre comme la surface à multiplier
  attention : multiplier une surface par 2 : simplement prendre deux instances de la surface initiale et les accoler

  0 mécanique de précision : trouver la pièce complémentaire

*** zoom-bound freeDrawing text reading animation

21 décembre 2020:
  une séance préparée pour 1 heure pour 24 élèves VS un programme pour x heures pour 10^n élèves

* un nombre (fini), c'est un parcours (fini) sur une fractale.

  0 show sqrt(2) * sqrt(2)

  0 make it sexy
    0 round corners
    0 "this thing is living" animations


*  0 raster and vector DUO: one window infiniteCanvas, the other paint.net : copy/paste images to and fro

  0 applications:
    0 une année de 4ème:
      0 tangram cat :
        0 translation only :
*         0 unrotatable fObj
          0 unscalable  fObj
            0 fixed scaleX|Y
            0 fixed homeScale

    0 une carte de mes voyages

    0 C-puzzle ("create objects" puzzle) : "recrée avec des formes l'image suivante"

** icObj.type = "url" : open new tab on click
      0 move to next exercise
*  icObj.type = "video"
*	 icObj.type = "webcam"

0 ne pas vouloir trop en faire pour le moment, rester sur quelque chose de simple

22 décembre 2020:
  Internet exists :
*   0 Z-puzzle : have players go find the puzzle pieces (==images to paste on canvas) on the Internet
**  0 CTRL-F on a webCanvasPage

* object wells: click and drag on object well to get an instance
    0 static
    0 animated object wells : le triangle rectangle qui tire des carrés qui disparaissent dans un portail cicatrice, on peut attraper le carré au vol

LES FAIRE FAIRE => il faut qu'ils utilisent l'éditeur à un moment donné

* une représentation de l'espace mental alloué : FORTNITE en gros et Mathématiques en tout tout petit

* le code informatique est lui aussi quelque chose de "moderne", dans le sens où il est porté par une fractale (à la différence du "plain text" (si on ne prend pas en compte les références littéraires ou culturelles))

* Le cours de la 4ème<X>:
    at start of class, file is opened
    during class,      content is edited
    at end of class,   file is saved

*être fiers de moi, c'est pas le but. Mais il faut aussi qu'ils soient un minimum admiratifs, sinon comment adhérer ?

23 décembre 2020:
* La même chose avec les fractions : utiliser l'infinite canvas pour montrer les fractions
    0 enchaînements alternés de découpages verticaux puis horizontaux etc.

* "Nombres en boutons"(== xylophone, fractal rep, etc.)::Somme
    positive side is immutable : get to target number using only negative side buttons (target = negative + positive)
* Probabilités avec les nombres en boutons de fabriquer le nombre N ?

** infiniteCanvas editor is a place for students to run algorithms by hand (? ideal sandbox ?)
    example: create Koch snowflake
    example: create Sierpinski's triangle

    exemple: trier un jeu de cartes...

* skewing exists in fabric => easy parallelograms from square
* Skewing allow easy creation of "big-to-small arrows" from standard arrows

* le project, c'est peut-être augmenter la boîte à outils numériques des élèves :
    - Scratch
    - Geogebra
    - Tableur
    - Infinite Canvas Whiteboard

* visualisation/manipulation des homothéties avec un object well et le zScroll
    Z-Puzzles sur les homothéties


* icObj types:
    [
      //primitive
      rect
      text
      circle

      //composite
      group (== anonymous composite)
      groupWithBgRect (bg rect will allow stroke and fill (== border and backgroundColor))
      card
      doubleObject
    ]

* z-puzzle : user must create group with objects ( zSlot only accepts group with particular properties)

* workingHomeScale : this would allow easy drawing of architectural planes

** mScroll (est-ce que ça a la moindre utilité ?)


** light-sending (== eye-catching) objects : no matter what current infiniteCanvas.scale is, a star grows from object so that it is visible at current infiniteCanvas.scale

** marker objects (on revient au côté whiteboard): those objects are like the other canvas objects, but they are not designed to stay, they are here to ease explanations
    0 toggle show marker objects
    0 clear marker objects

* animation: décollage de fusée
* l'infiniteCanvas permet de matérialiser des expressions du genre "étudier en profondeur" ou "un savoir superficiel"
* presentation : standard "infinite fall" story carrier: each story item is displayed on a square at zoom level n

* dynamic fabric object which parts pop and destruct along with the current pov (follow the yellow road) (this way an infinite object (like an axis) still can be represented)

24 décembre 2020:
* Lien entre le xylophone et les z-puzzles : La balance: target weight / current weight  (peser une planète sur une balance, c'est irréaliste, mais bon...)
**   paradrop:
        "updward" z-scroll(the only available) momentaneously changes object homeScale but object falls down to its natural homescale when released
        sparkle indicates where small object is (if user wants to remove it from the scale(==balance))

*( PUREE ! BALANCE EN ANGLAIS C'EST SCALE! On peut rebondir la dessus.

*edu: angle pas droit: glisser un éléphant dans l'espace intersticiel et ajouter un commentaire à côté "regarde, l'angle est tellement pas droit, qu'on a pu y ajouter un éléphant"

**  student may ask for hint:
      sparkle (light-sender)
      Arrow indicator in HUD ("in this direction, there may be something useful")
        hide arrow indicator when user is "in the object surroundings"
        additionnal upward/downward arrow to avoid using too many sparkles

** Le multiplicateur :
      un objet est sélectionné
      l'utilisateur choisit le type de multiplication : longueurs ou aire
      un nouvel objet est créé selon la multiplication

** Le guide âne pour montrer les découpes de fractions

* xylophone : 10^<n> zone : "nombre sélectionné dans cette zone" : donner plusieurs écritures
    exemples:
      5 x 10^4 : 50 000
      2 x 10^(-3) = 0,002
** /!\ aux erreurs d'arrondi quand on demande à l'ordi de sommer tous les termes
    updateActiveNumber 0.7000000000000001 (when only "sharp 0.7" is active...)
      => use string type
      OR
      => use Math library

** Comment faire pour débugger quand il n'y aura plus de logs pour avoir la meilleure performance possible ?

* zéro est un nombre comme les autres : créer une autre version du xylophone avec le zéro selectionnable et pas de toggle isActive sur les xylophone towers
    (le xylophone vanilla à un zéro "absence")

** xylo abaccus: manage temporary multiple active towers in xyloZone : show timer 3,2,1 and then resolve chaos and bring back order. This can involve cascade updates.

** il y a des problèmes que la civilisation se pose à elle-même : pourquoi avoir gardé le système de position des nombres de la droite vers la gauche alors que l'on lit de gauche à droite en occident ?
    parce que du coup, on se retrouve avec une droite graduée, qui va "dans le mauvais sens"

**xyloSynth: user types number and xylo updates accordingly (though we can't see much with standard xylo) (exponential xylo will be more readable)

* black is a strong color : black zero in xylophone catches the eye a lot, is it a good idea ?

** multiplication de deux segments colorés : utiliser des gradients pour former un damier
    _[___|___|___] segment3, couleur3
   | |
   |_|   à l'intérieur, chaque rectangle (ou carré en fait) est colorié avec un gradient de manière à former un damier (on voit n x m carrés, et on voit que leur couleur c'est un mélange de couleur_n et de couleur_m)
   | |
   [_|
  segment2, couleur2

25 décembre 2020:
* xylophone: ? add sounds ? (en base 9 on peut faire do ré mi fa sol la si do)
  0 ECRIRE EN GROS : ~ 5x homeScale

  *zPuzzle: piecewise hints:
    "la pièce n°2 se trouve au coordonées : x = ...   y = ..." et la position courante est affichée dans le HUD ->> l'élève peut chercher à tatons


** all is there : everything on the same canvas (~The Witness)
      remarque: le xylophone prend déjà une bonne partie de la place
** metagame : stars: get all 20|120 stars (comme dans Mario)
      3 stars for every minigame: easy, medium, hard (ces étoiles apparaissent dans un écrin de verre qu'on enlève en réussissant l'exercice)
**    étoiles d'exploration : some starts are there for the taking

   metagame: completing exercise X gives a puzzle piece for completing exercise Y
***    par exemple des xyloTowers ("touches de xylophone") pour pouvoir écrire des nombres qu'on ne pouvait pas écrire avant (ce qui fait le lien entre (z-)puzzle et xylophone (la xyloTower ne change pas de taille (pour ne pas trop perturber le joueur (au moins au début))))
          ce qui ferait du xylophone un objet central, sur lequel le joueur reviendrait plusieurs fois,
          et qui donnerait au jeu une saveur à la The Witness (autrement dit, une saveur exceptionnelle)
          ou par exemple des xylozones incomplètes aussi, ou même des xylozones adjacentes collées entre-elles (tout un secteur de puissances)
          ou aussi des xylozones avec les xyloTowers qui sont pas mises dans le bon ordre et qu'il faut remettre dans l'ordre avant de pouvoir les utiliser

  (0 beautiful xyloZone : perroquet: oeil(zéro) et ailes(1-9)

**  units converter : user types number and (unit_from; unit_to) and:
      1. the two unit-bound xyloZones are highlighted, unit_from with red border and unit_to with green border for example
      2. each xyloZonePerception has two lines : one for the number expressed in unit_from and the other in unit_to
      so user sees it's only a shift (when units are "scalar units")

*	ne pas réinventer la roue : https://mikemcl.github.io/decimal.js/ (javascript numbers have limited precision)

** separate 10+ mantissa numbers when writing string rep: separator |, or bracketing [] (instead of having to create symbols (we don't write A for 10, we write 10| or [10]))
    + write which base is used (cela va de soi)

* remplacer le point de la notation anglo-saxone par la virgule
** toutes les zones ramenées à unitZone.homeScale: afficher des agrandissements/réductions des différentes zones (un truc avec des lignes à moitié diagonales) pour arriver à un affichage de la somme des composantes à homeScale == unitZone.homeScale

* xylophone: fading optional zeros for decimal number : zero "inside" !!= zero "outside" (==optional) (concept mathémtique: chiffres significatifs)
* xylophone: cadenas à code pour xyloShow: user inputs number via scrollable cylinders

* 0 make xylophone dynamically infinite (destroy/create zones around current scale)

*:'( 2D canvas does not allow non-parallel skewing (~"scale traversing" objects)
    => use a 3D library to have:
      -scale traversing arrows
      -"pov aware" objects (==orienting sprites (as in paper mario))

26 décembre 2020:
***( un hyperlien, c'est juste un portail (dans le sens Portal)
      tous les portails de l'infiniteCanvas sont à sens unique (impossible de se retourner dans un espace 2D et aussi: un portail n'a pas d'épaisseur)
* traverse portal while zScrolling (==while "carrying" object)

* Build Empire State Building tower (ESB tower) with xyloTowers
  =>
* size-preserving z-scroll

** power fractals:
    squares
      8 8 8 8
      8 8 8 8 etc.
      2 2 4 4
      1 1 4 4
    staircase
      1
      [1] [1]
      [2   2] [2   2]
      [4   4   4   4] [4   4   4   4]
      etc.

** 0 Flat xylophone
    0 additions
    0 multiplication: scale "multiplier xylophone" so that the result's area equals B times A's area
      flatXyloB * flatXyloA
  A->   [   1   ]
       2[   1   ]
       2[   1   ]

       ^
       |
       B

*" en fait, y'a que des fractales partout, des conteneurs dans des conteneurs dans des conteneurs, etc. etc. etc.
*" je suis pas idéaliste ; mes idées, je sais qu'elles sont réalisables. (et je le sais parce que "ça" a infusé en moi)
*" l'infiniteCanvas, c'est juste un espace dimensionné pour notre discipline (autrement dit un espace infini)

** toutes ces fractales prennent beaucoup de place, si je pouvais mettre des canvas dans des doubleObjects, ce serait moins encombré, on serait plus à l'aise. Et ce serait davantage rangé. ça ferait comme les niveaux dans Mario64.

*** OPEN YOUR MIND (== "the world from a slit" / "THIS IS UNKNOWN TERRITORY"): initially, the player can only only see a small (_yet infinite_) part of the canvas, because there is a slit and the rest is black and filled with "unknown territory" labels
      open your mind animation: move to slit pov and show user that the slit is growing to a new size (/mutating to a new shape ?)
      -idée de scène initiale:  la caverne de Platon, et ensuite la personne se retourne (grosse animation, stupeur, mydriase etc.)

* a universe in ceiling cat's left eye

** "eye in eye" sequence: reversed image in retina: someone looks to someone which looks to someone, etc.

** entire book in canvas
** entire books : the Library

** time picture frame tunnel:
      __________
      |1940
      |    ______
      |    |1941
      |    |
              ...

* 0 trouver un moyen de symboliser "cette pièce est/n'est pas z-scrollable (i.e. "cette pièce à une taille fixe")"

** z-puzzle: arbre de calcul interactif: targetNumber,currentNumber
      easy: pieces == numbers
      normal: pieces == operators
      hard : pieces == numbers & operators
      => need graph library
        ? https://github.com/anvaka/ngraph.fabric

** z-puzzle: remettre les noms d'objets au bon endroit étant données telles et telles propriétes
    exemple:

** pour le calcul mental: parcours avec un timer: il faut aller récupérer le trésor caché profond en entrant succesivement dans des portes. Si le joueur met trop de temps il est ejecté (zoom-out animation) jusqu'à la porte de départ.
      la zoom-out animation doit être un peu costaude à coder non ?
      en cas de succès : collecter automatiquement l'étoile pour ne pas frustrer le joueur qui avait réussi à la débloquer ?

*[
  mini game ideas so far:
    xylo_write
    xylo_read
    z-puzzle: classic
    (z-)puzzle: arbre de calcul
    (z-)puzzle: range les nombres dans l'ordre croissant (on peut donner une sorte d'indice en mettant un mini xylo la tête en bas pour les nombres négatifs)
    (z-)puzzle: geometry: object names
    z-puzzle: citizenship/society: remettre les choses à la bonne taille
      par exemple: on écrit en grand "MOI"    et en petit "les autres", pour représenter l'individualisme
                   on écrit en grand "DROITS" et en petit "devoirs",    pour représenter l'oubli fréquent du lien entre les deux aspects de la loi
                   le joueur doit rétablir l'équilibre, c'est-à-dire la même taille pour les deux objets

    timeout travel: standard (pour exercer la mémoire, genre "active l'interrupteur à côté de la mouche", "maintenant, active l'interrupteur à côté de Y")
      on timeout write "time expired" and "you hear a door closing" to warn player that they'll have to start again back from the start
    timeout travel: deeper and deeper: calcul mental
    c-puzzle: évaluer des expressions
      - priorités opératoires
      - nombres relatifs
      - expressions littérales
    s-puzzle: ???
    P-puzzle: géométrie
    greenMouse
    Indiana's path

  wow-effects:
    a small part of a big piece is visible on the side of the screen
    piece already in slot but very very small
    slot hidden in piece

  big-picture:
    build numbers with only 1 to start with
    xylo recomposition (== (re)compose challenge input)
    zPuzzle zTraveler recomposition: to complete z-Puzzle, you have to 'activate'/'enable' all z-Travelers

    familiarisation progressive avec les "objets concepts" (comme les symboles dans The Witness)

    unlocked challenges :
      diy: when puzzle is completed, it can set up a challenge
      dust off: when covering challenge is completed, it reveals the covered challenge
      multikey: when challenge is completed, the multikey that was used is unlocked and can be used elsewhere
    unlocked recomposition component:
      unlocked challenge piece:
        movable:
          standard piece
        unmovable:
          zTraveler (unmovable yet moving)
    unlocked "skills":
      object wells:
        numbers
        operators (for example: a well that generates operator "+" puzzle pieces)
        geometric figures
      transformations:
        rotate
        machines:
          x10
          /10
          clone
    unlocking always happens via the same artifact (see: xylo-unlock)
    unlocked areas:
      Alice system
      "horizontal" areas

    unlocked:indirect key:
      xylo-unlock: player successfully completes a greenMouse challenge, then a number is given to them and they have to type it via the xylophone to unlock next thing

    unlocked places:
      "open your mind" system
      canvas-container double object (an entire fresh canvas in your fridge or bedroom window)
        and portals to get back to "home canvas"
      "<n> <X> required" door locks
      once Z|S|C-puzzle is complete, it transforms into a doubleObject or a portal (castle door for example)
      password (or hint or directions) hidden behind puzzle (player has to dismantle it in order to see the message behind (==l'étoile des douze coups de midi))

    geometrical puzzles inside number shapes
      ((construit un nombre 1 qui ait pour aire 1
      ((construit un nombre 2 qui ait pour aire 2

    co-challenges: challenges can only be solved by progressing alternatively in one and the other
      example: solving greenMouse challenge make sparkle appear(which indicates z-puzzle piece location) and putting piece in slot makes sparkle appear which indicates greenMouse challenge is renewed

      digitWell: a many-digit number can be transformed into nb_digits wells, each yielding the corresponding digit (exemple: de 7891, on pourra extraire [7] [8] [9] et [1])
        on peut créer des co-challenges qui font évoluer le "nombre puits" au fur et à mesure (c'est prometteur mais il va falloir se prendre la tête pour faire un "level design" qui soit goûtu)

  tool ideas so far:
    xylo_show
    ESB scroller with 'scroll increment = f(scale)'
    pythagore_show (avec des carrés)
    photograph: take picture of current rect and create puzzle piece or icImage from it
    clone tool
    repaint tool: input slot, color parameter --> output slot
    common multiples grid
    le répartiteur: user creates a partition of a 100% box and can then drag any collection or number that will be divided into different output boxes with the right proportions
    area of numbers (2 has area 2, 123 has area 123 (1 has area 100, 2 has area 20 and 3 has area 3))
    protractor
    redMouse calculator (a redMouse doesn't die when released anywhere)
    solution writer assistant: as in Scratch: writing a solution would involve selecting blocks and putting them together
    clock_simplifier: perform simplification of mathematical expression at each clock tick

  edu:
    slow building of year's z-puzzle by getting puzzle piece for each part of year's course when done (slow compositing)
    difficulty gradient:
      Say we want children to try a particular challenge type 20 times, first instance will be easy, then there will be a gradient of easy/medium/hard till the last instance which will be hard
    prevent bruteforcing by increasing nb_challenges_todo when bruteforcing is detected


]*

* xylophone for hours/minutes/seconds:

* pythagore_show: show squares (use same "reference square" in all three squares)

((à considérer ultérieurement: divisor drips and square-root waves: puisque j'ai un canevas infini, pourquoi me priver ? http://www.divisorplot.com/
  ((y'a un moment faut se calmer

* essayer un xylophone compact avec les chiffres en mode photo de classe (est-ce que ça va pas faire un peu abrupte ?)

* once again: make it sexy
    0 papier peint "pattern" sur les xylophoneTowers

** showing before dying : avoir un z-puzzle basique à montrer à Paul

** Hue(==anti-sparkle): object opacity getting stronger as we get closer
    trois parfums:
      glassPlaque: only scale matters, (x,y) doesn't matter
      Clameur: obj is "localized" around a particular(x,y,scale) ("nearer, we hear better")
      spook: it disappears when getting too close

** S-Puzzle: slot-only puzzle : user has to enter slot and complete task for slot to fill with completed state (typically, the slot becomes colorful, hence the name)
** C-puzzle: colorize puzzle: user has color palette and must color areas corresponding to number

27 décembre 2020:
** user created sparkles : SparkleMarker:
    - pour se repérer: "true"SparkleMarker
    - pour effectuer des mesures : l'outil mesure peut prendre en entrée des SparkleMarkers, ou créer des sparkleMarker

** edu: choix pédagogique pour les représentations: moi j'aime mon xylophone, mais d'autres préfèreront une autre représentation, libre à eux d'utiliser la représentation qui leur convient, étant donné qu'enseigner, c'est enseigner ce que l'on est.

* save game state: some objects don't need to be saved (since they are generated automatically when page loads)

*PAUL:
  un repère orthonormé pour chaque xyloZone, pourquoi pas, un seul axe en fait, l'axe important, l'axe des ordonnées avec 1 2 3 4 5 6 7 8 9
  z-puzzle: slot avec 1.47 x 10^-3 qui fait écho au papier peint des xyloTowers

* machine à x10, machine à /10 : un slot d'entrée et un slot de sortie

** écrire "taille normale: ..." et surtout _"agrandissement: ..."_ sur une zPièce pour bien montrer que ce n'est pas la taille normale de la pièce

* tous les élèves évoluant sur le même canvas: quel intérêt ? (à part du showoff client-serveur)
    compétition:
      -dynamic leaderboard (ce serait une sorte de course, on pourrait repasser 1er, ou être maintenant 3ème etc.)
    coopération:
      se partager les tâches: ~escape game (il faudrait que les élèves commencent à des endroits différents)

* photograph: take picture of current rect and create puzzle piece or icImage from it: this way user can create keyFrames to create a comic book page

* geometric puzzle: overlapping slots: pieceX has pointA, pointB, pointC labels, pieceY has pointB and pointC and pointD labels, so we know where to put it wrt pieceX
**  P-puzzle (==slotless puzzle, ==le bon vieux puzzle des familles): puzzle can only be completed by assembling adjacent pieces

*res: _DK Wonders of Nature_,  incredible source of beautiful natural objects

28 décembre 2020:
  NUIT HORRIBLE MAIS PROLIFIQUE
* create portal KeyP: select from, select to
* create canvas: a portal to another canvas
*   canvas link : move from any canvas to any canvas, example: triangle A <-> B <-> C et C <-> A
      "KeyBack": return to previous (/parent) canvas
* ? web page as fabric object ? (this way I could include a Scratch page for example), ou bien la page de l'ENT

* point and click a la Myst, from room to room: fake immersion with portal buttons (and back button) (actually, all frames are next to each other, but pov creates the immersion effect)

** Bubble sparkle (comme dans les bandes dessinées): "Hey!"
** PNJ: quêtes annexes:
    - remettre les poules dans l'enclos
    - Link(Zelda): je voudrais une épée plus grande ! "Merci, maintenant c'est moi qui ai la plus grosse."
** enemies: some enemies are wandering around and when they lock on player, scroll & move are locked until enemy is destroyed
*( Level and Xp ?

((
 * encore un peu sur la propagation de l'information:
    tdlr: NOW == SAY (ASSERT)
    - information could be polled every X seconds:
      'now' is eval'd only at discrete (regular or not) intervals
        ==> different versions from different 'sources' ==> revolve conflicts
    - legitimate sources:
        my students say "'now' is this"
        I am no longer legitimate to say what 'now' is
        ==> 'now' is saying "'now' is this"

  * representations::areas of influence: RepA could 'source' 'Network'X and 'Network'Y, RepB could source 'Network'Y and 'Network'Z
))

* Z-Memory: like a classic memory game but slots are big and small

* mirrored xylophone (left) + ESB tower (center) + tower fall on graduations(right)
* piano with sound for each piano key (base 8, do ré mi fa sol la si)
* challenge is there but unreadable:
    stains (need to unlock wiper)
    blur   (need to unlock glasses)

** PreviewSparkle: quand on veut embrasser d'un coup d'oeil des objets de taille très différentes

* 728,4�32�001: show empty space or unknown character for missing xylozone digit
* xkcd: put some mini characters here and there a la xkcd
* Z-Puzzle::Tangram
* NightVision/ThermalVision

* Docteur Maboule
* Z-Labyrinth => object is locked inside walls but can shrink/grow with Z-scroll to get to destination or to get out (the existence of a getout narrow passage is only blatant when zoomed):
    fabriquer un système de collision
    (fabriquer un système d'interrupteur et de portes qui s'ouvrent et se ferment (casse-tête)

* canvas world::scale world: a world with gravity which weighs a collection of objects
    target weight: ...
* Z-spook::telephone numpad (layerN is only visible for f(n)<scale<f(n+1) and opacity==1.0 for layerN.homeScale)
* Spook Challenge::constellation: challenge only appears around a certain (x,y,scale)
* (<X>-)puzzle: color on color: hide piece on top of similar object texture (like the chameleon) ("la pièce marron est cachée dans le pelage du chien")
* (color composer: compose color using R,G,B values ( (or using hexcode...))
* Angle-puzzle:telescope: user can set a precise angle (using arbitrary precision graduations) for the telescope and when the angle is the good one, a star can be fetched inside telescope's objective
* L-puzzle: link puzzle: relier les points
* Puzzles géométriques faisables/impossibles:
    faisables: avec un angle droit:
      Pythagore
      Triangle inscrit dans un cercle
    impossibles: avec un angle presque presque droit (il faut zoomer fort pour trouver pourquoi ça ne snappe pas)
      Pythagore
      Triangle inscrit dans un cercle
      ...

**Z-scroll: trace fading animation (so that user sees than the piece is growing or shrinking (or keeping its size (for non z-scrollable objects)))
* puzzle autour des fractions: Tablette de chocolat: 6 rangés de 4 carreaux (Mathieu)
* Localization challenge: select point with coordinates (x,y) or (r, theta)
    many points are put near the target point to show user that they sometimes need precision and zoom in to discriminate

* Le coin informatique:
    Algo-puzzle: user has to select to right operators to get to result
        operators:
          assignation == mutator == set
          evaluation  == accessor = get

((
Le petit coup de gueule mental de la nuit: "le dénominateur, c'est le nombre en bas": pas d'accord
  En fait je ne suis pas d'accord avec l'appellation dénominateur pour le nombre du bas dans une fraction;
    pour moi on devrait appeler dénominateur le morceau 1/b, de cette manière on serait plus cohérent.
    Quand j'ai 3/5, j'ai 3 cinquièmes == 3 (1/5)èmes. J'ai pas 3 cinqs.

  Lettres (lettre étiquettes et lettres nombres):
  Il y a x filles et y garçons.
  Combien y'a-t-il de filles ? Il y en a x. Ici x a uniquement une fonction numératoire.
  Qu'est-ce qui est en y exemplaires ? Ce sont les garçons. Ici "garçon" a uniquement une fonction dénominatoire.
  Le nombre a ce petit truc en plus par rapport à l'étiquette classique (étiquette classique == incarnation de la fonction dénominatoire) : il a une fonction numératoire.

  Donc: encore plus fort:
  Quand j'ai 3/5, j'ai 3 (1/5)èmes, mais je pourrais aussi dire que j'ai (1/5) trois.

  Soient une espèce d'animaux que l'on note z. On peut prendre 4 exemplaires de z, autrement dit 4 z. Mais on ne pourra jamais prendre z 4.
  On ne peut pas prendre singe 4, mais on peut prendre 4 singes.
  Dans ce cas z est simplement une étiquette. On ne pourra jamais compter avec z.

  En fait, pour décrire un produit de 2 nombres,
    - soit je parle avec un couple (numérateur, dénominateur) (que je peux choisir dans l'ordre que je veux)
    - soit je dis, sans prendre le risque de léser l'un ou l'autre des nombres (qui aurait voulu être numérateur ou dénominateur à la place de l'autre), c'est le produit de x et de y (on est obligé de commencer par l'un ou l'autre mais c'est moins spécialisé (désolé y si tu voulais être en premier)).

  L'idéal serait peut-être de dire: dans un produit avec le symbole "x", le premier terme est le numérateur, le deuxième est le dénominateur.
                                    dans un produit avec le symbole "grand Pi", il n'y a plus de distinctions.
  Une étape importante pour les élèves, c'est de comprendre que 3 x 4 donc "3 quatres", c'est la même chose que 4 x 3, "4 trois". Et l'unité est la clé pour résoudre ce problème (et tourner la tête pour refaire apparaître le rectangle dans le bon sens).
))

* Make it visible:
  Addition: fusion de parcs à moutons
  Multiplication: des moutons avec des moutons à l'intérieur
    ou alors on peut dire que chaque mouton du parc A rêve du parc à moutons B, ce qui fait n x m moutons de rêvés en tout.

* Calculator: missing keys: reassemble it before being able to use it

29 décembre 2020:
  29, c'est déjà un peu plus beau de 28

* code chiffre/son:
    challenge: "712", il faut placer dans slot(=="sertir") un katana

* comptage analogique:
    challenge: "150317": il faut sertir une pièce qui possède 150317 particules dessus
    challenge  "3 jaune/4 rouge": il faut sertir une pièce avec 3 points jaunes et 4 carrés rouges
    challenge: "17": il y a écrit 17 en pointillisme mais il manque deux particules pour faire 17 (le slot est visible, mais subtilement)
    challenge "incomplete rippa: 4/?": double challenge: il y a un outerslot et un inner slot

** Revenir sur les puzzles:
    - soit parce qu'il y a encore des étoiles à récupérer
        Mécanique: correct is good, fast is better
          exemple: le joueur gagne une deuxième étoile en refaisant le z-puzzle en moins de 40 secondes
            cela permet de créer des joueurs qui maîtrisent bien le z-scroll, qui l'ont intégré
    - soit parce qu'on a trouvé la pièce pour l'indice correspondant (MonoZSlotChallenge) (au moment où on a trouvé la pièce, on sait exactement(et c'est vrai) où elle va)
    - soit parce que ça y est on a compris ce qu'il fallait faire (jusque là une(/les) pièce(s) qu'on pensait correspondre à l'indice ne donne(nt) rien: on s'est pris des râteaux)
        exemple typique: le comptage analogique: indice: "150317", pièce à trouver: une pièce qui contient 150317 particules
          le joueur a testé de mettre des objets qu'il pense faire 150317 mètres, de mettre une expression littérale dont le résultat donne peut-être 150317, mais sans succès
          on peut donner un indice au joueur en écrivant 150317 en pointillisme mais le mieux serait de faire ça plus tard

   remarque: les différentes écritures des nombres sont une mine d'or pour créer des challenges

*[
Mécaniques de déroulement: {

  mécaniques:
  couple slot/pièce (SPCouple): une fois que la bonne pièce est snappé dans le slot, le slot s'entoure de vert pour indiquer que c'est bon
  duo indice et SPCouple (MonoZSlotChallenge)
    -l'indice est à côté du SPCouple: classic (outer hint)
    -le SPCouple est dans l'indice:           (container hint)
    -l'indice est écrit dans le slot:         (contained hint)
    -l'indice est écrit dans réparti dans le slot et dans la pièce: (complex contained hint)
  collection de MonoZSlotChallenges avec une logique propre: ZPuzzle
  containerSlot: un slot pour plusieurs pièces ("enclos à poules")
  "greenMouse" piece / vials: "trempez-la dans l'huile, trempez-la dans l'eau, ça fera un escargot tout chaud" (hold click and move around while held: piece mutates while held)
    this will allow user to keep focus, focus being almost captured by the holding down mouse button
    user won't have the possibility to insert a "how about sending a text message to Y ?"-step during the transformation sequence, because _mouse button is held down_.
  fragilePiece(=="fragile greenMouse piece"): => F-Puzzle
    1.user clicks on piece well
    2._while held_, piece can be mutated via mutationAreas (+1, /10, change color, etc.)  (pièces forgées au fil des "trempages")
    3.when piece is dropped:
      if piece is above a slot and corresponds to the slot criteria: piece is kept alive in the slot (slot is filled)
      in any other conditions: piece dies
  fragilePieceTemporarySlot: un avre de paix pour la fragile piece (qui doit peut-être être encore retravaillée), en attendant de rejoindre son slot de destination
  challenge resets when player has made too many attempts (prevent bruteforcing)
  FiniteWell: well will only yield n clones (no more)

  déroulement:
    it would be nice if every new mathematical topic could be introduced by a new puzzle type (this way the user is 'delighted', and could memorize the mathematical topic by remembering the puzzle type)
      en suivant cette logique: faire un challenge mélangeant topicA et topicB serait créer un challenge avec un puzzle mélange de topicA.puzzle et topicB.puzzle

  mutations:
    challenge complété devient:
      slot
      pièce
      challenge
    mutation complexe:
      "step challenge": collection de SPCouples complétés devient une pièce et le challenge "mère" mute également

  wandering around:
    montrer où sont les challenges: NAVI(Zelda) (c'est un objet complexe fabriqué à partir de Sparkle)

  déblocage:
    request:
      from player: player presses "give hint" button
      from game: le jeu demande qu'on donne un indice au joueur
        -à partir d'un certain temps
        -quand le jeu détecte que le joueur commence à être à la traîne par rapport au "peloton"
    les indices en eux-même:
      transformer un indice pour le rendre plus explicite (exemple: pointillisme pour le comptage analogique)
      montrer c'est où:
        sparkle
        HUD arrows
        les cailloux du petit poucet
      montrer un exemple de comment faut faire:
        solution "sèche"
        animation


  revisite:
    Z-puzzle disséminé
    do it faster now / do it real fast now
    color the world: colorier tous les 123 du jeu en rouge,vert,bleu débloque des étoiles (ou une seule étoile si on veut faire un challenge "road to 100% completion")
    the top-down edu principle:
      1. nommer l'objet
      2. rentrer dedans pour étudier ses propriétés

  challenges:
    autour du chiffrement:
      codage
      décodage
    induction:
      objets répétés et emplacement vide: il faut mettre un exemplaire de l'objet répété dans l'emplacement vide
      suites logiques:
        remplir l'emplacement du terme <k>
        remplir l'emplacement du terme général
        suites logiques avec figures géométriques
      fonctions:
        expression
        graphique

  décoration:
    écrire des noms de mathématiciens autour des challenges (+ mettre la photo ?)
      exemples: Sloane pour les suites numériques
                Pascal pour le triangle de Pascal
}
*]

((je le mets histoire de dire, mais je mets pas d'étoile, et j'espère qu'on le mettra pas en place: put the right price on object (on dirait que la raison de pourquoi on l'a pas mis, c'est parce que ce n'est pas stable dans le temps, et on passerait vite à autre chose :))

**philosophie de la montagne(mathématique (ou tout autre discipline)):
    1.reconnaître qu'elle est là, c'est-à-dire la rendre réelle : arrêter de passer au travers comme si elle n'était pas là. D'une certaine manière, la respecter.
    2.Plus on la gravit, plus on peut redescendre en glissant (et prendre de plaisir ce faisant), on peut aussi maintenant faire des figures au dessus des endroits où l'on avait précédemment peiné avec les cordes et piolet et crampons. Une fois qu'on a déjà été une fois à l'altitude h, on peut prendre l'hélicoptère pour y revenir.
    3.une fois qu'on est à l'aise avec un secteur, on peut aider les petits à monter, mais bien sûr, on ne peut pas leur faire prendre l'hélicoptère, sinon pour leur montrer ce qui les attend. (est-ce que ce serait pas quand même du gros spoil bien sale ?)
    4.on peut toujours trouver du nouveau, même dans les secteurs les plus arpentés. ou une couche de neige réconfortante.


((github
*choose license decision tree would be a nice idea for users creating new repos (like me)
    =>~ https://choosealicense.com/ :)
* wow: https://archiveprogram.github.com/
))

** pour les fractions: on pourra diviser par 1000: un rectangle devient 1000 petits rectangles
    combien de 'particules' le système peut-il supporter avant de crasher ?

** edu::pour les 'petits': unités, dixaines, centaines:
    demander à l'élève de construire 2,3,4,5,6,7,8,9,10
    demander à l'élève de construire 20,30,40,50,60,70,80,90,100
    demander à l'élève de construire 200,300,400,500,600,700,800,900,1000
**    bien afficher le fait que 200 contient des conteneurs qui contiennent des unités
**    c'est rébarbatif mais une fois qu'ille l'a fait, normalement, ille commence à avoir une idée du principe des décimaux, et ensuite ille peut passer au xylophone (et placer les nombres qu'ille a construit dans le xylophone)


* snapping: ? écouter la vitesse de la pièce ?

representation system is nice:
  this way the slot could mutate a piece in a blink of a eye:
    0 repaint a piece
    0 change its background texture pattern
    0 change its size
    0 rotate the piece 90° clockwise
    0 its nature
    0 its behavior (activate or deactivate eventListener code)

  0 more complex: change underlying fObj while held: fImage becomes fGroup for example

** relative number piece creation: F-puzzle
    on a un (ou plusieurs) nombre(s) de départ
    on a quelques opérateurs, _mais pas tous_
    et on doit remplir les slots avec des nombres forgés au fil des "trempages"
    exemple: si on a 4 au départ, et que l'on veut fabriquer -10, on trempe la pièce dans "+1" puis dans "x(-2)"
** trempage::équation:    même chose mais on part d'une équation
** trempage::inégalité:   même chose mais on part d'une inégalité
** trempage::encadrement: même chose mais on part d'un encadrement

**When you feel the concrete at the tip of your fingers, when you smell it, when you press your face over rough surface, you might have nice, _sharp_, "concrete-ideas". Otherwise, you might have "far perception-ideas" (which can be nice though, but are too often blurry on closer examination).
    on pourrait même se demander: qu'est-ce qu'on apprécie dans une incarnation ? l'idée qu'elle porte, avant tout ? ou plus simplement, son existence et par conséquent, son interaction avec nous ? (ENCORE UNE FOIS TU VAS TROP LOIN, CHERCHE PAS TROP A FAIRE LE MALIN, RESTE DANS LE BETON MON VIEUX. RAMENE TA FRAISE, JE VAIS TE FAIRE INTERAGIR AVEC UN SAC DE CIMENT. TU VERRAS SI LE POIDS DU SAC EST AVANT TOUT UNE IDEE.)
    Les concrete-ideas, elle se construisent progressivement, avec du concrete. Parfois ça se casse la gueule alors faut reprendre. Dans tous les cas, il faut avoir les mains dedans.
*   Ce qui fait peur, c'est quand on montre des bricolages à des gens qui sont pas du métier. (Toutes ces images complètement trafiquées...)       La réalité, c'est un nez qui coule, c'est un gamin qui pleure.

encore et encore et encore et encore des idées: prout
  est-ce qu'a un moment donné faut dire "stop, tant pis, allez vous faire voir dans un autre cerveau, je vous laisse passer, je vous retiens pas, la sortie c'est par là" ?
    onNewIdea((idea) => {
      //ignore
    })
  tout le temps parler, tout le temps parler, tout le temps parler: prout
  et si on dansait ? et si on écoutait l'Autre ?

* snapping: show that object will be snapped on release (==on drop) (so that user, being informed, chooses to drop it)
* snapping: what would be nice would be to use the norm of a transformation matrix to settle threshold
* snapping: new events: onSnapped, onUnsnapped
* snapping: asymmetrical allowed input size range: 80% - 110% (pour privilégier la fabrication de pièces qui "rentrent")

* on pourrait aussi habituer les élèves, qui savent déjà faire la conversion secondes/minutes/heures/jours/années/siècles/..., à faire la conversion mot/ligne/page/chapitre/livre/armoire/bibliothèque/...

Comme mes élèves, "ils" n'ont rien demandé. Ils se fichent complètement de savoir si la grossesse a été difficile ou pas, de pourquoi j'ai pas avorté. Le rejeton est plutôt agréable ? Tant mieux. Mais personne ne lui a demandé de venir au monde. C'est très étrange, surtout quand on pense à l'attachement que l'on peut avoir pour sa voiture, ou sa planche de skate. C'est moins fun un magasin vide.

* Plus on connaît de représentations, plus on se rapproche du backingObj.

* pov: show active object
* pov: show last action location (object may be deselected but get me to where I was when I last moved it)

** easyFill: _while held_, near enough to slot, object triggers onSnap(or 'onNearSlot', 'onNearEnough'), which leaves piece on slot, mutates held object (for example it can be a bottle of liquid, whose liquid has partially been transfered to the piece occupying slot), so we can continue filling, all in the same drag sequence.
      easyFill could be a simple "leave clone of held object in slot" ('hit and run')
** easyPaint: simple easyFill with color pieces

** bouton réinitialiser semble indispensable pour les challenges avec des effets irréversibles

j'essaye de séparer ce qui relève du jeu et ce qui relève de l'éditeur:
**icObj.snapped et icObj.type = "snapSlot" et icObj.type = "snapGrid" (si l'utilisateur veut une configuration de snap qui lui plaît mieux, il la fabrique lui même avec des snapSlot)
**layoutBag: icObj.flowLayoutBag: icObjects dropped inside automatically arrange in a "top-left if able" manner
    et tous les autres layoutBags auquel on peut naturellement penser
**snapSlot et layoutBag permettent à l'utilisateur de fabriquer des templates de présentation (==des dispositions dont on peut changer les images, les textes, etc., et montrer à l'utilisateur des variations sur un même leitmotiv visuel)
**et du coup, on pourrait relier toutes les instances de dispositions entre elles de manière à pouvoir appliquer des modifs au template qui se répercuteraient sur toutes les instances.
**presentation options: show/hide slots, show/hide layoutBags (c'est moins cracra de faire une présentation quand ils sont cachés)

* res: _Help your kids with Math_ (goldmine)
** montrer un histogramme avec les nombres entiers pour pouvoir ensuite afficher les multiples et les multiples communs
    cela va demander une construction dynamique de l'histogramme
*[
   icObj.type = "dynamicObject"
   icObj.objectsInRect = (rect) => {
    return objects;
   }
*]

** multiplication posée: highlight factors when hovering partial product

** addition de fractions: trouver un dénominateur commun avec une molette en dessous de chaque rectangle (mais attention, il faut pas que les challenge ressemblent trop à un cours de maths)
**   machine à compter les petits carrés: la machine grogne quand il y a des carrés qui ne font pas la même taille dans son "enclos" d'input

** machine à mélanger, machine à démélanger (dilutions)

***SELF-CONTAINED EDITOR: when sending the file to personX, I send the object I want to send, and its editor so personX see the object and then edit it and send me back the new file, so I can see the updated object and edit it etc.
    this would require saving the file in .html, with an object part (json) and an editor part (html/js)
    https://stackoverflow.com/questions/30563157/edit-save-self-modifying-html-document-format-generated-html-javascript
    https://www.reddit.com/r/learnprogramming/comments/4hjz1z/how_can_javascript_in_html_self_modify_and/
    https://github.com/gildas-lormeau/SingleFileZ
    https://github.com/gildas-lormeau/SingleFile
*[
  the dream:
        page.html (zip format)    //facade pour Monsieur Toutlemonde
          lib/                    //intérieur propre pour l'initié
            machin.js
            truc.js
          index.html
          data.json
*]

30 décembre 2020:
  still ideas: à chaque fois je perds du temps à tout recopier, ma pauvre chérie. comment perdre une heure tous les matins.

** flow-machine: la machine déclenche automatiquement la fabrication quand elle a les ingrédients suffisants
**flow-machine::object _fountain_: fountain = well + surrounding pool: when an object leaves the pool, machine automatically creates a new instance so that pool always keeps the same number of elements

* machine:random number machine: cette machine renvoie un nombre au hasard
* machine:random sample machine: cette machine renvoie un clone d'un élément au hazard du pool en input
* machine:random order machine:  cette machine renvoie une liste ordonnée aléatoirement à partir d'un pool en input
* edu: il faut que les machines soit faciles à utiliser, et que les {drags and drop, snap, légère animation de fonctionnement} rendent la chose ludique (__"c'est simple en fait, regarde !"__)


* challenge::chronology (dynamicConstruct timeScale needed)
   example of objects to place: cadillacs and dinosaurs
* challenge::apple tree: the apple to get to is located on a certain branch of the tree. A code is written like 4568541. The idea is to remember the code and press start. Then the player controls an ant, at the foot of the tree, and at each 'crossroads', move to the right branch (first one is 4 for example, next 5 etc.).
* challenge::homothety: select center and ratio (c'est une machine au fonctionnement un peu différent des autres machines ("à slots"))
* challenge::factory: une succession de "flow-machines", bien connectées entre-elles, permet la fabrication d'un objet complexe
    exemple: l'usine à flocons: on part d'une forme simple et on arrive à des flocons (et même une succession random>homothety pour fabriquer des flocons de tailles différentes)
** challenge: find the operator (travailler l'induction):
      il y a une zone d'input, une zone "opérator" (slot dans lequel il faut mettre la bonne pièce), et une zone d'output
      user can try putting in _any input value_, and result automatically displays in output slot
      it's by compiling those (input,ouput) couples that user finally finds the (most probable) matching operator
      greenMouse and vials could be put close, so that input attempts can be done in one held mouse click

* challenge: add parentheses (en fait ça va être assez hardcore à mettre en place je pense)
* challenge: pixel draw puzzle piece (les amener à compter les carreaux)
    easy:   grid has only "unit scale" precision graduations
    medium: grid has "unit to milli" precision graduations
    hard:   grid has arbitrary precision graduations
* challenge: line draw puzzle piece (les amener à comprendre que 1.97 en abscisses, c'est pas 2)
    line end points always snap to grid
    easy:   grid has only "unit scale" precision graduations
    medium: grid has "unit to milli" precision graduations
    hard:   grid has arbitrary precision graduations

* bizarrerie : all same-mantissa xyloTowers leading to same world (portal (montre-t-on à l'utilisateur qu'il passe un portail ou laissons ça 'seamless' ?))

* "self-contained": append datetime to filename so that savedgames look like videogames saved games (you know, when you choose 'load game')
* "self-contained":editable ==> password?
    empêcher les modifications par les petits malins: checksum
      is checksum written in self possible ?
      checksum in editor.js
      checksums everywhere :)
*"self-contained":editable: tool to show edited parts
    pour que je puisse voir si un élève s'amuse à mettre des images de X dans le monde original (bah ouais, vu qu'elle peut être arbitrairement petite faut faire gaffe)

* 9-puzzle with labyrinths: there is a frame for the 9 puzzle precising where start and end are

* edu: amener les élèves à jouer au jeu tous les jours
    exemple de système: day streak star: pour récupérer l'étoile, il faut la recomposer. Chaque jour, la challenge completion donne une fraction d'étoile (un cinquième par exemple). Il faut donc réussir le challenge cinq jours de suite.
* edu: nb max allowed errors: pour éviter que les élèves brute-forcent les exercices. (peut-être qu'il faut les laisser brute-forcer certains exos, que cette répétition peut être utile pédagogiquement, mais certainement pas tous.)
    ou alors on peut dire:
      easy:   infinite nb of attempts
      medium: 3 errors allowed
      hard:   no error allowed
* edu: montre moi que tu as compris: 5 tentatives minium et un taux de réussite supérieur à 3/5, 4/5 ?
    de cette manière: on voit que l'élève a essayé et on voit qu'il a compris ou pas compris
    0 statistiques sur chaque challenge ?

* edu: challenge habillé VS challenge "nu" (==sans aucun texte) (si y'a trop de texte, on va se croire dans un bouquin de maths)
* edu: outil pour analyser la progression de chaque élève
* edu: timestamps for challenge completion to track cheaters and headless-followers
* edu: tolérance:
    geometry: snap when close enough to answer

* edu: mécanisme pour augmenter la difficulté: montrer moins de choses, laisser un peu de calcul mental se faire
        par exemple avec la machine à homothétie: ne pas montrer la figure image intermédiaire quand on bouge le centre de l'homothétie. Indiquer seulement quand c'est bon. (pareil il faudra un peu de snapping dans ce cas, de _tolérance_).

* fractal labyrinth: some sectors are smaller than others, etc.

* sectors : on peut organiser des secteurs autour d'une même thématique
** map: quick access to sectors

* z-puzzle: que l'on soit bien clair: slots could be "z-different" too (et c'est un peu le sel du truc (parce que sinon, une fois que les pièces sont ramenés au même z, ça devient un puzzle classique))

* essayer des xylophones avec rectangles superposés pour avoir une aire valide:
    xylozone:
    [1]
    [ 2 ]
    [   3   ]
    ...
    - le 1 est par dessus le 2, qui est par dessus le 3 etc.,
    - quand on sélectionne une xylotower, elle passe devant et on voit alors que le rectangle fait telle taille
    - la hauteur de tous les rectangles est la même: si la zone est 10^3 alors tous feront 10^3 de hauteur

    0 essayer avec un léger décalage entre les xyloTowers pour qu'on voit dès le départ qu'il y a des rectangles courts et des rectangles longs

* flemme : regarder notes>"notes_a_taper__30_12_2020"

* edu: fil rouge: walking cat: complète le challenge pour que le mur soit détruit et que le chat puisse continuer d'avancer, etc.

** représentation visuelle de la racine carrée:
      fractale de racines carrées en utilisant un triangle rectangle de cathètes 1 et a: l'aire du grand carré sera 1+a².
      même chose avec 2 et a
      (? et en utilisant 10^n et a ?    10^(n/2) et a ?

** transformer un rectangle en carré:
    encore une "fractale" à la shu
      algorithme: 0: prendre le plus carré possible dans le rectangle
                  1+:avec ce qui reste, prendre le plus grand carré possible et 2 rectangles qui vont bien

(( donner comme note à un élève 10^(-2), 10^(-5),... bravo, bel esprit

** greenMouse::GLU: a particular kind of mutation
      the number 7 could be represented by 7 squares glued together
      soaking this representation inside a +2 vial would result in 9 squares glued together

* relative number: [[sign] [absolute value]]

31 décembre 2020:
* multipiece/multislot: le pendant Z game des "unrasterized" groups
    quand on place une multipiece sur un multislot, des slot peuvent être correctement remplis et d'autres non, en gros, c'est pas encore tout à fait correct.
    ça va demander une sorte de tether, de cordée, entre les "atomes"
*   => edu: construire petit à petit une réponse:  l'élève construit sa réponse avec des "atomes" _dépendants_

**_dependance_ : disons que la multipiece contient une pièce "a", et une pièce "2a", alors modifier la valeur de l'un impacte la valeur de l'autre (et réciproquement (si la relation de dépendance est bidirectionnelle))
** dependance::unidirectionnelle, bidirectionnelle

* SlideAndSnapXyloTower: on peut slider verticalement vers la valeur que l'on souhaite et la xyloTower garde la même largueur, elle snappe vers la valeur la plus proche
    cela apprend aussi à l'utilisateur qu'il va pouvoir redimensionner des objets avec les contrôles sur le contour
* "click & snap" xylotower: quand on clique dans la xylozone, elle traduit le click en un snap vers le "taquet" le plus proche
* ClickAndSnapSliderXyloTower semble être encore plus intuitive (on peut "sortir de l'ornière zéro")

* FreeSlideMonochromeXyloTower: on peut slider verticalement vers la valeur que l'on souhaite (pas de snap)
** FreeSlideColoredScalesXyloTower: la tour montre les différents "étages" nécessaires pour aller à la hauteur demandée   (les tours peuvent être ou ne pas être de même largeur)
    L'effet de couleurs changeantes qui se produit quand on déplace le slider doit valoir le coup d'oeil
    On pourrait mettre un effet sonore aussi, ça serait peut être bizarre
    => Il faut un Z-behavior aux petits oignons pour éviter de décevoir l'utilisateur (le z-scroll ne doit pas induire un changement trop important de la "valeur" de la tour)

** greenMouse: slot has countDown (say "3,2,1,0") and then triggers
    - this allows "soak cancel" (actually I wouldn't want to soak it there)
** greenMouse: the longer you stay, the more you get:
    example: the slot is a [+1] slot, then for every second you stay on it, greenMouse gains +1 (if it was 4 it is now 5 etc.)

*snapping: l'important, c'est les valeurs: il faut trouver des valeurs qui soient "juste comme il faut"
*snapping:unsnapping must be "harder" (snapping and unsnapping are asymetrical)

*snapping: snap(): la pièce écoute la version snapped, unsnap(): la pièce écoute la version free

**~mise en abyme/psyOps: dans le canvas infini, montrer des maisons, des immeubles, et quand on zoome dans une fenêtre du bâtiment, on voit un élève en train de joueur au Z-game, et en fait, c'est nous qui jouons à sa place.
    L'idée c'est de faire croire aux élèves que tout le monde joue au jeu et donc que c'est pas un truc de ringard/loser/tête d'ampoule.

***could we actually combine z-scroll and 3d canvas ? (z-scroll would zoom in current z-layer, but keeping z the same)
      (this would open the door to total madness)

*snapping: snap to any canvas 'position' (pas besoin de snapSlot, ici le "snapper" c'est le canvas lui-même)

* le système de représentations pourrait être utilisé pour retrouver un coupable (ou du moins mieux visualiser les différents points de vue)

01 janvier 2021:
* challenge mecanism: 5 seconds to complete: after clicking on start, user has 5 seconds to complete challenge
    greenMouse allows quick mutation combos : c'est rapide de glisser la souris
*   on pourrait aussi imaginer des mappings locaux de touches de clavier (valables uniquement quand le challenge est actif, pour déclencher des mutations (sous le slot il y aura marqué la touche de clavier pour le déclencher))

* challenge: related objects: mutate objects so that a relation is verified
    examples:
      mutate objB so that its area is twice as big as objA's
      mutate objB so that AC is twice as big as AB

* challenge: shmup: shoot numbers: to destroy negative numbers, you have to shoot positive numbers so their sum equals number opposite

02 janvier 2021:
around puzzles:
* polygonal piece
* rounding corners (any angle): inner/outer: courbes de Bézier (pour ne pas se prendre la tête avec les tangences) ?
* any piece shape ==> masks

* puzzle snap types:
    -shape and content-seam (le truc classique sur un puzzle)
    -shape-seam (la pièce snappe même quand les contenus ne font pas la jonction)
    -content-seam (la pièce snappe quand les contenus font la jonction, même si un des pièces déborde sur l'autre) ==> this requires complex z-index mgmt

* create pieces:
*  - machine: piece mould: input: content container (content), operator: piece mould (shape), output: piece with shape and content
** - pokéball: (single-use portable machine) (masked snapshot), user can carry along a puzzle mould, which when placed over content (this could be many objects piled up), and activated, mutates into a puzzle piece with mould shape and captured content

**machine: portable machine, machine is carried along to input location instead of input being carried to machine location
**machine: single-use portable machine: machine can only be successfully activated once

* wearing objects: objects wear out after a certain time, and then disappear
* edu: creation d'automatismes: [
    - timeout challenges
    - wearing objects
    - focus-enlivened wearing objects: what has not been appearing in screen rect for a long time begins wearing
]

*** Paul's idea: "companion app": une application couteau-suisse qui les suit tout au long de l'année et dont les programmes ont été construit par les élèves: ils se servent de ce qu'ils ont construit

** lien entre companion app et game app:
      - use companion in game (companion 'mascot' is visible in the game)
      - unlock companion skills in game (on est moins dans la construction mais plutôt dans l'acquisition)

* edu: docimologie:
    - noter la progression dans le jeu en fin de trimestre, coeff 2 par exemple
      - progression 'notée' vs progression facultative
    - si c'est le cas, il faut empêcher les élèves de tricher

* edu: un jeu qui suit le cours de l'année: à chaque chapitre, le prof donne le code pour débloquer le secteur associé au chapitre
    et il y a un secteur 'hors-piste' qui est toujours ouvert

** take photo and then look for piece content: photographs can now have very high resolution: piece content could be fetched from photograph
* edu:
    1. on marche et on prend des photos
    2. on cherche des objets particuliers dans les photos en zoomant
    3. on fabrique des pièces et on complète le puzzle

**StickSnap: the idea is to stick two pieces together
** L-stick snap: side-length snap: the idea is to stick two pieces together, using a flat side (a "gon"): snap will trigger only if sides length are rigorously equal
    edu: the idea is to make students understand that sometimes, things have to be precise
** P-stick snap: "perfect"(/"profile"/"protein") stick snap: when trying to stick pieces together, pieceA profile must be the anti(==complementary)-profile of pieceB
    same thing: the idea is for students to observe profiles by zooming in
**    edu: il y a un problème avec ce genre d'idée: _jusqu'où s'arrêter_: une fois qu'on a compris le principe, on peut se dire qu'il peut y avoir des "imperfections" cachées n'importe où ("paranoïa de la ligne jamais droite")

** pile up objects on snap slot:
    edu: the right order: poser 1,2,3,4,5,6,7,8,9 dans cet ordre sur le slot
** fifo/lifo: snapSlot could have fifo or lifo behavior

03 janvier 2021:

**meta-challenge: challenge list: challenge<N>.onCompleted(moveToChallenge<N+1>)
  edu: un meta-challenge "prérequis" avant de commencer une nouvelle étape

** greenMouse: activateOnTouch: onEnterActivationZone/onLeaveActivationZone (un peu comme un snapSlot mais ici c'est pas un snap c'est une juste une activation)
** greenMouse: fastGrow/mediumGrow/slowGrow (same effect but different strength)

** challenge: manually create clone: given a model, player has to recreate a clone of it next to it

* mettre des images de déchetteries: d'énormes piles de déchets

edu: miner des idées dans les bouquins de maths:
*edu: decimal dot-to-dot

** Dobble avec des représentations différentes d'un même représenté
  edu: avec les nombres: 1/2 est équivalent à 0.5 qui est équivalent à 5/10, etc.

** le livre dont vous êtes le héros: zoom-in to the branch you chose
** on peut fabriquer un poème fractal avec ce système

***infiniteCanvas exoObject: the idea is this: say we create an object in fabric(which is normally a representation space for icObjects) (typical example: a freeDrawing) and we don't want to know what it is explicitly(its properties, how it works, etc.), _as long as we can serialize it_ we can create an icExoObject which will then be reenacted when fabric.unserialize(icExoObject.payload)
    un peu comme une éponge sèche, que l'on mouille et que l'on fait redevenir une éponge tout à fait valable

**keyDownToggleX + mouseClick: select object
**keyDownToggleY + mouseClick: select object just below
**keyDownToggleZ + mouseClick: select object just above
**mouseDown/up: hold/release _(previously)selected_ object

**challenge: différentes représentations d'un nombre, un nombre au centre et les autres représentations autour avec des flèches et des slots

*puzzle pieces everywhere: puzzle pieces may have a distinctive frame, or symbol, so that we know it should go in a puzzle in sector X

Les grandes étapes de développement restantes: [
  Editeur:
    serialization
    freeDrawing (exoObject)
    Groups
    polyline
    svg

  Jeu:
    Xylophone with texts
    ESB tower
    ZPuzzle:
      basic zPuzzle
      indicator slot (slot borderColor is either green or red depending on .isValidPiece(piece))
    DoubleObjects
    Sparkles
    GreenMouse:
      basic GreenMouse
    Portals
    ...
]

05 janvier 2021:
* z-puzzle: piece original container image, exemple: (bulle de champagne(pièce) dans verre de champagne (container image))

06 janvier 2021:
* square graduation to ease "piece hunt" when trying to solve a z-puzzle
* z-scroll (minification): auto-attract to puzzle area

* "square caterpillar" growth animation on challenge completion ([1] piece was the "missing part")

07 janvier 2021:
** HP::HP fountain: to recover HP, player can solve repeatedly an "easy" challenge(each time with different "problem values") to get a small amount of HP back
  harder riddles may give a greater amount of HP back
** HP may determine how fast the player can zoomIn/zoomOut

*remark: fractal drawing seems very natural (as if we were predisposed to draw some (recursion is not brain-intensive, it is quite dumb actually))

*mouseDown z-scroll: follow cursor

https://cancerberosgx.github.io/demos/misc/fabricRectangleFreeDrawing.html?d=9

* shape recognition:
  https://stackoverflow.com/questions/10463158/fabric-js-implementing-shape-recognition-on-newly-created-paths
  this would require AI-trained library
    1. freeDraw a path
    2. shapeRecognitionLibrary.getShape(path)
    3. create fabricObject for recognized shape

**dehydration/rehydration of "non-passive" objects is to be done wisely (==reactive objects(like in a chemical reaction))  (for example: slots)
    couper les tentacules avant de congeler
    puis refaire des boutures de tentacules à la décongélation
  0 imagine if some "slow attraction" process was going on when saving: recover attraction process when loaded

**protoSlot: this objects waits for user to put piece in it
  a workflow:
    1. create obj
    2. create protoSlot
    3. drag obj in protoSlot => protoSlot mutates to slot
    4. select newly created slot
      5. (while slot is selected) keyP (for example) => slot creates piece
    6. piece can be moved around

**easy object: AmorousSquare ("pixel amoureux"): un pixel facile à vivre qui se vient se L-snapper à un autre AmorousSquare
    => on peut fabriquer facilement des polyominos
    => double L-snap, triple L-snap, quadruple L-snap: when piece L-snaps for different reasons at the same time
    AmorousSquare::padding: don't snap too close, leave a spacing between glued objects

**protoAmorousSlot: creates an AmourousSlot when an object is placed inside (amourousSlots can be useful when designing a puzzle)

* slot racing pour parler de l'abscisse curviligne

* find pieces to create triangle (segments [AB] [CD] [DE] etc.)

08 janvier 2021:
* l'unité de longueur d'un nombre c'est un nombre (le nombre 1)

* diamagnetic objects: cannot be snapped/attracted by snapslot (icObj.snappable == false)

* another slot/piece creation workflow: with a CreationManager
      1. create slot (it will be given id == 1 for example)   (creationManager.startSlotAndPiecesCreation(); creationManager.slot = slot;)
      2. create another object:
          if it's a piece                                     (creationManager.slot.allowed_pieces += piece;)
          if it's any other object:                           (creationManager.endSlotAndPiecesCreation(); (if slot has no associated piece: destroy slot))
      => this way we could associate "different pieces" (for example: [1],[2],[3]) to a same slot

* challenge creation: computed object's backing graph
    user creates slots (for example: "given", operators, "answer" or target)
    for each "computed" object, puzzle maker indicates via a graph how to compute value
    puzzle maker can then hide the backing graph so that player only sees challenge "facade" (on cache les tuyaux derrière un peu de placo)
* challenge creation: computed object's backing formula (way faster!)
    "= A1 + B2"

** match object's representations using freeDrawing: player links points using freeDrawing, then freeDrawing is replaced by "pretty line" when released
      there must be a freeDrawing zone (to avoid player doing crazy things)

**O-puzzle: Overlapping puzzle: slots overlap: some part of the piece is not useful, it must be overlapped by another piece for the whole to display something nice
    => this requires complex z-index mgmt
    => this requires "slot community" (first filled slot is "send to back", then next filled slot is put over etc.)
*   slot overlap has many different flavors: TL, TR, BL, BR, center, offsetXY
    difficulty::hard: slot can be filled multiple times
                      slot can be filled with pieces of different sizes
    example: with filling order
          ______________________
          | 2      |1          |
          |   6    |  5        |
          |        |           |
          ----------------------
          | 3      |  4        |
          |    9   |    7   8  |
          |________|___________|

edu: O-Puzzle "useless zones"(==zones that will be overlapped) could be used to carry texts in order to describe object parts
  edu: easy mode: add piece orderIndex in the useless zone
edu: O-Puzzle "useless zones" could be used to display what's behind facade
  example: anatomy

**edu: O-Puzzle: "put it in right order"    (un peu comme le jeu UNO, on empile quand on peut)
    examples:
      mathematical demonstration (in geometry for example)
*       we could use a slot for the main demonstration flow and satellite slots for the lemmas used in the main flow
      geometrical construction
*       edu: feedback: add tick when the right piece has been placed (like in a todo list)
      logical sequence: cover [A->B] with [B->C] etc.
        colors and numbers (un peu comme le jeu UNO mais en mode "dominos" (il faut utiliser tous les dominos))
        dobble (sets are related by one common element)
*   on est d'accord que le mieux c'est quand l'élève part de rien et doit tout fabriquer lui-même, ici c'est un peu de la réflexion discount
**  edu: add "unfitting" pieces(==dead-end pieces) (to prevent student from bruteforcing): there are many more pieces than actually needed
      some pieces may seem fitting at first glance but then appear to be dead-ends

*O-puzzle:easy creation workflow (for a single-slot O-puzzle):
  1. maker creates protoOPuzzleSlot
  2. maker puts _in the correct order_ the different pieces they want to use
  3. maker clicks on "Done"
  4. protoOPuzzleSlot automagically paints useless zones for each piece with garbage by comparing the different pieces
  5. maker can get the painted pieces from the filled protoOPuzzleSlot and put them wherever they want

*challenge: trouve l'intrus

*challenge: lis l'algorithme de déplacement et sélectionne le point d'arrivée, ensuite appuie sur "play"
*tool: le répartiteur: user creates a partition of a 100% box and can then drag any collection or number that will be divided into different output boxes with the right proportions

*<X>-puzzle::double puzzle: pieces are linked together so when solving puzzleA, it solves puzzleB  (first puzzle could be mathematical and the other puzzle could be an image)
      and only puzzleA pieces can be selected and moved

* coins: player earns coins
    easy exercises give fewer coins than hard exercises
    player can then buy:
      hints
      keys
    say the game is playable from kindergarten to high-school,
      in kindergarten,  player will earn 1 or 2 coins
      in comprehensive, player will earn 100-999 coins
      in highschool,    player will earn 1000-9999 coins per challenge
      (player would keep the coins they have earned the previous year, keep the places they discovered, keep the challenge they completed, and also those they have not completed yet, so they can always complete them later on)

* snap objects that don't have homeScale (example: lines) => "sizeless snap"
  => sizelessSnapSlot

* createLine: rep_proto ("proto representation")

( notre point de départ ça pourrait être un solide avec un volume, parce que c'est le seul objet mathématique "qui existe vraiment"

* AmorousSegment: once pointA is snapped, pointB can be moved around in the radius circle

* on pourrait refaire une interface plus rapide pour les chiffres dans "les chiffres et les lettres" basée sur green mouse
    (dans le fond, l'esprit de l'idée de départ de green mouse c'était très proche de ça)

* greenMouse: priorités opératoires:
    we don't care about the result value:
      - answer slot is filled with full expression
      - green mouse shows growing full expression
    we do care about the result value:
      alternate display: number result / full expression

    easy:
      - only result value
      - only full expression
    medium: alternate display: number result / full expression
    hard: answer and greenMouse have different representations (one is result value and one is full expression)
    harder: answer is full expression but player cannot mimic full expression with the available vial operators: player has to match two different, _yet equivalent_, full expressions

* greenMouse: function related vials:
    derivative
    primitive
    composition with another function

09 janvier 2021:
** challenge: "show me X", "show me the thing with property Y"
*edu: Langues: repère les fautes dans ce texte
*edu: Géographie: repère les pays/capitales sur cette carte
*edu: Maths: montre moi un exemplaire ayant tel type (montre moi un triangle, montre moi une équation, montre moi une inégalité, montre moi un théorème, etc.)
*edu: construction de preuve pas à pas :
  - l'élève clique sur ce qu'il estime être l'endroit concerné par la prochaine étape de la démonstration
  - l'élève a accès à une liste de théorèmes sur lesquels il peut cliquer
  exemple:
    1. l'élève sélectionne un triangle rectangle
    2. l'élève sélection le théorème de Pythagore
    3. l'identité de Pythagore associé au triangle selectionné apparaît (_en tant que nouvel objet_ dans le canvas)

** challenge: "show me X in field (normal/mini/micro field)"
      un peu comme pour les souris vertes, on demande à l'élève de répondre rapidement
      ici il faut cliquer sur l'objet associé à la question posée
      il peut y avoir plusieurs réponses valides possibles
      Le petit twist:
        - les objets "petits" (voire minuscules) vont être assez longs à atteindre.       Les objets petits sont les réponses  "évidentes".
        - les objets de taille normale vont être accessibles pratiquement instantanément. Les objets normaux sont les réponses "pas évidentes".
      Donc:
        easy:   player has enough time to pick a small object (the small, "obvious", object)
        normal: player may have enough time to pick a small object but it requires dexterity
        hard:   player does not have enough time to pick a small object, player has to think and select valid normal object
      exemple:
        La consigne c'est [1] (==sélectionne le nombre 1).
        Dans le champ de réponses possibles,
          il y aura un [1] tout petit,
          il y aura un [2 - 1] un peu plus gros.
          il y aura un [(5 - 1)/4] encore un peu plus gros.
          etc.
      optionnel:
        Avant que l'exercice ne commence (== avant que le timer se déclenche),
        l'élève peut se balader dans le champ de réponses pour se familiariser.

**wow-effect: present stuff and use game objects during presentations, since they are just right here
*edu: j'ai envie de sortir le glisse-nombre, je le sors, même pendant ma présentation de cours
      (j'en ai besoin là maintenant, eh bien, je ne change même pas de fenêtre, je ne perds pas de temps à aller le chercher dans mes dossiers, je l'ai là, je l'ai toujours eu là, sous la main, prêt)
      => besoin de plein de raccourcis clavier
*edu: j'ai envie de sortir un exercice/jeu, je le sors

**générateurs d'exercices: ne pas réinventer la roue (au moins au début)
    0 est-ce que pyromaths est open-source ?

*challenge: place le glisse nombre au bon endroit: "le xylophone est cassé: il donne des nombres sans mettre la virgule"
*challenge: place la virgule       au bon endroit
*challenge: réparation: aide nous à remettre au bon endroit la virgule sur le xylophone

(ni tout à fait vectoriel, ni tout à fait raster, un entre-deux

* slot "endoConfig" (if you get close enough, you will see the cogs and gears) ("horlogerie")

* opacity setting same as color => "KeyV"

* l'encre invisible ! write stuff with opacity 0.0
* opacity blend: add vs fusion

* 0 acheter le nom de domaine teachingbeforedying

* protoSparkle

10 janvier 2021:
* serialize useof interactive module: module will be loaded on deserialization
    example:
      modules: {
        xylophone: {
          type: "xylophone",
          exponent_min:
          exponent_max:
        },
      }

*sparkle emitter:
  phare
  feu de camp
  candle
  lightbulb
  luciole

* reversed Z-puzzle: remettre les objets à leur taille originale

11 janvier 2021:
*greenMouse: path graph: étant donné un nombre de départ et des opérateurs,
    - il y a des nombres faciles    à atteindre (==en peu      d'étapes)
    - il y a des nombres difficiles à atteindre (==en beaucoup d'étapes)
*(greenMouse: NIM game: à chaque fois que l'on utilise un opérateur, il disparaît, l'idée est de ne pas faire le dernier mouvement  (idée encore un peu floue)

0 fabriquer une présentation de cours avec infiniteCanvas

**machine: l'agrandisseur: (basé sur le théorème de Thalès)
    on a un angle donné, par exemple 35°
    il y a un slot dans lequel on met l'objet d'entrée
    on peut ensuite faire glisser l'objet pour l'agrandir/rétrécir à l'envi
    l'objet de départ est montré et le facteur d'agrandissement aussi

*( un pulse électrique dans le bouton de souris pour faire en sorte que l'utilisateur arrête de garder le bouton appuyé quand ce n'est plus nécessaire

* protoWell
* greenMouseWell/protoGreenMouseWell

* touchSlot: user-scripted touchSlot
* protoTouchSlot:
    - facade
    - transformation script

* scriptHolder (généralisation de touchSlot) et scriptHolder.triggeringEvent voire triggeringFunc (séquence complexe d'évènements)

* greenMouse: pour le fun: faire un exemple avec la souris verte, l'huile, l'eau, et l'escargot tout chaud
** greenMouse: pathHintTouchSlot: full: toucher cet objet donne un chemin à suivre pour arriver au résultat cible
** greenMouse: pathHintTouchSlot: next: toucher cet objet donne le prochain noeud  pour arriver au résultat cible

***dynamic object::network-fetched: "tout le web dans un seul canvas" / "infiniteBrowser"
    cela demande une autre façon de coder les sites web, mais si tout le monde s'y met, ça peut être sympa
0 add network-fetched image-of-the-day to infiniteCanvas

***Z-scroll railway(==z-railway): from beginning of course to end of course
    user can select the z-railway and then, when user would scroll, they would follow z-railway's path (le prof n'a qu'à rouler la souris pour dérouler son cours)

*pathSparkle: multiple phase-shifted similar sparkles (probably better with opacity != 1) (comme si on voyait d'en haut les balles d'un jongleur)

*touchSlot: explain mutation: [1][+2][=][3]    while greenMouse is "in" touchSlot, objects appear on the sides of touchSlot to explain mutation
                               ^  ^      ^
                               |  |      |______  mutated value  (== a preview of the greenMouse when it will leave touchSlot) (==rep_touched)
    original value    _________|  |
                                  |_______ touchSlot

    this is mainly dedicated to edu purposes
*edu: show steps around variable: accessor(get) == get value out of the box, compute expression == do stuff with value, mutator(set) == put new value in the box
    gros travail d'animation

*touch-based number shoot'em'up: player starts with 1 and tries to get the biggest value possible by touching powerups (x2, x(-4) (which may be a risky strategy), +10, etc.)
    we could imagine 'sector gates' that only numbers above(/below) threshold could get through

12 janvier 2021:
* greenMouse::competitive:
    beat(==finish before) computer
    beat other player

* greenMouse: conjugaison
* greenMouse: Pythagore
    il faut trouver un moyen _fluide_ de suivre le procédé qui amène à sqrt(a²+b²)

("Sans titre" aurait été tout à fait satisfaisant pour le PCI

*(
  a well is like a reverse snapSlot
		1. on hold, create new represented
		2. on release:
		 	if out of well's recapture area, disable recapture
			if inside well's recapture area, recapture object: destroy represented
  OR
  a well is a self-refilling initially-filled snapSlot (but this requires redefining the behavior of a greenMouse (greenMouse can continue living if it was never held))
    => composite object: snapSlot + sample#000
  OR
  a well is an object refusing to move (because snapped), cloning itself instead of moving, and a "blackhole" snapSlot (destroying whatever it snaps)
*)

** touchSlot: dual touch/multi touch: a dual transformation func is triggered only when two touchSlots are touched simultaneously

**"are these operators or numbers ?": a touchSlot, if prepared with "touchable = true", can then be touched, thus mutated (this way a -1 operator can become a -2 operator, when touching a x2 operator)
  edu: this way we can blur the boundaries between "operator -1" and "number -1"

**challenge: Indiana's path: to get to target slot, greenMouse has to cross a grid of touchSlots, so player has to find the right path (we can imagine complex looping paths)
* challenge(hardcore): Indiana's room: player has to fill 4 target slots. Once a target slot has been filled, player comes back from start and previously used touchSlots are neutralized (là on est dans le casse-tête)

*challenge:goulet: there are two "operation wards" and between the two, the only passage is a [x(-1)] operator: user has to anticipate before changing room
  targetSlot is only reachable from operationWard2

*edu: greenMouse operator spam:
  - spammer le +1 ne donne pas grand chose d'intéressant
  - spammer le x2    donne quelquechose d'intéressant (pour le cours sur les puissances)

*activationPool: touchSlot.canActivate is conditionned by activationPool.nbRemainingActivations (collective behavior)

*edu: easyStar/mediumStar/hardStar: check if student only has easyStars: it would be nice if student could, at least in one domain, get a hardStar
  (que l'élève ait une compétence avancée dans au moins un domaine)
  (pour qu'on puisse ensuite s'en servir comme d'un marche pied pour avancer dans les autres domaines)

*maker:easy: referringTo: comme pour la couleur, ou l'opacité, on aurait une zone un peu comme un select, qui indiquerait ce à quoi on se réfère en ce moment
  exemple: je veux créer un snapSlot qui snappe uniquement les icTexts, eh bien, si j'ai comme reférence "icText", alors quand je créerais mon snapSlot, il sera automatiquement configuré pour ne s'intéresser qu'aux icTexts

*greenMouse::litteral operators: [+x], [-y], [*z], [^k]
  easy:   autoReduce full expression
  medium: autoReduce current expression layer
  hard:   don't autoReduce

*greenMouse::fractions:
  easy:   autoSimplify full
  medium: autoSimplify current layer
  hard:   don't autoSimplify

*greenMouse: time extended/small heal: when greenMouse is soaked, it adds a bit of time/HP to the greenMouse
    we can represented the countDown by slowly removing HP from the greenMouse

*challenge: GTA: objectHolder is a car and player can accelerate/brake/turnleft/turnright
  c'est toujours la même soupe mais là on controle une petite voiture

*greenMouse: is a transient variable: say only greenMouse.value is transferred to target slot, then greenMouse is a transient variable (it does not outlive oneself)

* variableWell (==geminiWell): mutations are shared by all representations (there is only one object)
* challenge: 2 areas, 1 variable: each area is exclusive (one cannot go from one to the other), variable is present in each area and can be mutated in either

**greenMouse::vectors: vector greenMouse, vector operators, vector target
*   edu: show vector arrow (for 2D numerical vector)

*greenMouse::collection: collection greenMouse, collection operators (map, filter, reduce), collection or anyType target

* challenge: composite object

* a composite is not a group (a composite has only 1 level of nesting, a composite does not have intrinsic position, size or homeScale): compose() flattens all objects (though it does not break inner groups)
    0 moving one part:
      0 makes all parts move 					(== "fixing")
      0 does not make all parts move  (== "mobile")  (example: well's sample)
    (0 move individual part: rearrange composite

* selection transformations:
    - compose
    - wellify
    - greenMouseWellify

*composite object: protractor (rapporteur d'angle): les aiguilles sont les parties "mobile" et le centre  est "fixing"
  => mobile parts movement is constrained
*composite object: oriented-angle protractor
*composite object: editable segment: les deux points d'extremité  sont les parties "mobile" et le segment est "fixing"
*composite object: clock

***permanent challenge: clean the world: litter regularly spawns in the infiniteCanvas. Player would better put it it the bins, or else there will be litter everywhere.
      the more litter there is, the more litter there will spawn.
***permanent challenge: upkeep: everything slowly withers, if not "refreshed".

**composite object: "[+1] [-1]", when a [+1] touches a [-1], they cancel each other and object vanishes

*snapSlot::gravity-based: player can create satellites by giving the right release impulse

*challenge: "click on point with coordinates (< >;< >)", animation: an archer shoots an arrow to the point picked by user, if user point is close enough to target, then that's fine...

13 janvier 2021:
*greenMouse: parentheses
  plusieurs mises en oeuvre possibles:
  - two areas: switching area starts new parentheses expression
    - central parentheses operator: [()]
    - central parentheses related operators: [()+()][()-()][()x()][()/()][()^()]
    - central parentheses related operators: start new expression with initial value: [+0][-0][x1][/1][^1]
  - one area and parentheses operators on top, "standard" operators at bottom

*redMouse calculator: un outil pour calculer des nombres rapidement
  (a good parentheses ux is required)
*challenge: écris la rédaction correcte en assemblant les blocs (à la Scratch)
    some blocks would have slots to fill with redMouse calculator's output
    as in Scratch: slots/blocks should resize when inserting big piece (a long number piece for example)

*greenMouse::logical expressions (sûrement pas mal de choses à gratter de ce côté là)

*xylophone calculator(juste une autre proposition d'UI pour la calculatrice): user can pick number on xylophone

*edu: ce qui est bien avec l'idée initiale de greenMouse, c'est qu'on affiche jamais une expression incomplète à l'écran

*la désillusion: dans le fond, rien d'innovant: Scratch possède des snapSlots, Scratch possède des wells, Scratch montre des exemples de L-snapping, de composites, d'object bin,

*greenMouse: undo operator (merci Willy) (et redo aussi pourquoi pas)
*greenMouse:operator preview: show preview of operator's application
*greenMouse: guess the operator

14 janvier 2021:
**greenMouse: is equality
**greenMouse: is inequality

***greenMouse::equations: rejoue les étapes à l'envers pour éfeuiller l'expression

*greenMouse:complex operator: example: [x2+1]
**operator mutation: tu voulais [x20] ? eh bien, tu prends [x2] et tu lui fais toucher [x10]
**greenMouse:reset button (put operators back to their initial value)
*greenMouse: we may reset operators on greenMouse release (if operators mutate during the "greenMouse journey" (==greenMouse transformation process))

**opérateur de conversion: exemple: [croissant <-> argent]

*edu: greenMouse on Scratch pour faire comprendre le principe un peu plus en détail

**greenMouse: parentheses operator: une autre proposition: [)x(1] [)+(0]
*greenMouse::complex numbers [+i] [xe^(i theta)]

15 janvier 2021:
*greenMouse::eval operator:
  example: operator: [eval({x = 3; y = 5;})], so when [2y] will touch it will transforms into [10]
  this could produce partial evaluations

**greenMouse::strings: string variable, string operators, string target
    - capitalize
    - remove first/last letter
    - insert letter at index
    - concatenate
    - randomString with format

**greenMouse: number dump: the whole greenMouse area is actually a dumpingSlot, so when number is dropped, its value could be:
    - auto added
    - auto multiplied
    - etc.
    to the dumpingSlot current value

**greenMouse: target is ...<[ ]<...
    edu: -2 * 10^-3 <[    ]< -10^-3
**greenMouse: variable has to match target's condition
    - inequality
    - complex condition: {{number must be odd}    and     {over  9000}     and     {its last digit must be 6}}
    etc.

icObj.cType = "<>" may actually be replaced by:
  gmObj.icObj.type = "composite"
  gmObj.type = "<>"

((*
""système des boules noires et blanches choisies par le jury"":
    on peut faire un système de note probabiliste:
      chaque membre d'un jury(très nombreux) remplit un sac avec la note qu'il attribue au candidat
      le candidat tire une note au hasard dans le sac et c'est sa note définitive
))*

*edu: greenMouse: "last operation should be a multiplication" (pour forcer l'utilisation des fractions)
***greenMouse: "value path" conditions:
    "last operation should be a multiplication"
    "third operation must be a substraction"
    "reach target in max 5 operations"
    "reach target in exactly 5 operations"
    "reach target without exceeding 100 at any step"
    "reach target without getting 42 as a step result"
    => targetSlot checks value but may also check "value path" (==the value "fabrication process")

((le problème avec la forme: quelqu'un respecte la forme, mais c'est une belle coquille vide.

*edu: greenMouse: commencer léger
      child:   nb_operators: 1-2
      pupil:   nb_operators: 3-4
      student: nb_operators: any

***greenMouse: écrire une phrase sans fautes
  operators are renewed for next word
  il y en a avec des fautes et d'autres sans
  when touching a "mistake" operator: everything resets: back to the start

**greenMouse:show greenMouse path building:
    greenMouse: writing: montrer la phrase en train de se créer
    greenMouse: numbers: montrer l'expression en train de se créer

(""visionnement d’une vidéo montrant un épisode du jeu"": WOW
**redMouse:Mario et les champignons

*edu: show/hide value tag of redMouse

((est-ce qu'il est légitime de montrer des figures avec des longueurs de côté qui ne sont pas reflétées par le dessin ?

*webpage should be lightweight for "bad connection" users
*webpage shouldn't involve two much CPU/RAM usage for "bad computer" users

*greenMouse: build a tree: leafs and nodes
    1.it starts with a leaf ([1] for example)
*   2.then you select a node operator ([+] for example), you get [1]---[+]---[?]
    3.you have to fill empty leaf space with a leaf, you select a leaf operator ([2] for example), you get [1]---[+]---[2]
    4.then you select a node operator, etc.

*greenMouse: number textual form: [un]*[+2] va donner [trois]  (* == touches)
*greenMouse: observe the decimal system "in deeds" using operators: [+1] [+10] [+100] [+1000]

16 janvier 2021:
*greenMouse: target slot is riddled:
    exemple:   1234
            + [    ]
            ________
               7894

*union libre: composite([piece,slot])  (ça donne un petit côté gemini, "si tu me tues, l'autre mourra aussi")
*try composite([compositeA, compositeB]): regarder si on peut faire des trucs subtils avec isMobile (qui est en fait isMobileWrtMyComposite)

*Z-railway: from slot to piece
*Z-railway: dot wave: a wave from src to dst is formed by static dots getting bigger, getting smaller

*machine::clone:[inputSlot][temporaryWell]
*greenMouse: cloneMachinesEverywhere: well could be replaced by a cloneMachine to give the player the ability to choose the initial value
  edu: par exemple: l'élève peut prendre son numéro fétiche      pour faire le challenge (un petit côté "choose your character")
  edu: par exemple: l'élève peut prendre ses opérateurs préférés pour faire le challenge (un petit côté "choose your weapons")

*greenMouse: round()/trunc() operators

**multimouse(many mouses in classRoom) is compatible with greenMouse
**multimouse(many mouses in classRoom) is compatible with zPuzzle

*madness: 4 player split-screen greenMouse

**dev:MAKE IT F-ING SEXY (sinon personne va y jouer, ou alors 5 min et c'est tout)
    - rounded corners
    - animations (regarder ce que font les jeux genre Candy Crush etc.)

*challenge: contrôle qualité: le joueur doit dire si la pièce doit être mise au rebut ou pas en mesurant (on peut imaginer une machine qui produit des pièces)
    des longueurs
    des angles
    des couleurs
    etc.

*greenMouse: boiling operator: il faut attendre un peu de temps sur l'opérateur avant qu'il ne s'active (on s'écarte un peu de la "philosophie greenMouse")

*challenge: "dirty glasses"-puzzle: the "key" to solving puzzle is to use piece in HUD-layer, so the puzzle is completed when all others pieces have a correct relative position
***greenMouse: invisibleMouse: at some point, greenMouse is invisible, so player has to run the operations mentally
    edu: we could replace the invisibleness by a question mark symbol: [?]

*challenge: Pythagore et Thalès: une petite cuisine de nombres: length tags are redMouse wells so player can use them directly to create expressions

*easy clone: keyDownTrigger("<Key>") + hold object (en gros: keyDown + mouseDown + move)

17 Janvier 2021:
*z-well:   grow number via z-scrolling
*timeWell: grow number via waiting

*ui:numbers::colors:
  -each "broad" operation (+/-==+) is given a color:
    example:
      +: yellow
      x: cyan
  -each operation neutral number is given a color: the color for neutral
    example: [+0] could be yellow with a neutral color border

*challenge: single-operator challenge: since there is only one operation involved, numbers and operators can be considered the same thing
  in this case:
    [+] operation: [1]*[-1] = [-1]*[1] = [0]
    [x] operation: [2]*[1/2]=[1/2]*[2] = [1]
  operation symbol (and color) could be the background pattern of the challenge area (==operator as wallpaper)

*challenge mutator::now it's black and white: player is driven to reading the symbol instead of reading the color

***icObj.type = "emitter":
  - the information propagation could extremely slowed to be visually represented using a growing circle
  - the information attenuation could be visually represented with a fading effect

  edu: this way: player can visualize the cause of:
    - "negative events":
      - challenge reset (for example: the countDownTrigger triggers the resetEmitter, whose wave resets challenge)
    - "positive events":
      - challenge completion (for example: the completionTrigger triggers the completionEmitter, whose wave opens the star box/gives a key/etc.)

**E-Puzzle: emitter-based puzzle (==information propagation puzzle)

*challenge twist: touching countdown with number n adds/substracts n seconds, and number is to cross countdown (center area is narrowed not to leave any other possibility)
  (un peu une idée farfelue, mais les joueurs attendent des mécaniques farfelues)

*dev: live-shared document would be nice for brainstorming and creating exercices

*greenMouse: A*cos(w*t+phi): [0,2Pi]
*drop system: because life is also luck: when completing a challege, there may be "dropped" objects. dropped objects could be:
    numbers
    letters
    operators
    images
    quotations
    etc.

(*en fait, on parle jamais de contexte, d'espace de noms, quand on fait des maths avec des lettres mais on devrait peut-être. Je pense à l'élève qui a utilisé x = 7 dans l'exo1 et qui voit maintenant que x=-12 dans l'exo2, et qui comprend pas pourquoi il a changé.

subtract vs substract: substract is now obsolete

*tex and svg: icObj.type = "svg": double click to edit: show texCode, on stopEditing: show svg
mathematical expression <--> tex --> svg

(*résoudre une équation du premier degré, c'est de l'effeuillage.
  edu: exemple: Je note sur une feuille un mot. Je mets un scotch noir dessus. Je plie la feuille. Je la mets dans une enveloppe.
                effeuillage: ouvrir l'enveloppe, déplier la feuille, enlever le scotch.

*infiniteCanvas: classroom representation: put photographs of students
  ==> easy mgmt: click on student's photo

** https://numfocus.org/sponsored-projects

18 janvier 2021:
*greenMouse: tool: build expression from greenMousePath
*greenMouse: tool: build program from greenMousePath ((tu peux recoder une sorte de Scratch si tu veux mais pas maintenant))

*greenMouse: snapSlot in TeX expression: du gros dev en perspective

19 janvier:
* tex --> math
  0 Uncaught TypeError: algebra.fromTex is not a function
  Le travail a probablement déjà était fait, il faut juste le retrouver

* subtle work to adjust expression container size in order:
    - to fully contain expression
    - for expression to be readable (== 'big enough')
    - never to surprise user (size changes must be visually 'acceptable')
  OR
  we can animate expression's size adjustment: it slowly moves to target 'nice' size
  OR
  "touchable part" keeps the same size and "display part" continues growing
  OR
  we create composite: [E][=][(1+5+y)x2]
    and touchable part is [E], while growing part is right-hand side

*greenMouse: polynomials: show function graph/function shape next to expression (this way we see the 'waving effect' (== more and more roots as degree increases))

* icObj.type = "computed" (== icObj.type = "view"), createIcComputed(icObj,transformationFunc)

***z-Scroll:: 'scale defying' object: zTraveler: comme un sparkle, mais il ne clignote pas
      zTraveler gets as close as possible to infiniteCanvas.scale
      zTraveler may move along a z-railway

      edu: at level1: we see all operators, at level2 we can focus on each
        when we zoom in on a particular operator, we see that it seems to shrink, moving to its homeZone
        the operator's homeZone hosts a more specific challenge
      edu: "c'est le même opérateur"

*greenMouse: show all identities along greenMousePath: 1 + 2 = 3 ; 3 x 2 = 6; 6 x (-1) = -6 ; ...

*greenMouse::mathematical statements: sujet verbe complément subordonnée et grand-mère sur la commode
(* mathematical verbs: =, !=,  <, <=>, =>,

*greenMouse: evaluate expression:
    1. put expression in protoWell: [2x] --> [[2x]]
    2. use clones to evaluate:
          [2x] * [eval({x = 2}]  --> [4]
          [2x] * [eval({x = 10}] --> [20]
    (3. destroy protoWell to get original expression back

(* multiplier _une équation_ par 2 , c'est un peu comme mettre une phrase au pluriel.

*greenMouse: priorités opératoires: effeuillage: à chaque étape, proproser comme opérateurs les opérateurs qui constituent le chemin standard
    exemple: on demande de récupérer _le_ 8 dans l'expression (8 + 7 x 6)/50 - 1,
             pour [(8 + 7 x 6)/50 - 1]
                proposer
                  [+1]
                  [x50]
                  [-(7x6)]
                  (pourquoi pas [/6])
             ensuite pour pour [(8 + 7 x 6)/50]
                proposer
                  [x50]
                  [-(7x6)]
                  (pourquoi pas [/50])

((quand la souris accouche d'une montagne

* edu: two almost identical wells:
    a well yielding "autoSimplify:on"  nodes
    a well yielding "autoSimplify:off" nodes
    so when the student follows a greenMousePath, they will either see the "growing" _result_ or the "growing" _expression_

** edu: expression simplifies:
    - every n steps
    - at random time
    - only after student has earned the simplify skill
    - when touching _a_ simplify operator
* il y a des simplify spéciaux, par exemple quand on veut transformer (-1)x(-1) en (-1)^2 pour montrer l'exposant de (-1)

*edu: écris deux expressions égales, différentes dans leur écriture

**sparkle firework: to celebrate a challenge completion

*events:
  - circle propagation ("radio propagation")
  - wire propagation (we see the event moving along a wire)

*keep it local: icScope.icObjects = {}, pour:
  - éviter de scanner le monde entier quand on est un trigger      d'un challenge
  - éviter de spammer le monde entier quand on est un eventEmitter d'un challenge
  => là, c'est la notion de $scope qui intervient (tout existe déjà)

**composite mimic: from real-life object to mathematical model
    example: moving clock hands is "reactively" mimic'd in triangle

20 janvier 2021:
*greenMouse::invisibleMouse: question mark changes color and font when touched (touch feedback)
  edu: when greenMouse value is something x 10^30 and touches [+10], the value doesn't seem to change and yet there must be a feedback that touch happened
    (j'ai jeté une goutte d'eau dans l'océan et personne n'a remarqué).

**step by step simplification after node.evaluate("x = 3")
  => 0 "atomicSimplify" operator
  edu: l'idée par exemple, c'est un peu comme une montagne:
    on part de x,                         (pied de la montagne)
    on complexifie pas à pas l'expression (on monte)
    on fait l'évaluation                  (sommet)
    on simplifie pas à pas l'expression   (on redescend)
    on a le résultat                      (pied de la montagne)

* add a pool next to icObserver to put triggers in (or composites with triggers)

* icObj="challenge"
* icObj="challenge_generator"

**switch expression representation:
    - reduced form
    - tree
        show tree depth to get an idea of the complexity of the expression
    - "historical", unreduced form

**(*)redMouse::graph editing:
    0. there exists an empty node [empty] which can be used as an initial node
    1. user creates an operatorNode  [empty]---[+]---[empty] by touching the [+] gmOperator
    2. -THIS IS THE INTERESTING PART-  user can fill the empty nodes by
      a. selecting the empty node with the mouse and dragging it (the whole graph moves but the rest is "numb")
      b. touching a gmOperator (be it a common operator or a "valueOperator" like [1] or [2] for example)
    this can be extended to "non-math" graphs
*   increase operator arity: say the operator [+] has been touched and we have [ ]---[+]---[ ] then if we touch [+] operator again _with the [+] node_, we get:
       |---[ ]
[ ]---[+]---[ ]
    or even simpler:         say the operator [+] has been touched and we have [ ]---[+]---[ ] then if we touch a valueOperator (for example [1]) _with the [+] node_, we get:
       |---[1]
[ ]---[+]---[ ]
*   build tree: say the operator [+] has been touched and we have [ ]---[+]---[ ] then if we touch [+] operator again _with the left node_, we get:
[ ]---[+]---[ ]
       |---[+]---[ ]
**  mathNode graph: show partial result next to each operatorNode

(* en fait, les opérateurs [+2] [x(-1)] etc., sont des opérateurs unaires, qui sont en fait des currying d'opérateurs binaires. Grâce à eux, on construit l'arbre de calcul de façon séquentielle, sans "revenir en arrière".

*rect fusion: we a rect touches another rect, they fusion so that the new rect area is the sum of the two rects' areas

*ux: easy graph creation: draw a line between two objects and it creates the graph composite with the two objects as node and a link between them
    - draw a line   between the two to created an unoriented graph
    - draw an arrow between the two to created an oriented graph
    - draw the reverse direction arrow over an existing link to mutate the link to a bidirectional link

* colored value/ colored operator: operator only operates on a node with the same color
    - color assignment operator (==color change operator)

*greenMouse: target format is unsimplified expression: player does not have enough time, or does not have the operators allowing them to perfectly reproduce the target expression, they have to decode target expression and produce an equivalent expression

21 janvier 2021:

*challenge:greenMouse with only one "valueOperator": "the 4 fours", "3 nines" (refaire les premiers nombres avec des expressions contenant toujours le même chiffre)
*greenMouse: "Démonstrations folles":
  statementNode: "Je fais du sport" ou "<X> fait du sport"
  property operator: "Si je fais du sport, je transpire."
  exemple:
    Si on trempe "<X> fait du sport" dans "Si je fais du sport, alors je transpire", on obtient "<X> transpire".

*challenge::"edu countdown": countdown has a pause button near it, but, if pressed, challenge reward can't be earned
  - this way player can train
  - this way player understands that "the true thing" does not allow pausing

***greenMouse::living greenMouse: greenMouse' value updates even when there no user action: examples: countdown-greenMouse, radioactive-greenMouse, etc.
    countdown-greenMouse:
      -standard: every second, greenMouse value is removed 1
      -exponential: every 3 seconds, greenMouse value is multiplied by 10
      -random mutation: every n seconds, greenMouse value is transformed via a random operation
    countup-greenMouse: every second, greenMouse value is added 1.
    radioactive-greenMouse: after a random duration, and based on a probability density, greenMouse is mutated
    edu: this would provoke player into keeping the situation under control, into containing the living 'dragon blob' mouse
    edu: il faut vraiment trouver un moyen de rendre les mutations de vie visuellement différentes des mutations d'opération, pour pas que les élèves pensent que les nombres s'amusent à changer comme ça leur chante

**challenge:greenMouse:"get more than N": greenMouse value must get over target value during given time (snapping at the end is not necessary)
    -variant: countup-greenMouse: greenMouse slowly counts up, but too slowly to get over target value in time, so this plusOneing value must be operated on

(*icObj apoptosis: say there is a network of very small touchslots which send a 'continue living' signal, then, when an object is smaller than those touchslots, it will die from not having been maintained

*greenMouse: countdown timer is number too: player can use it to complete a challenge
    edu: think "out the box"

*digitWell: turn each digit of a number into a well (exemple: de 7891, on pourra extraire [7] [8] [9] et [1])
*operator: extract digits:
    edu: a way to create a collection from a single element
*machine: digitsExtractor

22 janvier 2021:
((comment ils font pour congeler du vivant dans les entreprises du jeu vidéo ? Est-ce qu'il y a une good practice ?
**  => copy paste "living object" between two applications

((en fait, en informatique, on a longtemps travaillé avec des morceaux de bois sans vie, et maintenant on commence à jouer avec des poulpes, à les faire travailler à notre place
((I think it's important, at the time being, (and, at last, to understand the lisp spirit) to consider that user written code is as important as user written "content". Data is code is data, period.

composite only needs a handle when solely composed of mobile parts

**maker/consumer: teacher creates exercise and, on the fly, students can try to complete it
  => this would allow a lot of reactivity and a lot of ^flicage^ (éducamération)
  après, tant que le flicage reste éphémère: un flicage de session, juste pour la séance...

*challenge:code chiffre-son: trouve le bon mot


* everything already exists: https://toytheater.com/category/teacher-tools/virtual-manipulatives/
  tout le concept de greenMouse est déjà là: https://toytheater.com/fraction-strips/ (lolilol, gardons le sourire, chacun sa pierre)
  (ça serait bien pour l'image de la France d'avoir une plateforme française dans ce genre là

(* composite(composite1, composite2): une vision du management hierarchique (pouvoir sacré)
*	0 fun: allow chosen non-top-level objects to be part of composite: create "funny dependencies behavior" objects
  edu: par exemple: si on bouge un nombre alors tous ses multiples bougent avec lui
    mais ça veut dire que le handle du composite est l'objet lui-même (... vive la récursion)

*edu: un scroller horizontal basique qui contrôle
  - la "zPosition" d'un zTraveler pour que l'élève arrive à l'idée de fonction
  - la taille d'un carré ou d'un rectangle ou d'un triangle
  => on peut fabriquer des machines configurables avec la valeur du scroller horizontal comme deuxième variable d'entrée

**summonSlot:
    1. user writes the name of the thing they'd like to summon,
    2. then when activating slot (press E),
    3. the infiniteCanvas checks if there is a summonable object with this name, and summons it if something was found
    example:
      1. user creates summonSlot
      2. user writes "challenge.greenMouse.numberOne" in summonSlot
      3. user can summon challenge.greenMouse.numberOne when activating the slot
    the summoned object can be easily deleted via a delete button near the object

23 janvier 2021:

**maker: composite(composite1, composite2) allows 'easy' animations (== easy creation of keyFrames)
    this would be even nicer if composites are graphs (i.e. composites with links) and if nodes and links are images

**greenMouse::shortest-path: get to targetValue in less than <n> steps (exponential may play a key role)
    easy:    20 steps
    medium:  10 steps
    hard:    6 steps

*maker: z-Index: keyDownToggle:
            -show z-indexes
            -if something is selected: mouseScroll will control z-index
            -if nothing selected:      mouseScroll will 'pierce' (voire 'peerce')

*maker: align
  - horizontally / vertically / diagonally / anyAngley
  - top/center/bottom

24 janvier 2021:
*challenge:greenMouse VS zIndex: greenMouse value is greenMouse zIndex: greenMouse must go above[50], go below[-20] (un peu un parcours du combattant)

**touchSlot::magicBox: touch only triggers when target is completely hidden behind touch slot

*spawn sequence(==egg-laying):
  - keyDown: if you stay pressed, a spawn will occur every <intervalDuration>
  - engine-based: when engine is started, sequence spawn will occur (no other user input is needed)
  keyDownCharge: you have to stay pressed the whole time
    0 chargeIndicator

*greenMouse:little squares:
    - [x2] operator adds the same arrangement next to the initial arrangement
      example:
        [][]                 [][][][]
        []    * [x2] gives:  []  []
        []                   []  []
    - squarify operator:  create closest-to-square    arrangement of little squares
      example:
        [][]                       [][]
        []    * [squarify] gives:  [][]
        []
    - rectangle operator: create closest-to-rectangle arrangement of little squares

    -divide/fraction happens in two steps:
      - prepare for divide: user has to use operators to arrange the little squares for the division to be obvious
      - divide prepared arrangement: since the arrangement has been prepared, division is obvious (== not surprising)

*gmOperator mutation:
 	Plusieurs choix se présentent:
 	- valueOperator3(value) = valueOperator2(valueOperator1(value))         (standard composition)
  [x2] * [+10] = [x2+10]
 	- valueOperator3 = (operatorOperatorify(valueOperator2))(valueOperator1) = OperatorOperator2(valueOperator1) (there is no typo here, operatorOperator means an operator which applies to operators)
  [x2] * [+10] = [x12]

*challenge:number Mahjong: there is a big heap of tiles with expressions and player has to match equal expressions to remove the tiles and gain access to the back layer challenge
    variant: face-up match-2, match-3, etc.

*greenMouse::variants
  - operator cannot be selected twice in a row (player has to 'alternate')
  - operators fall from the sky ('operator rain')

0? .bind(this) when rehydrating (when enliving)
(*les 2 clés pour des maths massifiées: animation et interaction

25 janvier 2021:
**enlivenSlot: when a dehydrated icObj touches/is snapped into/..  the enlivenSlot, the icObj becomes hydrated
  => challengeX reward may be a dehydrated object, and challengeY activation condition may be the enliving of the dehydrated object (for example a dehydrated well)
*challenge activation: any icObj can be dehydrated, so can a challenge (c'est un peu comme une pièce avec toutes les lumières éteintes)

**greenMouse operators: [²], [√]

**machine: reciprocalOperatorify: reciprocalOperatorify([x3]) = [/3]
    edu: pour expliquer la résolution d'équations (l'effeuillage), on part du set d'opérateur qui a permis la création de l'expression donnée, puis on fabrique le set d'opérateurs réciproques pour effeuiller

*challenge:machine chain: given step values (initial, final, and intermediate), player must put operators in snapSlot to create valid chain

*edu: timeout and nb_max_attempts may be counter-productive because they prevent pupil from sandboxing (l'idée de départ c'était de faire en sorte que l'élève se trompe énormément, comme il n'a jamais pu le faire auparavant)
*edu: track when an operator is spammed by pupil, and then prevent it from being spammed (Thrasher's 'area destroyed')

*telomere: each time object is rehydrated, add one to telomere (bon ok, normalement les télomères ça raccourcit mais je fais ce que je veux)

*simplify +1-1 or -1+1 when in sequence

**edu: add slider below equation for student to try solving equation (on peut imaginer un code couleur bleu-->rouge pour faire comme le jeu du chaud-froid)

26 janvier 2021:
*machine-cooked problem statements: first we generate a random expression or equation, then the machine builds a story around it

**challenge:propriétés opératoires: présenter deux expressions, et l'élève doit dire si elles sont égales ou non. _Si, oui, elles sont bien égales, il doit montrer pourquoi_.
    L'élève doit retravailler les termes pour montrer que les deux expressions sont égales:
      - commutation (a x b x c = c x a x b) (l'élève doit remettre les termes dans l'ordre)
      - parenthèses ((2) + 3 = 2 + 3 )      (l'élève doit supprimer les parenthèses qui ne sont pas nécessaires)
    ce qui va peut-être être chaud à développer: si un nombre est à une des extrémités et qu'on le déplace (ou peut-être pas si on se déplace dans l'arbre)

(*est-ce qu'il y a des chercheurs (français) qui bossent là-dessus ? (ou peut-être sont-ils passés du côté obscur de la force...)
((*à partir du 21ème siècle, il y a deux types de profs: les profs qui font cours à n ~ 100 élèves et les profs qui font cours à n ~ 100 000+ élèves. comme un MEGAPHONE silencieux.

(*equation: left hand side and right hand side are gemini, what you do to one also happens to the other

*ce qui est bien avec le fait de devoir coder les parenthèses, c'est qu'on est obligé de les considérer au même titre que les autres objets constituant une expression. On redevient élève.

***challenge:expression simplification by "touching" operatorNode with the correct simplified value:
      example: an expression is on the canvas: [2 / x + 64 - 30], user can pick [34] (from somewhere) and make it touch the '-' so that expression now becomes [2 / x + 34]
***"  from somewhere" == from a smart object pool
        smart pool should also propose letters when working with litteral expression (symbolicOperators: [xa], [-b], [/c])
      edu:
        easy: simplification wildcard: [?*] (==universal simplifier)
          sometimes the wildcard will "not work" : this is when there is another operation to consider before

        easy:   target fully-simplified expression is displayed
        medium: challenge listens to expression and completes when expression is fully reduced
        hard:   user has to click on "I think expression is fully reduced." button, and challenge completes only if expression is fully reduced (if not, expression is destroyed and user gets back to the start)

        easy/medium: smart object pool has equations in it which show simplifications calculations
          example: expression to simplify: [Y - 22 x Z x 33]
            then in smart object pool, you have [22 x 33 = 726] and [726]
        hardcore: smart pool contains deceiving objects

*challenge:get x:
  easy: x + 9 = 12
  medium: x + 50 = 2x + 12
  hard: (x+3) / (x+2) = 4

  easy:        x has first    position in the expression
  normal/hard: x has a random position in the expression

((*Pourquoi pas les automatismes d'abord ? Dans le fond, quand j'ai appris à parler, il a pas fallu m'expliquer pourquoi c'était important avant que je m'y mettes.
    D'abord on apprend à danser, et après on comprend pourquoi c'était important.

**[xylozone(0-9)] * [x10] = [xylozone(0-90)], [xylozone(0-9000)] * [/10] = [xylozone(0-900)]: value changes and so does size

**tool: display next priority: example: (12 + 4) / (5 - 3) will highlight "/" sign
**tool: simplify what user has lasso-selected

(*c'est chaud faut simplifier de façon chirurgicale

0 simplify: step by step
  0 create equality chain: initial = <simplified_step1> = <simplified_step2> = ...
    0 one line
    0 multiple lines

(*est-ce qu'il existe un symbole pour "simplifier" ?
https://www.symbolab.com/solver/trigonometric-simplification-calculator/simplify%20%5Cleft(3x%20%2Bx%20%2B50%5Cright)
  1 simplify logo, small s and "spiral arrow" (merci Cammy)

27 janvier 2021:
*mathWorkout: train 15/30?/60? min/day
  il faut au moins que l'élève essaie/se trompe 20 fois par jour

*simplification order is not really 'natural', it's like painting stripes on a tree
    [1] [2]     [3] [4]
      [5]         [6]
			      [7]

**from machine to human: "Maintenant, demande à ton voisin de faire comme l'ordinateur: simplifier l'équation étape par étape. Ensuite, compare les deux résultats."
    edu: bah ouais, si c'est l'ordi qui fait tout le temps le boulot, ça devient complètement aliénant, complètement "dépossessivant".

(((
"""
Alfred Gell (1945-1997), en anthropologue malicieux, énonçait de la façon suivante ce qu’il percevait comme un mécanisme à l’œuvre dans notre appréhension des artefacts, Joconde ou pagaie, et qu’il intitulait « captivation ».
La captivation est une forme de « fascination » et même « d’intimidation », « un état de blocage » qui survient lorsque le spectateur « ne peut plus suivre les différentes étapes de la création (dont l’œuvre d’art achevée est la trace objective) ».
C’est dire qu’il existe un« sort », une « magie » nous faisant projeter sur certains supports complexes des imaginations exorbitantes qui mettent au rebus notre pouvoir d’analyse.
De la même façon que les artefacts pris pour exemple par Gell, ce que nous redoutons et avec quoi il ne nous est pas possible de nous identifier nous « captive » et par là nous prive de raison, nous décérèbre.
"""
)))
*  edu: "Mais comment il a fait ?" (une perspective pour les élèves: "Plus tard, je comprendrai comment le prof a fait.")

*icObj.type = <as_X__Y>;   exemple: icObj.type = "as_text__mathNode";
    => icObj.parser  (== icObj.fromXtoY())

*icObj.type = "editableAsY__X": composite facade is X, composite editing medium is Y
* key<X>/doubleClick: Edit

https://textext.github.io/textext/
https://docs.mathquill.com/en/latest/

28 janvier 2021:
*modèle de financement à la JBFarkas: des collectionneurs peuvent acheter les challenges, qui restent gratuitement accessible à tous
  à côté du challenge, on peut appuyer sur un petit bouton d'information (i) qui nous montre qui est le propriétaire du challenge

*first demos: obfuscate html source code


29 janvier 2021:
	0 MathQuill + Visual Keyboard: pour rester dans le bain

  0 mathField.latex() --> icObj.parse(tex)
    0 don't parse "=" into ":="
*	  0 _upgrade_ to gmOperator when writing "x50"  / downgrade to mathNode when writing "50"
    0 x VS ×: it would be nice to write what user means when they type keyX

*"Nice barrier" : . . . . .
                  .       .
                  . . . . .

**edu: est-ce que j'écris [×10] ou [× 10] ?
    0 peut-être une façon de répondre à la question: faire du volume et regarder ce qui fonctionne le mieux pour les élèves

**challenge: probability: gotta catch'em all: fill target _slots_ with correct objects: probable outcome slots will be be filled easily. It will take time to fill improbable outcome slots.
    target objects may be:
      - a 1D object:
          dice roll, d6, d10, d20, etc.
          number in finite range
      - a 2D object:
          a colored number: number is in finite range + number color is in {blue, red, green, yellow} (with different probabilities)
    variant:
    fill outcome table with correct objects:
        probable outcome appears a lot of time in the outcome table, and these cells will be easily filled

**challenge: probability: history collector: explicit path on outcome ("those two stamps look the same but I was given this one by my great-grand-father")
            [  1  |  1  ]
            [_____|_____]
            [  1  |  8  ]
          when an outcome is given, its explicit path is written on it:
            exemple: if we get 1, because the top-right sector was selected, then the [1] we get is [1 (top right)]

  edu: il vaudrait mieux faire faire d'abord "history collector" puis "gotta catch'em all"


**tool: same denominator zone: arrange all fractions inside the zone so they have the same denominator


**PAUL: multiplication d'équation: il faudrait deux opérateurs rassemblés, et il faut toucher les deux pour que le touch se déclenche
  edu: une fois que les élèves sont habitués aux deux opérateurs, on peut leur faire utiliser le duo [ [x 1] | [x (3 / 3)] ] par exemple pour simplifier le membre de droite


*challenge: logique: opérateur qui transforme une égalité en vrai ou faux suivant si l'égalité est vraie ou fausse

30 janvier 2021:
  0 gmOperator: force simplify (si gmOperator.forceSimplify alors la simplification se produit même si les mathNode impliquées n'ont pas autoSimplify)

***challenge goldmine: probas et expériences aléatoires
    -sac
      contenu visible / non visible
      animation d'une sorte de main qui prend un élément au hasard
      remise obligatoire / remise possible / sans remise
    -probabilités conditionnelles (évenements dépendants / indépendants): on pioche dans un sac un objet et le deuxième sac de pioche dépend de l'object que l'on a pioché dans sac1

(*contenu mort vs contenu deshydraté: avant ce qu'il y avait dans les livres on considérait que c'était du contenu deshydraté, qu'on devait y ajouter notre part pour le rendre à nouveau vivant.
    mais maintenant, je ne sais pas si c'est par ce qu'on n'a plus de vie en nous ou que les livres sont mauvais, on considère que c'est du contenu mort. Comme un bout de bois. D'ailleurs c'est sûrement pour ça qu'on s'en sert pour caler les meubles.
    Les contenus deshydratés de maintenant, c'est les jeux vidéos. Peut-être qu'on est toujours vivant mais différemment. Et du coup c'est pour ça qu'on a du mal à réhydrater les livres.

* simplification: accolade de "soupèsement"

**icInfiniteChronoBar / icInfiniteProgressBar:
    - chronoBar grows a square at its end every 1 second (at some point, you have to zoomOut to read elapsed time)
    - progressBar shows students accomplishments. Same principle: it has no end
        variant: textual mathematical life steps infinite progress bar.   [j'ai appris à reconnaître les chiffres. j'ai appris à compter jusqu'à 3. j'ai appris à compter jusqu'à 10.     ...         j'ai appris à intégrer sur un contour     ...  j'ai découvert un nouvel objet mathématique.
**  edu: infiniteChronoBar est sympa aussi pour faire comprendre la notion de valeur approchée: vue de loin, la chronoBar a l'air de ne pas grandir, c'est parce qu'on la voit de manière approchée: on utilise une certaine puissance de 10 et la mantisse nous paraît rester la même.
      ce qui est bien c'est qu'on a un objet apparement à la fois un peu dynamique et à la fois un peu statique
*   edu: exponential chronoBar: chronoBar x2 every second

*une représentation de l'oubli: un demi-plan complètement noir avance tranquillement, toujours à la même vitesse, vers les x positifs

**0? rep_engined: ça ferait sens. rep_free c'est la représentation contrôlée par l'utilisateur. rep_engined c'est la représentation contrôlée par le moteur.

(*toujours la même rengaine: l'obstacle majeur: c'est la mise en prod. C'est le passage du prototype à "A table les enfants."

*["text"] * [x (22/7)] = ["texttexttextt"]avec le dernier t un peu coupé:
    text_out  = text_in * Math.floor(22/7)
    width_out = width_in * (22/7)

31 janvier 2021:
***yugioh-style number card game:   (SHU: i think this idea could be really powerful)
      - turn:
          draw
          play cards
      - field:
          monster == number
          magic   == operator
      - win when first to gather all monsters (monster zone are targetSlots) (~exodia)
      - can reuse built number as stem

     (- wildcards : [x ?*] [?* 4]

     ((- single-use / finite-use / infinite-use operators

**edu: session-cooked keyboard shortcuts:
    say I want, _in a particular 1-hour class_, to show students particular challenges
    I would use the following shortcuts:
      easy level:   "Key1"
      medium level: "Key2"
      hard level:   "Key3"
    And those keys would spawn a new challenge, _each time they are pressed_,
    this way, if students don't seem to understand well after one instance,
    I can always spawn _a new instance of the same difficulty_, until they understand

*edu: if != when, si != quand, condition != property (==consequence is true if condition is true) != event (==condition is true at this moment)
    les élèves peuvent fabriquer des propriétés à la pelle en combinant un bloc [when < >] avec une instruction [machin <-- truc]

*0 "embracing tree" / onion mathNode: sqrt((x - 94)/4)
    onionNode / layerNode
*   operator chain: add parentheses when operators have same priority, or else mathNode's structure is not explicit
    simplify top layer
**  en fait, on peut définir un layer comme un ensemble d'opérateurs de même priorité
*     mettre les layers en couleur
      un layer équivalent à [x 1] ou [+ 0] (== un layer équivalent à [id( )] peut être simplifié (== retiré de l'expression)
    une étape de simplification mathNode1:
      0. repérer l'opération de plus haut niveau
      1. créer l'opération inverse: {operator2, mathNodeTerminal2}
      2. appliquer l'opération inverse: l'arbre grandit: il devient operatorNode(operator2.symbol, operator2.funcName, [mathNode1, mathNodeTerminal2])
      3. réorganiser l'arbre pour faire apparaître l'opération identité composée d'un couple {opérateur, neutre pour l'opérateur}
      4. retirer la couche avec l'opération identité

      mais, c'est bizarre, après tout, l'opérateur est pas forcément binaire, ou peut-être que si ([A] ** [Anti(A)])

01 février 2021:
*cette chance de dévelopeur: ça fait sourire
  - y + 0 doit être simplifiée en utilisant [- 0]     ^^
  - \frac{\left(y\cdot 91\right)}{0}                  normal quoi, y'a rien de choquant...
    edu: ^^
  dev: la simplification du 'zéro tout seul' va être chiante

**[s x 60 s]: gmOperator + forceSimplify top layer
    => gmOperator has the same backgroundColor as standard simplification operators (for example: light green, ou gradient red-->green, black-->white)
**gmOperator decoratorTouchSlot "gmOpDec": when a
    via gmOperator composition: transformationFunc3(x) = transformationFunc2(transformationFunc1(x))
    decoration may be applied:
      - once
          cannot decorate with decoration1 what has just been decorated with decoration1
      - multiple times
          with an "identity decorator": t --> id(t), then could create chains dec1(id(dec1(id(dec1(t)))))

**(*)edu: "I think I got it." button: when student thinks he has understood something, when "something's just happened in their brain", they can press the button to indicate to the teacher that, well, something has happened in their brain (!)
        this would be a way to check if a challenge "is really worth it" (par rapport à l'"élève moyen")

02 février 2021:
*greenMouse: display part: in order to keep the touching part the same size, a _central display part_(== at the center of challenge's area) could be used to display green mouse's current state

**edu: the whole 'simple equation' workflow:
  1. create the 'simple equation' you want to solve
      challenge 1: coat your left side expression
      challenge 2(or 'challenge transition'): create the equation (touch "=" sign and then a number)
  2. get back to your initial letter on left side:
      challenge 3: uncoat your left side expression, and see right side getting 'inverse coated'

**edu:quality control: is this expression valid ? there is an expression provider and two bins: one for the valid expressions and one for the invalid
    if player has made nb_mistakes < nb_max_mistakes then challenge is completed

(((*attention avec les func.bind(this), les arrow functions font les rebelles: il faut utiliser les bonnes vieilles function() à la place.

(*la théorie du décollage: quand le processus de développement de l'élève est entretenu par l'élève lui-même ((souvent par une passion))

(*l'avenir sombre de l'éducation: convey

*un petit goût d'usine: conveyor-belt-based challenges: il faut pas traîner sinon ça fait planter la chaîne

03 février 2021:
**edu: random everything + "I think this is not possible" button.
    le pendant du "grand" aléatoire : on ne sait pas si on peut trouver une solution
*edu: 100 points par jour
**challenge:from expression1 to expression2 via x: unfold in order to customFold
  example: sqrt((3x+1)/2) --> x --> (60 - x)/sqrt(85) + 7

(((((*maths for the perv: puzzle composed of greenMouse targetSlots which gradually untile to show beautiful lady for example

*challenge: interlock: with "intersecting composites"

*add a handle next to snapSlot for easy 'group move'
*snapSlot may be, at start, a single-object composite. It then grows with the snapping of objects.
  => "snapComp" = composite(snapSlot)

**experiment: not really a challenge, not really a tool. It is more like a "this"-dedicated sandbox.
**edu:experiment: RVB color by hand: player creates a mosaic square (or a circle, or any shape) using small colored squares, r are red, g are green and b are blue: when zoomed out: we can see that the square color we see is near RVB(r,v,b)
    pour aller plus vite: on peut imaginer:
*    -un spray avec un compteur (on spraye(== position aléatoire) des petits carrés (ou ronds) de couleur donnée)
**   -un enclos avec une fonction de mélange: on met tous les ingrédients dedans, on appuie sur mélanger et ensuite on dézoome

04 février 2021:
*challenge: équations: [relier] les différentes étapes de résolution de différentes équations proposées
    les équations de départ               eq1     eq2     eq3     eq4
    les équations un peu résolues         eq3'    eq1'    eq2'    eq4'
    les équations un peu plus résolues    eq1''   eq2''   eq3''   eq4''
    les équations résolues                eq4'''  eq1'''  eq3'''  eq2'''

*tool: dependency: créer un objet formule qui se met à jour automatiquement quand ses dépendances changent
  edu:pour ensuite les faire basculer sur le tableur

**0 engined.engines = {}

(((*how to serialize a closure ?

(((*Le problème du retard, quand il n'y a pas d'échéance...

05 février 2021:
*"reverse" operators: operator is moving and touches what to transform
  - eraser
  - randomizer
  - show/hider

*icObj.type = "2d_plank" : [plank] * [x 2] = [plankplank]  ==> icObj.type = "2d_length"
*icObj.type = "2d_tile"  : [t i]   * [x 2] = [t i t i]     ==> icObj.type = "2d_area"
                           [l e]             [l e l e]
                                             [t i t i]
                                             [l e l e]
*la logique derrière, c'est la coercion de [x 2] en [".size.width x 2"] ou en [".size.width x 2: .size.height x 2"] selon l'"argument"

*clickWell:   onclick: create instance and "put it under the mouse cursor"
  c'est presque pareil du point de vue utilisateur, par contre c'est très différent niveau implémentation
*touchTarget: onTouch: if toucher is valid: nowCompleted

*challenge: (greenMouse) rainbow: there are multiple targetSlots and the objective is to fill all of them

*challenge: randomness: on part de [""] et on a des opérateurs [append random letter]
    edu: juste en dessous de l'opérateur [append random letter], on montre le sac duquel la lettre est tirée
*   edu: il y a une zone pour mettre les rebuts et un compteur de rebuts

(* 0 simultaneous n-touch, "composite touch" ==> nTouchEngine
		  this could be a way to discriminate objects: those which trigger the n-touch and those which do not

**touchSlot hardcore transformation: from icObj.typeX to icObj.typeY
    - transformer une forme en nombre
    - transformer un texte en son
    - transformer une équation en un composite comprenant le membre de gauche et le membre de droite
    le dev doit être un peu costaud

**yielder::fromAudio : press 'start recording', speak, press 'stop recording' : recorded audio is then transformed into a number, or an operator, or whatever corresponds to what you said

**freeDrawingAnimation recorder: the whole drawing process is recorded
**AudioFreeDrawingAnimation recorder: audio is recorded as well

((*architecture::challenge: composite(well, composite(operators), target) voire composite(composite(well), composite(operators), composite(target))

06 février 2021:
((* the canTouchFunc problem :
      le problème est le suivant: un objet a besoin du contexte pour estimer une condition et il ne sait pas ce qu'est le contexte. Seul le contexte peut lui fournir les informations dont il a besoin.
      le problème est le suivant: touchSlot.canTouchFunc(above, below) n'a pas assez de above et below pour donner réponse satisfaisante, il manque des paramètres.
      plusieurs solutions :
        (1. touchSlot.will["touch"]: mutate canTouchFunc juste before it's going to be used: le contexte écoute la fonction et la mutate just in time
        2. touchSlot.canTouchFunc(above, below, context): on rajoute tout simplement un paramètre
          => touchSlotConfig.facade

07 février 2021:
  0 Paul:
    0 petit personnage qui donne les instructions

    0 deux modes d'exercices différents
**    0 calcul mental un peu comme le golf:
        scoring comme le golf: par, 18 trous
          0 bouton recommencer et pénalité de 1 point
          0 ou système de seuil comme au golf
          0 ou alors on ne peut que recommencer trois fois un challenge puis ça donne une pénalité
        0 difficulté croissante (comme le mini golf)

      0 apprentissage par le jeu, la notion de score n'a pas d'importance
        on va jouer avec l'âge de ma grand-mère, en fait je ne le connaît pas, c'est pas grave, on va dire que c'est x.
        0 première partie chaîne de caractères
          0 au départ on se trimballe la grande chaîne de caractères
          0 niveau 3: ["l'âge de ma grand mère"] * [+ "l'âge de ma grand mère"] = [2 x "l'âge de ma grand mère"]
          0 niveau 4: ["l'âge de ma grand mère"] * [x "l'âge de ma grand mère"] = ["l'âge de ma grand mère" ²]
          => utiliser une inconnue dans les coulisses

        0 ensuite l'inconnue
          0 deux niveaux enchaînés:
            0 [y] * [x 2] = [y x 2]
            0 [y] * [x 2] = [2y]

        0 "ah c'est bon je me souviens, pour avoir l'âge de ma grand-mère"

        0 au bout d'un moment, le personnage compagnon choisit de remplacer

      0 parcours 1,5 avec la règle suivante: on n'affiche pas le résultat intermédiaire simplifié mais la version parenthésée
**       0 GlanceTouchSlot: _while_ touched : simplified expression is previewed

  0 SHU: utiliser le jeu de façon répétée pour s'améliorer (un peu comme les assistants de touchTyping), un peu tous les jours ==> "I was growing up big like a Superman"
    0 parcours 0: pas de score, pas de par, on peut "se tromper" autant qu'on veut
    0 troisième parcours avec uniquement des équations pour cette fois ci faire de l'entraînement
*** 0 BlueMouse (==GolfRedMouse): _if it has been mutated_, then when dropped: the previous well is moved to the drop position
        pour l'instant on ne va pas trop s'intéresser à ce concept car il cristalise les "erreurs"

    0 en fait il y a deux pars:
        0 dans un essai spécifique: le nombre d'opérateurs touchés
        0 le nombre d'essais (== de greenMouses utilisées)

*edu::challenge "injection" (inject challenge in presentation): addNewChallenge(screenRect): compute the coordinates to fit in screen rect

**edu: client-server benefits: teacher can be real-time moderator of student room (la cybernétique: wire power)
  - big-brother: oversee what individual student is doing
  - shutdown: close all sessions if students are too much agitated
  - course MC: "sharp control" course flow
      - show exercise
      - close exercise
      - lock/unlock move in student room
  - teacher can freeDraw hints in student room

*golfCourse: ui: use golfCourse standard pattern: (ball), teeing, (fairway, green,) hole, flag
*golfStep: onComplete:
  - show arrow pointing to next course, a big fat red arrow
      0 icObjType = "arrow"
          icObj.orientTo(point)
  - fill golf course with golfStep.score (when zoomed-out, we see big numbers and arrows)
      backgroundColor(score):
        bronze: above par
        silver: par
        gold  : below par
      edu: de cette manière on peut voir comment l'élève réagit à la difficulté croissante

*sexy/sexiness:
  - greenMouse trail
  - decorations:
      associate an image to each golf course (for example, an image from ALOI 1000)

*greenMouse: mode: survival: (== "endless")
    time is extended by n seconds when completing challenge
    challenge is mutated with new values|operators when completed

**greenMouse: forbidden values: gmValue cannot be x or else gm dies (there are forbidden nodes on the gmAllPathsGraph)

**challenge sequence::segue: how to transition from challengeX to challengeY

08 février 2021:
*greenMouse golf: "impossible? step": gm initial value is 0, operators are [x 6] [x 7] [/ 3] [/ 42] and targetValue is 42
    - player has to think outside the box and use a [+ 1] operator, available on the _previous golfCourse_
    - the 2 golfCourses are visually fusionned (to give player a hint of what to do)

***CURSES! :)
*icObj.type = "gmRebirthWell": there is actually no real well, only the gm respawning -> icObj.type = "bornAgain_gm"
**    bornAgain is a _curse_, same as greenMouse

**fucked-up maths (== curse operators):
  - delayed operators: a delayed operator will apply _after_ another operation is applied.          [after <n> operations: x 2]
  - 'just before' operators: a 'just before' operator will apply just before operation is applied   [just before x 2: + 1]
  - doom : gm will die after n turns
  - amplification/minification/replacement: operator right-side value is mutated before operation is applied: [x 2] will for example be 'felt' as [x 20]
**- "karma curse":
      - "next life": curse which applies to the bornAgain
      - "eternal curse": curse which applies to all the replicas. One can't get rid of this curse.
  - "feed me"/apoptosis curse: If object is left without interaction for n seconds, it will die.

(((
"""
Take everything away from me
Replace my skin with circuitry
All that I have bleeding from me
To feed the machine
"""
)))

*bizarre ideas: no-copy curse: object cannot be copied

((*une idée c'est 100 lignes de code et 10 autres idées qui se ramènent.

*edu: c'est intéressant de proposer le même challenge mais avec l'ordre des opérateurs changé car l'élève un peu distrait va retenter son "parcours glissé" qui fonctionnait avant et va se rendre compte qu'il ne fonctionne plus maintenant.

09 février 2021:
**challenge: consume stack of targets : well does not change but top card of targets' stack is removed on completion
    edu: this would be a nice mode for training: students has everything in sight and knows it's over when stack is emptied
*challenge: consume stack of targets with finite initial stack
    edu: pour se concentrer sur la bonne gestion des ressources

*score: score is decreased by 1 for every new attempt

**modulo: greenMouse value is modulo n
***the mole: touchOperator does not trigger if greenMouse is below (zIndexWise) : we can imagine 0-assignment walls or even complete contours, from which player would have to consider using the 'mole move'
      or bird move, if we consider that touchSlot triggers when greenMouse is below (it would be more coherent with stamping and soaking)

**challenge: wall of challenges / challenge pointillism: completing a challenge colors the tile. An image slowly appears with more and more completed challenges.
    dev: how about 500 challenges ? 1000 ?

performance:
**	0 touchSlot.local_listen
**	0 canvas.local_redraw

*edu: ux: parentheses: in unsimplified expression display mode, when chaining 1 * [+ 2] * [x 3], it would be nice, just before applying [x 3], to add an animation which shows the user that 1 + 2 is now (1 + 2)
    à la limite: carrément montrer "x has a higher priority than +", ajouter les parenthèses et appliquer l'opérateur
      colorier l'expression en fonction de la priorité de son opérateur racine
      colorier les opérateurs en fonction de leur priorité
      "pour appliquer une priorité supérieure, il faut emballer"

*edu: les bons jeux edu et les mauvais jeux edu: la jungle

10 février 2021:
((*la couleur (==la composition de couleur que l'on voit) a une influence sur le moral. Suffit que le fond soit un peu trop aggressif et c'est mort, on n'a plus envie.

**edu: computer science: scope, visually: say we have a "visual local variable" [x] (~un peu comme une greenMouse) in a visual scope [S] (~a playField), then in the same way as for a classic local variable x, we could have another [x] in another scope [S'] and the two will be completely hermetic/alien.

**challenge: 'overuse golf': il faut faire un nombre de coup _supérieur ou égal_ au par pour pouvoir valider le challenge.
**challenge: 'Ratatouille golf' ou "Pourquoi faire simple quand on peut faire compliqué ?": il faut utiliser au minimum n opérateurs différents pour pouvoir valider le challenge.

(((***la vision: rendre visible l'invisible (pour faire un tremplin vers la compétence "voir l'invisible" que l'on souhaite acquérir)

(((**le moteur: toujours avoir l'impression d'être libre

**challenge (computer-science): destroy ftw: : student has to destroy the right object to be able to complete challenge
    example 1:
      every time a touchSlot touches an object, a counter increases near the touchSlot
      the player has to use the touchSlot 5 times but, for the challenge to be completed, player is only allowed to use it 3 times
      an object is responsible for the counter increase, it is a visual representation of computer logic (and the object actually _carries_ this computer logic)
      if player destroys this object, as the counter is no longer increased, player can complete the challenge

**Attempt: Evolution vs Manoeuvre:
    Evolution: greenMouse-focused       passive stance: what the world does to me
    Manoeuvre: course-focused           active  stance: what I do to the world

0 icHook : les deux frères Will et Did

(((n'empêche, tout ce caca qu'il faut écrire... : from magma to cristal, from heart shapes to trash heaps

icObj.namespace ou icObj.family, par exemple: icObj.namespace = "golfStep4", icObj.namespace = "golfCourse7"
  pour savoir quel objet "appartient à qui"

on retrouve les bonnes vieilles marmites: "label: value" ==> icObj.type = "labelValue" (==composite(label, value)) (l'informatique des dinosaures)

*edu: [score] au dessus de [par] (limite avec une barre entre les deux) pour glisser au passage un petit mot sur les fractions.
    On peut imaginer mettre à côté une progressBar qui est débordée si on dépasse le par.

**edu: flipping operators: flip animation transforms operator into inverse operator. example: [x 2] becomes, after a flip, [/ 2].
**    edu: when the golfStep challenge is completed, we flip the operators, we flip targetSlot: it becomes the well, we flip the well: it becomes the targetSlot. Student, after some attempts, will begin to understand that they have to do the reverse path.

11 février 2021:
*golf: endScreen:       nom du parcours, tableau de score et médaille
*golf: startScreen:     nom du parcours
*golf: tutorialScreen
((on s'écarte de la vision originale (== à la The Witness) mais c'est pas grave.

*autoPar / golfChallenge constraints:
    - path must stay between 0 -100 and 100
    - path must uses rich composite numbers

** "AND THEN HE YAWNED"

12 février 2021:  paralysis :(
*golf: hacker/cheater: get total_score below 10 by cheating
**edu: allow cheating but explicitly show "cheating" when cheating and on end screen

**golf cheating:
  0 "that hole seemed nearer": ball_1 in hole_7
  0 golfCourse tampering: same principle but operators are exchanged so that, at first glance, there is no cheat
edu:
  general cheating schemes:
    ugly:
    - end screen tampering
    subtle:
    - varX as inputY
    - level tampering

**challenge:factoryChain:
    on left-side:   maps      to create core process values
    on center-side: values    core
    on right-side:  reduces   to create result value

          ----[+ 1]----->    [x + 1]    ---|
          |                                [+] -> [4x+1]---|
        [x] --[* 3]----->    [3x]       ---|               [-]--->    [(4x+1)-1/x]
          |                                                |
          ----[inv()]--->    [1/x]      --------------------
    Some blocks may display an _expected_ value, and the consequent value.

    two flavors:
      type:   user types what he thinks is correct make the chain valid
      puzzle: empty slots must be filled with pieces

*endless: recycle golfCourse VS create new golfCourse

**icObj.type = "repeater": when activated: contained operator is applied <n> times
                [R <5>       ]
                [   [x 2]    ]
                [            ]
    ? crocodile-style ui à la Scratch ?

**edu: challenge rework: on completion (or later on): challenge is proposed again, but under a new, reworked form
    - propose challenge.ver2 with different operators
        from [+ 2] [+ 2] [+ 2] [+ 2] [+ 2] spam to [R5 [+ 2]] to [+ (2 x 5)],
        from [x 2] [x 2] [x 2] [x 2] [x 2] spam to [R5 [x 2]] to [x (2 ^ 5)],
        from [/ 2] to [x (1/2)] (slight change of vision)
    - propose challenge.ver2 with ver2.input = 2 * input and ver2.target = 2 * target
        ver2.input = 10 * input and ver2.target = 10 * target, etc.
    - propose challenge.ver2 with all components' values scaled by 10
        scaled by 0.1
        scaled by 10^6


(((*l'adn, c'est le code qui a été retenu, donc normalement c'est du bonheur (par rapport à du code pourri ou du code sale)

**edu: practice: corrective feedback helping: (https://en.wikipedia.org/wiki/Control_engineering), create next step wrt previous steps attempts
    Appuyer là où ça fait mal
    dev: evolutionary computation, Resilient control systems

*edu: display evolution: show graph of greenMouse value evolution
**edu: inverse operators on top row: each bottom row operator has an inverse counterpart on top row: when student has "made a mistake", student can always cancel their mistake by applying the inverse operator

13 février 2021:
((*j'aime bien le problème de nommage de operator, quand on ne fournit seulement qu'operatorFunc. Si on connaît le code de la fonction, alors normalement on peut nommer correctement.

*edu: group-covering operator set: so that there always exists a path to the target
    - ℕ-covering operator set: to drive student into using [x (-1)]

*pretty operators: [/ 2] -> [□ / 2]

*edu: challenge.deceiving_rank: check solving paths for lasagna trees built from the super operator set: {operators} + {inverse operators}
  some students may try to solve "[48] --> [38]" using [+ 10]
*   Il y a un gros travail à faire autour de "C'est quoi un challenge difficile ? C'est quoi un challenge facile ? C'est quoi un 'bon' challenge (pédagogiquement) ? C'est quoi un 'bon' challenge (gameplay) ?"
  petit à petit (=="gradient fractal") faire passer de [+ 1] à [- (-1)] à l'indifférence [+ 1] ou [- (-1)]

*edu: est-ce que ça apporterait quelque chose que considérer des opérateurs qui acceptent seulement un certain type de valeurs d'entrée ? (par exemple: seulement des nombres, seulement des symboles, seulement des fractions, etc.)

*edu: un peu risqué: fraction as a certain number of turns (oriented unbounded angle)

0 easy composite rewrite: composite.parts["x"] = y;

*challenge: greenMouse = RangeNode: toutes les opérations sur les intervalles
*challenge: revolver operator (== operator cycle): once used, operator becomes operatorCycle[n+1]

14 février 2021:
**edu: BiggieSmalls: bigger font for what is important: artificially create a foreground and a background in TeX expression
    - solving an equation: MAKE 'LAST' OPERATION BIGGER
        ---|                   /|    /__\
           |                  / |   /    \
         --|     (x + 1)   =    |       /
           |                    |      /
        ---|                    |     /___

         ^
         |
         |___  this is the last operation that was applied

**edu: cherry-picking: [save (previous) challenge] / [copy (previous) challenge to clipboard] quand on a trouvé quelque chose d'intéressant au challenge aléatoire que l'on vient de rencontrer
((*L'approche phénoménologique: les maths interactives, ça demande de passer par l'étape (plus ou moins chiante) de _programmation_ des activités. Les maths interactives, ça tombe pas du ciel. Après on en tire les conséquences qu'on veut.

*rep_eternal VS rep_living: how it feels never to die

***0 en fait il faudrait un symbole pour chaque opération:
      unitful operation (=="node_b" is unitful):
        multiplication:      ×                A shock, like a battle between the two factors (cross swords). Some units are lost in the process. d = v * t
                                                Quantities multiply and units combine.
        quotition division:  ÷                We search the unitful quantity of unitful bottom member present in top member.
      unitless (==scalar) operation (=="node_b" is unitless, it is a "true" number):
        scaling:             · (|no symbol)   We scale by <coefficient>.                                  ("mother" unit is preserved).
        partition division:  /                We search the value of a part if we partition into n parts. ("mother" unit is preserved).

      Le langage fait apparaître des "unités invisibles": quand je dis 3 demis, je peux me dire que mon unité est le demi, et ma quantité est 3.
      Quand je dis "Trois demis fois un quart", en fait,
        - je multiplie les quantités : je fais trois fois un, ça donne 3.
        - je combine   les unités:     la moitié d'un quart c'est un huitième.
        Résultat final: 3 huitièmes.

      Trois demis divisés par un demi == Trois demis partionnés en 'un demi': Trop facile, ça fait 3.

      On peut passer de 3 demis à "1,5 uns".

*edu: "Bon je vais où maintenant, vous me montrez ?" infiniteCanvas program X clickless student multimouse

15 février 2021:
0 Atelier_<X>: zone de dev pour icObj<X> ou pour une mise en scène d'icObjs

16 février 2021:
**edu: (mainly for client/server): evanescent freeDrawing: teacher can write hints or indications which gradually vanish
**mathNode.toTex(): custom: to inject color for example
((*hack: use (x 1^id) to tag sub expression

**edu: speed evaluation: l'élève a 3 secondes pour toucher le bon target
    pour par exemple:
*     ("faire rentrer") les additions simples et moins simples (9 + 2 = 11, 9 + 8 = 17, 7 + 4 = 11, 8 + 7 = 15, ...)
      ("faire rentrer") les tables de multiplications
      ("faire rentrer") les relatifs

**0 ux: make it _readable_( {size, fontSize} )

**operands: argument operand VS parameter operand
    [x] * [+ 3]
     ^     ^ ^__ parameter operand
     |     |_ operator
     |___ argument operand

**edu: challenge: from x to expr:
    ver1: same operation set is used to create targetExpr and 'growingExpr'
		  easy:    one instance of symbol, operand order is left to right
		  normal1: one instance of symbol, random operand order          (là on est au coeur d'une difficulté des élèves: passer d'un parsing left-to-right à un parsing plus global)
      hard:    random operand order, sometimes parameter operand is an instance of symbol

    ver2: different operation sets are used to create targetExpr and 'growingExpr': student has to mentally simplify to find the right operation
      easy:   simplify one step (+ -):  [+ 2] * [- 3] into [- 1]
      normal: simplify one step (x /):  [x 2] * [/ 6] into [/ 3]
      hard: simplify two steps: [x (3 + 10/5)] into [x 5]

((*A challenge mechanics for every 'learning step': expliciter toutes les petites difficultés des élèves: transformer l'escalier à grosses marches en tremplin

(((* maintenant j'ai comme une "tendresse" pour les opérations genre [x 2]

*"operator simplification":  [x [2^4]] = [x [2 x 2 x 2 x 2]] = [x 2 x 2 x 2 x 2] (on peut retirer les [])

17 février 2021:  'INDIRECT'
* 0 indirect touch: contactArea is the only entryway for touch
  =>targetTouchSlot.facade on top, targetTouchSlot.touchSlot at the bottom,   so that player can see the two expressions distinctly when try to submit answer

* 0 indirect hold:  if I grab greenMouse's tail, I grab the whole greenMouse. Same thing with any other body part.

(0 sometimes algebrite fails to recognize that two expressions are equal

19 février 2021:
**challenge: Different ways: get to target via n different ways
    inspiré de
      2 + 2 - 2 / 2 = 5
      2 x 2 - 2 / 2 = 5
**challenge: greenMouse in tuxedo: greenMouse displays numerical expression instead of value, target displays value

*fill tool:
    0 bounded fillable
      0 find if there there is a bounded fillable around cursor
      0 create object which fills
    0 unbounded fillable
      0 create unbounded fillable (dynamic object)

*greenMouse: pure operators [+],[-],[x],[/]
    0 gm_calculator
    edu: [(x + 3)] * [-] * [(2 - 3x)]

(((("HE PUSHED A ROCK"
(((("AND THEN HE YAWNED"

20 février 2021:
**challenge: mutating target: each time greenMouse mutates, so does target. It's kind of a curse.
    example:
      linear evolution:       target := target + 2
      exponential evolution:  target := target x 2        (better be quick)
      cyclical evolution:
               target := target + 2
          then target := target -10
          then target := target + 2
          etc.

21 février 2021:
**adaptive pov: pov follows activeSelection size: if object is shrunk by an operator, then pov follows
**size-restricted operators: operators only trigger when greenMouse size is compatible
    edu: put [x2] or [+0,01]  size(10^-2) operators      around _or inside_    a size(10^1) [/1000] operator

*gm: test-tube operators: there is a test-tube wrapper around operator which forces greenMouse to be touched in a particular direction
        ______________
        |[2 x]  <--<--<--<-- [3 + 4]        ==> [2 x 3 + 4]
        |_____________

**bag: put/pick (==push/pull)
    push x1:  touching object pushes  1 instance  of it in the bag
    push x10: touching object pushes 10 instances of it in the bag
**  random pull (==random pick): touching operator random picks an instance in the bag
**challenge: fill bag then "random deliver" (target must be _attained via random picking_)
**challenge: multiple chained random deliveries     (one may try again, and again, and again)

**0 ustensil: operator can be dragged to touch other objects and gets back to its original place when released

**edu: easy arrowing: measure: create measurement arrow next to object

**number fonts:
    even  number: round
    odd   number: spiky
    prime number: noble
  0 tex fonts

22 février 2021:
**challenge: cube target:
    1. player can manipulate target to understand it better:  [turn left], [turn up] operators in order to know what target is
    2. player has to turn and mutate side and turn and mutate side of greenMouse cube to match target cube
    example:
      cube painting
      dice painting (paint dots)

*Scratch-like: any colour you like
  https://github.com/nicolaspoulain/scratchTeX

**greenMouse: boulangerie-pâtisserie:
    - greenMouse starts with coins
    - there are bakery operators: [get baguette (1,00 €)] [get croissant (1,20 €)]
    - each time greenMouse touches operators, greenMouse loses money but gains object
    - unavailable operators (not enough coins) are grayed
    edu: même chose: un parcours à l'endroit puis à l'envers (revente au prix coûtant) permet d'introduire les expressions littérales puis les équations avec des prix inconnus

0 regarder le travail des grands:
    Scratch: https://github.com/LLK/
      dependencies:
**      - http://paperjs.org/
        - plein de trucs de Google... (???) (!!!)

23 février 2021: Quantum Protocol is very good: supergraph, mastery, research, activationCountdown, different activation types: initialize, when <condition>, execute, ...
*supergraph (==story graph): we organize "keyGames" (~superKeyframes) in a graph
**"research": player unlocks new objects when they have enough mastery

**challenge: random in range => narrow range: every turn tick, greenMouse metamorphoses into random number in range. Yet, "source range" can be mutated using operators in order to narrow down possible outcomes.

**0 icObj.parts.curse.parts.counter, icObj.parts.curse.parts.curse_row

**a countDown curse can be put on _a challenge_
((curses for everyone :)

((*coop game: one player controls greenMouse, the other can cook operators

*benecurse: touching benecursed operator adds counters to targetValue's countdownCurse.countdown

***reactiveAnimated: mutating one property mutates the others, in order to stay on animationPath  (==lifespanObj)
      example 1:
        {
          progress: 0.12,

          index:    1,        <--- mutating index results in a progress quantization

          color:    someColor(0.12),
        }

      example 2:
        {
          progress:         0.4,

          name:             "ozij fozjf",
          wealth:           5000,
          nb_of_children:   1,
        }

24 février 2021:
  0 algebraic expressions easy unequal checks: 0, 1, -1
**greenMouse: units: [12 people] * [/ 4 people] = [3]
**greenMouse: dotted line: periodic mutation

**greenMouse: back to binary operators: operations operands can be swapped (dnd)
**redMouse: back to binary operators: three (or two) red mice as left and right operands, left operand is also "receiver"

WOW: https://mathsolver.microsoft.com/fr/solve-problem/7%20%60times%20%208x%20%20%5E%20%7B%202%20%20%7D%20%20%3D3?r=bi&ref=bi

**multistep operation/multistep inverse operation (why not trying harder ?)
    example: [x] * [(3? + 4)/5] = [(3x + 4)/5]
             [(3x + 4)/5] * [(?x5-4)/3] = [x]

((*il y a le test fonctionnel: regarder s'il y a des bugs, et il y a le test "goûteur", le test qui se demande si un humain va accrocher.

*terminalMathNode: x vs ((((((x)))))

greenMouse: expr to x:
*   medium: propose 'reduced' operator when two same-priority operators are chained
      example:  [((3x + 5)/4)*12] --> [x]: propose [x 3] instead of [x 4] or [/ 12]
*   medium: propose equivalent operation: [- (-1)] -> [+ 1]

**greenMouse: binary representation of numbers: 0110011010010
    - shift: left / right
    - invert bits (~)
    - add<n>

25 février 2021:
**challenge: greenMouse: clear target stacks in <n> turns: player has to find the path to clear target stacks in least turns
    - numbers
    - number exprs
    - litt exprs
**challenge: greenMouse: given _hypothesis_, complete challenge
    example:
      _hypothesis_ : _x = 4_,   [3x + 7] --> [74],  using operators: [+ 1] [x 4] [- 6] [- 7]

**challenge: greenMouse: suites: player starts with _n=<k>_ and [value(u_n)], operators are [u_(n+1)] [u_(n+2)] [u_2n] etc.
    touching operator [u_(n+1)] does two things: it updates greenMouse and it updates _n=.._ display: "n=<k>+1"

**ux: tablet: _dragArea_, displayArea, contactArea

((il manque un symbole pour dire c'est une expression ou c'est une opération. e3 / 2e  VS o/ 2o.

**challenge: greenMouse: from expr to x:
    medium+:  depth: 10     (ça a l'air hardcore mais en fait c'est toujours la même chose et ça permet de rendre 'acceptables' les grandes expressions)

edu: on pourrait envisager différemment les niveaux de difficulté:
    easy:     découverte                    prise de contact
    medium:   pratique courante             prise en main
    medium+:  renforcement, automatisation, prise de confiance
    hard:     désautomatisation, ouverture, prise de recul

*0 save/load gameSetup  (save/load anything (don't limit yourself to one serial type))

0 simplify: same priority == same "simplification level":  [frac((7x+3),7)x10] * [x 7] should yield [(7x+3)x10]

(((*qu'est-ce que ça va devenir tout ça ? poussière, chose publique, big money ? Should I give a fuck ? Pourquoi fait-on des enfants ?

**simplify: factorize
**simplify: animate simplifcation process: like combos in Tetris (Attack)
***  edu: tool: clock_simplifier: perform simplification at each clock tick
        Parenthesis removal step can be considered a first-class simplification step. (après on peut en débattre, mais je trouve que le mieux c'est de ne pas mettre la difficulté "parenthèses" entre parenthèses)

*yellowMouse (==chickMouse): comme le tri des poussins, on la balance là ou là
**challenge: yellowMouse: evaluate (numerical) expression
    1. player drags expr to choiceSlot
    2. the expression is drawn to the center of the challenge, in the "center stage" display zone
    3. the expression is then clock_simplified until the solution is shown
    4. player's choiceSlot then turns green if correct (or red if incorrect)
    5. challenge completes (with success or failure)

0 class Simplifier
*icObj.type = "simplifyZone" : when icMathNode is inside, a top layer simplification is attempted every second (comme des coups de marteau, un petit côté maréchal-ferrand)







.
