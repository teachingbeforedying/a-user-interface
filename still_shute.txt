04 décembre 2020: initial morning program based on https://github.com/TomHumphries/InfiniteCanvasWhiteboard

0 create zoom loops

*	0 there is so much space, that one can hide messages in the vast infinity

05 décembre 2020:
0 échelle
  0 double flèche

0 parcours
	0 arbre
	0 notation 0-20 : nb_questions = n(n-1)/2 = 190

06 décembre 2020:

0 Arrow:
  0 "horizontal arrow" : 10 fois plus loin
  0 "vertical arrow"   : 10 fois plus grand
  0 "oblique arrow"    : itinéraire (ou mesure)

0 "les deux amoureux" (each is on a planet)
0 itinéraire:
    0 select pointA, pointB
    0 draw arrow
      0 orientation automatique de la flèche représentant l'ordre de grandeur courant en fonction de la flèche "itinéraire"
    0 find order of magnitude and "get there" (show the arrow with the "right size" wrt screen)

0 from question A to question B:
	0 create line from A to B and follow it in the direction of the arrow till you meet the next exercise
	0 warp

0 from question A,B and C to question D:
	0 triangulate

0 PAUL's vision:
  deux calculs
    L'abscisse est la réponse à la question 1
    L'ordonnée est la réponse à la question 2
    Abscisse et ordonnée par rapport au _repère courant_

    avec un repérage "A1":
    on peut utiliser les préfixes comme indicateur de colonne

  tableau d'un peintre: fractale

11 décembre 2020:

**0 import pdf

0 workflow :
		0 import mind map pdf
		0	enrich the map by adding
				0 neurohandle images : a goat, a lion,
					0 associate biome to zoomLevel
				0	content inside those neurohandles : exercices, problems, figures...

* 0 hardcore : zoom trap : when zooming out, user does not get to previous scene, but sees zoomed out current scene

14 Décembre 2020:
**Z-PUZZLE: bring object back to its corresponding slot (object can be extended, shrinked)
		0 click and scroll to change size
			0 long click| long press to lock obj selection

15 Décembre 2020:

**Z-Puzzle avec des carrés : inscrire un nombre dans le carré, avec une double flèche pour indiquer la longueur du côté, _à l'intérieur_

0 Z-Puzzle Logo : write Z-Puzzle with squares of different sizes

0 WOW effects :
  0 puzzle pieces are on a blue background : blue background is only a small (blue) part of a big piece of the puzzle
  0 puzzle pieces are on a table : the table is a part of a big piece of the puzzle

16 Décembre 2020:
	0 puzzle creation :
		0 image split
		0 create puzzle piece using cutting path

	0 commencer par un petit Z-puzzle à 4 pièces :
			initialisation : toutes les pièces sont carrés, de la même taille, de couleur différentes avec un numéro différent (1,2,3 ou 4)
			le slot pour le numéro 1 est très grand, on voit dans la vue initiale un petit morceau de bordure de 1
			le slot pour le numéro 2 est de taille initiale
			le slot pour le numéro 3 est petit mais on peut y arriver avec un resize classique
			le slot pour le numéro quatre est très petit

17 décembre 2020:

	idées:
	0 movable/unmovable objects : bg objects vs interaction objects
	0 z-index should (/may) decrease when object gets bigger (imagine an image of the universe which was contained in a house window)
	0 group/ungroup when z-scrolling inner element

	0 inno_further:
		0 double object: {front layer, back layer}
				front layer displayed when scale <= x
				back  layer displayed when scale > x
				example: closed window / open window
				=> 0 calendrier de l'avent

			0 living object: front layer may change if something has been done "inside" object (i.e. when scale > x)


	0 edu:

		0 numbers fractal :   [             9              ]
	                        [0][1][2][3][4][5][6][7][8][9]
													etc.
													il y a le zero-level : avec [0,][1,][2,][3,][4,][5,][6,][7,][8,][9,]

		0 10^n rectangles       _____________________________________________________________________________________________________
														[                                  10^n                                                             ]
														-----------------------------------------------------------------------------------------------------

														__________
	                        	[10^(n-1)]
														----------

		0 double layer numbers :
		 		front
										[             ]
										[      9      ]
										[             ]
				back
										[  1   2   3  ]
										[  4   5   6  ]
										[  7   8   9  ]


19 décembre 2020:

*	0 remanent points : center point for rotation is displayed then fades when rotation is done

*	0 complex animations :
		0 X-wing : zoom-in + centered rotate
		0 spiral staircase : zoom-in + non-centered rotate

** 0 animated objects : endless spinning wheel, endless translation
*			0 user could force software to adopt moving object's referential

** 0 temporal active objects :
		  0 calendrier de l'avent : mettre un timer dans le programme pour que les fenêtres (==double object) ne soit "ouvrables"(==pénétrables) que lorsque le jour est passé
      0 devoir maison : le sujet n'est plus accessible après
      0 interro : time frames

    0 edu:
				three sectors : course material plane is divided:
					green sector  : easy : for everyone
					orange sector : moderate : for almost everyone
					black  sector : serious : for strong pupils

					students can rotate the wheel to access to stronger content

    0 un z-puzzle simple:
			des carrés de couleur

    0 z-puzzle with reflection : negative scale

    0 snapping:
			0 move
			0 resize
			0 rotate
			0 what is the right snapping percentage ?

20 décembre 2020:
  edu:
    bien affcher la taille et la position du rectangle d'observation

  zpuzzle:
    0 droite graduée et profil affine (carré de différentes tailles)
      un humain près du 1 (1 mètre)

    0 z-puzzle : telephone
        7  8   9
        4  []  6
        1  2   3

    0 colored squares with dimensions
  			0 format : factor    x     power of ten
    			[---------]
    			[<------->]
    			[   3,8   ]
    			[    x    ]
    			[ 10^(-2) ]
    			[_________]
        0 need _reference_ arrow

    0 more complex: no reference is shown : pupil has to use relative sizes to solve puzzle

** z-scroll, r-scroll, etc. is only about placing the selected object in _a different ("hovering") layer_, and then dropping it in the original layer
    maybe code would be cleaner if it was done this way
*   => hovering layer is the player's backpack (multiple objects could travel along)


* ((double puzzle: recto / verso


*  basic exercice course:
    exercise n:
      - image (funny)
      - statement (less funny ^^)
      - answer text field:
          on right answer : open exercise n+1 door etc.

** OUR WEBSITE : students' have a website consisting of an infinishute
     every student can have its own miniverse in the infinite vastness

* animation: pov path  : from pov1 to pov2 to pov3 to pov4 etc.
    edu: séquence de mémorisation


*[
	Keyboard shortcuts:
			F: Rect          F for fabric
      Shift F: Toggle object.reactor on/off
			T: Text
      Shift T: Tag
			X: Point         "cross"  (if   nothing is selected)
         OR: sameHomeScaleClone (if something is selected)
             Shift X: geminiShade
      D: Droite                 (if   nothing is selected)
         Decoration Begin/End   (if something is selected)

      Q: Circle        Q looks like O
      W/N: Polyline    W/N is a polyline

      M:       Measurement arrow  (depends on context orientation)
        ? + M: greatest length
        ? + M: smallest length

      G: Group
      B: Ungroup       "Break group"
            (special: toggle .isMobile of selected composite part)
      Shift G: Compose
        Shift Alt G: Compose (special)  (je ne sais plus à quoi je pensais quand j'ai écrit ça...)
        Shift ² G: Compose: create equation
      Shift B: Decompose

      Alt G: Link
      Alt B: Unlink

      Shift + move:
            (special: force move of selected composite part (== make as if it were .isMobile == true))

      "!": Show object types (KeyDown (toggle)) (on peut voir (via une bordure spéciale par exemple) les composites, les groupes, les objets normaux, etc.)
      ",": Split active object (==object in supervessel, be it currently held (mousedown) or simply selected)
      ";": Join active objects (==objects in supervessel)
      "_": Toggle icObj.isTouchable

      A: zoom out (KeyDown (timeout))     "Away"
      Z: zoom in  (KeyDown (timeout))
      Shift A: zoom out (/10)
      Shift Z: zoom in  (x10)

			R: Rotate   (KeyDown (toggle))
			C: Color    (KeyDown (toggle))
        ² + C :         pick color at cursor (canvas "global")
        Shift + ² + C : pick color at cursor (canvas fObj in front)
        ?unknown shortcut?: pick color at cursor (document global)
      V: Opacity  (KeyDown (toggle))
      W: StrokeWidth   (KeyDown (toggle))
      "²": FreeDrawing (KeyDown (toggle))
        Shift "²": FreeDrawing group (group parts)
        <unknown shortcut>: Evanescent FreeDrawing
        <unknown shortcut>: Sticky FreeDrawing
        Alt "²": cosmetic FreeDrawing (== (.isCosmetic == true))
          maybe "isCosmetic" should have a reserved keyDownToggle, in order to spawn objects _of any type_ with .isCosmetic true or false
      <: Category (KeyDown (toggle))      (this will allow: selectNextObject(activeCategory), selectAllObjects(activeCategory)...)
      &/1: Cursor (KeyDown (toggle))      (this will allow: click on obj VS select obj and then move it)
      X: Context orientation (KeyDown (toggle))   (horizontal, vertical, ltrb diagonal, rtlb diagonal)
      "^": Landing stage (KeyDown toggle): new objects spawn in landing stage (object or infiniteCanvas, or infiniteCanvas.layerX))

      H: Homescale for new objects (KeyUp (toggle))
      Shift H: save homeScale to preset.homeScale

      CTRL + 0: move to origin pov
      digit<n> move to pov<n>

      Y: Z-Puzzle slot
      P: Create Platform
      Shift P: Create ProtoSlot

      E : Activate (maybe mouse click is more intuitive)
      E(long press): toggle reactive version

      S: Save all              (when nothing held)
         Toggle Sticky Release (when something held)
      Shift S: save selection
      L: Load

      Esc: cancel current behavior (for example Sticky Release)

      ← ↑ → ↓: move active selection

      +/-: "Time" control: accelerate, slow down (KeyDown (toggle) == as in game consoles emulators)

      debug:
        Toggle Supervessel (KeyUp (toggle))

  Keyboard+Mouse:
    rightMouseDown + zoomIn/Out   keeps screenRect centered on object while zoomingIn/Out
    Shift + scale via side controls: unitCloneScale

ET LES GAUCHERS ALORS ?...

*]

1 keyZ: zoom-in to cursor / zoom-out
  "KeyW" : get aWay
  "KeyE" : "Enter"/"Explore" : zoom-in
  1 keyDownTimeout
  0 keyDownTimeout VS keyDown: complex mgmt to only zoom once when key is "simply" down-up'd (== ? pressed ?)
**		=> problem "vanishes" when timeout delay is 17 ms (== "small enough")

** sometimes it all adds up nicely (==resulting feature): rightMouseDown + zoomIn/Out keeps screenRect centered on object (this is a nice feature which should be preserved)

* antialias "pixel fight" when zoomingIn is like Heisenberg's principle, it's more and more shaking

** edu: le petit poucet de Gulliver : semer des petits cailloux à chaque niveau de zoom pour ne pas se perdre
    => les amener à comprendre la notation décimale
**    on "remonte" un nombre comme par exemple 14758,1654873    (on part du niveau de zoom)
** avoir un affichage spécifique pour les "zéros facultatifs" (que ce soient ceux qui sont à gauche ou à droite de la virgule)
    0 affichage additif (on affiche le nombre sous la forme sigma(ai x 10^i))

    0 representations:
      0 square representation : I don't like this one because it may override what we try to teach regarding areas
      1 rectangle representation : better
**      1 "representation 74" (xylophone representation) (width does not matter, only height matters)
*         0 704 : write "0" when no column is filled
            0 fill remaining space in black and write "0" when no column is filled
*         0 add double arrow (as separator) : double arrow size depends on select number, to show that only height matters
          0 show |10^<n> sector| on top of each xyloblock
*         0 show addition of two number with this representation
            0 two "lines" (is this possible ? (yes, if all towers have same height))
            0 abaccus way
*         0 allow user to type number and draw corresponding representation
            => 0 exercise : type the number corresponding to the displayed representation
                0 easy:           183,01
                0 standard:   140 015,3
                0 hard:     1 000 000,000 028
*         0 allow user to select rectangles and show corresponding number
            => 0 exercise : select rectangles to represent the number 157,005408
                 0 show "current number: ...."
                        "target        : ...."
          0 negative numbers : upside down
            0 show addition of positive and negative number
          0 show sqrt(2)
          0 square product of two xylos
            0 show sqrt(2) * sqrt(2)
          0 xylophone number char representation: small 1, bigger 2, even bigger 3 etc.
*       0 representation "empire state building" : pile up all rectangles
          0 with rectangles
          0 with real-life objects rectangles
          0 add corresponding power of ten square [10^<n>] next to the xyloblock
*       0 representation fallen skyscraper : empire state building goes horizontal
          0 with rectangles
          0 with real-life objects rectangles
        0 animation:
          0 from xylophone to empire state building
          0 from empire state building to fallen skyscraper
**          0 Wow effect: la virgule tournée dont on ne comprend pas au départ la signification, revient dans le bon sens pour former l'écriture décimale du nombre (écriture décimale "pondérée")
        (0 representation "closest square puzzle"
      0 sum of scientific notations (sigma(ai x 10^i))
      0 exponential-carried representation (logarithmic scaleX)
      0 fractal path representation ("5,1 c'est un bonhomme et un petit poisson"): each square has BL = (0 ; 0) and BR = (10^<n> ; 0)
        0 create "trailing part" only when "tower" becomes active (or else number of objects will grow exponentially)
      0 représentation en aire: essayer de montrer un remplissage des xylorects de telle manière que le nombre représenté corresponde à la somme des aires

    0 "vous avez débloqué un nouveau secteur : partie décimale"


  0 colored numbers:
*   0 zero could have transparent color ("container")
*   0 non used level number could have very low opacity (but we could still seem them)
*     0 write "0" when no column is filled

  0 power of ten : patterns
    each power of ten has a characteristic filling pattern (example: hearts, diamonds,  ... , cars, cells, ... )



pour la multiplication de deux nombres :
  représentation en surface d'un nombre : on prend arbitrairement un des deux comme 'multiplicateur' et l'autre comme la surface à multiplier
  attention : multiplier une surface par 2 : simplement prendre deux instances de la surface initiale et les accoler

  0 mécanique de précision : trouver la pièce complémentaire

*** zoom-bound freeDrawing text reading animation

21 décembre 2020:
  une séance préparée pour 1 heure pour 24 élèves VS un programme pour x heures pour 10^n élèves

* un nombre (fini), c'est un parcours (fini) sur une fractale.

  0 show sqrt(2) * sqrt(2)

  0 make it sexy
    0 round corners
    0 "this thing is living" animations


*  0 raster and vector DUO: one window infiniteCanvas, the other paint.net : copy/paste images to and fro

  0 applications:
    0 une année de 4ème:
      0 tangram cat :
        0 translation only :
*         0 unrotatable fObj
          0 unscalable  fObj
            0 fixed scaleX|Y
            0 fixed homeScale

    0 une carte de mes voyages

    0 C-puzzle ("create objects" puzzle) : "recrée avec des formes l'image suivante"

** icObj.type = "url" : open new tab on click
      0 move to next exercise
*  icObj.type = "video"
*	 icObj.type = "webcam"

0 ne pas vouloir trop en faire pour le moment, rester sur quelque chose de simple

22 décembre 2020:
  Internet exists :
*   0 Z-puzzle : have players go find the puzzle pieces (==images to paste on canvas) on the Internet
**  0 CTRL-F on a webCanvasPage

* object wells: click and drag on object well to get an instance
    0 static
    0 animated object wells : le triangle rectangle qui tire des carrés qui disparaissent dans un portail cicatrice, on peut attraper le carré au vol

LES FAIRE FAIRE => il faut qu'ils utilisent l'éditeur à un moment donné

* représenter l'espace mental alloué dans l'infiniteCanvas : FORTNITE en gros et Mathématiques en tout tout petit

* le code informatique est lui aussi quelque chose de "moderne", dans le sens où il est porté par une fractale (à la différence du "plain text" (si on ne prend pas en compte les références littéraires ou culturelles))

* Le cours de la 4ème<X>:
    at start of class, file is opened
    during class,      content is edited
    at end of class,   file is saved

23 décembre 2020:
* La même chose avec les fractions : utiliser l'infinite canvas pour montrer les fractions
    0 enchaînements alternés de découpages verticaux puis horizontaux etc.

* "Nombres en boutons"(== xylophone, fractal rep, etc.)::Somme
    positive side is immutable : get to target number using only negative side buttons (target = negative + positive)
* Probabilités avec les nombres en boutons de fabriquer le nombre N ?

** infiniteCanvas editor is a place for students to run algorithms by hand (? ideal sandbox ?)
    example: create Koch snowflake
    example: create Sierpinski's triangle

    exemple: trier un jeu de cartes...

* skewing exists in fabric => easy parallelograms from square
* Skewing allow easy creation of "big-to-small arrows" from standard arrows

* le project, c'est peut-être augmenter la boîte à outils numériques des élèves :
    - Scratch
    - Geogebra
    - Tableur
    - Infinite Canvas Whiteboard

* visualisation/manipulation des homothéties avec un object well et le zScroll
    Z-Puzzles sur les homothéties


* icObj types:
    [
      //primitive
      rect
      text
      circle

      //composite
      group (== anonymous composite)
      groupWithBgRect (bg rect will allow stroke and fill (== border and backgroundColor))
      card
      doubleObject
    ]

* z-puzzle : user must create group with objects ( zSlot only accepts group with particular properties)

* workingHomeScale : this would allow easy drawing of architectural planes

** mScroll (est-ce que ça a la moindre utilité ?)


** light-sending (== eye-catching) objects : no matter what current infiniteCanvas.scale is, a star grows from object so that it is visible at current infiniteCanvas.scale

** marker objects (on revient au côté whiteboard): those objects are like the other canvas objects, but they are not designed to stay, they are here to ease explanations
    0 toggle show marker objects
    0 clear marker objects

* animation: décollage de fusée
* l'infiniteCanvas permet de matérialiser des expressions du genre "étudier en profondeur" ou "un savoir superficiel"
* presentation : standard "infinite fall" story carrier: each story item is displayed on a square at zoom level n

* dynamic fabric object which parts pop and destruct along with the current pov (follow the yellow road) (this way an infinite object (like an axis) still can be represented)

24 décembre 2020:
* Lien entre le xylophone et les z-puzzles : La balance: target weight / current weight  (peser une planète sur une balance, c'est irréaliste, mais bon...)
**   paradrop:
        "updward" z-scroll(the only available) momentaneously changes object homeScale but object falls down to its natural homescale when released
        sparkle indicates where small object is (if user wants to remove it from the scale(==balance))

*edu: angle pas droit: glisser un éléphant dans l'espace intersticiel et ajouter un commentaire à côté "regarde, l'angle est tellement pas droit, qu'on a pu y ajouter un éléphant"

**  student may ask for hint:
      sparkle (light-sender)
      Arrow indicator in HUD ("in this direction, there may be something useful")
        hide arrow indicator when user is "in the object surroundings"
        additionnal upward/downward arrow to avoid using too many sparkles

** Le multiplicateur :
      un objet est sélectionné
      l'utilisateur choisit le type de multiplication : longueurs ou aire
      un nouvel objet est créé selon la multiplication

** Le guide âne pour montrer les découpes de fractions

* xylophone : 10^<n> zone : "nombre sélectionné dans cette zone" : donner plusieurs écritures
    exemples:
      5 x 10^4 : 50 000
      2 x 10^(-3) = 0,002
** /!\ aux erreurs d'arrondi quand on demande à l'ordi de sommer tous les termes
    updateActiveNumber 0.7000000000000001 (when only "sharp 0.7" is active...)
      => use string type
      OR
      => use Math library

** Comment faire pour débugger quand il n'y aura plus de logs pour avoir la meilleure performance possible ?

* zéro est un nombre comme les autres : créer une autre version du xylophone avec le zéro selectionnable et pas de toggle isActive sur les xylophone towers
    (le xylophone vanilla à un zéro "absence")

** xylo abaccus: manage temporary multiple active towers in xyloZone : show timer 3,2,1 and then resolve chaos and bring back order. This can involve cascade updates.

** il y a des problèmes que la civilisation se pose à elle-même : pourquoi avoir gardé le système de position des nombres de la droite vers la gauche alors que l'on lit de gauche à droite en occident ?
    parce que du coup, on se retrouve avec une droite graduée, qui va "dans le mauvais sens"

**xyloSynth: user types number and xylo updates accordingly (though we can't see much with standard xylo) (exponential xylo will be more readable)

* black is a strong color : black zero in xylophone catches the eye a lot, is it a good idea ?

** multiplication de deux segments colorés : utiliser des gradients pour former un damier
    _[___|___|___] segment3, couleur3
   | |
   |_|   à l'intérieur, chaque rectangle (ou carré en fait) est colorié avec un gradient de manière à former un damier (on voit n x m carrés, et on voit que leur couleur c'est un mélange de couleur_n et de couleur_m)
   | |
   [_|
  segment2, couleur2

25 décembre 2020:
* xylophone: ? add sounds ? (en base 9 on peut faire do ré mi fa sol la si do)
  0 ECRIRE EN GROS : ~ 5x homeScale

  *zPuzzle: piecewise hints:
    "la pièce n°2 se trouve au coordonées : x = ...   y = ..." et la position courante est affichée dans le HUD ->> l'élève peut chercher à tatons


** all is there : everything on the same canvas (~The Witness)
      remarque: le xylophone prend déjà une bonne partie de la place
** metagame : stars: get all 20|120 stars (comme dans Mario)
      3 stars for every minigame: easy, medium, hard (ces étoiles apparaissent dans un écrin de verre qu'on enlève en réussissant l'exercice)
**    étoiles d'exploration : some starts are there for the taking

   metagame: completing exercise X gives a puzzle piece for completing exercise Y
***    par exemple des xyloTowers ("touches de xylophone") pour pouvoir écrire des nombres qu'on ne pouvait pas écrire avant (ce qui fait le lien entre (z-)puzzle et xylophone (la xyloTower ne change pas de taille (pour ne pas trop perturber le joueur (au moins au début))))
          ce qui ferait du xylophone un objet central, sur lequel le joueur reviendrait plusieurs fois,
          et qui donnerait au jeu une saveur à la The Witness (autrement dit, une saveur exceptionnelle)
          ou par exemple des xylozones incomplètes aussi, ou même des xylozones adjacentes collées entre-elles (tout un secteur de puissances)
          ou aussi des xylozones avec les xyloTowers qui sont pas mises dans le bon ordre et qu'il faut remettre dans l'ordre avant de pouvoir les utiliser

  (0 beautiful xyloZone : perroquet: oeil(zéro) et ailes(1-9)

**  units converter : user types number and (unit_from; unit_to) and:
      1. the two unit-bound xyloZones are highlighted, unit_from with red border and unit_to with green border for example
      2. each xyloZonePerception has two lines : one for the number expressed in unit_from and the other in unit_to
      so user sees it's only a shift (when units are "scalar units")

*	ne pas réinventer la roue : https://mikemcl.github.io/decimal.js/ (javascript numbers have limited precision)

** separate 10+ mantissa numbers when writing string rep: separator |, or bracketing [] (instead of having to create symbols (we don't write A for 10, we write 10| or [10]))
    + write which base is used (cela va de soi)

* remplacer le point de la notation anglo-saxone par la virgule
** toutes les zones ramenées à unitZone.homeScale: afficher des agrandissements/réductions des différentes zones (un truc avec des lignes à moitié diagonales) pour arriver à un affichage de la somme des composantes à homeScale == unitZone.homeScale

* xylophone: fading optional zeros for decimal number : zero "inside" !!= zero "outside" (==optional) (concept mathémtique: chiffres significatifs)
* xylophone: cadenas à code pour xyloShow: user inputs number via scrollable cylinders

* 0 make xylophone dynamically infinite (destroy/create zones around current scale)

*:'( 2D canvas does not allow non-parallel skewing (~"scale traversing" objects)
    => use a 3D library to have:
      -scale traversing arrows
      -"pov aware" objects (==orienting sprites (as in paper mario))

26 décembre 2020:
***( un hyperlien, c'est juste un portail (dans le sens Portal)
      tous les portails de l'infiniteCanvas sont à sens unique (impossible de se retourner dans un espace 2D et aussi: un portail n'a pas d'épaisseur)
* traverse portal while zScrolling (==while "carrying" object)

* Build Empire State Building tower (ESB tower) with xyloTowers
  =>
* size-preserving z-scroll

** power fractals:
    squares
      8 8 8 8
      8 8 8 8 etc.
      2 2 4 4
      1 1 4 4
    staircase
      1
      [1] [1]
      [2   2] [2   2]
      [4   4   4   4] [4   4   4   4]
      etc.

** 0 Flat xylophone
    0 additions
    0 multiplication: scale "multiplier xylophone" so that the result's area equals B times A's area
      flatXyloB * flatXyloA
  A->   [   1   ]
       2[   1   ]
       2[   1   ]

       ^
       |
       B

*" en fait, y'a que des fractales partout, des conteneurs dans des conteneurs dans des conteneurs, etc. etc. etc.
*" je suis pas idéaliste ; mes idées, je sais qu'elles sont réalisables. (et je le sais parce que "ça" a infusé en moi)
*" l'infiniteCanvas, c'est juste un espace dimensionné pour notre discipline (autrement dit un espace infini)

** toutes ces fractales prennent beaucoup de place, si je pouvais mettre des canvas dans des doubleObjects, ce serait moins encombré, on serait plus à l'aise. Et ce serait davantage rangé. ça ferait comme les niveaux dans Mario64.

*** OPEN YOUR MIND (== "the world from a slit" / "THIS IS UNKNOWN TERRITORY"): initially, the player can only only see a small (_yet infinite_) part of the canvas, because there is a slit and the rest is black and filled with "unknown territory" labels
      open your mind animation: move to slit pov and show user that the slit is growing to a new size (/mutating to a new shape ?)
      -idée de scène initiale:  la caverne de Platon, et ensuite la personne se retourne (grosse animation, stupeur, mydriase etc.)

* a universe in ceiling cat's left eye

** "eye in eye" sequence: reversed image in retina: someone looks to someone which looks to someone, etc.

** entire book in canvas
** entire books : the Library

** time picture frame tunnel:
      __________
      |1940
      |    ______
      |    |1941
      |    |
              ...

* 0 trouver un moyen de symboliser "cette pièce est/n'est pas z-scrollable (i.e. "cette pièce à une taille fixe")"

** z-puzzle: arbre de calcul interactif: targetNumber,currentNumber
      easy: pieces == numbers
      normal: pieces == operators
      hard : pieces == numbers & operators
      => need graph library
        ? https://github.com/anvaka/ngraph.fabric

** z-puzzle: remettre les noms d'objets au bon endroit étant données telles et telles propriétes
    exemple:

** pour le calcul mental: parcours avec un timer: il faut aller récupérer le trésor caché profond en entrant succesivement dans des portes. Si le joueur met trop de temps il est ejecté (zoom-out animation) jusqu'à la porte de départ.
      la zoom-out animation doit être un peu costaude à coder non ?
      en cas de succès : collecter automatiquement l'étoile pour ne pas frustrer le joueur qui avait réussi à la débloquer ?

*[
  mini game ideas so far:
    xylo_write
    xylo_read
    z-puzzle: classic
    (z-)puzzle: arbre de calcul
    (z-)puzzle: range les nombres dans l'ordre croissant (on peut donner une sorte d'indice en mettant un mini xylo la tête en bas pour les nombres négatifs)
    (z-)puzzle: geometry: object names
    z-puzzle: citizenship/society: remettre les choses à la bonne taille
      par exemple: on écrit en grand "MOI"    et en petit "les autres", pour représenter l'individualisme
                   on écrit en grand "DROITS" et en petit "devoirs",    pour représenter l'oubli fréquent du lien entre les deux aspects de la loi
                   le joueur doit rétablir l'équilibre, c'est-à-dire la même taille pour les deux objets

    timeout travel: standard (pour exercer la mémoire, genre "active l'interrupteur à côté de la mouche", "maintenant, active l'interrupteur à côté de Y")
      on timeout write "time expired" and "you hear a door closing" to warn player that they'll have to start again back from the start
    timeout travel: deeper and deeper: calcul mental
    c-puzzle: évaluer des expressions
      - priorités opératoires
      - nombres relatifs
      - expressions littérales
    s-puzzle: ???
    P-puzzle: géométrie
    greenMouse
    Indiana's path
    bulletMouse
    bulletGolf

  wow-effects:
    a small part of a big piece is visible on the side of the screen
    piece already in slot but very very small
    slot hidden in piece

  big-picture:
    build numbers with only 1 to start with
    xylo recomposition (== (re)compose challenge input)
    zPuzzle zTraveler recomposition: to complete z-Puzzle, you have to 'activate'/'enable' all z-Travelers
      like the laser beams opening mountain top in The Witness
      there will be a "moutain top" sensation when all z-travelers recompose the mountain top challenge
    "complete by repairing":
      "pebbles in the shoe":
        conductive operator seems broken (reason is: super small operand is inside conductive area so that apparent binary operation is actually involving three operands)
          completing another challenge may give the location of this "~hidden" (pebble) operand
          player "repairs" the operator by moving the pebble out of conductive area
          This pebble could be of use somewhere else...

    familiarisation progressive avec les "objets concepts" (comme les symboles dans The Witness)

    unlocked challenges :
      diy: when puzzle is completed, it can set up a challenge
      dust off: when covering challenge is completed, it reveals the covered challenge
      multikey: when challenge is completed, the multikey that was used is unlocked and can be used elsewhere
    unlocked recomposition component:
      unlocked challenge piece:
        movable:
          standard piece
        unmovable:
          zTraveler (unmovable yet moving)
      R-Puzzle target may be a patchwork which turns into an operator when completed
    unlocked "skills":
      object wells:
        numbers
        operators (for example: a well that generates operator "+" puzzle pieces)
        geometric figures
      transformations:
        rotate
        machines:
          x10
          /10
          clone
        keyboard shortcuts: player gradually learns "new keyboard keys"
    unlocking always happens via the same artifact (see: xylo-unlock)
    unlocked areas:
      Alice system
      "horizontal" areas (à la The Witness)

    unlocked:indirect key:
      xylo-unlock: player successfully completes a greenMouse challenge, then a number is given to them and they have to type it via the xylophone to unlock next thing

    unlocked places:
      "open your mind" system
      canvas-container double object (an entire fresh canvas in your fridge or bedroom window)
        and portals to get back to "home canvas"
      "<n> <X> required" door locks
      once Z|S|C-puzzle is complete, it transforms into a doubleObject or a portal (castle door for example)
      password (or hint or directions) hidden behind puzzle (player has to dismantle it in order to see the message behind (==l'étoile des douze coups de midi))

    geometrical puzzles inside number shapes
      ((construit un nombre 1 qui ait pour aire 1
      ((construit un nombre 2 qui ait pour aire 2

    co-challenges: challenges can only be solved by progressing alternatively in one and the other
      example: solving greenMouse challenge make sparkle appear(which indicates z-puzzle piece location) and putting piece in slot makes sparkle appear which indicates greenMouse challenge is renewed

      digitWell: a many-digit number can be transformed into nb_digits wells, each yielding the corresponding digit (exemple: de 7891, on pourra extraire [7] [8] [9] et [1])
        on peut créer des co-challenges qui font évoluer le "nombre puits" au fur et à mesure (c'est prometteur mais il va falloir se prendre la tête pour faire un "level design" qui soit goûtu)

  tool ideas so far:
    xylo_show
    ESB scroller with 'scroll increment = f(scale)'
    pythagore_show (avec des carrés)
    photograph: take picture of current rect and create puzzle piece or icImage from it
    clone tool
    repaint tool: input slot, color parameter --> output slot
    common multiples grid
    le répartiteur: user creates a partition of a 100% box and can then drag any collection or number that will be divided into different output boxes with the right proportions
    area of numbers (2 has area 2, 123 has area 123 (1 has area 100, 2 has area 20 and 3 has area 3))
    protractor
    redMouse calculator (a redMouse doesn't die when released anywhere)
    solution writer assistant: as in Scratch: writing a solution would involve selecting blocks and putting them together
    clock_simplifier: perform simplification of mathematical expression at each clock tick
    The Mirror: what happens on bottom screen happens in mirror on top screen, _in a different _representation system_ _
      example:
        bottom screen: expressions       //     top screen: bag of numbers
        bottom screen: fractions         //     top screen: colored rectangles ('fractions for kids')
    Frac_add

  edu:
    slow building of year's z-puzzle by getting puzzle piece for each part of year's course when done (slow compositing)
    difficulty gradient:
      Say we want children to try a particular challenge type 20 times, first instance will be easy, then there will be a gradient of easy/medium/hard till the last instance which will be hard
    prevent bruteforcing by increasing nb_challenges_todo when bruteforcing is detected


]*

* xylophone for hours/minutes/seconds:

* pythagore_show: show squares (use same "reference square" in all three squares)

* essayer un xylophone compact avec les chiffres en mode photo de classe (est-ce que ça va pas faire un peu abrupte ?)

* once again: make it sexy
    0 papier peint "pattern" sur les xylophoneTowers

** showing before dying : avoir un z-puzzle basique à montrer à Paul

** Hue(==anti-sparkle): object opacity getting stronger as we get closer
    trois parfums:
      glassPlaque: only scale matters, (x,y) doesn't matter
      Clameur: obj is "localized" around a particular(x,y,scale) ("nearer, we hear better")
      spook: it disappears when getting too close

** S-Puzzle: slot-only puzzle : user has to enter slot and complete task for slot to fill with completed state (typically, the slot becomes colorful, hence the name)
** C-puzzle: colorize puzzle: user has color palette and must color areas corresponding to number

27 décembre 2020:
** user created sparkles : SparkleMarker:
    - pour se repérer: "true"SparkleMarker
    - pour effectuer des mesures : l'outil mesure peut prendre en entrée des SparkleMarkers, ou créer des sparkleMarker

** edu: choix pédagogique pour les représentations: moi j'aime mon xylophone, mais d'autres préfèreront une autre représentation, libre à eux d'utiliser la représentation qui leur convient, étant donné qu'enseigner, c'est enseigner ce que l'on est.

* save game state: some objects don't need to be saved (since they are generated automatically when page loads)

*PAUL:
  un repère orthonormé pour chaque xyloZone, pourquoi pas, un seul axe en fait, l'axe important, l'axe des ordonnées avec 1 2 3 4 5 6 7 8 9
  z-puzzle: slot avec 1.47 x 10^-3 qui fait écho au papier peint des xyloTowers

* machine à x10, machine à /10 : un slot d'entrée et un slot de sortie

** écrire "taille normale: ..." et surtout _"agrandissement: ..."_ sur une zPièce pour bien montrer que ce n'est pas la taille normale de la pièce

* tous les élèves évoluant sur le même canvas: quel intérêt ? (à part du showoff client-serveur)
    compétition:
      -dynamic leaderboard (ce serait une sorte de course, on pourrait repasser 1er, ou être maintenant 3ème etc.)
    coopération:
      se partager les tâches: ~escape game (il faudrait que les élèves commencent à des endroits différents)

* photograph: take picture of current rect and create puzzle piece or icImage from it: this way user can create keyFrames to create a comic book page

* geometric puzzle: overlapping slots: pieceX has pointA, pointB, pointC labels, pieceY has pointB and pointC and pointD labels, so we know where to put it wrt pieceX
**  P-puzzle (==slotless puzzle, ==le bon vieux puzzle des familles): puzzle can only be completed by assembling adjacent pieces

*res: _DK Wonders of Nature_,  incredible source of beautiful natural objects

28 décembre 2020:
  NUIT HORRIBLE MAIS PROLIFIQUE
* create portal KeyP: select from, select to
* create canvas: a portal to another canvas
*   canvas link : move from any canvas to any canvas, example: triangle A <-> B <-> C et C <-> A
      "KeyBack": return to previous (/parent) canvas
* ? web page as fabric object ? (this way I could include a Scratch page for example), ou bien la page de l'ENT

* point and click a la Myst, from room to room: fake immersion with portal buttons (and back button) (actually, all frames are next to each other, but pov creates the immersion effect)

** Bubble sparkle (comme dans les bandes dessinées): "Hey!"
** PNJ: quêtes annexes:
    - remettre les poules dans l'enclos
    - Link(Zelda): je voudrais une épée plus grande ! "Merci, maintenant c'est moi qui ai la plus grosse."
** enemies: some enemies are wandering around and when they lock on player, scroll & move are locked until enemy is destroyed
*( Level and Xp ?

* Z-Memory: like a classic memory game but slots are big and small

* mirrored xylophone (left) + ESB tower (center) + tower fall on graduations(right)
* piano with sound for each piano key (base 8, do ré mi fa sol la si)
* challenge is there but unreadable:
    stains (need to unlock wiper)
    blur   (need to unlock glasses)

** PreviewSparkle: quand on veut embrasser d'un coup d'oeil des objets de taille très différentes

* 728,4�32�001: show empty space or unknown character for missing xylozone digit
* xkcd: put some mini characters here and there a la xkcd
* Z-Puzzle::Tangram
* NightVision/ThermalVision

* Docteur Maboule
* Z-Labyrinth => object is locked inside walls but can shrink/grow with Z-scroll to get to destination or to get out (the existence of a getout narrow passage is only blatant when zoomed):
    fabriquer un système de collision
    (fabriquer un système d'interrupteur et de portes qui s'ouvrent et se ferment (casse-tête)

* canvas world::scale world: a world with gravity which weighs a collection of objects
    target weight: ...
* Z-spook::telephone numpad (layerN is only visible for f(n)<scale<f(n+1) and opacity==1.0 for layerN.homeScale)
* Spook Challenge::constellation: challenge only appears around a certain (x,y,scale)
* (<X>-)puzzle: color on color: hide piece on top of similar object texture (like the chameleon) ("la pièce marron est cachée dans le pelage du chien")
* (color composer: compose color using R,G,B values ( (or using hexcode...))
* Angle-puzzle:telescope: user can set a precise angle (using arbitrary precision graduations) for the telescope and when the angle is the good one, a star can be fetched inside telescope's objective
* L-puzzle: link puzzle: relier les points
* Puzzles géométriques faisables/impossibles:
    faisables: avec un angle droit:
      Pythagore
      Triangle inscrit dans un cercle
    impossibles: avec un angle presque presque droit (il faut zoomer fort pour trouver pourquoi ça ne snappe pas)
      Pythagore
      Triangle inscrit dans un cercle
      ...

**Z-scroll: trace fading animation (so that user sees than the piece is growing or shrinking (or keeping its size (for non z-scrollable objects)))
* puzzle autour des fractions: Tablette de chocolat: 6 rangés de 4 carreaux (Mathieu)
* Localization challenge: select point with coordinates (x,y) or (r, theta)
    many points are put near the target point to show user that they sometimes need precision and zoom in to discriminate

* Le coin informatique:
    Algo-puzzle: user has to select to right operators to get to result
        operators:
          assignation == mutator == set
          evaluation  == accessor = get

* Make it visible:
  Addition: fusion de parcs à moutons
  Multiplication: des moutons avec des moutons à l'intérieur
    ou alors on peut dire que chaque mouton du parc A rêve du parc à moutons B, ce qui fait n x m moutons de rêvés en tout.

* Calculator: missing keys: reassemble it before being able to use it

29 décembre 2020:
  29, c'est déjà un peu plus beau de 28

* code chiffre/son:
    challenge: "712", il faut placer dans slot(=="sertir") un katana

* comptage analogique:
    challenge: "150317": il faut sertir une pièce qui possède 150317 particules dessus
    challenge  "3 jaune/4 rouge": il faut sertir une pièce avec 3 points jaunes et 4 carrés rouges
    challenge: "17": il y a écrit 17 en pointillisme mais il manque deux particules pour faire 17 (le slot est visible, mais subtilement)
    challenge "incomplete rippa: 4/?": double challenge: il y a un outerslot et un inner slot

** Revenir sur les puzzles:
    - soit parce qu'il y a encore des étoiles à récupérer
        Mécanique: correct is good, fast is better
          exemple: le joueur gagne une deuxième étoile en refaisant le z-puzzle en moins de 40 secondes
            cela permet de créer des joueurs qui maîtrisent bien le z-scroll, qui l'ont intégré
    - soit parce qu'on a trouvé la pièce pour l'indice correspondant (MonoZSlotChallenge) (au moment où on a trouvé la pièce, on sait exactement(et c'est vrai) où elle va)
    - soit parce que ça y est on a compris ce qu'il fallait faire (jusque là une(/les) pièce(s) qu'on pensait correspondre à l'indice ne donne(nt) rien: on s'est pris des râteaux)
        exemple typique: le comptage analogique: indice: "150317", pièce à trouver: une pièce qui contient 150317 particules
          le joueur a testé de mettre des objets qu'il pense faire 150317 mètres, de mettre une expression littérale dont le résultat donne peut-être 150317, mais sans succès
          on peut donner un indice au joueur en écrivant 150317 en pointillisme mais le mieux serait de faire ça plus tard

   remarque: les différentes écritures des nombres sont une mine d'or pour créer des challenges

*[
Mécaniques de déroulement: {

  mécaniques:
  couple slot/pièce (SPCouple): une fois que la bonne pièce est snappé dans le slot, le slot s'entoure de vert pour indiquer que c'est bon
  duo indice et SPCouple (MonoZSlotChallenge)
    -l'indice est à côté du SPCouple: classic (outer hint)
    -le SPCouple est dans l'indice:           (container hint)
    -l'indice est écrit dans le slot:         (contained hint)
    -l'indice est écrit dans réparti dans le slot et dans la pièce: (complex contained hint)
  collection de MonoZSlotChallenges avec une logique propre: ZPuzzle
  containerSlot: un slot pour plusieurs pièces ("enclos à poules")
  "greenMouse" piece / vials: "trempez-la dans l'huile, trempez-la dans l'eau, ça fera un escargot tout chaud" (hold click and move around while held: piece mutates while held)
    this will allow user to keep focus, focus being almost captured by the holding down mouse button
    user won't have the possibility to insert a "how about sending a text message to Y ?"-step during the transformation sequence, because _mouse button is held down_.
  fragilePiece(=="fragile greenMouse piece"): => F-Puzzle
    1.user clicks on piece well
    2._while held_, piece can be mutated via mutationAreas (+1, /10, change color, etc.)  (pièces forgées au fil des "trempages")
    3.when piece is dropped:
      if piece is above a slot and corresponds to the slot criteria: piece is kept alive in the slot (slot is filled)
      in any other conditions: piece dies
  fragilePieceTemporarySlot: un avre de paix pour la fragile piece (qui doit peut-être être encore retravaillée), en attendant de rejoindre son slot de destination
  challenge resets when player has made too many attempts (prevent bruteforcing)
  FiniteWell: well will only yield n clones (no more)

  déroulement:
    it would be nice if every new mathematical topic could be introduced by a new puzzle type (this way the user is 'delighted', and could memorize the mathematical topic by remembering the puzzle type)
      en suivant cette logique: faire un challenge mélangeant topicA et topicB serait créer un challenge avec un puzzle mélange de topicA.puzzle et topicB.puzzle

  mutations:
    challenge complété devient:
      slot
      pièce
      challenge
    mutation complexe:
      "step challenge": collection de SPCouples complétés devient une pièce et le challenge "mère" mute également

  wandering around:
    montrer où sont les challenges: NAVI(Zelda) (c'est un objet complexe fabriqué à partir de Sparkle)

  déblocage:
    request:
      from player: player presses "give hint" button
      from game: le jeu demande qu'on donne un indice au joueur
        -à partir d'un certain temps
        -quand le jeu détecte que le joueur commence à être à la traîne par rapport au "peloton"
    les indices en eux-même:
      transformer un indice pour le rendre plus explicite (exemple: pointillisme pour le comptage analogique)
      montrer c'est où:
        sparkle
        HUD arrows
        les cailloux du petit poucet
      montrer un exemple de comment faut faire:
        solution "sèche"
        animation


  revisite:
    Z-puzzle disséminé
    do it faster now / do it real fast now
    color the world: colorier tous les 123 du jeu en rouge,vert,bleu débloque des étoiles (ou une seule étoile si on veut faire un challenge "road to 100% completion")
    the top-down edu principle:
      1. nommer l'objet
      2. rentrer dedans pour étudier ses propriétés

  challenges:
    autour du chiffrement:
      codage
      décodage
    induction:
      objets répétés et emplacement vide: il faut mettre un exemplaire de l'objet répété dans l'emplacement vide
      suites logiques:
        remplir l'emplacement du terme <k>
        remplir l'emplacement du terme général
        suites logiques avec figures géométriques
      fonctions:
        expression
        graphique

  décoration:
    écrire des noms de mathématiciens autour des challenges (+ mettre la photo ?)
      exemples: Sloane pour les suites numériques
                Pascal pour le triangle de Pascal
}
*]

((je le mets histoire de dire, mais je mets pas d'étoile, et j'espère qu'on le mettra pas en place: put the right price on object (on dirait que la raison de pourquoi on l'a pas mis, c'est parce que ce n'est pas stable dans le temps, et on passerait vite à autre chose :))

**philosophie de la montagne(mathématique (ou tout autre discipline)):
    1.reconnaître qu'elle est là, c'est-à-dire la rendre réelle : arrêter de passer au travers comme si elle n'était pas là. D'une certaine manière, la respecter.
    2.Plus on la gravit, plus on peut redescendre en glissant (et prendre de plaisir ce faisant), on peut aussi maintenant faire des figures au dessus des endroits où l'on avait précédemment peiné avec les cordes et piolet et crampons. Une fois qu'on a déjà été une fois à l'altitude h, on peut prendre l'hélicoptère pour y revenir.
    3.une fois qu'on est à l'aise avec un secteur, on peut aider les petits à monter, mais bien sûr, on ne peut pas leur faire prendre l'hélicoptère, sinon pour leur montrer ce qui les attend. (est-ce que ce serait pas quand même du gros spoil bien sale ?)
    4.on peut toujours trouver du nouveau, même dans les secteurs les plus arpentés. ou une couche de neige réconfortante.


** pour les fractions: on pourra diviser par 1000: un rectangle devient 1000 petits rectangles
    combien de 'particules' le système peut-il supporter avant de crasher ?

** edu::pour les 'petits': unités, dixaines, centaines:
    demander à l'élève de construire 2,3,4,5,6,7,8,9,10
    demander à l'élève de construire 20,30,40,50,60,70,80,90,100
    demander à l'élève de construire 200,300,400,500,600,700,800,900,1000
**    bien afficher le fait que 200 contient des conteneurs qui contiennent des unités
**    c'est rébarbatif mais une fois qu'ille l'a fait, normalement, ille commence à avoir une idée du principe des décimaux, et ensuite ille peut passer au xylophone (et placer les nombres qu'ille a construit dans le xylophone)


* snapping: ? écouter la vitesse de la pièce ?

representation system is nice:
  this way the slot could mutate a piece in a blink of a eye:
    0 repaint a piece
    0 change its background texture pattern
    0 change its size
    0 rotate the piece 90° clockwise
    0 its nature
    0 its behavior (activate or deactivate eventListener code)

  0 more complex: change underlying fObj while held: fImage becomes fGroup for example

** relative number piece creation: F-puzzle
    on a un (ou plusieurs) nombre(s) de départ
    on a quelques opérateurs, _mais pas tous_
    et on doit remplir les slots avec des nombres forgés au fil des "trempages"
    exemple: si on a 4 au départ, et que l'on veut fabriquer -10, on trempe la pièce dans "+1" puis dans "x(-2)"
** trempage::équation:    même chose mais on part d'une équation
** trempage::inégalité:   même chose mais on part d'une inégalité
** trempage::encadrement: même chose mais on part d'un encadrement

**When you feel the concrete at the tip of your fingers, when you smell it, when you press your face over rough surface, you might have nice, _sharp_, "concrete-ideas". Otherwise, you might have "far perception-ideas" (which can be nice though, but are too often blurry on closer examination).
    on pourrait même se demander: qu'est-ce qu'on apprécie dans une incarnation ? l'idée qu'elle porte, avant tout ? ou plus simplement, son existence et par conséquent, son interaction avec nous ? (ENCORE UNE FOIS TU VAS TROP LOIN, CHERCHE PAS TROP A FAIRE LE MALIN, RESTE DANS LE BETON MON VIEUX. RAMENE TA FRAISE, JE VAIS TE FAIRE INTERAGIR AVEC UN SAC DE CIMENT. TU VERRAS SI LE POIDS DU SAC EST AVANT TOUT UNE IDEE.)
    Les concrete-ideas, elle se construisent progressivement, avec du concrete. Parfois ça se casse la gueule alors faut reprendre. Dans tous les cas, il faut avoir les mains dedans.
*   Ce qui fait peur, c'est quand on montre des bricolages à des gens qui sont pas du métier. (Toutes ces images complètement trafiquées...)       La réalité, c'est un nez qui coule, c'est un gamin qui pleure.

encore et encore et encore et encore des idées: prout
  est-ce qu'a un moment donné faut dire "stop, tant pis, allez vous faire voir dans un autre cerveau, je vous laisse passer, je vous retiens pas, la sortie c'est par là" ?
    onNewIdea((idea) => {
      //ignore
    })
  tout le temps parler, tout le temps parler, tout le temps parler: prout
  et si on dansait ? et si on écoutait l'Autre ?

* snapping: show that object will be snapped on release (==on drop) (so that user, being informed, chooses to drop it)
* snapping: what would be nice would be to use the norm of a transformation matrix to settle threshold
* snapping: new events: onSnapped, onUnsnapped
* snapping: asymmetrical allowed input size range: 80% - 110% (pour privilégier la fabrication de pièces qui "rentrent")

* on pourrait aussi habituer les élèves, qui savent déjà faire la conversion secondes/minutes/heures/jours/années/siècles/..., à faire la conversion mot/ligne/page/chapitre/livre/armoire/bibliothèque/...

Comme mes élèves, "ils" n'ont rien demandé. Ils se fichent complètement de savoir si la grossesse a été difficile ou pas, de pourquoi j'ai pas avorté. Le rejeton est plutôt agréable ? Tant mieux. Mais personne ne lui a demandé de venir au monde. C'est très étrange, surtout quand on pense à l'attachement que l'on peut avoir pour sa voiture, ou sa planche de skate. C'est moins fun un magasin vide.

* Plus on connaît de représentations, plus on se rapproche du backingObj.

* pov: show active object
* pov: show last action location (object may be deselected but get me to where I was when I last moved it)

** easyFill: _while held_, near enough to slot, object triggers onSnap(or 'onNearSlot', 'onNearEnough'), which leaves piece on slot, mutates held object (for example it can be a bottle of liquid, whose liquid has partially been transfered to the piece occupying slot), so we can continue filling, all in the same drag sequence.
      easyFill could be a simple "leave clone of held object in slot" ('hit and run')
** easyPaint: simple easyFill with color pieces

** bouton réinitialiser semble indispensable pour les challenges avec des effets irréversibles

j'essaye de séparer ce qui relève du jeu et ce qui relève de l'éditeur:
**icObj.snapped et icObj.type = "snapSlot" et icObj.type = "snapGrid" (si l'utilisateur veut une configuration de snap qui lui plaît mieux, il la fabrique lui même avec des snapSlot)
**layoutBag: icObj.flowLayoutBag: icObjects dropped inside automatically arrange in a "top-left if able" manner
    et tous les autres layoutBags auquel on peut naturellement penser
**snapSlot et layoutBag permettent à l'utilisateur de fabriquer des templates de présentation (==des dispositions dont on peut changer les images, les textes, etc., et montrer à l'utilisateur des variations sur un même leitmotiv visuel)
**et du coup, on pourrait relier toutes les instances de dispositions entre elles de manière à pouvoir appliquer des modifs au template qui se répercuteraient sur toutes les instances.
**presentation options: show/hide slots, show/hide layoutBags (c'est moins cracra de faire une présentation quand ils sont cachés)

* res: _Help your kids with Math_ (goldmine)
** montrer un histogramme avec les nombres entiers pour pouvoir ensuite afficher les multiples et les multiples communs
    cela va demander une construction dynamique de l'histogramme
*[
   icObj.type = "dynamicObject"
   icObj.objectsInRect = (rect) => {
    return objects;
   }
*]

** multiplication posée: highlight factors when hovering partial product

** addition de fractions: trouver un dénominateur commun avec une molette en dessous de chaque rectangle (mais attention, il faut pas que les challenge ressemblent trop à un cours de maths)
**   machine à compter les petits carrés: la machine grogne quand il y a des carrés qui ne font pas la même taille dans son "enclos" d'input

** machine à mélanger, machine à démélanger (dilutions)

***SELF-CONTAINED EDITOR: when sending the file to personX, I send the object I want to send, and its editor so personX see the object and then edit it and send me back the new file, so I can see the updated object and edit it etc.
    this would require saving the file in .html, with an object part (json) and an editor part (html/js)
    https://stackoverflow.com/questions/30563157/edit-save-self-modifying-html-document-format-generated-html-javascript
    https://www.reddit.com/r/learnprogramming/comments/4hjz1z/how_can_javascript_in_html_self_modify_and/
    https://github.com/gildas-lormeau/SingleFileZ
    https://github.com/gildas-lormeau/SingleFile
*[
  the dream:
        page.html (zip format)    //facade pour Monsieur Toutlemonde
          lib/                    //intérieur propre pour l'initié
            machin.js
            truc.js
          index.html
          data.json
*]

30 décembre 2020:
  still ideas: à chaque fois je perds du temps à tout recopier, ma pauvre chérie. comment perdre une heure tous les matins.

** flow-machine: la machine déclenche automatiquement la fabrication quand elle a les ingrédients suffisants
**flow-machine::object _fountain_: fountain = well + surrounding pool: when an object leaves the pool, machine automatically creates a new instance so that pool always keeps the same number of elements

* machine:random number machine: cette machine renvoie un nombre au hasard
* machine:random sample machine: cette machine renvoie un clone d'un élément au hazard du pool en input
* machine:random order machine:  cette machine renvoie une liste ordonnée aléatoirement à partir d'un pool en input
* edu: il faut que les machines soit faciles à utiliser, et que les {drags and drop, snap, légère animation de fonctionnement} rendent la chose ludique (__"c'est simple en fait, regarde !"__)


* challenge::chronology (dynamicConstruct timeScale needed)
   example of objects to place: cadillacs and dinosaurs
* challenge::apple tree: the apple to get to is located on a certain branch of the tree. A code is written like 4568541. The idea is to remember the code and press start. Then the player controls an ant, at the foot of the tree, and at each 'crossroads', move to the right branch (first one is 4 for example, next 5 etc.).
* challenge::homothety: select center and ratio (c'est une machine au fonctionnement un peu différent des autres machines ("à slots"))
* challenge::factory: une succession de "flow-machines", bien connectées entre-elles, permet la fabrication d'un objet complexe
    exemple: l'usine à flocons: on part d'une forme simple et on arrive à des flocons (et même une succession random>homothety pour fabriquer des flocons de tailles différentes)
** challenge: find the operator (travailler l'induction):
      il y a une zone d'input, une zone "opérator" (slot dans lequel il faut mettre la bonne pièce), et une zone d'output
      user can try putting in _any input value_, and result automatically displays in output slot
      it's by compiling those (input,ouput) couples that user finally finds the (most probable) matching operator
      greenMouse and vials could be put close, so that input attempts can be done in one held mouse click

* challenge: add parentheses (en fait ça va être assez hardcore à mettre en place je pense)
* challenge: pixel draw puzzle piece (les amener à compter les carreaux)
    easy:   grid has only "unit scale" precision graduations
    medium: grid has "unit to milli" precision graduations
    hard:   grid has arbitrary precision graduations
* challenge: line draw puzzle piece (les amener à comprendre que 1.97 en abscisses, c'est pas 2)
    line end points always snap to grid
    easy:   grid has only "unit scale" precision graduations
    medium: grid has "unit to milli" precision graduations
    hard:   grid has arbitrary precision graduations

* bizarrerie : all same-mantissa xyloTowers leading to same world (portal (montre-t-on à l'utilisateur qu'il passe un portail ou laissons ça 'seamless' ?))

* "self-contained": append datetime to filename so that savedgames look like videogames saved games (you know, when you choose 'load game')
* "self-contained":editable ==> password?
    empêcher les modifications par les petits malins: checksum
      is checksum written in self possible ?
      checksum in editor.js
      checksums everywhere :)
*"self-contained":editable: tool to show edited parts
    pour que je puisse voir si un élève s'amuse à mettre des images de X dans le monde original (bah ouais, vu qu'elle peut être arbitrairement petite faut faire gaffe)

* 9-puzzle with labyrinths: there is a frame for the 9 puzzle precising where start and end are

* edu: amener les élèves à jouer au jeu tous les jours
    exemple de système: day streak star: pour récupérer l'étoile, il faut la recomposer. Chaque jour, la challenge completion donne une fraction d'étoile (un cinquième par exemple). Il faut donc réussir le challenge cinq jours de suite.
* edu: nb max allowed errors: pour éviter que les élèves brute-forcent les exercices. (peut-être qu'il faut les laisser brute-forcer certains exos, que cette répétition peut être utile pédagogiquement, mais certainement pas tous.)
    ou alors on peut dire:
      easy:   infinite nb of attempts
      medium: 3 errors allowed
      hard:   no error allowed
* edu: montre moi que tu as compris: 5 tentatives minium et un taux de réussite supérieur à 3/5, 4/5 ?
    de cette manière: on voit que l'élève a essayé et on voit qu'il a compris ou pas compris
    0 statistiques sur chaque challenge ?

* edu: challenge habillé VS challenge "nu" (==sans aucun texte) (si y'a trop de texte, on va se croire dans un bouquin de maths)
* edu: outil pour analyser la progression de chaque élève
* edu: timestamps for challenge completion to track cheaters and headless-followers
* edu: tolérance:
    geometry: snap when close enough to answer

* edu: mécanisme pour augmenter la difficulté: montrer moins de choses, laisser un peu de calcul mental se faire
        par exemple avec la machine à homothétie: ne pas montrer la figure image intermédiaire quand on bouge le centre de l'homothétie. Indiquer seulement quand c'est bon. (pareil il faudra un peu de snapping dans ce cas, de _tolérance_).

* fractal labyrinth: some sectors are smaller than others, etc.

* sectors : on peut organiser des secteurs autour d'une même thématique
** map: quick access to sectors

* z-puzzle: que l'on soit bien clair: slots could be "z-different" too (et c'est un peu le sel du truc (parce que sinon, une fois que les pièces sont ramenés au même z, ça devient un puzzle classique))

* essayer des xylophones avec rectangles superposés pour avoir une aire valide:
    xylozone:
    [1]
    [ 2 ]
    [   3   ]
    ...
    - le 1 est par dessus le 2, qui est par dessus le 3 etc.,
    - quand on sélectionne une xylotower, elle passe devant et on voit alors que le rectangle fait telle taille
    - la hauteur de tous les rectangles est la même: si la zone est 10^3 alors tous feront 10^3 de hauteur

    0 essayer avec un léger décalage entre les xyloTowers pour qu'on voit dès le départ qu'il y a des rectangles courts et des rectangles longs

* flemme : regarder notes>"notes_a_taper__30_12_2020"

* edu: fil rouge: walking cat: complète le challenge pour que le mur soit détruit et que le chat puisse continuer d'avancer, etc.

** représentation visuelle de la racine carrée:
      fractale de racines carrées en utilisant un triangle rectangle de cathètes 1 et a: l'aire du grand carré sera 1+a².
      même chose avec 2 et a
      (? et en utilisant 10^n et a ?    10^(n/2) et a ?

** transformer un rectangle en carré:
    encore une "fractale" à la shu
      algorithme: 0: prendre le plus carré possible dans le rectangle
                  1+:avec ce qui reste, prendre le plus grand carré possible et 2 rectangles qui vont bien

(( donner comme note à un élève 10^(-2), 10^(-5),... bravo, bel esprit

** greenMouse::GLU: a particular kind of mutation
      the number 7 could be represented by 7 squares glued together
      soaking this representation inside a +2 vial would result in 9 squares glued together

* relative number: [[sign] [absolute value]]

31 décembre 2020:
* multipiece/multislot: le pendant Z game des "unrasterized" groups
    quand on place une multipiece sur un multislot, des slot peuvent être correctement remplis et d'autres non, en gros, c'est pas encore tout à fait correct.
    ça va demander une sorte de tether, de cordée, entre les "atomes"
*   => edu: construire petit à petit une réponse:  l'élève construit sa réponse avec des "atomes" _dépendants_

**_dependance_ : disons que la multipiece contient une pièce "a", et une pièce "2a", alors modifier la valeur de l'un impacte la valeur de l'autre (et réciproquement (si la relation de dépendance est bidirectionnelle))
** dependance::unidirectionnelle, bidirectionnelle

* SlideAndSnapXyloTower: on peut slider verticalement vers la valeur que l'on souhaite et la xyloTower garde la même largueur, elle snappe vers la valeur la plus proche
    cela apprend aussi à l'utilisateur qu'il va pouvoir redimensionner des objets avec les contrôles sur le contour
* "click & snap" xylotower: quand on clique dans la xylozone, elle traduit le click en un snap vers le "taquet" le plus proche
* ClickAndSnapSliderXyloTower semble être encore plus intuitive (on peut "sortir de l'ornière zéro")

* FreeSlideMonochromeXyloTower: on peut slider verticalement vers la valeur que l'on souhaite (pas de snap)
** FreeSlideColoredScalesXyloTower: la tour montre les différents "étages" nécessaires pour aller à la hauteur demandée   (les tours peuvent être ou ne pas être de même largeur)
    L'effet de couleurs changeantes qui se produit quand on déplace le slider doit valoir le coup d'oeil
    On pourrait mettre un effet sonore aussi, ça serait peut être bizarre
    => Il faut un Z-behavior aux petits oignons pour éviter de décevoir l'utilisateur (le z-scroll ne doit pas induire un changement trop important de la "valeur" de la tour)

** greenMouse: slot has countDown (say "3,2,1,0") and then triggers
    - this allows "soak cancel" (actually I wouldn't want to soak it there)
** greenMouse: the longer you stay, the more you get:
    example: the slot is a [+1] slot, then for every second you stay on it, greenMouse gains +1 (if it was 4 it is now 5 etc.)

*snapping: l'important, c'est les valeurs: il faut trouver des valeurs qui soient "juste comme il faut"
*snapping:unsnapping must be "harder" (snapping and unsnapping are asymetrical)

*snapping: snap(): la pièce écoute la version snapped, unsnap(): la pièce écoute la version free

**~mise en abyme/psyOps: dans le canvas infini, montrer des maisons, des immeubles, et quand on zoome dans une fenêtre du bâtiment, on voit un élève en train de joueur au Z-game, et en fait, c'est nous qui jouons à sa place.
    L'idée c'est de faire croire aux élèves que tout le monde joue au jeu et donc que c'est pas un truc de ringard/loser/tête d'ampoule.

***could we actually combine z-scroll and 3d canvas ? (z-scroll would zoom in current z-layer, but keeping z the same)
      (this would open the door to total madness)

*snapping: snap to any canvas 'position' (pas besoin de snapSlot, ici le "snapper" c'est le canvas lui-même)

* le système de représentations pourrait être utilisé pour retrouver un coupable (ou du moins mieux visualiser les différents points de vue)

01 janvier 2021:
* challenge mecanism: 5 seconds to complete: after clicking on start, user has 5 seconds to complete challenge
    greenMouse allows quick mutation combos : c'est rapide de glisser la souris
*   on pourrait aussi imaginer des mappings locaux de touches de clavier (valables uniquement quand le challenge est actif, pour déclencher des mutations (sous le slot il y aura marqué la touche de clavier pour le déclencher))

* challenge: related objects: mutate objects so that a relation is verified
    examples:
      mutate objB so that its area is twice as big as objA's
      mutate objB so that AC is twice as big as AB

* challenge: shmup: shoot numbers: to destroy negative numbers, you have to shoot positive numbers so their sum equals number opposite

02 janvier 2021:
around puzzles:
* polygonal piece
* rounding corners (any angle): inner/outer: courbes de Bézier (pour ne pas se prendre la tête avec les tangences) ?
* any piece shape ==> masks

* puzzle snap types:
    -shape and content-seam (le truc classique sur un puzzle)
    -shape-seam (la pièce snappe même quand les contenus ne font pas la jonction)
    -content-seam (la pièce snappe quand les contenus font la jonction, même si un des pièces déborde sur l'autre) ==> this requires complex z-index mgmt

* create pieces:
*  - machine: piece mould: input: content container (content), operator: piece mould (shape), output: piece with shape and content
** - pokéball: (single-use portable machine) (masked snapshot), user can carry along a puzzle mould, which when placed over content (this could be many objects piled up), and activated, mutates into a puzzle piece with mould shape and captured content

**machine: portable machine, machine is carried along to input location instead of input being carried to machine location
**machine: single-use portable machine: machine can only be successfully actioned once

* wearing objects: objects wear out after a certain time, and then disappear
* edu: creation d'automatismes: [
    - timeout challenges
    - wearing objects
    - focus-enlivened wearing objects: what has not been appearing in screen rect for a long time begins wearing
]

*** Paul's idea: "companion app": une application couteau-suisse qui les suit tout au long de l'année et dont les programmes ont été construit par les élèves: ils se servent de ce qu'ils ont construit

** lien entre companion app et game app:
      - use companion in game (companion 'mascot' is visible in the game)
      - unlock companion skills in game (on est moins dans la construction mais plutôt dans l'acquisition)

* edu: docimologie:
    - noter la progression dans le jeu en fin de trimestre, coeff 2 par exemple
      - progression 'notée' vs progression facultative
    - si c'est le cas, il faut empêcher les élèves de tricher

* edu: un jeu qui suit le cours de l'année: à chaque chapitre, le prof donne le code pour débloquer le secteur associé au chapitre
    et il y a un secteur 'hors-piste' qui est toujours ouvert

** take photo and then look for piece content: photographs can now have very high resolution: piece content could be fetched from photograph
* edu:
    1. on marche et on prend des photos
    2. on cherche des objets particuliers dans les photos en zoomant
    3. on fabrique des pièces et on complète le puzzle

**StickSnap: the idea is to stick two pieces together
** L-stick snap: side-length snap: the idea is to stick two pieces together, using a flat side (a "gon"): snap will trigger only if sides length are rigorously equal
    edu: the idea is to make students understand that sometimes, things have to be precise
** P-stick snap: "perfect"(/"profile"/"protein") stick snap: when trying to stick pieces together, pieceA profile must be the anti(==complementary)-profile of pieceB
    same thing: the idea is for students to observe profiles by zooming in
**    edu: il y a un problème avec ce genre d'idée: _jusqu'où s'arrêter_: une fois qu'on a compris le principe, on peut se dire qu'il peut y avoir des "imperfections" cachées n'importe où ("paranoïa de la ligne jamais droite")

** pile up objects on snap slot:
    edu: the right order: poser 1,2,3,4,5,6,7,8,9 dans cet ordre sur le slot
** fifo/lifo: snapSlot could have fifo or lifo behavior

03 janvier 2021:

**meta-challenge: challenge list: challenge<N>.onCompleted(moveToChallenge<N+1>)
  edu: un meta-challenge "prérequis" avant de commencer une nouvelle étape

** greenMouse: activateOnTouch: onEnterActivationZone/onLeaveActivationZone (un peu comme un snapSlot mais ici c'est pas un snap c'est une juste une activation)
** greenMouse: fastGrow/mediumGrow/slowGrow (same effect but different strength)

** challenge: manually create clone: given a model, player has to recreate a clone of it next to it

* mettre des images de déchetteries: d'énormes piles de déchets

edu: miner des idées dans les bouquins de maths:
*edu: decimal dot-to-dot

** Dobble avec des représentations différentes d'un même représenté
  edu: avec les nombres: 1/2 est équivalent à 0.5 qui est équivalent à 5/10, etc.

** le livre dont vous êtes le héros: zoom-in to the branch you chose
** on peut fabriquer un poème fractal avec ce système

***infiniteCanvas exoObject: the idea is this: say we create an object in fabric(which is normally a representation space for icObjects) (typical example: a freeDrawing) and we don't want to know what it is explicitly(its properties, how it works, etc.), _as long as we can serialize it_ we can create an icExoObject which will then be reenacted when fabric.unserialize(icExoObject.payload)
    un peu comme une éponge sèche, que l'on mouille et que l'on fait redevenir une éponge tout à fait valable

**keyDownToggleX + mouseClick: select object
**keyDownToggleY + mouseClick: select object just below
**keyDownToggleZ + mouseClick: select object just above
**mouseDown/up: hold/release _(previously)selected_ object

**challenge: différentes représentations d'un nombre, un nombre au centre et les autres représentations autour avec des flèches et des slots

*puzzle pieces everywhere: puzzle pieces may have a distinctive frame, or symbol, so that we know it should go in a puzzle in sector X

Les grandes étapes de développement restantes: [
  Editeur:
    serialization
    freeDrawing (exoObject)
    Groups
    polyline
    svg

  Jeu:
    Xylophone with texts
    ESB tower
    ZPuzzle:
      basic zPuzzle
      indicator slot (slot borderColor is either green or red depending on .isValidPiece(piece))
    DoubleObjects
    Sparkles
    GreenMouse:
      basic GreenMouse
    Portals
    ...
]

05 janvier 2021:
* z-puzzle: piece original container image, exemple: (bulle de champagne(pièce) dans verre de champagne (container image))

06 janvier 2021:
* square graduation to ease "piece hunt" when trying to solve a z-puzzle
* z-scroll (minification): auto-attract to puzzle area

* "square caterpillar" growth animation on challenge completion ([1] piece was the "missing part")

07 janvier 2021:
** HP::HP fountain: to recover HP, player can solve repeatedly an "easy" challenge(each time with different "problem values") to get a small amount of HP back
  harder riddles may give a greater amount of HP back
** HP may determine how fast the player can zoomIn/zoomOut

*remark: fractal drawing seems very natural (as if we were predisposed to draw some (recursion is not brain-intensive, it is quite dumb actually))

*mouseDown z-scroll: follow cursor

https://cancerberosgx.github.io/demos/misc/fabricRectangleFreeDrawing.html?d=9

* shape recognition:
  https://stackoverflow.com/questions/10463158/fabric-js-implementing-shape-recognition-on-newly-created-paths
  this would require AI-trained library
    1. freeDraw a path
    2. shapeRecognitionLibrary.getShape(path)
    3. create fabricObject for recognized shape

**dehydration/rehydration of "non-passive" objects is to be done wisely (==reactive objects(like in a chemical reaction))  (for example: slots)
    couper les tentacules avant de congeler
    puis refaire des boutures de tentacules à la décongélation
  0 imagine if some "slow attraction" process was going on when saving: recover attraction process when loaded

**protoSlot: this objects waits for user to put piece in it
  a workflow:
    1. create obj
    2. create protoSlot
    3. drag obj in protoSlot => protoSlot mutates to slot
    4. select newly created slot
      5. (while slot is selected) keyP (for example) => slot creates piece
    6. piece can be moved around

**easy object: AmorousSquare ("pixel amoureux"): un pixel facile à vivre qui se vient se L-snapper à un autre AmorousSquare
    => on peut fabriquer facilement des polyominos
    => double L-snap, triple L-snap, quadruple L-snap: when piece L-snaps for different reasons at the same time
    AmorousSquare::padding: don't snap too close, leave a spacing between glued objects

**protoAmorousSlot: creates an AmourousSlot when an object is placed inside (amourousSlots can be useful when designing a puzzle)

* slot racing pour parler de l'abscisse curviligne

* find pieces to create triangle (segments [AB] [CD] [DE] etc.)

08 janvier 2021:
* l'unité de longueur d'un nombre c'est un nombre (le nombre 1)

* diamagnetic objects: cannot be snapped/attracted by snapslot (icObj.snappable == false)

* another slot/piece creation workflow: with a CreationManager
      1. create slot (it will be given id == 1 for example)   (creationManager.startSlotAndPiecesCreation(); creationManager.slot = slot;)
      2. create another object:
          if it's a piece                                     (creationManager.slot.allowed_pieces += piece;)
          if it's any other object:                           (creationManager.endSlotAndPiecesCreation(); (if slot has no associated piece: destroy slot))
      => this way we could associate "different pieces" (for example: [1],[2],[3]) to a same slot

* challenge creation: computed object's backing graph
    user creates slots (for example: "given", operators, "answer" or target)
    for each "computed" object, puzzle maker indicates via a graph how to compute value
    puzzle maker can then hide the backing graph so that player only sees challenge "facade" (on cache les tuyaux derrière un peu de placo)
* challenge creation: computed object's backing formula (way faster!)
    "= A1 + B2"

** match object's representations using freeDrawing: player links points using freeDrawing, then freeDrawing is replaced by "pretty line" when released
      there must be a freeDrawing zone (to avoid player doing crazy things)

**O-puzzle: Overlapping puzzle: slots overlap: some part of the piece is not useful, it must be overlapped by another piece for the whole to display something nice
    => this requires complex z-index mgmt
    => this requires "slot community" (first filled slot is "send to back", then next filled slot is put over etc.)
*   slot overlap has many different flavors: TL, TR, BL, BR, center, offsetXY
    difficulty::hard: slot can be filled multiple times
                      slot can be filled with pieces of different sizes
    example: with filling order
          ______________________
          | 2      |1          |
          |   6    |  5        |
          |        |           |
          ----------------------
          | 3      |  4        |
          |    9   |    7   8  |
          |________|___________|

edu: O-Puzzle "useless zones"(==zones that will be overlapped) could be used to carry texts in order to describe object parts
  edu: easy mode: add piece orderIndex in the useless zone
edu: O-Puzzle "useless zones" could be used to display what's behind facade
  example: anatomy

**edu: O-Puzzle: "put it in right order"    (un peu comme le jeu UNO, on empile quand on peut)
    examples:
      mathematical demonstration (in geometry for example)
*       we could use a slot for the main demonstration flow and satellite slots for the lemmas used in the main flow
      geometrical construction
*       edu: feedback: add tick when the right piece has been placed (like in a todo list)
      logical sequence: cover [A->B] with [B->C] etc.
        colors and numbers (un peu comme le jeu UNO mais en mode "dominos" (il faut utiliser tous les dominos))
        dobble (sets are related by one common element)
*   on est d'accord que le mieux c'est quand l'élève part de rien et doit tout fabriquer lui-même, ici c'est un peu de la réflexion discount
**  edu: add "unfitting" pieces(==dead-end pieces) (to prevent student from bruteforcing): there are many more pieces than actually needed
      some pieces may seem fitting at first glance but then appear to be dead-ends

*O-puzzle:easy creation workflow (for a single-slot O-puzzle):
  1. maker creates protoOPuzzleSlot
  2. maker puts _in the correct order_ the different pieces they want to use
  3. maker clicks on "Done"
  4. protoOPuzzleSlot automagically paints useless zones for each piece with garbage by comparing the different pieces
  5. maker can get the painted pieces from the filled protoOPuzzleSlot and put them wherever they want

*challenge: trouve l'intrus

*challenge: lis l'algorithme de déplacement et sélectionne le point d'arrivée, ensuite appuie sur "play"
*tool: le répartiteur: user creates a partition of a 100% box and can then drag any collection or number that will be divided into different output boxes with the right proportions

*<X>-puzzle::double puzzle: pieces are linked together so when solving puzzleA, it solves puzzleB  (first puzzle could be mathematical and the other puzzle could be an image)
      and only puzzleA pieces can be selected and moved

* coins: player earns coins
    easy exercises give fewer coins than hard exercises
    player can then buy:
      hints
      keys
    say the game is playable from kindergarten to high-school,
      in kindergarten,  player will earn 1 or 2 coins
      in comprehensive, player will earn 100-999 coins
      in highschool,    player will earn 1000-9999 coins per challenge
      (player would keep the coins they have earned the previous year, keep the places they discovered, keep the challenge they completed, and also those they have not completed yet, so they can always complete them later on)

* snap objects that don't have homeScale (example: lines) => "sizeless snap"
  => sizelessSnapSlot

* createLine: rep_proto ("proto representation")

( notre point de départ ça pourrait être un solide avec un volume, parce que c'est le seul objet mathématique "qui existe vraiment"

* AmorousSegment: once pointA is snapped, pointB can be moved around in the radius circle

* on pourrait refaire une interface plus rapide pour les chiffres dans "les chiffres et les lettres" basée sur green mouse
    (dans le fond, l'esprit de l'idée de départ de green mouse c'était très proche de ça)

* greenMouse: priorités opératoires:
    we don't care about the result value:
      - answer slot is filled with full expression
      - green mouse shows growing full expression
    we do care about the result value:
      alternate display: number result / full expression

    easy:
      - only result value
      - only full expression
    medium: alternate display: number result / full expression
    hard: answer and greenMouse have different representations (one is result value and one is full expression)
    harder: answer is full expression but player cannot mimic full expression with the available vial operators: player has to match two different, _yet equivalent_, full expressions

* greenMouse: function related vials:
    derivative
    primitive
    composition with another function

09 janvier 2021:
** challenge: "show me X", "show me the thing with property Y"
*edu: Langues: repère les fautes dans ce texte
*edu: Géographie: repère les pays/capitales sur cette carte
*edu: Maths: montre moi un exemplaire ayant tel type (montre moi un triangle, montre moi une équation, montre moi une inégalité, montre moi un théorème, etc.)
*edu: construction de preuve pas à pas :
  - l'élève clique sur ce qu'il estime être l'endroit concerné par la prochaine étape de la démonstration
  - l'élève a accès à une liste de théorèmes sur lesquels il peut cliquer
  exemple:
    1. l'élève sélectionne un triangle rectangle
    2. l'élève sélection le théorème de Pythagore
    3. l'identité de Pythagore associé au triangle selectionné apparaît (_en tant que nouvel objet_ dans le canvas)

** challenge: "show me X in field (normal/mini/micro field)"
      un peu comme pour les souris vertes, on demande à l'élève de répondre rapidement
      ici il faut cliquer sur l'objet associé à la question posée
      il peut y avoir plusieurs réponses valides possibles
      Le petit twist:
        - les objets "petits" (voire minuscules) vont être assez longs à atteindre.       Les objets petits sont les réponses  "évidentes".
        - les objets de taille normale vont être accessibles pratiquement instantanément. Les objets normaux sont les réponses "pas évidentes".
      Donc:
        easy:   player has enough time to pick a small object (the small, "obvious", object)
        normal: player may have enough time to pick a small object but it requires dexterity
        hard:   player does not have enough time to pick a small object, player has to think and select valid normal object
      exemple:
        La consigne c'est [1] (==sélectionne le nombre 1).
        Dans le champ de réponses possibles,
          il y aura un [1] tout petit,
          il y aura un [2 - 1] un peu plus gros.
          il y aura un [(5 - 1)/4] encore un peu plus gros.
          etc.
      optionnel:
        Avant que l'exercice ne commence (== avant que le timer se déclenche),
        l'élève peut se balader dans le champ de réponses pour se familiariser.

**wow-effect: present stuff and use game objects during presentations, since they are just right here
*edu: j'ai envie de sortir le glisse-nombre, je le sors, même pendant ma présentation de cours
      (j'en ai besoin là maintenant, eh bien, je ne change même pas de fenêtre, je ne perds pas de temps à aller le chercher dans mes dossiers, je l'ai là, je l'ai toujours eu là, sous la main, prêt)
      => besoin de plein de raccourcis clavier
*edu: j'ai envie de sortir un exercice/jeu, je le sors

**générateurs d'exercices: ne pas réinventer la roue (au moins au début)
    0 est-ce que pyromaths est open-source ?

*challenge: place le glisse nombre au bon endroit: "le xylophone est cassé: il donne des nombres sans mettre la virgule"
*challenge: place la virgule       au bon endroit
*challenge: réparation: aide nous à remettre au bon endroit la virgule sur le xylophone

(ni tout à fait vectoriel, ni tout à fait raster, un entre-deux

* slot "endoConfig" (if you get close enough, you will see the cogs and gears) ("horlogerie")

* opacity setting same as color => "KeyV"

* l'encre invisible ! write stuff with opacity 0.0
* opacity blend: add vs fusion

* 0 acheter le nom de domaine teachingbeforedying

* protoSparkle

10 janvier 2021:
* serialize useof interactive module: module will be loaded on deserialization
    example:
      modules: {
        xylophone: {
          type: "xylophone",
          exponent_min:
          exponent_max:
        },
      }

*sparkle emitter:
  phare
  feu de camp
  candle
  lightbulb
  luciole

* reversed Z-puzzle: remettre les objets à leur taille originale

11 janvier 2021:
*greenMouse: path graph: étant donné un nombre de départ et des opérateurs,
    - il y a des nombres faciles    à atteindre (==en peu      d'étapes)
    - il y a des nombres difficiles à atteindre (==en beaucoup d'étapes)
*(greenMouse: NIM game: à chaque fois que l'on utilise un opérateur, il disparaît, l'idée est de ne pas faire le dernier mouvement  (idée encore un peu floue)

0 fabriquer une présentation de cours avec infiniteCanvas

**machine: l'agrandisseur: (basé sur le théorème de Thalès)
    on a un angle donné, par exemple 35°
    il y a un slot dans lequel on met l'objet d'entrée
    on peut ensuite faire glisser l'objet pour l'agrandir/rétrécir à l'envi
    l'objet de départ est montré et le facteur d'agrandissement aussi

*( un pulse électrique dans le bouton de souris pour faire en sorte que l'utilisateur arrête de garder le bouton appuyé quand ce n'est plus nécessaire

* protoWell
* greenMouseWell/protoGreenMouseWell

* touchSlot: user-scripted touchSlot
* protoTouchSlot:
    - facade
    - transformation script

* scriptHolder (généralisation de touchSlot) et scriptHolder.triggeringEvent voire triggeringFunc (séquence complexe d'évènements)

* greenMouse: pour le fun: faire un exemple avec la souris verte, l'huile, l'eau, et l'escargot tout chaud
** greenMouse: pathHintTouchSlot: full: toucher cet objet donne un chemin à suivre pour arriver au résultat cible
** greenMouse: pathHintTouchSlot: next: toucher cet objet donne le prochain noeud  pour arriver au résultat cible

***dynamic object::network-fetched: "tout le web dans un seul canvas" / "infiniteBrowser"
    cela demande une autre façon de coder les sites web, mais si tout le monde s'y met, ça peut être sympa
0 add network-fetched image-of-the-day to infiniteCanvas

***Z-scroll railway(==z-railway): from beginning of course to end of course
    user can select the z-railway and then, when user would scroll, they would follow z-railway's path (le prof n'a qu'à rouler la souris pour dérouler son cours)

*pathSparkle: multiple phase-shifted similar sparkles (probably better with opacity != 1) (comme si on voyait d'en haut les balles d'un jongleur)

*touchSlot: explain mutation: [1][+2][=][3]    while greenMouse is "in" touchSlot, objects appear on the sides of touchSlot to explain mutation
                               ^  ^      ^
                               |  |      |______  mutated value  (== a preview of the greenMouse when it will leave touchSlot) (==rep_touched)
    original value    _________|  |
                                  |_______ touchSlot

    this is mainly dedicated to edu purposes
*edu: show steps around variable: accessor(get) == get value out of the box, compute expression == do stuff with value, mutator(set) == put new value in the box
    gros travail d'animation

*touch-based number shoot'em'up: player starts with 1 and tries to get the biggest value possible by touching powerups (x2, x(-4) (which may be a risky strategy), +10, etc.)
    we could imagine 'sector gates' that only numbers above(/below) threshold could get through

12 janvier 2021:
* greenMouse::competitive:
    beat(==finish before) computer
    beat other player

* greenMouse: conjugaison
* greenMouse: Pythagore
    il faut trouver un moyen _fluide_ de suivre le procédé qui amène à sqrt(a²+b²)

("Sans titre" aurait été tout à fait satisfaisant pour le PCI

*(
  a well is like a reverse snapSlot
		1. on hold, create new represented
		2. on release:
		 	if out of well's recapture area, disable recapture
			if inside well's recapture area, recapture object: destroy represented
  OR
  a well is a self-refilling initially-filled snapSlot (but this requires redefining the behavior of a greenMouse (greenMouse can continue living if it was never held))
    => composite object: snapSlot + sample#000
  OR
  a well is an object refusing to move (because snapped), cloning itself instead of moving, and a "blackhole" snapSlot (destroying whatever it snaps)
*)

** touchSlot: dual touch/multi touch: a dual transformation func is triggered only when two touchSlots are touched simultaneously

**"are these operators or numbers ?": a touchSlot, if prepared with "touchable = true", can then be touched, thus mutated (this way a -1 operator can become a -2 operator, when touching a x2 operator)
  edu: this way we can blur the boundaries between "operator -1" and "number -1"

**challenge: Indiana's path: to get to target slot, greenMouse has to cross a grid of touchSlots, so player has to find the right path (we can imagine complex looping paths)
* challenge(hardcore): Indiana's room: player has to fill 4 target slots. Once a target slot has been filled, player comes back from start and previously used touchSlots are neutralized (là on est dans le casse-tête)

*challenge:goulet: there are two "operation wards" and between the two, the only passage is a [x(-1)] operator: user has to anticipate before changing room
  targetSlot is only reachable from operationWard2

*edu: greenMouse operator spam:
  - spammer le +1 ne donne pas grand chose d'intéressant
  - spammer le x2    donne quelquechose d'intéressant (pour le cours sur les puissances)

*activationPool: touchSlot.canActivate is conditionned by activationPool.nbRemainingActivations (collective behavior)

*edu: easyStar/mediumStar/hardStar: check if student only has easyStars: it would be nice if student could, at least in one domain, get a hardStar
  (que l'élève ait une compétence avancée dans au moins un domaine)
  (pour qu'on puisse ensuite s'en servir comme d'un marche pied pour avancer dans les autres domaines)

*maker:easy: referringTo: comme pour la couleur, ou l'opacité, on aurait une zone un peu comme un select, qui indiquerait ce à quoi on se réfère en ce moment
  exemple: je veux créer un snapSlot qui snappe uniquement les icTexts, eh bien, si j'ai comme reférence "icText", alors quand je créerais mon snapSlot, il sera automatiquement configuré pour ne s'intéresser qu'aux icTexts

*greenMouse::litteral operators: [+x], [-y], [*z], [^k]
  easy:   autoReduce full expression
  medium: autoReduce current expression layer
  hard:   don't autoReduce

*greenMouse::fractions:
  easy:   autoSimplify full
  medium: autoSimplify current layer
  hard:   don't autoSimplify

*greenMouse: time extended/small heal: when greenMouse is soaked, it adds a bit of time/HP to the greenMouse
    we can represented the countDown by slowly removing HP from the greenMouse

*challenge: GTA: objectHolder is a car and player can accelerate/brake/turnleft/turnright
  c'est toujours la même soupe mais là on controle une petite voiture

*greenMouse: is a transient variable: say only greenMouse.value is transferred to target slot, then greenMouse is a transient variable (it does not outlive oneself)

* variableWell (==geminiWell): mutations are shared by all representations (there is only one object)
* challenge: 2 areas, 1 variable: each area is exclusive (one cannot go from one to the other), variable is present in each area and can be mutated in either

**greenMouse::vectors: vector greenMouse, vector operators, vector target
*   edu: show vector arrow (for 2D numerical vector)

*greenMouse::collection: collection greenMouse, collection operators (map, filter, reduce), collection or anyType target

* challenge: composite object

* a composite is not a group (a composite has only 1 level of nesting, a composite does not have intrinsic position, size or homeScale): compose() flattens all objects (though it does not break inner groups)
    0 moving one part:
      0 makes all parts move 					(== "fixing")
      0 does not make all parts move  (== "mobile")  (example: well's sample)
    (0 move individual part: rearrange composite

* selection transformations:
    - compose
    - wellify
    - greenMouseWellify

*composite object: protractor (rapporteur d'angle): les aiguilles sont les parties "mobile" et le centre  est "fixing"
  => mobile parts movement is constrained
*composite object: oriented-angle protractor
*composite object: editable segment: les deux points d'extremité  sont les parties "mobile" et le segment est "fixing"
*composite object: clock

***permanent challenge: clean the world: litter regularly spawns in the infiniteCanvas. Player would better put it it the bins, or else there will be litter everywhere.
      the more litter there is, the more litter there will spawn.
***permanent challenge: upkeep: everything slowly withers, if not "refreshed".

**composite object: "[+1] [-1]", when a [+1] touches a [-1], they cancel each other and object vanishes

*snapSlot::gravity-based: player can create satellites by giving the right release impulse

*challenge: "click on point with coordinates (< >;< >)", animation: an archer shoots an arrow to the point picked by user, if user point is close enough to target, then that's fine...

13 janvier 2021:
*greenMouse: parentheses
  plusieurs mises en oeuvre possibles:
  - two areas: switching area starts new parentheses expression
    - central parentheses operator: [()]
    - central parentheses related operators: [()+()][()-()][()x()][()/()][()^()]
    - central parentheses related operators: start new expression with initial value: [+0][-0][x1][/1][^1]
  - one area and parentheses operators on top, "standard" operators at bottom

*redMouse calculator: un outil pour calculer des nombres rapidement
  (a good parentheses ux is required)
*challenge: écris la rédaction correcte en assemblant les blocs (à la Scratch)
    some blocks would have slots to fill with redMouse calculator's output
    as in Scratch: slots/blocks should resize when inserting big piece (a long number piece for example)

*greenMouse::logical expressions (sûrement pas mal de choses à gratter de ce côté là)

*xylophone calculator(juste une autre proposition d'UI pour la calculatrice): user can pick number on xylophone

*edu: ce qui est bien avec l'idée initiale de greenMouse, c'est qu'on affiche jamais une expression incomplète à l'écran

*la désillusion: dans le fond, rien d'innovant: Scratch possède des snapSlots, Scratch possède des wells, Scratch montre des exemples de L-snapping, de composites, d'object bin,

*greenMouse: undo operator (merci Willy) (et redo aussi pourquoi pas)
*greenMouse:operator preview: show preview of operator's application
*greenMouse: guess the operator

14 janvier 2021:
**greenMouse: is equality
**greenMouse: is inequality

**greenMouse::equations: rejoue les étapes à l'envers pour éfeuiller l'expression

*greenMouse:complex operator: example: [x2+1]
**operator mutation: tu voulais [x20] ? eh bien, tu prends [x2] et tu lui fais toucher [x10]
**greenMouse:reset button (put operators back to their initial value)
*greenMouse: we may reset operators on greenMouse release (if operators mutate during the "greenMouse journey" (==greenMouse transformation process))

**opérateur de conversion: exemple: [croissant <-> argent]

*edu: greenMouse on Scratch pour faire comprendre le principe un peu plus en détail

**greenMouse: parentheses operator: une autre proposition: [)x(1] [)+(0]
*greenMouse::complex numbers [+i] [xe^(i theta)]

15 janvier 2021:
*greenMouse::eval operator:
  example: operator: [eval({x = 3; y = 5;})], so when [2y] will touch it will transforms into [10]
  this could produce partial evaluations

**greenMouse::strings: string variable, string operators, string target
    - capitalize
    - remove first/last letter
    - insert letter at index
    - concatenate
    - randomString with format

**greenMouse: number dump: the whole greenMouse area is actually a dumpingSlot, so when number is dropped, its value could be:
    - auto added
    - auto multiplied
    - etc.
    to the dumpingSlot current value

**greenMouse: target is ...<[ ]<...
    edu: -2 * 10^-3 <[    ]< -10^-3
**greenMouse: variable has to match target's condition
    - inequality
    - complex condition: {{number must be odd}    and     {over  9000}     and     {its last digit must be 6}}
    etc.

icObj.cType = "<>" may actually be replaced by:
  gmObj.icObj.type = "composite"
  gmObj.type = "<>"

((*
""système des boules noires et blanches choisies par le jury"":
    on peut faire un système de note probabiliste:
      chaque membre d'un jury(très nombreux) remplit un sac avec la note qu'il attribue au candidat
      le candidat tire une note au hasard dans le sac et c'est sa note définitive
))*

*edu: greenMouse: "last operation should be a multiplication" (pour forcer l'utilisation des fractions)
***greenMouse: "value path" conditions:
    "last operation should be a multiplication"
    "third operation must be a substraction"
    "reach target in max 5 operations"
    "reach target in exactly 5 operations"
    "reach target without exceeding 100 at any step"
    "reach target without getting 42 as a step result"
    => targetSlot checks value but may also check "value path" (==the value "fabrication process")

((le problème avec la forme: quelqu'un respecte la forme, mais c'est une belle coquille vide.

*edu: greenMouse: commencer léger
      child:   nb_operators: 1-2
      pupil:   nb_operators: 3-4
      student: nb_operators: any

**greenMouse: écrire une phrase sans fautes
  operators are renewed for next word
  il y en a avec des fautes et d'autres sans
  when touching a "mistake" operator: everything resets: back to the start

**greenMouse:show greenMouse path building:
    greenMouse: writing: montrer la phrase en train de se créer
    greenMouse: numbers: montrer l'expression en train de se créer

(""visionnement d’une vidéo montrant un épisode du jeu"": WOW
**redMouse:Mario et les champignons

*edu: show/hide value tag of redMouse

((est-ce qu'il est légitime de montrer des figures avec des longueurs de côté qui ne sont pas reflétées par le dessin ?

*webpage should be lightweight for "bad connection" users
*webpage shouldn't involve two much CPU/RAM usage for "bad computer" users

*greenMouse: build a tree: leafs and nodes
    1.it starts with a leaf ([1] for example)
*   2.then you select a node operator ([+] for example), you get [1]---[+]---[?]
    3.you have to fill empty leaf space with a leaf, you select a leaf operator ([2] for example), you get [1]---[+]---[2]
    4.then you select a node operator, etc.

*greenMouse: number textual form: [un]*[+2] va donner [trois]  (* == touches)
*greenMouse: observe the decimal system "in deeds" using operators: [+1] [+10] [+100] [+1000]

16 janvier 2021:
*greenMouse: target slot is riddled:
    exemple:   1234
            + [    ]
            ________
               7894

*union libre: composite([piece,slot])  (ça donne un petit côté gemini, "si tu me tues, l'autre mourra aussi")
*try composite([compositeA, compositeB]): regarder si on peut faire des trucs subtils avec isMobile (qui est en fait isMobileWrtMyComposite)

*Z-railway: from slot to piece
*Z-railway: dot wave: a wave from src to dst is formed by static dots getting bigger, getting smaller

*machine::clone:[inputSlot][temporaryWell]
*greenMouse: cloneMachinesEverywhere: well could be replaced by a cloneMachine to give the player the ability to choose the initial value
  edu: par exemple: l'élève peut prendre son numéro fétiche      pour faire le challenge (un petit côté "choose your character")
  edu: par exemple: l'élève peut prendre ses opérateurs préférés pour faire le challenge (un petit côté "choose your weapons")

*greenMouse: round()/trunc() operators

**multimouse(many mouses in classRoom) is compatible with greenMouse
**multimouse(many mouses in classRoom) is compatible with zPuzzle

*madness: 4 player split-screen greenMouse ((many mouses in classRoom))

**dev:MAKE IT F-ING SEXY (sinon personne va y jouer, ou alors 5 min et c'est tout)
    - rounded corners
    - animations (regarder ce que font les jeux genre Candy Crush etc.)

*challenge: contrôle qualité: le joueur doit dire si la pièce doit être mise au rebut ou pas en mesurant (on peut imaginer une machine qui produit des pièces)
    des longueurs
    des angles
    des couleurs
    etc.

*greenMouse: boiling operator: il faut attendre un peu de temps sur l'opérateur avant qu'il ne s'active (on s'écarte un peu de la "philosophie greenMouse")

*challenge: "dirty glasses"-puzzle: the "key" to solving puzzle is to use piece in HUD-layer, so the puzzle is completed when all others pieces have a correct relative position
**(*)greenMouse: invisibleMouse: at some point, greenMouse is invisible, so player has to run the operations mentally
    edu: we could replace the invisibleness by a question mark symbol: [?]

*challenge: Pythagore et Thalès: une petite cuisine de nombres: length tags are redMouse wells so player can use them directly to create expressions

*easy clone: keyDownTrigger("<Key>") + hold object (en gros: keyDown + mouseDown + move)

17 Janvier 2021:
*z-well:   grow number via z-scrolling
*timeWell: grow number via waiting

*ui:numbers::colors:
  -each "broad" operation (+/-==+) is given a color:
    example:
      +: yellow
      x: cyan
  -each operation neutral number is given a color: the color for neutral
    example: [+0] could be yellow with a neutral color border

*challenge: single-operator challenge: since there is only one operation involved, numbers and operators can be considered the same thing
  in this case:
    [+] operation: [1]*[-1] = [-1]*[1] = [0]
    [x] operation: [2]*[1/2]=[1/2]*[2] = [1]
  operation symbol (and color) could be the background pattern of the challenge area (==operator as wallpaper)

*challenge mutator::now it's black and white: player is driven to reading the symbol instead of reading the color

***icObj.type = "emitter":
  - the information propagation could extremely slowed to be visually represented using a growing circle
  - the information attenuation could be visually represented with a fading effect

  edu: this way: player can visualize the cause of:
    - "negative events":
      - challenge reset (for example: the countDownTrigger triggers the resetEmitter, whose wave resets challenge)
    - "positive events":
      - challenge completion (for example: the completionTrigger triggers the completionEmitter, whose wave opens the star box/gives a key/etc.)

**E-Puzzle: emitter-based puzzle (==information propagation puzzle)

*challenge twist: touching countdown with number n adds/substracts n seconds, and number is to cross countdown (center area is narrowed not to leave any other possibility)
  (un peu une idée farfelue, mais les joueurs attendent des mécaniques farfelues)

*dev: live-shared document would be nice for brainstorming and creating exercices

*greenMouse: A*cos(w*t+phi): [0,2Pi]
*drop system: because life is also luck: when completing a challege, there may be "dropped" objects. dropped objects could be:
    numbers
    letters
    operators
    images
    quotations
    etc.

(*en fait, on parle jamais de contexte, d'espace de noms, quand on fait des maths avec des lettres mais on devrait peut-être. Je pense à l'élève qui a utilisé x = 7 dans l'exo1 et qui voit maintenant que x=-12 dans l'exo2, et qui comprend pas pourquoi il a changé.

subtract vs substract: substract is now obsolete

*tex and svg: icObj.type = "svg": double click to edit: show texCode, on stopEditing: show svg
mathematical expression <--> tex --> svg

(*résoudre une équation du premier degré, c'est de l'effeuillage.
  edu: exemple: Je note sur une feuille un mot. Je mets un scotch noir dessus. Je plie la feuille. Je la mets dans une enveloppe.
                effeuillage: ouvrir l'enveloppe, déplier la feuille, enlever le scotch.

*infiniteCanvas: classroom representation: put photographs of students
  ==> easy mgmt: click on student's photo

18 janvier 2021:
*greenMouse: tool: build expression from greenMousePath
*greenMouse: tool: build program from greenMousePath ((tu peux recoder une sorte de Scratch si tu veux mais pas maintenant))

*greenMouse: snapSlot in TeX expression: du gros dev en perspective

19 janvier:
* tex --> math
  0 Uncaught TypeError: algebra.fromTex is not a function
  Le travail a probablement déjà était fait, il faut juste le retrouver

* subtle work to adjust expression container size in order:
    - to fully contain expression
    - for expression to be readable (== 'big enough')
    - never to surprise user (size changes must be visually 'acceptable')
  OR
  we can animate expression's size adjustment: it slowly moves to target 'nice' size
  OR
  "touchable part" keeps the same size and "display part" continues growing
  OR
  we create composite: [E][=][(1+5+y)x2]
    and touchable part is [E], while growing part is right-hand side

*greenMouse: polynomials: show function graph/function shape next to expression (this way we see the 'waving effect' (== more and more roots as degree increases))

* icObj.type = "computed" (== icObj.type = "view"), createIcComputed(icObj,transformationFunc)

***z-Scroll:: 'scale defying' object: zTraveler: comme un sparkle, mais il ne clignote pas
      zTraveler gets as close as possible to infiniteCanvas.scale
      zTraveler may move along a z-railway

      edu: at level1: we see all operators, at level2 we can focus on each
        when we zoom in on a particular operator, we see that it seems to shrink, moving to its homeZone
        the operator's homeZone hosts a more specific challenge
      edu: "c'est le même opérateur"

*greenMouse: show all identities along greenMousePath: 1 + 2 = 3 ; 3 x 2 = 6; 6 x (-1) = -6 ; ...

*greenMouse::mathematical statements: sujet verbe complément subordonnée et grand-mère sur la commode
(* mathematical verbs: =, !=,  <, <=>, =>,

*greenMouse: evaluate expression:
    1. put expression in protoWell: [2x] --> [[2x]]
    2. use clones to evaluate:
          [2x] * [eval({x = 2}]  --> [4]
          [2x] * [eval({x = 10}] --> [20]
    (3. destroy protoWell to get original expression back

(* multiplier _une équation_ par 2 , c'est un peu comme mettre une phrase au pluriel.

*greenMouse: priorités opératoires: effeuillage: à chaque étape, proproser comme opérateurs les opérateurs qui constituent le chemin standard
    exemple: on demande de récupérer _le_ 8 dans l'expression (8 + 7 x 6)/50 - 1,
             pour [(8 + 7 x 6)/50 - 1]
                proposer
                  [+1]
                  [x50]
                  [-(7x6)]
                  (pourquoi pas [/6])
             ensuite pour pour [(8 + 7 x 6)/50]
                proposer
                  [x50]
                  [-(7x6)]
                  (pourquoi pas [/50])

((quand la souris accouche d'une montagne

* edu: two almost identical wells:
    a well yielding "autoSimplify:on"  nodes
    a well yielding "autoSimplify:off" nodes
    so when the student follows a greenMousePath, they will either see the "growing" _result_ or the "growing" _expression_

** edu: expression simplifies:
    - every n steps
    - at random time
    - only after student has earned the simplify skill
    - when touching _a_ simplify operator
* il y a des simplify spéciaux, par exemple quand on veut transformer (-1)x(-1) en (-1)^2 pour montrer l'exposant de (-1)

*edu: écris deux expressions égales, différentes dans leur écriture

**sparkle firework: to celebrate a challenge completion

*events:
  - circle propagation ("radio propagation")
  - wire propagation (we see the event moving along a wire)

*keep it local: icScope.icObjects = {}, pour:
  - éviter de scanner le monde entier quand on est un trigger      d'un challenge
  - éviter de spammer le monde entier quand on est un eventEmitter d'un challenge
  => là, c'est la notion de $scope qui intervient (tout existe déjà)

**composite mimic: from real-life object to mathematical model
    example: moving clock hands is "reactively" mimic'd in triangle

20 janvier 2021:
*greenMouse::invisibleMouse: question mark changes color and font when touched (touch feedback)
  edu: when greenMouse value is something x 10^30 and touches [+10], the value doesn't seem to change and yet there must be a feedback that touch happened
    (j'ai jeté une goutte d'eau dans l'océan et personne n'a remarqué).

**step by step simplification after node.evaluate("x = 3")
  => 0 "atomicSimplify" operator
  edu: l'idée par exemple, c'est un peu comme une montagne:
    on part de x,                         (pied de la montagne)
    on complexifie pas à pas l'expression (on monte)
    on fait l'évaluation                  (sommet)
    on simplifie pas à pas l'expression   (on redescend)
    on a le résultat                      (pied de la montagne)

* add a pool next to icObserver to put triggers in (or composites with triggers)

* icObj="challenge"
* icObj="challenge_generator"

**switch expression representation:
    - reduced form
    - tree
        show tree depth to get an idea of the complexity of the expression
    - "historical", unreduced form

**(*)redMouse::graph editing:
    0. there exists an empty node [empty] which can be used as an initial node
    1. user creates an operatorNode  [empty]---[+]---[empty] by touching the [+] gmOperator
    2. -THIS IS THE INTERESTING PART-  user can fill the empty nodes by
      a. selecting the empty node with the mouse and dragging it (the whole graph moves but the rest is "numb")
      b. touching a gmOperator (be it a common operator or a "valueOperator" like [1] or [2] for example)
    this can be extended to "non-math" graphs
*   increase operator arity: say the operator [+] has been touched and we have [ ]---[+]---[ ] then if we touch [+] operator again _with the [+] node_, we get:
       |---[ ]
[ ]---[+]---[ ]
    or even simpler:         say the operator [+] has been touched and we have [ ]---[+]---[ ] then if we touch a valueOperator (for example [1]) _with the [+] node_, we get:
       |---[1]
[ ]---[+]---[ ]
*   build tree: say the operator [+] has been touched and we have [ ]---[+]---[ ] then if we touch [+] operator again _with the left node_, we get:
[ ]---[+]---[ ]
       |---[+]---[ ]
**  mathNode graph: show partial result next to each operatorNode

(* en fait, les opérateurs [+2] [x(-1)] etc., sont des opérateurs unaires, qui sont en fait des currying d'opérateurs binaires. Grâce à eux, on construit l'arbre de calcul de façon séquentielle, sans "revenir en arrière".

*rect fusion: we a rect touches another rect, they fusion so that the new rect area is the sum of the two rects' areas

*ux: easy graph creation: draw a line between two objects and it creates the graph composite with the two objects as node and a link between them
    - draw a line   between the two to created an unoriented graph
    - draw an arrow between the two to created an oriented graph
    - draw the reverse direction arrow over an existing link to mutate the link to a bidirectional link

* colored value/ colored operator: operator only operates on a node with the same color
    - color assignment operator (==color change operator)

*greenMouse: target format is unsimplified expression: player does not have enough time, or does not have the operators allowing them to perfectly reproduce the target expression, they have to decode target expression and produce an equivalent expression

21 janvier 2021:

*challenge:greenMouse with only one "valueOperator": "the 4 fours", "3 nines" (refaire les premiers nombres avec des expressions contenant toujours le même chiffre)
*greenMouse: "Démonstrations folles":
  statementNode: "Je fais du sport" ou "<X> fait du sport"
  property operator: "Si je fais du sport, je transpire."
  exemple:
    Si on trempe "<X> fait du sport" dans "Si je fais du sport, alors je transpire", on obtient "<X> transpire".

*challenge::"edu countdown": countdown has a pause button near it, but, if pressed, challenge reward can't be earned
  - this way player can train
  - this way player understands that "the true thing" does not allow pausing

***greenMouse::living greenMouse: greenMouse' value updates even when there no user action: examples: countdown-greenMouse, radioactive-greenMouse, etc.
    countdown-greenMouse:
      -standard: every second, greenMouse value is removed 1
      -exponential: every 3 seconds, greenMouse value is multiplied by 10
      -random mutation: every n seconds, greenMouse value is transformed via a random operation
    countup-greenMouse: every second, greenMouse value is added 1.
    radioactive-greenMouse: after a random duration, and based on a probability density, greenMouse is mutated
      tree-senescence: operatorNode greenMouse has branches that separate from main tree (after some time)
    edu: this would provoke player into keeping the situation under control, into containing the living 'dragon blob' mouse
    edu: il faut vraiment trouver un moyen de rendre les mutations de vie visuellement différentes des mutations d'opération, pour pas que les élèves pensent que les nombres s'amusent à changer comme ça leur chante

**challenge:greenMouse:"get more than N": greenMouse value must get over target value during given time (snapping at the end is not necessary)
    -variant: countup-greenMouse: greenMouse slowly counts up, but too slowly to get over target value in time, so this plusOneing value must be operated on

(*icObj apoptosis: say there is a network of very small touchslots which send a 'continue living' signal, then, when an object is smaller than those touchslots, it will die from not having been maintained

*greenMouse: countdown timer is number too: player can use it to complete a challenge
    edu: think "out the box"

*digitWell: turn each digit of a number into a well (exemple: de 7891, on pourra extraire [7] [8] [9] et [1])
*operator: extract digits:
    edu: a way to create a collection from a single element
*machine: digitsExtractor

22 janvier 2021:
((comment ils font pour congeler du vivant dans les entreprises du jeu vidéo ? Est-ce qu'il y a une good practice ?
**  => copy paste "living object" between two applications

((en fait, en informatique, on a longtemps travaillé avec des morceaux de bois sans vie, et maintenant on commence à jouer avec des poulpes, à les faire travailler à notre place
((I think it's important, at the time being, (and, at last, to understand the lisp spirit) to consider that user written code is as important as user written "content". Data is code is data, period.

composite only needs a handle when solely composed of mobile parts

**maker/consumer: teacher creates exercise and, on the fly, students can try to complete it
  => this would allow a lot of reactivity and a lot of ^flicage^ (éducamération)
  après, tant que le flicage reste éphémère: un flicage de session, juste pour la séance...

*challenge:code chiffre-son: trouve le bon mot


* everything already exists: https://toytheater.com/category/teacher-tools/virtual-manipulatives/
  tout le concept de greenMouse est déjà là: https://toytheater.com/fraction-strips/ (lolilol, gardons le sourire, chacun sa pierre)
  (ça serait bien pour l'image de la France d'avoir une plateforme française dans ce genre là

(* composite(composite1, composite2): une vision du management hierarchique (pouvoir sacré)
*	0 fun: allow chosen non-top-level objects to be part of composite: create "funny dependencies behavior" objects
  edu: par exemple: si on bouge un nombre alors tous ses multiples bougent avec lui
    mais ça veut dire que le handle du composite est l'objet lui-même (... vive la récursion)

*edu: un scroller horizontal basique qui contrôle
  - la "zPosition" d'un zTraveler pour que l'élève arrive à l'idée de fonction
  - la taille d'un carré ou d'un rectangle ou d'un triangle
  => on peut fabriquer des machines configurables avec la valeur du scroller horizontal comme deuxième variable d'entrée

**summonSlot:
    1. user writes the name of the thing they'd like to summon,
    2. then when activating slot (press E),
    3. the infiniteCanvas checks if there is a summonable object with this name, and summons it if something was found
    example:
      1. user creates summonSlot
      2. user writes "challenge.greenMouse.numberOne" in summonSlot
      3. user can summon challenge.greenMouse.numberOne when activating the slot
    the summoned object can be easily deleted via a delete button near the object

23 janvier 2021:

**maker: composite(composite1, composite2) allows 'easy' animations (== easy creation of keyFrames)
    this would be even nicer if composites are graphs (i.e. composites with links) and if nodes and links are images

**greenMouse::shortest-path: get to targetValue in less than <n> steps (exponential may play a key role)
    easy:    20 steps
    medium:  10 steps
    hard:    6 steps

*maker: z-Index: keyDownToggle:
            -show z-indexes
            -if something is selected: mouseScroll will control z-index
            -if nothing selected:      mouseScroll will 'pierce' (voire 'peerce')

*maker: align
  - horizontally / vertically / diagonally / anyAngley
  - top/center/bottom

24 janvier 2021:
*challenge:greenMouse VS zIndex: greenMouse value is greenMouse zIndex: greenMouse must go above[50], go below[-20] (un peu un parcours du combattant)

**touchSlot::magicBox: touch only triggers when target is completely hidden behind touch slot

*spawn sequence(==egg-laying):
  - keyDown: if you stay pressed, a spawn will occur every <intervalDuration>
  - engine-based: when engine is started, sequence spawn will occur (no other user input is needed)
  keyDownCharge: you have to stay pressed the whole time
    0 chargeIndicator

*greenMouse:little squares:
    - [x2] operator adds the same arrangement next to the initial arrangement
      example:
        [][]                 [][][][]
        []    * [x2] gives:  []  []
        []                   []  []
    - squarify operator:  create closest-to-square    arrangement of little squares
      example:
        [][]                       [][]
        []    * [squarify] gives:  [][]
        []
    - rectangle operator: create closest-to-rectangle arrangement of little squares

    -divide/fraction happens in two steps:
      - prepare for divide: user has to use operators to arrange the little squares for the division to be obvious
      - divide prepared arrangement: since the arrangement has been prepared, division is obvious (== not surprising)

*gmOperator mutation:
 	Plusieurs choix se présentent:
 	- valueOperator3(value) = valueOperator2(valueOperator1(value))         (standard composition)
  [x2] * [+10] = [x2+10]
 	- valueOperator3 = (operatorOperatorify(valueOperator2))(valueOperator1) = OperatorOperator2(valueOperator1) (there is no typo here, operatorOperator means an operator which applies to operators)
  [x2] * [+10] = [x12]

*challenge:number Mahjong: there is a big heap of tiles with expressions and player has to match equal expressions to remove the tiles and gain access to the back layer challenge
    variant: face-up match-2, match-3, etc.

*greenMouse::variants
  - operator cannot be selected twice in a row (player has to 'alternate')
  - operators fall from the sky ('operator rain')

0? .bind(this) when rehydrating (when enliving)
(*les 2 clés pour des maths massifiées: animation et interaction

25 janvier 2021:
**enlivenSlot: when a dehydrated icObj touches/is snapped into/..  the enlivenSlot, the icObj becomes hydrated
  => challengeX reward may be a dehydrated object, and challengeY activation condition may be the enliving of the dehydrated object (for example a dehydrated well)
*challenge activation: any icObj can be dehydrated, so can a challenge (c'est un peu comme une pièce avec toutes les lumières éteintes)

**greenMouse operators: [²], [√]

**machine: reciprocalOperatorify: reciprocalOperatorify([x3]) = [/3]
    edu: pour expliquer la résolution d'équations (l'effeuillage), on part du set d'opérateur qui a permis la création de l'expression donnée, puis on fabrique le set d'opérateurs réciproques pour effeuiller

*challenge:machine chain: given step values (initial, final, and intermediate), player must put operators in snapSlot to create valid chain

*edu: timeout and nb_max_attempts may be counter-productive because they prevent pupil from sandboxing (l'idée de départ c'était de faire en sorte que l'élève se trompe énormément, comme il n'a jamais pu le faire auparavant)
*edu: track when an operator is spammed by pupil, and then prevent it from being spammed (Thrasher's 'area destroyed')

*telomere: each time object is rehydrated, add one to telomere (bon ok, normalement les télomères ça raccourcit mais je fais ce que je veux)

*simplify +1-1 or -1+1 when in sequence

**edu: add slider below equation for student to try solving equation (on peut imaginer un code couleur bleu-->rouge pour faire comme le jeu du chaud-froid)

26 janvier 2021:
*machine-cooked problem statements: first we generate a random expression or equation, then the machine builds a story around it

**challenge:propriétés opératoires: présenter deux expressions, et l'élève doit dire si elles sont égales ou non. _Si, oui, elles sont bien égales, il doit montrer pourquoi_.
    L'élève doit retravailler les termes pour montrer que les deux expressions sont égales:
      - commutation (a x b x c = c x a x b) (l'élève doit remettre les termes dans l'ordre)
      - parenthèses ((2) + 3 = 2 + 3 )      (l'élève doit supprimer les parenthèses qui ne sont pas nécessaires)
    ce qui va peut-être être chaud à développer: si un nombre est à une des extrémités et qu'on le déplace (ou peut-être pas si on se déplace dans l'arbre)

(*est-ce qu'il y a des chercheurs (français) qui bossent là-dessus ? (ou peut-être sont-ils passés du côté obscur de la force...)
((*à partir du 21ème siècle, il y a deux types de profs: les profs qui font cours à n ~ 100 élèves et les profs qui font cours à n ~ 100 000+ élèves. comme un MEGAPHONE silencieux.

(*equation: left hand side and right hand side are gemini, what you do to one also happens to the other

*ce qui est bien avec le fait de devoir coder les parenthèses, c'est qu'on est obligé de les considérer au même titre que les autres objets constituant une expression. On redevient élève.

***challenge:expression simplification by "touching" operatorNode with the correct simplified value:
      example: an expression is on the canvas: [2 / x + 64 - 30], user can pick [34] (from somewhere) and make it touch the '-' so that expression now becomes [2 / x + 34]
***"  from somewhere" == from a smart object pool
        smart pool should also propose letters when working with litteral expression (symbolicOperators: [xa], [-b], [/c])
      edu:
        easy: simplification wildcard: [?*] (==universal simplifier)
          sometimes the wildcard will "not work" : this is when there is another operation to consider before

        easy:   target fully-simplified expression is displayed
        medium: challenge listens to expression and completes when expression is fully reduced
        hard:   user has to click on "I think expression is fully reduced." button, and challenge completes only if expression is fully reduced (if not, expression is destroyed and user gets back to the start)

        easy/medium: smart object pool has equations in it which show simplifications calculations
          example: expression to simplify: [Y - 22 x Z x 33]
            then in smart object pool, you have [22 x 33 = 726] and [726]
        hardcore: smart pool contains deceiving objects

*challenge:get x:
  easy: x + 9 = 12
  medium: x + 50 = 2x + 12
  hard: (x+3) / (x+2) = 4

  easy:        x has first    position in the expression
  normal/hard: x has a random position in the expression

((*Pourquoi pas les automatismes d'abord ? Dans le fond, quand j'ai appris à parler, il a pas fallu m'expliquer pourquoi c'était important avant que je m'y mettes.
    D'abord on apprend à danser, et après on comprend pourquoi c'était important.

**[xylozone(0-9)] * [x10] = [xylozone(0-90)], [xylozone(0-9000)] * [/10] = [xylozone(0-900)]: value changes and so does size

**tool: display next priority: example: (12 + 4) / (5 - 3) will highlight "/" sign
**tool: simplify what user has lasso-selected

(*c'est chaud faut simplifier de façon chirurgicale

0 simplify: step by step
  0 create equality chain: initial = <simplified_step1> = <simplified_step2> = ...
    0 one line
    0 multiple lines

(*est-ce qu'il existe un symbole pour "simplifier" ?
https://www.symbolab.com/solver/trigonometric-simplification-calculator/simplify%20%5Cleft(3x%20%2Bx%20%2B50%5Cright)
  1 simplify logo, small s and "spiral arrow" (merci Cammy)

27 janvier 2021:
*mathWorkout: train 15/30?/60? min/day
  il faut au moins que l'élève essaie/se trompe 20 fois par jour

*simplification order is not really 'natural', it's like painting stripes on a tree
    [1] [2]     [3] [4]
      [5]         [6]
			      [7]

**from machine to human: "Maintenant, demande à ton voisin de faire comme l'ordinateur: simplifier l'équation étape par étape. Ensuite, compare les deux résultats."
    edu: bah ouais, si c'est l'ordi qui fait tout le temps le boulot, ça devient complètement aliénant, complètement "dépossessivant".

*edu: é"Mais comment il a fait (pour fabriquer ça) ?" (une perspective pour les élèves: é"Plus tard ("quand je serai grand"), je comprendrai comment le prof a fait.")

*icObj.type = <as_X__Y>;   exemple: icObj.type = "as_text__mathNode";
    => icObj.parser  (== icObj.fromXtoY())

*icObj.type = "editableAsY__X": composite facade is X, composite editing medium is Y
* key<X>/doubleClick: Edit

https://textext.github.io/textext/
https://docs.mathquill.com/en/latest/

28 janvier 2021:
*modèle de financement à la JBFarkas: des collectionneurs peuvent acheter les challenges, qui restent gratuitement accessible à tous
  à côté du challenge, on peut appuyer sur un petit bouton d'information (i) qui nous montre qui est le propriétaire du challenge

*first demos: obfuscate html source code


29 janvier 2021:
	0 MathQuill + Visual Keyboard: pour rester dans le bain

  0 mathField.latex() --> icObj.parse(tex)
    0 don't parse "=" into ":="
*	  0 _upgrade_ to gmOperator when writing "x50"  / downgrade to mathNode when writing "50"
    0 x VS ×: it would be nice to write what user means when they type keyX

*"Nice barrier" : . . . . .
                  .       .
                  . . . . .

**edu: est-ce que j'écris [×10] ou [× 10] ?
    0 peut-être une façon de répondre à la question: faire du volume et regarder ce qui fonctionne le mieux pour les élèves

**challenge: probability: gotta catch'em all: fill target _slots_ with correct objects: probable outcome slots will be be filled easily. It will take time to fill improbable outcome slots.
    target objects may be:
      - a 1D object:
          dice roll, d6, d10, d20, etc.
          number in finite range
      - a 2D object:
          a colored number: number is in finite range + number color is in {blue, red, green, yellow} (with different probabilities)
    variant:
    fill outcome table with correct objects:
        probable outcome appears a lot of time in the outcome table, and these cells will be easily filled

**challenge: probability: history collector: explicit path on outcome ("those two stamps look the same but I was given this one by my great-grand-father")
            [  1  |  1  ]
            [_____|_____]
            [  1  |  8  ]
          when an outcome is given, its explicit path is written on it:
            exemple: if we get 1, because the top-right sector was selected, then the [1] we get is [1 (top right)]

  edu: il vaudrait mieux faire faire d'abord "history collector" puis "gotta catch'em all"


**tool: same denominator zone: arrange all fractions inside the zone so they have the same denominator


**PAUL: multiplication d'équation: il faudrait deux opérateurs rassemblés, et il faut toucher les deux pour que le touch se déclenche
  edu: une fois que les élèves sont habitués aux deux opérateurs, on peut leur faire utiliser le duo [ [x 1] | [x (3 / 3)] ] par exemple pour simplifier le membre de droite


*challenge: logique: opérateur qui transforme une égalité en vrai ou faux suivant si l'égalité est vraie ou fausse

30 janvier 2021:
  0 gmOperator: force simplify (si gmOperator.forceSimplify alors la simplification se produit même si les mathNode impliquées n'ont pas autoSimplify)

***challenge goldmine: probas et expériences aléatoires
    -sac
      contenu visible / non visible
      animation d'une sorte de main qui prend un élément au hasard
      remise obligatoire / remise possible / sans remise
    -probabilités conditionnelles (évenements dépendants / indépendants): on pioche dans un sac un objet et le deuxième sac de pioche dépend de l'object que l'on a pioché dans sac1

(*contenu mort vs contenu deshydraté: avant ce qu'il y avait dans les livres on considérait que c'était du contenu deshydraté, qu'on devait y ajouter notre part pour le rendre à nouveau vivant.
    mais maintenant, je ne sais pas si c'est par ce qu'on n'a plus de vie en nous ou que les livres sont mauvais, on considère que c'est du contenu mort. Comme un bout de bois. D'ailleurs c'est sûrement pour ça qu'on s'en sert pour caler les meubles.
    Les contenus deshydratés de maintenant, c'est les jeux vidéos. Peut-être qu'on est toujours vivant mais différemment. Et du coup c'est pour ça qu'on a du mal à réhydrater les livres.

* simplification: accolade de "soupèsement"

**icInfiniteChronoBar / icInfiniteProgressBar:
    - chronoBar grows a square at its end every 1 second (at some point, you have to zoomOut to read elapsed time)
    - progressBar shows students accomplishments. Same principle: it has no end
        variant: textual mathematical life steps infinite progress bar.   [j'ai appris à reconnaître les chiffres. j'ai appris à compter jusqu'à 3. j'ai appris à compter jusqu'à 10.     ...         j'ai appris à intégrer sur un contour     ...  j'ai découvert un nouvel objet mathématique.
**  edu: infiniteChronoBar est sympa aussi pour faire comprendre la notion de valeur approchée: vue de loin, la chronoBar a l'air de ne pas grandir, c'est parce qu'on la voit de manière approchée: on utilise une certaine puissance de 10 et la mantisse nous paraît rester la même.
      ce qui est bien c'est qu'on a un objet apparement à la fois un peu dynamique et à la fois un peu statique
*   edu: exponential chronoBar: chronoBar x2 every second

*une représentation de l'oubli: un demi-plan complètement noir avance tranquillement, toujours à la même vitesse, vers les x positifs

**0? rep_engined: ça ferait sens. rep_free c'est la représentation contrôlée par l'utilisateur. rep_engined c'est la représentation contrôlée par le moteur.

(*toujours la même rengaine: l'obstacle majeur: c'est la mise en prod. C'est le passage du prototype à "A table les enfants."

*["text"] * [x (22/7)] = ["texttexttextt"]avec le dernier t un peu coupé:
    text_out  = text_in * Math.floor(22/7)
    width_out = width_in * (22/7)

31 janvier 2021:
***yugioh-style number card game:   (SHU: i think this idea could be really powerful)
      - turn:
          draw
          play cards
      - field:
          monster == number
          magic   == operator
      - win when first to gather all monsters (monster zone are targetSlots) (~exodia)
      - can reuse built number as stem (? or as operand?)

     (- wildcards : [x ?*] [?* 4]

     ((- single-use / finite-use / infinite-use operators

**edu: session-cooked keyboard shortcuts:
    say I want, _in a particular 1-hour class_, to show students particular challenges
    I would use the following shortcuts:
      easy level:   "Key1"
      medium level: "Key2"
      hard level:   "Key3"
    And those keys would spawn a new challenge, _each time they are pressed_,
    this way, if students don't seem to understand well after one instance,
    I can always spawn _a new instance of the same difficulty_, until they understand

*edu: if != when, si != quand, condition != property (==consequence is true if condition is true) != event (==condition is true at this moment)
    les élèves peuvent fabriquer des propriétés à la pelle en combinant un bloc [when < >] avec une instruction [machin <-- truc]

*0 "embracing tree" / onion mathNode: sqrt((x - 94)/4)
    onionNode / layerNode
*   operator chain: add parentheses when operators have same priority, or else mathNode's structure is not explicit
    simplify top layer
**  en fait, on peut définir un layer comme un ensemble d'opérateurs de même priorité
*     mettre les layers en couleur
      un layer équivalent à [x 1] ou [+ 0] (== un layer équivalent à [id( )] peut être simplifié (== retiré de l'expression)
    une étape de simplification mathNode1:
      0. repérer l'opération de plus haut niveau
      1. créer l'opération inverse: {operator2, mathNodeTerminal2}
      2. appliquer l'opération inverse: l'arbre grandit: il devient operatorNode(operator2.symbol, operator2.funcName, [mathNode1, mathNodeTerminal2])
      3. réorganiser l'arbre pour faire apparaître l'opération identité composée d'un couple {opérateur, neutre pour l'opérateur}
      4. retirer la couche avec l'opération identité

      mais, c'est bizarre, après tout, l'opérateur est pas forcément binaire, ou peut-être que si ([A] ** [Anti(A)])

01 février 2021:
*cette chance de dévelopeur: ça fait sourire
  - y + 0 doit être simplifiée en utilisant [- 0]     ^^
  - \frac{\left(y\cdot 91\right)}{0}                  normal quoi, y'a rien de choquant...
    edu: ^^
  dev: la simplification du 'zéro tout seul' va être chiante

**[s x 60 s]: gmOperator + forceSimplify top layer
    => gmOperator has the same backgroundColor as standard simplification operators (for example: light green, ou gradient red-->green, black-->white)
**gmOperator decoratorTouchSlot "gmOpDec": when a
    via gmOperator composition: transformationFunc3(x) = transformationFunc2(transformationFunc1(x))
    decoration may be applied:
      - once
          cannot decorate with decoration1 what has just been decorated with decoration1
      - multiple times
          with an "identity decorator": t --> id(t), then could create chains dec1(id(dec1(id(dec1(t)))))

**(*)edu: "I think I got it." button: when student thinks he has understood something, when "something's just happened in their brain", they can press the button to indicate to the teacher that, well, something has happened in their brain (!)
        this would be a way to check if a challenge "is really worth it" (par rapport à l'"élève moyen")

02 février 2021:
*greenMouse: display part: in order to keep the touching part the same size, a _central display part_(== at the center of challenge's area) could be used to display green mouse's current state

**edu: the whole 'simple equation' workflow:
  1. create the 'simple equation' you want to solve
      challenge 1: coat your left side expression
      challenge 2(or 'challenge transition'): create the equation (touch "=" sign and then a number)
  2. get back to your initial letter on left side:
      challenge 3: uncoat your left side expression, and see right side getting 'inverse coated'

**edu:quality control: is this expression valid ? there is an expression provider and two bins: one for the valid expressions and one for the invalid
    if player has made nb_mistakes < nb_max_mistakes then challenge is completed

(((*attention avec les func.bind(this), les arrow functions font les rebelles: il faut utiliser les bonnes vieilles function() à la place.

(*la théorie du décollage: quand le processus de développement de l'élève est entretenu par l'élève lui-même ((souvent par une passion))

(*l'avenir sombre de l'éducation: convey

*un petit goût d'usine: conveyor-belt-based challenges: il faut pas traîner sinon ça fait planter la chaîne

03 février 2021:
**edu: random everything + "I think this is not possible" button.
    le pendant du "grand" aléatoire : on ne sait pas si on peut trouver une solution
*edu: 100 points par jour
**challenge:from expression1 to expression2 via x: unfold in order to customFold
  example: sqrt((3x+1)/2) --> x --> (60 - x)/sqrt(85) + 7

(((((*maths for the perv: puzzle composed of greenMouse targetSlots which gradually untile to show beautiful lady for example

*challenge: interlock: with "intersecting composites"

*add a handle next to snapSlot for easy 'group move'
*snapSlot may be, at start, a single-object composite. It then grows with the snapping of objects.
  => "snapComp" = composite(snapSlot)

**experiment: not really a challenge, not really a tool. It is more like a "this"-dedicated sandbox.
**edu:experiment: RVB color by hand: player creates a mosaic square (or a circle, or any shape) using small colored squares, r are red, g are green and b are blue: when zoomed out: we can see that the square color we see is near RVB(r,v,b)
    pour aller plus vite: on peut imaginer:
*    -un spray avec un compteur (on spraye(== position aléatoire) des petits carrés (ou ronds) de couleur donnée)
**   -un enclos avec une fonction de mélange: on met tous les ingrédients dedans, on appuie sur mélanger et ensuite on dézoome

04 février 2021:
*challenge: équations: [relier] les différentes étapes de résolution de différentes équations proposées
    les équations de départ               eq1     eq2     eq3     eq4
    les équations un peu résolues         eq3'    eq1'    eq2'    eq4'
    les équations un peu plus résolues    eq1''   eq2''   eq3''   eq4''
    les équations résolues                eq4'''  eq1'''  eq3'''  eq2'''

*tool: dependency: créer un objet formule qui se met à jour automatiquement quand ses dépendances changent
  edu:pour ensuite les faire basculer sur le tableur

**0 engined.engines = {}

(((*how to serialize a closure ?

(((*Le problème du retard, quand il n'y a pas d'échéance...

05 février 2021:
*"exertive" operators: operator is moving and touches what to transform
  - eraser
  - randomizer
  - show/hider

*icObj.type = "2d_plank" : [plank] * [x 2] = [plankplank]  ==> icObj.type = "2d_length"
*icObj.type = "2d_tile"  : [t i]   * [x 2] = [t i t i]     ==> icObj.type = "2d_area"
                           [l e]             [l e l e]
                                             [t i t i]
                                             [l e l e]
*la logique derrière, c'est la coercion de [x 2] en [".size.width x 2"] ou en [".size.width x 2: .size.height x 2"] selon l'"argument"

*clickWell:   onclick: create instance and "put it under the mouse cursor"
  c'est presque pareil du point de vue utilisateur, par contre c'est très différent niveau implémentation
*touchTarget: onTouch: if toucher is valid: nowCompleted

*challenge: (greenMouse) rainbow: there are multiple targetSlots and the objective is to fill all of them

*challenge: randomness: on part de [""] et on a des opérateurs [append random letter]
    edu: juste en dessous de l'opérateur [append random letter], on montre le sac duquel la lettre est tirée
*   edu: il y a une zone pour mettre les rebuts et un compteur de rebuts

(* 0 simultaneous n-touch, "composite touch" ==> nTouchEngine
		  this could be a way to discriminate objects: those which trigger the n-touch and those which do not

**touchSlot hardcore transformation: from icObj.typeX to icObj.typeY
    - transformer une forme en nombre
    - transformer un texte en son
    - transformer une équation en un composite comprenant le membre de gauche et le membre de droite
    le dev doit être un peu costaud

**yielder::fromAudio : press 'start recording', speak, press 'stop recording' : recorded audio is then transformed into a number, or an operator, or whatever corresponds to what you said

**freeDrawingAnimation recorder: the whole drawing process is recorded
**AudioFreeDrawingAnimation recorder: audio is recorded as well

((*architecture::challenge: composite(well, composite(operators), target) voire composite(composite(well), composite(operators), composite(target))

06 février 2021:
((* the canTouchFunc problem :
      le problème est le suivant: un objet a besoin du contexte pour estimer une condition et il ne sait pas ce qu'est le contexte. Seul le contexte peut lui fournir les informations dont il a besoin.
      le problème est le suivant: touchSlot.canTouchFunc(above, below) n'a pas assez de above et below pour donner réponse satisfaisante, il manque des paramètres.
      plusieurs solutions :
        (1. touchSlot.will["touch"]: mutate canTouchFunc juste before it's going to be used: le contexte écoute la fonction et la mutate just in time
        2. touchSlot.canTouchFunc(above, below, context): on rajoute tout simplement un paramètre
          => touchSlotConfig.facade

07 février 2021:
  0 Paul:
    0 petit personnage qui donne les instructions

    0 deux modes d'exercices différents
**    0 calcul mental un peu comme le golf:
        scoring comme le golf: par, 18 trous
          0 bouton recommencer et pénalité de 1 point
          0 ou système de seuil comme au golf
          0 ou alors on ne peut que recommencer trois fois un challenge puis ça donne une pénalité
        0 difficulté croissante (comme le mini golf)

      0 apprentissage par le jeu, la notion de score n'a pas d'importance
        on va jouer avec l'âge de ma grand-mère, en fait je ne le connaît pas, c'est pas grave, on va dire que c'est x.
        0 première partie chaîne de caractères
          0 au départ on se trimballe la grande chaîne de caractères
          0 niveau 3: ["l'âge de ma grand mère"] * [+ "l'âge de ma grand mère"] = [2 x "l'âge de ma grand mère"]
          0 niveau 4: ["l'âge de ma grand mère"] * [x "l'âge de ma grand mère"] = ["l'âge de ma grand mère" ²]
          => utiliser une inconnue dans les coulisses

        0 ensuite l'inconnue
          0 deux niveaux enchaînés:
            0 [y] * [x 2] = [y x 2]
            0 [y] * [x 2] = [2y]

        0 "ah c'est bon je me souviens, pour avoir l'âge de ma grand-mère"

        0 au bout d'un moment, le personnage compagnon choisit de remplacer

      0 parcours 1,5 avec la règle suivante: on n'affiche pas le résultat intermédiaire simplifié mais la version parenthésée
**       0 GlanceTouchSlot: _while_ touched : simplified expression is previewed

  0 SHU: utiliser le jeu de façon répétée pour s'améliorer (un peu comme les assistants de touchTyping), un peu tous les jours ==> "I was growing up big like a Superman"
    0 parcours 0: pas de score, pas de par, on peut "se tromper" autant qu'on veut
    0 troisième parcours avec uniquement des équations pour cette fois ci faire de l'entraînement
*** 0 BlueMouse (==GolfRedMouse): _if it has been mutated_, then when dropped: the previous well is moved to the drop position
        pour l'instant on ne va pas trop s'intéresser à ce concept car il cristalise les "erreurs"

    0 en fait il y a deux pars:
        0 dans un essai spécifique: le nombre d'opérateurs touchés
        0 le nombre d'essais (== de greenMouses utilisées)

*edu::challenge "injection" (inject challenge in presentation): addNewChallenge(screenRect): compute the coordinates to fit in screen rect

**edu: client-server benefits: teacher can be real-time moderator of student room (la cybernétique: wire power)
  - big-brother: oversee what individual student is doing
  - shutdown: close all sessions if students are too much agitated
  - course MC: "sharp control" course flow
      - show exercise
      - close exercise
      - lock/unlock move in student room
  - teacher can freeDraw hints in student room

*golfCourse: ui: use golfCourse standard pattern: (ball), teeing, (fairway, green,) hole, flag
*golfStep: onComplete:
  - show arrow pointing to next course, a big fat red arrow
      0 icObjType = "arrow"
          icObj.orientTo(point)
  - fill golf course with golfStep.score (when zoomed-out, we see big numbers and arrows)
      backgroundColor(score):
        bronze: above par
        silver: par
        gold  : below par
      edu: de cette manière on peut voir comment l'élève réagit à la difficulté croissante

*sexy/sexiness:
  - greenMouse trail
  - decorations:
      associate an image to each golf course (for example, an image from ALOI 1000)
  - card aura
  - rainbow
  - card back
  - factions : grand colors
  - rare card / foil
  - stack

*greenMouse: mode: survival: (== "endless")
    time is extended by n seconds when completing challenge
    challenge is mutated with new values|operators when completed

**greenMouse: forbidden values: gmValue cannot be x or else gm dies (there are forbidden nodes on the gmAllPathsGraph)

**challenge sequence::segue: how to transition from challengeX to challengeY

08 février 2021:
*greenMouse golf: "impossible? step": gm initial value is 0, operators are [x 6] [x 7] [/ 3] [/ 42] and targetValue is 42
    - player has to think outside the box and use a [+ 1] operator, available on the _previous golfCourse_
    - the 2 golfCourses are visually fusionned (to give player a hint of what to do)

***CURSES! :)
*icObj.type = "gmRebirthWell": there is actually no real well, only the gm respawning -> icObj.type = "bornAgain_gm"
**    bornAgain is a _curse_, same as greenMouse

**fucked-up maths (== curse operators):
  - delayed operators: a delayed operator will apply _after_ another operation is applied.          [after <n> operations: x 2]
  - 'just before' operators: a 'just before' operator will apply just before operation is applied   [just before x 2: + 1]
  - doom : gm will die after n turns
  - amplification/minification/replacement: operator right-side value is mutated before operation is applied: [x 2] will for example be 'felt' as [x 20]
**- "karma curse":
      - "next life": curse which applies to the bornAgain
      - "eternal curse": curse which applies to all the replicas. One can't get rid of this curse.
  - "feed me"/apoptosis curse: If object is left without interaction for n seconds, it will die.

*bizarre ideas: no-copy curse: object cannot be copied

((*une idée c'est 100 lignes de code et 10 autres idées qui se ramènent.

*edu: c'est intéressant de proposer le même challenge mais avec l'ordre des opérateurs changé car l'élève un peu distrait va retenter son "parcours glissé" qui fonctionnait avant et va se rendre compte qu'il ne fonctionne plus maintenant.

09 février 2021:
**challenge: consume stack of targets : well does not change but top card of targets' stack is removed on completion
    edu: this would be a nice mode for training: students has everything in sight and knows it's over when stack is emptied
*challenge: consume stack of targets with finite initial stack
    edu: pour se concentrer sur la bonne gestion des ressources

*score: score is decreased by 1 for every new attempt

**modulo: greenMouse value is modulo n
***the mole: touchOperator does not trigger if greenMouse is below (zIndexWise) : we can imagine 0-assignment walls or even complete contours, from which player would have to consider using the 'mole move'
      or bird move, if we consider that touchSlot triggers when greenMouse is below (it would be more coherent with stamping and soaking)

**challenge: wall of challenges / challenge pointillism: completing a challenge colors the tile. An image slowly appears with more and more completed challenges.
    dev: how about 500 challenges ? 1000 ?

performance:
**	0 touchSlot.local_listen
**	0 canvas.local_redraw

*edu: ux: parentheses: in unsimplified expression display mode, when chaining 1 * [+ 2] * [x 3], it would be nice, just before applying [x 3], to add an animation which shows the user that 1 + 2 is now (1 + 2)
    à la limite: carrément montrer "x has a higher priority than +", ajouter les parenthèses et appliquer l'opérateur
      colorier l'expression en fonction de la priorité de son opérateur racine
      colorier les opérateurs en fonction de leur priorité
      "pour appliquer une priorité supérieure, il faut emballer"

*edu: les bons jeux edu et les mauvais jeux edu: la jungle

10 février 2021:
((*la couleur (==la composition de couleur que l'on voit) a une influence sur le moral. Suffit que le fond soit un peu trop aggressif et c'est mort, on n'a plus envie.

**edu: computer science: scope, visually: say we have a "visual local variable" [x] (~un peu comme une greenMouse) in a visual scope [S] (~a playField), then in the same way as for a classic local variable x, we could have another [x] in another scope [S'] and the two will be completely hermetic/alien.

**challenge: 'overuse golf': il faut faire un nombre de coup _supérieur ou égal_ au par pour pouvoir valider le challenge.
**challenge: 'Ratatouille golf' ou "Pourquoi faire simple quand on peut faire compliqué ?": il faut utiliser au minimum n opérateurs différents pour pouvoir valider le challenge.

(((**la vision: rendre visible l'invisible (pour faire un tremplin vers la compétence "voir l'invisible" que l'on souhaite acquérir)

(((**le moteur: toujours avoir l'impression d'être libre

**challenge (computer-science): destroy ftw: : student has to destroy the right object to be able to complete challenge
    example 1:
      every time a touchSlot touches an object, a counter increases near the touchSlot
      the player has to use the touchSlot 5 times but, for the challenge to be completed, player is only allowed to use it 3 times
      an object is responsible for the counter increase, it is a visual representation of computer logic (and the object actually _carries_ this computer logic)
      if player destroys this object, as the counter is no longer increased, player can complete the challenge

**Attempt: Evolution vs Manoeuvre:
    Evolution: greenMouse-focused       passive stance: what the world does to me
    Manoeuvre: course-focused           active  stance: what I do to the world

0 icHook : les deux frères Will et Did

(((n'empêche, tout ce caca qu'il faut écrire... : from magma to cristal, from heart shapes to trash heaps

icObj.namespace ou icObj.family, par exemple: icObj.namespace = "golfStep4", icObj.namespace = "golfCourse7"
  pour savoir quel objet "appartient à qui"

on retrouve les bonnes vieilles marmites: "label: value" ==> icObj.type = "labelValue" (==composite(label, value)) (l'informatique des dinosaures)

*edu: [score] au dessus de [par] (limite avec une barre entre les deux) pour glisser au passage un petit mot sur les fractions.
    On peut imaginer mettre à côté une progressBar qui est débordée si on dépasse le par.

**edu: flipping operators: flip animation transforms operator into inverse operator. example: [x 2] becomes, after a flip, [/ 2].
**    edu: when the golfStep challenge is completed, we flip the operators, we flip targetSlot: it becomes the well, we flip the well: it becomes the targetSlot. Student, after some attempts, will begin to understand that they have to do the reverse path.

11 février 2021:
*golf: endScreen:       nom du parcours, tableau de score et médaille
*golf: startScreen:     nom du parcours
*golf: tutorialScreen
((on s'écarte de la vision originale (== à la The Witness) mais c'est pas grave.

*autoPar / golfChallenge constraints:
    - path must stay between 0 -100 and 100
    - path must uses rich composite numbers

** "AND THEN HE YAWNED"

12 février 2021:  paralysis :(
*golf: hacker/cheater: get total_score below 10 by cheating
**edu: allow cheating but explicitly show "cheating" when cheating and on end screen

**golf cheating:
  0 "that hole seemed nearer": ball_1 in hole_7
  0 golfCourse tampering: same principle but operators are exchanged so that, at first glance, there is no cheat
edu:
  general cheating schemes:
    ugly:
    - end screen tampering
    subtle:
    - varX as inputY
    - level tampering

**challenge:factoryChain:
    on left-side:   maps      to create core process values
    on center-side: values    core
    on right-side:  reduces   to create result value

          ----[+ 1]----->    [x + 1]    ---|
          |                                [+] -> [4x+1]---|
        [x] --[* 3]----->    [3x]       ---|               [-]--->    [(4x+1)-1/x]
          |                                                |
          ----[inv()]--->    [1/x]      --------------------
    Some blocks may display an _expected_ value, and the consequent value.

    two flavors:
      type:   user types what he thinks is correct make the chain valid
      puzzle: empty slots must be filled with pieces

*endless: recycle golfCourse VS create new golfCourse

**icObj.type = "repeater": when actioned: contained operator is applied <n> times
                [R <5>       ]
                [   [x 2]    ]
                [            ]
    ? crocodile-style ui à la Scratch ?

**edu: challenge rework: on completion (or later on): challenge is proposed again, but under a new, reworked form
    - propose challenge.ver2 with different operators
        from [+ 2] [+ 2] [+ 2] [+ 2] [+ 2] spam to [R5 [+ 2]] to [+ (2 x 5)],
        from [x 2] [x 2] [x 2] [x 2] [x 2] spam to [R5 [x 2]] to [x (2 ^ 5)],
        from [/ 2] to [x (1/2)] (slight change of vision)
    - propose challenge.ver2 with ver2.input = 2 * input and ver2.target = 2 * target
        ver2.input = 10 * input and ver2.target = 10 * target, etc.
    - propose challenge.ver2 with all components' values scaled by 10
        scaled by 0.1
        scaled by 10^6


(((*l'adn, c'est le code qui a été retenu, donc normalement c'est du bonheur (par rapport à du code pourri ou du code sale)

**edu: practice: corrective feedback helping: (https://en.wikipedia.org/wiki/Control_engineering), create next step wrt previous steps attempts
    Appuyer là où ça fait mal
    dev: evolutionary computation, Resilient control systems

*edu: display evolution: show graph of greenMouse value evolution
**edu: inverse operators on top row: each bottom row operator has an inverse counterpart on top row: when student has "made a mistake", student can always cancel their mistake by applying the inverse operator

13 février 2021:
((*j'aime bien le problème de nommage de operator, quand on ne fournit seulement qu'operatorFunc. Si on connaît le code de la fonction, alors normalement on peut nommer correctement.

*edu: group-covering operator set: so that there always exists a path to the target
    - ℕ-covering operator set: to drive student into using [x (-1)]

*pretty operators: [/ 2] -> [□ / 2]

*edu: challenge.deceiving_rank: check solving paths for lasagna trees built from the super operator set: {operators} + {inverse operators}
  some students may try to solve "[48] --> [38]" using [+ 10]
*   Il y a un gros travail à faire autour de "C'est quoi un challenge difficile ? C'est quoi un challenge facile ? C'est quoi un 'bon' challenge (pédagogiquement) ? C'est quoi un 'bon' challenge (gameplay) ?"
  petit à petit (=="gradient fractal") faire passer de [+ 1] à [- (-1)] à l'indifférence [+ 1] ou [- (-1)]

*edu: est-ce que ça apporterait quelque chose que considérer des opérateurs qui acceptent seulement un certain type de valeurs d'entrée ? (par exemple: seulement des nombres, seulement des symboles, seulement des fractions, etc.)

*edu: un peu risqué: fraction as a certain number of turns (oriented unbounded angle)

0 easy composite rewrite: composite.parts["x"] = y;

*challenge: greenMouse = RangeNode: toutes les opérations sur les intervalles
*challenge: revolver operator (== operator cycle): once used, operator becomes operatorCycle[n+1]

14 février 2021:
**edu: BiggieSmalls: bigger font for what is important: artificially create a foreground and a background in TeX expression
    - solving an equation: MAKE 'LAST' OPERATION BIGGER
        ---|                   /|    /__\
           |                  / |   /    \
         --|     (x + 1)   =    |       /
           |                    |      /
        ---|                    |     /___

         ^
         |
         |___  this is the last operation that was applied

**edu: cherry-picking: [save (previous) challenge] / [copy (previous) challenge to clipboard] quand on a trouvé quelque chose d'intéressant au challenge aléatoire que l'on vient de rencontrer
((*L'approche phénoménologique: les maths interactives, ça demande de passer par l'étape (plus ou moins chiante) de _programmation_ des activités. Les maths interactives, ça tombe pas du ciel. Après on en tire les conséquences qu'on veut.

*rep_eternal VS rep_living: how it feels never to die

***0 en fait il faudrait un symbole pour chaque opération:
      unitful operation (=="node_b" is unitful):
        multiplication:      ×                A shock, like a battle between the two factors (cross swords). Some units are lost in the process. d = v * t
                                                Quantities multiply and units combine.
        quotition division:  ÷                We search the unitful quantity of unitful bottom member present in top member.
      unitless (==scalar) operation (=="node_b" is unitless, it is a "true" number):
        scaling:             · (|no symbol)   We scale by <coefficient>.                                  ("mother" unit is preserved).
        partition division:  /                We search the value of a part if we partition into n parts. ("mother" unit is preserved).

      Le langage fait apparaître des "unités invisibles": quand je dis 3 demis, je peux me dire que mon unité est le demi, et ma quantité est 3.
      Quand je dis "Trois demis fois un quart", en fait,
        - je multiplie les quantités : je fais trois fois un, ça donne 3.
        - je combine   les unités:     la moitié d'un quart c'est un huitième.
        Résultat final: 3 huitièmes.

      Trois demis divisés par un demi == Trois demis partionnés en 'un demi': Trop facile, ça fait 3.

      On peut passer de 3 demis à "1,5 uns".

*edu: "Bon je vais où maintenant, vous me montrez ?" infiniteCanvas program X clickless student multimouse

15 février 2021:
0 Atelier_<X>: zone de dev pour icObj<X> ou pour une mise en scène d'icObjs

16 février 2021:
**edu: (mainly for client/server): evanescent freeDrawing: teacher can write hints or indications which gradually vanish
**mathNode.toTex(): custom: to inject color for example
((*hack: use (x 1^id) to tag sub expression

**edu: speed evaluation: l'élève a 3 secondes pour toucher le bon target
    pour par exemple:
*     ("faire rentrer") les additions simples et moins simples (9 + 2 = 11, 9 + 8 = 17, 7 + 4 = 11, 8 + 7 = 15, ...)
      ("faire rentrer") les tables de multiplications
      ("faire rentrer") les relatifs

**0 ux: make it _readable_( {size, fontSize} )

**operands: argument operand VS parameter operand
    [x] * [+ 3]
     ^     ^ ^__ parameter operand
     |     |_ operator
     |___ argument operand

**edu: challenge: from x to expr:
    ver1: same operation set is used to create targetExpr and 'growingExpr'
		  easy:    one instance of symbol, operand order is left to right
		  normal1: one instance of symbol, random operand order          (là on est au coeur d'une difficulté des élèves: passer d'un parsing left-to-right à un parsing plus global)
      hard:    random operand order, sometimes parameter operand is an instance of symbol

    ver2: different operation sets are used to create targetExpr and 'growingExpr': student has to mentally simplify to find the right operation
      easy:   simplify one step (+ -):  [+ 2] * [- 3] into [- 1]
      normal: simplify one step (x /):  [x 2] * [/ 6] into [/ 3]
      hard: simplify two steps: [x (3 + 10/5)] into [x 5]

((*A challenge mechanics for every 'learning step': expliciter toutes les petites difficultés des élèves: transformer l'escalier à grosses marches en tremplin

(((* maintenant j'ai comme une "tendresse" pour les opérations genre [x 2]

*"operator simplification":  [x [2^4]] = [x [2 x 2 x 2 x 2]] = [x 2 x 2 x 2 x 2] (on peut retirer les [])

17 février 2021:  'INDIRECT'
* 0 indirect touch: contactArea is the only entryway for touch
  =>targetTouchSlot.facade on top, targetTouchSlot.touchSlot at the bottom,   so that player can see the two expressions distinctly when try to submit answer

* 0 indirect hold:  if I grab greenMouse's tail, I grab the whole greenMouse. Same thing with any other body part.

(0 sometimes algebrite fails to recognize that two expressions are equal

19 février 2021:
**challenge: Different ways: get to target via n different ways
    inspiré de
      2 + 2 - 2 / 2 = 5
      2 x 2 - 2 / 2 = 5
**challenge: greenMouse in tuxedo: greenMouse displays numerical expression instead of value, target displays value

*fill tool:
    0 bounded fillable
      0 find if there there is a bounded fillable around cursor
      0 create object which fills
    0 unbounded fillable
      0 create unbounded fillable (dynamic object)

*greenMouse: pure operators [+],[-],[x],[/]
    0 gm_calculator
    edu: [(x + 3)] * [-] * [(2 - 3x)]

(((("HE PUSHED A ROCK"
(((("AND THEN HE YAWNED"

20 février 2021:
**challenge: mutating target: each time greenMouse mutates, so does target. It's kind of a curse.
    example:
      linear evolution:       target := target + 2
      exponential evolution:  target := target x 2        (better be quick)
      cyclical evolution:
               target := target + 2
          then target := target -10
          then target := target + 2
          etc.

21 février 2021:
**adaptive pov: pov follows activeSelection size: if object is shrunk by an operator, then pov follows
**size-restricted operators: operators only trigger when greenMouse size is compatible
    edu: put [x2] or [+0,01]  size(10^-2) operators      around _or inside_    a size(10^1) [/1000] operator

*gm: test-tube operators: there is a test-tube wrapper around operator which forces greenMouse to be touched in a particular direction
        ______________
        |[2 x]  <--<--<--<-- [3 + 4]        ==> [2 x 3 + 4]
        |_____________

**bag: put/pick (==push/pull)
    push x1:  touching object pushes  1 instance  of it in the bag
    push x10: touching object pushes 10 instances of it in the bag
**  random pull (==random pick): touching operator random picks an instance in the bag
**challenge: fill bag then "random deliver" (target must be _attained via random picking_)
**challenge: multiple chained random deliveries     (one may try again, and again, and again)

**0 ustensil: operator can be dragged to touch other objects and gets back to its original place when released

**edu: easy arrowing: measure: create measurement arrow next to object

**number fonts:
    even  number: round
    odd   number: spiky
    prime number: noble
  0 tex fonts

22 février 2021:
**challenge: cube target:
    1. player can manipulate target to understand it better:  [turn left], [turn up] operators in order to know what target is
    2. player has to turn and mutate side and turn and mutate side of greenMouse cube to match target cube
    example:
      cube painting
      dice painting (paint dots)

*Scratch-like: any colour you like
  https://github.com/nicolaspoulain/scratchTeX

**greenMouse: boulangerie-pâtisserie:
    - greenMouse starts with coins
    - there are bakery operators: [get baguette (1,00 €)] [get croissant (1,20 €)]
    - each time greenMouse touches operators, greenMouse loses money but gains object
    - unavailable operators (not enough coins) are grayed
    edu: même chose: un parcours à l'endroit puis à l'envers (revente au prix coûtant) permet d'introduire les expressions littérales puis les équations avec des prix inconnus

0 regarder le travail des grands:
    Scratch: https://github.com/LLK/
      dependencies:
**      - http://paperjs.org/
        - plein de trucs de Google... (???) (!!!)

23 février 2021: Quantum Protocol is very good: supergraph, mastery, research, activationCountdown, different activation types: initialize, when <condition>, execute, ...
*supergraph (==story graph): we organize "keyGames" (~superKeyframes) in a graph
**"research": player unlocks new objects when they have enough mastery

**challenge: random in range => narrow range: every turn tick, greenMouse metamorphoses into random number in range. Yet, "source range" can be mutated using operators in order to narrow down possible outcomes.

**0 icObj.parts.curse.parts.counter, icObj.parts.curse.parts.curse_row

**a countDown curse can be put on _a challenge_
((curses for everyone :)

((*coop game: one player controls greenMouse, the other can cook operators

*benecurse: touching benecursed operator adds counters to targetValue's countdownCurse.countdown

***reactiveAnimated: mutating one property mutates the others, in order to stay on animationPath  (==lifespanObj)
      example 1:
        {
          progress: 0.12,

          index:    1,        <--- mutating index results in a progress quantization

          color:    someColor(0.12),
        }

      example 2:
        {
          progress:         0.4,

          name:             "ozij fozjf",
          wealth:           5000,
          nb_of_children:   1,
        }

24 février 2021:
  0 algebraic expressions easy unequal checks: 0, 1, -1
**greenMouse: units: [12 people] * [/ 4 people] = [3]
**greenMouse: dotted line: periodic mutation

**greenMouse: back to binary operators: operations operands can be swapped (dnd)
**redMouse: back to binary operators: three (or two) red mice as left and right operands, left operand is also "receiver"

WOW: https://mathsolver.microsoft.com/fr/solve-problem/7%20%60times%20%208x%20%20%5E%20%7B%202%20%20%7D%20%20%3D3?r=bi&ref=bi

**multistep operation/multistep inverse operation (why not trying harder ?)
    example: [x] * [(3? + 4)/5] = [(3x + 4)/5]
             [(3x + 4)/5] * [(?x5-4)/3] = [x]

((*il y a le test fonctionnel: regarder s'il y a des bugs, et il y a le test "goûteur", le test qui se demande si un humain va accrocher.

*terminalMathNode: x vs ((((((x)))))

greenMouse: expr to x:
*   medium: propose 'reduced' operator when two same-priority operators are chained
      example:  [((3x + 5)/4)*12] --> [x]: propose [x 3] instead of [x 4] or [/ 12]
*   medium: propose equivalent operation: [- (-1)] -> [+ 1]

**greenMouse: binary representation of numbers: 0110011010010
    - shift: left / right
    - invert bits (~)
    - add<n>

25 février 2021:
**challenge: greenMouse: clear target stacks in <n> turns: player has to find the path to clear target stacks in least turns
    - numbers
    - number exprs
    - litt exprs
**challenge: greenMouse: given _hypothesis_, complete challenge
    example:
      _hypothesis_ : _x = 4_,   [3x + 7] --> [74],  using operators: [+ 1] [x 4] [- 6] [- 7]

**challenge: greenMouse: suites: player starts with _n=<k>_ and [value(u_n)], operators are [u_(n+1)] [u_(n+2)] [u_2n] etc.
    touching operator [u_(n+1)] does two things: it updates greenMouse and it updates _n=.._ display: "n=<k>+1"

**ux: tablet: _dragArea_, displayArea, contactArea

((il manque un symbole pour dire c'est une expression ou c'est une opération. e3 / 2e  VS o/ 2o.

**challenge: greenMouse: from expr to x:
    medium+:  depth: 10     (ça a l'air hardcore mais en fait c'est toujours la même chose et ça permet de rendre 'acceptables' les grandes expressions)

edu: on pourrait envisager différemment les niveaux de difficulté:
    easy:     découverte                    prise de contact
    medium:   pratique courante             prise en main
    medium+:  renforcement, automatisation, prise de confiance
    hard:     désautomatisation, ouverture, prise de recul

*0 save/load gameSetup  (save/load anything (don't limit yourself to one serial type))

0 simplify: same priority == same "simplification level":  [frac((7x+3),7)x10] * [x 7] should yield [(7x+3)x10]

(((*qu'est-ce que ça va devenir tout ça ? poussière, chose publique, big money ? Should I give a fuck ? Pourquoi fait-on des enfants ?

**simplify: factorize
**simplify: animate simplifcation process: like combos in Tetris (Attack)
***  edu: tool: clock_simplifier: perform simplification at each clock tick
        Parenthesis removal step can be considered a first-class simplification step. (après on peut en débattre, mais je trouve que le mieux c'est de ne pas mettre la difficulté "parenthèses" entre parenthèses)

*yellowMouse (==chickMouse): comme le tri des poussins, on la balance là ou là
**challenge: yellowMouse: evaluate (numerical) expression
    1. player drags expr to choiceSlot
    2. the expression is drawn to the center of the challenge, in the "center stage" display zone
    3. the expression is then clock_simplified until the solution is shown
    4. player's choiceSlot then turns green if correct (or red if incorrect)
    5. challenge terminates (with success or failure)

0 class Simplifier
*icObj.type = "simplifyZone" : when icMathNode is inside, a top layer simplification is attempted every second (comme des coups de marteau, un petit côté maréchal-ferrand)

**"It's not maths, it's a card game." because the mathematical object is in your hands.

26 février 2021: a day without coding, a day of blah blah
**ux: coterie composite: this composite appears automatically when objects are close from one another and there is a legitimate relationship linking them
    the main reason of this object is to be able to move coterie objects without having to click a lot (== without having to compose or group them, then decompose or degroup)
**ux: preempt user actions: create easy objects for future actions

*card game: crack the code: find x, y and z
  - card cost depends on the "filtering power" of expr
    [z](5):       highest filtering power
    [3z+y](3):    medium  filtering power
    [5x+3y+z](1): lowest  filtering power
  - card evaluates when entering field
  - the game ends when one of the players has successfully found x, y and z

(*greenMouse: equation systems: il faut trouver un moyen de rendre ça facilement manipulable

0 tex: one color for each number place
    EN has nice words place, place value, face value

**number is composite / myCustomNumber / "mon nombre avec jantes 20 pouces": simple is already complex    (~text_destroyer: "text's not just text")
    0,271 avec
      - le 0 des unités:    noir et bold et Arial 100%,
      - le 2 des dixièmes:  rouge et italic et Liberation 80%
      - le 7 des centièmes: animated: rainbow gradient wave
      - le 1 des millièmes: curse: only appears when in invisible light area
      etc.
    http://adereth.github.io/blog/2013/11/29/colorful-equations/
  => 0 RichMathNode
     0 PositionalNumber {}
**number is banana:
  0 https://github.com/pkra/mathjax-img
  0 Xy-pic — Typesetting Graphs and Diagrams in TeX
    Xy-pic is a package for typesetting graphs and diagrams using the principle of logical composition of visual components.
    \xymatrix{ . . . }
**RichMathNode: number has a color stroke (draw in number, and this trait accompanies number (the whole thing is a composite)). If number increments, color stroke is still here.
                number has hat
                number has <anything>
(**sentence tree:
                [turbulent]
                  |
     [Il]       [très]
      |--[était]--|

27 février 2021:
**bad calculators (game on the internet): 'exact par' as "same same but different"-variant source

(((Tu rentres dans l'environnement d'une librairie et au bout d'un moment, tu comprends que c'est le gros foutoir. C'est clé en main, mais le sol est couvert de clés.
      et au bout d'un moment, dans tout ce foutoir, tu finis éventuellement par trouver ton bonheur...

((La dimension visuelle des équations: Comment faire quelque chose d'adapté pour les non-voyants ?
    on parle de membre de gauche, de membre de droite (lol genre les aveugles connaissent pas la gauche et la droite...)

((le dev c'est aussi perdre une matinée pour faire fonctionner une lib...
((*et tu te dis "putain je vais y passer la matinée", et effectivement, tu y passes __exactement__ la matinée: à 11h59, le truc tombe en marche, comme déclenché par un timer...
((*et au moment où tu crois que c'est bon, ça plante à nouveau...

*richMathNode: color gradient (when adding 2 colored numbers)
  https://tex.stackexchange.com/questions/45744/how-to-put-color-gradient-to-desired-text-only/46034

((toujours cette idée de repousser les limites, parce que c'est nul les limites.

28 février 2021:
*greenMouse: challenge multiple endings: contamination: if greenMouse is contaminated then reward is X, otherwise reward is Y.
  edu: une manière de diriger

**reactorMouse (==reduceMouse): mouse is covered with touchSlot, mouse is assigned result
    lore: elle est restée trop longtemps à côté d'un touchSlot
    ==> il va y avoir deux opérateurs pour chaque opération non commutative:
      [x-y] et [y-x]
      [x/y] et [y/x]
      [x append y] [y append x]
**versatileReactorMouse: l'opérateur de surface change quand on la trempe dans un opérateur
    l'opérateur touché est [op]
    si op est un opérateur qui commute: on met op comme opérateur actif dans la _roue des opérateurs_
    si op est un opérateur non commutatif: on bascule vers la prochaine version de l'opérateur dans la roue des opérateurs (exemple: [x-y] devient [y-x])
**turn reactor on/off
    default reactor operator is [+]
**needleMouse:  mouse destroys what it touches
***guzzlerMouse: (versatile)reactorMouse + needleMouse      (aussi appelée worldEaterMouse, gluttonMouse)

**challenge: guzzlerMouse:
    - en haut:  des opérateurs [+] [-]  [x] [/]
    - en bas:   des nombres    [4] [-1] [2] [0,18]

**greenMouse.characteristic / [.is operator]: like a curse, but it takes part of greenMouse definition
    example:
      [.is  evenNumber]
      [.is  hundreds digit is same as units digit]
      [.is  positive]
      [.is  not a multiple of 3]
**greenMouse: all possibles:
    example: let g be a 4-digit even number starting with 1
           9   9
           8   8
           7   7   8
           6   6   6
      [1 | 5 | 5 | 4 ]
           4   4   2
           3   3   0
           2   2
           1   1
           0   0

**challenge: whoami guzzlerMouse: end up with only one possibility from an all-possibles mouse

***challenge: from expr to expr:  [split top layer] [split all]
    1. split expr into components
    2. build new expr from components
  edu: expression rebuild: from expr to same expr
**  various starting stems: reactor core is randomly assigned to a node
    optional: faire travailler la mémoire: on ne raffiche plus l'expression de départ

01 Mars 2021:
**reactorMouse: when split: one component is _reactorCore_ ((==interaction stem))
**challenge: fruityMouse: each digit symbol is replaced by a fruit symbol
    so player has to:
      1. play with operators to get a grasp of which fruit corresponds to which digit
      2. using this new knowledge, use the operators to make target value
    edu: quand on applique plusieurs fois l'opération [x k], comment peut se transformer le chiffre des unités ? et avec [+ k] ? etc.
    medium:   avec des entiers
    hard:     avec des décimaux
    hardcore: avec des complexes

***splitter: output: composite       (weak splitter)
    fireworks split         [1]                   [2]
        \    |   /            \       |           /
        _ [split] _   ==>    _ [composite handle] _
        /    |   \            /       |           \
                                     [+]
      0 animation: explosion

    rect splitter| shape splitter:
      separate square into 4 pieces
      separate square into 2 triangles
      etc.
**operator: assemble: randomly assemble composite parts (arr_icMathNode) to create a single expression (icMathNode)

**clone fireworks: when <condition>:       separate into <n> clones, each following a different direction
      operators: when touching an operator: separate into 4 clones, each following a different direction
      labyrinth: at a crossroads:           separate into 4 clones, each following a different direction

**operator: next type (==morpher): [nextType]: object cycles to the next type it extends to
    example: icMathNode --> icText --> ...
**operator: "equals": [=]     (sûrement plus qu'un simple opérateur)

(((the composite hack:  ONE IS ONE IS THREE

(((Je ne fais que dérouler les possibilités qui se montrent, et ainsi de suite. Comme un enfant qui joue dans le bain.
    Si je démonte, juste après, j'ai envie de remonter.
    Si j'ai une collection, juste après, j'ai envie d'avoir un seul objet.

((déjà dit:*PolyHandle-Puzzle: puzzle created using composites created from subsets of same components set

02 Mars 2021:
***AriadneMouse (==PoopooMouse): when touching a touchSlot: untransformed mouse waits where it touched (==poo poo), while transformed mouse continues "under player's click"
    Branch-cancel PoopooMouse: moving a poop destroys all descendants from this state
    edu: this way, all intermediate states appear on screen (even the unfruitful)

03 Mars 2021:
**reactorGreenMouse: ux: non commutative operator double touch
    - when reactor is in (|y-z|) position: when touching [-] again: instead of selecting (|z-y|) reactor operator, select (|+|) and change [n] to [-n]
    - [n](|/|) becomes [1/n](|x|) when touching [/]
    edu: c'est une autre manière de présenter les choses, qui permet d'afficher un réacteur simplifié (un seul -, un seul /)

**greenMouse: operator is unsimplified: instead of showing [+ 40], show [+ 8x5], or [+ 8 x 5]
    medium: [+ 8x5]   (renforcer les tables)
    hard:   [+ 8 x 5] (renforcer les priorités opératoires)

**customerMouse: [stickman] [bank(-20 € on bank account)]     [buy oranges(2,10 €)] [buy tea(3,30 €)] ...
    edu: les équations, les relatifs (le découvert), ...

((**fabricjs: change activeObject _while dragging_    (please make it easy for future generations)
    		0 recréer les "conditions de départ" du drag
      https://github.com/fabricjs/fabric.js/issues/5820
      https://github.com/fabricjs/fabric.js/issues/2753

04 Mars 2021:
**supervessel: on move start, show supervessel.contactArea (==supervessel.contactArea.isVisible = true;)

**edu: 32bits/64bits: faire sentir la différence avec des "petites instructions" (32bits) vs des "moyennes instructions" (64bits)

**(*)challenge: split,recompose,match
    1. ClassX instance is split into components  (for example: a litteral expression is split into "component mathNode"s)
    2. components are randomly recomposed into a _new instance_ of ClassX
    3. player has to match the new instance with _something equivalent to it_ in a pool of possibilities
    edu: ça fait le lien entre les expressions littérales et les probabilités

**challenge: recycling ground: player may split many source items and put the components in a bag, and then use the components in the bag to create target item
    the idea there would be to split fewer items possible

05 Mars 2021:
supervessel: cargo
0 manage touch with supervessel
  0 the old way: business as usual, but with supervessel inclusion
  0 the new way 1: event capturing: only supervessel is touched
  0 the new way 2: event bubbling: touch bubbles up to supervessel
***infiniteCanvas::operate on active object (can be done while held :) thanks to supervessel)
    - any operation
    - associated ux: une main sur la souris, une main sur le clavier
**Split active object == split supervessel cargo
    edu(/pres): language: split a sentence
    edu(/game): maths: split a refined object, an object which is the result of many operations
**supervessel:make active object(s) touchable
    on peut rendre le truc encore plus mystique en activant cette opération quand le supervessel touche un opérateur spécifique au supervessel

**"greenMouse ex machina": while holding empty supervessel, inject a one-life-only greenMouse under it

**IcObjectTypeOverlay:  (or IcObjectTypeContainer)
    - object type symbol on topleft corner
      |---------
      | S |
      |___|
      |
      |
    - icObject type <-> border color
        mathNode        hotpink
        string          Como
        image           Rajah
        freeDrawing     Dark Violet
        shape           Gray
        video           Cola
        bag             Baker's Chocolate #553516

**challenge: simultaneous release: player must use supervessel to split an object into component and then release/snap them "simultaneously"
    because when snapping an individual component, the other slots close down

((*split void: on peut faire surgir des paires d'objets opposés du vide canvassien

(((the software psychotouch: when nothing explicitly indicates a bug, but still, you feel it under your mouse click

**(*)challenge: multiType challenge: some operators are type-specific, so user has to use morphers before using type-specific operators
    edu: renforcer l'idée de _nature_ d'un objet, et des propriétés et opérations de cette nature

06 Mars 2021:
***shard transformation: morph to typed representation == show icObj.shard<X>
    cette transformation peut être déclenchée en utilisant une touche de clavier: "operate on active object"
      - morph to text description     example: "Il y a un lac à l'arrière plan. Et au premier plan, une voiture et un chien."
***   - morph to code                 ==>This way one can modify the behavior of icObject. (==> DSL)
***   - morph to inner world          On peut zoomer dans l'inner world et intéragir dans cet inner world.

**greenMouse: fractions: colored 'lengths'
    - on touch: append to greenMouse
    easy:     no number tag is shown: only colored rectangles
    medium:   number tags are shown on every rectangle    (1/10, 1/2, 1, 1/20, etc.)
    medium+:  improper fractions: 8/3, 5/2, etc.
    hard:     target is a number (there is no target rectangle)

**collection-only operators (==bag operators): pour montrer la distributivité
**edu: The Mirror

0 l'inverse de split: join
  0 incorporate geometry:
      [                ["i"] ]
      [ ["w"]["o"]["r"]["d"] ] * [merge] = ["    i\nword\n    e\n    a"]
      [                ["e"] ]
      [                ["a"] ]
  0 animation: center attraction
**math: prevent join from creating "divide by 0" expressions
**  allowed mathNode / allowed subgraph

*que se passe-t-il quand on join() des objets de types différents ?
  0 hierarchie de types
  0 appeler ça autrement: merge, marry, unite, combine
  0 trouver le bon verbe pour chaque situation

**maths: brainfuck: use operator symbol as terminal symbol name (3+ + 4 - 4/ x 3): i think this could get funny and mad

**logical puzzle: all must be true
    - problèmes de tri
    - self referential puzzles: there are 3 objects in zone A
    edu: sur la nature des objets:
      zone A: any number inside is < -5
      zone B: any number inside is even
      zone C: any number inside is only composed of 1 and 2 as digits
      zone D: any number inside is a perfect square
      zone E: the sum of numbers inside is 20
      etc.

07 Mars 2021:
*challenge: reuse: create touchOperators by splitting expr
*join: triangles semblables

**"dropper un reset": erase the past
    principe:
      - les élèves abordent une notion via un ensemble de challenges
      - il y a des stats qui sont reliées à la notion: pour faire simple succès|échecs
      - une fois que l'élève réussit un certain nombre de fois d'affilée sans se tromper, un bouton "reset" peut apparaître pour réinitialiser ses statistiques. "'Oh, j'ai droppé un reset', s'écria-t-il."
      - cela donne la possiblité à l'élève de se la jouer en exhibant ses "flawless statistics"
** edu: on peut même jouer sur les stats pour ouvrir de nouveaux challenges: min. 10 attempts and 90% success

***greenMouse: properties: [A=>B] * [B=>C] = [A=>C], target is [A=>Z]
    edu: on peut aussi expliciter: [A=>B] * [B=>C] = [A=>B=>C]
**greenMouse: equation::equivalent equations: show <=> sign: [A=B] * [x 3] = [A=B <=> 3A=3B]
    or build a composite: with head part and trailing part
      [
        [  [A=B]
           [<=>]
                  ]   trailing
        [ [3A=3B] ]   head
                    ]
      only head can interact with other objects/be operated on

***landing stage: where a new object will be spawn in
    - default: infiniteCanvas
    - usage: new objects spawn in landing stage (object or infiniteCanvas, or infiniteCanvas.layerX))
        this is the main mechanic for object enrichment

08 Mars 2021:
**challenge: fractions: la planche à découper: on laisse des morceaux sur la planche quand on prend une fraction d'un objet
    - [x (1/3)] means we cut in three equal parts and then we pick one part
    - [x (2/3)] means we cut in three equal parts and then we pick two parts and join them together

**edu: redMouse/redMice: fractions: montrer la droite graduée au plein milieu de l'aire de challenge, disable z-scroll for redmouse

(**the taoist way of understanding numbers: numbers and operators arise mutually. L'un ne va pas sans l'autre.

*Same function, different worlds: append_left(a,b), append_right(a,b) (==append_left(b,a)) in the string world and in the math world are very different.
    quelque chose du genre: a x 10^(floor(log(b))) + b

09 Mars 2021:
(**J'aime pas les soi-disant jeux qui à la fin te disent: Bon bah tu t'es trompé 4 fois sur les 10 épreuves. On te donne 6 étoiles.
    Pour moi, "l'important c'est de passer". Peu importe le nombre d'essais, l'important c'est de franchir l'obstacle. L'important c'est de ne pas être empêché, de pouvoir voir ce qu'il y a après.
    On est pas là pour sanctionner, on est là pour faire progresser.

10 Mars 2021:
**l'"objet opérateur", du coup, il est à gauche, ou à droite ? Dans ma tête, il est parfois à gauche, parfois à droite. Ca dépend. Ca dépend des jours ?
    [1,5 x] 24 VS 14 [x 2]

**"Et ce serait dur de mettre un système d'analyse des réponses des élèves ?"(merci David)
    0 Prélever les données. Il faut mettre des capteurs de données pertinentes dans le code des challenges.
    0 Traiter les données:
        0 librairies de stats
        0 edu-tailored libs: il existe peut-être des bibliothèques "edu" toutes faites

11 Mars 2021:
**VS game (vertical split screen): green rain
    - on each player screen, it's raining operators
    - player can try to create the biggest number possible
    - sometimes, when a player has "made a good move": it's raining [x 0] operators on opponent's screen

12 Mars 2012:
***error management: keep the machine running: from player mistake to platform|runtime error
    - frame is cropped:  next challenge frame corresponds to player input: No mistake, no cropping.
    - memory error: challenges spawn regularly, if player takes too much time to solve challenge, there will be too much objects hence a memory error.
    - screen flood: previous challenge is cleaned wrt player's success: No mistake, perfect clean. So that, we mistakes accumulate, the screen is flooded with previous' challenges parts.

((**l'ensemble des nombres que l'on peut produire avec un ensemble de symboles: from graph theory to number theory

**octoMouse(==icExoSkeleton(mouse)): exoSkeleton provides "realization limbs" to value-only mouse:
      area:                         interaction:
    - grabArea                      player --> mouse
    - contactArea                   mouse  --> other objects
    - displayArea                   mouse  --> player
    - decorationArea                mouse  --> player
    - ... (?)
    - internalsArea(==valueSlot)    mouse  --> mouse  (a priori, not visible)

  => supervessel{octoMouse{value or expression}}  ... ça fait pas mal d'emballage
    supervessel, when solely cargoing an exoSkeleton, is like an "exoSpirit" possessing the exoSkeleton

*operators are "naturally" reactive: makeReactive([+]) * [n] = [+ n]

**glassMouse (curse): mouse breaks if something illegal is done
**glassMouse (curse): equations: mouse breaks if left side is mutated without having right side mutated the same way
    en fait ici, on a affaire à une octoMouse avec deux "valueSlot"s et un "decorationSlot" (pour le signe =)

**manage simulteanous touches:
    - open touch phase
    - collect all touches
    - close touch phase
    - resolve all touches

**equations: gemini-headed octoMouse: when one operations is applied to left side, it is automatically applied to right side too

13 Mars 2012:
*color gradient between exolimbs  (pour montrer les relations entre exolimbs (ce truc-là, c'est le "toucheur" de cette facade, ou plutôt des internals représentés par cette facade))
  example: yellow-blue gradient between display and contact
***3D-->2D: _canvas lock/unlock_ (à la The Witness): player moves freely in a 3D environment and can focus on boards (which are (in)finiteCanvases)
    edu: one board for each subject   (at least)
    edu: board pov stays where the player left
    fun: wormholes from one board to another (==portals)    3D.location1-->board1.position1-->board2.position2-->3D.location2
   => Ce serait bien de voir un jour ce point réalisé.
   more madness: move 2D object from canvas to 3D HUD (which is a permanent 2D space) and then back to another 2D "true" canvas
   even more madness: 3D HUD is z-cruisable: like the glasses overlay of the hi-tech military.   Write stuff in green to match the cliché.

*touchSlot (active) VS contactArea (passive, delegator)
    => touchSlot.touch(contactArea.delegate)

**compose: create equation: create equation composite from 2 icMathNodes
**poopooMouse: equations: poopoo log: when transforming an equation, the previous version is added to a log (displayZone), so we can see the equivalent equations history

14 Mars 2012:
(**Il y a déjà le concept de greenMouse dans The Witness.

16 Mars 2012: SOLVE ET COAGULA
(Il y a déjà le concept de greenMouse dans les motifs de déverrouillage des téléphones

(((*from audience to vidience: not hearing but interacting

**Z-Puzzle: find the right homeScale using "membrane markers"
    -hardcore: optional marker (marker may or may not be used)  (~téton sorti ou téton rentré)

***Black-box onion puzzle: there is a black area on the screen which contains operators, player has to discover what are those operators. The "onion trick" is that an inner-layer operator can touch greenMouse only after the outer layers have been traversed.
    bbbbbbbbbbbbbbbbbbbbbbbbb
    b[+   2][-  1][+ 7][/ 8]b
    b[+ 4][+ 1][x 9][-   8 ]b
    b[/   10][^ 2][x (-1)  ]b
    bbbbbbbbbbbbbbbbbbbbbbbbb
    the more layers the harder it gets
***Black-box onion greenMouse challenge: the goal is not to snap operators on placeholders. Rather, it is a classic greenMouse challenge. Player has to find a route to attain target. Of course, route could imply coming in and out of black box.
      there is a touch sfx to identify when a touch occurs while in the dark
    easy: operators are contoured

(((comme quoi ça peut parfois être productif d'aller traîner son skate sous la pluie

((on a besoin de mécaniques qui se marient bien avec l'"objet d'étude"

(*en fait l'idéal serait de se poser pendant un certain temps avec quelqu'un pour dépiler still_shute, pour le transformer en quelque chose de beaucoup plus lisible

17 Mars 2021:
*edu: geom greenMouse: [rect shape] * [+ 10] = [rect shape "with 10 added"]   ,  [rect shape] * [x 2] = [rect shape with doubled area]
**edu: unification via variety: _après une certaine maîtrise des concept-challenges, pris isolément_, mettre des instances (aléatoirement) de différents concept-challenges les unes à la suite des autres pour unifier tous les concepts.

(((**loups-garous avec des nombres: les impairs: loups, les pairs: villageois (C'est drôle j'ai toujours considéré les nombres pairs comme plus débiles que les nombres impairs.)

(**une salle de classe, c'est comme dans une salle de concert, t'aurais envie de sauter partout, mais tu peux pas, _y'a pas la place_. L'espace individuel est contraint.

((((FUUUU... donc là je perds du temps à cause d'erreurs du moteur, alors que j'ai envie de programmer des exercices...

0 decomposition operators:
    - prime decomposition             [decomp_product_prime]
    - digit*power sum decomposition   [decomp_sum_digpow]

**A fraction doesn't care about how it's been produced, it has no regard for its past. 1/27 does not care if it's 1/(3x3x3) or 1/(9x3) or (1/3)/9 etc.
    Whereas a litteral expression is nothing but a transformation log.
    A numerical expression is halfway between those 2 ends.

*edu: fractions
    [1 / 20] * [x 2] = [2 / 20]
    [1 / 20] * [x 2] = [1 / 10]
    Il y a deux [x 2] différents ici:
    on pourrait s'amuser à créer des rôles pour le 2 du [x 2]:
      - un qui aime monter sur la fraction   (== qui aime multiplier: [1 / 20] * [x 2] = [2 / 20])
      - un qui aime détruire le dénominateur (== qui aime diviser:    [1 / 20] * [x 2] = [1 / 10])
    et ensuite dire que c'est la même chose.

18 Mars 2021:
*can't escape from curse: split mouse must still be cursed, even when in split form
  - ? every bit is cursed ?
  - ? there is a curse halo ?

0 singleOperatorize (~flatten)
  0	[/ 3] -> [x (1/3)]
  0 [- 3] -> [+ (-3)]
  0 remonter tout le priorityShell...

**black box number challenge (==conditional simplification): what you see is not precisely true
    - [56] is displayed, but internally, number is [4 x 2 x 7]
    - when player does [56] * [/ 8], simplification does not occur, [56 / 8] is displayed (internally it's now [4 x 2 x 7 / 8])
    - when player does [56] * [/ 4], simplification does     occur, [14]     is displayed (internally it's now [2 x 7])
    (hardcore: only last term simplification is allowed: [4 x 2 x 7] * [/ 4] = [4 x 2 x 7 / 4] and [4 x 2 x 7] * [/ 7] = [4 x 2]

((c'est marrant, on peut faire new math.ConstantNode(-2) mais pas new math.ConstantNode(1/2)

((a x (b x c) = a x b x c   does not seem to have the same flavor as    f(a, f(b,c)) = f(a,b,c)   but that's what we mean sometimes. It's like the multiplication is diffused, and "x" is only a separator.
    En fait on est devenus dans tout ce qui est binaire, parce qu'on a continué à vouloir écrire sur une seule ligne et que, dans ce cas, tout élément a une extrémité gauche et une extrémité droite et c'est tout.
    La même chose pourrait être conclue avec le temps qui s'écoule "dans une seule direction seulement".

19 Mars 2021:
  (0 class PriortyShell

((comment appeler l'inverse de l'inverse ?  exverse ? deverse ? preverse ? averse ?

20 Mars 2021:
(((*"universal 7" == 7, _all representations accounted_   3+4, 2.9+4.1, -5 + 12, etc.
** 0 simplification with "keep unsimplified factors order" is not that simple to do

**redMouse: fractions:: add|subtract fraction challenge: split, rework parts, gather

**operator decoration: decorate operator function with simplification function ("same same, but different" :) )

**conductive area operator: (mainly for binary operations (add, append, ...))
    example: [6] * [+]{[4]} = [10]  and [4] is consumed
**greenMouse: temporary rest zone (==SafetyZone): when released in this zone, greenMouse is not reset

**green greenMouse(en français: souris verte écolo): objects which have been produced using greenMouse are destroyed when greenMouse is destroyed
  edu: player may produce helpful representations of greenMouse when trying to solve a puzzle (typically: fraction with prime factorized "ators")

**greenMouse: intermediate target slot (==viaTargetSlot)
    with _the same green mouse_:
      1. touch intermediate target slot(s)
      2. touch        final target slot
    => when greenMouse resets, intermediate touch slot resets too

25 Mars 2021:
**expiring mutation: object resets to previous state on expiration
    edu: fractions: decomposed version is shown for 3 seconds

0 prevent target "exopeek" version from touching target slot

26 Mars 2021:
***BulletMouse (meta-challenge): "Deterministic road to success (==TIM/Eets style)":
    edu: ROAD TO PROGRAMMING
    - Player has no control over mouse.
    - Player interactions are:
        move operators so that bulletMouse run into them
        push start button
          Bullet will then start moving and encounter operators which will mutate bullet.
          Challenge completes if bullet has the right value when touching target slot.
    première forme: "linear"
    deuxième forme: plumbing style: some operators change the direction of the mouse
      easy: value changing operators on one side, direction changing operators on the other side
      hard: {value, direction} changing operators
    troisième forme: not your average bullet: ~"polarization"
      "polarization" operators: when bullet touches a polarization operator, bullet polarization (==color) is set
        example: [* --> blue]
       polarized operators: bullet is only affected by operators which polarization matches bullet polarization
        if the bullet is blue, then a red operator will have no effect
        example: [if(red){   }]
      hardcore: polarized polarization operator: [red --> blue]
        edu: this is somewhat similar to proof construction

    quatrième forme: multiple inputs: 2 bullets, n bullets...
      edu: addition de fractions
*     use conductive area operator _[+]_
      edu: pour la soustraction, il faudra utiliser [x (-1)] sur l'un des deux opérandes
    cinquième forme: [bullet<N> start] is a touchable operator

    sixième forme: slider-controlled time   (give the user some "greenMouse feeling" back)
      only forward, for a first approach

**bulletGolf: getting closer to "real" golf: [stop] operator
    -there is a long road between tee (==bulletStart) and hole (==targetSlot)    (player has to dezoom to see targetSlot)
    -some parts of the golfCourse require the ball to have a certain value, or to have a value in a certain range
    -player has to use [stop] operator to end his shot at a certain position and prepare for a new shot, starting from there

*greenMouse::greenMice: SafetyZone conductive operators:
    fractions:
    edu: 1. challenge with one greenMouse and target slot is right after _[+]_[1/30]_   (addition is prepared)
         2. challenge with two greenMice  and target slot is right after _[+]_
         3. challenge with 3+ greenMice ( reworked(reworked(A)+B)+C )...

**parameters galore conductiveOperator ("conductiveFunction"): [set] color, value, shape
    operator has multiple parameters, _each with a different type_
    so that when operator is actioned, parameters are used:
      [conducted] or default value for the missing

*icPlatform: object released on a platform is added to the platform: when platform moves, platform and objects on it all move together, resize together, rotate together, flip together, etc. (like an adhesive board)
*dropTouchSlot: touch activates when object is dropped on slot

*equation platform:
    ----      ----
    [   ]____[   ]
    [   __=__    ]
    [___]    [___]

27 Mars 2021:
*floodTouchSlot (le contraire d'un dropTouchSlot): when _touchSlot_ is slid and released under an icObj, then touch activates
*shovelPlatform: when _platform_ is slid and released under an icObj, icObj is added to platform terrace

0 platform on a platform

((*conductive operator: there is "true input" (active input),"conducted input"(passive input == context) and output
    => "context operands",  calculer c'est d'abord parser

**snapSlot-based conductive operator: If slots are empty, displayed default values are used. If slots are filled, snapped value is used.

**challenge: cooking table: conductive operators (_[+]_,_[-]_,_[x]_,_[/]_) are in the center of the challenge area. Player has to cook target number using "raw ingredient" numbers.
*conductive operator: when operating
    settingA: consume conducted_operands (~> conducted_operands == input)
    settingB: retain  conducted_operands (~> conducted_operands == context)

(**less code could be written if "generalized proxies" i.e. inheritors, decorators, containers, composites, and any kind of "I contain that kind of thing you operate on" were all managed the same way

28 Mars 2021:
**(*)draw the operator: 1. user draws an operator, 2. system recognizes what they have drawn, 3. drawing is now considered a legit operator

*edu: impossible button: user has to press it 15 times for it to trigger
   this way, player doesn't get the habit of skipping or gets it _less likely_

**upgrade icObj to icObj2:
    upgrade [x 2] to [x 2 / x 2](fraction operator)
    upgrade [x 2] to [x 2 = x 2](equation operator)
    upgrade [x 2] to [area x 2](shape operator)

*edu: fractionOne_operators animation: every 1.5 seconds, operator display swaps (either it shows [x 1] or it shows [x 4 / x 4]). So that subliminally, student gets that value isn't changed.

*edu: gmSafetyZone could be used to "pause" (the pause being either student-initiated or teacher-initiated)

29 Mars 2021:
**challenge: in order: n "sticky" greenMice: we can start with any of them and then stick the others in order
    so that any greenMouse in this challenge is a reactorMouse which then becomes a greenMouseComposite (releasing the composite makes the greenMouse parts go back to their place, and the linker "<" parts are destroyed)
((*C'est drôle ; un truc simple à dire n'est pas forcément simple à coder.

30 Mars 2021:
**eduDemo/eduQuestion: c'est un challenge modifié pour qu'il soit présenté à la classe
    on pourrait dire que c'est le tutoriel
  1 edu: première eduDémo devant les élèves: frac add (:))

**eduQuestion: "What is the value of the GM at the end of the path ?"
**  WOW effect: GM actually follows path when [PLAY] is pressed

**[PLAY] operator is just another operator: Le bouton "Run" dans Scratch est à l'extérieur de la zone de rendu. Dans l'infiniteCanvas, il est à l'intérieur. C'est un opérateur comme les autres.

31 Mars 2021:
*edu: demo: distributivité: [1 + 3] * [x 2] = [2 + 6]
*"atomic fraction simplification" operator (example: [/2 / /2]): does not trigger if simplification by <n> is not possible

***interacting with student's writing: LET THERE BE LIFE
  1. students draws some operators on their paperbook
  2. an image capture device is used to bring the paperbook image to the infiniteCanvas
    a. image is captured (teacher's phone)
    b. image is conveyed through network to computer running infiniteCanvas
    c. image is imported to infiniteCanvas
    d. image is analyzed and parsed: drawings are now legit operators
    (a. and b. can be performed with ChingView)
  3. let's interact

** colored feynman slash
    Il y a du dev à faire à ce niveau là (custom Mathjax tex package)
      edu: each simplifiable factor pair could be slashed with a different color

**tree analysis output variety:
    - mark nodes in-place
    - spoof nodes in-place    (example: ConstantNode(1) becomes MySummerNode(1))
    - analysisOutput object   (with its a structure of its own)

((*Any step is a discovery step. Any step is a hacking step. (bricolage / make things happen). Nothing comme zizi

02 Avril 2021:
**edu: corrigé des exercices: plus facile, plus rapide
    1. importer l'image de l'exercice
    2. ramener les opérateurs adaptés
    3. capture d'écran
    OR even better:
    4. serialization

**decomposition operators: many flavors
    decompose step by step:
      output: primeA x compositeB
        in prime order
        in "easiness" order
      output: compositeA x compositeB
    random decomposition
    recompose
    recompose step by step

**fractions: rational number decimal period
    eduDemo
      gm: [x=1,517...]
      operators:
        [x 1000]
        [decomp:sum something + x]
        [- x]
        [/ 999]
        [show approximative value]
    then same thing with random decomposition
    challenge

**challenge: integer / not integer

*0 edu: any input:
  0 STT(speech to text)
  0 OCR (optical character recognition) (of selected screenArea)
    0 Math OCR lib in js ? => use Emscripten to create a js lib

**reification: "scale" representation (number "is a" thin and long rectangle): "reictangle"
**reification: "duda" representation of a numerical/litteral expression (using colored squares)
  edu: this will pave the way to the first-degree equation resolution process

**shape operator: [x k]: many flavors
    [x 2 <->]  (scaleX: x 2)
      example:
      [] * [x 2 <->] = [][]

    [     ^]
    [x 2  |]   (scaleY: x 2)
    [     v]

    [x 2 diag] (scaleX: x sqrt(2), scaleY: x sqrt(2))

    [x2 (diagonaly copy)]
      example:                  []
        [] * [x 2 diagCopy] = []

**shape operator: reshape ("gravity")
      []
    []   *   [gravity x]  = [][]

    []                    []
  []   *   [gravity y]  = []

**shape operator: reshape using wall collision
      []     |         []|
    []   >>> |   -->   []|
            wall

((*L'idée ce serait de faire passer subtilement cette idée : Si on s'intéresse à la _transformation_, alors a * [x 1] = [a], c'est très différent de [1] * [x a] = [a].
    D'un côté on a une idée plutôt arithmétique (~entiers, cardinal), de l'autre côté on a plutôt une idée géométrique (échelle).
   La commutativité, c'est quelque chose de bizarre.

**R-Puzzle: Rei-Puzzle:  from black unit-length shapes   to colored scaled shapes puzzle
    there are "rei operators" ([+ 1], [x 2], etc.)
    there are color operators ([blue], [red], etc.)     (or even [nextColor])
    the montage area is a gmSafetyZone
    edu: c'est un bon moyen de faire sentir le côté "travail sur l'échelle"(agrandissement, réduction) de [x 2]

*fraction: [x 2 / x 2] rei-edition: this subdivides the reictangle, nothing less, nothing more

*icBloom: composite({core,facets})
  [bloom] operator (==start bloom with touched as core)
  [petal<X>] operator (==createFacet and add to current bloom)
  ? bloom de bloom: à quoi ça pourrait bien servir ?

03 Avril 2021:
*challenge: assign, alloc, dealloc: faire sentir ce que c'est qu'une variable

*homebringer: z-scroll of one object also z-scrolls _related_ objects

(*0 try to have multimouse working on infiniteCanvas

04 Avril 2021:
**challenge: add digits
    this requires "welling", either via operator or using keyboard shortcut

*slotableGreenMouseWell: well has two slots: one slot for the original (input) and one slot for the clones (output)
  so that player can take back the original and put something else in the input slot
**(*)"wellSelection": wellSelected objects will _clone on drag_ and original will keep their place

**edu: keyboard keys statistics:
***IC KEY CONCEPT: "I Am Dismantling in Order to Re-mantle" / "Sorry Engine, I've got a call-up from Master User" / resource everywhere / sheep everywhere ("T'inquiète pas, ça va repousser.")
    En prenant n'importe quel morceau sur n'importe quel objet, je peux créer des compositions intéressantes.
    L'idéal étant de débrayer, si un moteur est concerné, avant de prendre un morceau sur un objet. Mais _ce n'est pas obligé_.
    Embrayer/débrayer (en anglais: engage/disengage, ce qui est cool parce que ça commence comme engine)
    => Les objets doivent être conçus pour être démontables facilement.
    exemple:
      Je tape un texte. Quand je tape la touche "e" du clavier, un objet écouteur de 'touche e pressée' incrémente un compteur et une réification du compteur en forme de rectangle se met à grandir.
      Même chose avec les autres lettres.
      Au bout d'un moment, j'ai des rectangles de différentes longueurs correspondant aux fréquences des lettres.
      J'ai envie de prendre chacun de ces rectangles pour fabriquer un histogramme.
      Je peux le faire en les déplaçant (displace) de leur objet porteur (en l'occurence de l'écouteur de touche).
      Si je n'ai pas débrayé, l'histogramme va être synchrone avec les appuis de touche ultérieurs.
      Si j'ai débrayé (disengage) avant de déplacer, les rectangles étant maintenant déconnectés de leur objet porteur, il n'y aura plus de synchronicité.
        Soit les écouteurs dépouillés (shorn) vont attendre qu'on leur glisse des rectangles de réification ([furbish]) et ils seront readyiés et on pourra alors réembrayer (engage).
        Soit les écouteurs dépouillés (shorn) vont attendre qu'on leur glisse des rectangles de réification ([furbish]) et ils seront readyiés et l'engage se fera automatiquement (.isEngageOnReady == true).
        Soit les écouteurs dépouillés (shorn) vont être réparés
             de façon automatique (.isAutoRepair == true)
          ou de façon manuelle ([repair] operator or shortcut key).
        Soit les écouteurs dépouillés vont être laissés tels quels (parce qu'on ne les utilisera plus).
      Réinitialiser les écouteurs, c'est réparer si nécessaire puis remettre les compteurs à zéro.
    TLDR:
      displace != dismantle
      dismantle = disengage, displace
      repair = furbish, engage
      reset = repair, reinit

**RCMouse: use WASD to move mouse around
    fun: joystick support

05 Avril 2021:
**colorPicker: comment n'ai-je pas pu y penser avant ?

**RCMouse _system_ (à la 'Press Ctrl'): mouse1 touches buttons which make mouse2 move, mouse2 touches buttons which make mouse1 move

**conductive operator, symbol edition: [x [...] [...]]: with this operator, we can build [x [2] [y]], [x [-1] [z]]

**greenMouse: smart additive decomposition * division
    example: [192] * [smart decomp wrt /16] = [160 + 32]
             [160 + 32] * [/ 16] = [10 + 2]
             [10 + 2] * [simplify] = [12]

***YOUR OPERATOR: ask students to imagine an operator of their own

**greenMouse: equations:
  1. classic gm challenges
    0 challenge: get to [x = v]
      0 challenge 1 : 3x + 18 = 54
      0 challenge 2:  3x + 18 = 5x + 60
      0 challenge 3: 5(x+1) - 12 = 13
        0 develop and reduce
        0 continue using the standard algorithm
  2. smart pool challenges: (student has played with the mechanism, it's now time to be a little clever)
    0 challenge: smart pool of operators: some operators are clever (multiply by fraction for example)
  3. choose answer/follow path challenges:
    0 challenge: touch the right answer: resets challenge on wrong answer
      0 challenge 4 : can only get to  5x = 25 	 using operators
      0 challenge 5 : no more operators, you have to do the maths in your head
        0 you have to follow the right path

06 Avril 2021:
*gm: relative numbers: challenge with [- 100] [- 10] [- 1] and their inverse operators
0 [show], [hide]
    show/hide composite

*edu: the equation movie: in the top area of the screen, a movie is shown with someone performing physical operations. at the bottom, play can mimic what's happening using operators.
  example: in the video, we see someone manipulating apples, putting them in bags, moving the bags, picking some apples from a bag, etc.

*edu: on peut amener de façon naturelle les opérateurs [opposé] et [inverse] ([0 -] et [1 /])
    1. on fait d'abord utiliser [+ 2] et [x 2]
    2. on fait ensuite utiliser [2 +] et [2 x] ((et on voit que ça fait la même chose, à part peut-être quand on écrit sans calculer (y × 2, ça s'écrit pas pareil que 2 × y) ))
    3. on fait utiliser [0 -]
    4. on fait utiliser [opposé]
    5. enfin, éventuellement, on pourrait envisager de ressortir des cartons le "petit moins" [-]

**curse/uncurse operators:
    - standardCurse:  curse will withdraw only when withdrawal condition is met   (example: when touching [uncurse(<X>)] operator)
    - singleUseCurse: withdrawal condition is "curse has been consumed" == curse actionates once then withdraws
    - hardCurse:      there is no withdrawal condition
    examples:
      [curse: autoSimplify]
      [curse: autoColorize]

**(*)context operators:: meaning-based operator
    example: [(2y + 10)/2]  *  [10 == 5 x 2]   = [(2y + 5x2)/2]
                              \meaning-based/
      so then [(2y + 5x2)/2] * ["simplify"] = [y + 5]
    edu/dev: this means that we have to anticipate and identify what the student would like to do.
             maybe via a pool, but it must not be cluttered
             What would be nice would be to identify common mistakes and
                propose the operator they would like to use _given their 'mistaking context'_,
                to show them that the rules of maths make it roll not as what they would expect

*greenMouse: exponent operator: [ ²](unary), [^ 2](unarified binary)

07 Avril 2021:
**(*)[meta] layout is meaning. When looking from afar, you know what it's about.
    If it is a challenge about addition, write a "+" sign with the operators/objects involved.
     []
   [][][]
     []
    If it is a challenge about multiplication, write a "x" sign, etc.
  edu: when student thinks about the challenge, subliminally, they will see the symbol perspiring from the layout.

**slice cut: cut image following slice path
    edu: pour montrer les produits de fractions: 24 * [x 1/2] * [x 1/3]

**atelier: neither a challenge nor an eduDemo, but a place where the player can tinker
**atelier::create a fraction
                    [num <- 1] [num <- 2], ...
    [fracWell: ?/?]
                    [den <- 1] [den <- 2], ...
    edu: so that there is a sense of number line, and proportions
          if player touches                                               [num <- 6]
          and then                         [den <- 3]
          player then feels that the numerator is 2 times the denominator
    edu: this seems a boring atelier at first glance but:
            - player can then generate its own fractions to turn sheet exercices into manipulations
            - player subliminally gets used to the assignment operator, and to the relative proportions
            - player does not touch keyboard

08 Avril 2021:
**(*)more kinesthetic feeling of number: touchScreen touches
    shrink/grow: pinch and spread (p-IN-ch"/"p-OUT-ch)
      player pinches/spreads a reictangle in a number bloom : number shrinks/grow accordingly
    2-finger pinch for 1D-scale
    3-finger pinch and 2D-scale

12 Avril 2021:
***ic digitalBootstrap: from basic skills (move the mouse) to advanced skills (spawn, copy/paste, group/compose, protoSlots, ...)
      1. use the mouse:: leftclick
        challenge1: player must handdraw a line from A to B
          this challenge is "greenMoused": if leftclick is released before reaching B, handdrawn line is erased
        challenge2: same thing with obstacles: if an obstacle is touched, handdrawn line is erased
      2. use the mouse:: move object to touch other object
      4. use the mouse:: rightclick
        challenge3: player must handdraw a line from A to B, but point B is not visible on the screen: player must rightclick to pan current visible area
        challenge4: line is a redMouse: player must draw, pan, draw, pan, etc. to reach point B
      5. use the mouse:: scroll
        challenge3: player must handdraw a line from A to B, but point B is not visible on the screen: player must rightclick to pan current visible area

      6. use the keyboard:: spawn object
      7. use the keyboard:: copy/paste object
      8. use the keyboard:: group/ungroup objects
      9. use the keyboard:: compose/decompose objects
      etc.

**mixed-selection copy, paste in outer software (specially Writer, Calc, Draw, etc. (==standard office software))

13 Avril 2021:
**flyTag: when an object enters flyTag's area (range or specific region) and flyTag's text matches object (object type, value, ...) then flyTag will stick to the object, as long as it remains in its covered area.
    edu: on peut imaginer une zone bizarre, pleine de mouchétiquettes, qui servirait à faire un rappel du type d'objet que l'on est en train de manipuler (nombre, opérateur, nom, verbe, adjectif, ...)

** single/multi management: there is a big area where player can choose how they want to play : single or multi
    player creates a round avatar and then manipulates it, as any other icObject, if it is dragged into a roomConnection slot:
    then players' active avatar spawn in a bounded-yet-infinite multiplayerArea
    .____                 __________________
    .  o |               ||o             o ||
    .____|               ||you           p2||
    roomConnectionSlot   ||________________||
                            multiplayerArea
    edu: some challenge may be multi only / single only

**curveLength challenge: Player has to draw a curve from A to B with length in given range
    variant: A to B to C to D, each portion within a given range

*the "* [operator]" process:
    for a mathNode-based operator:
      1. findMathNodePathInObject(icObj)
      2. if a path was found: apply transformation using path
      3. return transformationOutput

14 Avril 2021:
**(*) (madness) ic operating system: "everything is there"
    Sur le même modèle que l'OS dans lequel on se déplace en 3D et dans lequel le bureau, c'est vraiment un bureau.
    Mais ici, y'a pas de bureau, juste un gigantesque tapis d'enfant pour adulte, un bac à sable d'étoiles de travail.

*V-scroll: change selected object opacity

15 Avril 2021:
*(freeDrawn) overlay operator: connect different objects with (drawn) overlay operator, then release
      [     ]  #  [     ]
      [  A ######### B  ] = [A + B]
      [     ]  #  [     ]

*operator: pixel-of-color counter

***eduDemo::spawn wrt context:
    context can be:
      - active selection
      - current location:
        - current pov bounds
        - current subworld (example: the fractions world, the equations world, the adjectives world, the colors world, ...)
      - current activity ("active ity")
      - current time:
        - current "sequence" (example: little red riding hood)
        - current "frame"    (example: the wolf is about to win)
    examples:
      spawn a 2x2 table with cell proportions: my active object
      spawn a multiplication table with starting number: my active object
      spawn the next sentence/the next character of the story

***eduDemo::switch to edudemo keyboard shortcuts: DSI (domain specific input), the input equivalent of DSL (domain specific language)
    edudemoX.automaticallySwitchToDomainSpecificInput = false;
    design: il va falloir définir les touches qui ne changent pas et les touches qui accueillent le DSI


**(*)scripted operator: write your own code in operator's icText field,
      example: if() {} else {}
***scripted template operator: "don't write, just drag"
    snapSlots or platforms to host objects
      example: if(input is [<>]) {} else {}
    operator is functional when all its parts have been filled
    This is a 3-star idea because it enacts "code is data, data is code"
*   truth-value operators: [== 2], [> 2]
      slot-based truth-value operators: [== [<>]], [> [<>]]

16 Avril 2021:
*undo/redo keyboard shortcuts
    dev: this part may not be fun

**greenMouse: create sentence for the image.
    at each step, there is only one valid spelling, but there is no mistakeBomb ("Oh my god you made a mistake"). The sentence simply does not validate at the end.
    Releasing mouse resets sentence.
    examples: [[El] [niño] [esta] [jugando] [en] [la] [calle]].
              [[Le] [chapeau] [de] [la] [dame] [s'envole]]

17 Avril 2021:
**what is "to manipulate" ? use hands and handtools
    - slice (with or without sawcut)
    - tape/glue together
    - fold
    - press/pressure (varying intensity --> varying response)
    - make holes
    - rotate/scale/flip
    - arrange/dispose (move, align, center, ...)
    - superimpose
    - decorate/paint/draw/write
    - bend
    - pin
    - attract/repel
    - copy/cut/paste
    - bag/unbag
    - intrinsic manipulation (shake, press, etc.)
    - capture: photos, videos
    - hoard (i like it, i'll keep it)
    - build worlds, build stories
    - share
    - "make it roll" (domino effect) (display an intrinsic property of an "external composite" ("outrinsic" property)) ((what is in, what is out ?))
    - repeat: same conditions, same results ?
    - "gong" (tap and listen to the sound) ((y'a pas que l'image dans la vie))

**(*)slice anything:: slice mathematical expressions
    a sliced mathNode would create an expression and a "cutout operator" which can be seen as an _incomplete expression_
    edu: this "cutout operator" could be used to try the operator against different values
                .
      [(x + 12) . / 3 + 5] --> [x + 12]   ;    [... / 3 + 5]
                .                              ^_ cutout operator (== half an expression, half an operator)
    dev:
      here the medium is the image representation of the mathematical object
        slice(mathNode.representations.2dImage, imageSliceProps) --> slice(mathNode, mathNodeSliceProps) --> array of mathNodes
        OR
        slice(mathNode.representations.2dImage, imageSliceProps) --> array of images --> array of mathNodes
      but we can do the same thing with the audio representation of the mathematical object
        example: someone saying "three p minus four times z"
          the slice could be done via:
            pausing the player at the desired time
            saying "slice"     at the desired time
          and then we may process the 2 resulting parts

((*edu: objectives: allow _patterns_ ownershipping

**paint: only paint inside activeSelection

18 Avril 2021:
*textured path = svg (shape) + bitmap (texture)

**sliceWell: slice something from the sliceWell and it's automatically cloned
    example: slice a letter in an alphabet board  [ABCDE]
                                                  [FGHIJ]
**sliceClone(): command: slice something and it's cloned

**edu: project: create a comic strip
    pick a sprite sheet on the internet (and maybe create a sliceWell or sliceClone from it)

**edu: solar system (true scale):
    side view
    top view

19 Avril 2021:
dev: il reste beaucoup de travail autour des doubleObjects

***examine,edit,promote: edit code using icObjects  (give a way for people "very far from code" to tinker a bit)
  examine: bring some part of code to the infinite canvas in an ic-displayable form
  edit: play with icObjects to edit logic
  promote: when you're done editing or creating, transfer the object as code in the page script
  dev: forcément, y'a des composants de coeur qu'il vaudrait mieux laisser en lecture seule

***x's island: load the icWorld of other people into yours (be it offline or online)
    if you like someone then you add its world to yours so you can visit it sometimes to see what has changed (some kind of fa-iC-e book)
    there might be a giant hub connecting all worlds (iC-nternet)
    when you add someone's icWorld it could be only a proxy of it, so that when you access it, the true owner, if at home, sees you in and can interact with you
    dev: il faudra des protocoles tout ça tout ça

20 Avril 2021:
**greenMouse:: vectors
    vector transformations are displayed (we can see the 2D path followed by vector's end point)
    [(x ]  *  [  (0 ]  = [(x   ]
    [   ]     [+    ]    [     ]
    [ y)]     [   4)]    [ y+4)]

**greenMouse:: fractions and images: [img1] * [x (2/5) _vert] * [x (7/13) _horiz] = [img2]   How many times img2 is img1 ?

0 setHomeScale so that, at "scale0", object appears to have this size

**(*) img operator: convert to unit clones (img has been scaled and we want to know how much of the original it has become)
    [convert:uc _horiz]: horizontally aligned unit clones + horiz-scaled fractional part clone
    [convert:uc _vert]:   vertically   aligned unit clones + vert-scaled  fractional part clone
    [convert:uc _prop]:   diagonally   aligned unit clones + prop-scaled  fractional part clone
    [convert:uc _rect]: rect of clones displayed in horiz(scale.X (int + frac)) * vert(scale.Y (int + frac)) (four regions)
    [convert:uc _square]: square of clones (total: sqrt(scale.X * scale.Y)) displayed in horiz(int + frac) * vert(int + frac) (four regions)

**anytime there is a math operation to do, use mathNode and operators

**img operator: split   into color component "rects": each "rect" size corresponds to color size in original image (rect can contain transparent pixel if necessary)
**img operator: convert into colorComponent-ordered image
    edu: use image with few colors (3 to 5) to show that when scaling, scaling is distributed to each color

21 Avril 2021:
**click&drag unitCloneScale: grab side control and drag, it instantaneously shows the unitCloneScaled object (== unitClone-converted scaled object)
    dev/ux: outche
     /!\ when doing proportional unitCloneScale: clones will 'overflow' the grabbed diagonal point
      => ? rep_orig / rep_ucs ?
    unitCloneScaled = composite({[unitClone] + fractionalPart}) ...
    edu: so then we can manipulate the "unit-bounded" parts
**icObj.type = "xyloNumber": semi-xylophone which "depth" can be increased by click&dragging while zoomed
  edu: this gives another way of specifying/setting a number

**greenMouse: scale challenge: target is a scaled version of the original object, operators are scale operators
    edu: create a challenge that seems impossible: player has to rotate the object to complete the challenge (and player has to find out this 'solution' by themself)

**vert/horiz scale:
    - wrt object intrinsic coords
    - wrt coords in canvas (=> boundingBox...)
    - wrt operator coord system

*snapRotate: allow only 0,45,90,135,180, etc.

**keyDownSelect: keyDownToggle + select object (then you can keyUp it's okay): scroll now mutates object
    - color: select object while KeyC is down (now you can release KeyC), scroll mutates object color
    so zScroll is the default keyDownSelect

**strokeWidthScroll

((there are ideas,
    then there is development
      which brings the ideas down in the real world
      so there is this discussion between vision persons and preparation persons
      "This may seem easy, looking at it from the clouds, but down there it's a bit more difficult."
      "We discovered this while coding, what do you think about it? Does it inspire you new ideas?"
    then there is actualUse (for example using the software for demos while teaching)
      which brings the features down in the real² world
      so there is this discussion between preparation persons and activation persons
      "The dancefloor is nice but maybe we could add sofas on the side, and bubblegum-scent diffusers."

**machine: distribution board: output is expressed using clones of input zone "vocabulary" objects, each represented the number of times specified in factor zone
        |                                     |
  input |  output zone                 factor | output zone
   zone |                                zone |
      --------------                        ----------------
        |  factor zone                        | input zone
      ver1: input is on left-side           ver2:input is on bottom-side

21 Avril 2021:
**edu: greenMouse: back to good old {[+ 1] [+ 10] [x 2] [x (-1)]}
    propose challenges in which, all else unchanged ("Ceteris paribus"):
      - target  changes
      - initial changes
    this way the students will start mastering this operator set
    then, _when grinded enough_, we can propose another operator set

**Monte-Carlo: spawn disk at random position in rect...

((There is that standing position in The Witness which is important. Students should be standing (more) in classrooms.

23 Avril 2021:
*greenMouse: challenge: distances: when dragging the greenMouse, a carried variable is updated as the greenMouse moves from its starting point. Using [+] and [-] operators, the goal is to attain [target] value.
    when touching a [+] or [-] operator, the starting point becomes the position of the last touch.
    if [-] has been touched, the new distance is subtracted from the previous variable value.
    edu: this could be used to move from hypotenuse to vectors.

24 Avril 2021:
  0 create tutorial directly using the software features
**0 id collisions  !!!

25 Avril 2021:
**serialization: load infinishutes (==serialized states) programatically, treat them as first class objects
    edu: this way teachers could create specific classes quickly, by arranging existing material
    dev: il y aura du travail pour tout organiser, sauf si les composites deviennent robustes

((*faciliter la vie des profs (fabrication aisée de corrigés par exemple) et des élèves (possiblité d'écrire sur l'énoncé numérique (ce qui est très difficile avec un pdf) par exemple)

26 Avril 2021:
((Baba Is You   is a great game: game mechanics + level design + aesthetics (no need to be too pretty, simply be consistant)

**"touchable as a whole": composite.isTouchable == true    and   composite.parts.some(.isTouchable) == false

*edudemo: from 1x1 square to 2x1 rectangle to sqrt(2)xsqrt(2) square : scale, split, join

*image transformation: toColorHistogram(), param: nb_color_boxes for coarse/fine analysis

**3d classroom:: 2d 'infinities'
    - every student has an infiniteCanvas on their table (this is their notebook)
    - every whiteboard in the classroom is an infiniteCanvas
**3d classroom:: extension rooms: those rooms are tailored for the current course: students can leave the classroom and play around in those extension rooms

((*j'ai l'impression qu'en faisant du freedrawing à la souris, j'écris à peu près à la vitesse de mes élèves

*draw over font and then define the result as custom font

28 Avril 2021:
*edu: on bakery operators: It MUST be emphasized that, for human life to be worth it, human life practices are MORE than operations.
       You MAY MODEL them AS operations, but there will always be more in such practices.

29 Avril 2021:
**scale-aware selection (cannot select something whose homeScale is too far from current scale)
**probabilistic operator: [× ¿1-10?]

(suite à l'envie de créer un opérateur "o:scale" avec scale proportionnel en réutilisant les opérateurs o:scale horiz et o:scale vert :
**operator.type == "comp" (operation is a composite of other operation)
    this composition may be sequential or parallel

**"compoper": compositing operator: this operator pipes the operators inside it
  2 flavors: sequential and parallel
    - sequential may have an arrow to precise the order (default orientation: left to right)
      dev: this would mean projecting a key point of each operator on the arrow to determine the order
      edu: this operator would go along well with morphers ([math --> text] [append "!"] [text --> math])
    - when in parallel mode, conductive composition operator may check if operator are compatible (== orthogonal)

***supereasy operator composition: conductive-platform compositing operator
    and, on top of that, supereasy facading: to hide the implementation
    edu: on peut ouvrir le capot et regarder comment ça marche
**(*) spawn "ready to tinker" compositing operator with inner operators (== non-empty compositing operator)

***operator crafting / smart facade : supereasy compositing operator has a smart engine which allows it to facade what its inner arrangement of operators is equivalent to
    bad recipes (with incompatible output / input types for example) would be facaded as "bad recipe"
    edu: [[+ 2] then [x 3]] could be smartFacaded as [x 3 + 6]
    edu: [[+ ¿2-5?] then [x ¿3-6?]] could be smartFacaded as [x ¿3-6? + ¿6-30?] (though we lose information when displaying it that way)

**snap-based compositing operator: un peu moins naturel que le conductive
**text-based compoper: for creating compoper programmatically

**'Z-fallback' operator: when operator2 is slid under operator1 (via zIndex) , if operator1 does not return "success", then operator2 activates

*class Operation {}

30 Avril 2021:
*ux: selectAll / removeAll
     selectAllInPov / removeAllInPov

**modifiers: objects that change the behavior of another object
  dev: this may require a lot a work around platforms

**modifier:: activation condition modifier

**greenMouse X compositing:  "2 and 2 only"-modified compositing operator: compoper is working only when this condition is fulfilled
  3 and 3 only...
  So the game setup is like this:
    |---------------------------------------------------------------------------------|
    |  [1]               [---->]      [---->]      [---->]         [42]               |
    |  initial value         compositing operators                 target slot        |
    |                                                                                 |
    |        [+ 2] [+ 10] [- 1] [x 2] [+ 12] [/ 2] [+ 7] [+ 40] [- (-1)] [/ (-3)]     |
    |                      operators to be composed                                   |
    -----------------------------------------------------------------------------------
  another interesting activation condition modifier: all compositing operators must be filled for target value to be 'touchable'

**edu: randomness has drawbacks, BUT it has this key feature: players cannot "paste" the solution to the other players, they have to explain the mechanics,... which make them teachers :)

**(*)conductive-platform activating operator: "actop": a platform whose sole purpose is to forward the touch to the operator that's inside (which could not be touched without doing this). That's what is meant with the word "activating".

**modifier:: transparencer/obscurizer: an operator with these modifiers mutates what it touches into something transparent or obscure (== we can no longer see what it is)
  different flavors: when touched (permanent) / while touched (temporary)
  edu: a obscurizer actop would require the player to remember what the conducted operator is, when holding the greenmouse (look at the game setup above and replace the compopers with obscurizer actops)
      the player may pick the obscured operator out of the actop to give it back its natural appearance, but the player won't be able to do it when holding the greenmouse

(edu: we could imagine a practice phase in which the player can fail a lot and then a course phase in which the player tries to have lowest overall golfwise score

01 Mai 2021:
**(*)literal compositing operator: operator priorities are taken into account
  edu: to make a link between the "operator mindset" and the "literal expression mindset"
  edu: [[+ 2] then [x 3]] could be smartFacaded as [+ 6]
                                                or [+ 2x3] with 2x3 appearing in a different color
  edu: [[+ ¿2-5?] then [x ¿3-6?]] could be smartFacaded as [+ ¿{6-30}?] (though we lose information when displaying it that way)
                                                                      6 8 10 12
                                                                           9 12 15 18
                                                                             12   16    20  24
                                                                                15      20       25    30

02 Mai 2021:
*presets (for users who don't like z-scroll by default)
    presetA: selected + scroll       = z-scroll

    presetB: selected + scroll       = scroll
             selected + shift-scroll = z-scroll

    for users who prefer selecting with right click, ...
    etc.

*(*)from group-based multiSelection to composite-based multiSelection
      highlight cargo objects
        icObj.isCargo
        highlight parts when cargo object is composite

**show fading border animation when trying to select an object whose homeScale is too far from current pov scale
  so that user understands that their selection attempt failed

(composites, over and again:
***Sticky release: when sticky-releasing an object S over an object O, a composite is created whose parts are: [O, S]
    this way we can create complex composite very easily
    target recipient is highlighted
    ux: keyboard shortcut is: S
      first press activates sticky release behavior
      next presses cycle to next target recipient
      (Esc key cancels sticky release behavior
    dev: all this ux could be then reused when editing ngraph.tree

    0 find an easy way to show/hide composite handle (because a lot of them will be created)
    0 toggle composite recursive move amplification

**(*)Sticky FreeDrawing: drawing over an object in "Sticky" mode creates a composite whose parts are: [object (original), freeDrawing (decoration)]
      edu: this way we can type text, and then decorate the symbols by freeDrawing over them, and then move the decorated text around, all in one go.
      edu: same principle for geometrical figures, which we would enrich via freeDrawing

**Replace release: when replace-releasing an object R over an object O, R "now replaces" object O
    - in a composite C containing O: O is removed and R is added. R's 'space properties' are set to O's.
    - elsewhere: same principle (we consider canvas as root composite)

**Decoration "Frame" (Begin/End):
    1. user select an object O
    2. user begins decorating (==decoration_begin())
    3. user creates objects
    4. user ends decorating   (==decoration_end())
        a composite D is created, whose parts are [O, ...created objects]
        if O was part of a composite C, D now replaces O in C

*Bloom decoration: add representation to a bloom object via decorating: i.e. decorate + bind

(0 organiser un concours de création de 'peinture profonde'

***(*)inner recording: start recording, move stuff around, do operations, stop recording: a record object will be created. It is an "animation" operator (it operates on canvas objects to recreate the recorded animation)
      recorded animation == actionSequence
      multiple flavors for the recording:
        pov:
          - pov is part of the recording
          - pov is not part of the recording
        frames:
         - discrete interval frame recording --> tick tick tick...
         - meaningful keypoints recording    --> bezier curve interpolation
      multiple flavors for the operator:
        - video-like
        - slider-based
      edu: this way we can roll the film back and forth to the students
      dev: this is gonna be tough
        eventSourcing
        compress moves: FourierTransform, Bezier curves
      game: we can then create challenges in which a greenMouse can press play button so that it makes other objects move and then greenMouse can interact with those moving objects and attain target
      we can record the activation of an animation operator, etc. omg
      we can split an actionSequence and join actionSequence chunks
    (Braid in iC, lolilol
    Event sourcing vs Command sourcing
    actionSequence may not be playable if objects are "too far" from the record initial configuration (== initial "revision")
    [rec reset] operator to put back objects in record initial configuration (== "update to revision"), so that actionSequence can be played
    Red dot on top left HUD to indicate that recording is ongoing
    edu: experiments with periodicity: Does this actionSequence comes back to the initial state when repeated a certain number of times ?
    semantic-recording: system analyzes what has been done and only stores "semantics":
      example: "smallest number was added to greatest number"
      so if you play it in another context, it will try to apply its semantic program on the working objects
    game: record then stay pressed on [activate] then some operators will be active when record is played
**polysync recording: until the recording has ended, all object moves "start at 'time zero'"
    this allows keyframing multiple objects: {1,2,3} --> {1',2',3'} --> {1'',2'',3''}
**"almost time zero"(== "time zero +") syncing:
    example:
      recording 1 : obj1 split into {obj2 + piece1} and move piece1
      recording 2 : obj2 split into {obj3 + piece2} and move piece2
      when the two recording are "time zero +" sync'ed, what we see happening is:
                    obj1 split into {obj3 + piece1 + piece2} and move piece1 and move piece2
      there are sync'ed but recording1 still starts before recording2: recording 2 is brought "as close as possible" to recording1: recording2 starts as soon as obj2 is available

04 Mai 2021:
**(*)program by tagging: Baba #[is greenMouse], rock #[is operator], flag #[is target] (à la Baba is You)
    tags are sticky by default
    programming happens in 2 phases:
      1. create objects   (==spawn)
      2. assign behavior  (==tag)
    edu: this way, teachers and students can easily create challenges

**scale tracks: an object following the track (==part of a function plot) will scale along accordingly
    example: linear track, exponential track
    many flavors:
      - hovered  track: the track is below, but it's not physical, it's more like an idea, it can be ignored if crossed orthogonally
      - clinging track: the track is physical, and when getting too close, you are clung to it and must follow it till you find an "untrack opportunity" (like a Y)
    those tracks may convey a particular scale flavor: scaleX, scaleY, propScale, etc.
    edu: that would be a way to become familiar with function plots and variations
    dev: une sorte de snap dynamique

(Maths DJ: when enough challenges, edudemos, features and worlds will be available, maths deejaying will become available (propose circuits in compositions)

05 Mai 2021:
*3D virtual classroom:: group fork: 4 students fork the current classroom: same room but other students are no longer visible
    then at some point we could merge the different forks (for example: each group has a dedicated whiteboard to write on, a dedicated area to build things in)

**sticky tentacle: click on point in object then drag, a sticky freedrawing starts with the pointed color at clicked point (=="tentacle")

**top-right corner button: toggleTouchDevice (switch controls to touchDevice mode)

*icObj.type = "pov";
  edu: easily create transitions: move from pov1 to pov2
**icObj.type = "link";  A link is simply a line between the 2 objects
**easyLink: freeDraw a line between 2 objects and then proper link is created

**conductive link: when an object is operated on, all "conductive-link"ed objects are operated on too.
**challenge: link, operate, link, operate...

**composite-link: link is composite handle

**area link: link between 3+ objects

06 Mai 2021:
edu::chemistry: using conductive operators (example: [+ [CO2]])

07 Mai 2021:
user-initiated command (user --> obj) VS obj-initiated command (obj --> obj)
    example: user moving obj via holding  VS  touchSlot operating on obj when touched

0 local eventstore: "connect to oneself"

((the vision is to provide everyone easy-to-use powerful tools:
    provide easy animation recording to everyone would be so nice

**(*)oob clone (==out-of-body clone): when grabbing object, you don't move it but instead you extract and move an out-of-body clone of it which can then interact with [move] operators, which operate on "real-body" obj
  =>=> statueMouse

10 Mai 2021:
*burning (m/h)ouse: raisonnement par l'absurde: when the chain of equivalent transformations gets to a statement we know is false, all the poopoo statements burn backwards to end up "destroying" the hypothesis we now know was supposed wrongly.
*[x2 / x2] operator applied on fraction reictangles: numerator is multiplied and denominator is multiplied so that the bloom now appears bigger, but it's the same fraction.

11 Mai 2021:
(expliciter la subtilité: lever les ambiguïtés:
  opérateurs de séquence VS opérateurs d'expression
    avec les opérateurs de séquence,  la priorité des opérateurs est décroissante suivant le sens de lecture
      3 +S 4 xS 5 -S 1 = 34
    avec les opérateurs d'expression, la priorité de chaque opérateur est fixe
      3 +E 4 xE 5 -E 1= 22
  "petit moins" (unaire) et "grand moins" (binaire)
  (ça vaudrait peut-être le coup d'essayer sur quelques élèves

12 Mai 2021:
**time composition of icReplay objects: we display a spatial representation of time
**ghost-based programmable [record/replay] operator: ("oob clone meets record"): user can grab a ghost from the operator and produce a path with it, then any 'free' object(==unheld, user-aloof (nothing to do with "free" representation)) touching the operator will follow the recorded path

13 Mai 2021:
**poopoo path:
    - manual (record{ grab move poop move poop move poop move release }) where poop actions are user-initiated
    - auto (==throttled)
      - every <length>, poop action is triggered (be it a spatial length or a time length)
**poopoo vector path: poopoo_{n} orientation is determined by vector(from: poopoo_{n-1} position, to: poopoo_{n} position)

**"keyframe programming": polysync-recording sequence: record_start/{next_keyframe_start}*/record_end
    edu: easy creation of complex animations:
      example:    on top: [1] --> [ 1 ][ 1 ][ 1 ]
               at bottom: [1] --> [<---- 3 ---->]
    edu: pour expliquer les tris aussi, ce sera bien. On pourra enchaîner chaque étape.

**(*)"define" operator via recording (=="def by i/o[]" programming) (Inductive Logic Programming)
        let's suppose it's a unary operator, whose behavior we want the machine to understand
          1. we prepare an object in a desired state: inputX
          2. we record our making the object interact with the operator, and then we edit the object so that it's in the desired outputX state
          3. we end the recording and some magic configures the operator so that it now transforms inputX to outputX
        we may do multiple recordings to disambiguate: inputY * [op] = outputY, etc.
      edu: teach relative numbers: define operator via 4 * [op] = 3 and see what 0 * [op] equals to.

*contextual operation (=="injustice" operators): what if 2 objects are similar, but as one is grabbed from the blue area, while the other is grabbed from the green area, they now, when operated on, yield different outputs.

**le glitch du replay while recording: "object is somewhere along that path": on peut surement faire quelque chose de sympa avec cette bugfeature

**activate(==enable) VS actionate(==trigger)

**(*)machineGunReplay: replay 1000 times, and all that, in 5 seconds (==supereasy iteration)
    edu: pour montrer des tirages au sort: au début on le fait doucement, puis on enregistre une transformation et on la refait plein de fois
        on peut mettre un écouteur sur la valeur produite pour générer des histogrammes
    edu: pour montrer des évolutions de systèmes non-linéaires
        on peut mettre un écouteur sur la valeur produite pour générer un graphe de fonction
    ux: peut-être gérer le cas où ça crashe, essayer de contenir l'explosion. Cloisonner la zone pour protéger les objets autour au cas où.
**edu: pretty loop: replay (n-1) times then, for last iteration, replay cropped chunk(==from start to destination keyframe (which was marked during recording))
          when recording the sample, ensure that "nothing happens" when in the "moving back to the start"-phase

**conditionally-activating conductive platform: operators inside it can touch incoming object if and only if the condition of the platform is met by incoming object
conditionally-activated operators:
**[break] operator: when in the "moving back to the start"-phase, touching this operator will end the loop prematurely
    the breaking of the loop is reified by the object being left next to the break operator, like a poopoo

*[continue] operator: go back to loop starting position
    dev: find a path which is short, safe (==without any operator on the way) and pretty(== round-edged) to go back to the starting position

**(*)[move] operator:
  many flavors:
  - exo-level [move] operator => miniScene transformation: in order to depict a [move] operator, we can use a miniScene in which, when touched by the [move] operator, an inner object (the "performer") will move according to the [move] operator (the miniScene has its own coordinate system)
      edu: when introducing this concept, it would be nice to use a small and simple miniScene in which the performer is almost alone (you may put a few rocks and trees, or the coordinate system axes, in order to notice the performer move)
  - same-level [move] operator:
      - when touching a non-part-of-a-composite object: object is moved accordingly
      - when touching a composite object and one part of it is the performer: performer is moved accordingly
          consequence: when touching the supervessel: performer cargo object is moved accordingly in supervessel. So the general impression is that the held object still moves, even if held.

**[loop move] operator, [pretty loop move] operator

14 mai 2021:
**[poopoo-path move]
    many flavors:
      - consuming: path is erased as perfomer moves
      - permanent: path stays there and many objects can follow it simultaneously

**cart move/cart controller: object is in the cart (==platform). Cart follows track. A scrollbar based on a small representation of the track (for example: a straight line or a loop) allows user to control cart move along the track.

**stepmania-like pace line: the "now" line progressing on a music partition
  edu: build choreographies with students
  edu: a bloom petal for the object "time". The pace line reifies the passing of time.

15 mai 2021:
**[if] operator/[switch] operator in railway track (=="program")
    - highlight the "chosen" track and darken the others

(la notion de variable ou d'objet (==espace mémoire, rétention) est plus ou moins déjà présente chez les élèves.
    Quand ils écrivent 4 / 2 = 2 / 2 = 1, en fait ils voudraient écrire: [[4]] / 2 --> [[2]] / 2 --> [[1]]. C'est-à-dire une séquence de mutations d'un même objet. Ils veulent décrire un morceau de vie de l'objet.
    Peut-être que cette notation ("avec cadre et flèche") leur permettrait de faire la différence entre :
      les 'performances'(auxquelles ils sont habitués): Maintenant, je fait bidule sur truc et il devient machin.     ((Relié : utilisation,  action,   évènement,    exécution,    instance,   apply(f, args),   now,       vie courante
        sémantique séquentielle
      les égalités                                                                                                    ((Relié : propriété,    règle,    opérateur,    programme,    classe,     f,                anytime,   loi
        sémantique arborescente
    Une autre façon de faire des maths, c'est de regarder ces allers-retours entre performances et égalités.
    Petit à petit dans la scolarité, on passe d'un système de notation {performance: A signe égal B (qui est bancal), propriété: Si X alors Y}, à un système de notation {performance: la double flèche d'équivalence (ce qui est toujours un peu bancal), propriété: quantificateurs et relations (dont le signe égal fait partie)}
    En fait, c'est pas très clair toute cette histoire. Du coup, c'est normal que ce soit pas clair pour les élèves.
      On devrait peut-être noter op_symbol__sequential avec une flèche dessinée en dessous ((et l'autre avec un arbre en dessous mais ce serait peut-être un peu trop)).

**zeroperator (=="side-effect"-ator, ==procedure, ==non-args function, ==arg-insensitive operator): what it does is side-effect only.
    edu: on pourra toujours me dire qu'en fait il y a un argument: l'espace entier (voire même l'espace-temps entier (quand on joue de la musique par exemple)),
          puisque les effets de bord reviennent à des mutations de l'espace qui contient l'objet "touché" et le zéropérateur.
         il est bon de le préciser, pour planter un cadre fonctionnel serein dans la tête des élèves ("all functions are one-argument functions").

*actionator segment: this pace line actionates any actionable object it touches
  edu: build choreographies _for the machine to perform_ (or, more likely, for students and machine)

**game: Anisotropic music partition: the partition is a 2d arrangement of music playing zeroperators.
    an actionator segment can traverse the partition following any slice path the user wants: each traversal will result in its own music
    The game is to find the right path.
    different flavors:
      straight path
      curvy    path
    edu: this game is close but not exactly about dot-product
    this game can have a lot of variants:
      visual:
        superposing images instead of playing music, display fireworks animation, etc.
      audiovisual:
        sync image displaying with sound playing

16 mai 2021:
**replays, many flavors:
    from now:
    - telekinesis:     replay only moves, inner interactions can happen
    - mutationStory:   replay only 'operator encounters'
    - oldtimes:        replay all but ignore elements that were not there when recording was done
    from the past:
    - closureRollback: rollback to record starting event and replay all (== everything "in closure" is rolled back, (==related side-effects))
                          everything outside this spacetime closure is kept the same

17 mai 2021:
**pov-capturing object: moving object also moves pov    ((c'est un peu la mécanique inverse du z-scroll))

**populator: when actioned, populator spawns object(s) in the canvas
    la diversité des populateurs est a priori très grande:
      - certains vont être des zéropérateurs
      - d'autres vont prendre en paramètre l'actionnateur pour faire naître des objects
          donc on peut imaginer du clonage, de l'anisotropie, ...

**(*)autogen system: "when actionator meets populator":
    while(something interesting may happen)
      0. actionator moves and meets populator
      1. actionator actionates populator
      2. populator creates a new object, for example another populator, hopefully in front of the moving actionator
    edu: this system will allow emergence

**"different-different but same": enforce equality of icObjects by "composite binding" them   ("Tous dans le même sac.")
    example:
      Dynamic geometry
        Say we have:
          segmentAB: {pointA, rectAB, pointB}
          segmentCD: {pointC, rectCD, pointD}
        We can implement the requirement "pointA is the same as pointC":
          - assign the same coordinates to pointA and pointC    ("align")
          - create a composite
              which contains pointA and pointC
              which contains another point, pointX, above pointA and pointC, with pointX.isMobile == false
        Now when user moves pointX, pointA and pointC move as if they were a single entity

18 mai 2021:
(tree == state, sequential == event-sourcing
**icObj insensible au roulis: l'objet s'oriente de manière à garder son bottom dirigé vers le bas de l'écran

**[sym: <X>]     operators: apply symmetry to obj
**[timeReversal] operator: apply time reverse symmetry to obj

**"dessine moi une horloge":
    0. spawn a [+ 1] operator and a [[0]] mathNode
    1. record mathNode move: sideA --> * [+ 1] --> sideB,
      and generate [forward] and [reverse] replays
        default [forward] may spawn at first
        then to get [reverse]: clone [forward] and  symmetrical
    2. create a sequence operator [[forward] [reverse]]
    3. create a loop [loop: [sequence]]
    dev:
      sequence and loop operators may ease the animations

((dreams as another event track, the innerEvents, the "semantic" events
(body evergoing reconstruction is functional, rebuild_cell(rebuild_cell(rebuild_cell(...))) => event sourcing, and yet we consider ourselves as a state

(((Is it necessary to run the courses in that way, in order to grasp the full thing ?
    1. be taught things the wrong way
    2. realize they were wrong
    En particulier:
      la précision quand on utilise un langage: au départ, on dit les choses de façon grossière
      l'orienté-objet pour finalement revenir vers le fonctionnel

(edu: il faudrait que [2 x] [[3]] et [[3]] [x 2] aient des significations différentes
  proposition:
    [2 x] [[3]] serait la signification "clonage": 2 pommes                 (application d'un adjectif numéral)
    [[3]] [x 2] serait la signification "échelle": 1 pomme agrandie 2 fois  (application d'un adjectif qualificatif d'échelle)

19 mai 2021:
**edu: le "multiplier numéral" VS le "multiplier échelle":
  on peut créer une représentation spéciale pour les fractions:
    en bas:  un bloc tout seul, avec un nom : le _bloc nommé_.
    en haut: des blocs, sans nom, mais de la même taille que le bloc nommé. Il y en a un certain _nombre_.
  L'important pour cette bloom c'est la longueur des blocs. Un _bloc nommé_ [1/3] devra avoir une longueur trois fois plus petite qu'un _bloc nommé unité_ [1].
    exemple:
      Une représentation de 4/3 :
      [     [   ][   ][   ][   ]    ]
      [     [1/3]                   ]

  Avec cette représentation, on ramène deux types d'opérateurs:
    les opérateur   numéraux:   qui agissent sur le numérateur.
    les opérateurs "nominaux":  qui agissent sur le _nominateur_.   (ou on pourrait dire opérateurs "escals" (==d'échelle))
      d'un point de vue mathématique, pour les fractions, on a nominateur == 1 / dénominateur  (ici le préfixe "dé-" est interprété comme inversif : si on multiplie par le dénominateur, la fraction n'a plus de nom (==le nom par défaut (=="unité")))
    exemple:
      [     [   ][   ][   ][   ]    ]     *   [x 2: via num]   =  [     [   ][   ][   ][   ][   ][   ][   ][   ]    ]
      [     [1/3]                   ]                             [     [1/3]                                       ]

      [     [   ][   ][   ][   ]    ]     *   [x 2: via nom]   =  [     [        ][        ][        ][        ]    ]
      [     [1/3]                   ]                             [     [   2/3  ]                                  ]

    et
    les opérateurs de conversion ("to"):
      [     [   ][   ][   ][   ]    ]
      [     [1/3]                   ]
      *
      [nom: to [2/3]]
      =
      [     [        ][        ]    ]
      [     [   2/3  ]              ]

  En fait, cette bloom a un énorme inconvénient: dans cette notation, on met le nominateur en bas alors que dans la notation fraction, c'est le dénominateur qu'on met en bas.
  Peut-être qu'une version gauche droite serait plus adaptée:
    [ [1/3] [   ][   ][   ][   ] ]
    pour petit à petit passer vers
    [ [1/3] * [x 4]]
    et arriver à [4/3]
  Un autre inconvénient: on utilise une fraction pour le nominateur...
    On peut s'en sortir si on définit proprement [1/n]

    [     [        ][        ][        ][        ]    ]
    [     [   2/3  ]                                  ]
    peut être déplié de cette façon :
    [     [        ][        ][        ][        ]    ]
    [     [   ][   ]                                  ]
    [     [1/3]                                       ]

  Je ne sais pas pourquoi mais, toujours est-il, j'aime bien cette notation.
  Notation sur papier:
    on met un nombre entier en haut, une fraction en bas et entre les deux une barre qui aurait la forme d'un "sigma orthogonal aplati"
  exemple:

                                                 xx
                                                 x
                                               xx
                                              xx
                                             xx
                                            xx
                                           xx       x
                                          xx        x
                                          xxxxxxxxxxxxxxxx
                                                    x
                                                    x
                                                    x
                                                    x

      ┌────────────────────────────┬─────────────────────────────────
      │                            │
      │                            │
      │                            │
      └────────────────────────────┘

                   xx
                  xxx
                xx  x
              xx    x
                    x
                    x
                    x
                    x


             xxxxxxxxxxxxxxx


                 xxxxxxxx
                        x
                        x
                    xxxxx
                       xxxx
                          x
                        xxx
                  xxxxxxx

    ((ou peut-être qu'un sigma miroir orthogonal aplati serait mieux car on lirait directement 4 "1/3" : quatre tiers.
        4
        _______
            |_|
            1/3
      mais du coup ça commencerait pareil qu'une fraction visuellement...

("sémantique syntaxique": quand je veux faire comprendre quelque chose à propos de la notation elle-même

**draw content VS draw meaning: one can switch between two input modes: user wants to create content (==objects) or user wants to create behavior(==moves, operations,...)
    example: user could tell the computer to create a [replay] in reverse from a [replay] "going forward" by drawing an arrow that shows an object movement that is the reverse of the normal "forward" object movement

20 mai 2021:
(Some researcher is actually named Shute!: Valerie J. Shute, https://myweb.fsu.edu/vshute/

**ghost-path greenMouse: for deferred feedback: student draws the path and _afterwise_ the mouse follows the path
**Braid-like reverse (==keyDown reverse): "hot-reverse" a grabbed greenMouse
    0 à essayer pour voir ce que ça donne
    dev: mouse pointer may shift wrt physical mouse position

****pathmade operator: create operator from path (path == move-events-only replay)
        operator does this: make object follow path, making it encounter existing operators
        yet, we don't see the object moving when touching this operator, we see the mutations on anything but the object position
        for simplicity, path start is where operator will spawn
        after it has been created, pathmade operator's path shows on mouse hover (or on two-finger hover for touchscreens)
        encountered operators may be loop operators
      edu: this way, we can create operators in a blink, and use them to build other operators, etc.
      edu: we may create specific applications (== apply) using a cart loader : arguments are put in the cart and the loaded cart encounters the operator we want to apply to the args
      edu: this way, we can create functions of functions (operators taking operator as an arg)
      edu: this paves the way to creating a new programming language
      dev: this is gonna be tough, but this is gonna be it
      2 flavors:
        - off-ground: path is parsed into a function when operator is created
              if encountered operators are moved or replaced: the operator still plays as if the original encountered operators were there
        - grounded == path-treading
          2 flavors:
            - conveyor: touched object is moved along the path
                operator leaves performer at end of path
                so it's like "function + goto"
                2 flavors:
                  - original object conveyor
                  - clone conveyor
            -"possessed_geminiShade"-based: a gemini shade moves along the path and its mutations (everything but position) are forwarded to the original touched object
                if encountered operators are moved or replaced: it will result in the pathmade operator behaving differently
                (here Papert's idea of "screen as a data type" is realized
                we could replay:
                  - at original speed                (==timing does matter):     to explain, to debug, or to reify async operations
                  - way faster (== as fast as possible, timing does not matter): to use it productively, even it makes us somehow forget how it works internally

              edu: we can then create trees of pathmadeOperators, and maybe treer things
      sync/async:
        sync : waits for any operator along the path to complete
        async: does not wait for completion, mutations may happen anytime

      procedure/function:
        procedure:        object is mutated along the way
        "pure" function:  object is replaced by function's output when function has finished
        edu: this way we can explain state and the different between state-based and functional programming

    0 from svg path to move events sequence
    0 from move events sequence to svg path

      edu: "ghost-path greenMouse" can now be put one step further: "tailored pathmade operator creation"   ("Donne moi une fonction qui résout ce problème")

      ((The Witness meets Braid ^^))

      edu: we can change function parameters by equipping the performer ghost_rep with a reactor
      edu: recursion can be enacted by making pathmade operator be encountered along its own path
      edu: recursion could also be done via cloning "everything needed" into a lower area, and continue execution there, etc.

**conveyor seam: if two conveyors operate simultaneously on the same object, ignore the conveyor which is closest to its end

*event injection: inject add1 in move move move... sequence
  0 inject an event which stalls the object for 1 second

21 mai 2021:
0 dessine moi un mouton de fonctions (using visible path pathmade operators)

*music: frequency gradient operator:
    top, red:      treble
    bottom, brown: bass
*music: notes circle: 12 operators are disposed on circle, to play a note one may:
  - cross the circle:
    - from inside  to outside
    - from outside to inside
  - bounce:
    - stay inside
    - stay outside

**icEngined.engine = ProjectileEngine()
**icObject.type = "projectileThrower"
    ? when wrapped in a pathmade operator: where should we the projectile be shot from ?

**icObject.type = "eraser"
    single-use vs everlasting
    projectile eraser:
      example: destroy possesed_ghost_rep of pathmade operator while it is running by throwing an icEraser on it

**edu: 0 pathmake all operators using [clone] and [-], and [[0]] and [[1]]

**my deck of operators: student chooses or creates a deck of operators and then tries to complete the challenges using them (of course pathmade operators can be 'raised' from the starting set)

**icObj teleportation: while moving icObj, enter freeDrawing mode, the icObj does not move but the cursor moves, then leave freeDrawing mode: icObj teleports to cursor

22 mai 2021:
**modifier: inject condition inside looping conveyor to transform it into a while loop

**behavior:pickAndDrop: pick object X and drop on object Y
**icObj.type = "pickAndDrop"  (une version incarnée du comportement pick and drop)

**(*)le ramassage des pommes: réapprovisionner le canvas avec de nouvelles pommes et relancer
    tant qu'il reste des pommes:
      le pickAndDrop performer ramasse une pomme à chaque tour de boucle (la pomme se colle à lui et il la ramène au début du parcours où il la dépose dans un panier)
      quand le performer a tout ramassé la boucle s'arrête
      On peut alors
        ajouter à nouveau des pommes sur le parcours et relancer une nouvelle exécution
        ou enlever des pommes avec la souris et regarder qu'il s'arrête bien quand il n'y a plus de pommes
      many flavors:
        - condition is local (==performer-related): performer knows that there isn't any apple left to pick (because it has not found any on the path)
        - condition is global:                      "global" knows that there are apples to pick
    tant qu'il y a moins de 5 pommes dans le panier
    edu: pour expliquer la complétude: mettre une pomme à un endroit qui est dans l'enclos mais qui n'est pas sur le trajet du performer: le trajet n'est pas couvrant

**function::showstopper: any process involving object X must stop now
    so this may be used to terminate a looping conveyor operating

**challenge: show me a path/ show me the shortest path: draw a path to transform X in Y
    pleins d'opérateurs éparpillés, un objet de départ et l'objet qu'il faut obtenir
   edu: pour aller vers les fonctions (voire les polynômes): draw a path to transform X in X', Y in Y' and Z in Z'
   edu: pour aller vers le calcul littéral: find 2 different yet equivalent paths

**whileTouch slots: comme quand on reste appuyé sur une touche d'un sampler, le sample continue de jouer tant qu'on relâche pas la touche

*[tupler] creates tuple [[{A:, B:}]]

***graph by inputting: [pathmade op] then [graphConveyor]:
    when [pathmade op] touches [[input]], [graphConveyor] sets its path to put [[output]] at coordinates corresponding to [[input]]
    dev: ça va encore être un peu sportif dans les coulisses
    edu: pour expliquer entre autres la linéarité, la non-linéarité, la fonction exponentielle
    edu: avec cette façon de faire, on reste très proche de la réalité "calculer reporter" que l'on peut faire avec une calculatrice et une feuille de papier

    (a more explicit yet more complicated version:
      [conveyor]         }
                         }  then [tupler] then [graphConveyor]
      ["input" conveyor] }

23 mai 2021:
**write the function on the object:
    example: perimeter conveyor
      ----[+ 5]----
      |           |
    [+ 5]       [+ 5]
      |           |
      ----[+ 5]----

*edu: EXPERIMENTS before EXERCISES: before giving them exercises to do, give them experiments to do
  l'apport de l'ordi est le suivant: cette activité, qui devrait normalement être une activité un peu barbante à la calculette, devient une activité facile et rapide à faire
  exemple: faire [[5]] * [+ 3], faire [[-5]] * [+ 3], faire [[5]] * [+ (-3)], faire [[-5]] * [+ (-3)]
  Si on veut faire une expérience du genre "faire [[5]] * [- 3] * [- 7] * [- 5] * [- 10]", on peut déjà avoir disposé les opérateurs de manière à ce qu'on puisse tout faire en un seul mouvement
    (peut-être pas forcément une ligne droite pour prendre le temps de voir ce qu'il se passe à chaque étape)

**icObj.type = "pen"
    penUp, penDown etc.
    edu: pen + conveyor(s) can be nice

**magnetic generation: mousedown with empty supervessel and touch generator operator: generated object is now in supervessel cargo, which will be dropped on mouseup

*operator's own supervessel / disposable supervessel: maybe, at some point, we'll want differentiate supervessel and platform, by giving them slightly different meanings and behaviors
    supervessel is like a the magnet  of a magnet crane
    platform    is like a the flatbed of a flatbed truck

(OMG: I'm such a copy! Seymour Papert last week, now Ivan Sutherland: https://www.youtube.com/watch?v=6orsmFndx_o
  (so funny actually, all that is so old, so bright, yet nobody seems to have cared! (except some people of that distant time)

**constraints / constraintsSolver: comme dans la vidéo de Sketchpad, on met des contraintes sur une figure puis on la fait toucher un opérateur [solve constraints] qui nous donne la version résolue
    - deux nouveaux types opérateurs: [constraints::add] et [constraints::solve]
    edu: bien sûr, on peut cloner la figure avec les contraintes avant de la résoudre pour afficher les deux versions
    - une nouvelle représentation: rep_constraintsSolved

praised be thy Doug:
**easy editing of documents by diving inside, editing (for example drawing) and then moving outside
    there is a quantization of zoom levels
**Database of links: either click links or portals
**Networking: allow collaboration on the same location in the canvas

24 mai 2021:
**"full spectrum" composite: all representations or all shades, r_official excluded, are parts of a full spectrum composite
    so when you destroy the composite, you destroy the full spectrum of objects

(((is the shade of a shade still a shade of the original ?

25 mai 2021:
*pov, superpov, pov conveyor: a way to create transition in presentations
**"become the object": when pov moves as if it were the object
*easy orientation via dragging
*for quick 'handmade' anims: freeDrawing.isTouchable = true after it has been created

*la supercouche interprétative: quand une computer vision interprète l'espace d'interaction
  exemple: des objets superposés seront peut-être interprétés comme étant le même objet

**Narwhal numbers: multiplayer canvas, operators and their inverses are disseminated around, each player has a starting value and a goal, winner is the first to attain their goal
    variant: each player also has an operator attached to them (that's a way to somehow keep the joust mechanic)
      so the narwhal number player has its operator on the front and its value on the back
      example:  -=([[3]]   [x  2])>>
  edu: I know that's gamification... (but maybe it's gonna be ok still)

**shade.im_dying_now
		2 flavors:
			- bring original down
			- don't affect original

26 mai 2021:
*var: [create: number], [assign: 0], ...operations..., [destroy]

**turtle: operations are forwarded to a third-party object (the two first being [[obj]] and [operator]): [[obj]] * [operator] = [[turtle]] * [operator]
    edu: c'est vrai que Mathland sans turtle(s), ç'aurait été un peu triste.
**pen(== turtle) drawing: record pen drawing: create [pathmade:penDraw] operator. Touching this operator will command pen to draw.
    edu: this way we can draw crenellations by looping on this operator
**penDrawing: relativeOrientation => roses: record pen's ending orientation so that looping on curve drawings will result in roses

**in the steps of giants:
    https://fr.wikipedia.org/wiki/Squeak
    https://en.wikipedia.org/wiki/Croquet_Project
    Lively kernel

29 mai 2021:
*katamari operator: [stick [<obj>]]: touching this operator sticks a clone of <obj> on you
    2 flavors:
      directional: the clone sticks where touching
      random:      the clone sticks anywhere on the border
*katamari generation loop: loop [stick [<obj>]]
    edu: emerging structures

***pathmade:triggered pathmade: user draws paths for each argument and conveyors will be triggered to start altogether.
  this allows support for multiple arguments
  [[firestarter]] obj: this is like a "gogogo" argument: this will trigger the operator
  Result is last drawn conveyor's output.
  Result is cargoed in supervessel.
  2 different implementations:
    - vacuum conveyors: trigger is a pure trigger and, when actioned, all conveyors will try to vacuum an argument near their starting point and then start conveying
*** - embark pathmade: pathmade is a platform operator and each time an argument is put on it, it is mapped to the corresponding conveyor.
        mapping to conveyor can be done using order, type, ...
        Trigger happens:
          - when all arguments are here
          - if actioned by a [[firestarter]]
  2 flavors:
    - 2+ args:
        - optional arguments
        - required arguments
    - only 1 argument and the rest are parameters
      edu: also, we _see_ the difference between an argument an a parameter:
        argument is consumed
        parameters are not consumed

  triggered pathmade can be conveyor ("multiConveyor"), shadePossessor ("multiPossessor"), etc.
  edu/fun: with multiConveyor, we can create an [arrange as face] operator which puts #1 arg as left eye, #2 as right eye, #3 as nose, #4 as mouth
    and then we can wonder what is actually a face, is it the arrangement or the arranging (==the result or the process)

  0 show location of #1 when drawing #2
  variant: superhot mode: to move in space is to move in time

  user may decide whether he wants the touched object to be conveyed or shadePossessed (== choice between kind of a procedure and kind of a function)
    depending on the glove color of their grabbing hand

  user may configure whether a path is:
    - a dead end (==performer will not be given back to user)
    - an outlet  (==performer will     be given back to user)

  edu: pour que ça soit vraiment *edu* (et aussi pour que ça soit vraiment utile),
        - il faut qu'on puisse éditer la fonction (==le chemin) après qu'on l'a créée
        - il faut que ça reste rond et courbe
        - il faut qu'on puisse changer la vitesse d'éxécution, de façon continue de figé à rapide, jusqu'au saut quantique: "hardwired"(==compilé, ==le plus vite possible, ==on n'affiche plus l'exécution)
    dev: encore du sport à venir

**pathmade:await: wait for operator to finish before going forward
  dev: this is the hard part

**pathmade:custom generators:
    2 different implementations:
      - generator path: when drawing a path, if the starting point is on a generator, this means we want to create an object and make it follow that path
          we can then create custom generators using generator paths pulled out from _elementary_ generators
      - generator as arg: when the triggered pathmade triggers: the output obj from the generator is used as working argument
    edu: generator path may be a little bit easier to understand than generator as arg

30 mai 2021:
*easy multiargfunc: type "3x + 2y -5z" and it automatically creates an embark operator
  "[[1]] x 3 + [[2]] x 2 + [[3]] x (-5)" should be parsed the same way

*?(the path is the operation

31 mai 2021:
*embark operator:named slots (==renamable slots)
  slots corresponding to each arg are named "#1", "#2", etc. but then you can rename them
**embark operator: add support for bag input (bag contains all the args)

*a program for every theorem
**0 fabriquer un additionneur de fractions avec les outils existants

*global pool: this pool contains words, numbers, shapes, ... (un peu comme une chambre d'enfant)
*global pool: operators: grep: this would allow easy finding of
**condition-based magnet: wave the magnet over a dense area: objects satisfying the condition will stick to the magnet

*bloom: morph into next representation
    edu: pour passer facilement de 10 à [1,1,1,1,1,1,1,1,1,1], et inversement

*create Heider Simmel -like stories
    edu: maybe a little happier

01 juin 2021:
* "a + b x c"
  0 have it working
  0 parse tree-formatted expression into tree-arranged paths implementation

*trueGolf: randomStroke/manualStroke
  there are multiple stages for each hole: {stage 0} --> {stage 1} --> {stage 2} --> {stage 3}
  each stage partitions the hole course into areas in a specific way: {stage n} --> {stage n+1} with probability P(s_n+1), {HoleCourse \ stage n+1} with probability (1 - P(s_n+1))
  randomStroke moves the ball to each zone with probability P(zone)

*shadeConveyors <~> multiOutput

**(*)temporal builder(==temporal form): build anything by specifying one property at a time
    1. I declare that I start creating an obj
    2. while i'm not done, I specify another property of the obj I'm building
    3. I declare that I'm done: the obj is built
    These buildings can be nested.
    It would be nice to show the hierarchy of the object we're building and the properties we have specified so far.
    edu: this is a simple -yet powerful- way to build complex objects
    example:
      temporal composite builder: (generalization of multipathmade)
        1. I declare that I start creating a composite
        2. I create the parts of the obj, one part at a time
        3. I declare that I'm done creating the parts: the composite is built

02 juin 2021:
*stages inside a function:
    mapping
    twingling
    outputting

(codage géométrique: contraintes en puissance VS contraintes en acte

*"Copies, clones & replicants": many flavors of "they are the same":
    - gemini      (still "in touch")  (something I am)  (limb)
    - copy        (objects are apart) (something I was) (poopoo)
      - shallow
      - deep
    - impersonator                    (something trying to be me)
      - stateImpersonator
      - behaviorImpersonator

**composite: rearrange parts using conveyors:
    [up 50], [down 50], [left 50], [right 50]
    edu: un mélange de tortue et de translation
    edu: on peut fabriquer des obliques en mettant le début d'un opérateur à la fin d'un autre

**ecological poopoo: poopoo stays in the composite
    edu: this way, composite's inner turtle can penDown, without polluting global context

(algèbre des chemins

(en informatique, y'a ce double décalage (temporel et "productionnel") entre la vision qu'on a et sa réalisation. Parfois c'est près, parfois c'est loin.

**composite: [objectAtIndex:<index>] operator
    [[{1 2 3}]] * [objectAtIndex: 0] = [[1]]

**WASD-controlled obj, open world: numbers adventure game (/!\attention à ne pas faire une gamification merdique/!\)
    edu: créer un petit monde avec des portes et des clés et des portails laser avec des conditions logiques ("all must be > 12", "any equals 5")
    edu: quand on a pas beaucoup de mana (==motivation), on peut toujours jouer à la manette. La souris demande un peu plus de motivation.

03 juin 2021:
*edu: small stroke for mathNode pour différencier "ajouter" et "mettre dans le même sac"
*edu: créer des exercices avec des cailloux de couleur pour commencer à maîtriser les fonctions

**[objectAtIndex:]: multiple flavors
  - destroy container and keep part at index (==pure-function way)
      edu: this behavior has a nice advantage: working space stays clean
  - don't mutate container: simply gain control of part at index
  - mutate container: remove part at index from container
  some of those behaviors may only be possible when using supervessel

**[pickme <obj>] operator: when an object becomes an operator
    to ease function drawing, we can store an object in an operator, waiting to be used later
    object touching operator:
      - if it's a container, obj will be added to it
      - if it's an obj,      a container will be created containing the two objects
      - if it's an emptyObj, obj will replace emptyObj

**edu: tranquillement aller vers l'abstraction (et "l'équivoque"): du spécifique au générique
    commencer par les opérateurs spécifiques [c:objectAtIndex:] [str:charAtIndex:] etc.
    pour aller vers les opérateurs génériques [g:elementAtIndex:]

04 juin 2021:
**pathmade: vesseler: convey objects using a disposable vessel
    either we make the vessel touchable and mutate it directly
    or     we make the vessel untouchable and we get it back from the touched object (-"Are you being vesseled ?" -"Yes, I do" -"Kay, thanks")
    shu: I prefer the second way

**transformationFunc("new"): coords__icObj_new = coords__vessel
*?transformationFunc("append"): keep old and add new

***pathmade:part#nPath
    the idea: easily draw paths to _dispatch_ composite parts (==vesseled objects)
      draw part#1Path by pressing "1" and drawing
      draw part#2Path by pressing "2" and drawing
      you can choose to draw only part#2Path if you don't want to do anything with part#1
      you can draw part#2Path before part#1Path, drawing order does not matter
      when used, if performer has only one part, part#2 path will simply be unused
    shu: l'idée vient de la confrontation avec cette envie de dessiner des fonctions (facilement)
    dev: encore du sport

**[<- [1,2,3]]: touching this operator adds 3 objects to current vessel
**[store: linear]: any object touched by this operator will be added to a collection just under the operator
    the collection is either:
    - a composite
    - an arrangement (objects parent is canvas) and the collection is an inner variable of the operator

**[vessel] and [unvessel] in order to try operators manually

05 juin 2021:
**curse::unique: ==not clonable
    as it is a restriction, there are as many flavors as there are clone flavors

**walls: isFloating while conveyed: use paths to get over walls   (inspiration: BABA IS YOU)
    edu: this compels students to use paths

***pathmade: seaming:
    when perfomer is touched by another pathmadeOp:
      1. prematurely terminate current pathmadeOp
      2. perform for new pathmadeOp
    loop: newest has priority over its old self
    edu: la règle est assez simple en fait, c'est comme quand on a une copine
    example:
      while loop = draw [loop] pathmadeOp, draw [if] pathmadeOp which exits loop path
**pathmade::loop: system automatically sets facade name as "loop" when end of path intersects operator's touchSlot

(*Not simply draw, but draw in time, draw in space & time

**write condition script in [if <condition>] pathmadeOp

*[join("+")]

**store commands: "clone and store", "create store", "set active store"

**path merge: [if] pathmadeOp goes back to original path
      ====[if]========>=================
            \--------->----------/

*edudemo: build operator: [^ <exponent>]
    there will be many ways to build it:
      - loop + exits
      - whileLoop
      - repeatLoop

**edudemo: les deux formes de la multiplication
  - repeat(+)
  - scale(bloom)
  edu: ces deux formes sont équivalentes (c'est un peu comme le principe d'équivalence d'Einstein)
  edu: on peut peut-être fabriquer une edudemo intermédiaire qui ferait le lien entre les deux

07 juin 2021:
**another operator behavior: imprintable: on first touch(es), operator's behavior gets fully specified
    example:
      imprintable counter: count all like this one (one touch to fully specify behavior)
      imprintable combo counter: count all combos like this combo (multiple touches to fully specify behavior)
    like an EEPROM, but it's an operator

**challenge::dictation: touch mistakes in the text with the correct [mistake] obj

*value-wise store/counter: only store or count when touching an object with an expected value

**histogram store: must touch with the expected value
**histogram counter: store + counter reictangle
**histogram loop: since we use value-wise counters, performer can try all counters for a valid touch
    example workflow: random sample: build single   histogram  : loop { get_random_value, try all counters for a valid touch}
    example workflow: random sample: build multiple histograms : loop { get_random_value, try all counters for a valid touch in random events partition #1, try all counters for a valid touch in random events partition #2, etc.}

08 juin 2021:
**edu: constructionism: any object that the student has managed to create is then available in a dedicated well
    - as a snapshot version:    this version contains all the pain and trouble that the student has overcome
    - as an "instant" version:  this version is the most efficient version

**Theorem as a function: meta-theorem as a function generator     ("functions all the way down")
  edu: [bag with conditions] * [theorem] = [bag with conclusions]

11 juin 2021:
**icObj.type = "magnifier"
    edu: pour mettre en avant une zone spéficique dans une présentation dynamique
    edu: pour regarder ce qui se passe dans un processus "profond"
          et pour pouvoir débugger par exemple

store: layout: gridLayout
  layoutEngine

**icObj.type = "layout"
    this object is like a composite but parts are arranged using specific rules
    (fun: include handle in the objects we layout ("icLayout layouting itself")
    dev: first, static layout
    dev: then, dynamic layout (allow dnd reordering etc.)

**"Time" control: accelerate, slow down
    edu: when repeating random experiments, after having shown a few outcomes, accelerate to build histograms

**value-wise counter: 2DGrid: we specify two sets A and B, and we then count objects in AxB

**(*)store: many flavors:
    copyStore: [[obj]] * [store] = [[obj]]  + side effect: copy of [[obj]] is put in depot
        shallowCopy
          dev: dans ce cas on crée rep_stored et on met rep_stored au dépot ?
        deepCopy
    hardStore: [[obj]] * [store] = [[*]]    + side effect:         [[obj]] is put in depot
      [[*]] means an activator (empty) object
    edu: la shallow copy peut être très utile pour représenter des partitions: si tu es petit, je te peins en bleu, si tu es grand, je te peins en rouge

**edu: use a loop to create counters: [iterator: possible_outcomes]/[iterator generator: create possible_outcomes iterator]
                                        icObj generator            /  generator generator
  dev: pour cela, on a besoin de connaître l'ensemble des issues possibles

**edu: show stack: encountering a shadePossessor along the path must be treated as: push next path on the stack
**icObj.type = "futuring"
    icObj.futuring
    mutate current futuring, as if it were any other property, like position or fill color
    icObj.futuring = ttFunc(icObj.futuring)
    [speed:fast], [speed:slow], [speed:normal]
    [speed:faster], [speed:slower]
    we may also track down the transformation process of the transformation process, etc. (== the futuring of the futuring)

**edu: show stackless execution: encountering a conveyor along the path is treated as: abort previous pathOperator and follow the new one

**edu: show tree evaluation: starting at the bottom, make shadePossessor halfloops to compute which reduced object the tree is equivalent to

**edu: Z-tree: each depth level has its own homeScale so that you have to zoom in to see what is inside the node, etc.

**icObj.isTouchable -> icObj.isTouchableDict
    this will allow complex routing: two objects may follow the same path, and yet, interact with different operators along the way

**(*)AI objects create their own pathmade operators: this may be funny to see, all the more if they achieve something non trivial

12 juin 2021:
**the admin way of drawing: multidimensional color == {color + recipients}
    this way, the admin may specify things to specific players
    admin is able to see what all players see: either all merged or specific projections
    typical use case: adminDraw a codenames game: draw blue and red borders only for tellers

**theorem operators: [[hypothesis]] * [theorem:<your_theorem>] = [[conclusions]]
    example: {[[a<b]], [[b<c]]} * [< is transitive] = [[a<c]]

**pathsnapping: snap operator on path
  dev: outche

**dynamically (re)define font: font adapts to your editing it: you can draw over a character and character adapts
  (=> "supereasy" font creation)

13 juin 2021:
(intention vs implementation

**supereasy::number creation: type a numpad number (a timeout resets after each key press) and an icMathNode is created with your number as constantNode's value
    edu: because it's primarily created for kids to manipulate numbers
    edu: maybe we should also add this shortcut: KeyX: create an icMathNode with "x" as symbolNode's symbol
    0 number builder
      0 manage builder timeout
      0 manage -12
        0 infinite wait for -
      0 manage 3/4
        0 infinite wait for /

14 juin 2021:
(x  |--> "x" |--> lf("x") |--> f(x)    VS  x |--> f(x)
   to_litt  litteral_f   from_litt             f
   on pourrait faire un carré mais l'idée est la suivante: est-ce qu'on ne mélange pas trop souvent les deux ?
   et on pourrait ajouter une phase de simplification, si on considère que l'objet non simplifié et l'objet simplifié sont tout de même différents l'un de l'autre
    lf("x") |--> nsf(x)          |-->     sf(x)
              not simplified   simplify   simplified

15 juin 2021:
***le transformé comme sujet VS le transformeur comme sujet: ajouter le comportement "dual": j'attrape un opérateur et je touche(/me fais toucher par ?) ce que je veux transformer
    edu: peut-être que les deux comportements sont complémentaires pour faire comprendre telle ou telle opération
         l'avantage du transformé comme sujet, c'est qu'il permet les enchaînements de transformations
    edu: et puis ça ouvre la voie vers les opérateurs d'operateurs etc.

(("Le graphe pour le graphe" (Ducrot dans la tête): notre réseau de neurones dans la tête serait là pour calquer les graphes qui existent dans la nature
    de manière à avoir une sorte de "toy copy" dans la tête
    Un des graphes les plus utiles à "toy copier" est le graphe du langage (en fait il y en a plusieurs, le graphe langagier et le(s) graphe(s) linguistique(s)).
      Si on considère que le sens d'un mot n'est que le graphe des connexions qui shadowent un mot, et que, c'est uniquement cette structure abstraite qui donne le goût du mot, alors on a juste besoin d'une machine à fabriquer des graphes pour, partant de rien, petit à petit comprendre des trucs.
      Le graphe de notre réseau de neurones serait donc un super graphe ("toy copy") et une fonction de génération de graphe.
      La fonction de génération de graphe doit sûrement dépendre, au bout d'un moment, du super graphe lui-même (mais là ça devient hardcore).
      Le super graphe, bien qu'il soit tentant de le considérer comme une construction physique statique, comme un tas d'argile modelée,
      est en fait un graphe performé (et donc surtout _performable_): quand le sens d'un mot est vécu,
      les relations entre éléments du graphe sont effectivement réalisées, à chaque fois,
      par des circulations, comme une relecture (très rapide) de tout ce qui fait ce sens,
      ou du moins tant que le super graphe n'a pas lui-même bâtit un mini graphe "compilé" qui réalise tout cela de manière encore plus accélérée.
    Un dictionnaire, c'est une version "rétention tertiaire"(livre) du graphe du langage.

(*l'algèbre des carreaux: [2x (horiz)] et [2x (vert)]    [[5 horiz]] / [[10 horiz]] = [[3 vert]] / [[6 vert]]
  [[1 horiz]] == [[1 vert]] == [[1 square]] == [[1]]
  [[6 vert]] == [[1]] * [x6 (vert)]

***iCClassroom (==iC + colyseus): on imagine qu'on reconstitue une classe en partant d'un grand rectangle qu'on divise en sous-rectangles
  chaque élève a son sous-rectangle dans lequel il peut travailler,
    ce qui est cool, c'est que cet espace, quoique borné, est infini.
  Le prof a un sous-rectangle de présentation, et plus important, il voit chaque sous-rectangle de sa classe.
    est-ce qu'il peut voir tous les objets ? même ceux que l'élève cache profondément, genre des petits dessins, des trucs comme ça ? (avec un focus_to_next_object() en appuyant sur TAB)
  Les élèves peuvent voir ou ne pas voir ce que font les autres élèves en fonction de l'activité.
  En phase de travail:
    mode fermé:  l'élève ne voit que son espace
      edu: pour faire en sorte que l'élève puisse se concentrer
    mode ouvert: les élèves peuvent voir les espaces des autres
      edu: pour confronter différentes idées, différents résultats
  En phase de cours magistral:
    les élèves peuvent écrire dans leur espace mais de façon exceptionnelle: quand le tableau blanc n'est plus dans leur point de vue, un compte à rebours s'active qui les ramènent au tableau blanc.
  edu/dev: wow, y'a plein de choses à faire, y'a du potentiel

16 juin 2021:
**24-sourced controller: from 24 inputs to 1 input: every frame, input is avg input
    => The Wisdom of crowds

**pathmade operator: throwing exceptions: _any_ operator may throw an exception, which results in stopping the current pathmade
    examples:
      when encountering an empty vessel
      when trying to divide by zero

**[filter:<condition>]: filter removes cargo from vessel when condition is not satisfied

**conductive operator: allow [generator] to be used in place of [[instantiated collection]]
    ([randInBag {} with .isConsume = false] is a generator (?)

18 juin 2021:
**symbol: "on top of", "put over": /_
**stacks: [[0]] /_ [[+ 2]] /_ [+ 3] /_ [/ 5]
    {[[0]], [[2]]} /_ [+] /_ [+ 3]

**[eval:inner] operator: [[*]] * [eval:inner {[[3]], [+ 2]}] = [[5]]
   edu: pour pouvoir montrer la différence entre une expression non-évaluée et une expression évaluée
   this operator creates an inner no-interaction zone, so that we can set up a stack inside it [eval:inner <stack>]

**exothermic reactions: [[A]] * [B] = [[C]] + {[[exoParticleD]], [[exoParticleE]], ...}
  edu: this would be used to show chain reactions
  edu: I don't know what endothermic reactions would be like ?

**[occurences]: [[collection]] * [occurences] = [dict__occurences]
*edu: loto: faire plusieurs tirages de loto (boucle de boucle5 et store de store5) et ensuite analyser les différents tirages de 5 numéros
  prendre le store et lui faire toucher des opérateurs, [occurences], [unique], etc.

**edu: randInBag: bag.parts = {bag_drawing, ...bag_contents}
    bag_drawing.isCosmetic = true;

(*revolving randomness: are we still in the "random experiment" theoretical boundaries?
    example: rand( revolving(1,2,3,4,5,6), revolving(7,8,9) ) which would yield, at first, 1 or 7, then 2 or 8, then 3 or 9, then 4 or 7, etc.

(**"TRY HARDER" VER: on reprend tout, en gardant ce qui est bon, en corrigeant ce qui doit être corrigé, et tout ça, sur des fondations différentes, _a priori_ meilleures

19 juin 2021:
**named object(=> references): if [[2]].name is "x", then [["x"]] * [get named] = [[2]]
**evocator (== [get [[*x]] ]): get existing _long-living_ object
    this brings state in this otherwise functional landscape

**operator evocation: when almost every [[+ 2]] mean: "get the one and only [[+ 2]] thing, and do it"
    there is a pathmade way to do operator evocation: when pathmade is simply a "passthrough operator", with the path only passing through one operator (the one we want to evoke)

**t[icWorld]t (==file object (or folder)): when you doubleclick on this object, its contents are loaded so that its biggest scale is the scale in which you enter it (==it is framed)
    a world can contain itself, either as a dive (==go deeper) or as a reboot (==go back to entrance)

**edu: iC to specify a language: some typical human situations, and their contexts, are set up and the user can write the words of his language, or record the sounds of his language which are related to the situation, when it is relevant.

20 juin 2021:
**transformationOutput.cfg.isKeepPosition

21 juin 2021:
**dot operator: get property named: [. [[propName]] ]
  example: [. [["color"]] ]

**randomMultipathmade: parts-to-paths mapping is random
  like a 2-D shuffler
**quantum-like: "all possibles"-multipath travels
    collection object covers all possible paths by cloning

***edu::teamChallenge: "right in front of you": hide a key near a geometrical point (we can do it since the canvas is infinite) + transmission of information
    1. a student, the "witness", is shown a geometrical construction sequence
          at the very end of the sequence, a geometrical point is highlighted, this is where lies the challenge completion key
    2. the witness has to write down, in his own words, how to reproduce the sequence
    3. then these instructions are handed to the rest of the team
    4. the team has to reproduce the original construction which will make the key spawn
    5. the team has to find the key which lies near the end point

**randInBag: manage the case where the picked object is put back in the bag

**edu: functionamer operator: [["x"]] * [functionamer [["f"]]] = [["f(x)"]]
    [wrap ["f("] <your_obj> [")"]]
    et là on se dit qu'il nous faudrait quelque chose qui ressemble à du texte, mais dans le lequel on pourrait mettre n'importe quel objet : une sorte de texte++.

**edu: proportionality lab: different ways of responding to [x 2]
    [[2,7]]       * [x 2] = [[5,4]]
    [[baguette]]  * [x 2] = {[[baguette]], [[baguette]]}
    [[<-rect->]]  * [x 2] = [[<-----rect----->]]
    [[square(2)]] * [x 2] = [[square(4)]]
    [["hello"]]   * [x 2] = "hellohello"


22 juin 2021:
**edu(/tech): ensure that students all experience the same (when possible)
    - scroll-speed automatic calibration
    "etc."

**draw movement/draw on wrt something moving:
    lock pov on moving object, then draw in that local coordinate system
    example:
      draw earth movement around the sun then draw moon movement around the earth
    edu: if student can draw a solar system in, say, 5 minutes, then they may understand it better







.
