<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Infinite Canvas</title>

  <style>
    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;

      /* Prevent document pinch-zoom & touch-hold-to-highlight */
      touch-action: none;

      -webkit-touch-callout: none;
      /* iOS Safari */
      -webkit-user-select: none;
      /* Safari */
      -khtml-user-select: none;
      /* Konqueror HTML */
      -moz-user-select: none;
      /* Old versions of Firefox */
      -ms-user-select: none;
      /* Internet Explorer/Edge */
      user-select: none;
      /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
    }
  </style>

</head>

<body>

  <!-- <video id="myVideo"></video> -->
  <!-- <button id="myButton"></button> -->
  <!-- <img id="myImage" src="https://i.stack.imgur.com/8fooU.png"></img> -->

  <!-- <script src='saves/th_nostalgie.js' type='text/javascript'> </script> -->


  <link href="lib/video-js.min.css" rel="stylesheet">
  <script src="lib/video.min.js"></script>

  <!-- global -->
  <script>

    class Globals {
      constructor() {
        this.isEditing = false;
      }
    }

    const globalsSingleton = new Globals(); 

  </script>

  <!-- utils -->
  <script>

    class Utils {

      static arrayByRemovingElement(src_arr, elt) {

        const index = src_arr.indexOf(elt);

        return this.arrayByRemovingElementAtIndex(src_arr, index);
      }

      static arrayByRemovingElementAtIndex(src_arr, index) {

        const arr = [...src_arr]; //create shallow copy of src_arr

        const arr_removed = arr.splice(index, 1);   //starting at index, remove 1 element
        const arr_new = arr;                    //array is mutated in place

        return arr;
      }

      static randomElementInArray(arr) {
        const elt = arr[Math.floor(Math.random() * arr.length)];

        // "~~" for a closest "int"
        // const elt = arr[~~(arr.length * Math.random())];

        // "|" for a kinda "int div"
        // const elt = arr[arr.length * Math.random() | 0];

        return elt;
      }

      static randomElementInArray__weighted(arr, arr_weight_in) {
        var i;

        const arr_weight = [...arr_weight_in];

        for (i = 0; i < arr_weight.length; i++)
          arr_weight[i] += arr_weight[i - 1] || 0;

        const random = Math.random() * arr_weight[arr_weight.length - 1];

        for (i = 0; i < arr_weight.length; i++)
          if (arr_weight[i] > random)
            break;

        return arr[i];
      }

      static early_break_reduce(arr, reduce_callback, initial, checkStopFunc) {
        const x = [...arr]                         // create copy of "array" for iterating
          .reduce((acc, x, i, arr) => {
            if (checkStopFunc(acc, x, i, arr)) {
              arr.splice(1);     // eject early by mutating iterated copy
              return acc;
            }
            return reduce_callback(acc, x, i, arr);
          }, initial);
        return x;
      }


      static randomSubArrWithArray(arr_src_in, nb) {
        var arr_src = [...arr_src_in];
        return [...Array(nb).keys()].reduce((acc, x) => {
          const arr_index = [...Array(arr_src.length).keys()]
          const index_random = Utils.randomElementInArray(arr_index);
          const elt_picked = arr_src[index_random];
          arr_src = Utils.arrayByRemovingElementAtIndex(arr_src, index_random);
          return [...acc, elt_picked];
        }, []);
      }



      /**
       * Shuffles array in place.
       * @param {Array} a items An array containing the items.
       */
      static shuffle(a) {
        var j, x, i;
        for (i = a.length - 1; i > 0; i--) {
          j = Math.floor(Math.random() * (i + 1));
          x = a[i];
          a[i] = a[j];
          a[j] = x;
        }
        return a;
      }

      static arr_progress(nb_steps) {
        var outArr;

        outArr = [...Array(nb_steps).keys()].map(index => {
          const progress = 1.0 * index / (nb_steps - 1);
          return progress;
        });
        logger.log("log1", "arr_progress", outArr);

        return outArr;
      }

      static partitionArray(arr, spacing) {
        var output = [];

        for (var i = 0; i < arr.length; i += spacing) {
          output[output.length] = arr.slice(i, i + spacing);
        }

        return output;
      }

    }


    class ColorUtils {

      static randomColor() {
        var r = 255 * Math.random() | 0,
          g = 255 * Math.random() | 0,
          b = 255 * Math.random() | 0;
        return 'rgb(' + r + ',' + g + ',' + b + ')';
      }



      static rainbow__color_with_progress(progress, nb_cycles) {
        var outString;
        const value_h = math.floor(360 * progress * nb_cycles) % 360;
        const color = new Color("hsl(" + value_h + ",80%,50%)");
        logger.log("log1", "rainbow__color_with_progress", color);

        // outString = color.toString({format: "hex"});
        function hslToHex(h, s, l) {
          l /= 100;
          const a = s * Math.min(l, 1 - l) / 100;
          const f = n => {
            const k = (n + h / 30) % 12;
            const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return Math.round(255 * color).toString(16).padStart(2, '0');   // convert to Hex and prefix "0" if needed
          };
          return `#${f(0)}${f(8)}${f(4)}`;
        }

        outString = hslToHex(color.h, color.s, color.l);

        logger.log("log1", "rainbow__color_with_progress", outString);

        return outString;
      }

      static rainbow__random_arr_of_length(length, nb_cycles) {
        var outArr;

        outArr = Utils.arr_progress(length)
          .map(progress => {
            return ColorUtils.rainbow__color_with_progress(progress, nb_cycles);
          });

        return outArr;
      }


    }


    class Logger {

      constructor() {
        this.initialize();

        // this.hush(this);
      }

      initialize() {
        this.invest(console);
        this.hush(console);
      }

      invest(obj) {
        this.log = obj.log;
        this.trace = obj.trace;
      }

      hush(obj) {
        obj.log = function () { };
        obj.trace = function () { };
      }


    }

    const logger = new Logger();

  </script>
  <!-- <script>
      //debug
      const arr_test = [1,2,3,4,5,6];
      const s = Utils.early_break_reduce(arr_test, (acc,x,i,arr) => {
        logger.log("x", x);
        return acc + x;
      }, 0, (acc, x, i, arr) => {
        return i > 2;
      });
      logger.log("s", s);
    </script> -->

  <!-- <script src='lib/base64.js' type='text/javascript'></script> -->

  <script src='lib/Queue.js' type='text/javascript'> </script>
  <script src='lib/PriorityQueue.js' type='text/javascript'> </script>


  <!-- GEMINI -->
  <!-- <script src='lib/gemini.browserified.bundle.js' type='text/javascript'> </script>
    <script>
      logger.log("Bundle_GMN", Bundle_GMN);
      const Gemini = Bundle_GMN.Gemini.Gemini;
      logger.log("Gemini", Gemini);
      const GeminiObject = Bundle_GMN.GeminiObject.Gemini_Object;
      logger.log("GeminiObject", GeminiObject);
    </script> -->
  <script src='lib/gemini/Gemini_All.js' type='text/javascript'> </script>
  <script>
    logger.log("Gemini", Gemini);
    logger.log("GeminiObject", GeminiObject);
    logger.log("GeminiHatch", GeminiHatch);
    logger.log("Mini", Mini);
  </script>

  <!-- UI -->
  <script src='lib/fabric.min.js' type='text/javascript'></script>
  <!-- "tool canvas" -->
  <!-- <canvas id="canvas__tool" style="visibility:hidden;">Your browser does not support HTML5 canvas</canvas> -->
  <!-- <script>
      const canvas__tool = document.getElementById("canvas__tool");
      canvas__tool.width  = window.innerWidth;
      canvas__tool.height = window.innerHeight;
    </script> -->
  <script>
    const canvas__tool = document.createElement("canvas");
    canvas__tool.id = "canvas__tool";
    canvas__tool.width = 1000;
    canvas__tool.height = 1000;
      // canvas__tool.style.visibility = 'hidden';
      // document.body.appendChild(canvas__tool);
  </script>
  <!-- <script>
      const fabricCanvas__tool = new fabric.Canvas(canvas__tool.id, {
        backgroundColor: 'rgba(0,0,0,0)',
        // backgroundColor: 'rgb(0,0,0)',

        width:  canvas__tool.width,
        height: canvas__tool.height,
      });
      logger.log("fabricCanvas__tool", fabricCanvas__tool);
    </script> -->
  <script>
    class ImageUtils {

      static boundingBox__pixelWise(imageData, w, h) {
        var outBoundingBox;

        const arr_x = [...Array(w).keys()];
        const arr_y = [...Array(h).keys()];

        const mat_xy = arr_x.map(x => {
          return arr_y.map(y => {
            const point = {
              x: x,
              y: y,
            };
            return point;
          });
        }).flat();

        outBoundingBox = mat_xy.reduce((acc, point) => {

          const x = point.x;
          const y = point.y;

          const arr_rgba = ImageUtils.getPixelArrRgba(imageData, w, h, x, y);

          const r = arr_rgba[0];
          const g = arr_rgba[1];
          const b = arr_rgba[2];
          const a = arr_rgba[3];

          const isRgbNonZero = (r != 0) || (g != 0) || (b != 0);
          const isAlphaNonZero = (a != 0);

          const isNonEmpty = isRgbNonZero && isAlphaNonZero;
          if (isNonEmpty) {
            // logger.log("x", x, "y", y);
            // logger.log("arr_rgba", arr_rgba);

            acc.x1 = Math.min(acc.x1, point.x);
            acc.y1 = Math.min(acc.y1, point.y);
            acc.x2 = Math.max(acc.x2, point.x);
            acc.y2 = Math.max(acc.y2, point.y);
          }

          return acc;
        }, {
          x1: w - 1,
          y1: h - 1,
          x2: 0,
          y2: 0,
        });

        return outBoundingBox;
      }

      static getImageDataObj(dataUrl) {

        const ctx = canvas__tool.getContext("2d");
        logger.log("ctx", ctx);
        ctx.width = canvas__tool.width;
        ctx.height = canvas__tool.height;

        //clear context
        ctx.clearRect(0, 0, ctx.width, ctx.width);

        return new Promise(function (resolve, reject) {
          if (dataUrl == null) return reject();

          var image = new Image();
          image.addEventListener('load', function () {
            const w = image.width;
            const h = image.height;

            var width__ctx_old = ctx.width;
            if (w > ctx.width) {
              ctx.width = w;
            }
            var height__ctx_old = ctx.height;
            if (h > ctx.height) {
              ctx.height = h;
            }

            ctx.drawImage(image, 0, 0, w, h);

            // const imageData = ctx.getImageData(0, 0, w, h).data.buffer;
            const imageData = ctx.getImageData(0, 0, w, h);

            const imageDataObj = {
              data: imageData,
              w: w,
              h: h,
            };

            ctx.width = width__ctx_old;
            ctx.height = height__ctx_old;

            resolve(imageDataObj, false);
          });
          image.src = dataUrl;
        });

      }

      static imageFromImageData(imagedata) {
        var ctx = canvas__tool.getContext('2d');
        canvas__tool.width = imagedata.width;
        canvas__tool.height = imagedata.height;
        ctx.putImageData(imagedata, 0, 0);

        var image = new Image();
        image.src = canvas__tool.toDataURL();
        return image;
      }

      static imageFromDataUrl_p(dataUrl) {
        const image_p = new Promise(function (resolve, reject) {
          if (dataUrl == null) return reject();

          var image = new Image();
          image.addEventListener('load', function () {
            resolve(image, false);
          });
          image.src = dataUrl;
        });
        return image_p;
      }

      static imageFromVideo_p(video) {

        canvas__tool.height = video.videoHeight;
        canvas__tool.width = video.videoWidth;

        const ctx = canvas__tool.getContext("2d");
        logger.log("ctx", ctx);

        ctx.drawImage(video, 0, 0, canvas__tool.width, canvas__tool.height);
        const dataUrl = canvas__tool.toDataURL();

        const image_p = new Promise(function (resolve, reject) {
          if (dataUrl == null) return reject();

          var image = new Image();
          image.addEventListener('load', function () {
            resolve(image, false);
          });
          image.src = dataUrl;
        });

        return image_p;

      }

      static getPixelArrRgba(imageData, w, h, x, y) {
        // logger.log("getPixel", imageData, w, h, x, y);

        // const data = new Uint32Array(imageData);
        // logger.log("data.length", data.length);
        // logger.log("w * h", w * h);

        // const index__pixel = y * w + x;
        // const value__pixel = data[index__pixel];
        // return value__pixel;

        const data = imageData.data;
        const index__pixel = y * w + x;
        const index__pixel4 = index__pixel * 4;

        const index__r = index__pixel4;
        const index__g = index__pixel4 + 1;
        const index__b = index__pixel4 + 2;
        const index__a = index__pixel4 + 3;

        const r = data[index__r];
        const g = data[index__g];
        const b = data[index__b];
        const a = data[index__a];

        return [r, g, b, a];
      }

      static getPixelRgbaColorString(imageData, w, h, x, y) {
        const arr_rgba = ImageUtils.getPixelArrRgba(imageData, w, h, x, y);

        const rgbaColorString = "rgba(" + arr_rgba.join(",") + ")";

        return rgbaColorString;
      }

      // static qrcode__decode_image(img) {
      //   const imageData = ImageUtils.getImageDataObj(img);
      //   return ImageUtils.qrcode__decode_imageData(imageData);
      // }


      // static qrcode__decode_image_p__zxing(img) {
      //   const codeReader = new ZXing.BrowserMultiFormatReader();
      //   // logger.log("codeReader", codeReader);
      //   return codeReader.decodeFromImage(img);
      // }

      // static qrcode__decode_imageData__zxing(imageData) {
      //   logger.log("log1", "qrcode__decode_imageData", imageData);
      //
      //   const BarcodeFormat      = ZXing.BarcodeFormat;
      //   const DecodeHintType     = ZXing.DecodeHintType;
      //   const MultiFormatReader  = ZXing.MultiFormatReader;
      //   const RGBLuminanceSource = ZXing.RGBLuminanceSource;
      //   const BinaryBitmap       = ZXing.BinaryBitmap;
      //   const HybridBinarizer    = ZXing.HybridBinarizer;
      //
      //
      //   const hints   = new Map();
      //   const formats = [BarcodeFormat.QR_CODE, ZXing.BarcodeFormat.DATA_MATRIX/*, ...*/];
      //
      //   hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);
      //
      //   const reader = new MultiFormatReader();
      //
      //   const imgByteArray = imageData.data;
      //   const imgWidth     = imageData.width;
      //   const imgHeight    = imageData.height;
      //
      //   const luminanceSource = new RGBLuminanceSource(imgByteArray, imgWidth, imgHeight);
      //   const binaryBitmap    = new BinaryBitmap(new HybridBinarizer(luminanceSource));
      //
      //   return reader.decode(binaryBitmap, hints);
      // }




      static qrcode__decode_image_p(img, shouldTryWithFilters = true) {

        //create
        const id__reader = "reader";

        const readerElt = document.createElement("div");
        logger.log("readerElt", readerElt);
        readerElt.setAttribute("id", id__reader);
        readerElt.setAttribute("width", "600px");
        // readerElt.setAttribute("width","100px"); //test

        document.body.appendChild(readerElt);

        const reader = new Html5Qrcode(id__reader, { formatsToSupport: [Html5QrcodeSupportedFormats.QR_CODE] });
        logger.log("reader", reader);

        const file = FileIntegration.fileForImg(img);

        const result_p = reader.scanFile(file, true)
          .then(decodedText => {
            logger.log("decodedText", decodedText);
            return decodedText;
          })
          .catch(err => {
            // failure, handle it.
            logger.log(`Error scanning file. Reason: ${err}`);

            if (shouldTryWithFilters) {
              //retry with different brightness and contrast
              const value__brightness = 0.10;
              const value__contrast = 0.30;

              const img__filtered_p = ImageUtils.image_filtered_p(img, value__brightness, value__contrast);
              const decodedText__filtered_p = img__filtered_p.then(image_filtered => {
                return ImageUtils.qrcode__decode_image_p(img__filtered, false);
              });

              return decodedText__filtered_p;
            }

          })
          .finally(() => {
            readerElt.remove();
          });

        return result_p;
      }


      //filters

      static image_filtered_p(img, value_brightness, value_contrast) {
        const fObj = new fabric.Image(img);
        const filter__brightness = new fabric.Image.filters.Brightness({
          brightness: value_brightness,
        });
        const filter__contrast = new fabric.Image.filters.Contrast({
          contrast: value_contrast,
        });
        fObj.filters.push(filter__brightness);
        fObj.filters.push(filter__contrast);
        fObj.applyFilters();

        //get image from fObj
        const dataUrl = fObj.toDataURL();
        const img__filtered_p = ImageUtils.imageFromDataUrl_p(dataUrl);
        return img__filtered_p;
      }

    }

  </script>


  <script src='lib/anime.min.js' type='text/javascript'></script>

  <script src='lib/color.global.min.js' type='text/javascript'></script>


  <!-- QRCODE -->
  <!-- <script src='lib/instascan.browserified.bundle.js' type='text/javascript'></script>
    <script>
      const Instascan = Bundle_IS.Instascan;
      logger.log("log1", "Instascan", Instascan);
    </script> -->
  <!-- debug -->
  <!-- <video id="preview"></video> -->
  <!-- <script>
      let scanner = new Instascan.Scanner({ video: document.getElementById('preview') });
      scanner.addListener('scan', function (content) {
        alert(content);
      });
      Instascan.Camera.getCameras().then(function (cameras) {
        if (cameras.length > 0) {
          scanner.start(cameras[0]);
        } else {
          console.error('No cameras found.');
        }
      }).catch(function (e) {
        console.error(e);
      });
    </script> -->
  <!-- <script src='lib/zxingjs.browserified.bundle.js' type='text/javascript'></script>
    <script>
      const ZXing = Bundle_ZX.ZXing;
      // logger.log("log1", "ZXing", ZXing);
    </script> -->
  <script src="lib/html5-qrcode.min.js" type="text/javascript"></script>
  <!-- <script>
      logger.log("log1", "Html5Qrcode", Html5Qrcode);
    </script> -->

  <script src='lib/nodeqrcode.browserified.bundle.js' type='text/javascript'></script>
  <script>
    const NodeQRCode = Bundle_NQ.NodeQRCode;
      // logger.log("log1", "NodeQRCode", NodeQRCode);
  </script>
  <!-- convenience -->
  <script>
    function qrcodeImg_p(str_in) {
      const dataURL_p = NodeQRCode.toDataURL(str_in);
      const img_p = dataURL_p.then((dataURL) => {
        logger.log("log1", "qrcodeImg_p, dataURL", dataURL);
        return FileIntegration.imageFromImgSrc_p(dataURL);
      });
      return img_p;
    }
  </script>


  <!-- MathJax -->
  <script>
    //setup
    MathJax = {
      loader: {
        load: [
          '[tex]/color',
          '[tex]/newcommand',
        ],
      },
      tex: {
        packages: {
          '[+]': [
            'color',
            'newcommand'
          ],
        },
      },
      startup: {
        ready: () => {
          logger.log('MathJax is loaded, but not yet initialized');
          MathJax.startup.defaultReady();
          logger.log('MathJax is initialized, and the initial typeset is queued');
          // logger.log("MathJax", MathJax);

          //newcommand
          //discovery
          MathJax.tex2svg("\\newcommand{\\braket}[1]{\\langle #1 \\rangle}");

          //centernot / fsl(Feynman slash)
          // MathJax.tex2svg("\\newcommand{\\fsl}[1]{\\ensuremath{\\mathrlap{\\!\\not{\\phantom{#1}}}#1}}");
          // MathJax.tex2svg("\\newcommand{\\fsl}[1]{{\\ooalign{\\(#1\\)\\cr\\hidewidth\\(/\\)\\hidewidth\\cr}}");
          // MathJax.tex2svg("\\newcommand{\\fsl}[1]{{\\centernot{#1}}}");

          //colored operation
          MathJax.tex2svg("\\newcommand{\\redbraket}[1]{\\color{red}{\\langle} \\color{black}{#1} \\color{red}{\\rangle}}");
          // MathJax.tex2svg("\\newcommand{\\colorbraket}[2]{\\color{#1}{\\langle} #2 \\color{#1}{\\rangle}}");
          // MathJax.tex2svg("\\newcommand{\\blueoline}[1]{\\colorlet{temp}{.}\\color{blue}\\overline{\\color{temp}#1}\\color{temp}}");
          // MathJax.tex2svg("\\newcommand{\\colorbraket}[2]{\\colorlet{temp}{.} \\color{#1}{\\langle} \\color{temp}{#2} \\color{#1}{\\rangle} \\color{temp}}");

          const mathJaxContainer_svg = MathJax.tex2svg("{\\color{red} 13}");
          logger.log("mathJaxContainer_svg", mathJaxContainer_svg);
        },
      },
    };

      // MathJax = {
      //   tex: {
      //     autoload: {
      //       color: ['color', 'definecolor', 'textcolor', 'colorbox', 'fcolorbox'],
      //     },
      //   },
      // };
  </script>
  <!-- <script src='lib/mathjax.tex-mml-chtml.js' type='text/javascript'></script> -->
  <script src='lib/mathjax.tex-svg.js' type='text/javascript'></script>
  <script>
    //test
    logger.log("MathJax", MathJax);
    logger.log("MathJax.tex2svg", MathJax.tex2svg);
      // MathJax.tex2svg("{\\color(red) 13}");
  </script>

  <script>
    //integration
    class TexHelper {
      static toSvgEl(tex, color = "red") {
        const mathJaxContainer_svg = MathJax.tex2svg(tex);

        const htmlCollection = mathJaxContainer_svg.children;
        const svgEl = htmlCollection.item(0);
        console.log("svgEl", svgEl);

        svgEl.style.color = color;
        // svgEl.style.color2 = "blue";

        return svgEl;
      }
    }

    class SvgHelper {
      static toDataURL(svgEl) {
        var outDataUrl;

        // const svgSource = svgEl.outerHTML;

        const serializer = new XMLSerializer();
        const svgSource = serializer.serializeToString(svgEl);

        // svgSource = svgSource.replaceAll('http://', 'https://');
        console.log("svgSource", svgSource);

        const dataUrl = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svgSource)));

        outDataUrl = dataUrl;

        return outDataUrl;
      }
    }
  </script>
  <!-- <script>
      //discovery
      console.log("MathJax", MathJax);
      // const mathJaxContainer_svg = MathJax.tex2svg('\\frac{1}{x^2-1}', {display: true});
      const mathJaxContainer_svg = MathJax.tex2svg('\\frac{1}{x^2-1}');
      console.log("mathJaxContainer_svg", mathJaxContainer_svg);
    </script> -->

  <!-- <script src='lib/countdown.min.js' type='text/javascript'></script> -->
  <!-- <script>
      //discovery
      var timerId =
        countdown(
          new Date(),
          function(ts) {
            console.log("countdown::ts", ts);
            if(ts.value > 3000) {
              stop();
            }
          },
          countdown.HOURS|countdown.MINUTES|countdown.SECONDS);
      console.log("countdown::timerId", timerId);

      function stop() {
        clearInterval(timerId);
      }
    </script> -->
  <script src='lib/html2canvas.min.js' type='text/javascript'></script>
  <!-- <div id="lolilol" style="width: 100px; height: 100px; background-color:yellow">123456789</div>
    <script>
      //discovery
      html2canvas(document.getElementById("lolilol")).then(function(canvas) {
        // document.body.appendChild(canvas);
        console.log("html2canvas, canvas", canvas);
      });
    </script> -->
  <link rel="stylesheet" href="lib/mathquill/mathquill.css" />
  <script src='lib/mathquill/jquery-3.5.1.min.js' type='text/javascript'></script>
  <script src='lib/mathquill/mathquill.min.js' type='text/javascript'></script>
  <script>
    const MQ = MathQuill.getInterface(2);
    console.log("MQ", MQ);

    function createMathField() {
      var outMathField;

      const span = document.createElement("span");

      if (span.style == null) { span.style = {}; }
      span.style.backgroundColor = "yellow";
      // span.style.width  = "100px";
      // span.style.height = "100px";
      span.style.color = "purple";


      span.style.textAlign = "center";
      span.style.verticalAlign = "middle";

      const mathField = MQ.MathField(span, {
        handlers: {
          edit: function () {
            var tex = mathField.latex(); // Get entered math in LaTeX format
            console.log("tex", tex);
          }
        }
      });
      console.log("mathField", mathField);

      outMathField = mathField;

      return outMathField;
    }

  </script>


  <!-- <p><span id="answer">x=</span></p>
    <script>
      var answerSpan = document.getElementById('answer');
      var answerMathField = MQ.MathField(answerSpan, {
        handlers: {
          edit: function() {
            var enteredMath = answerMathField.latex(); // Get entered math in LaTeX format
            // checkAnswer(enteredMath);
            console.log("enteredMath", enteredMath);
          }
        }
      });
    </script> -->


  <!-- Maths -->
  <script src='lib/decimal.min.js' type='text/javascript'></script>

  <script src='lib/math.js' type='text/javascript'></script>
  <script>
    //customization

    class MySummerNode extends math.ConstantNode {

      // toTex() {
      //   if(this.value == 1) {
      //     // return "un";
      //     return "\\not{1}";
      //   }
      //   return super.toTex();
      // }

      toTex() {
        var outTex;

        const tex__legacy = super.toTex();

        if (this.isSlashed) {
          return "\\not{" + tex__legacy + "}";
        } else {
          outTex = tex__legacy;
        }

        return outTex;
      }

    }
  </script>


  <!-- <script src='lib/algebra-0.2.6.min.js' type='text/javascript'></script> -->
  <!-- <script>

      //discovery
      {
        // const chain = math.chain(1);
        //OR
        const chain = math.chain();
        chain.value = 1;
        console.log("debug::chain, initial", chain);

        const step1 = chain.add(8);
        const r1    = step1.done();
        // const r1 = chain.valueOf();
        console.log("debug::chain, r1", r1);

        const step2 = step1.multiply(100);
        const r2    = step2.done();
        console.log("debug::chain, r2", r2);

        console.log("debug::chain is not mutated in place");     //which is nice and not surprising from a functional programming pov
        console.log("debug::chain.done()", chain.done());
      }

      //chaining on expression
      /*
      { //SHU: THE DREAM
        const math_with_algebra = math.create(math.all);
        math_with_algebra.import(algebra, {wrap: true, silent: true});
        // math_with_algebra.import(algebra, {override: true, wrap: true, silent: true});

        const chain = math_with_algebra.chain();

        // const expr   = new algebra.Expression("x");
        const expr   = new math_with_algebra.Expression("x");
        // const expr = "x";

        console.log("expr", expr);
        chain.value = expr;                                             //SHU TODO: make this possible
        console.log("debug::chain, initial", chain);

        // const step1 = chain.add(8);                                      //SHU: en fait c'est peut-être juste un problème de coercion.
        const step1 = chain.add(new math_with_algebra.Expression(8));    //SHU: Ah non. Dommage.

        const r1    = step1.done();
        // const r1 = chain.valueOf();
        console.log("debug::chain, r1", r1);

        const step2 = chain.multiply(100);
        const r2    = step2.done();
        console.log("debug::chain, r2", r2);
      }
      */

      /*
      { //SHU: THE WORKAROUND
        var expr   = new algebra.Expression("x");
        expr = expr.multiply(2);
        expr = expr.multiply("x");
        expr = expr.multiply(new algebra.Expression("x"));
        expr = expr.add("y");
        expr = expr.add(new algebra.Fraction(1, 3));
        expr = expr.add("y");                                       //SHU: oh, no. There is automatic reducing.
        console.log("expr", expr.toString());

        //Simplification
        //All expression operations accept a simplify argument that will yield an unsimplified expression when set to false.
        //You can then get a simplified expression with Expression.simplify.

        var expr   = new algebra.Expression("x");
        expr = expr.multiply(2,false);
        expr = expr.multiply("x",false);
        expr = expr.multiply(new algebra.Expression("x"),false);
        expr = expr.add("y",false);
        expr = expr.add(new algebra.Fraction(1, 3),false);
        expr = expr.add(new algebra.Expression("y"),false);
        console.log("expr", expr.toString());                       //SHU: unsimplified expression terms order is wrong
        expr = expr.simplify();                                     //SHU TODO: show correct terms order
        console.log("expr", expr.toString());
      }
      */

    </script> -->

  <!-- <script src='lib/math-expressions.js' type='text/javascript'></script> -->
  <!-- <script src='lib/math-expressions_umd.js' type='text/javascript'></script> -->
  <script src='lib/math-expressions.browserified.bundle.js' type='text/javascript'></script>
  <script>
    const MathExpression = Bundle_ME.MathExpression;
  </script>
  <!-- <script>
      //discovery
      const mathExpression1      = MathExpression.fromText("sin^2 (x^3)");
      const tex__mathExpression1 = mathExpression1.tex();
      console.log("MathExpression, tex__mathExpression1", tex__mathExpression1);

      const mathExpression2       = MathExpression.fromTex("5 \\times 3");
      const text__mathExpression2 = mathExpression2.toString();
      console.log("MathExpression, text__mathExpression2", text__mathExpression2);
    </script> -->



  <script src='lib/ngraph.graph.min.js' type='text/javascript'></script>
  <!-- <script>
      //discovery
      const g = createGraph();

      g.addNode('hello');
      g.addNode('world');
      //Now graph g contains two nodes: hello and world. You can also use addLink() method to grow a graph. Calling this method with nodes which are not present in the graph creates them:

      g.addLink('space', 'bar'); // now graph 'g' has two new nodes: 'space' and 'bar'
      //If nodes already present in the graph 'addLink()' makes them connected:

      // Only a link between 'hello' and 'world' is created. No new nodes.
      g.addLink('hello', 'world');

      console.log("g", g);
    </script> -->


  <script src='lib/algebrite.bundle-for-browser.js' type='text/javascript'></script>
  <script>

    //discovery
    const equality_1 = Algebrite.run('x + y + x == y + 2x');
    logger.log("equality_1", equality_1);

    const equality_2 = Algebrite.run('4(x + y) - x == 4y + 3x');
    logger.log("equality_2", equality_2);


    const equality_3 = Algebrite.run('4z(x + y) - zx == 4yz + 3xz');    //SHU: software is dumb and intelligent: a priori, xz != zx ( or maybe it's something else ... )
    logger.log("equality_3", equality_3);

    const equality_4 = Algebrite.run('4z(x + y) - zx == 4zy + 3zx');
    logger.log("equality_4", equality_4);

  </script>

  <!-- custom maths stuff -->
  <script>

    const dict_opConfig = {
      1: {
        minus: {
          arity: 1,
          symbol: "-",
          name: "unaryMinus",
          precedence: 6,
        },
        inverse: {
          arity: 1,
          symbol: "/",
          name: "inverse",
          precedence: "?",
        },
      },
      2: {
        plus: {
          arity: 2,
          symbol: "+",
          // name: "plus",
          name: "add",
          precedence: 9,

          inverse: "minus",
        },
        minus: {
          arity: 2,
          symbol: "-",
          // name: "minus",
          name: "subtract",
          precedence: 9,

          inverse: "plus",
        },
        multiply: {
          arity: 2,
          symbol: "×",

          name: "multiply",
          precedence: 8,

          inverse: "divide",
        },
        divide: {
          arity: 2,
          symbol: "/",
          name: "divide",
          precedence: 8,

          inverse: "multiply",
        },
        // pow: {
        //   op: "^",
        //   name: "pow",
        // },
      },
      n: {
        plus: {
          arity: "n",
          symbol: "+",
          // name: "plus",
          name: "add",
          precedence: 9,

          inverse: "minus",
        },
        multiply: {
          arity: "n",
          symbol: "×",
          name: "multiply",
          precedence: 8,

          inverse: "divide",
        },
      },
    };


    // (...) [...] {...}		            1
    // x(...) x[...] obj.prop :		    2
    // '		                            3
    // !		                            4
    // ^, .^		                        5
    // +, -, ~, not		                6
    // See section below		            7
    // *, /, .*, ./, %, mod		        8
    // +, -		                        9
    // :		                           10
    // to, in		                     11
    // <<, >>, >>>		                 12
    // Err :501		                   13
    // &		                           14
    // ^|		                         15
    // |		                           16
    // and		                         17
    // xor		                         18
    // or		                         19
    // ?, :		                       20
    // =		                           21
    // ,		                           22
    // ;		                           23
    // \n, ;		                       24
    const precedenceDict = {
      "unaryPlus": 6,
      "unaryMinus": 6,

      "multiply": 8,
      "divide": 8,

      "add": 9,
      "subtract": 9,
    };


    class Operator {

      constructor(arity, easyName, symbol, name, inverseName = null) {
        this.arity = arity;
        this.easyName = easyName;

        this.op = symbol;
        this.symbol = symbol;

        this.name = name;

        this.inverseName = inverseName;
      }

      static fromConfig(opConfig) {
        const op = new Operator(opConfig.arity, "lolilol", opConfig.symbol, opConfig.name, opConfig.inverse);
        return op;
      }

      static randomInstance(arity) {

        const arr_opConfig = Object.values(dict_opConfig[arity]);
        const opConfig__random = Utils.randomElementInArray(arr_opConfig);

        const op__random = Operator.fromConfig(opConfig__random);
        return op__random;
      }


      inverse() {   //what did you expect ?
        const arity = this.arity;
        const inverseName = this.inverseName;

        const opConfig__inverse = dict_opConfig[arity][inverseName];

        const op__inverse = Operator.fromConfig(opConfig__inverse);
        return op__inverse;
      }


      static multiply() {
        var outOp;

        const opConfig = dict_opConfig[2]["multiply"];
        outOp = Operator.fromConfig(opConfig);

        return outOp;
      }

      static divide() {
        var outOp;

        const opConfig = dict_opConfig[2]["divide"];
        outOp = Operator.fromConfig(opConfig);

        return outOp;
      }

      static fromString_binary(opString) {
        var outOp;

        function fnString_for_opString(opString) {
          var outString;

          switch (opString) {
            case "+":
              outString = "plus";
              break;
            case "-":
              outString = "minus";
              break;
            case "x":
              outString = "multiply";
              break;
            case "/":
              outString = "divide";
              break;
          }

          return outString;
        }

        const fnString = fnString_for_opString(opString);

        const opConfig = dict_opConfig[2][fnString];
        outOp = Operator.fromConfig(opConfig);

        return outOp;
      }


    }

    class Operation {

      constructor(transformationFunc) {
        this.transformationFunc = transformationFunc;
      }

    }





    function random_op(arity) {
      const op = Operator.randomInstance(arity);
      return op;
    }
    // console.log("random_op", random_op(2));

    function random_number(range) {
      const span = range.max - range.min;
      const number = Math.floor(range.min + Math.random() * span);
      return number;
    }

    const arr_symbols = ["x", "y"];
    // const arr_symbols = ["x", "y", "z", "t", "a", "b"];

    function random_symbol() {
      const symbol = Utils.randomElementInArray(arr_symbols);
      return symbol;
    }

    function arityForArr(arr) {
      var outArity;

      switch (arr.length) {
        // case 0:
        //   outArity = 0;     //everything or nothing
        // break;
        case 1:
          outArity = 1;
          break;
        case 2:
          outArity = 2;
          break;
        default:
          outArity = "n";
          break;
      }

      return outArity;
    }

    //////////////////////

    function random_constantNode(range = { min: 0, max: 100, step: 1 }) {
      const number = random_number(range);
      const constantNode = new math.ConstantNode(number);
      return constantNode;
    }

    function random_symbolNode() {
      const symbol = random_symbol();
      const symbolNode = new math.SymbolNode(symbol);
      return symbolNode;
    }

    function random_terminal_mathNode_withType(type) {
      var outMathNode;

      switch (type) {
        case "ConstantNode":
          outMathNode = random_constantNode();
          break;
        case "SymbolNode":
          outMathNode = random_symbolNode();
          break;
        // case "operator":
        // break;
      }

      return outMathNode;
    }

    function random_terminal_mathNode_withType_inArr(arr_type) {
      const type = Utils.randomElementInArray(arr_type);
      const mathNode = random_terminal_mathNode_withType(type);
      return mathNode;
    }

    function random_terminal_mathNode_withType_inArr_and_isEnvelopped(arr_type, isEnvelopped) {

      var mathNode = random_terminal_mathNode_withType_inArr(arr_type);
      if (isEnvelopped) {
        mathNode = new math.ParenthesisNode(mathNode);
      }

      return mathNode;
    }

    function random_operatorNode(/*arity,*/ arr_node) {
      const arity = arityForArr(arr_node);
      const op = random_op(arity);
      const operatorNode = new math.OperatorNode(op.op, op.name, arr_node);
      return operatorNode;
    }

    function random_operatorNodeFactoryFunc_binary(arr_type) {
      var outFunc;

      const arity = 2
      const op = random_op(arity);

      const node_b = random_terminal_mathNode_withType_inArr(arr_type);

      outFunc = (node_a) => {
        const arr_node = [node_a, node_b];
        const operatorNode = new math.OperatorNode(op.op, op.name, arr_node);
        return operatorNode;
      };

      return outFunc;
    }

    function createMathNodeTransformationFunc_binary(mathOperatorSymbol_in, mathOperatorFuncName_in, node_b_in, isShuffled = false) {
      return (node_a) => {
        var outNode;

        const mathOperatorSymbol = mathOperatorSymbol_in;
        const mathOperatorFuncName = mathOperatorFuncName_in;
        const node_b = node_b_in;

        function standardOperation(node_in) {
          var outNode;

          // const node_b        = new math.ConstantNode(mathValue);

          var arr_child = [node_in, node_b];
          // logger.log("arr_child, before", arr_child);
          if (isShuffled) {
            switch (mathOperatorFuncName) {
              case "add":
              case "multiply":
                {
                  const shuffle = arr =>
                    [...arr].reduceRight((res, _, __, s) =>
                      (res.push(s.splice(0 | Math.random() * s.length, 1)[0]), res), []);

                  arr_child = shuffle(arr_child);
                  // logger.log("arr_child, after", arr_child);
                }
                break;
              default:
                //do nothing
                break;
            }
          }

          const node_operator = new math.OperatorNode(mathOperatorSymbol, mathOperatorFuncName, arr_child);

          const node_unsimplified = node_operator;

          if (node_in.autoSimplify) {
            // const node_simplified = math.simplify(node_unsimplified);
            const node_simplified = Simplifier.simplify_top_layer(node_unsimplified);
            outNode = node_simplified;
          } else {
            outNode = node_unsimplified;
          }

          outNode.autoSimplify = node_in.autoSimplify;

          return outNode;
        }

        // logger.log("node_a", node_a);
        if (node_a.isEquation) {
          console.log("node_a", node_a);
          const node_left = standardOperation(node_a.params[0]);
          const node_right = standardOperation(node_a.params[1]);
          const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
          node_equation.isEquation = true;

          outNode = node_equation;
        } else {
          outNode = standardOperation(node_a);
        }

        // outNode.autoSimplify = node_a.autoSimplify;

        return outNode;
      };
    };

    function random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op = null) {
      var outFuncWrapper;

      const arr_type__node_b = operatorParams.node_b.types;
      const range__node_b = operatorParams.node_b.range;
      const arr__node_b = operatorParams.node_b.arr;

      const isShuffled = (operatorParams.isShuffled != null) ? operatorParams.isShuffled : false;


      const arity = 2
      var op;
      if (arr_op != null) {
        op = Utils.randomElementInArray(arr_op);
      } else {
        op = random_op(arity);
      }

      var node_b = random_terminal_mathNode_withType_inArr(arr_type__node_b);
      // logger.log("random_operatorNodeFactoryFuncWrapper_binary, node_b", node_b);
      if (node_b.type == "ConstantNode") {

        function randomValue() {
          return math.randomInt(range__node_b.min, range__node_b.max);
        }

        var value;
        if (arr__node_b != null) {
          value = Utils.randomElementInArray(arr__node_b);
        } else {
          value = randomValue();
        }
        // logger.log("value:", value);
        if (op.name == "divide") {
          while (value == 0) {
            value = randomValue();
          }
        }


        node_b = new math.ConstantNode(value);

        if (node_b.value < 0) {
          node_b = new math.ParenthesisNode(node_b);
        }

      }

      outFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b, isShuffled);

      return outFuncWrapper;
    }

    function operatorNodeFactoryFuncWrapper_binary(op, node_b, isShuffled = false) {
      var outFuncWrapper;

      const func = createMathNodeTransformationFunc_binary(op.op, op.name, node_b, isShuffled);

      const op__inverse = op.inverse();
      const func__inverse = createMathNodeTransformationFunc_binary(op__inverse.op, op__inverse.name, node_b, isShuffled);

      function createFuncWrapper(op, node_b, func) {

        const simpleName = op.op + " " + node_b.toString();

        const funcWrapper = {
          semantics: {
            operator: op,
            node_b: node_b.cloneDeep(),
            name: simpleName,
          },
          func: func,
          inverse: null,  //set later
        };

        return funcWrapper;
      }

      const funcWrapper = createFuncWrapper(op, node_b, func);
      const funcWrapper__inverse = createFuncWrapper(op__inverse, node_b, func__inverse);
      funcWrapper.inverse = funcWrapper__inverse;

      outFuncWrapper = funcWrapper;

      return outFuncWrapper;
    }


    function random_operatorNode_debug() {
      const arr_nodes = [
        random_symbolNode(),
        random_constantNode(),
      ];
      const operatorNode = random_operatorNode(arr_nodes);
      return operatorNode;
    }
    console.log("random_operatorNode_debug", random_operatorNode_debug());



    function random_operatorNode_binary_withDepth(depth) {
      if (depth < 2) {
        throw new Error("operatorNode is has min depth: 2");
      } else if (depth == 2) {
        const arr_node = [0, 1].map(index => random_terminal_mathNode_withType_inArr(["ConstantNode", "SymbolNode"]));
        const operatorNode = random_operatorNode(arr_node);
        return operatorNode;
      } else {
        const arr_node = [0, 1].map(index => random_operatorNode_binary_withDepth(depth - 1));
        const operatorNode = random_operatorNode(arr_node);
        return operatorNode;
      }
    }

    function random_mathNode_withDepth(depth) {
      var outMathNode;

      if (depth < 1) {
        throw new Error("mathNode is has min depth: 1");
      } else if (depth == 1) {
        const terminalNode = random_terminal_mathNode_withType_inArr(["ConstantNode", "SymbolNode"]);
        outMathNode = terminalNode;
      } else {
        const operatorNode = random_operatorNode_binary_withDepth(depth);
        outMathNode = operatorNode;
      }

      return outMathNode;
    }
    console.log("random_mathNode_withDepth", random_mathNode_withDepth(4));





    //only n symbols

    function getNbSymbolNodes(mathNode) {
      var outInt = 0;

      switch (mathNode.type) {
        case "SymbolNode":
          outInt = 1;
          break;
        case "OperatorNode":
          outInt = operator.params.reduce((acc, x) => acc + getNbSymbolNodes(x), 0);
      }

      return outInt;
    }

    function arr_terminalTypes_for_nbSymbols(nb_symbols) {
      const arr_terminalTypes = ["ConstantNode"];
      if (nb_symbols > 0) {
        arr_terminalTypes.push("SymbolNode");
      }
      return arr_terminalTypes;
    }

    function random_reduceObj__operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols) {   //SHU: it's nb_symbols_remaining
      var outObj;
      var outNode;
      var outNbSymbols;

      const depth_min = 2;

      if (depth < depth_min) {
        throw new Error("operatorNode is has min depth: 2");
      };

      var nb_symbols_curr = nb_symbols;
      if (depth == 2) {

        const arity = 2;
        const arr_nodeIndex = [...new Array(arity).keys()];

        const reducedObj2 = arr_nodeIndex.reduce((acc2, nodeIndex) => {
          const arr_terminalTypes = arr_terminalTypes_for_nbSymbols(acc2.nb_symbols);
          const mathNode = random_terminal_mathNode_withType_inArr(arr_terminalTypes);

          if (mathNode.type == "SymbolNode") {
            acc2.nb_symbols -= 1;
          }

          acc2.arr_mathNode.push(mathNode);

          return acc2;
        }, {
          nb_symbols: nb_symbols_curr,
          arr_mathNode: [],
        });

        outNbSymbols = reducedObj2.nb_symbols;

        const operatorNode = random_operatorNode(reducedObj2.arr_mathNode);
        outNode = operatorNode;
      } else {

        const arity = 2;
        const arr_nodeIndex = [...new Array(arity).keys()];

        const reducedObj2 = arr_nodeIndex.reduce((acc2, nodeIndex) => {
          const reducedObj_ = random_reduceObj__operatorNode_binary_withDepth_and_nbSymbols(depth - 1, acc2.nb_symbols);

          acc2.nb_symbols = reducedObj_.nb_symbols;

          const mathNode = reducedObj_.mathNode;
          acc2.arr_mathNode.push(mathNode);

          return acc2;
        }, {
          nb_symbols: nb_symbols_curr,
          arr_mathNode: [],
        });

        outNbSymbols = reducedObj2.nb_symbols;

        const operatorNode = random_operatorNode(reducedObj2.arr_mathNode);
        outNode = operatorNode;
      }

      outObj = {
        nb_symbols: outNbSymbols,
        mathNode: outNode,
      };
      console.log("depth", depth, "outNbSymbols", outNbSymbols);

      return outObj;
    }

    function random_operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols = 1) {
      const reduceObj = random_reduceObj__operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols);
      return reduceObj.mathNode;
    }

    function random_mathNode_withDepth_and_nbSymbols(depth, nb_symbols = 1) {
      var outMathNode;

      if (depth < 1) {
        throw new Error("mathNode is has min depth: 1");
      } else if (depth == 1) {
        const terminalNode = random_terminal_mathNode_withType_inArr(["ConstantNode", "SymbolNode"]);
        outMathNode = terminalNode;
      } else {
        const operatorNode = random_operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols);
        outMathNode = operatorNode;
      }

      return outMathNode;
    }

    function random_onion_mathNode(depth, isWithExplicitationParentheses = true, isWithRandomParentheses = false) {
      var outMathNode;

      if (depth < 1) {
        throw new Error("mathNode is has min depth: 1");
      } else if (depth == 1) {

        const random_boolean = Math.random() < 0.5;
        const isEnvelopped = random_boolean;

        const terminalNode = random_terminal_mathNode_withType_inArr_and_isEnvelopped(["SymbolNode"], isEnvelopped);

        outMathNode = terminalNode;
      } else {
        const innerOnionNode = random_onion_mathNode(depth - 1, isWithExplicitationParentheses);

        const layerTerminalNode = random_terminal_mathNode_withType_inArr(["ConstantNode"]);

        const layerNode = random_operatorNode([innerOnionNode, layerTerminalNode]);
        console.log("layerNode", layerNode);

        outMathNode = layerNode;

        if (isWithExplicitationParentheses) {
          if (innerOnionNode.type == "OperatorNode") {
            console.log("innerOnionNode", innerOnionNode);

            const opFuncName__innerOnionNode = innerOnionNode.fn;
            const opFuncName__layerNode = layerNode.fn;

            const precedence__innerOnionNode = precedenceDict[opFuncName__innerOnionNode];
            const precedence__layerNode = precedenceDict[opFuncName__layerNode];

            const isSamePrecedence = (precedence__innerOnionNode == precedence__layerNode);

            if (isSamePrecedence) {
              var enveloppedInnerOnionNode;
              if (innerOnionNode.type == "ParenthesisNode") {    //already envelopped
                enveloppedInnerOnionNode = innerOnionNode;
              } else {
                enveloppedInnerOnionNode = new math.ParenthesisNode(innerOnionNode);
              }

              const layerNode_explicit = new math.OperatorNode(layerNode.op, layerNode.fn, [enveloppedInnerOnionNode, layerTerminalNode]);

              outMathNode = layerNode_explicit;
            }

          }

        }

      }

      return outMathNode;
    }

    // //debug
    // {
    //   const debugNode = random_mathNode_withDepth_and_nbSymbols(4, 2);
    //   console.log("debugNode(4,2)", debugNode);
    //   console.log("getDepth(debugNode)", getDepth(debugNode));
    // }





    function random_operatorNode_consumePool(pool) {

    }





    /*UTILS*/

    function getDepth(mathNode) {
      var outInt;

      switch (mathNode.type) {
        case "OperatorNode":
          {
            const arr_child_node = mathNode.args;
            const arr_child_node_depth = arr_child_node.map(node => getDepth(node));
            const max_child_depth = Math.max(...arr_child_node_depth);
            outInt = 1 + max_child_depth;
          }
          break;
        default:
          outInt = 1;
          break;
      }

      console.log("outInt", outInt);
      return outInt;
    }

    function getArr_all_leaves__node(mathNode) {
      var outArray;

      switch (mathNode.type) {
        case "OperatorNode":
          {
            const depth = getDepth(mathNode);
            if (depth == 2) {
              const arr_child = mathNode.args;
              outArray = arr_child;
            } else {
              outArray = mathNode.args.reduce((acc, child) => {
                const arr_grandChild = child.args;

                var arr_grandChild_sorted_by_decreasing_depth = arr_grandChild.slice();
                arr_grandChild_sorted_by_decreasing_depth.sort(function (a, b) {
                  const depth_a = getDepth(a);
                  const depth_b = getDepth(b);

                  if (depth_a > depth_b) {
                    return 1;
                  }
                  if (depth_a < depth_b) {
                    return -1;
                  }
                  return 0;
                });

                arr_grandChild_sorted_by_decreasing_depth.forEach((grandChild, i) => {
                  const arr_sub = getArr_all_leaves__node(grandChild);
                  console.log("arr_sub", arr_sub);
                  acc.push(...arr_sub);
                });

                return acc;

              }, []);
            }
          }
          break;
        default:
          outArray = [mathNode];
          break;
      }

      return outArray;
    }

    function getArr_all_leaves__treeObj(mathNode, parentPath = []) {
      var outArray;

      switch (mathNode.type) {
        case "OperatorNode":
          {
            const depth = getDepth(mathNode);
            if (depth == 2) {
              const arr_child = mathNode.args;
              outArray = arr_child.map((child, childIndex) => {
                const treeObj = {
                  node: child,
                  path: parentPath.concat([childIndex]),
                };
                return treeObj;
              });
            } else {
              outArray = mathNode.args.reduce((acc, child, childIndex) => {
                const arr_grandChild = child.args;

                var arr_grandChild_sorted_by_decreasing_depth = arr_grandChild.slice();
                arr_grandChild_sorted_by_decreasing_depth.sort(function (a, b) {
                  const depth_a = getDepth(a);
                  const depth_b = getDepth(b);

                  if (depth_a > depth_b) {
                    return 1;
                  }
                  if (depth_a < depth_b) {
                    return -1;
                  }
                  return 0;
                });

                arr_grandChild_sorted_by_decreasing_depth.forEach((grandChild, grandChildIndex) => {
                  const path = parentPath.concat([childIndex, grandChildIndex]);
                  const arr_sub = getArr_all_leaves__treeObj(grandChild, path);
                  console.log("arr_sub", arr_sub);
                  acc.push(...arr_sub);
                });

                return acc;

              }, []);
            }
          }
          break;
        default:
          const treeObj = {
            node: mathNode,
            path: parentPath/*.concat([0])*/,
          };
          outArray = [treeObj];
          break;
      }

      return outArray;
    }

    function getArr_all_nodes_at_depth(mathNode, depth) {
      var outArray;

      if (depth < 1) {
        throw new Error("depth must be > 1");
      } else if (depth == 1) {
        outArray = [mathNode];
      } else {
        const arr_child = mathNode.args;

        outArray = arr_child.reduce((acc, child) => {
          const arr_nodes__one_deeper = getArr_all_nodes_at_depth(child, depth - 1);

          acc.push(...arr_nodes__one_deeper);

          return acc;
        }, []);
      }

      return outArray;
    }

    function getArr_deep_first__treeObj(mathNode, parentPath = []) {
      var outArray;

      const depth = getDepth(mathNode);
      const arr_depth__increasing = [...new Array(depth).keys()].map(i => i + 1);
      const arr_depth__decreasing = arr_depth__increasing.slice().reverse();

      outArray = arr_depth__decreasing.reduce((acc, depth) => {

        const arr_all_treeObj_at_depth = getArr_all_treeObj_at_depth(mathNode, depth, parentPath);
        acc.push(...arr_all_treeObj_at_depth);

        return acc;
      }, []);

      return outArray;
    }

    function getArr_all_treeObj_at_depth(mathNode, depth, parentPath = []) {
      var outArray;

      if (depth < 1) {
        throw new Error("depth must be > 1");
      } else if (depth == 1) {
        const treeObj = {
          node: mathNode,
          path: parentPath,
        };
        outArray = [treeObj];
      } else {
        var arr_child = mathNode.args;

        if (arr_child == null) {
          arr_child = [];
        }

        outArray = arr_child.reduce((acc, child, childIndex) => {
          const child_path = parentPath.concat(childIndex);
          const arr_treeObj__one_deeper = getArr_all_treeObj_at_depth(child, depth - 1, child_path);

          acc.push(...arr_treeObj__one_deeper);

          return acc;
        }, []);

      }

      return outArray;
    }


    function getArr_deep_first__treeObj(mathNode, parentPath = []) {
      var outArray;

      const depth = getDepth(mathNode);
      const arr_depth__increasing = [...new Array(depth).keys()].map(i => i + 1);
      const arr_depth__decreasing = arr_depth__increasing.slice().reverse();

      outArray = arr_depth__decreasing.reduce((acc, depth) => {

        const arr_all_treeObj_at_depth = getArr_all_treeObj_at_depth(mathNode, depth);
        acc.push(...arr_all_treeObj_at_depth);

        return acc;
      }, []);

      return outArray;
    }





    function operatorNodeBySettingNodeAtPath(operatorNode_in, node_l, path) {
      var outOperatorNode;

      const operatorNode_cloned = operatorNode_in.clone();
      // const operatorNode_cloned = operatorNode_in.cloneDeep();

      //get target inner parentNode
      const path__all_but_last = path.slice(0, -1);
      const targetParentNode = path__all_but_last.reduce((acc, x) => {
        return acc.args[x];
      }, operatorNode_cloned);

      //mutate target inner parentNode
      const path__last = path[path.length - 1];
      targetParentNode.args[path__last] = node_l;

      outOperatorNode = operatorNode_cloned;

      return outOperatorNode;
    }

      // //debug
      // {
      //   const debugNode = random_mathNode_withDepth_and_nbSymbols(4, 2);
      //   console.log("debugNode(4,2)", debugNode);
      //   console.log("getDepth(debugNode)", getDepth(debugNode));
      //   console.log("getArr_all_leaves__node(debugNode)", getArr_all_leaves__node(debugNode));
      // }

  </script>
  <script>
    /*
    class InverseNode extends math.Node {   //ClassicInverseNode
      constructor(node_in) {

      }
    }
    math.InverseNode = InverseNode;                 //SHU: pas obligé mais pourquoi pas
    */

    class Inverser {
      static inverse(mathNode) {
        var outMathNode;

        switch (mathNode.type) {
          case "ConstantNode":
          case "SymbolNode":
            {
              const mathNode_ONE = new math.ConstantNode(1);
              const mathNode_clone = mathNode.cloneDeep();
              outMathNode = new math.OperatorNode("/", "divide", [mathNode_ONE, mathNode_clone]);
            }
            break;

          case "OperatorNode":
            {
              const operatorNode = mathNode;
              switch (operatorNode.fn) {
                case "divide":
                  {
                    const mathNode_firstArg = operatorNode.args[0];
                    if (mathNode_firstArg.type == "ConstantNode" && mathNode_firstArg.value == 1) {
                      //'simplification'
                      const mathNode_secondArg_clone = operatorNode.args[1].cloneDeep();
                      outMathNode = mathNode_secondArg_clone;
                    } else {
                      const mathNode_clone = mathNode.cloneDeep();
                      mathNode_clone.args = mathNode_clone.args.slice().reverse();
                      outMathNode = mathNode_clone;
                    }
                  }
                  break;
                default:
                  {
                    const mathNode_ONE = new math.ConstantNode(1);
                    const mathNode_clone = mathNode.cloneDeep();
                    outMathNode = new math.OperatorNode("/", "divide", [mathNode_ONE, mathNode_clone]);
                  }
                  break;
              }
            }
            break;
          case "ParenthesisNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;


          //maybe one day
          case "BlockNode":
          case "ObjectNode":
          case "ConditionalNode":
          case "FunctionNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;

          case "ArrayNode":
          case "AssignmentNode":
          case "FunctionAssignmentNode":
          case "RelationalNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;

          default:
            throw new Error("unsupported type: " + mathNode.type);
            break;
        }

        return outMathNode;
      }


      static opposite(mathNode) {
        var outMathNode;

        switch (mathNode.type) {
          case "ConstantNode":
          case "SymbolNode":
            {
              const mathNode_ZERO = new math.ConstantNode(0);
              const mathNode_clone = mathNode.cloneDeep();
              outMathNode = new math.OperatorNode("-", "subtract", [mathNode_ZERO, mathNode_clone]);
            }
            break;

          case "OperatorNode":
            {
              const operatorNode = mathNode;
              switch (operatorNode.fn) {
                case "subtract":
                  {
                    const mathNode_firstArg = operatorNode.args[0];
                    if (mathNode_firstArg.type == "ConstantNode" && mathNode_firstArg.value == 0) {
                      //'simplification'
                      const mathNode_secondArg_clone = operatorNode.args[1].cloneDeep();
                      outMathNode = mathNode_secondArg_clone;
                    } else {
                      const mathNode_clone = mathNode.cloneDeep();
                      mathNode_clone.args = mathNode_clone.args.slice().reverse();
                      outMathNode = mathNode_clone;
                    }
                  }
                  break;
                default:
                  {
                    const mathNode_ZERO = new math.ConstantNode(0);
                    const mathNode_clone = mathNode.cloneDeep();
                    outMathNode = new math.OperatorNode("-", "subtract", [mathNode_ZERO, mathNode_clone]);
                  }
                  break;
              }
            }
            break;
          case "ParenthesisNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;


          //maybe one day
          case "BlockNode":
          case "ObjectNode":
          case "ConditionalNode":
          case "FunctionNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;

          case "ArrayNode":
          case "AssignmentNode":
          case "FunctionAssignmentNode":
          case "RelationalNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;

          default:
            throw new Error("unsupported type: " + mathNode.type);
            break;
        }

        return outMathNode;
      }

    }

    /*
    class GeneralInverseOperatorDuo extends math.OperatorNode {
      constructor(, )
    }
    math.GeneralInverseNode = GeneralInverseNode;


    class GeneralInverseNode extends math.OperatorNode {
      constructor(operatorDuo, node) {

      }
    }
    math.GeneralInverseNode = GeneralInverseNode;
    */


    class Simplifier {

      constructor() {

      }

      static simplify_top_layer(node_in) {
        var outNode;

        if (node_in.type == "OperatorNode") {

          const depth = getDepth(node_in);

          if (depth > 2) {
            console.log("___st A");

            //'outermost first' simplify

            const operator__layerN = node_in;
            const arr_child__layerN = operator__layerN.args;
            var terminal__layerN = arr_child__layerN.filter(child => Simplifier.isTerminalType(child)).find(e => true);
            terminal__layerN = Simplifier.getTerminalMathNode(terminal__layerN);

            const operator__layerN_minus_1 = arr_child__layerN.filter(child => (child.type == "OperatorNode")).find(e => true);
            const arr_child__layerN_minus_1 = operator__layerN_minus_1.args;
            // const terminal__layerN_minus_1      = arr_child__layerN_minus_1.filter(child => isTerminalType(child)).find(e => true);
            var arr_terminal__layerN_minus_1 = arr_child__layerN_minus_1.filter(child => Simplifier.isTerminalType(child));
            arr_terminal__layerN_minus_1 = arr_terminal__layerN_minus_1.map(mathNode => Simplifier.getTerminalMathNode(mathNode));

            const sameTerminal = arr_terminal__layerN_minus_1.find(term__layerN_minus_1 => Simplifier.isSameTerminal(terminal__layerN, term__layerN_minus_1));
            if (!sameTerminal) {
              return node_in;
            }

            const isInverseOperators_ = Simplifier.isInverseOperators(operator__layerN_minus_1, operator__layerN);
            console.log("isInverseOperators_", isInverseOperators_);
            if (!isInverseOperators_) {
              return node_in;
            }

            const node__layerN_minus_2 = arr_child__layerN_minus_1.filter(child => child != sameTerminal).find(e => true);

            //remove parentheses if any
            // if(node__layerN_minus_2.type == "ParenthesisNode") {
            //   const contentNode = node__layerN_minus_2.content;
            //   outNode = contentNode;
            // } else {
            //   outNode = node__layerN_minus_2;
            // }

            outNode = node__layerN_minus_2;

          } else {
            console.log("___st B");

            //simple simplify

            const node_unsimplified = node_in;

            const node_simplified = math.simplify(node_unsimplified);
            node_simplified.isSimplified = true;

            outNode = node_simplified;

          }

        } else {
          console.log("___st C");
          logger.log("node_in", node_in);

          //simple simplify

          const node_unsimplified = node_in;

          const node_simplified = math.simplify(node_unsimplified);   //SHU: boom
          node_simplified.isSimplified = true;

          outNode = node_simplified;

        }

        outNode.autoSimplify = node_in.autoSimplify;

        return outNode;
      }

      static isOne(mathNode) {
        return Simplifier.isOne_strict(mathNode) || Simplifier.isOne_wide(mathNode);
      }

      static isOne_strict(mathNode) {
        return (mathNode.type == "ConstantNode") && (mathNode.value == 1);
      }

      static isOne_wide(mathNode) {
        // return (mathNode.type == "ConstantNode") && (mathNode.value == 1);
        return false;
      }

      static isZero_strict(mathNode) {
        return (mathNode.type == "ConstantNode") && (mathNode.value == 0);
      }

      static simplify_singleOperatorize_topPriorityShell(mathNode) {
        var outMathNode;

        logger.log("simplify_singleOperatorize_topPriorityShell", mathNode);

        switch (mathNode.type) {
          case "OperatorNode":
            {
              const operatorNode = mathNode;

              // if(operatorFn == "multiply") {
              switch (operatorNode.fn) {
                case "multiply":
                  {
                    //1. transform children
                    const arr_child = operatorNode.args.map(mathNode_child => Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_child));

                    //2. merge (~aggregate, ~flatten)
                    const arr_child2 = arr_child.reduce((acc, x) => {

                      switch (x.type) {
                        case "OperatorNode":
                          {
                            switch (x.fn) {
                              case "multiply":
                                {
                                  acc.push(...x.args);
                                }
                                break;
                              default:
                                acc.push(x);
                                break;
                            }
                          }
                          break;
                        default:
                          acc.push(x);
                          break;
                      }

                      return acc;
                    }, []);

                    //3. filter out ONEs
                    const arr_child3 = arr_child2.filter(mathNode => {
                      const isOne = Simplifier.isOne(mathNode);
                      return !isOne;
                    });

                    if (arr_child3.length > 1) {
                      outMathNode = new math.OperatorNode("x", "multiply", arr_child3);
                    } else {
                      outMathNode = arr_child3.find(e => true);
                    }

                  }
                  break;
                case "divide":
                  {
                    // const mathNode_firstArg = operatorNode.args[0];
                    // if(mathNode_firstArg.type == "ConstantNode" && mathNode_firstArg.value == 1) {
                    //   //'simplification'
                    //   const mathNode_secondArg_clone = operatorNode.args[1].cloneDeep();
                    //   outMathNode = mathNode_secondArg_clone;
                    // } else {
                    //   const mathNode_clone = mathNode.cloneDeep();
                    //   mathNode_clone.args = mathNode_clone.args.slice().reverse();
                    //   outMathNode = mathNode_clone;
                    // }


                    //1. transform children
                    //transform numerator   (left side)
                    const mathNode_numerator = operatorNode.args[0];
                    const mathNode_numerator_transformed = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_numerator);
                    //transform denominator (right side)
                    const mathNode_denominator = operatorNode.args[1];
                    const mathNode_denominator_transformed = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_denominator);

                    //2.transform into multiplication
                    var arr_mathNode_denominator;
                    switch (mathNode_denominator_transformed.type) {
                      case "OperatorNode":
                        {
                          const operatorNode = mathNode_denominator_transformed;
                          switch (operatorNode.fn) {
                            case "multiply":
                              {
                                arr_mathNode_denominator = operatorNode.args;
                              }
                              break;
                            default:
                              {
                                arr_mathNode_denominator = [mathNode_denominator_transformed];
                              }
                              break;
                          }
                        }
                        break;
                      default:
                        {
                          arr_mathNode_denominator = [mathNode_denominator_transformed];
                        }
                        break;
                    }

                    const arr_factor = [mathNode_numerator_transformed, ...arr_mathNode_denominator.map(Inverser.inverse)];

                    outMathNode = new math.OperatorNode("x", "multiply", arr_factor);

                  }
                  break;

                case "add":
                  {
                    //1. transform children
                    const arr_child = operatorNode.args.map(mathNode_child => Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_child));

                    //2. merge (~aggregate, ~flatten)
                    const arr_child2 = arr_child.reduce((acc, x) => {

                      switch (x.type) {
                        case "OperatorNode":
                          {
                            switch (x.fn) {
                              case "add":
                                {
                                  acc.push(...x.args);
                                }
                                break;
                              default:
                                acc.push(x);
                                break;
                            }
                          }
                          break;
                        default:
                          acc.push(x);
                          break;
                      }

                      return acc;
                    }, []);

                    //3. filter out ZEROs
                    const arr_child3 = arr_child2.filter(mathNode => {
                      const isZero = Simplifier.isZero_strict(mathNode);
                      return !isZero;
                    });

                    if (arr_child3.length > 1) {
                      outMathNode = new math.OperatorNode("+", "add", arr_child3);
                    } else {
                      outMathNode = arr_child3.find(e => true);
                    }
                  }
                  break;

                case "subtract":
                  {
                    //1. transform children
                    //transform diminuend (left side)
                    const mathNode_diminuend = operatorNode.args[0];
                    const mathNode_diminuend_transformed = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_diminuend);
                    //transform diminutor (right side)
                    const mathNode_diminutor = operatorNode.args[1];
                    const mathNode_diminutor_transformed = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_diminutor);

                    //2.transform into addition
                    var arr_mathNode_diminutor;
                    switch (mathNode_diminutor_transformed.type) {
                      case "OperatorNode":
                        {
                          const operatorNode = mathNode_diminutor_transformed;
                          switch (operatorNode.fn) {
                            case "add":
                              {
                                arr_mathNode_diminutor = operatorNode.args;
                              }
                              break;
                            default:
                              {
                                arr_mathNode_diminutor = [mathNode_diminutor_transformed];
                              }
                              break;
                          }
                        }
                        break;
                      default:
                        {
                          arr_mathNode_diminutor = [mathNode_diminutor_transformed];
                        }
                        break;
                    }

                    const arr_actor = [mathNode_diminuend_transformed, ...arr_mathNode_diminutor.map(Inverser.opposite)];

                    outMathNode = new math.OperatorNode("+", "add", arr_actor);
                  }
                  break;

                default:
                  outMathNode = mathNode;
                  break;
              }
              // } else {
              //   throw new Error("unsupported operatorFn: " + operatorFn);
              // }

            }
            break;
          case "ParenthesisNode":
            {
              const parenthesisNode = mathNode;
              //check content
              const mathNode__content = parenthesisNode.content;
              outMathNode = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode__content);
            }
            break;
          default:
            outMathNode = mathNode;
            break;
        }

        return outMathNode;
      }


      static isConstant(mathNode) {
        return (mathNode.type == "ConstantNode");
      }

      static isConstantOrInverse(mathNode) {
        return Simplifier.isConstant(mathNode) || Simplifier.isInverse(mathNode);
      }

      static isInverse(mathNode) {
        var outBool;

        const isDivide = (mathNode.type == "OperatorNode") && (mathNode.fn == "divide");
        if (isDivide) {
          const mathNode_numerator = mathNode.args[0];
          const isNumeratorOne = Simplifier.isOne_strict(mathNode_numerator);

          const mathNode_denominator = mathNode.args[1];
          const isDenominatorConstant = Simplifier.isConstant(mathNode_denominator);

          outBool = isNumeratorOne && isDenominatorConstant;
        } else {
          outBool = false;
        }

        return outBool;
      }

      static isConstantOrOpposite(mathNode) {
        return Simplifier.isConstant(mathNode) || Simplifier.isOpposite(mathNode);
      }

      static isOpposite(mathNode) {
        var outBool;

        const isSubtract = (mathNode.type == "OperatorNode") && (mathNode.fn == "subtract");
        if (isSubtract) {
          const mathNode_diminuend = mathNode.args[0];
          const isDiminuendZero = Simplifier.isZero_strict(mathNode_diminuend);

          const mathNode_diminutor = mathNode.args[1];
          const isDiminutorConstant = Simplifier.isConstant(mathNode_diminutor);

          outBool = isDiminuendZero && isDiminutorConstant;
        } else {
          outBool = false;
        }

        return outBool;
      }


      static simplify_top_priorityShell(node_in) {
        var outNode;

        logger.log("simplify_top_priorityShell", node_in);

        const mathNode = node_in;

        //1. singleOperatorize
        const node_singleOperatorized = Simplifier.simplify_singleOperatorize_topPriorityShell(node_in);
        logger.log("node_singleOperatorized", node_singleOperatorized);

        switch (node_singleOperatorized.type) {
          case "OperatorNode":
            {
              // const depth = getDepth(node_w);
              // if(depth > 2) {

              switch (node_singleOperatorized.fn) {
                case "multiply":
                  {

                    //2. look for inverse matches : count plus and minus
                    const arr_mathNode_factor_all = node_singleOperatorized.args;
                    logger.log("arr_mathNode_factor_all", arr_mathNode_factor_all);

                    if (arr_mathNode_factor_all == null) {     //SHU: the downfall
                      return mathNode;
                    }
                    if (arr_mathNode_factor_all.length < 2) {
                      return mathNode;
                    }

                    const obj_factors = arr_mathNode_factor_all.reduce((acc, mathNode_factor, index) => {

                      var value;
                      var multiplicity;

                      const isConstantOrInverse = Simplifier.isConstantOrInverse(mathNode_factor);
                      if (isConstantOrInverse) {

                        const isInverse = (mathNode_factor.type == "OperatorNode") && (mathNode_factor.fn == "divide");
                        if (isInverse) {
                          const mathNode_inverse = mathNode_factor;
                          const mathNode_denominator = mathNode_inverse.args[1];
                          const mathNode_averse = mathNode_denominator;
                          value = mathNode_averse.value;
                          multiplicity = -1;
                        } else {
                          const mathNode_averse = mathNode_factor;
                          value = mathNode_averse.value;
                          multiplicity = +1;
                        }

                        const valueStr = "" + value;

                        if (acc.portion_valued[valueStr] == null) {
                          acc.portion_valued[valueStr] = 0;
                        }

                        acc.portion_valued[valueStr] += multiplicity;

                      } else {
                        acc.portion_indexed[index] = mathNode_factor;
                      }

                      return acc;
                    }, {
                      portion_valued: {},
                      portion_indexed: {},
                    });
                    logger.log("obj_factors", obj_factors);   //SHU: acc[value] stringifies value

                    const arr_mathNode_factor_simplified = Object.entries(obj_factors.portion_valued)
                      .filter(([valueStr, multiplicity]) => multiplicity != 0)
                      .map(([valueStr, multiplicity]) => {
                        var outArr;

                        logger.log("valueStr, multiplicity", valueStr, multiplicity);

                        const value = Number(valueStr);

                        const multiplicity_abs = math.abs(multiplicity);

                        if (multiplicity > 0) {
                          outArr = [...Array(multiplicity_abs).keys()].map(index => {
                            const mathNode_averse = new math.ConstantNode(value);
                            return mathNode_averse;
                          });
                        } else {
                          outArr = [...Array(multiplicity_abs).keys()].map(index => {
                            const mathNode_averse = new math.ConstantNode(value);
                            const mathNode_inverse = Inverser.inverse(mathNode_averse);
                            return mathNode_inverse;
                          });
                        }

                        return outArr;
                      })
                      .flat();
                    logger.log("arr_mathNode_factor_simplified", arr_mathNode_factor_simplified);


                    const arr_mathNode_factor_simplified_merged = [...arr_mathNode_factor_simplified, ...Object.values(obj_factors.portion_indexed)];
                    logger.log("arr_mathNode_factor_simplified_merged", arr_mathNode_factor_simplified_merged);


                    const nb_factors = arr_mathNode_factor_simplified_merged.length;
                    if (nb_factors == 0) {
                      outNode = new math.ConstantNode(1);
                    } else if (nb_factors == 1) {
                      const mathNode_a = arr_mathNode_factor_simplified_merged.find(e => true);
                      outNode = mathNode_a;
                    } else {
                      outNode = new math.OperatorNode("x", "multiply", arr_mathNode_factor_simplified_merged);
                    }

                  }
                  break;

                case "add":
                  {

                    //2. look for inverse matches : count plus and minus
                    const arr_mathNode_actor_all = node_singleOperatorized.args;
                    logger.log("arr_mathNode_actor_all", arr_mathNode_actor_all);

                    if (arr_mathNode_actor_all == null) {
                      return mathNode;
                    }
                    if (arr_mathNode_actor_all.length < 2) {
                      return mathNode;
                    }

                    const obj_actors = arr_mathNode_actor_all.reduce((acc, mathNode_actor, index) => {

                      var value;
                      var multiplicity;

                      const isConstantOrOpposite = Simplifier.isConstantOrOpposite(mathNode_actor);
                      if (isConstantOrOpposite) {

                        const isOpposite = (mathNode_actor.type == "OperatorNode") && (mathNode_actor.fn == "subtract");
                        if (isOpposite) {
                          const mathNode_opposite = mathNode_actor;
                          const mathNode_diminutor = mathNode_opposite.args[1];
                          const mathNode_averse = mathNode_diminutor;
                          value = mathNode_averse.value;
                          multiplicity = -1;
                        } else {
                          const mathNode_averse = mathNode_actor;
                          value = mathNode_averse.value;
                          multiplicity = +1;
                        }

                        const valueStr = "" + value;

                        if (acc.portion_valued[valueStr] == null) {
                          acc.portion_valued[valueStr] = 0;
                        }

                        acc.portion_valued[valueStr] += multiplicity;

                      } else {
                        acc.portion_indexed[index] = mathNode_actor;
                      }

                      return acc;
                    }, {
                      portion_valued: {},
                      portion_indexed: {},
                    });
                    logger.log("obj_actors", obj_actors);   //SHU: acc[value] stringifies value

                    const arr_mathNode_actor_simplified = Object.entries(obj_actors.portion_valued)
                      .filter(([valueStr, multiplicity]) => multiplicity != 0)
                      .map(([valueStr, multiplicity]) => {
                        var outArr;

                        logger.log("valueStr, multiplicity", valueStr, multiplicity);

                        const value = Number(valueStr);

                        const multiplicity_abs = math.abs(multiplicity);

                        if (multiplicity > 0) {
                          outArr = [...Array(multiplicity_abs).keys()].map(index => {
                            const mathNode_averse = new math.ConstantNode(value);
                            return mathNode_averse;
                          });
                        } else {
                          outArr = [...Array(multiplicity_abs).keys()].map(index => {
                            const mathNode_averse = new math.ConstantNode(value);
                            const mathNode_opposite = Inverser.opposite(mathNode_averse);
                            return mathNode_opposite;
                          });
                        }

                        return outArr;
                      })
                      .flat();
                    logger.log("arr_mathNode_actor_simplified", arr_mathNode_actor_simplified);


                    const arr_mathNode_actor_simplified_merged = [...arr_mathNode_actor_simplified, ...Object.values(obj_actors.portion_indexed)];
                    logger.log("arr_mathNode_actor_simplified_merged", arr_mathNode_actor_simplified_merged);


                    const nb_actors = arr_mathNode_actor_simplified_merged.length;
                    if (nb_actors == 0) {
                      outNode = new math.ConstantNode(0);
                    } else if (nb_actors == 1) {
                      const mathNode_a = arr_mathNode_actor_simplified_merged.find(e => true);
                      outNode = mathNode_a;
                    } else {
                      outNode = new math.OperatorNode("+", "add", arr_mathNode_actor_simplified_merged);
                    }

                  }
                  break;

                default:
                  outNode = node_singleOperatorized;
                  break;

                // } else {
                //   // throw new Error("depth <= 2");
                //   outNode = node_singleOperatorized;
                // }
              }

            }
            break;
          case "ParenthesisNode":
            {
              const parenthesisNode = mathNode;
              const contentNode = parenthesisNode.content;
              outNode = Simplifier.simplify_top_priorityShell(contentNode);
            }
            break;
          default:
            outNode = mathNode;
            break;
        }

        outNode.autoSimplify = node_in.autoSimplify;

        return outNode;
      }

      static simplify_fraction_into_product(mathNode_fraction) {
        var outMathNode;

        outMathNode = Rewriter.decomposition_product_primes(mathNode_fraction);
        outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);

        return outMathNode;
      }

      static simplify_fraction(mathNode_fraction) {
        var outMathNode;

        // outMathNode = Rewriter.decomposition_product_primes(mathNode_fraction);
        // outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);
        // outMathNode = math.simplify(outMathNode);

        //SHU: ou plus simplement ---___---
        outMathNode = math.simplify(mathNode_fraction);

        return outMathNode;
      }

      static simplify_litexp(mathNode_litexp) {
        var outMathNode;

        outMathNode = mathNode_litexp;

        // outMathNode = Rewriter.decomposition_product_primes_and_symbols(outMathNode);
        // outMathNode = Simplifier.simplify_fraction(outMathNode);
        // outMathNode = Simplifier.simplify_singleOperatorize_topPriorityShell(outMathNode);

        var isSimplifiedFully = false;
        while (!isSimplifiedFully) {
          const mathNode__prev = outMathNode;
          outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);
          const mathNode__new = outMathNode;
          const str__prev = mathNode__prev.toString();
          const str__new = mathNode__new.toString();
          isSimplifiedFully = (str__prev == str__new);
        }

        outMathNode = Rewriter.removeUnnecessaryOnesInLitexp(outMathNode);
        outMathNode = math.simplify(outMathNode);

        return outMathNode;
      }

      static simplify_equation(mathNode_equation) {
        var outMathNode;

        logger.log("math.simplify.rules", math.simplify.rules);
        logger.log("math.simplify.rules[0].toString()", math.simplify.rules[0].toString());
        logger.log("math.simplify.rules[16].toString()", math.simplify.rules[16].toString());

        function simplify_child(mathNode_child) {
          return Simplifier.simplify_litexp(mathNode_child);
        }

        outMathNode = mathNode_equation.clone();
        outMathNode.params = outMathNode.params.map((mathNode_child, i) => {
          return simplify_child(mathNode_child);
        });

        return outMathNode;
      }


      static simplify_full(mathNode) { //SHU: TODO
        var outMathNode;

        //1. transform was is likely to be a binary tree into a nary tree with [+] and [x] as nary operators and [opposite] and [inverse] as unary operators (([0 -] and [1 /]))

        //2. simplify (== look for opposite matches) from bottom to top, as much as needed

        throw new Error("Not implemented yet");
        return outMathNode;
      }

      static isTerminalType(mathNode) {
        var outBool;

        const type = mathNode.type;

        switch (type) {
          case "ConstantNode":
          case "SymbolNode":
            outBool = true;
            break;
          case "ParenthesisNode":
            {
              //check content
              const mathNode__content = mathNode.content;
              outBool = isTerminalType(mathNode__content);
            }
            break;
          default:
            outBool = false;
            break;
        }

        return outBool;
      }

      static getTerminalMathNode(mathNode) {
        var outMathNode;

        const type = mathNode.type;

        switch (type) {
          case "ConstantNode":
          case "SymbolNode":
            outMathNode = mathNode;
            break;
          case "ParenthesisNode":
            {
              //check content
              const mathNode__content = mathNode.content;
              outMathNode = getTerminalMathNode(mathNode__content);
            }
            break;
          default:
            // outMathNode = null;
            throw new Error("no terminal node to fetch");
            break;
        }

        return outMathNode;
      }

      static isSameTerminal(termNode1, termNode2) {
        var outBool;

        function isSameTerminalType(termNode1, termNode2) {
          return (termNode1.type == termNode2.type);
        }

        const isSameTerminalType_ = isSameTerminalType(termNode1, termNode2);
        console.log("isSameTerminalType_", isSameTerminalType_);

        if (!isSameTerminalType_) {
          return false;                 //j'aime pas trop ça mais bon...
        }

        function isSameTerminalContent(termNode1, termNode2) {
          console.log("isSameTerminal", termNode1, termNode2);
          var outBool;

          switch (termNode1.type) {
            case "SymbolNode":
              outBool = (termNode1.name == termNode2.name);
              break;
            case "ConstantNode":
              outBool = (termNode1.value == termNode2.value);
              break;
            default:
              throw new Error("unsupported type", termNode1.type);
              break;
          }

          return outBool;
        }

        outBool = isSameTerminalContent(termNode1, termNode2);

        return outBool;
      }

      static isInverseOperators(opNode1, opNode2) {
        console.log("isInverseOperators", opNode1, opNode2);
        var outBool;

        const set_opFunc = new Set([opNode1.fn, opNode2.fn]);
        console.log("set_opFunc", set_opFunc);

        /*Set utils*/
        function eqSet(as, bs) {
          return as.size === bs.size && all(isIn(bs), as);
        }

        function all(pred, as) {
          for (var a of as) if (!pred(a)) return false;
          return true;
        }

        function isIn(as) {
          return function (a) {
            return as.has(a);
          };
        }
        /**/



        const arr_set_inverse = [
          new Set(["multiply", "divide"]),
          new Set(["add", "subtract"]),
        ];

        outBool = arr_set_inverse.reduce((acc, x) => {
          if (eqSet(set_opFunc, x)) {
            acc = true;
          }
          return acc;
        }, false);

        return outBool;
      }


      static simplify_level1(mathNode) {
        var outMathNode;

        //0. check if candidate (== legitimate operand)
        switch (mathNode) {
          case "OperatorNode":
            break;
          case "ParenthesisNode":
            const mathNode__content = mathNode.content;
            const mathNode__result = Simplifier.simplify_level1(mathNode__content);
            const mathNode__paren = mathNode.clone();
            mathNode__paren.content = mathNode__result;
            return mathNode__paren;
          default:
            //ignore
            return mathNode;        //SHU: un return dans un switch ! hahaha
        }

        const operatorNode = mathNode;

        //1. get level1 node(s) with lower depth
        const dict_arrForDepth = operatorNode.args.reduce((acc, mathNode_child) => {
          const depth = getDepth(mathNode_child);
          if (acc[depth] == null) {
            acc[depth] = [];
          }
          acc[depth].push(mathNode_child);
          return acc;
        }, {});

        //temporarily: work only with depth 1
        const arr_depth1 = dict_arrForDepth[1];
        if (arr_depth1 == null) {
          return mathNode;
        }

        //2. try to find inverse wrt mathNode fn
        const mathNode_slasher = null;
        const mathNode_victim = null;

        return outMathNode;
      }

      static simplify_level1_recursively(mathNode) {
        var outMathNode;



        return outMathNode;
      }

    }





  </script>
  <script>
    class Rewriter {

      constructor() {

      }

      static decomposition_product_primes(mathNode) {
        var outNode;

        switch (mathNode.type) {
          case "ConstantNode":
            const value = mathNode.value;
            const arr_values = MathUtils.primeFactorization(value);

            // const joinreduce = function(joinFunc, )
            const value_first = arr_values[0];
            const arr_butfirst = arr_values.slice(1);
            const mathNode_initial = new math.ConstantNode(value_first);
            outNode = arr_butfirst.reduce((acc, x) => {
              const mathNode_arg2 = new math.ConstantNode(x);
              return new math.OperatorNode("×lol×", "multiply", [acc, mathNode_arg2]);
            }, mathNode_initial);

            break;
          case "OperatorNode":
            const operatorNode = mathNode;
            logger.log("operatorNode", operatorNode);
            // switch(operatorNode.op) {
            //   case "/":
            //   break;
            // }
            outNode = new math.OperatorNode(operatorNode.op, operatorNode.fn, operatorNode.args.map(Rewriter.decomposition_product_primes));
            break;
          default:
            throw new Error("unsupported type: " + mathNode.type);
            break;
        }

        return outNode;
      }


      static decomposition_product_primes_and_symbols(mathNode) {
        var outNode;

        switch (mathNode.type) {
          case "ConstantNode":
            const value = mathNode.value;
            const arr_values = MathUtils.primeFactorization(value);

            // const joinreduce = function(joinFunc, )
            const value_first = arr_values[0];
            const arr_butfirst = arr_values.slice(1);
            const mathNode_initial = new math.ConstantNode(value_first);
            outNode = arr_butfirst.reduce((acc, x) => {
              const mathNode_arg2 = new math.ConstantNode(x);
              return new math.OperatorNode("×lol×", "multiply", [acc, mathNode_arg2]);
            }, mathNode_initial);

            break;
          case "OperatorNode":
            const operatorNode = mathNode;
            logger.log("operatorNode", operatorNode);
            // switch(operatorNode.op) {
            //   case "/":
            //   break;
            // }
            outNode = new math.OperatorNode(operatorNode.op, operatorNode.fn, operatorNode.args.map(Rewriter.decomposition_product_primes_and_symbols));

            break;
          case "SymbolNode":
            outNode = mathNode;
            break;

          default:
            throw new Error("unsupported type: " + mathNode.type);
            break;
        }

        return outNode;
      }

      static removeUnnecessaryOnesInLitexp(mathNode_litexp) {
        var outMathNode;

        const rules = [
          "1 * n1 -> n1",
          "n1 * 1 -> n1",
        ];

        outMathNode = math.simplify(mathNode_litexp, rules);

        return outMathNode;
      }

    }
  </script>



  <script>
    class Splitter {

      constructor() {

      }

      static split_top_layer(mathNode) {
        var outArr;

        switch (mathNode.type) {
          case "OperatorNode":
            {
              const arr_args = mathNode.args;

              // const operatorNode__nude = mathNode.clone();
              // operatorNode__nude.args = [];
              //
              // outArr = [...arr_args, operatorNode__nude];

              const symbolNode__operator = new math.SymbolNode(mathNode.op);
              outArr = [symbolNode__operator, ...arr_args];
            }
            break;
          case "ParenthesisNode":
            {
              const symbolNode__operator = new math.SymbolNode("()");
              outArr = [symbolNode__operator, mathNode.content];

              // const symbolNode__operatorOpen  = new math.SymbolNode("(");
              // const symbolNode__operatorClose = new math.SymbolNode(")");
              // outArr = [symbolNode__operatorOpen, mathNode.content, symbolNode__operatorClose];
            }
            break;
          default:
            outArr = [mathNode];
            break;
        }

        return outArr;
      }

      static split_full(mathNode) {
        var outArr;

        const arr_components = Splitter.split_top_layer(mathNode);
        if (arr_components.length > 1) {
          outArr = arr_components.reduce((acc, x) => {
            const arr_mathNode = Splitter.split_full(x);
            acc.push(...arr_mathNode);
            return acc;
          }, []);
        } else {
          outArr = arr_components;
        }

        return outArr;
      }

      static geometry__fireworks(center, nb_sparks) {
        var outGeometryObj;


        return outGeometryObj;
      }



      static split_string(str_in) {
        var outArr;

        outArr = str_in.split("");

        return outArr;
      }

    }

  </script>
  <script>
    class Joiner {
      constructor() {

      }

      /**
      *   create a mathNode using all mathNodes in arr_mathNode
      */
      static random_join(arr_mathNode) {
        var outMathNode;

        const nb_max_try = 1000;

        var found = false;
        var nb_try = 0;
        //ugly brute            //SHU: sometimes, one can be proud of one's hideousness
        while (!found && nb_try < nb_max_try) {
          try {
            const join_workz = Joiner.random_join_workz(arr_mathNode, true);
            outMathNode = join_workz.output;
            found = true;
          }
          catch (e) {
            logger.log(e);
            found = false;
          }
          nb_try += 1;
        }

        if (!found) {
          outMathNode = new math.SymbolNode("error");
        }

        // logger.log("outMathNode", outMathNode);

        return outMathNode;
      }

      // static random_join_workz(arr_mathNode, isExhaustive = false) {
      //   logger.log("random_join_workz", arr_mathNode);
      //   var outWorkz;
      //
      //   outWorkz = {
      //     output:   null,
      //     arr_rest: [],
      //   };
      //
      //   var isTerminal;
      //   if(isExhaustive) {
      //     const isOneNodeArray = (arr_mathNode.length == 1);
      //     isTerminal = isOneNodeArray;
      //   } else {
      //     //randomly terminal
      //     const random_boolean = Math.random() < 0.5;
      //     isTerminal = random_boolean;
      //   }
      //
      //
      //   if(isTerminal) {
      //     //get a terminal node
      //     const arr_terminalNode     = arr_mathNode.filter(mathNode => {
      //       const isConstantNode       = (mathNode.type == "ConstantNode");
      //       const isTerminalSymbolNode = (mathNode.type == "SymbolNode") && (Joiner.filter_operatorSymbols([mathNode]).length == 0);
      //       return isConstantNode || isTerminalSymbolNode;
      //     });
      //     Utils.shuffle(arr_terminalNode);
      //
      //     const terminalNode = arr_terminalNode.find(e => true);
      //
      //     outWorkz.output   = terminalNode;
      //     outWorkz.arr_rest = arr_mathNode.filter(mathNode => mathNode != terminalNode);
      //
      //   } else {
      //     //1. get an operator
      //     const arr_symbolNode       = Joiner.filter_operatorSymbols(arr_mathNode);
      //     Utils.shuffle(arr_symbolNode);
      //
      //     const symbolNode__operator = arr_symbolNode.find(e => true);
      //     logger.log("symbolNode__operator", symbolNode__operator);
      //
      //     const arr_mathNode_rest    = arr_mathNode.filter(mathNode => mathNode != symbolNode__operator);
      //
      //     //2. get operands
      //     const nb_operands = 2;
      //     const obj_operands = [...new Array(nb_operands).keys()].reduce((acc, x, index) => {
      //       const arr_component__before = acc.arr_component;
      //
      //       const isExhaustive = (index == (nb_operands - 1));
      //       const join_workz = Joiner.random_join_workz(arr_component__before, isExhaustive);
      //
      //       acc.arr_component = join_workz.arr_rest;
      //       const mathNode__operand = join_workz.output;
      //       acc.arr_out.push(mathNode__operand);
      //
      //       return acc;
      //     }, {
      //       arr_component: arr_mathNode_rest,
      //       arr_out: [],
      //     });
      //
      //     const operatorNode = Joiner.operatorNodeForOperatorSymbolNode(symbolNode__operator);
      //     operatorNode.args = obj_operands.arr_out;
      //     logger.log("operatorNode")
      //
      //     outWorkz.output   = operatorNode;
      //     outWorkz.arr_rest = obj_operands.arr_component;
      //   }
      //
      //   return outWorkz;
      // }

      static random_join_workz(arr_mathNode, isExhaustive = false) {
        logger.log("random_join_workz", arr_mathNode);
        var outWorkz;

        outWorkz = {
          output: null,
          arr_rest: [],
        };

        var isTerminal;
        if (isExhaustive) {
          const isOneNodeArray = (arr_mathNode.length == 1);
          isTerminal = isOneNodeArray;
        } else {
          //randomly terminal
          const random_boolean = Math.random() < 0.5;
          isTerminal = random_boolean;
        }


        if (isTerminal) {
          //get a terminal node
          const arr_terminalNode = arr_mathNode.filter(mathNode => {
            const isConstantNode = (mathNode.type == "ConstantNode");
            const isTerminalSymbolNode = (mathNode.type == "SymbolNode") && (Joiner.filter_operatorSymbols([mathNode]).length == 0);
            return isConstantNode || isTerminalSymbolNode;
          });
          Utils.shuffle(arr_terminalNode);

          const terminalNode = arr_terminalNode.find(e => true);

          outWorkz.output = terminalNode;
          outWorkz.arr_rest = arr_mathNode.filter(mathNode => mathNode != terminalNode);

        } else {
          //1. get an operator
          const arr_symbolNode = Joiner.filter_operatorSymbols(arr_mathNode);
          Utils.shuffle(arr_symbolNode);

          const symbolNode__operator = arr_symbolNode.find(e => true);
          logger.log("symbolNode__operator", symbolNode__operator);

          const arr_mathNode_rest = arr_mathNode.filter(mathNode => mathNode != symbolNode__operator);

          const specializedNode = Joiner.specializedNodeForSymbolNode(symbolNode__operator);

          //2. get operands
          const nb_operands = Joiner.arityForSymbolNode(symbolNode__operator);
          const obj_operands = [...new Array(nb_operands).keys()].reduce((acc, x, index) => {
            const arr_component__before = acc.arr_component;

            const isExhaustive = (index == (nb_operands - 1));
            const join_workz = Joiner.random_join_workz(arr_component__before, isExhaustive);

            acc.arr_component = join_workz.arr_rest;
            const mathNode__operand = join_workz.output;
            acc.arr_out.push(mathNode__operand);

            return acc;
          }, {
            arr_component: arr_mathNode_rest,
            arr_out: [],
          });

          const arr_operands = obj_operands.arr_out;

          switch (specializedNode.type) {
            case "ParenthesisNode":
              const parenthesisNode = specializedNode;
              const contentNode = arr_operands.find(e => true);
              parenthesisNode.content = contentNode;
              break;
            case "OperatorNode":
              const operatorNode = specializedNode;
              operatorNode.args = arr_operands;
              break;
            default:
              throw new Error("unsupported specializedNode type : " + specializedNode.type);
              break;
          }

          logger.log("operatorNode")

          outWorkz.output = specializedNode;
          outWorkz.arr_rest = obj_operands.arr_component;
        }

        return outWorkz;
      }


      static filter_operatorSymbols(arr_mathNode) {
        var outArr;

        function isOperatorSymbolNode(symbolNode) {
          var outBool;

          switch (symbolNode.name) {
            case "+":
            case "-":
            case "×":
            case "/":
              outBool = true;
              break;

            case "()":
              outBool = true;
              break;

            default:
              outBool = false;
              break;
          }

          return outBool;
        }

        outArr = arr_mathNode
          .filter(mathNode => (mathNode.type == "SymbolNode"))
          .filter(isOperatorSymbolNode);

        return outArr;
      }

      static operatorNodeForOperatorSymbolNode(symbolNode) {
        var outOperatorNode;

        const op = symbolNode.name;

        var funcName;
        switch (op) {
          case "+":
            funcName = "add";
            break;
          case "-":
            funcName = "subtract";
            break;
          case "×":
            funcName = "multiply";
            break;
          case "/":
            funcName = "divide";
            break;
          default:
            throw new Error("unsupported op symbol : " + op);
            break;
        }

        outOperatorNode = new math.OperatorNode(op, funcName, []);

        return outOperatorNode;
      }

      static specializedNodeForSymbolNode(symbolNode) {
        var outSpecializedNode;

        const op = symbolNode.name;

        var funcName;
        switch (op) {
          case "+":
            funcName = "add";
            outSpecializedNode = new math.OperatorNode(op, funcName, []);
            break;
          case "-":
            funcName = "subtract";
            outSpecializedNode = new math.OperatorNode(op, funcName, []);
            break;
          case "×":
            funcName = "multiply";
            outSpecializedNode = new math.OperatorNode(op, funcName, []);
            break;
          case "/":
            funcName = "divide";
            outSpecializedNode = new math.OperatorNode(op, funcName, []);
            break;

          case "()":
            const mathNode__placeholder = new math.SymbolNode("placeholder");
            outSpecializedNode = new math.ParenthesisNode(mathNode__placeholder);   //SHU: ni propre, ni sale. Juste un peu dérangeant.
            break;

          default:
            throw new Error("unsupported op symbol : " + op);
            break;
        }

        return outSpecializedNode;
      }

      static arityForSymbolNode(symbolNode) {
        var outInt;

        const op = symbolNode.name;

        var funcName;
        switch (op) {
          case "+":
          case "-":
          case "×":
          case "/":
            outInt = 2;
            break;
          case "()":
            outInt = 1;
            break;
          default:
            throw new Error("unsupported op symbol : " + op);
            break;
        }

        return outInt;
      }

    }
  </script>
  <script>
    class MathUtils {

      static primeFactorization(number, result) {
        var result = (result || []);
        var root = Math.sqrt(number);
        var x = 2;

        if (number % x) {
          x = 3;

          while ((number % x) && ((x = (x + 2)) < root)) { }
        }

        x = (x <= root) ? x : number;

        result.push(x);

        return (x === number) ? result : MathUtils.primeFactorization((number / x), result);
      }

      static arr_prime(length) {
        var outArr = [];

        // return [...Array(length).keys()].map(index => )

        var nb_remaining = length;
        var running = 2;
        while (nb_remaining > 0) {
          if (math.isPrime(running)) {
            outArr.push(running);
            nb_remaining -= 1;
          }
          running += 1;
        }

        return outArr;
      }

      static arr_prime_in_range(range) {
        const span = range.max - range.min;
        return [...Array(span).keys()].map(index => index + range.min).filter(math.isPrime);
      }

      static randomPrimeInRange(range) {
        return;
      }

      static isFraction(mathNode) {
        var outBool;

        if (mathNode.type == "OperatorNode" && mathNode.fn == "divide") {

          const operatorNode = mathNode;

          const mathNode__numerator = operatorNode.args[0];
          const isTerminalNode__numerator = Simplifier.isTerminalType(mathNode__numerator);

          const mathNode__denominator = operatorNode.args[1];
          const isTerminalNode__denominator = Simplifier.isTerminalType(mathNode__denominator);

          outBool = isTerminalNode__numerator && isTerminalNode__denominator;

        } else {
          outBool = false;
        }

        return outBool;
      }

      static randomCartDictFromArr(arr_elts, nb, min_nb_families_in = 1, max_nb_families_in = -1) {
        var outDict;

        var min_nb_families = min_nb_families_in;
        if (min_nb_families <= 0) { min_nb_families = 1 };

        var max_nb_families = max_nb_families_in;
        if (max_nb_families == -1) {
          max_nb_families = arr_elts.length
        } else if (max_nb_families > arr_elts.length) {
          max_nb_families = arr_elts.length
        };

        const nb_families = math.randomInt(min_nb_families, max_nb_families + 1);
        const arr_families = Utils.randomSubArrWithArray(arr_elts, nb_families);
        // logger.log("arr_families", arr_families);

        outDict = [...Array(nb).keys()].reduce((acc, index) => {
          var currDict = acc;

          const index_random = Utils.randomElementInArray([...arr_families.keys()]);
          const elt = arr_families[index_random];
          // logger.log("elt", elt);

          var id;
          // if(elt.id != null) {
          //   id = elt.id;
          // } else {
          id = "obj_" + index_random;
          // }
          if (currDict[id] == null) {
            const miniDict = {
              obj: elt,
              nb: 0,
            };
            currDict[id] = miniDict;
          }

          currDict[id].nb += 1;

          return currDict;
        }, {});

        return outDict;
      }

      static randomCartArrFromArr(arr_elts, nb, min_families = -1, max_families = -1, isShuffled = false) {
        var outArr;

        const dict_cart = MathUtils.randomCartDictFromArr(arr_elts, nb, min_families, max_families);
        outArr = MathUtils.arrFromOccurenceDict(dict_cart);

        if (isShuffled) {
          const arr_cart__shuffled = Utils.shuffle([...outArr]);
          outArr = arr_cart__shuffled;
        }

        return outArr;
      }

      static arrFromOccurenceDict(dict_occurence) {
        var outArr;

        outArr = Object.entries(dict_occurence).reduce((acc, entry) => {
          const id = entry[0];

          const obj = entry[1].obj;
          const nb = entry[1].nb;

          return [...acc, ...([...Array(nb)].map(e => obj))];
        }, []);

        return outArr;
      }

      static arrOfPairs(arr) {
        var outArr;

        outArr = arr.reduce((acc, x, index) => {
          var outArr;
          const arr_index__tail = [...Array(arr.length).keys()].slice(index + 1);
          const arr_pairs = arr_index__tail.map(index_tail => [arr[index], arr[index_tail]]);
          outArr = [...acc, ...arr_pairs];
          return outArr;
        }, []);

        return outArr;
      }

      static arrOfPairs__indexes(arr) {
        var outArr;

        outArr = arr.reduce((acc, x, index) => {
          const arr_index__tail = [...Array(arr.length).keys()].slice(index + 1);
          const arr_pairs = arr_index__tail.map(index_tail => [index, index_tail]);
          return [...acc, ...arr_pairs];
        }, []);

        return outArr;
      }

    }
  </script>
  <script>
    //debug
    const arr_src = [...Array(20).keys()];

    const dict_cart = MathUtils.randomCartDictFromArr(arr_src, 10, 3, 6);
    logger.log("log1", "dict_cart", dict_cart);
    const arr_cart = MathUtils.randomCartArrFromArr(arr_src, 10, 3, 6);
    logger.log("log1", "arr_cart", arr_cart);

  </script>


  <!-- icObj transformation stuff -->
  <script>
    class Combiner {
      constructor() {

      }

      static combine(arr_icObj) {
        var outIcObj;


        return outIcObj;
      }

    }
  </script>
  <script>
    class TransformationOutput {

      constructor(type, value, from) {
        this.type = type;
        this.value = value;
        this.from = from;
      }

    }
  </script>
  <script>

    class RichMathNode {

      constructor(mathNode) {
        this.mathNode = mathNode;
        this.rich = {};
      }

      configure(config) {
        this.rich.colorMode = config.colorMode;
        this.rich.color = config.color;
      }

      toTex() {
        var outString;

        const colorMode = this.rich.colorMode;

        switch (colorMode) {
          case "xylophone":
            {
              if (this.mathNode.type == "ConstantNode") {
                const positionalNumber = new PositionalNumber(this.mathNode.value);
                outString = positionalNumber.toTex("xylophone");
              } else {
                throw new Error("colorMode:xylophone only compatible with ConstantNode");
              }
            }
            break;
          case "fullplain":
            {
              const color = this.rich.color;
              if (this.mathNode.type == "ConstantNode") {
                const positionalNumber = new PositionalNumber(this.mathNode.value);
                outString = positionalNumber.toTex(color);
              } else {
                throw new Error("colorMode:xylophone only compatible with ConstantNode");
              }
            }
            break;
          case "evenodd":
            {
              const color__even = "#FFFFFF";
              const color__odd = "#000000";

              var color;
              if (this.rich.isEven) {
                color = color__even;
              } else {
                color = color__odd;
              }

              const tex__mathNode = this.mathNode.toTex();
              outString = TexEnricher.color(tex__mathNode, color);
            }
            break;
          case "plain":
            {
              const tex__mathNode = this.mathNode.toTex();

              //color
              if (this.rich.color != null) {
                const color = this.rich.color;
                outString = TexEnricher.color(tex__mathNode, color);
              } else {
                throw new Error("no color specified for colorMode: " + colorMode);
              }

            }
            break;
          default:
            {
              const tex__mathNode = this.mathNode.toTex();
              outString = tex__mathNode;
            }
            // throw new Error("unknown colorMode: " + colorMode);
            break;
        }

        return outString;
      }

      clone() {
        return;
      }

    }

    class TexEnricher {

      static color(tex_in, color_in) {
        var outString;

        outString = "{\\color{" + color_in + "} " + tex_in + " }";

        return outString;
      }

      // static font(tex_in, font_in) {
      //   var outString;
      //
      //   outString = "{\\fontfamily{pag}\\selectfont " + tex_in  + "}";
      //
      //   return outString;
      // }

    }

    // class UnfoldedNumber {
    class PositionalNumber {

      constructor(number, base = 10) {
        this.arr_digit = ("" + number).split("").map(digitStr => parseInt(digitStr));
        this.base = base;
      }

      toTex(color) {
        var outString;

        outString = this.arr_digit.reduce((acc, x) => {
          acc += PositionalNumber.texForDigit(x, color);
          return acc;
        }, "");

        return outString;
      }

      static texForDigit(digit, color_in) {

        var outString;

        outString = "" + digit;

        var color = color_in;
        if (color == "xylophone") {


          if (digit == 0) {
            // outString = "{\\fbox {}}";
            // outString = "{\\fbox {?}}";
            // outString = "\\enspace";

            // outString = "{\\mbox {0}}";

            // outString = "▢";
            // outString = "▫";
            // outString = "☐";
            // outString = "𖡄";
            outString = "?";


            ///not working
            // outString = "{\\fbox {\\hspace{1cm}} }";

          } else {
            color = PositionalNumber.colorForDigit(digit);
          }

          outString = TexEnricher.color(outString, color);

        } else {
          outString = TexEnricher.color(outString, color);
        }

        return outString;
      }

      static colorForDigit(digit) {
        var outColor = null;

        switch (digit) {
          case 0:
            outColor = "#000000";
            break;

          case 1:
            outColor = "#FF7F0E";
            break;
          case 2:
            outColor = "#2CA02C";
            break;
          case 3:
            outColor = "#D62728";
            break;
          case 4:
            outColor = "#9467BD";
            break;
          case 5:
            outColor = "#8C564B";
            break;
          case 6:
            outColor = "#E377C2";
            break;
          case 7:
            outColor = "#7F7F7F";
            break;
          case 8:
            outColor = "#BCBD22";
            break;
          case 9:
            outColor = "#17BECF";
            break;

          //SHU TODO: colors or patterns for those:
          case 10:  //A
            outColor = "#000000";
            break;
          case 11:  //B
            outColor = "#000000";
            break;
          case 12:  //C
            outColor = "#000000";
            break;
          case 13:  //D
            outColor = "#000000";
            break;
          case 14:  //E
            outColor = "#000000";
            break;
          case 15:  //F
            outColor = "#000000";
            break;

          default:
            throw new Error("unsupported digit: " + digit);
        }

        return outColor;
      }



    }

  </script>






  <!-- UX -->
  <script type="text/javascript" src="lib/rxjs.umd.min.js"></script> <!-- for easy inner/outer copy|paste -->
  <script>
    const Rx = rxjs;
    const Rx_operators = rxjs.operators;

    const Subject = Rx.Subject;
    const ReplaySubject = Rx.ReplaySubject;
  </script>
  <!-- <script>
      //discovery
      const rx_debug__subject    = new Subject();
      const rx_debug__observable = rx_debug__subject.asObservable();
      const rx_debug__sub        = rx_debug__observable.subscribe({
        next: (value) => {
          console.log("value", value);
        },
      });
      rx_debug__subject.next(10);
      rx_debug__subject.next(100);
      rx_debug__subject.next(1000);
    </script> -->
  <script>//for easy html element observation

    function mutationCallback__debug(mutationsList, observer) {
      console.log(mutationsList);
      console.log(observer);
      for (const mutation of mutationsList) {
        if (mutation.type === 'childList') {
          console.log('A child node has been added or removed.');
        } else if (mutation.type === 'attributes') {
          console.log('The ' + mutation.attributeName + ' attribute was modified.');
        } else {
          console.log('mutation.type: ' + mutation.type);
          console.log('New value ' + JSON.stringify(mutation.target.data));
        }
      }
    }

    function createHtmlEltObserver(htmlElt) {

      // Observation medium
      const rx_subject__mutation = new Subject();

      function mutationCallback(mutationsList, observer) {
        console.log(mutationsList);
        console.log(observer);

        const mutation = mutationsList.find(e => true);

        switch (mutation.type) {
          case "childList":
            rx_subject__mutation.next(htmlElt);
            break;
          case "attributes":
            // /!\ .attr() != .prop()
            break;
          default:
            console.log('mutation.type: ' + mutation.type);
            console.log('New value ' + JSON.stringify(mutation.target.data));
            break;
        }

        // rx_subject__mutation.next(htmlElt);
      }

      // Create an observer instance linked to the callback function
      const observer = new MutationObserver(mutationCallback);
      observer.rx_observable__mutation = rx_subject__mutation.asObservable();

      // What to observe
      const mutationConfig = { attributes: true, childList: true, subtree: true, characterData: true };

      // Start observation
      observer.observe(htmlElt, mutationConfig);

      return observer;
    }

  </script>
  <!-- <script>
      //discovery

      document.addEventListener("DOMContentLoaded", function () {
        const htmlElt = document.getElementById("debug_nbObjects");
        const observer = createObserver(htmlElt);

        setTimeout(() => {
          htmlElt.innerHTML = 123456;
        }, 5000);

      });

    </script> -->



  <!-- information -->
  <!-- <script type="text/javascript" src="lib/serialize-javascript.browserified.main.js"></script> -->
  <script type="text/javascript" src="lib/serialize-javascript.browserified.bundle.js"></script>
  <script>
    // console.log("Bundle_SJ", Bundle_SJ);
    const serialize = Bundle_SJ.serialize;
    const deserialize = Bundle_SJ.deserialize;
  </script>
  <!-- <script>
      //discovery
      const sj__obj = {
        myFunc: (x) => x + 1,
      };
      const sj__serialized = serialize(sj__obj);
      console.log("serialize-javascript::sj__serialized", sj__serialized);
      const sj__deserialized = deserialize(sj__serialized);
      console.log("serialize-javascript::sj__deserialized", sj__deserialized);
      const sj__myFunc_result = sj__deserialized.myFunc(0);
      console.log("serialize-javascript::sj__myFunc_result", sj__myFunc_result);
    </script> -->

  <!-- <script type="text/javascript" src="lib/eventstore/eventstore.browserified.bundle.js"></script>
    <script>
      logger.log("Bundle_ES", Bundle_ES);
      const eventstore = Bundle_ES.eventstore;

      const es_options = {
        emitStoreEvents: false,
      };
      const es         = eventstore(es_options);
      logger.log("es", es);

      es.init(function (err) {
        // this callback is called when all is ready...
        logger.log("es.init", "done", es);
      });
    </script>
    <script>
      //discovery
      setTimeout(() => {

        es.defineEventMappings({
          id:             'id',
          commitId:       'commitId',
          commitSequence: 'commitSequence',
          commitStamp:    'commitStamp',
          streamRevision: 'streamRevision'
        });

        // es.commit({lol : "lol"});
        const event__0 = {
          id: 0,
        };
        const eventStream = [event__0];

        // const eventStream = new EventStream();
        // eventStream.addEvent(event__0);

        // es.addEventStream(eventStream);

        es.store.addEvents([event__0], (err) => {
          if(err != null) {
            logger.log("err", err);
          }
        });

      }, 1000);

    </script>
    <script type="text/javascript" src="lib/eventstore/eventstore-client.browserified.bundle.js"></script>
    <script>
      logger.log("Bundle_ESC", Bundle_ESC);
      const eventstoreClient = Bundle_ESC.eventstoreClient;

      const esc_options = {

      };
      const esc         = eventstoreClient(esc_options);
      logger.log("esc", esc);


    </script> -->


  <!-- <script type="text/javascript" src="lib/js-event-sourcing-example/bundle.js"></script>
    <script>

    </script>
    <script>
      //discovery


    </script> -->

  <!-- <script type="text/javascript" src="lib/coriolis/coriolis.browserified.bundle.js"></script>
    <script>
      logger.log("Bundle_CORIO", Bundle_CORIO);
      const coriolis = Bundle_CORIO.coriolis;

      // const eventStore = coriolis.createStore({});

    </script>
    <script>
      //discovery

      const projection__currentCount = ({ useState, useEvent }) => (
        useState(0),
        useEvent(),
        (state, event) => {
          switch (event.type) {
            case 'incremented':
              return state + 1

            case 'decremented':
              return state - 1

            default:
              return state
          }
        }
      );

      const eventStore = coriolis.createStore(({ withProjection, dispatch }) => {

        withProjection(projection__currentCount).subscribe((count) => logger.log(count));
        // 0

        dispatch({ type: 'incremented' });
        // 1

        dispatch({ type: 'incremented' });
        // 2

        dispatch({ type: 'decremented' });
        // 1
      });

      logger.log("eventStore", eventStore);

    </script> -->

  <script type="text/javascript" src="lib/uuid.browserified.bundle.js"></script>
  <script>
    logger.log("Bundle_UUID", Bundle_UUID);

    const uuidv4 = Bundle_UUID.uuidv4;
    const id__test = uuidv4();

    logger.log("id__test", id__test);

  </script>


  <script type="text/javascript" src="lib/jwt.browserified.bundle.js"></script>
  <script>
    logger.log("Bundle_JWT", Bundle_JWT);

    var counter__jwt = 0;
    const string__private = "lolilol";
    const getJwt = () => {
      counter__jwt = counter__jwt + 1;
      const token = Bundle_JWT.jwt.sign({ counter__jwt: counter__jwt }, string__private);
      return token;
    };

  </script>
  <!-- <script>
      //discovery
      const token = getJwt();
      logger.log("token", token);

      logger.log("getJwt()", getJwt());
      logger.log("getJwt()", getJwt());
    </script> -->

  <!-- <script type="text/javascript" src="lib/wolkenkit-eventstore/wolkenkit-eventstore.browserified.bundle.edited.js"></script> -->
  <script type="text/javascript" src="lib/wolkenkit-eventstore/wolkenkit-eventstore.browserified.bundle.js"></script>
  <script>
    logger.log("Bundle_WKES", Bundle_WKES);
    const Eventstore = Bundle_WKES.eventstore.Eventstore;
    const Event = Bundle_WKES.eventstore.Event;
    const Command = Bundle_WKES.eventstore.Command;
    // const EventEmitter = Bundle_WKES.eventstore.EventEmitter;

    const eventstore__global = new Eventstore();
    eventstore__global.initialize();
    logger.log("eventstore__global", eventstore__global);

    // const eventPublisher = new EventEmitter();
    const uuid__unknown = '123e4567-e89b-42d3-a456-426614174000';

    function readEventStream_p(eventStream) {
      logger.log("readEventStream_p", eventStream);

      return new Promise((resolve, reject) => {

        var arr_event = [];

        eventStream.on('readable', function () {
          // logger.log("eventStream.on('readable')");
          while ((evt = eventStream.read()) != null) {
            arr_event.push(evt);
          }
        });

        eventStream.on('end', function () {
          // logger.log("eventStream.on('end')");
          resolve(arr_event);
        });

      });

    };

  </script>
  <!-- <script>
      //discovery
      // eventstore__global.destroy();

      //create commands and events
      {
        const command = new Command({
          context: {
            name: 'network'
          },
          aggregate: {
            name: 'node',
            id: '85932442-bf87-472d-8b5a-b0eac3aa8be9'
          },
          name: 'ping',
          data: {
            ttl: 10 * 1000
          },
          custom: {
            sourceIp: '127.0.0.1'
          }
        });
        logger.log("command", command);

        const token = getJwt();
        logger.log("token.sub", token.sub());
        const initiator = {
          id: token.sub(),
        };
        command.addInitiator(initiator);

        const event = new Event({
          context: {
            name: 'network'
          },
          aggregate: {
            name: 'node',
            id: '85932442-bf87-472d-8b5a-b0eac3aa8be9'
          },
          name: 'pinged',
          data: {
            ttl: 10 * 1000
          },
          custom: {
            sourceIp: '127.0.0.1'
          },
          metadata: {
            correlationId: '13505cab-0ca2-4502-b8c9-8f3ce63ae390',
            causationId: '124885f3-d35e-43a6-84eb-e28c70b5be66'
          }
        });

        event.addInitiator(command.initiator);

      }

      //store event
      {

        const id__aggregate = '85932442-bf87-472d-8b5a-b0eac3aa8be9';

        const event__1 = new Event({
          context: {
            name: 'network'
          },
          aggregate: {
            name: 'node',
            id: id__aggregate,
          },
          name: 'pinged',
          data: {
            ttl: 10 * 1000
          },
          custom: {
            sourceIp: '127.0.0.1'
          },
          metadata: {
            correlationId: '13505cab-0ca2-4502-b8c9-8f3ce63ae390',
            causationId: '124885f3-d35e-43a6-84eb-e28c70b5be66'
          }
        });
        event__1.metadata.revision = 1;

        const event__2 = new Event({
          context: {
            name: 'network'
          },
          aggregate: {
            name: 'node',
            id: id__aggregate,
          },
          name: 'lolilol',
          data: {
            ttl: 10 * 1000
          },
          custom: {
            sourceIp: '127.0.0.1'
          },
          metadata: {
            correlationId: '13505cab-0ca2-4502-b8c9-8f3ce63ae390',
            causationId: '124885f3-d35e-43a6-84eb-e28c70b5be66'
          }
        });
        event__2.metadata.revision = 2;


        const arr_event__saved = eventstore__global.saveEvents({
          uncommittedEvents: [
            { event: event__1, state: {desc: "state1"} },
            { event: event__2, state: {desc: "state2"} }
          ]
        });

        const arr_event__stored = eventstore__global.getStoredEvents();
        logger.log("arr_event__stored", arr_event__stored);

        eventstore__global.getLastEvent(id__aggregate).then(event__last => {
          logger.log("event__last", event__last);
        });

        const eventStream_p = eventstore__global.getEventStream({aggregateId: id__aggregate});
        eventStream_p.then(readEventStream_p)
        .then(arr_event__eventStream => {
          logger.log("arr_event__eventStream", arr_event__eventStream);
        });

      }

      //store event again
      {

        const id__aggregate = uuidv4();
        // const id__aggregate = uuid__unknown;

        const id__correlation = uuidv4();
        const id__causation   = uuidv4();

        const event__3 = new Event({
          context: {
            name: 'ux'
          },
          aggregate: {
            name: 'node',
            id: id__aggregate,
          },
          name: 'grabbed',
          data: {},
          custom: {},
          metadata: {
            correlationId: id__correlation,
            causationId:   id__causation,
          }
        });
        event__3.metadata.revision = 1;

        const event__4 = new Event({
          context: {
            name: 'ux'
          },
          aggregate: {
            name: 'node',
            id: id__aggregate,
          },
          name: 'moved',
          data: {},
          custom: {},
          metadata: {
            correlationId: id__correlation,
            causationId:   id__causation
          }
        });
        event__4.metadata.revision = 2;


        const arr_event__saved = eventstore__global.saveEvents({
          uncommittedEvents: [
            { event: event__3, state: {desc: "state3"} },
            { event: event__4, state: {desc: "state4"} }
          ]
        });

        const arr_event__stored = eventstore__global.getStoredEvents();
        logger.log("arr_event__stored", arr_event__stored);

        eventstore__global.getLastEvent(id__aggregate).then(event__last => {
          logger.log("event__last", event__last);
        });

        const eventStream_p = eventstore__global.getEventStream({aggregateId: id__aggregate});
        eventStream_p.then(readEventStream_p)
        .then(arr_event__eventStream => {
          logger.log("arr_event__eventStream", arr_event__eventStream);
        });

      }



      //replay
      {
        const replayStream_p = eventstore__global.getReplay({
          // fromPosition: 7,
          // toPosition: 23
        });

        replayStream_p.then(readEventStream_p)
        .then(arr_event__replay => {
          logger.log("arr_event__replay", arr_event__replay);
        });

      }

    </script> -->

  <!-- <script type="text/javascript" src="lib/bluebird.min.js"></script> -->
  <script type="text/javascript" src="lib/bluebird.browserified.bundle.js"></script>
  <script>
    logger.log("Bundle_BBIRD", Bundle_BBIRD);

    const bluebird = Bundle_BBIRD.bluebird;
  </script>
  <!-- <script>
      //discovery
      const arr_promise = [...Array(10).keys()].map(index => {
        return bluebird.delay(index * 1000, index);
      });

      const sum_p = bluebird.reduce(arr_promise, (acc,x) => {
        logger.log("acc", acc);
        return acc + x;
      }, 0);

      sum_p.then(value => {
        logger.log("sum_p", value);
      });
    </script> -->


  <canvas id="myCanvas">Your browser does not support HTML5 canvas</canvas>
  <script>
    const canvas = document.getElementById("myCanvas");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  </script>


  <!-- debug -->
  <div id="debug_container" style="position:absolute; left:0; top: 0; font-size: 60px; pointer-events: none;">
    <div>
      <div style="display: inline-block;">current scale: </div>
      <div style="display: inline-block;" id="debug_scale"></div>
    </div>
    <div>
      <div style="display: inline-block;">offset: </div>
      <div style="display: inline-block;" id="debug_offset"></div>
    </div>
    <div>
      <div style="display: inline-block;">nb objects: </div>
      <div style="display: inline-block;" id="debug_nbObjects"></div>
    </div>
    <div>
      <div style="display: inline-block;">current object rect: </div>
      <div style="display: inline-block;" id="debug_currObjRect"></div>
    </div>
    <div>
      <div style="display: inline-block;">activeColor: </div>
      <div style="display: inline-block;" id="debug_activeColor">" "</div>
    </div>
  </div>

  <script>
    class Debug {
      constructor(eltsDict) {
        this.eltsDict = eltsDict;

        this.eltsDict["container"].style.visibility = "hidden";
      }

      setScale(scale) {
        this.eltsDict["scale"].innerHTML = JSON.stringify(scale);
      }
      setOffset(offset) {
        this.eltsDict["offset"].innerHTML = JSON.stringify(offset);
      }
      setNbObjects(nb_objects) {
        this.eltsDict["nb_objects"].innerHTML = nb_objects;
      }
      setCurrentObjectRect(current_object_rect) {
        this.eltsDict["current_object_rect"].innerHTML = JSON.stringify(current_object_rect);
      }

      setActiveColor(color) {
        this.eltsDict["active_color"].style.backgroundColor = color;
      }

    }

    const debugEltsDict = {
      container: document.getElementById("debug_container"),

      scale: document.getElementById("debug_scale"),
      offset: document.getElementById("debug_offset"),
      nb_objects: document.getElementById("debug_nbObjects"),
      current_object_rect: document.getElementById("debug_currObjRect"),

      active_color: document.getElementById("debug_activeColor"),
    };
    const debug = new Debug(debugEltsDict);

  </script>




  <script>

    /**** model  ****/

    const RedrawOccasion = {
      // "forceRedraw"   : 0,
      "forceRedraw": "forceRedraw",


      // "offsetChanged" : 10,
      "offsetChanged": "offsetChanged",
      // "scaleChanged"  : 11,
      "scaleChanged": "scaleChanged",
      "orientationChanged": "orientationChanged",


      // "objectAdded"   : 20,
      "objectAdded": "objectAdded",
      "pureObjectAdded": "pureObjectAdded",

      "objectRemoved": "objectRemoved",



      // "windowResize"  : 100,
      "windowResize": "windowResize",
    };


    class InfiniteCanvas {

      constructor(canvas, inputProperties) {

        this.canvas = canvas;
        this.inputProperties = inputProperties;

        //--properties

        this.coords_initial = {
          scale: {
            X: 1,
            Y: 1,
          },
          offset: {
            dx: 0,
            dy: 0,
          },
          orientation: 0,
        };

        // coordinates of our cursor
        this.cursor = {
          x: 0,
          y: 0,
        };
        this.previousCursor = Object.assign({}, this.cursor);


        // distance from origin
        this.offset = Object.assign({}, this.coords_initial.offset);
        this.previousOffset = Object.assign({}, this.offset);
        this.dOffset = {
          dx: 0,
          dy: 0,
        };

        // zoom amount
        this.scale = Object.assign({}, this.coords_initial.scale);

        this.orientation = this.coords_initial.orientation;

        this.didUpdateListeners = [];


        //--objects

        this.icObjects = {
          any: [],
        };
        this.didAddObjectListeners = [];

        this.pure_icObjects = {
          any: [],
        };
        this.didAddPureObjectListeners = [];

        this.creationManagers = {};



        this.represented = {};
        this.didAddRepresentedListeners = [];
        this.didRemoveRepresentedListeners = [];

        this.representations = {};
        this.didAddRepresentationListeners = [];


        this.didUpdateListenersDict = {
          // "objectAdded": [],
          "scaleChanged": [],
        };

        this.requestSyncWithIcObjListeners = [];

        this.icObjListeners = [];


        this.redrawCanvasListeners = [];
        this.setupRedrawConditions();

        this.counter = 0;


        this.configureInitialIcObjects();

        this.isZIndexEditing = false;


        this.counter__event = 1;  //shu: this starts at 1

        // this.isRecording = false;
        this.isRecording_subject = new Rx.BehaviorSubject(false);
        this.isRecording_observable = this.isRecording_subject.asObservable();
        this.rx_icEvent_subject = new Rx.Subject();
        this.rx_icEvent_observable = this.rx_icEvent_subject.asObservable();

        // this.isRecordingPathmade_subject    = new Rx.BehaviorSubject(false);
        // this.isRecordingPathmade_observable = this.isRecordingPathmade_subject.asObservable();

        this.rx_icPathmadeOperator_subject = new Rx.Subject();
        this.rx_icPathmadeOperator_observable = this.rx_icPathmadeOperator_subject.asObservable();



        this.index__counter = 1;


        //--track changes

        // this.lastChangeTimestamp = null;
        this.changed = false;



        var mySaveTimeout = null;

        const infiniteCanvas = this;
        window.addEventListener("beforeunload", (e) => {
          console.log("beforeunload", e);

          if (infiniteCanvas.changed /*&& !infiniteCanvas.leaveWithoutSaving*/) {

            const infiniteCanvas = this;
            const infinishute_p = this.createInfinishute_p();

            function userStaysOnPage() {
              infiniteCanvas.manageSaveInfinishute_p_2(infinishute_p);
            }

            setTimeout(function () {                   //the nested setTimeout is the working way :)
              mySaveTimeout = setTimeout(() => {
                userStaysOnPage();
              }, 100);
            }, 1);

          }

        });

        window.addEventListener('unload', function onUnload(e) {
          console.log("onUnload", e);
          clearTimeout(mySaveTimeout);
        });

      }
      get isRecording() {
        return this.isRecording_subject.value;
      }
      set isRecording(value) {
        this.isRecording_subject.next(value);
      }




      setChanged(changed) {
        //uncomment for promptWhenUnsavedChanges
        // this.changed = changed;
        this.changed = false;


        if (this.changed) {
          window.onbeforeunload = () => {
            return "You have unsaved changes;";
          };

        } else {
          window.onbeforeunload = null;
        }

      }

      //properties

      update(propName, newValue) {
        const oldValue = this[propName];
        this[propName] = newValue;
        this.didUpdate(propName, oldValue, newValue);
      }

      didUpdate(propName, oldValue, newValue) {
        this.didUpdateListeners.forEach((listener, i) => {
          listener(this, propName, oldValue, newValue);
        });
      }


      //objects
      //creation

      generateIcObjectId() {
        const id = this.counter;
        this.counter += 1;
        return id;
      }

      generateIcEventIndex() {
        const id = this.counter__event;
        this.counter__event += 1;
        return id;
      }

      createIcObject(type, position, size, homeScale) {

        const id = this.generateIcObjectId();

        const icObj = new IcObject(id, type, position, size, homeScale);
        return icObj;

        // return this.createRepresentedIcObject(icObj);
      }

      createRepresentedIcObject(icObj) {

        const icObj__represented = RepresentedFactory.initial(icObj);
        const icObj__rep_official = icObj__represented.r_official();

        const icObj__rep_free = icObj__represented.createNewRepresentation("free");
        icObj__rep_free.addInteraction_hold();

        if (icObj.type == "composite") {

          icObj__represented.parts = {};
          icObj__rep_official.parts = {};
          icObj__rep_free.parts = {};

          // icObj__represented.compositeConfig  = {};
          // icObj__rep_official.compositeConfig = {};
          // icObj__rep_free.compositeConfig     = {};


          // const parts = icObj.compositeConfig.parts;
          const parts = icObj.parts;

          Object.entries(parts)
            .forEach(([partName, part_icObj], i) => {

              const id_icObj = part_icObj.id;
              const represented_check = this.getRepresented(id_icObj);
              if (represented_check != null) {
                console.log("represented already added");

                // if(part_icObj.isMobile) {
                const part__represented = represented_check;
                const part__rep_official = part__represented.r_official();
                const part__rep_free = part__represented.r_free();
                // if(part__rep_free.holdListeners == null) {
                //   part__rep_free.addInteraction_hold();
                // }
                // }

                icObj__represented.parts[partName] = part__represented;
                icObj__rep_official.parts[partName] = part__rep_official;
                icObj__rep_free.parts[partName] = part__rep_free;
                // icObj__represented.compositeConfig.parts[partName]  = part__represented;
                // icObj__rep_official.compositeConfig.parts[partName] = part__rep_official;
                // icObj__rep_free.compositeConfig.parts[partName]     = part__rep_free;

              } else {

                const part__represented = this.createRepresentedIcObject(part_icObj);
                const part__rep_official = part__represented.r_official();
                const part__rep_free = part__represented.createNewRepresentation("free");
                if (part__rep_free.nowHeld == null) {
                  part__rep_free.addInteraction_hold();
                }

                icObj__represented.parts[partName] = part__represented;
                icObj__rep_official.parts[partName] = part__rep_official;
                icObj__rep_free.parts[partName] = part__rep_free;

              }

            });
        }

        return icObj__represented;
      }

      tetherIcObject(represented) {
        // logger.log("tetherIcObject", represented.r_official().id);

        const infiniteCanvas = this;

        // icObj.didUpdateListeners.push((icObj, requestCanvasRedraw) => {
        //   infiniteCanvas.manageIcObjUpdate(icObj, requestCanvasRedraw);
        // });

        //report updates
        const rep_official = represented.r_official();
        rep_official.onOuterUpdate((rep_official, updateDict) => {
          // console.log("rep_official", "onOuterUpdate", rep_official);
          infiniteCanvas.icObjDidUpdate(rep_official, updateDict);
        });

        //await object death
        const death_handler = (rep_official_incoming, outerUpdatesDict) => {
          // logger.log("death_handler", rep_official_incoming, outerUpdatesDict);

          const isDead = (outerUpdatesDict["im_dead_now"] != null) && (outerUpdatesDict["im_dead_now"].new == true);
          if (isDead) {
            const represented = rep_official_incoming.represented;
            // logger.log("isDead", represented.r_official().id);

            if (represented.r_official() != null) {  //SHU666: deeper into sadness
              var shouldAlsoRemoveChildren = represented.r_official().shouldAlsoRemoveChildren ? represented.r_official().shouldAlsoRemoveChildren : false;

              infiniteCanvas.removeRepresented(represented, shouldAlsoRemoveChildren);

              infiniteCanvas.offIcObjUpdate(death_handler);
            }

          }
        };
        infiniteCanvas.onIcObjUpdate(death_handler);


        //official rep follows free rep
        const rep_free = represented.r_free();
        rep_official.follow(rep_free);

      }

      untetherIcObject(represented) {
        const infiniteCanvas = this;

        const rep_official = represented.r_official();
        rep_official.offAllOuterUpdates();

        const rep_free = represented.r_free();
        rep_official.unfollow(rep_free);
      }





      introduceToExistingObjects(represented) {

        //introduce object to existing touchSlots
        this.introduceToExistingType_touchSlot(represented);

        const type__represented = represented.r_official().type;

        switch (type__represented) {
          case "touchSlot":
          case "dropTouchSlot":
            {
              //introduce touchslot to existing objects

              const touchSlot = represented.r_official();
              const id_touchSlot = touchSlot.id;

              const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());

              arr_official.forEach((rep_official, i) => {
                rep_official.touchStateDict[id_touchSlot] = TouchState.Untouched;
              });
            }
            break;
          default:
            break;
        }

      }

      introduceToExistingType_touchSlot(represented) {

        const rep_official__incoming = represented.r_official();

        // const existing_type = "touchSlot";

        const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
        // const arr_official_exisitingType = arr_official.filter(rep => (rep.type == existing_type));
        const arr_official_exisitingType = arr_official.filter(rep => {
          var outBool;

          outBool = (rep.type == "touchSlot") || (rep.type == "dropTouchSlot");

          return outBool;
        });

        arr_official_exisitingType.forEach((rep, i) => {

          const id_touchSlot = rep.id;

          if (rep_official__incoming.touchStateDict[id_touchSlot] == null) {
            rep_official__incoming.touchStateDict[id_touchSlot] = TouchState.Untouched;
          }
          //SHU TODO: check if touches

        });

      }

      extroduceFromExistingObjects(represented) {
        console.log("extroduceFromExistingObjects", represented);

      }




      getRepresented(id) {
        return this.represented[id];
      }

      getAllRepresentedWithType(type) {
        const arr_represented = Object.values(this.represented).filter(represented => {
          const rep_official = represented.r_official();
          const isRequestedType = (rep_official.type == type);
          return isRequestedType;
        });
        return arr_represented;
      }


      createIcRect_withLTWH(left, top, width, height) {

        const type = "rect";
        const position = Geometry.createPoint(left, top);
        const size = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;
      }

      createIcRect_withLTRB(left, top, right, bottom) {
        const width = right - left;
        const height = bottom - top;
        const icRect = this.createRect_withLTWH(left, top, width, height);

        return icRect;
      }

      createIcRect(trueRect) {

        const type = "rect";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;
      }

      createIcPoint(point) {
        logger.log("createIcPoint", point);

        const type     = "point";
        const position = Geometry.createPoint(point.x, point.y);
        const size     = Geometry.createSize(10, 10);
        // const size      = Geometry.createSize(1, 1);

        // const homeScale = null;   // exact geometry objects don't have a homeScale
        const homeScale = {X: 1, Y: 1};   // exact geometry objects don't have a homeScale


        const icObj = this.createIcObject(type, position, size, homeScale);

        const icPoint_spec = {
          isPoint: true,        //points have a particular relationship with position, size and scale
          isUsingCenterPosition: true,

          "color": "blue",
          "name": "A",

          "fillColor": "black",

          "fill": "orange",

          "pointType": "undefined",
        };

        const icPoint = Object.assign(icObj, icPoint_spec);

        return icPoint;

      }

      createIcSpotPoint(pointCenter, size_in) {
        logger.log("createIcSpotPoint", pointCenter, size_in);

        const type      = "spotPoint";
        const position  = Object.assign({}, pointCenter);
        const size      = Object.assign({}, size_in);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSpot_spec = {
          isUsingCenterPosition: true,

          "color": "blue",
          "name": "S",

          "fillColor": "black",
          "fill":      "lime",

          "viewType": "undefined",
        };

        const icSpot = Object.assign(icObj, icSpot_spec);

        return icSpot;
      }

      createIcHUDPoint(point) {
        logger.log("createIcHUDPoint", point);

        const type     = "HUD_point";
        const position = Geometry.createPoint(point.x, point.y);
        const size     = Geometry.createSize(0, 0);
        // const size      = Geometry.createSize(1, 1);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icPoint_spec = {
          isPoint: true,     //points have a particular relationship with position, size and scale
          isUsingCenterPosition: true,

          "color": "blue",
          "name": "A",

          "fillColor": "black",

          "fill": "orange",

          "pointType": "undefined",
        };

        const icPoint = Object.assign(icObj, icPoint_spec);

        return icPoint;

      }



      createIcCircle(pointCenter, radius, cfg_in = {}) {

        const type = "circle";
        // const position  = Geometry.createPoint(left, top);
        const size = Geometry.createSize(radius, radius);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, pointCenter, size, homeScale);


        const cfg_default = {
          isUsingCenterPosition: true,
          strokeWidth: 2,
          strokeColor: "red",
          fillColor: "blue",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icCircle_spec = {
          isUsingCenterPosition: cfg.isUsingCenterPosition,
          radius: radius,

          strokeWidth: cfg.strokeWidth,
          stroke: cfg.strokeColor,
          fill: cfg.fillColor,

          //add properties which specify circle can't be resizedX or resizedY
        };

        const icCircle = Object.assign(icObj, icCircle_spec);

        return icCircle;
      }

      createIcEllipse(trueRect, cfg_in = {}) {

        const type = "ellipse";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const cfg_default = {
          strokeColor: "magenta",
          fillColor: "cyan",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icEllipse_spec = {
          "stroke": cfg.strokeColor,
          "fill": cfg.fillColor,
        };

        const icEllipse = Object.assign(icObj, icEllipse_spec);

        return icEllipse;
      }

      createIcArcOfSquare(pointCenter, radius, angleInDegrees__start, angleInDegrees__end, cfg_in = {}) {  //arc = object + clipping path

        const type = "arc_of_square";
        //const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(2 * radius, 2 * radius);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, pointCenter, size, homeScale);

        const cfg_default = {
          strokeColor: "black",
          fillColor: "blanchedalmond",

          arcStart: angleInDegrees__start,
          arcEnd: angleInDegrees__end,
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icArcOfSquare_spec = {
          isUsingCenterPosition: true,

          squareCenter: pointCenter,
          radius: radius,

          "stroke": cfg.strokeColor,
          //"strokeWidth" : 0,

          "fill": cfg.fillColor,

          "arcStart": cfg.arcStart,
          "arcEnd": cfg.arcEnd,
        };

        const icArcOfSquare = Object.assign(icObj, icArcOfSquare_spec);

        return icArcOfSquare;
      }

      createIcArcOfCircle(pointCenter, radius, angleInDegrees__start, angleInDegrees__end, cfg_in = {}) {  //arc = object + clipping path

        const type = "arc_of_circle";
        //const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(radius, radius);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, pointCenter, size, homeScale);

        const cfg_default = {
          strokeColor: "orange",
          fillColor: "",

          arcStart: angleInDegrees__start,
          arcEnd: angleInDegrees__end,
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icCircle_spec = {
          isUsingCenterPosition: true,

          circleCenter: pointCenter,
          radius: radius,

          strokeWidth: cfg.strokeWidth,
          stroke: cfg.strokeColor,
          fill: cfg.fillColor,

          arcStart: cfg.arcStart,
          arcEnd: cfg.arcEnd,

          //add properties which specify circle can't be resizedX or resizedY
        };

        const icCircle = Object.assign(icObj, icCircle_spec);

        return icCircle;
      }

      createIcArcOfEllipse(trueRect, cfg_in = {}) {

        const type = "arc_of_ellipse";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const cfg_default = {
          strokeColor: "magenta",
          fillColor: "cyan",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icEllipse_spec = {
          "stroke": cfg.strokeColor,
          "fill": cfg.fillColor,
        };

        const icEllipse = Object.assign(icObj, icEllipse_spec);

        return icEllipse;
      }

      createIcSegmentedArcOfCircle(pointCenter, radius, cfg_in = {}) {  //arc = object + clipping path

        const type = "segmented_arc_of_circle";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const cfg_default = {
          strokeColor: "magenta",
          fillColor: "cyan",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icEllipse_spec = {
          "stroke": cfg.strokeColor,
          "fill": cfg.fillColor,
        };

        const icEllipse = Object.assign(icObj, icEllipse_spec);

        return icEllipse;
      }

      createIcSegmentedArcOfEllipse(trueRect, cfg_in = {}) {

        const type = "segmented_arc_of_ellipse";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const cfg_default = {
          strokeColor: "magenta",
          fillColor: "cyan",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icEllipse_spec = {
          "stroke": cfg.strokeColor,
          "fill": cfg.fillColor,
        };

        const icEllipse = Object.assign(icObj, icEllipse_spec);

        return icEllipse;
      }


      createIcPolygon(arr_point, cfg_in = null) {

        const type = "polygon";
        const rect__enveloppe = Geometry.getEnveloppeRect(arr_point);

        const position = Geometry.createPoint(rect__enveloppe.x, rect__enveloppe.y);
        const size = Geometry.createSize(rect__enveloppe.width, rect__enveloppe.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const cfg_default = {
          strokeColor: "red",
          fillColor: "blue",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icPolygon_spec = {
          arr_point: arr_point,

          "stroke": cfg.strokeColor,
          "fill": cfg.fillColor,
        };

        const icPolygon = Object.assign(icObj, icPolygon_spec);

        return icPolygon;
      }

      createIcHexagon(pointTL, length, cfg_in = null) {
        const arr_point = [
          Geometry.createPoint(pointTL.x + length * 0.5, pointTL.y + 0),
          Geometry.createPoint(pointTL.x + length * 1.5, pointTL.y + 0),
          Geometry.createPoint(pointTL.x + length * 2.0, pointTL.y + length * math.sqrt(3) / 2.0),
          Geometry.createPoint(pointTL.x + length * 1.5, pointTL.y + length * math.sqrt(3)),
          Geometry.createPoint(pointTL.x + length * 0.5, pointTL.y + length * math.sqrt(3)),
          Geometry.createPoint(pointTL.x + length * 0.0, pointTL.y + length * math.sqrt(3) / 2.0),
        ];

        const cfg_default = {
          strokeColor: "red",
          fillColor: "blue",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icPolygon = this.createIcPolygon(arr_point, cfg);

        return icPolygon;
      }

      createIcProgressMarker(trueRect, progress, cfg) { //bind progress outer object via cfg
        const infiniteCanvas = this;

        const pointCenter = Geometry.getCenterPoint(Geometry.createLTRect(trueRect));
        const strokeWidth = trueRect.width / 20;
        const radius = trueRect.width / 2 - strokeWidth / 2;

        const cfg_circle__bg = {
          strokeWidth: strokeWidth,
          strokeColor: "grey",
          fillColor: "",
        };
        const circle__bg = infiniteCanvas.createIcCircle(pointCenter, radius, cfg_circle__bg);
        const cfg_arc = {
          strokeWidth: strokeWidth,
          strokeColor: "gold",
          fillColor: "",
        };
        const arc = infiniteCanvas.createIcArcOfCircle(pointCenter, radius, 0, progress * 360, cfg_arc);

        var arr_point__crown = [
          Geometry.createPoint(0, 100),
          Geometry.createPoint(100, 150),
          Geometry.createPoint(250, 0),
          Geometry.createPoint(400, 150),
          Geometry.createPoint(500, 100),
          Geometry.createPoint(400, 400),
          Geometry.createPoint(100, 400),
        ];
        arr_point__crown = Geometry.getCenterScaledPolygon(arr_point__crown, 0.10);
        const point__src = Geometry.getCenterPoint(Geometry.createLTRect(Geometry.getEnveloppeRect(arr_point__crown)));
        const point__dst = Geometry.pointOnCircle__angleInDegrees(pointCenter, radius, 0);
        arr_point__crown = Geometry.getTranslatedPolygon(arr_point__crown, point__src, point__dst);

        const cfg__crown = {
          strokeColor: "grey",
          strokeWidth: 5,

          fillColor: "gold",
        };
        const crownSymbol = infiniteCanvas.createIcPolygon(arr_point__crown, cfg__crown);
        const facade = infiniteCanvas.createIcRect(Geometry.getCenterScaledRect(trueRect, 0.5));

        const parts = {
          "circle_bg": circle__bg,
          "arc": arc,
          "crownSymbol": crownSymbol,

          //"facade":      facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "progress_marker";

        //debug
        // const icObj = icComposite;
        // setTimeout(() => {
        //   const represented = infiniteCanvas.getRepresented(icObj.id);
        //   const rep_free    = represented.r_free();
        //
        //   // const progress = 0.9;
        //   // rep_free.progress = progress;
        //
        //   const arcStart = 40;
        //   const arcEnd   = 160;
        //   rep_free.parts.arc.arcStart = arcStart;
        //   rep_free.parts.arc.arcEnd   = arcEnd;
        //
        // }, 2000);

        return icComposite;
      }

      createIcProductOfPrimesDisk(pointCenter, number) {
        const infiniteCanvas = this;

        const mathNode__number = new math.ConstantNode(number);
        // const mathNode__prpr   = Rewriter.decomposition_product_primes(mathNode__number);
        const arr_values = MathUtils.primeFactorization(number);
        logger.log("arr_values", arr_values);
        const nb_factors = arr_values.length;

        const radius_full = 100;
        const strokeWidth = radius_full / 4;
        const radius = radius_full - strokeWidth / 2.0;

        const width = 2 * radius_full;
        const height = 2 * radius_full;
        const trueRect = Geometry.createCenteredXYRect(pointCenter, width, height);

        // const cfg_circle__bg = {
        //   strokeWidth: strokeWidth,
        //   strokeColor: "grey",
        //   fillColor: "",
        // };
        // const circle__bg  = infiniteCanvas.createIcCircle(pointCenter, radius, cfg_circle__bg);

        function colorForPrime(number) {
          const dict_color = {
            2: "orange",
            3: "green",
            5: "blue",
            7: "violet",
          };
          const color_default = "red";
          if (!math.isPrime(number)) {
            throw new Error("number must be a prime number");
          }
          const color = dict_color[number] ? dict_color[number] : color_default;
          return color;
        }

        function angleStartForSector(index_sector, nb_sectors) {
          return 360 * index_sector / nb_sectors;
        }

        function angleEndForSector(index_sector, nb_sectors) {
          return 360 * (index_sector + 1) / nb_sectors; //- 0.05;
        }

        function arcForPrimeNumber(number, index_sector, nb_sectors) {

          const color = colorForPrime(number);

          const cfg_arc = {
            strokeWidth: strokeWidth,
            strokeColor: color,
            fillColor: "",
          };
          const angleStart = angleStartForSector(index_sector, nb_sectors);
          const angleEnd = angleEndForSector(index_sector, nb_sectors);
          const arc = infiniteCanvas.createIcArcOfCircle(pointCenter, radius, angleStart, angleEnd, cfg_arc);
          return arc;
        }

        const arr_arc = arr_values.map((number, index) => {
          const arc = arcForPrimeNumber(number, index, nb_factors);
          return arc;
        });
        const arr_entries = arr_arc.map((arc, index) => {
          const name = "sector_" + index;
          return [name, arc];
        });
        const dict_sector = Object.fromEntries(arr_entries);

        var parts = {};
        parts = Object.assign(parts, dict_sector);

        // const facade      = infiniteCanvas.createIcMathNode(x,y,mathNode);
        // parts.facade = facade;

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "product_of_primes";

        return icComposite;
      }


      createIcText(left, top, text) {

        const type = "text";
        const position = Geometry.createPoint(left, top);
        const size = Geometry.createSize(0, 0);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        // const text     = "icText";
        const fontSize = 100;

        const icText_spec = {
          text: text,
          textColor: "black",
          fontSize: fontSize,
        };

        const icText = Object.assign(icObj, icText_spec);

        icText.addInteraction_edit();

        //SHU123
        // //add collection
        // function collectionCreation_textChangeListener(icObj) {
        //
        // }
        // icText.onEditExit(collectionCreation_textChangeListener);
        // rep_free.onEditExit(collectionCreation_textChangeListener);

        return icText;
      }

      createIcImage(left, top, img_in) {
        const type = "image";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        var img;
        if (img_in != null) {
          img = img_in;
        } else {
          const width__default = 100;
          const height__default = 100;
          img = new Image(width__default, height__default);

          logger.log("log1", "img", img);
        }

        const icImage_spec = {
          img: img,
          force_width: false,
          force_height: false,
        };

        const icImage = Object.assign(icObj, icImage_spec);

        return icImage;
      }

      createIcVideo(left, top, video_in) {
        const type = "video";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        var video;
        if (video_in != null) {
          video = video_in;
        } else {
          const width__default = 100;
          const height__default = 100;
          video = document.createElement('video');

          logger.log("log1", "video", video);
        }

        const icVideo_spec = {
          video: video,
          img: null,
          force_width: false,
          force_height: false,
        };

        const icVideo = Object.assign(icObj, icVideo_spec);

        ImageUtils.imageFromVideo_p(video).then((img) => {
          Object.assign(icObj, { img: img });
        });

        class VideoEngine {
          constructor() {

            this.initialized = false;

            this.initialize = function (scopeObj) {

              //"wake up":
              //bind all funcs
              // function isFunction(functionToCheck) {
              //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
              // }
              const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

              this.awoken = {
                'i_am': "awoken",
              };
              console.log("this.virgin", this.virgin);
              Object.entries(this.virgin)
                .filter(([propName, prop]) => isFunction(prop))
                .forEach(([propName, prop], i) => {
                  this.awoken[propName] = prop.bind(this.awoken);
                });

              // this.scopeObj  = scopeObj;
              //engineCarrier,
              //infiniteCanvas,
              this.awoken.scopeObj = scopeObj;

              this.initialized = true;
            }

            // this.r_official_update_handler2 = function(rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions
            //
            //   // logger.log("r_official_update_handler2", rep_official_incoming);
            //
            //   // console.log("engine::r_official_update_handler2, this", this);
            //   // console.log("this.scopeObj", this.scopeObj);
            //
            // };

            this.start = function () {
              console.log("engine::start, this", this);
              logger.log("dropTouchSlotEngine::start", "this.scopeObj", this.scopeObj);
              const infiniteCanvas = this.scopeObj.infiniteCanvas;
              const icVideo = this.scopeObj.engineCarrier;

              {
                function startRefreshLoop() {
                  logger.log("log1", "startRefreshLoop");

                  /// get context from canvas (canvas not shown in example)
                  var ctx = canvas.getContext('2d');

                  var counter = 1;                  /// this is used to reduce FPS

                  /// register refresh loop
                  function refreshLoop() {

                    const represented = infiniteCanvas.getRepresented(icVideo.id);
                    // console.log("represented", represented);
                    const rep_official = represented.r_official();
                    const rep_free = represented.r_free();

                    const video = icVideo.video;


                    /// reduce frame-rate
                    const nb_skipped_frames__video = 0;
                    if (counter % (nb_skipped_frames__video + 1) == 0) {
                      setNewFrame();
                      counter = 1;
                    } else {
                      counter = counter + 1;
                    }

                    if (icObj.isShouldRequestAnimationFrame) {
                      requestAnimationFrame(refreshLoop);
                    }


                    function setNewFrame() {
                      // logger.log("log1", "setNewFrame");

                      ImageUtils.imageFromVideo_p(video).then((img) => {
                        rep_free.img = img;
                      });

                    }

                  }

                  icObj.isShouldRequestAnimationFrame = true;
                  icObj.requestAnimationFrame = requestAnimationFrame(refreshLoop);

                }

                startRefreshLoop();

              }

            };

            this.stop = function () {
              // delete this.scopeObj;
            };


            this.virgin = Object.assign({}, this);  //virgin == not bound

          }
        }

        //TBD: play on click/shift-click
        // const video = icVideo.video;
        video.play();

        const engine = new VideoEngine();
        const eType = "video";
        const icEngined = infiniteCanvas.installEngineOnIcObj(icVideo, eType, engine);

        return icEngined;
      }

      getFrameFromVideo_p(video) {

        const html_elt = video;

        const canvasElt_p = html2canvas(html_elt, {
          // onclone: function (clone__htmlElt) {
          // clone__htmlElt.style.visibility = "visible";
          // clone__htmlElt.style.display = "block";
          // },
        });

        const fObj_hmtlElt_image_p = canvasElt_p.then((canvasElt) => {

          function getNumericalValueForPxString(pxString) {
            return parseInt(pxString.replace("px", ""));
          }

          const width__canvasElt = getNumericalValueForPxString(canvasElt.style.width);
          const height__canvasElt = getNumericalValueForPxString(canvasElt.style.height);

          const img = new fabric.Image(canvasElt);

          const group = fObj;
          img.set({
            // left: 0,
            // top: 0,
            //SHU: that smell of Scotch Tape
            left: -group.width / 2,
            top: -group.height / 2,

            //debug
            // stroke: "yellow",
            // strokeWidth: 2,
          });

          return img;

          return canvasElt;
        });

      }


      createIcFreeDrawing_from_freeDrawingFObj(fObj) {
        console.log("createIcFreeDrawing_from_freeDrawingFObj", fObj);
        console.log("createIcFreeDrawing_from_freeDrawingFObj", fObj.constructor.name);


        const type = "freeDrawing";


        const trueRect = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        const exoObject = Object.assign({}, fObj);
        exoObject.icObj = null; // remove circular dependency

        const isCosmetic = fObj.isCosmetic;

        const icFreeDrawing_spec = {
          // path: fObj.path,

          exoObject: exoObject,

          isCosmetic: isCosmetic,
        };

        const icFreeDrawing = Object.assign(icObj, icFreeDrawing_spec);

        return icFreeDrawing;
      }

      createIcSvg(left, top, svgEl) {
        const type = "svg";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSvg_spec = {
          svg: svgEl,
        };

        var icSvg = Object.assign(icObj, icSvg_spec);

        const color_property = {
          get color() {
            return icSvg.svg.style.color;
          },
          set color(value) {
            icSvg.svg.style.color = value;
          },
        };

        icSvg = Object.assign(icSvg, color_property);

        return icSvg;
      }

      createIcTex(left, top, tex) {
        const type = "tex";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(500, 500);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icTex_spec = {
          tex: tex,
        };

        const icTex = Object.assign(icObj, icTex_spec);

        //debug
        // const infiniteCanvas = this;
        // setTimeout(() => {
        //   const tex = '\\frac{50}{50x^2-50}';
        //
        //   const represented = infiniteCanvas.getRepresented(icObj.id);
        //   // const rep_official = represented.r_official();
        //   // rep_official.tex = tex;
        //   const rep_free = represented.r_free();
        //   rep_free.tex = tex;
        //
        // }, 5000);

        return icTex;
      }

      createIcMathNode(left, top, mathNode) {
        console.log("createIcMathNode", left, top, mathNode);


        const type = "mathNode";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icMathNode_spec = {
          mathNode: mathNode,

          //appearance
          strokeWidth: 0.0777,
          stroke: "hotpink",
        };

        const icMathNode = Object.assign(icObj, icMathNode_spec);
        icMathNode.isTouchable = true;


        //edition
        const infiniteCanvas = this;

        icMathNode.edit = {};
        icMathNode.edit.start = function () {
          console.log("icMathNode.edit.start");

          globalsSingleton.isEditing = true;

          //mathQuill
          {
            //create mathField
            const mathField = createMathField();

            //add mathField root HTML element to canvasContainer
            const elt = mathField.el();
            console.log("elt", elt);

            if (elt.style == null) { elt.style = {}; }
            elt.style.position = "absolute";

            const canvasContainer = infiniteCanvas.canvas.parentElement;
            canvasContainer.appendChild(elt);    //SHU: move this to fabricIntegration

            mathField.reflow();


            // //update position
            // function updatePosition() {
            //   const represented = infiniteCanvas.getRepresented(icMathNode.id);
            //   // console.log("represented", represented);
            //   const rep_free = represented.r_free();
            //
            //   const position_screen = rep_free.getScreenPositionWithoutOffset();
            //   console.log("position_screen", position_screen);
            //
            //   const style = {
            //     left: position_screen.x + 'px',
            //     top:  position_screen.y + 'px',
            //   };
            //
            //   const elt = mathField.el();
            //   // elt.style = Object.assign(elt.style, style);
            //   elt.style.left = style.left;
            //   elt.style.top  = style.top;
            //
            //   mathField.reflow();
            // }
            //
            // updatePosition();


            //update rect
            function updateRect() {
              const represented = infiniteCanvas.getRepresented(icMathNode.id);
              const rep_free = represented.r_free();

              const screenRect = rep_free.getScreenRect();
              console.log("screenRect", screenRect);

              const style = {
                left: screenRect.left + 'px',
                top: screenRect.top + 'px',
                width: screenRect.width + 'px',
                height: screenRect.height + 'px',
              };

              const elt = mathField.el();
              // elt.style = Object.assign(elt.style, style);
              elt.style.left = style.left;
              elt.style.top = style.top;
              elt.style.width = style.width;
              elt.style.height = style.height;

              mathField.reflow();
            }

            updateRect();


            //update tex
            function updateTex() {
              const represented = infiniteCanvas.getRepresented(icMathNode.id);
              const rep_free = represented.r_free();

              const tex = rep_free.mathNode.toTex();
              mathField.latex(tex);
            }

            updateTex();

            //bind position
            {

            }



            //track end of mathField edition
            // mathField.upOutOf({
            //   const represented = infiniteCanvas.getRepresented(icMathNode.id);
            //   const rep_free    = represented.r_free();
            //
            //   rep_free.edit.stop(mathField);
            // })
            // mathField.el().onfocusout(() => {
            //   stopEditing(mathField);
            // });
            const eventListener = () => {
              stopEditing(mathField);
            };
            mathField.el().addEventListener("focusout", eventListener);

            function stopEditing(mathField) {
              const represented = infiniteCanvas.getRepresented(icMathNode.id);
              const rep_free = represented.r_free();

              rep_free.edit.stop(mathField);

              globalsSingleton.isEditing = false;
            }


            //focus mathField
            mathField.focus();

          }


        };

        icMathNode.edit.stop = function (mathField) {
          console.log("icMathNode.edit.stop", mathField);

          //mathQuill
          {

            //transfer tex
            {
              const tex = mathField.latex();
              console.log("tex", tex);

              const represented = infiniteCanvas.getRepresented(icMathNode.id);
              const rep_free = represented.r_free();

              //this is where fun starts
              function mathFieldTex_to_mathNode(tex) {
                var outMathNode;

                // outMathNode = math.parse(tex);
                const mathExpression = MathExpression.fromLatex(tex);
                const text = mathExpression.toString();
                console.log("text", text);
                outMathNode = math.parse(text);

                //don't parse "=" into ":="

                //upgrade to gmOperator when writing "x50"

                return outMathNode;
              }

              const mathNode__new = mathFieldTex_to_mathNode(tex);
              mathNode__new.autoSimplify = true;

              rep_free.mathNode = mathNode__new;
            }

            //remove all listeners
            // mathField.el().removeEventListener("focusout", eventListener);
            $(mathField.el()).off();

            //remove mathField elt from canvasContainer
            mathField.el().remove();

            //destroy mathField
            mathField.revert();
          }


        };



        return icMathNode;
      }

      createIcRichMathNode(left, top, richMathNode) {
        console.log("createIcRichMathNode", left, top, richMathNode);

        const type = "richMathNode";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRichMathNode_spec = {
          richMathNode: richMathNode,
        };

        const icRichMathNode = Object.assign(icObj, icRichMathNode_spec);


        return icRichMathNode;
      }


      // createIcAsText_mathNode(left, top, text, ) {
      //
      //   const type      = "as_text__mathNode";
      //   const position  = Geometry.createPoint(left, top);
      //   const size      = Geometry.createSize(0, 0);
      //   const homeScale = Object.assign({}, this.scale);
      //
      //   const icObj = this.createIcObject(type, position, size, homeScale);
      //
      //
      //   // const text     = "icText";
      //   const fontSize = 100;
      //
      //   const icText_spec = {
      //     text:      text,
      //     textColor: "black",
      //     fontSize:  fontSize,
      //   };
      //
      //   const icText = Object.assign(icObj, icText_spec);
      //
      //   return icText;
      // }
      //
      // createIcAsY(left, top, type_y, type_x, func_YtoX) {
      //
      // }
      //
      // createIcEditingAsY(left, top, type_y, type_x, func_YtoX) {
      //
      // }


      createIcMNReictangle(left, top, mathNode, length_unit = 30) {
        console.log("createIcMNReictangle", left, top, mathNode);

        const type = "mnrei_rectangle";
        const position = Geometry.createPoint(left, top);

        const value = mathNode.evaluate({});

        const width = length_unit * value;
        // const height = length_unit * 1;
        const height = 30;

        const size = Geometry.createSize(width, height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);
        // icMNReictangle.fill = "orange";

        const icMNReictangle_spec = {
          mathNode: mathNode,
          length_unit: length_unit,
        };

        const icMNReictangle = Object.assign(icObj, icMNReictangle_spec);

        const infiniteCanvas = this;
        infiniteCanvas.onceOnAddRepresentedForIcObject(icMNReictangle, (icMNReictangle) => {

          const rep_free = infiniteCanvas.getRepresented(icMNReictangle.id).r_free();

          rep_free.onInnerUpdate((rep_free, propName, oldValue, newValue) => {

            if (propName == "mathNode") {
              logger.log("icMNReictangle.onInnerUpdate, mathNode", propName, newValue);

              const mathNode = newValue;

              const value = mathNode.evaluate({});
              logger.log("value", value);

              const length_unit = rep_free.length_unit;

              const width = length_unit * value;
              // const height = length_unit * 1;
              const height = 30;

              const size = Geometry.createSize(width, height);

              rep_free.size = size;
            }

          });

        });

        return icMNReictangle;
      }


      createIcHtmlElt(left, top, html_elt) {
        console.log("createIcHtmlElt", left, top, html_elt);
        const infiniteCanvas = this;

        const type = "htmlElt";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icHtmlElt_spec = {
          htmlElt: html_elt,
        };

        const icHtmlElt = Object.assign(icObj, icHtmlElt_spec);



        const htmlEltObserver = createHtmlEltObserver(html_elt);
        htmlEltObserver.rx_observable__mutation.subscribe({
          next: (html_elt_mutated) => {

            const represented = infiniteCanvas.getRepresented(icHtmlElt.id);
            const rep_free = represented.getRepresentation("free");

            rep_free.htmlElt = html_elt_mutated;

          },
        });

        html_elt.innerHTML = "1";
        // html_elt.text = "1";


        //debug
        setTimeout(() => {
          html_elt.innerHTML += "[]";
          // html_elt.text += "[]";
        }, 5000);

        // setInterval(() => {
        //   html_elt.innerHTML += "[]";
        //   // html_elt.text += "[]";
        // }, 2000);


        return icHtmlElt;
      }




      createIcGroupWithChildIcObjects(arr_icObjs) {
        console.log("createIcGroupWithChildIcObjects", arr_icObjs);

        const type = "group";

        const trueRect = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icGroup_spec = {
          children: children,
        };

        const icGroup = Object.assign(icObj, icGroup_spec);

        return icGroup;
      }

      createIcGroup_from_groupFObj(fObj) {
        console.log("createIcGroup_from_groupFObj", fObj);

        const type = "group";

        const trueRect = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const fChildren = fObj.getObjects();
        const icChildren = fChildren.map(fObj => {
          const icObj = fObj.icObj;

          //?add position wrt group
          return icObj;
        });

        const icGroup_spec = {
          children: icChildren,
        };

        const icGroup = Object.assign(icObj, icGroup_spec);

        return icGroup;
      }

      createIcActiveSelection_from_activeSelectionFObj(fObj) {
        console.log("createIcActiveSelection_from_activeSelectionFObj", fObj);

        const type = "activeSelection";

        const trueRect = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const arr_fChild = fObj.getObjects();
        const arr_icChild = arr_fChild.map(fObj_child => {
          logger.log("fObj_child", fObj_child);

          // const icObj_child = fObj.icObj;
          // logger.log("icObj_child", icObj_child);   //????
          // icObj_child.icObj__activeSelection = icObj;

          fObj.activeSelection = fObj;

          //add position wrt group

        });

        const icActiveSelection_spec = {
          children: arr_icChild,
        };

        const icActiveSelection = Object.assign(icObj, icActiveSelection_spec);

        return icActiveSelection;

      }


      createIcLink(icObj1, icObj2) {
        console.log("createIcLink", fObj);

        const infiniteCanvas = this;

        const type = "link";

        const trueRect = {

        };
        const position = Geometry.getPointTL(trueRect);
        const size = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const arr_part = {
          [icObj1.id]: icObj1,
          [icObj2.id]: icObj2,
        };

        const icLink_spec = {
          parts: arr_part,
        };

        const icLink = Object.assign(icObj, icLink_spec);

        return icLink;
      }




      createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive) {

        const type = "toggleRect";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icToggleRect_spec = {
          activeCfg: activeCfg,
          inactiveCfg: inactiveCfg,

          isActive: isActive,
        };

        const icToggleRect = Object.assign(icObj, icToggleRect_spec);

        return icToggleRect;

      }



      createIcSnapSlot(trueRect, snapSlotConfig_in = null) {
        console.log("createIcSnapSlot");

        const infiniteCanvas = this;

        const type      = "snapSlot";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        var snapSlotConfig = snapSlotConfig_in;
        if (snapSlotConfig == null) {
          // console.log("snapEngine == null");
          snapSlotConfig = Snap.defaultSnapSlotConfig();
        }

        const icSnapSlot_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 3,

          snapSlotConfig: snapSlotConfig,
        };

        const icSnapSlot = Object.assign(icObj, icSnapSlot_spec);



        const engine = new SnapSlotEngine();
        const eType = "snapSlot";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icSnapSlot, eType, engine);


        return icEngined;
      }





      createIcLine_start() {
        // console.log("createIcLine_start");

        //check
        {
          const creationManager__line = this.creationManagers["line"];
          if (creationManager__line != null) {
            throw new Error("createIcLine_start, creationManager__line != null");
          }
        }

        // this.creationManagers["line"] = new LineCreationManager();
        this.creationManagers["line"] = {};
        const creationManager__line = this.creationManagers["line"];

        const true_cursor = this.getTrueCursor();

        creationManager__line.point_start = Object.assign({}, true_cursor);
      }

      createIcLine_end() {
        // console.log("createIcLine_end");

        //check
        {
          const creationManager__line = this.creationManagers["line"];
          if (creationManager__line == null) {
            throw new Error("createIcLine_end, creationManager__line == null");
          }
        }

        const creationManager__line = this.creationManagers["line"];

        const true_cursor = this.getTrueCursor();

        creationManager__line.point_end = Object.assign({}, true_cursor);

        // this.createIcLine(creationManager__line.point_start, creationManager__line.point_end);
        const icSegment = this.createIcSegment(creationManager__line.point_start, creationManager__line.point_end);
        this.addIcObject(icSegment);

        delete this.creationManagers["line"];
      }

      createIcLine(startPoint, endPoint) {

        const type = "line";
        const position = Geometry.createPoint(left, top);
        const size = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;

      }

      createIcSegment(point_start, point_end) {
        // console.log("createIcSegment", point_start, point_end);

        const type       = "segment";
        const position   = null;
        const size       = null;
        const homeScale  = {X: 1, Y: 1};

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSegment_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
          point_start: point_start,
          point_end:   point_end,
        };

        const icSegment = Object.assign(icObj, icSegment_spec);

        return icSegment;
      }



      createIcSpotLine_start() {
        // console.log("createIcLine_start");

        //check
        {
          const creationManager__line = this.creationManagers["line"];
          if (creationManager__line != null) {
            throw new Error("createIcLine_start, creationManager__line != null");
          }
        }

        // this.creationManagers["line"] = new LineCreationManager();
        this.creationManagers["line"] = {};
        const creationManager__line = this.creationManagers["line"];

        const true_cursor = this.getTrueCursor();

        creationManager__line.point_start = Object.assign({}, true_cursor);
      }

      createIcSpotLine_end() {
        // console.log("createIcLine_end");

        //check
        {
          const creationManager__line = this.creationManagers["line"];
          if (creationManager__line == null) {
            throw new Error("createIcLine_end, creationManager__line == null");
          }
        }

        const creationManager__line = this.creationManagers["line"];

        const true_cursor = this.getTrueCursor();

        creationManager__line.point_end = Object.assign({}, true_cursor);

        // this.createIcLine(creationManager__line.point_start, creationManager__line.point_end);
        const icSegment = this.createIcSegment(creationManager__line.point_start, creationManager__line.point_end);
        this.addIcObject(icSegment);

        delete this.creationManagers["line"];
      }

      createIcSpotLine(startPoint, endPoint) {

        const type      = "spotLine";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;

      }

      createIcSpotSegment(point_start, point_end) {
        // console.log("createIcSegment", point_start, point_end);

        const type = "spotSegment";
        const position = null;
        const size = null;
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSegment_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
          point_start: point_start,
          point_end: point_end,
        };

        const icSegment = Object.assign(icObj, icSegment_spec);

        return icSegment;
      }




      createIcSlider(trueRect, sliderConfig) {
        // console.log("createIcSlider", trueRect, sliderConfig);

        const type      = "slider";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);





        const ratio__wh_end    = 1. /  80;
        const ratio__wh_marker = 1. / 120;


        const pointL = Geometry.createPoint(-800, -200);
        const width  = 2000;
        const pointR = Geometry.createPoint(pointL.x + width, pointL.y);

        const icSegment__segment = infiniteCanvas.createIcSegment(pointL, pointR);
        // infiniteCanvas.addIcObject(icObj_Segment__segment);


        //mark ends

        const height__end = ratio__wh_end * width;

        const point_endL_T = Geometry.createPoint(pointL.x, pointL.y - height__end);
        const point_endL_B = Geometry.createPoint(pointL.x, pointL.y + height__end);

        const icSegment__endL = infiniteCanvas.createIcSegment(point_endL_T, point_endL_B);
        // infiniteCanvas.addIcObject(icObj_Segment__endL);


        const point_endR_T = Geometry.createPoint(pointR.x, pointR.y - height__end);
        const point_endR_B = Geometry.createPoint(pointR.x, pointR.y + height__end);

        const icSegment__endR = infiniteCanvas.createIcSegment(point_endR_T, point_endR_B);
        // infiniteCanvas.addIcObject(icObj_Segment__endR);



        


        //valueify segment
        const ratio__wh_spot = 1. / 100;

        const size__spot = {
          width:   ratio__wh_spot * width, 
          height:  ratio__wh_spot * width,
        };

        // const icSpotPoint = infiniteCanvas.createIcSpotPoint(pointL, size__spot);
        // icSpotPoint.viewType = "circle";


        const icPoint__L        = infiniteCanvas.createIcPoint(pointL);
        icPoint__L.pointType    = "circle";

        const icPoint__R        = infiniteCanvas.createIcPoint(pointR);
        icPoint__R.pointType    = "circle";

        const icPoint__knob     = infiniteCanvas.createIcPoint(pointL);
        icPoint__knob.pointType = "circle";
        icPoint__knob.fill      = "lime";




        function mark_divide(point1, point2, nb_sectors, ratio_wh_marker) {

        }

        function createMarkerWithValue(icSegment, value_min, value_max, value) {
          const progress          = (value - value_min) / (value_max - value_min);
          const icSegment__marker = createMarkerWithProgress(icSegment, progress);
          return icSegment__marker; 
        }

        function createMarkerWithProgress(icSegment, progress) {

          const pointL = icSegment.point_start;
          const pointR = icSegment.point_end;

          const vSegment = Geometry.vector_2d(icSegment.point_start, icSegment.point_end);
          const width    = Geometry.norm_2d(vSegment);
          
          const height__marker = ratio__wh_marker * width;

          const x__progress = pointL.x + progress * (pointR.x - pointL.x);
          const y__progress = pointL.y + progress * (pointR.y - pointL.y);

          const point__marker_T = Geometry.createPoint(x__progress, y__progress - height__marker);
          const point__marker_B = Geometry.createPoint(x__progress, y__progress + height__marker);

          const icSegment__marker = infiniteCanvas.createIcSegment(point__marker_T, point__marker_B);
          return icSegment__marker;
        } 


        const icSegment__marker_0 = createMarkerWithValue(icSegment__segment, sliderConfig.value__L, sliderConfig.value__R, 0);
        const icSegment__marker_1 = createMarkerWithValue(icSegment__segment, sliderConfig.value__L, sliderConfig.value__R, 1);


        const parts = {
          "segment":  icSegment__segment,
          "endL":     icSegment__endL,
          "endR":     icSegment__endR,

          "marker_0": icSegment__marker_0,
          "marker_1": icSegment__marker_1,

          "pointL":   icPoint__L,
          "pointR":   icPoint__R,
          "knob":     icPoint__knob,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        // compositeConfig[icPoint.id].isMobile = true;

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "slider";




        const icSlider_spec = {
          value__L: sliderConfig.value__L,
          value__R: sliderConfig.value__R,

          // value: sliderConfig.value,
          mathNode: new math.ConstantNode(sliderConfig.value),
        };

        const icSlider = Object.assign(icComposite, icSlider_spec);



        const sliderEngine = new SliderEngine();
        infiniteCanvas.installEngineOnIcObj(icSlider, "slider", sliderEngine);


        // //debug
        // infiniteCanvas.onceOnAddRepresentedForIcObject(icSlider, (icSlider) => {
        //   const rep_free = infiniteCanvas.getRepresented(icSlider.id).r_free();
          
        //   setTimeout(() => {
        //     rep_free.mathNode = new math.ConstantNode(50);
        //   }, 3000);

        // })



        return icSlider;
      }







      createIcHUDLine_start() {
        // console.log("createIcHUDLine_start");

        //check
        {
          const creationManager__line = this.creationManagers["HUD_line"];
          if (creationManager__line != null) {
            throw new Error("createIcHUDLine_start, creationManager__line != null");
          }
        }

        // this.creationManagers["HUD_line"] = new LineCreationManager();
        this.creationManagers["HUD_line"] = {};
        const creationManager__line = this.creationManagers["HUD_line"];

        const true_cursor = this.getTrueCursor();

        creationManager__line.point_start = Object.assign({}, true_cursor);
      }

      createIcHUDLine_end() {
        // console.log("createIcLine_end");

        //check
        {
          const creationManager__line = this.creationManagers["HUD_line"];
          if (creationManager__line == null) {
            throw new Error("createIcHUDLine_end, creationManager__line == null");
          }
        }

        const creationManager__line = this.creationManagers["HUD_line"];

        const true_cursor = this.getTrueCursor();

        creationManager__line.point_end = Object.assign({}, true_cursor);

        // this.createIcLine(creationManager__line.point_start, creationManager__line.point_end);
        const icSegment = this.createIcHUDSegment(creationManager__line.point_start, creationManager__line.point_end);
        this.addIcObject(icSegment);

        delete this.creationManagers["HUD_line"];
      }

      createIcHUDLine(startPoint, endPoint) {

        const type      = "HUD_line";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(width, height);
        const homeScale = {X: 1, Y: 1};

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;

      }

      createIcHUDSegment(point_start, point_end) {
        // console.log("createIcHUDSegment", point_start, point_end);

        const type      = "HUD_segment";
        const position  = null;
        const size      = null;
        const homeScale = {X: 1, Y: 1};

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSegment_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
          point_start: point_start,
          point_end: point_end,
        };

        const icSegment = Object.assign(icObj, icSegment_spec);

        return icSegment;
      }







      



      // createEventstore_p() {
      //   //logger.log("createEventstore_p");
      //
      //   const eventstore = new Eventstore();
      //   return eventstore.initialize();
      // }
      createEventstore() {
        // logger.log("createEventstore");

        const eventstore = new Eventstore();
        eventstore.initialize();

        return eventstore;
      }

      getArrEvent_p(eventstore__) {
        var out_p;

        const replayStream_p = eventstore__.getReplay({
          // fromPosition: 7,
          // toPosition: 23
        });

        out_p = replayStream_p.then(readEventStream_p);

        return out_p;
      }

      getReplayObj_p(eventstore__) {
        var out_p;

        out_p = this.getArrEvent_p(eventstore__)
          .then(arr_event__replay => {

            const replayObj = {
              arr_event: arr_event__replay,
            };

            return replayObj;
          });

        return out_p;
      }

      performReplay(arr_event__replay) {

        const event__first = arr_event__replay[0];
        const time__first = event__first.data.time;
        const arr_replayEvent = arr_event__replay.map(event => {
          const event__clone = Object.assign({}, event);

          const time__event = event__clone.data.time
          event__clone.timeout = time__event - time__first;

          return event__clone;
        });

        arr_replayEvent.forEach((replayEvent, i) => {
          setTimeout(() => {
            infiniteCanvas.manageMoveEvent(replayEvent);
          }, replayEvent.timeout);
        });

      }


      createIcReplay_start() {
        // console.log("createIcReplay_start");

        const infiniteCanvas = this;

        //check
        {
          const creationManager__replay = infiniteCanvas.creationManagers["replay"];
          if (creationManager__replay != null) {
            throw new Error("createIcReplay_start, creationManager__replay != null");
          }
        }

        // infiniteCanvas.creationManagers["replay"] = new icReplayCreationManager();
        infiniteCanvas.creationManagers["replay"] = {};
        const creationManager__replay = infiniteCanvas.creationManagers["replay"];


        //create dedicated eventstore
        // infiniteCanvas.createEventstore_p()
        // .then((eventstore__replay) => {
        //   logger.log("eventstore__replay", eventstore__replay);
        //   creationManager__replay.eventstore = eventstore__replay;
        // });
        const eventstore__replay = infiniteCanvas.createEventstore();
        logger.log("eventstore__replay", eventstore__replay);
        creationManager__replay.eventstore = eventstore__replay;

        //start recording
        creationManager__replay.sub = infiniteCanvas.rx_icEvent_observable.subscribe({
          next: (icEvent) => {
            infiniteCanvas.recordIcEvent_p(eventstore__replay, icEvent);

            //debug
            infiniteCanvas.recordIcEvent_p(eventstore__global, icEvent);
          },
        });

      }

      createIcReplay_end() {
        // console.log("createIcReplay_end");

        const infiniteCanvas = this;

        //check
        {
          const creationManager__replay = this.creationManagers["replay"];
          if (creationManager__replay == null) {
            throw new Error("createIcReplay_end, creationManager__replay == null");
          }
        }

        const creationManager__replay = this.creationManagers["replay"];

        //stop recording
        creationManager__replay.sub.unsubscribe();



        const true_cursor = this.getTrueCursor();
        // creationManager__replay.point_end = Object.assign({}, true_cursor);
        const trueRect = {
          x: true_cursor.x,
          y: true_cursor.y,
          width: 100,
          height: 100,
        };

        const eventstore__replay = creationManager__replay.eventstore;
        const replayObj_p = this.getReplayObj_p(eventstore__replay);

        replayObj_p.then(replayObj => {

          const icReplay = infiniteCanvas.createIcReplay(trueRect, replayObj);
          infiniteCanvas.addIcObject(icReplay);

          delete infiniteCanvas.creationManagers["replay"];
        });

      }

      createIcReplay(trueRect, replayObj) {
        logger.log("createIcReplay", trueRect, replayObj);

        const type = "replay";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);
        icObj.fill = "red";

        const icReplay_spec = {
          replayObj: replayObj,
        };

        const icReplay = Object.assign(icObj, icReplay_spec);

        return icReplay;
      }





      createIcPathmadeOperator_start(type__pathmadeOp) {
        // console.log("createIcPathmadeOperator_start");

        const infiniteCanvas = this;

        //check
        {
          const creationManager__pathmadeOperator = infiniteCanvas.creationManagers["pathmadeOperator"];
          if (creationManager__pathmadeOperator != null) {
            throw new Error("createIcPathmadeOperator_start, creationManager__pathmadeOperator != null");
          }
        }

        infiniteCanvas.creationManagers["pathmadeOperator"] = {
          type: type__pathmadeOp,
        };
        const creationManager__pathmadeOperator = infiniteCanvas.creationManagers["pathmadeOperator"];

        //create dedicated eventstore
        const eventstore__pathmadeOperator = infiniteCanvas.createEventstore();
        logger.log("eventstore__pathmadeOperator", eventstore__pathmadeOperator);
        creationManager__pathmadeOperator.eventstore = eventstore__pathmadeOperator;

        //start recording
        creationManager__pathmadeOperator.sub = infiniteCanvas.rx_icEvent_observable.subscribe({
          next: (icEvent) => {
            infiniteCanvas.recordIcEvent_p(eventstore__pathmadeOperator, icEvent);
          },
        });

      }

      createIcPathmadeOperator_end_p() {
        // console.log("createIcPathmadeOperator_end_p");
        var out_p;

        const infiniteCanvas = this;

        //check
        {
          const creationManager__pathmadeOperator = infiniteCanvas.creationManagers["pathmadeOperator"];
          if (creationManager__pathmadeOperator == null) {
            const err = new Error("createIcPathmadeOperator_end_p, creationManager__pathmadeOperator == null");
            out_p = Promise.reject(err);
          }
        }

        const creationManager__pathmadeOperator = infiniteCanvas.creationManagers["pathmadeOperator"];

        //stop recording
        creationManager__pathmadeOperator.sub.unsubscribe();


        const type__pathmadeOp = creationManager__pathmadeOperator.type;
        const path = creationManager__pathmadeOperator.path;
        const replayObj = creationManager__pathmadeOperator.replayObj;

        const eventstore__pathmadeOperator = creationManager__pathmadeOperator.eventstore;
        const replayObj_p = infiniteCanvas.getReplayObj_p(eventstore__pathmadeOperator);

        out_p = replayObj_p
          .then(replayObj => {

            const icPathmadeOperator = infiniteCanvas.createIcPathmadeOperator(type__pathmadeOp, path, replayObj);

            delete this.creationManagers["pathmadeOperator"];

            return icPathmadeOperator;
          });

        return out_p;
      }

      // createIcPathmadeOperator_from_operatorPathDrawingFObj(fObj) {
      //   console.log("createIcPathmadeOperator_from_operatorPathDrawingFObj", fObj);
      //   console.log("createIcPathmadeOperator_from_operatorPathDrawingFObj", fObj.constructor.name);
      //
      //   const type      = "pathmadeOperator";
      //
      //   const trueRect  = this.toTrueRect(fObj);
      //   const position = Geometry.getPointTL(trueRect);
      //   const size     = Geometry.createSize(trueRect.width, trueRect.height);
      //
      //   const homeScale = Object.assign({}, this.scale);
      //
      //   const icObj = this.createIcObject(type, position, size, homeScale);
      //
      //
      //   const exoObject = Object.assign({}, fObj);
      //   exoObject.icObj = null; // remove circular dependency
      //
      //   const icPathmadeOperator_spec = {
      //     path: fObj.path,
      //     // exoObject: exoObject,
      //   };
      //
      //   const icPathmadeOperator = Object.assign(icObj, icPathmadeOperator_spec);
      //
      //   return icPathmadeOperator;
      // }


      startingPointFromPath(path) {
        logger.log("startingPointFromPath", path);

        var outPoint;

        //["M", 406.91, 627.09]
        const elt__first = path[0];
        const x = elt__first[1];
        const y = elt__first[2];

        outPoint = {
          x: x,
          y: y,
        };

        return outPoint;
      }

      transformationFuncForReplayObj(replayObj) {
        var outFunc;

        outFunc = function (icObj) {
          var transformationOutput;

          //debug
          // if(icObj.text != null) {
          //   icObj.text += "lol";
          // }


          const arr_event__replay = replayObj.arr_event;
          if (arr_event__replay.length > 0) {

            const event__first = arr_event__replay[0];
            const time__first = event__first.data.time;
            const arr_replayEvent = arr_event__replay.map(event => {
              const event__clone = Object.assign({}, event);

              const time__event = event__clone.data.time
              event__clone.timeout = time__event - time__first;

              return event__clone;
            });


            arr_replayEvent.forEach((replayEvent, i) => {
              setTimeout(() => {

                const rep_free = icObj;

                const moveEvent = replayEvent;

                //"apply" event
                const position__new = moveEvent.data.position;
                rep_free.position = position__new;

              }, replayEvent.timeout);
            });

          }




          transformationOutput = new TransformationOutput("mutated", icObj, icObj);

          return transformationOutput;
        };

        return outFunc;
      }

      // doEvent_p(icEvent) {
      //
      // }

      transformationFunc_pForReplayObj(replayObj) {
        var outFunc;

        outFunc = function (icObj) {
          var out_p;

          //follow a new path
          icObj.counter__path += 1;
          const index__path = icObj.counter__path;

          const arr_event__replay = replayObj.arr_event;
          if (arr_event__replay.length > 0) {

            const event__first = arr_event__replay[0];
            const time__first = event__first.data.time;
            const arr_replayEvent = arr_event__replay.map(event => {
              const event__clone = Object.assign({}, event);

              const time__event = event__clone.data.time
              event__clone.timeout = time__event - time__first;

              return event__clone;
            });

            function createPromiseForReplayEvent(replayEvent) {
              return new Promise((resolve, reject) => {

                setTimeout(() => {

                  if (icObj.counter__path == index__path) {

                    const rep_free = icObj;

                    const moveEvent = replayEvent;

                    //"apply" event
                    const position__new = moveEvent.data.position;
                    rep_free.position = position__new;

                    resolve(rep_free);

                  } else {
                    // const err = new Error("icObj.id__replayObj != replayObj.id");
                    // reject(err);
                    resolve(icObj);
                  }

                }, replayEvent.timeout);
              });
            }

            const arr_promise = arr_replayEvent.map(createPromiseForReplayEvent);

            var transformationOutput = new TransformationOutput("mutated", icObj, icObj);

            out_p = bluebird.reduce(arr_promise, (acc, x) => {
              // logger.log("x", x);
              return acc;
            }, transformationOutput);

            //debug
            // out_p = out_p.then(transformationOutput => {
            //   logger.log("transformationOutput", transformationOutput);
            //   return transformationOutput;
            // });

          } else {
            out_p = Promise.reject(new Error("arr_event__replay.length == 0"));
          }

          return out_p;
        };

        return outFunc;
      }


      createIcDummy(trueRect) {
        logger.log("createIcDummy");

        const icObj = this.createIcRect(trueRect);

        const fColor__fill = new fabric.Color("black");
        fColor__fill.setAlpha(0.444);
        icObj.fill = fColor__fill.toRgba();

        icObj.strokeWidth = 2;
        const fColor__stroke = new fabric.Color("red");
        fColor__stroke.setAlpha(0.444);
        icObj.stroke = fColor__stroke.toRgba();

        const icDummy_spec = {
          isDummy: true,
        };

        const icDummy = Object.assign(icObj, icDummy_spec);

        return icDummy;
      }



      // createIcPathmadeOperator(path, replayObj) {
      //   logger.log("createIcPathmadeOperator", path, replayObj);
      //
      //   //debug
      //   const point__start = this.startingPointFromPath(path);
      //
      //   const trueRect = {
      //     x:      point__start.x,
      //     y:      point__start.y,
      //     width:  100,
      //     height: 100,
      //   };
      //
      //   const type      = "pathmadeOperator";
      //   const position  = Geometry.createPoint(trueRect.x, trueRect.y);
      //   const size      = Geometry.createSize(trueRect.width, trueRect.height);
      //   const homeScale = Object.assign({}, this.scale);
      //
      //   const icObj = this.createIcObject(type, position, size, homeScale);
      //   icObj.fill = "blanchedalmond";
      //
      //   const icPathmadeOperator_spec = {
      //     path: path,
      //     replayObj: replayObj,
      //   };
      //
      //   const icPathmadeOperator = Object.assign(icObj, icPathmadeOperator_spec);
      //
      //   return icPathmadeOperator;
      // }

      createIcPathmadeOperator(type__pathmadeOp, path, replayObj) {
        var outIcObj;

        switch (type__pathmadeOp) {
          case "conveyor":
            outIcObj = infiniteCanvas.createIcPathmadeOperator__conveyor(path, replayObj);
            break;
          case "shadePossessor":
            outIcObj = infiniteCanvas.createIcPathmadeOperator__shadePossessor(path, replayObj);
            break;
          case "vesseler":
            outIcObj = infiniteCanvas.createIcPathmadeOperator__vesseler(path, replayObj);
            break;
          default:
            throw new Error("Unsupported type: " + type__pathmadeOp);
            break;
        }

        return outIcObj;
      }

      createIcPathmadeOperator__conveyor(path, replayObj) {
        logger.log("createIcPathmadeOperator__conveyor", path, replayObj);

        const point__start = this.startingPointFromPath(path);

        const trueRect = {
          x: point__start.x,
          y: point__start.y,
          width: 100,
          height: 100,
        };

        const text_in = "pathmade:conveyor";

        // const transformationFunc = this.transformationFuncForReplayObj(replayObj);
        const transformationFunc = async function (icObj, icTouchSlot) {

          //prevent original from touches while shadePossessor is running     //SHU: il faudra trouver un moyen de faire autrement car c'est moche
          // icObj.isTouchable = false;

          const transformationFunc_p = infiniteCanvas.transformationFunc_pForReplayObj(replayObj);
          const transformationOutput = await transformationFunc_p(icObj)
            .then(transformationOutput => {

              //restore isTouchable                 //SHU: il faudra trouver un moyen de faire autrement car c'est moche
              // if(icObj.type != "geminiShade") {
              //   icObj.isTouchable = true;
              // }

              return transformationOutput;
            });

          return transformationOutput;
        };

        const operatorConfig = new OperatorConfig(text_in, transformationFunc);

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_operator";

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;


        const icPathmadeOperator_spec = {
          path: path,
        };

        const icPathmadeOperator = Object.assign(icComposite, icPathmadeOperator_spec);

        return icPathmadeOperator;
      }


      createIcPathmadeOperator__shadePossessor(path, replayObj) {
        logger.log("createIcPathmadeOperator__shadePossessor", path, replayObj);

        const point__start = this.startingPointFromPath(path);

        const trueRect = {
          x: point__start.x,
          y: point__start.y,
          width: 100,
          height: 100,
        };

        const text_in = "pathmade:shadePossessor";

        // const transformationFunc = this.transformationFuncForReplayObj(replayObj);
        const transformationFunc__decorated = async function (icObj, icTouchSlot) {

          //create geminiShade
          const icGeminiShade = infiniteCanvas.createIcGeminiShade(icObj);
          // icGeminiShade.position = {
          //   x: icGeminiShade.position.x + 100,
          //   y: icGeminiShade.position.y + 100,
          // };

          //prevent geminiShade from being touched by shadePossessor when starting
          {
            icGeminiShade.touchStateDict[icTouchSlot.id] = TouchState.Touched;
            // icGeminiShade.isTouchable = false;


            // logger.log("*icTouchSlot", icTouchSlot);
            // const canTouchFunc_geometryWise = function(above, below, context) {
            //   const canTouchFunc = Touch.canTouch;
            //   const canTouchFunc = Touch2Singleton.sharedInstance().canTouch;
            //
            //   return canTouchFunc(above, below);
            // };
            //
            // const canTouchFunc_idWise = function(above, below, context) {
            //   logger.log("canTouchFunc_idWise, above.id", above.id);
            //   logger.log("canTouchFunc_idWise, icGeminiShade.id", icGeminiShade.id);
            //
            //   return (above.id != icGeminiShade.id);
            // };
            //
            // const canTouchFuncs = {
            //   "geometry": canTouchFunc_geometryWise,
            //   "id":       canTouchFunc_idWise,
            // };
            //
            // const canTouchFunc_allWise = (above, below, context) => {
            //   return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            //     const canTouch_xWise = canTouchFunc_xWise(above,below, context);
            //     console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            //     return acc && canTouch_xWise;
            //   }, true);
            // };
            //
            // const canTouchFunc = canTouchFunc_allWise;
            // icTouchSlot.touchSlotConfig.canTouchFunc = canTouchFunc;
          }

          //prevent original from touches while shadePossessor is running     //SHU: il faudra trouver un moyen de faire autrement car c'est moche
          icObj.isTouchable = false;

          const transformationOutput = await infiniteCanvas.addIcObject_p(icGeminiShade)
            .then(rep_free__geminiShade => {
              var out_p;

              //operate on shade

              const transformationFunc_p = infiniteCanvas.transformationFunc_pForReplayObj(replayObj);

              out_p = transformationFunc_p(rep_free__geminiShade)
                .then(transformationOutput => {
                  // logger.log("transformationOutput", transformationOutput);

                  const obj = {
                    rep_free__geminiShade: rep_free__geminiShade,
                    transformationOutput: transformationOutput,
                  };

                  return obj;
                });

              return out_p;
            })
            .then(obj => {

              const rep_free__geminiShade = obj.rep_free__geminiShade;
              // const transformationOutput  = obj.transformationOutput;
              const transformationOutput = new TransformationOutput("mutated", icObj, icObj);

              //destroy shade
              rep_free__geminiShade.im_dying_now = true;

              //restore isTouchable                 //SHU: il faudra trouver un moyen de faire autrement car c'est moche
              // if(icObj.type != "geminiShade") {
              //   icObj.isTouchable = true;
              // }

              return transformationOutput;
            });

          return transformationOutput;
        };

        const operatorConfig = new OperatorConfig(text_in, transformationFunc__decorated);

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_operator";

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;


        // return icComposite;

        const icPathmadeOperator_spec = {
          path: path,
        };

        const icPathmadeOperator = Object.assign(icComposite, icPathmadeOperator_spec);

        return icPathmadeOperator;
      }

      createIcPathmadeOperator__vesseler(path, replayObj) {
        logger.log("createIcPathmadeOperator__vesseler", path, replayObj);

        const point__start = this.startingPointFromPath(path);

        const trueRect = {
          x: point__start.x,
          y: point__start.y,
          width: 100,
          height: 100,
        };

        const text_in = "pathmade:vesseler";

        // const transformationFunc = this.transformationFuncForReplayObj(replayObj);
        const transformationFunc__decorated = async function (icObj, icTouchSlot) {

          //create vessel
          const trueRect__icObj = {
            x: icObj.position.x,
            y: icObj.position.y,
            width: icObj.size.width,
            height: icObj.size.height,
          };
          const icVessel = infiniteCanvas.createIcVessel(trueRect__icObj);

          //prevent vessel from being touched by parent vesseler when starting
          {
            icVessel.touchStateDict[icTouchSlot.id] = TouchState.Touched;
          }

          const transformationOutput = await infiniteCanvas.addIcObject_p(icVessel)
            .then(rep_free__vessel => {
              var out_p;

              // shutemp {
              //
              //remove icObj from previous vessel (if any)
              const previousVessel = infiniteCanvas.getVessel(icObj);
              if (previousVessel != null) {
                // previousVessel.engine.awoken.removePart(icObj);
                previousVessel.im_dying_now = true;                   //SHU: this is ugly, and fortunately, only temporary
              }
              //
              // shutemp }


              //add icObj to vessel
              rep_free__vessel.dict_engine["composite"].engine.awoken.addPart(icObj);

              //operate on vessel
              const transformationFunc_p = infiniteCanvas.transformationFunc_pForReplayObj(replayObj);

              out_p = transformationFunc_p(rep_free__vessel)
                .then(transformationOutput => {
                  // logger.log("transformationOutput", transformationOutput);

                  const obj = {
                    rep_free__vessel: rep_free__vessel,
                    transformationOutput: transformationOutput,
                  };

                  return obj;
                });

              return out_p;
            })
            .then(obj => {

              const rep_free__vessel = obj.rep_free__vessel;
              // const transformationOutput  = obj.transformationOutput;
              const transformationOutput = new TransformationOutput("mutated", icObj, icObj);

              //remove icObj from vessel
              rep_free__vessel.dict_engine["composite"].engine.awoken.removePart(icObj);

              //destroy vessel
              rep_free__vessel.im_dying_now = true;

              return transformationOutput;
            });

          return transformationOutput;
        };

        const operatorConfig = new OperatorConfig(text_in, transformationFunc__decorated);

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_operator";

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;


        // return icComposite;

        const icPathmadeOperator_spec = {
          path: path,
        };

        const icPathmadeOperator = Object.assign(icComposite, icPathmadeOperator_spec);

        return icPathmadeOperator;
      }

      createIcVessel(trueRect) {
        logger.log("createIcVessel");

        const parts = [];
        const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.c_type = "vessel";

        const fColor = new fabric.Color("violet");
        fColor.setAlpha(0.666);
        const rgbaColorString = fColor.toRgba();

        const icVessel_spec = {
          fill: rgbaColorString,

          isTouchable: false,
        }

        const icVessel = Object.assign(icComposite, icVessel_spec);

        return icVessel;
      }

      createIcFuturing(trueRect) {
        logger.log("createIcFuturing");

        const infiniteCanvas = this;

        const type = "futuring";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icFuturing_spec = {

        };

        const icFuturing = Object.assign(icObj, icFuturing_spec);


        const engine = new FuturingEngine();
        const eType = "futuring";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icFuturing, eType, engine);
      }




      createIcMultiPathmadeOperator_start(type__pathmadeOp) {
        // console.log("createIcMultiPathmadeOperator_start");

        const infiniteCanvas = this;

        //check
        {
          const creationManager__multiPathmadeOperator = infiniteCanvas.creationManagers["multiPathmadeOperator"];
          if (creationManager__multiPathmadeOperator != null) {
            throw new Error("createIcMultiPathmadeOperator_start, creationManager__multiPathmadeOperator != null");
          }
        }

        infiniteCanvas.creationManagers["multiPathmadeOperator"] = {
          type: type__pathmadeOp,
        };
        const creationManager__multiPathmadeOperator = infiniteCanvas.creationManagers["multiPathmadeOperator"];

        //create array for parts
        creationManager__multiPathmadeOperator.arr_pathmadeOp = [];

        //start amassing
        creationManager__multiPathmadeOperator.sub = infiniteCanvas.rx_icPathmadeOperator_observable.subscribe({
          next: (icPathmadeOperator) => {
            creationManager__multiPathmadeOperator.arr_pathmadeOp.push(icPathmadeOperator);
          },
        });

      }

      createIcMultiPathmadeOperator_end() {
        console.log("createIcMultiPathmadeOperator_end");

        const infiniteCanvas = this;

        //check
        {
          const creationManager__multiPathmadeOperator = infiniteCanvas.creationManagers["multiPathmadeOperator"];
          if (creationManager__multiPathmadeOperator == null) {
            throw new Error("createIcMultiPathmadeOperator_end, creationManager__multiPathmadeOperator == null");
          }
        }

        const creationManager__multiPathmadeOperator = infiniteCanvas.creationManagers["multiPathmadeOperator"];

        //stop amassing
        creationManager__multiPathmadeOperator.sub.unsubscribe();


        const type__pathmadeOp = creationManager__multiPathmadeOperator.type;
        const arr_pathmadeOp = creationManager__multiPathmadeOperator.arr_pathmadeOp;


        //create from parts
        const icMultiPathmadeOperator = infiniteCanvas.createIcMultiPathmadeOperator(arr_pathmadeOp);

        return icMultiPathmadeOperator;
      }


      createIcMultiPathmadeOperator(arr_pathmadeOp) {
        logger.log("createIcMultiPathmadeOperator", arr_pathmadeOp);

        const pathmadeOp__first = arr_pathmadeOp.find(e => true);
        const path__first = pathmadeOp__first.path;

        const point__start = this.startingPointFromPath(path__first);

        const trueRect = {
          x: point__start.x,
          y: point__start.y,
          width: 100,
          height: 100,
        };

        const text_in = "multipathmade";


        const canTouchFunc_geometryWise = function (above, below, context) {
          // const canTouchFunc = Touch.canTouch;
          const canTouchFunc = Touch2Singleton.sharedInstance().canTouch;

          return canTouchFunc(above, below);
        };

        const canTouchFunc_valueWise = function (icObj) {
          var outBool;

          if (icObj.type == "composite") {
            const nb_parts = Object.values(icObj.parts).length;
            logger.log("nb_parts", nb_parts);
            const nb_op = arr_pathmadeOp.length;
            logger.log("nb_op", nb_op);

            outBool = (nb_parts == nb_op);
          } else {
            outBool = false;
          }

          logger.log("canTouchFunc_valueWise", icObj, outBool);

          return outBool;
        };

        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value": canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above, below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;


        const transformationFunc = async function (icObj, icTouchSlot) {

          //debug
          // icObj.fill = ColorUtils.randomColor();
          const transformationOutput = new TransformationOutput("mutated", icObj, icObj);

          //dispatch
          const arr_part = Object.values(icObj.parts);
          const arr_transformationFunc = arr_pathmadeOp.map(icObj => icObj.parts.touchSlot.touchSlotConfig.transformationFunc);

          const zip = (a, b) => a.map((k, i) => [k, b[i]]);
          const arr_zipped = zip(arr_part, arr_transformationFunc);

          const arr_transformationOutput = arr_zipped.map(([part, transformationFunc], i) => {
            const transformationOutput = transformationFunc(part);
          });

          return transformationOutput;
        };


        const operatorConfig = new OperatorConfig(text_in, transformationFunc);

        const touchSlotConfig = {
          canTouchFunc: canTouchFunc,
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "multipathmade";

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;


        const icMultiPathmadeOperator_spec = {
          arr_pathmadeOp: arr_pathmadeOp,
        };

        const icMultiPathmadeOperator = Object.assign(icComposite, icMultiPathmadeOperator_spec);

        return icMultiPathmadeOperator;
      }



      createIcLayout(truePoint, storeConfig) {    //SHU: todo
        logger.log("createIcLayout", truePoint, storeConfig);

        // const parts           = [];
        // const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
        // const icComposite     = this.createIcComposite(trueRect, parts, compositeConfig);
        // icComposite.c_type = "store";
        //
        // const fColor = new fabric.Color("9A7B5F");
        // fColor.setAlpha(1.0);
        // const rgbaColorString = fColor.toRgba();
        //
        // const icStore_spec = {
        //   fill: rgbaColorString,
        //
        //   isTouchable: true,
        // }
        //
        // const icVessel = Object.assign(icComposite, icVessel_spec);
        //
        // return icVessel;
      }


      createIcStore(trueRect, storeConfig_in) {
        logger.log("createIcStore", trueRect, storeConfig);

        var storeConfig = storeConfig_in;
        if (storeConfig == null) {
          storeConfig = {
            type: "copy",
          };
        }

        const transformationFunc = async function (icObj, icTouchSlot) {

          //debug
          icObj.fill = ColorUtils.randomColor();
          const transformationOutput = new TransformationOutput("mutated", icObj, icObj);


          const rep_free__icStore = infiniteCanvas.getRepresented(icTouchSlot.compositeId).r_free();
          const rep_free__depot = rep_free__icStore.parts.depot;

          const icObj__clone = icObj.deepClone();
          const id__clone = infiniteCanvas.generateIcObjectId();
          icObj__clone.id = id__clone;
          icObj__clone.isTouchable = false;

          infiniteCanvas.addIcObject(icObj__clone);
          const rep_free__clone = infiniteCanvas.getRepresented(icObj__clone.id).r_free();

          rep_free__clone.homeScale = Object.assign({}, icObj.homeScale);

          const nb__in_depot = Object.values(rep_free__depot.parts).length;
          const spacing__x = 200;
          rep_free__clone.isMobile = true;
          rep_free__clone.position = {
            x: rep_free__depot.position.x + nb__in_depot * spacing__x,
            y: rep_free__depot.position.y,
          };

          rep_free__depot.dict_engine["composite"].engine.awoken.addPart(rep_free__clone);

          return transformationOutput;
        };

        const text_in = "store";
        const operatorConfig = new OperatorConfig(text_in, transformationFunc);

        const touchSlotConfig = {
          // canTouchFunc:       canTouchFunc,
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;


        var depot;
        {
          const parts = [];
          const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
          const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
          icComposite.c_type = "depot";

          depot = icComposite;
        }


        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.backgroundColor = "#9A7B5F";        //SHU: is store really an operator ?
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "depot": depot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.c_type = "store";

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;

        const icStore_spec = {

        };

        const icStore = Object.assign(icComposite, icStore_spec);

        infiniteCanvas.onceOnAddRepresentedForIcObject(icStore, (icStore) => {

          const rep_free__icStore = infiniteCanvas.getRepresented(icStore.id).r_free();
          const rep_free__depot = rep_free__icStore.parts.depot;

          //shift down depot
          rep_free__depot.isMobile = true;
          rep_free__depot.position = Object.assign({}, rep_free__depot.position, { y: rep_free__depot.position.y + 180 });
          rep_free__depot.isMobile = false;

        });

        return icStore;
      }


      createIcCounter(trueRect, counterConfig_in) {
        logger.log("createIcCounter", trueRect, counterConfig_in);

        var counterConfig = counterConfig_in;
        if (counterConfig == null) {
          counterConfig = this.createCounterConfig(1);
        }

        const canTouchFunc_geometryWise = (above, below, context) => {
          // const canTouchFunc = Touch.canTouch;
          const canTouchFunc = Touch2Singleton.sharedInstance().canTouch;

          return canTouchFunc(above, below);
        };

        const canTouchFunc_valueWise = function (icObj, icTouchSlot) {
          const canCount = counterConfig.canCountFunc(icObj);
          return canCount;
        };

        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value": canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above, below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;

        const transformationFunc = async function (icObj, icTouchSlot) {

          //debug
          // icObj.fill = ColorUtils.randomColor();
          const transformationOutput = new TransformationOutput("mutated", icObj, icObj);


          const rep_free__icCounter = infiniteCanvas.getRepresented(icTouchSlot.compositeId).r_free();

          const rep_free__reictangle = rep_free__icCounter.parts.reictangle;
          const rep_free__label = rep_free__icCounter.parts.label;


          //increment counter inner variable
          //counter inner variable is reictangle mathNode
          const mathNode__counter__old = rep_free__reictangle.mathNode;
          const value__counter__old = mathNode__counter__old.value;
          const value__counter__new = value__counter__old + 1;


          //update parts
          const mathNode__counter__new = new math.ConstantNode(value__counter__new);
          rep_free__reictangle.mathNode = mathNode__counter__new;

          rep_free__label.text = "" + value__counter__new;

          return transformationOutput;
        };

        const text_in = "count_";
        const operatorConfig = new OperatorConfig(text_in, transformationFunc);

        const touchSlotConfig = {
          canTouchFunc: canTouchFunc,
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        // touchSlot.fill     = "";
        // touchSlot.isMobile = false;





        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.backgroundColor = "#9A7B5F";        //SHU: is store really an operator ?
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const icObj__specimen = counterConfig.icObj__specimen;
        icObj__specimen.position = {
          x: facade.position.x + 280,
          y: facade.position.y + 32,
        };


        const mathNode = new math.ConstantNode(0);
        const icMNReictangle = this.createIcMNReictangle(trueRect.x + 100, trueRect.y - 50, mathNode);
        icMNReictangle.isTouchable = false;
        icMNReictangle.fill = "#A6C39E";
        icMNReictangle.orientation = -90;


        const string__counter = "" + mathNode.value;
        const label = infiniteCanvas.createIcText(trueRect.x + 100, trueRect.y + 200, string__counter);
        label.backgroundColor = "#A6C39E";

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
          "specimen": icObj__specimen,

          "reictangle": icMNReictangle,
          "label": label,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.c_type = "counter";

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;

        const icCounter_spec = {

        };

        const icCounter = Object.assign(icComposite, icCounter_spec);

        //arrange parts once added
        // infiniteCanvas.onceOnAddRepresentedForIcObject(icCounter, (icCounter) => {
        //
        //   const rep_free__icCounter = infiniteCanvas.getRepresented(icCounter.id).r_free();
        //
        //   const rep_free__touchSlot   = rep_free__icCounter.parts.touchSlot;
        //   const rep_free__facade      = rep_free__icCounter.parts.facade;
        //
        //   const rep_free__specimen    = rep_free__icCounter.parts.specimen;
        //   const rep_free__reictangle  = rep_free__icCounter.parts.reictangle;
        //   const rep_free__label       = rep_free__icCounter.parts.label;
        //
        //   rep_free__touchSlot.isMobile = true;
        //   rep_free__touchSlot.position = Object.assign({}, rep_free__icCounter.position);
        //   rep_free__touchSlot.isMobile = false;
        //
        //   rep_free__facade.isMobile = true;
        //   rep_free__facade.position = Object.assign({}, rep_free__icCounter.position);
        //   rep_free__facade.isMobile = false;
        //
        //   // rep_free__specimen.isMobile = true;
        //   // rep_free__specimen.position = Object.assign({}, rep_free__icCounter.position);
        //   // rep_free__specimen.isMobile = false;
        //
        //
        //   rep_free__reictangle.isMobile = true;
        //   rep_free__reictangle.position = {
        //     x: rep_free__specimen.position.x,
        //     y: rep_free__specimen.position.y - 100,
        //   };
        //   rep_free__reictangle.isMobile = false;
        //
        //   rep_free__label.isMobile = true;
        //   rep_free__label.position = {
        //     x: rep_free__specimen.position.x - 100,
        //     y: rep_free__specimen.position.y + 100,
        //   };
        //   rep_free__label.isMobile = false;
        //
        // });

        return icCounter;
      }




      // createIcSparkle(trueRect, img, sparkleConfig) {
      createIcSparkle(truePoint, img, sparkleConfig) {
        // console.log("createIcSparkle", truePoint, sparkleConfig);

        const type = "sparkle";

        // const position = Geometry.getPointTL(trueRect);
        // const size     = Geometry.createSize(trueRect.width, trueRect.height);
        // const center = Geometry.getCenterPoint(trueRect);
        const position = {
          x: truePoint.x,
          y: truePoint.y,
        };
        const size = Geometry.createSize(img.width, img.height);

        const homeScale = {
          // X: this.scale.X * 10,
          // Y: this.scale.Y * 10,
          X: this.scale.X,
          Y: this.scale.Y,
        };

        const icObj = this.createIcObject(type, position, size, homeScale);



        const icSparkle_spec = {
          isUsingCenterPosition: true,
          // center: center,

          homeScale_max: 10000,
          homeScale_min: 0,

          img: img,

          isSnappable: false,
        };

        const icSparkle = Object.assign(icObj, icSparkle_spec);

        return icSparkle;
      }

      debug_sparkleAnims(isAnimPaused) {
        console.log("debug_sparkleAnims(", isAnimPaused, ")");

        const arr_sparkles = Object.values(this.represented)
          .map(represented => {
            // return represented.r_official();
            return represented.r_free();
          })
          .filter(rep => {
            const isSparkle = (rep.type == "sparkle");
            return isSparkle;
          });

        arr_sparkles.forEach((rep, i) => {
          rep.isAnimPaused = isAnimPaused;

          const animation = rep.animation;
          const progress = animation.progress / 100.0;
          console.log("debug_sparkleAnims: progress", progress);

          if (isAnimPaused) {
            animation.pause();
          } else {
            animation.play();
          }
        });
      }




      createIcTouchSlot(trueRect, touchSlotConfig) {
        console.log("createIcTouchSlot", trueRect, touchSlotConfig);

        const infiniteCanvas = this;

        const type = "touchSlot";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icTouchSlot_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 3,

          touchSlotConfig: touchSlotConfig,
        };

        const icTouchSlot = Object.assign(icObj, icTouchSlot_spec);


        const engine = new TouchSlotEngine();
        const eType = "touchSlot";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icTouchSlot, eType, engine);

        //debug: hot-mutating touchSlotConfig
        // setTimeout(() => {
        //
        //   const represented = infiniteCanvas.getRepresented(icEngined.id);
        //   const rep_free    = represented.r_free();
        //
        //   rep_free.touchSlotConfig = {
        //     transformationFunc: (icObj) => {
        //       icObj.fill = "orange";
        //     },
        //   };
        //
        // }, 10000);

        return icEngined;
      }


      createIcDropTouchSlot(trueRect, touchSlotConfig_in = null, engine_in = null) {
        console.log("createIcTouchSlot", trueRect, touchSlotConfig);

        const infiniteCanvas = this;

        const type = "dropTouchSlot";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        var touchSlotConfig;
        if (touchSlotConfig_in != null) {
          touchSlotConfig = touchSlotConfig_in;
        } else {
          const icObjToIcObjFunc = (new GMOperatorTextChangeEngine()).transformationFuncForText("+ 1");
          const transformationFunc = (icObj) => {
            const icObj__sadness = icObjToIcObjFunc(icObj);
            const transformationOutput = new TransformationOutput("sadness", icObj__sadness, icObj);
            return transformationOutput;
          };

          touchSlotConfig = {
            transformationFunc__touch: transformationFunc,
            transformationFunc__untouch: transformationFunc,
          };
        }

        const icDropTouchSlot_spec = {
          isSnappable: false,

          fill: "#226699",

          stroke: "purple",
          strokeWidth: 3,

          touchSlotConfig: touchSlotConfig,
        };

        const icDropTouchSlot = Object.assign(icObj, icDropTouchSlot_spec);


        var engine;
        if (engine_in != null) {
          engine = engine_in;
        } else {
          engine = new DropTouchSlotEngine();
        }
        const eType = "dropTouchSlot";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icDropTouchSlot, eType, engine);

        return icEngined;
      }


      createIcCollection(trueRect, collectionConfig) {
        console.log("createIcCollection", trueRect, collectionConfig);

        const infiniteCanvas = this;

        function createPartsDict(collectionConfig) {

          function trueRectForPartIndex(index) {
            const outTrueRect = {
              x: trueRect.x + 200 + index * 100 / infiniteCanvas.scale.X,
              y: trueRect.y,
              width: trueRect.width,
              height: trueRect.height,
            };

            return outTrueRect;
          }

          const nb_elements = collectionConfig.max - collectionConfig.min + 1;
          const arr_numbers = Array.from({ length: nb_elements }, (_, i) => i + collectionConfig.min)

          const arr_entries = arr_numbers.map((number, index) => {
            const trueRect__icObj = trueRectForPartIndex(index);
            const mathNode = new math.ConstantNode(number);
            const icObj = infiniteCanvas.createIcMathNode(trueRect__icObj.x, trueRect__icObj.y, mathNode);

            const name__element = "part_" + index;
            return [name__element, icObj];
          });

          const partsDict = Object.fromEntries(arr_entries);

          return partsDict;
        }

        const parts = createPartsDict(collectionConfig);

        const compositeConfig = Object.entries(parts).reduce((acc, [partName, part], index) => {
          // const isMobile = (index != 0);
          const isMobile = true;

          // acc[partName] = {
          acc[part.id] = {
            isMobile: isMobile,
          };
          return acc;
        }, {});

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);

        icComposite.isCollection = true;
        icComposite.isTouchable = true;

        return icComposite;
      }


      // createIcComposite(parts, engine) {
      createIcComposite_debug(trueRect) {
        console.log("createIcComposite_debug", trueRect);


        function createPartsDict() {
          // const part1_trueRect = trueRect;
          const part1_trueRect = {
            x: trueRect.x + 400,
            y: trueRect.y + 50,
            width: trueRect.width,
            height: trueRect.height,
          };
          const part1_icObj = infiniteCanvas.createIcRect(part1_trueRect);
          part1_icObj.fill = "cyan";

          // const part2_trueRect = {
          //   x:      trueRect.x + 400,
          //   y:      trueRect.y + 50,
          //   width:  trueRect.width,
          //   height: trueRect.height,
          // };
          const part2_trueRect = part1_trueRect;
          const part2_icObj = infiniteCanvas.createIcRect(part2_trueRect);
          part2_icObj.fill = "orange";

          const part3_trueRect = part1_trueRect;
          const part3_icObj = infiniteCanvas.createIcRect(part2_trueRect);
          part3_icObj.fill = "magenta";

          const partsDict = {
            "part1": part1_icObj,
            "part2": part2_icObj,
            "part3": part3_icObj,
          };

          return partsDict;
        }

        const parts = createPartsDict();

        const compositeConfig = Object.entries(parts).reduce((acc, [partName, part], index) => {
          const isMobile = (index != 0);
          // acc[partName] = {
          acc[part.id] = {
            isMobile: isMobile,
          };
          return acc;
        }, {});

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);

        return icComposite;
      }


      createIcComposite(trueRect, parts, compositeConfig) {
        console.log("createIcComposite", trueRect);

        const infiniteCanvas = this;

        const type = "composite";

        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);
        const icObj = this.createIcObject(type, position, size, homeScale);


        const icComposite_spec = {
          isSnappable: false,

          // stroke: "red",
          // strokeWidth: 4,

          fill: "pink",

          parts: parts,
          compositeConfig: compositeConfig,
        };

        const icComposite = Object.assign(icObj, icComposite_spec);

        const engine = new CompositeEngine();
        const eType = "composite";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icComposite, eType, engine);


        return icEngined;
      }


      createIcBloom(trueRect, core, facets, compositeConfig) {
        console.log("createIcBloom", trueRect, core, facets, compositeConfig);

        const infiniteCanvas = this;

        const parts = [core, ...facets];
        const icComposite = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "bloom";

        const icBloom_spec = {
          core: core,
          facets: facets,
        };

        const icBloom = Object.assign(icComposite, icBloom_spec);

        return icBloom;
      }

      createIcCore(icObj) {
        console.log("createIcCore", icObj);

        const infiniteCanvas = this;


        const trueRect__touchSlot = {
          x: icObj.position.x + 100,
          y: icObj.position.x + 100,
          width: 100,
          height: 100,
        };
        const touchSlotConfig = {
          transformationFunc: function (icObj) {

            //will be set later in CoreEngine

            return new TransformationOutput("mutated", icObj, icObj);
          },
        };
        const icTouchSlot = infiniteCanvas.createIcTouchSlot(trueRect__touchSlot, touchSlotConfig);
        icTouchSlot.fill = "pink";
        icTouchSlot.opacity = 0.4;

        const trueRect__ghost = {
          x: icObj.position.x + 200,
          y: icObj.position.x - 200,
          width: 100,
          height: 100,
        };
        const icGhost = infiniteCanvas.createIcGhost(trueRect__ghost);
        icGhost.fill = "black";
        icGhost.opacity = 0.2;


        const parts = {
          specimen: icObj,
          touchSlot: icTouchSlot,
          ghost: icGhost,
        };
        const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
        const trueRect__core = {
          x: icObj.position.x + 100,
          y: icObj.position.x - 100,
          width: 100,
          height: 100,
        };
        const icComposite = infiniteCanvas.createIcComposite(trueRect__core, parts, compositeConfig);
        icComposite.cType = "core";


        const icCore_spec = {

        };

        var icCore = Object.assign(icComposite, icCore_spec);
        icCore.fill = "lime";
        icCore.opacity = 0.4;


        const coreEngine = new CoreEngine();
        const icEngined = infiniteCanvas.installEngineOnIcObj(icCore, "core", coreEngine);

        //so: core has 2 engines: CompositeEngine and CoreEngine

        return icEngined;
      }

      createIcGhost(trueRect) {
        console.log("createIcGhost", trueRect);

        const infiniteCanvas = this;

        const parts = {};
        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        const icComposite = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "ghost";

        const icGhost_spec = {

        };

        const icGhost = Object.assign(icComposite, icGhost_spec);

        return icGhost;
      }



      createIcTag(left, top, text) {

        const type = "tag";
        const position = Geometry.createPoint(left, top);
        const size = Geometry.createSize(0, 0);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        // const text     = "icText";
        const fontSize = 100;

        const icTag_spec = {
          text: text,
          textColor: "black",
          fontSize: fontSize,
        };

        const icTag = Object.assign(icObj, icTag_spec);

        return icTag;
      }

      createIcLabelValue(trueRect, text, value) {
        console.log("createIcLabelValue", trueRect, text, value);

        const infiniteCanvas = this;

        const icObj__label = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        icObj__label.fill = "";

        const icObj__value = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "" + value);
        icObj__value.fill = "";

        const parts = {
          "label": icObj__label,
          "value": icObj__value,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "labelValue";
        icComposite.fill = "";



        //put value on right side of label
        // infiniteCanvas.onceOnAddRepresentedForIcObject(icComposite, (icComposite) => {
        // logger.log("infiniteCanvas.onceOnAddRepresentedForIcObject", icComposite);
        setTimeout(() => {

          const labelValue__represented = infiniteCanvas.getRepresented(icComposite.id);
          const labelValue__rep_free = labelValue__represented.r_free();


          const label__rep_free = labelValue__rep_free.parts["label"];
          const value__rep_free = labelValue__rep_free.parts["value"];
          // logger.log("label__rep_free", label__rep_free);
          // logger.log("value__rep_free", value__rep_free);


          labelValue__rep_free.compositeConfig[value__rep_free.id].isMobile = true;

          const spacing = 50;
          value__rep_free.position = {
            x: label__rep_free.position.x + label__rep_free.size.width + spacing,
            y: value__rep_free.position.y,
          };

          labelValue__rep_free.compositeConfig[value__rep_free.id].isMobile = false;


          // });
        }, 10);   //SHU TODO: remove this ugliness


        return icComposite;
      }


      createIcButton(trueRect, buttonConfig_in) {
        console.log("createIcButton", trueRect, buttonConfig_in);

        const infiniteCanvas = this;

        const type = "button";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        var buttonConfig;
        if (buttonConfig_in == null) {
          buttonConfig = {
            buttonFunc: (scopeObj) => {
              console.log("buttonFunc", scopeObj);
              const button = scopeObj.engineCarrier;
              button.fill = ColorUtils.randomColor();
            },
          };
        }

        const icButton_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 1,
          fill: "lightgray",

          buttonConfig: buttonConfig,
        };

        const icButton = Object.assign(icObj, icButton_spec);


        const engine = new ButtonEngine();
        const eType = "button";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icButton, eType, engine);

        return icEngined;
      }

      createIcClickWell(trueRect, value_in = -48) {
        console.log("createIcClickWell", trueRect);

        const infiniteCanvas = this;

        // const type      = "clickWell";
        const type = "button";

        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const buttonFunc = (scopeObj) => {
          console.log("buttonFunc", scopeObj);
          const button = scopeObj.engineCarrier;
          button.fill = ColorUtils.randomColor();

          //create/add new spawn
          const infiniteCanvas = scopeObj.infiniteCanvas;

          const trueRect = {
            x: button.position.x,
            y: button.position.y,
            width: button.size.width,
            height: button.size.height,
          };

          // const spawn = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "spawn");
          // const spawn = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "12");

          const mathNode = new math.ConstantNode(value_in);
          mathNode.autoSimplify = true;
          const spawn = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);


          infiniteCanvas.addIcObject(spawn);


          //set spawn as active object
          const spawn__represented = infiniteCanvas.getRepresented(spawn.id);
          const spawn__rep_free = spawn__represented.r_free();

          infiniteCanvas.setActiveObject(spawn__rep_free);
        };

        const buttonConfig = {
          buttonFunc: buttonFunc,
        };


        const icButton_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 1,
          fill: "lightgray",

          buttonConfig: buttonConfig,
        };

        const icButton = Object.assign(icObj, icButton_spec);


        const engine = new ButtonEngine();
        const eType = "button";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icButton, eType, engine);

        return icEngined;
      }

      setActiveObject(icObj) {
        icObj.im_active_now = true;
      }

      createIcPlatform(trueRect) {
        console.log("createIcPlatform", trueRect);

        const infiniteCanvas = this;

        const parts__terrace = {};
        const compositeConfig__terrace = Compositer.defaultCompositeConfig(parts__terrace, false);
        const icComposite__terrace = infiniteCanvas.createIcComposite(trueRect, parts__terrace, compositeConfig__terrace);


        const dropTouchSlotEngine__platformEdition = new DropTouchSlotEngine();
        dropTouchSlotEngine__platformEdition.isObjectIgnored = function (incomingObj) {
          logger.log("dropTouchSlotEngine__platformEdition.isObjectIgnored", incomingObj);
          // return false;
          const isTerrace = (incomingObj.id != icComposite__terrace.id);
          return !isTerrace;
        };
        dropTouchSlotEngine__platformEdition.virgin = Object.assign({}, dropTouchSlotEngine__platformEdition);  //virgin == not bound

        const icDropTouchSlot = infiniteCanvas.createIcDropTouchSlot(trueRect, null, dropTouchSlotEngine__platformEdition);


        const parts = {
          dropTouchSlot: icDropTouchSlot,       //landing
          terrace: icComposite__terrace,  //sitting
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "platform";
        // icComposite.isTouchable = false;


        // const engine = new PlatformEngine();
        // const eType  = "platform";
        //
        // const icEngined = infiniteCanvas.installEngineOnIcObj(icComposite, eType, engine);

        // const icPlatform = icEngined;
        const icPlatform = icComposite;

        //rework
        infiniteCanvas.onceOnAddRepresentedForIcObject(icPlatform, (icPlatform) => {

          const rep_free__platform = infiniteCanvas.getRepresented(icPlatform.id).r_free();

          // const icObjToIcObjFunc = (new GMOperatorTextChangeEngine()).transformationFuncForText("+ 4");
          // const transformationFunc = (icObj) => {
          //   const icObj__sadness = icObjToIcObjFunc(icObj);
          //   const transformationOutput = new TransformationOutput("sadness", icObj__sadness, icObj);
          //   return transformationOutput;
          // };
          // rep_free__platform.parts.dropTouchSlot.touchSlotConfig.transformationFunc = transformationFunc;

          const transformationFunc__touch = (icObj) => {
            // const icObj__sadness = icObjToIcObjFunc(icObj);

            logger.log("transformationFunc__touch", icObj);

            rep_free__platform.parts.terrace.dict_engine["composite"].engine.awoken.addPart(icObj);

            const transformationOutput = new TransformationOutput("displaced", icObj, icObj);
            return transformationOutput;
          };
          rep_free__platform.parts.dropTouchSlot.touchSlotConfig.transformationFunc__touch = transformationFunc__touch;

          const transformationFunc__untouch = (icObj) => {
            // const icObj__sadness = icObjToIcObjFunc(icObj);

            rep_free__platform.parts.terrace.dict_engine["composite"].engine.awoken.removePart(icObj);

            const transformationOutput = new TransformationOutput("displaced", icObj, icObj);
            return transformationOutput;
          };
          rep_free__platform.parts.dropTouchSlot.touchSlotConfig.transformationFunc__untouch = transformationFunc__untouch;


        });

        return icPlatform;
      }


      createIcConductiveOperator(trueRect, mathOperatorSymbol_in = "+", cfg_in = null) {
        console.log("createIcConductiveOperator", trueRect);

        var cfg = cfg_in;
        if (cfg == null) {
          cfg = {
            isRetaining: false,
          };
        }

        const trueRect__platform = Object.assign({}, trueRect, { width: 300, height: 300 });
        const icPlatform = infiniteCanvas.createIcPlatform(trueRect__platform);
        infiniteCanvas.addIcObject(icPlatform);                         //SHU: workaround.  One day, find out how to create fresh composite containing fresh composite

        const touchSlotConfig = {
          transformationFunc: function (icObj) {
            // logger.log("transformationFunc, default", icObj);
            return new TransformationOutput("mutated", icObj, icObj);
            // return icObj;
          },
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;



        const text = mathOperatorSymbol_in;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "platform": icPlatform,
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "conductive_operator";
        // icComposite.isTouchable = false;


        const icConductiveOperator = icComposite;

        //rework
        infiniteCanvas.onceOnAddRepresentedForIcObject(icConductiveOperator, (icConductiveOperator) => {

          const rep_free__conductiveOperator = infiniteCanvas.getRepresented(icConductiveOperator.id).r_free();

          // const rep_free__platform = rep_free__conductiveOperator.parts.platform;
          // logger.log("rep_free__platform", rep_free__platform);

          const rep_free__touchSlot = rep_free__conductiveOperator.parts.touchSlot;

          const mathOperatorSymbol = mathOperatorSymbol_in;

          switch (mathOperatorSymbol) {
            case "+":
            case "-":
            case "x":
            case "/":
              {
                const gmOperatorTextChangeEngine = new GMOperatorTextChangeEngine();
                const mathOperatorFuncName = gmOperatorTextChangeEngine.mathOperatorFuncNameForSymbol(mathOperatorSymbol);

                const transformationFunc = (icObj) => {
                  var transformationOutput;

                  logger.log("transformationFunc__touch", icObj);

                  const rep_free__platform = rep_free__conductiveOperator.parts.platform;
                  logger.log("rep_free__platform", rep_free__platform);

                  // const icObj__sadness = icObjToIcObjFunc(icObj);

                  const conducted_operands = rep_free__platform.parts.terrace.parts;
                  const arr_conducted_operands = Object.values(conducted_operands);

                  if (arr_conducted_operands.length > 0) {

                    if (icObj.type == "mathNode") {

                      //check if transformation is allowed
                      function isTransformationAllowed_atomic(mathNode_a, mathNode_b) {
                        var outBool;

                        //fractions mode
                        if (MathUtils.isFraction(mathNode_a) && MathUtils.isFraction(mathNode_b)) {

                          const mathNode__denominator_a = mathNode_a.args[1];
                          const mathNode__denominator_b = mathNode_b.args[1];

                          const isSameDenominator = (mathNode__denominator_a.value == mathNode__denominator_b.value);   //SHU: this should be improved (symbols, parentheses...)

                          outBool = isSameDenominator;

                        } else {
                          outBool = true;
                        }

                        return outBool;
                      }

                      const arr_conducted_mathNodes = arr_conducted_operands.filter(icObj => icObj.type == "mathNode").map(icObj => icObj.mathNode);
                      logger.log("arr_conducted_mathNodes", arr_conducted_mathNodes);

                      const mathNode__initial = icObj.mathNode.cloneDeep();
                      mathNode__initial.autoSimplify = icObj.mathNode.autoSimplify;

                      const isTransformationAllowed = Utils.early_break_reduce(arr_conducted_mathNodes, (acc, x, i, arr) => {
                        return acc && isTransformationAllowed_atomic(mathNode__initial, x);
                      }, true, (acc, x, i, arr) => {
                        return (acc == false);
                      });

                      if (isTransformationAllowed) {

                        // const mathNode__new = arr_conducted_mathNodes.reduce((acc, mathNode_conducted) => {
                        const mathNode__new = arr_conducted_operands.reduce((acc, icObj_conducted) => {

                          const mathNode__acc = acc;
                          const mathNode_conducted = icObj_conducted.mathNode;

                          if (!cfg.isRetaining) {
                            rep_free__platform.parts.terrace.dict_engine["composite"].engine.awoken.removePart(icObj_conducted);
                            icObj_conducted.im_dying_now = true;
                          }

                          const transformationFunc = gmOperatorTextChangeEngine.createTransformationFunc(mathOperatorSymbol, mathOperatorFuncName, mathNode_conducted);

                          const transformationFunc__decorated = function (mathNode) {
                            var outMathNode;

                            outMathNode = transformationFunc(mathNode);

                            return outMathNode;
                          };

                          //SHU: addition de fractions:
                          // const transformationFunc__decorated = function(mathNode) {
                          //   var outMathNode;
                          //
                          //   // outMathNode = transformationFunc(mathNode);
                          //   // outMathNode = Simplifier.simplify_fraction(outMathNode);
                          //
                          //   logger.log("mathNode__acc", mathNode__acc);
                          //
                          //   const mathNode_numerator__acc       = mathNode__acc.args[0];
                          //   const mathNode_numerator__conducted = mathNode_conducted.args[0];
                          //
                          //   const value__numerator      = mathNode_numerator__acc.value + mathNode_numerator__conducted.value;
                          //   const mathNode__numerator   = new math.ConstantNode(value__numerator);
                          //   const mathNode__denominator = mathNode__acc.args[1];
                          //
                          //   outMathNode = new math.OperatorNode("/", "divide", [mathNode__numerator, mathNode__denominator]);
                          //
                          //   return outMathNode;
                          // };

                          acc = transformationFunc__decorated(acc);

                          return acc;
                        }, mathNode__initial);
                        logger.log("mathNode__new", mathNode__new);

                        const icObj__new = icObj.clone();
                        icObj__new.mathNode = mathNode__new;

                        transformationOutput = new TransformationOutput("mutated", icObj__new, icObj);

                      } else {
                        transformationOutput = new TransformationOutput("old", icObj, icObj);
                      }

                    } else {
                      transformationOutput = new TransformationOutput("old", icObj, icObj);
                    }

                  } else {
                    icObj.fill = ColorUtils.randomColor();
                    // icObj.mathNode = new math.ConstantNode(42);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc;
              }
              break;

            case "randInBag":
              {
                const transformationFunc = (icObj) => {
                  var transformationOutput;

                  logger.log("transformationFunc__touch", icObj);

                  const rep_free__platform = rep_free__conductiveOperator.parts.platform;
                  logger.log("rep_free__platform", rep_free__platform);

                  // const icObj__sadness = icObjToIcObjFunc(icObj);

                  const conducted_operands = rep_free__platform.parts.terrace.parts;
                  const arr_conducted_operands = Object.values(conducted_operands);

                  switch (arr_conducted_operands.length) {
                    case 0:
                      {
                        icObj.fill = ColorUtils.randomColor();
                        // icObj.mathNode = new math.ConstantNode(42);
                        transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                      }
                      break;

                    case 1:
                      {
                        const isBag = (arr_conducted_operands[0].type == "composite");
                        if (isBag) {

                          const icObj__bag = arr_conducted_operands[0];

                          const arr_part = Object.values(icObj__bag.parts)
                            .filter(icObj__part => !icObj__part.isCosmetic);

                          const part__random = Utils.randomElementInArray(arr_part);

                          var icObj__new;
                          if (cfg.isConsume) {
                            //remove part
                            const rep_free__parent = infiniteCanvas.getRepresented(part__random.compositeId).r_free();
                            rep_free__parent.dict_engine["composite"].engine.awoken.removePart(part__random);

                            icObj__new = part__random;

                            //destroy bag if emptied
                            {
                              const arr_remaining = Object.values(rep_free__parent.parts)
                                .filter(icObj__part => !icObj__part.isCosmetic);

                              if (arr_remaining.length == 0) {

                                // //remove bag from platform's terrace
                                // const rep_free__terrace = infiniteCanvas.getRepresented(rep_free__parent.compositeId).r_free();
                                // rep_free__terrace.engine.awoken.removePart(rep_free__parent);

                                // rep_free__parent.shouldAlsoRemoveChildren = true;

                                rep_free__parent.im_dying_now = true;
                              }
                            }


                          } else {
                            const icObj__clone = infiniteCanvas.createReplicant(part__random);
                            icObj__new = icObj__clone;
                          }

                          // icObj__new.position = Object.assign({}, icObj.position);

                          transformationOutput = new TransformationOutput("new", icObj__new, icObj);

                        } else {
                          const part__random = arr_conducted_operands[0];

                          const icObj__clone = infiniteCanvas.createReplicant(part__random);
                          icObj__new = icObj__clone;

                          transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                        }
                      }
                      break;

                    default:  //manage objects put directly on platform     //SHU: TODO: flatten atoms and composites
                      {
                        const arr_part = arr_conducted_operands;

                        //debug
                        {
                          const arr_values = arr_part.map(x => {
                            var outValue;

                            const mathNode = x.mathNode;
                            logger.log("mathNode", mathNode);
                            if (mathNode != null) {
                              outValue = mathNode.value;
                            }

                            return outValue;
                          });
                          logger.log("arr_values", arr_values);
                        }

                        const part__random = Utils.randomElementInArray(arr_part);

                        var icObj__new;
                        if (cfg.isConsume) {
                          //remove part
                          const rep_free__parent = infiniteCanvas.getRepresented(part__random.compositeId).r_free();
                          rep_free__parent.dict_engine["composite"].engine.awoken.removePart(part__random);

                          icObj__new = part__random;
                        } else {
                          const icObj__clone = infiniteCanvas.createReplicant(part__random);
                          icObj__new = icObj__clone;
                        }

                        // icObj__new.position = Object.assign({}, icObj.position);

                        transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                      }
                      break;
                  }

                  return transformationOutput;
                };

                rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc;
              }
              break;
            default:
              throw new Error("Unsupported mathOperatorSymbol: " + mathOperatorSymbol);
              break;
          }




        });

        return icConductiveOperator;
      }


      createIcFractionOneOperator(trueRect, operatorNodeFactoryFuncWrapper_in = null, isSimplifying = true) {

        var operatorNodeFactoryFuncWrapper;
        if (operatorNodeFactoryFuncWrapper_in != null) {
          operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_in;
        } else {
          const op = Operator.fromString_binary("x");
          const node_b = new math.ConstantNode(2);
          operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);
        }

        const touchSlotConfig = {
          transformationFunc: function (icObj) {
            var transformationOutput;

            if (icObj.type == "mathNode") {

              var mathNode__input = icObj.mathNode;

              // const isFraction = MathUtils.isFraction(mathNode__input);
              const isFraction = mathNode__input.type == "OperatorNode" && mathNode__input.fn == "divide";
              if (!isFraction) {
                mathNode__input = new math.OperatorNode("/", "divide", [mathNode__input, new math.ConstantNode(1)]);
              }

              const mathNode__input__numerator = mathNode__input.args[0];
              const mathNode__input__denominator = mathNode__input.args[1];

              const operatorNodeFunc = operatorNodeFactoryFuncWrapper.func;

              // var mathNode__output__numerator   = new math.OperatorNode("x", "multiply", [mathNode__input__numerator,   mathNode__factor]);
              var mathNode__output__numerator = operatorNodeFunc(mathNode__input__numerator);
              if (isSimplifying) {
                mathNode__output__numerator = Simplifier.simplify_fraction(mathNode__output__numerator);
              }

              // var mathNode__output__denominator = new math.OperatorNode("x", "multiply", [mathNode__input__denominator, mathNode__factor]);
              var mathNode__output__denominator = operatorNodeFunc(mathNode__input__denominator);
              if (isSimplifying) {
                mathNode__output__denominator = Simplifier.simplify_fraction(mathNode__output__denominator);
              }

              var mathNode__output = new math.OperatorNode("/", "divide", [mathNode__output__numerator, mathNode__output__denominator]);
              if (isSimplifying) {
                if (mathNode__output__denominator.value == 1) {
                  mathNode__output = mathNode__output__numerator;
                }
              }

              const icObj__new = icObj.clone();
              icObj__new.mathNode = mathNode__output;

              transformationOutput = new TransformationOutput("mutated", icObj__new, icObj);

            } else {
              transformationOutput = new TransformationOutput("old", icObj, icObj);
            }

            return transformationOutput;
          },
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;


        // const value = mathNode__factor.value;
        const operation = operatorNodeFactoryFuncWrapper.semantics.name;

        // const text         = "x" + "(" + value + "/" + value + ")";
        // const facade       = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        // const tex = '\\times \\frac{' + value +  '}{' + value + '}';
        const tex = '\\frac{\\ ' + operation + '}{\\ ' + operation + '}';

        const facade = infiniteCanvas.createIcTex(trueRect.x, trueRect.y, tex);
        facade.size = {
          width: 100,
          height: 100,
        };

        facade.backgroundColor = "orange";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };
        // touchSlot.zIndex = facade.zIndex - 1;

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "fractionOne_operator";
        // icComposite.isTouchable = false;

        const icFractionOneOperator = icComposite;

        return icFractionOneOperator;
      }




      createIcConductiveCompositingOperator(trueRect) {
        logger.log("createIcConductiveCompositingOperator", trueRect);

        const icPlatform = infiniteCanvas.createIcPlatform(trueRect);
        infiniteCanvas.addIcObject(icPlatform);                         //SHU: workaround.  One day, find out how to create fresh composite containing fresh composite

        const touchSlotConfig = {
          transformationFunc: function (icObj) {
            // logger.log("transformationFunc, default", icObj);
            return new TransformationOutput("mutated", icObj, icObj);
            // return icObj;
          },
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const parts = {
          "platform": icPlatform,
          "touchSlot": touchSlot,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "conductive_compositing_operator";
        // icComposite.isTouchable = false;


        const icConductiveCompositingOperator = icComposite;

        //rework
        infiniteCanvas.onceOnAddRepresentedForIcObject(icConductiveCompositingOperator, (icConductiveCompositingOperator) => {

          const rep_free__conductiveCompositingOperator = infiniteCanvas.getRepresented(icConductiveCompositingOperator.id).r_free();

          const rep_free__touchSlot = rep_free__conductiveCompositingOperator.parts.touchSlot;

          const transformationFunc = (icObj) => {
            var transformationOutput;

            logger.log("transformationFunc__touch", icObj);

            const rep_free__platform = rep_free__conductiveCompositingOperator.parts.platform;
            logger.log("rep_free__platform", rep_free__platform);

            const dict__conducted_operators = rep_free__platform.parts.terrace.parts;
            const arr__conducted_operators = Object.values(dict__conducted_operators);

            transformationOutput = new TransformationOutput("old", icObj, icObj);

            if (arr__conducted_operators.length > 0) {

              const arr__operations = arr__conducted_operators.map(icObj__operator => {
                logger.log("icObj__operator", icObj__operator);
                const operation = icObj__operator.operation;
                return operation;
              });

              transformationOutput = arr__operations.reduce((acc, operation) => {
                var transformationOutput__step;

                logger.log("operation", operation);
                const transformationOutput__previousStep = acc;
                const input = transformationOutput__previousStep.value;

                transformationOutput__step = operation.transformationFunc(input);

                return transformationOutput__step;
              }, transformationOutput);

              logger.log("transformationOutput", transformationOutput);
            }

            return transformationOutput;
          };

          rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc;

        });

        return icConductiveCompositingOperator;
      }





      createIcGMClickWell(trueRect, value_in = -48) {
        console.log("createIcClickWell", trueRect);

        const infiniteCanvas = this;

        // const type      = "clickWell";
        const type = "button";

        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const buttonFunc = (scopeObj) => {
          console.log("buttonFunc", scopeObj);
          const button = scopeObj.engineCarrier;
          button.fill = ColorUtils.randomColor();

          //create/add new spawn
          const infiniteCanvas = scopeObj.infiniteCanvas;

          const spawn = infiniteCanvas.createIcGreenMouse(trueRect, value_in);

          infiniteCanvas.addIcObject(spawn);
        };

        const buttonConfig = {
          buttonFunc: buttonFunc,
        };


        const icButton_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 1,
          fill: "lightgray",

          buttonConfig: buttonConfig,
        };

        const icButton = Object.assign(icObj, icButton_spec);


        const engine = new ButtonEngine();
        const eType = "button";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icButton, eType, engine);

        return icEngined;
      }


      createIcGreenMouse(trueRect, value_in = 1) {
        console.log("createIcGreenMouse", trueRect);

        const infiniteCanvas = this;

        // const type      = "greenMouse";


        const mathNode = new math.ConstantNode(value_in);
        mathNode.autoSimplify = true;
        const spawn = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);



        infiniteCanvas.onceOnAddRepresentedForIcObject(spawn, (spawn) => {

          //set spawn as active object
          const spawn__represented = infiniteCanvas.getRepresented(spawn.id);
          const spawn__rep_free = spawn__represented.r_free();

          //greenMouseify
          infiniteCanvas.greenMouseify(spawn__rep_free);
          spawn__rep_free.onHold(() => {
            spawn__rep_free.curse_greenMouse_start();
          })

        });


        return spawn;
      }


      createIcBornAgainGreenMouse(trueRect, mathNode_in = new math.ConstantNode(1)) {
        console.log("createIcBornAgainGreenMouse", trueRect);

        const infiniteCanvas = this;

        // const type      = "bornAgainGreenMouse";


        const mathNode = mathNode_in;
        // mathNode.autoSimplify = true;

        const spawn = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        spawn.isTouchable = true;


        infiniteCanvas.onceOnAddRepresentedForIcObject(spawn, (spawn) => {

          //set spawn as active object
          const spawn__represented = infiniteCanvas.getRepresented(spawn.id);
          const spawn__rep_free = spawn__represented.r_free();

          //greenMouseify
          infiniteCanvas.greenMouseify(spawn__rep_free);
          spawn__rep_free.onHold(() => {
            spawn__rep_free.curse_greenMouse_start();
          });

          //bornAgainify
          infiniteCanvas.bornAgainify(spawn__rep_free);
          //spawn__rep_free.onHold(() => {
          spawn__rep_free.curse_bornAgain_start();
          //});

        });



        return spawn;
      }


      createIcGreenMouseBox(trueRect, mathNode_in = new math.ConstantNode(1)) {
        console.log("createIcBornAgainGreenMouseBox", trueRect);

        const infiniteCanvas = this;

        // const type      = "bornAgainGreenMouse";


        const mathNode = mathNode_in;
        // mathNode.autoSimplify = true;


        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        facade.isTouchable = false;
        const contactArea = infiniteCanvas.createIcRect(trueRect);
        contactArea.fill = "lightblue";

        const parts = {
          contactArea: contactArea,
          facade: facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_box";

        const greenMouseBox = icComposite;
        greenMouseBox.isTouchable = true;
        // greenMouseBox.canBeHeld   = true;


        infiniteCanvas.onceOnAddRepresentedForIcObject(greenMouseBox, (greenMouseBox) => {

          //set spawn as active object
          const greenMouseBox__represented = infiniteCanvas.getRepresented(greenMouseBox.id);
          const greenMouseBox__rep_free = greenMouseBox__represented.r_free();

          //greenMouseify
          const facade__rep_free = greenMouseBox__rep_free.parts.facade;

          greenMouseBox__rep_free.die = () => {
            greenMouseBox__rep_free.im_dying_now = true;
          };

          infiniteCanvas.greenMouseify(facade__rep_free);
          //rewrite greenMouse.die
          facade__rep_free.die = () => {
            // logger.log("greenMouse, die (override)");
            greenMouseBox__rep_free.die();
          };

          facade__rep_free.onHold(() => {
            // logger.log("greenMouseBox__rep_free", "curse_greenMouse_start");
            facade__rep_free.curse_greenMouse_start();
          });

        });

        return greenMouseBox;
      }

      createIcBornAgainGreenMouseBox(trueRect, mathNode_in = new math.ConstantNode(1)) {
        console.log("createIcBornAgainGreenMouseBox", trueRect);

        const infiniteCanvas = this;

        // const type      = "bornAgainGreenMouse";


        const mathNode = mathNode_in;
        // mathNode.autoSimplify = true;


        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        const contactArea = infiniteCanvas.createIcRect(trueRect);
        contactArea.fill = "lightblue";

        const parts = {
          contactArea: contactArea,
          facade: facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_box";

        const greenMouseBox = icComposite;
        greenMouseBox.isTouchable = true;


        infiniteCanvas.onceOnAddRepresentedForIcObject(greenMouseBox, (greenMouseBox) => {

          //set spawn as active object
          const greenMouseBox__represented = infiniteCanvas.getRepresented(greenMouseBox.id);
          const greenMouseBox__rep_free = greenMouseBox__represented.r_free();

          //greenMouseify
          infiniteCanvas.greenMouseify(greenMouseBox__rep_free);
          greenMouseBox__rep_free.onHold(() => {
            greenMouseBox__rep_free.curse_greenMouse_start();
          });

          //bornAgainify
          infiniteCanvas.bornAgainify(greenMouseBox__rep_free);
          //spawn__rep_free.onHold(() => {
          greenMouseBox__rep_free.curse_bornAgain_start();
          //});

        });



        return greenMouseBox;
      }



      createIcExoSkeleton(/*icObj__heart,*/ exoSkeletonConfig) {
        console.log("createIcExoSkeleton", /*icObj__heart,*/ exoSkeletonConfig);

        const infiniteCanvas = this;

        function easyTrueRectWithTrueRect(trueRect, position_easy) {
          var outTrueRect;

          const trueRect_clone = Object.assign({}, trueRect);
          switch (position_easy) {
            case "left":
              outTrueRect = trueRect_clone;
              outTrueRect.x = outTrueRect.x - outTrueRect.width;
              break;
            case "right":
              outTrueRect = trueRect_clone;
              outTrueRect.x = outTrueRect.x + outTrueRect.width;
              break;
            case "top":
              outTrueRect = trueRect_clone;
              outTrueRect.y = outTrueRect.y - outTrueRect.height;
              break;
            case "bottom":
              outTrueRect = trueRect_clone;
              outTrueRect.y = outTrueRect.y + outTrueRect.height;
              break;
            case "center":
              outTrueRect = trueRect_clone;
              break;
            default:
              throw new Error("Unsupported position_easy: " + position_easy);
              break;
          }

          return outTrueRect;
        }

        const trueRect__heart = {
          x: icObj__heart.position.x,
          y: icObj__heart.position.y,
          width: icObj__heart.size.width,
          height: icObj__heart.size.height,
        };


        const icObj__display = icObj__heart.deepClone();
        icObj__display.stroke = "red";
        icObj__display.strokeWidth = 5;



        const icObj__grab = infiniteCanvas.createIcRect(trueRect__heart);
        icObj__grab.fill = "green";
        const trueRect__grab = easyTrueRectWithTrueRect(trueRect__heart, exoSkeletonConfig.grab.position_easy);
        icObj__grab.position = {
          x: trueRect__grab.x,
          y: trueRect__grab.y,
        };

        const icObj__contact = infiniteCanvas.createIcRect(trueRect__heart);
        icObj__contact.fill = "lightblue";
        const trueRect__contact = easyTrueRectWithTrueRect(trueRect__heart, exoSkeletonConfig.contact.position_easy);
        icObj__contact.position = {
          x: trueRect__contact.x,
          y: trueRect__contact.y,
        };

        const parts = {
          heart: icObj__heart,

          display: icObj__display,
          grab: icObj__grab,
          contact: icObj__contact,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect__heart, parts, compositeConfig);
        icComposite.cType = "exoSkeleton";

        return icComposite;
      }








      createIcWell(trueRect) {
        console.log("createIcWell", trueRect);

        const startingValue = 1;

        const canSnapFunc = (above, below) => {
          var outBool;

          const canSnapFunc_geometryWise = (above, below) => {
            // return Snap.canSnap(above, below);
            return Snap.canSnap_noSize(above, below);
          };

          // const canSnapFunc_valueWise    = (above, below) => (above.value == targetValue);
          // const canSnapFunc_valueWise    = (above, below) => {
          //   const value = parseInt(above.text,10);
          //   const isValueValid = (value == targetValue);
          //   return isValueValid;
          // };

          const canSnapFuncs = {
            "geometry": canSnapFunc_geometryWise,
            // "value":    canSnapFunc_valueWise,
          };

          const canSnapFunc_allWise = (above, below) => Object.entries(canSnapFuncs).reduce((acc, [canSnapFunc_xWiseName, canSnapFunc_xWise]) => {
            const canSnap_xWise = canSnapFunc_xWise(above, below);
            console.log("canSnap_xWise", canSnapFunc_xWiseName, canSnap_xWise);
            return acc && canSnap_xWise;
          }, true);

          const canSnap_allWise = canSnapFunc_allWise(above, below);
          console.log("canSnap_allWise", canSnap_allWise);

          outBool = canSnap_allWise;

          return outBool;
        };
        const canUnsnapFunc = (above, below) => {
          return Snap.canUnsnap(above, below);
        };
        // const snapMutationFunc  = (above, below) => {   //SHU TODO: toSnapState mutations: toPresnapped, toSnapped, toUnsnapped
        //   //how rep_snapped  will differ from rep_official
        //   //how snappedState will differ from rep_official
        // };
        const snapSlotConfig = {
          canSnapFunc: canSnapFunc,
          canUnsnapFunc: canUnsnapFunc,
        };

        const snapSlot = infiniteCanvas.createIcSnapSlot(trueRect, snapSlotConfig);
        snapSlot.fill = "lightblue";
        snapSlot.isMobile = false;

        const text = startingValue.toString(10);
        const stem = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        stem.textColor = "blue";
        stem.backgroundColor = "";
        stem.isMobile = true;
        stem.isTouchable = true;

        const parts = {
          // "snapSlot": snapSlot,
          "stem": stem,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "well";

        // icComposite.isTouchable = false;


        // snapEngine.will['unsnap'].on((snapSlot, icObj) => {
        //   console.log("well, snapEngine.will['unsnap']", snapSlot, icObj);
        //
        //   const cloned = icObj.deepClone();
        //   cloned.snapState = SnapState.Unsnapped;
        //   cloned.position = Object.assign({}, snapSlot.position);
        //   infiniteCanvas.addIcObject(cloned);
        //
        //   // snapEngine.clonedObj = cloned;
        // });


        // infiniteCanvas.onceOnAddRepresentedForIcObject(stem, (stem) => {
        //
        //   //get free rep
        //   const represented = infiniteCanvas.getRepresented(stem.id);
        //   console.log("represented", represented);
        //   const rep_free = represented.r_free();
        //
        //   infiniteCanvas.greenMouseify(rep_free);
        //
        //   rep_free.curse_greenMouse_start();
        // });


        return icComposite;
      }






      greenMouseify(rep) {
        console.log("greenMouseify", rep);

        rep.die = () => {
          // logger.log("greenMouse, die");
          rep.im_dying_now = true;
        };

        rep.curse_greenMouse_do = (icObj) => {
          console.log("curse_greenMouse_do");
          rep.curse_greenMouse_end();
          rep.die();
        };

        rep.curse_greenMouse_start = () => {
          rep.onRelease(rep.curse_greenMouse_do);
        };

        rep.curse_greenMouse_end = () => {
          rep.offRelease(rep.curse_greenMouse_do);
        };

        // rep.curse_greenMouse_start = () => {
        //   if(rep.cType == "gm_box") {
        //     rep.parts.facade.onRelease(rep.curse_greenMouse_do);
        //   } else {
        //     rep.onRelease(rep.curse_greenMouse_do);
        //   }
        // };
        //
        // rep.curse_greenMouse_end = () => {
        //   if(rep.cType == "gm_box") {
        //     rep.parts.facade.offRelease(rep.curse_greenMouse_do);
        //   } else {
        //     rep.offRelease(rep.curse_greenMouse_do);
        //   }
        // };

      }


      bornAgainify(rep) {
        console.log("bornAgainify", rep);

        const infiniteCanvas = this;

        if (rep.die == null) {
          throw new Error("Can't resurrect what doesn't die");
        }
        Hooker.installHooks(rep, "die");

        if (rep.number_replica == null) {
          rep.number_replica = 0;
        }

        const stem = rep.clone();
        // stem.mathNode = rep.mathNode.cloneDeep();

        rep.prepareForResurrection = () => {

        };

        rep.resurrect = () => {
          console.log("resurrect");

          //born again
          const resurrected = stem.clone();
          // logger.log("resurrected", resurrected);
          resurrected.mathNode = stem.mathNode;

          const id_resurrected = this.generateIcObjectId();
          resurrected.id = id_resurrected;

          resurrected.number_replica = stem.number_replica + 1;

          infiniteCanvas.addIcObject(resurrected);


          //cursed again
          //SHU TODO: better management of curses
          const spawn__represented = infiniteCanvas.getRepresented(resurrected.id);
          const spawn__rep_free = spawn__represented.r_free();

          //greenMouseify
          infiniteCanvas.greenMouseify(spawn__rep_free);
          spawn__rep_free.onHold(() => {
            spawn__rep_free.curse_greenMouse_start();
          })

          //bornAgainify
          infiniteCanvas.bornAgainify(spawn__rep_free);
          spawn__rep_free.curse_bornAgain_start();

        };

        rep.curse_bornAgain_start = () => {
          rep.will["die"].on(rep.prepareForResurrection);
          rep.did["die"].on(rep.resurrect);
        };

        rep.curse_bornAgain_end = () => {
          rep.did["die"].off(rep.resurrect);
        };



        //not that easy to die
        // Object.defineProperty(rep, 'im_dying_now', {
        //   get() { return false; },
        //   set(newValue) { rep.lolilol = newValue; },
        //   enumerable: true,
        //   configurable: true
        // });

      }

      // createCurseTrigger_countdown() {
      //
      //   const curseTrigger = new CurseTrigger_countdown();
      //
      //   return curseTrigger;
      // }

      createCurse_metamorphosis(curseTrigger) {
        logger.log("createCurse_metamorphosis", curseTrigger);


        // const facade_represented = infiniteCanvas.getRepresented(facade.id);
        // const facade_rep_free    = facade_represented.r_free();
        //
        // const mathNode = new math.ConstantNode(stepIndex);
        // facade_rep_free.mathNode = mathNode;

        const curseFunc = (rep_free) => {
          // logger.log("curseFunc, rep_free:", rep_free);
          const mathNode = random_constantNode();
          rep_free.mathNode = mathNode;
        };

        const curse_metamorphosis = this.createCurse(curseTrigger);
        // logger.log("curse_metamorphosis.curseTrigger", curse_metamorphosis.curseTrigger);

        curse_metamorphosis.curseFunc = curseFunc;
        curse_metamorphosis.rx_countDownCounter = curseTrigger.engine.rx_countDownCounter;

        return curse_metamorphosis;
      }

      createCurse(curseTrigger) {
        // logger.log("createCurse", curseTrigger);

        const curse = new Curse(curseTrigger);

        return curse;
      }

      accurse__metamorphosis(rep_free) {
        const infiniteCanvas = this;

        const curseTrigger_countdown = new CurseTrigger_countdown();
        const curse_metamorphosis = this.createCurse_metamorphosis(curseTrigger_countdown);

        curse_metamorphosis.reset = function () {
          const curseTrigger_countdown = new CurseTrigger_countdown();
          curseTrigger_countdown.curse = curse_metamorphosis;

          curse_metamorphosis.curseTrigger = curseTrigger_countdown;
          curse_metamorphosis.rx_countDownCounter = curseTrigger_countdown.engine.rx_countDownCounter;


          // infiniteCanvas.accurse__metamorphosis(rep_free);   //SHU: does not work
        };

        rep_free.curse_metamorphosis = curse_metamorphosis;
      }




      createIcGreenMouseWell(trueRect) {

      }

      mutateGreenMouseWell__addReactivePart(icGreenMouseWell) {

      }


      createIcGMSafetyZone(trueRect) {
        logger.log("createIcGMSafetyZone", trueRect);

        const touchSlotConfig = {
          transformationFunc__touch: function (icObj) {
            var transformationOutput;

            logger.log("icGMSafetyZone, transformationFunc__touch", icObj);
            //debug
            // icObj.fill = ColorUtils.randomColor();

            const isGreenMouse = (icObj.die != null);

            if (isGreenMouse) {

              const rep_free__greenMouse = icObj;

              const bornAgainFunc = rep_free__greenMouse.bornAgainFunc;
              if (bornAgainFunc) {
                rep_free__greenMouse.did["die"].off(bornAgainFunc);
              }

              transformationOutput = new TransformationOutput("mutated", icObj, icObj);
            } else {
              transformationOutput = new TransformationOutput("old", icObj, icObj);
            }

            return transformationOutput;
          },
          transformationFunc__untouch: function (icObj) {
            var transformationOutput;

            logger.log("icGMSafetyZone, transformationFunc__untouch", icObj);
            //debug
            // icObj.fill = ColorUtils.randomColor();

            const isGreenMouse = (icObj.die != null);

            if (isGreenMouse) {

              const rep_free__greenMouse = icObj;

              const bornAgainFunc = rep_free__greenMouse.bornAgainFunc;
              if (bornAgainFunc) {
                rep_free__greenMouse.did["die"].on(bornAgainFunc);
              }

              transformationOutput = new TransformationOutput("mutated", icObj, icObj);
            } else {
              transformationOutput = new TransformationOutput("old", icObj, icObj);
            }

            return transformationOutput;
          },
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "honeydew";
        // touchSlot.isMobile = false;

        const icGMSafetyZone = touchSlot;

        return icGMSafetyZone;
      }



      createIcGMOperator(trueRect, operatorString_in = null) {
        console.log("createIcGMOperator", trueRect);

        var operatorConfig;
        if (operatorString_in == null) {
          const rank = this.getNextTouchSlotRank();
          operatorConfig = GMOperatorMama.operatorConfigForRank(rank);
        } else {
          const text_in = operatorString_in;
          // const transformationFunc_oldStyle = (new GMOperatorTextChangeEngine()).transformationFuncForText(text_in);

          // const transformationFunc = function(icObj) {
          //   var transformationOutput;
          //
          //   const icObj__mutated = transformationFunc_oldStyle(icObj);
          //   transformationOutput = new TransformationOutput("mutated", icObj__mutated, icObj);
          //
          //   return transformationOutput;
          // };

          const transformationFunc = (new GMOperatorTextChangeEngine()).transformationFuncForText(text_in);

          operatorConfig = new OperatorConfig(text_in, transformationFunc);
        }

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_operator";

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;

        // icComposite.isTouchable = false;

        return icComposite;
      }

      createIcGMOperator_withType(trueRect, gmOperatorType, cfg = {}) {
        console.log("createIcGMOperator_withType", trueRect, gmOperatorType);

        const infiniteCanvas = this;

        function operatorConfigForType(gmOperatorType) {

          var operatorConfig = {
            name: "",
            transformationFunc: null,
          };

          switch (gmOperatorType) {

            case "simplify":
              {
                operatorConfig.name = "s";
                const transformationFunc = (node_a) => {
                  var outNode;

                  function standardOperation(node_in) {
                    var outNode;

                    const node_unsimplified = node_in;

                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;

                    outNode.autoSimplify = node_in.autoSimplify;

                    return outNode;
                  }

                  if (node_a.isEquation) {
                    console.log("node_a", node_a);
                    const node_left = standardOperation(node_a.params[0]);
                    const node_right = standardOperation(node_a.params[1]);
                    const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    node_equation.isEquation = true;

                    outNode = node_equation;
                  } else {
                    outNode = standardOperation(node_a);
                  }

                  return outNode;
                };
                operatorConfig.transformationFunc = transformationFunc;
              }
              break;
            case "simplify__full":
              {
                operatorConfig.name = "sfull";
                const transformationFunc = (node_a) => {
                  var outNode;

                  function standardOperation(node_in) {
                    var outNode;

                    const node_unsimplified = node_in;

                    const node_simplified = Simplifier.simplify_full(node_unsimplified);
                    outNode = node_simplified;

                    outNode.autoSimplify = node_in.autoSimplify;

                    return outNode;
                  }

                  if (node_a.isEquation) {
                    console.log("node_a", node_a);
                    const node_left = standardOperation(node_a.params[0]);
                    const node_right = standardOperation(node_a.params[1]);
                    const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    node_equation.isEquation = true;

                    outNode = node_equation;
                  } else {
                    outNode = standardOperation(node_a);
                  }

                  return outNode;
                };
                operatorConfig.transformationFunc = transformationFunc;
              }
              break;


            case "simplify__step_by_step":
              {
                operatorConfig.name = "st";
                const transformationFunc = (node_a) => {
                  var outNode;

                  function standardOperation(node_in) {
                    var outNode;

                    if (node_in.type == "OperatorNode") {

                      const depth = getDepth(node_in);

                      if (depth > 2) {
                        console.log("___st A");

                        //'innermost first' simplify

                        const arr_deep_first__treeObj = getArr_deep_first__treeObj(node_in);
                        console.log("arr_deep_first__treeObj", arr_deep_first__treeObj);

                        const arr_deep_first__treeObj__operatorNode = arr_deep_first__treeObj.filter(treeObj => (treeObj.node.type == "OperatorNode"));

                        const treeObj_operatorNode__first_unsimplified = arr_deep_first__treeObj__operatorNode.find(treeObj => !treeObj.node.isSimplified);

                        const node_unsimplified = treeObj_operatorNode__first_unsimplified.node;
                        console.log("node_unsimplified", node_unsimplified);
                        const path__node_unsimplified = treeObj_operatorNode__first_unsimplified.path;

                        const node_simplified = math.simplify(node_unsimplified);
                        node_simplified.isSimplified = true;
                        console.log("node_simplified", node_simplified);

                        const node_mutated = operatorNodeBySettingNodeAtPath(node_in, node_simplified, path__node_unsimplified);

                        outNode = node_mutated;

                      } else {
                        console.log("___st B");

                        //simple simplify

                        const node_unsimplified = node_in;

                        const node_simplified = math.simplify(node_unsimplified);
                        node_simplified.isSimplified = true;

                        outNode = node_simplified;

                      }

                    } else {
                      console.log("___st C");

                      //simple simplify

                      const node_unsimplified = node_in;

                      const node_simplified = math.simplify(node_unsimplified);
                      node_simplified.isSimplified = true;

                      outNode = node_simplified;

                    }

                    outNode.autoSimplify = node_in.autoSimplify;

                    return outNode;
                  }

                  if (node_a.isEquation) {
                    console.log("node_a", node_a);
                    const node_left = standardOperation(node_a.params[0]);
                    const node_right = standardOperation(node_a.params[1]);
                    const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    node_equation.isEquation = true;

                    outNode = node_equation;
                  } else {
                    outNode = standardOperation(node_a);
                  }

                  return outNode;
                };
                operatorConfig.transformationFunc = transformationFunc;
              }
              break;


            case "simplify__top_layer":
              {
                operatorConfig.name = "stl";
                const transformationFunc = (node_a) => {
                  var outNode;

                  // function standardOperation(node_in) {
                  //   var outNode;
                  //
                  //   if(node_in.type == "OperatorNode") {
                  //
                  //     const depth = getDepth(node_in);
                  //
                  //     if(depth > 2) {
                  //       console.log("___st A");
                  //
                  //       //'outermost first' simplify
                  //
                  //       function isTerminalType(mathNode) {
                  //         const type = mathNode.type;
                  //         return ( (type == "ConstantNode") || (type == "SymbolNode") );
                  //       }
                  //
                  //       const operator__layerN          = node_in;
                  //       const arr_child__layerN         = operator__layerN.args;
                  //       const terminal__layerN          = arr_child__layerN.filter(child => isTerminalType(child)).find(e => true);
                  //
                  //       const operator__layerN_minus_1      = arr_child__layerN.filter(child => (child.type == "OperatorNode") ).find(e => true);
                  //       const arr_child__layerN_minus_1     = operator__layerN_minus_1.args;
                  //       // const terminal__layerN_minus_1      = arr_child__layerN_minus_1.filter(child => isTerminalType(child)).find(e => true);
                  //       const arr_terminal__layerN_minus_1  = arr_child__layerN_minus_1.filter(child => isTerminalType(child));
                  //
                  //       function isSameTerminal(termNode1, termNode2) {
                  //         var outBool;
                  //
                  //         function isSameTerminalType(termNode1, termNode2) {
                  //           return (termNode1.type == termNode2.type);
                  //         }
                  //
                  //         const isSameTerminalType_ = isSameTerminalType(termNode1, termNode2);
                  //         console.log("isSameTerminalType_", isSameTerminalType_);
                  //
                  //         if(!isSameTerminalType_) {
                  //           return false;                 //j'aime pas trop ça mais bon...
                  //         }
                  //
                  //         function isSameTerminalContent(termNode1, termNode2) {
                  //           console.log("isSameTerminal", termNode1, termNode2);
                  //           var outBool;
                  //
                  //           switch(termNode1.type) {
                  //             case "SymbolNode":
                  //               outBool = (termNode1.name == termNode2.name);
                  //             break;
                  //             case "ConstantNode":
                  //               outBool = (termNode1.value == termNode2.value);
                  //             break;
                  //             default:
                  //               throw new Error("unsupported type", termNode1.type);
                  //               break;
                  //           }
                  //
                  //           return outBool;
                  //         }
                  //
                  //         outBool = isSameTerminalContent(termNode1, termNode2);
                  //
                  //         return outBool;
                  //       }
                  //
                  //       const sameTerminal = arr_terminal__layerN_minus_1.find(term__layerN_minus_1 => isSameTerminal(terminal__layerN, term__layerN_minus_1));
                  //       if(!sameTerminal) {
                  //         return node_in;
                  //       }
                  //
                  //       function isInverseOperators(opNode1, opNode2) {
                  //         console.log("isInverseOperators", opNode1, opNode2);
                  //         var outBool;
                  //
                  //         const set_opFunc = new Set([opNode1.fn, opNode2.fn]);
                  //         console.log("set_opFunc", set_opFunc);
                  //
                  //         /*Set utils*/
                  //         function eqSet(as, bs) {
                  //             return as.size === bs.size && all(isIn(bs), as);
                  //         }
                  //
                  //         function all(pred, as) {
                  //             for (var a of as) if (!pred(a)) return false;
                  //             return true;
                  //         }
                  //
                  //         function isIn(as) {
                  //             return function (a) {
                  //                 return as.has(a);
                  //             };
                  //         }
                  //         /**/
                  //
                  //
                  //
                  //         const arr_set_inverse = [
                  //           new Set(["multiply", "divide"]),
                  //           new Set(["add", "subtract"]),
                  //         ];
                  //
                  //         outBool = arr_set_inverse.reduce((acc, x) => {
                  //           if(eqSet(set_opFunc, x)) {
                  //             acc = true;
                  //           }
                  //           return acc;
                  //         }, false);
                  //
                  //         return outBool;
                  //       }
                  //
                  //       const isInverseOperators_ = isInverseOperators(operator__layerN_minus_1, operator__layerN);
                  //       console.log("isInverseOperators_", isInverseOperators_);
                  //       if(!isInverseOperators_) {
                  //         return node_in;
                  //       }
                  //
                  //       const node__layerN_minus_2      = arr_child__layerN_minus_1.filter(child => child != sameTerminal).find(e => true);
                  //
                  //       //remove parentheses if any
                  //       // if(node__layerN_minus_2.type == "ParenthesisNode") {
                  //       //   const contentNode = node__layerN_minus_2.content;
                  //       //   outNode = contentNode;
                  //       // } else {
                  //       //   outNode = node__layerN_minus_2;
                  //       // }
                  //
                  //       outNode = node__layerN_minus_2;
                  //
                  //     } else {
                  //       console.log("___st B");
                  //
                  //       //simple simplify
                  //
                  //       const node_unsimplified = node_in;
                  //
                  //       const node_simplified = math.simplify(node_unsimplified);
                  //       node_simplified.isSimplified = true;
                  //
                  //       outNode = node_simplified;
                  //
                  //     }
                  //
                  //   } else {
                  //     console.log("___st C");
                  //     console.log("node_in", node_in);
                  //
                  //     //simple simplify
                  //
                  //     const node_unsimplified = node_in;
                  //
                  //     const node_simplified = math.simplify(node_unsimplified);   //SHU: boom
                  //     node_simplified.isSimplified = true;
                  //
                  //     outNode = node_simplified;
                  //
                  //   }
                  //
                  //   outNode.autoSimplify = node_in.autoSimplify;
                  //
                  //   return outNode;
                  // }

                  const operation = Simplifier.simplify_top_layer;

                  if (node_a.isEquation) {
                    console.log("node_a", node_a);
                    const node_left = operation(node_a.params[0]);
                    const node_right = operation(node_a.params[1]);
                    const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    node_equation.isEquation = true;

                    outNode = node_equation;
                  } else {
                    outNode = operation(node_a);
                  }

                  return outNode;
                };

                const icObjTransformationFunc = (icObj) => {
                  var outIcObj;

                  outIcObj = icObj.clone();

                  // logger.log("icObj.mathNode", icObj.mathNode);
                  outIcObj.mathNode = transformationFunc(icObj.mathNode);

                  return outIcObj;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "simplify__remove_parentheses":
              {
                operatorConfig.name = "srp";
                const transformationFunc = (node_a) => {
                  var outNode;

                  function standardOperation(node_in) {
                    var outNode;

                    if (node_in.type == "ParenthesisNode") {
                      const contentNode = node_in.content;
                      outNode = contentNode;
                    } else {
                      outNode = node_in;
                    }

                    outNode.autoSimplify = node_in.autoSimplify;

                    return outNode;
                  }

                  if (node_a.isEquation) {
                    console.log("node_a", node_a);
                    const node_left = standardOperation(node_a.params[0]);
                    const node_right = standardOperation(node_a.params[1]);
                    const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    node_equation.isEquation = true;

                    outNode = node_equation;
                  } else {
                    outNode = standardOperation(node_a);
                  }

                  return outNode;
                };
                operatorConfig.transformationFunc = transformationFunc;
              }
              break;

            case "simplify:force":
              {
                operatorConfig.name = "simplify";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;

                    const mathNode__in = icObj.mathNode;

                    const mathNode__clone = mathNode__in.cloneDeep();
                    // logger.log("mathNode__clone", mathNode__clone);

                    const value__out = mathNode__clone.evaluate({});
                    // logger.log("value__out", value__out);
                    const mathNode__out = math.parse(value__out);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode__out);
                    icObj__new.isTouchable = true;

                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("old", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "format:toFixed":
              {
                operatorConfig.name = "format:toFixed";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;

                    const mathNode__in = icObj.mathNode;

                    const mathNode__clone = mathNode__in.cloneDeep();
                    // logger.log("mathNode__clone", mathNode__clone);

                    const str__formatted = math.format(mathNode__clone.evaluate({}), { notation: "fixed" });
                    logger.log("str__formatted", str__formatted);
                    const mathNode__out = math.parse(str__formatted);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode__out);
                    icObj__new.isTouchable = true;

                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("old", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;


            case "split__top_layer":
              {
                operatorConfig.name = "sptl";
                const transformationFunc = (node_a) => {
                  var outArr;

                  const operation = Splitter.split_top_layer;

                  if (node_a.isEquation) {
                    // console.log("node_a", node_a);
                    // const node_left     = operation(node_a.params[0]);
                    // const node_right    = operation(node_a.params[1]);
                    // const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    // node_equation.isEquation = true;
                    //
                    // outNode = node_equation;
                    throw new Error("unsupported (yet): split equation");
                  } else {
                    outArr = operation(node_a);
                  }

                  return outArr;
                };

                const icObjTransformationFunc = (icObj) => {

                  logger.log("icObj.mathNode", icObj.mathNode);
                  const arr_mathNodes = transformationFunc(icObj.mathNode);
                  logger.log("arr_mathNodes", arr_mathNodes);

                  const trueRect = {
                    x: icObj.position.x,
                    y: icObj.position.y,
                    width: icObj.size.width,
                    height: icObj.size.height,
                  };

                  const arr_icMathNode = arr_mathNodes.map((mathNode, index) => {
                    const trueRect_part = {
                      x: trueRect.x + index * 100,
                      y: trueRect.y + index * 100,
                      width: trueRect.width,
                      height: trueRect.height,
                    };
                    const icMathNode = infiniteCanvas.createIcMathNode(trueRect_part.x, trueRect_part.y, mathNode);
                    return icMathNode;
                  })

                  const parts = arr_icMathNode;
                  const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
                  const icComposite = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);

                  const icObj__new = icComposite;

                  //debug
                  // const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "new_object");
                  // // const icObj__new = icText;
                  // const parts           = [icText];
                  // const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
                  // const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
                  // const icObj__new = icComposite;


                  // outIcObj = icComposite;
                  // return outIcObj;
                  const transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;


            case "split__full":
              {
                operatorConfig.name = "spf";
                const transformationFunc = (node_a) => {
                  var outArr;

                  const operation = Splitter.split_full;

                  if (node_a.isEquation) {
                    // console.log("node_a", node_a);
                    // const node_left     = operation(node_a.params[0]);
                    // const node_right    = operation(node_a.params[1]);
                    // const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    // node_equation.isEquation = true;
                    //
                    // outNode = node_equation;
                    throw new Error("unsupported (yet): split equation");
                  } else {
                    outArr = operation(node_a);
                  }

                  return outArr;
                };

                const icObjTransformationFunc = (icObj) => {
                  var outIcObj;

                  logger.log("icObj.mathNode", icObj.mathNode);
                  const arr_mathNodes = transformationFunc(icObj.mathNode);
                  logger.log("arr_mathNodes", arr_mathNodes);

                  const trueRect = {
                    x: icObj.position.x,
                    y: icObj.position.y,
                    width: icObj.size.width,
                    height: icObj.size.height,
                  };

                  const arr_icMathNode = arr_mathNodes.map((mathNode, index) => {
                    const trueRect_part = {
                      x: trueRect.x + index * 100,
                      y: trueRect.y + index * 100,
                      width: trueRect.width,
                      height: trueRect.height,
                    };
                    const icMathNode = infiniteCanvas.createIcMathNode(trueRect_part.x, trueRect_part.y, mathNode);
                    return icMathNode;
                  })

                  const parts = arr_icMathNode;
                  const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
                  const icComposite = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);

                  const icObj__new = icComposite;

                  //debug
                  // const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "new_object");
                  // // const icObj__new = icText;
                  // const parts           = [icText];
                  // const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
                  // const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
                  // const icObj__new = icComposite;


                  // outIcObj = icComposite;
                  // return outIcObj;
                  const transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;


            // case "join__top_layer":
            // {
            //   operatorConfig.name = "sptl";
            //   const transformationFunc = (node_a) => {
            //     var outArr;
            //
            //     const operation = .split_top_layer;
            //
            //     if(node_a.isEquation) {
            //       // console.log("node_a", node_a);
            //       // const node_left     = operation(node_a.params[0]);
            //       // const node_right    = operation(node_a.params[1]);
            //       // const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
            //       // node_equation.isEquation = true;
            //       //
            //       // outNode = node_equation;
            //       throw new Error("unsupported (yet): split equation");
            //     } else {
            //       outArr = operation(node_a);
            //     }
            //
            //     return outArr;
            //   };
            //
            //   const icObjTransformationFunc = (icObj) => {
            //     var outIcObj;
            //
            //     logger.log("icObj.mathNode", icObj.mathNode);
            //     const arr_mathNodes = transformationFunc(icObj.mathNode);
            //     logger.log("arr_mathNodes", arr_mathNodes);
            //
            //     const trueRect = {
            //       x:      icObj.position.x,
            //       y:      icObj.position.y,
            //       width:  icObj.size.width,
            //       height: icObj.size.height,
            //     };
            //
            //     const arr_icMathNode = arr_mathNodes.map((mathNode, index) => {
            //       const trueRect_part = {
            //         x:      trueRect.x + index * 100,
            //         y:      trueRect.y + index * 100,
            //         width:  trueRect.width,
            //         height: trueRect.height,
            //       };
            //       const icMathNode = infiniteCanvas.createIcMathNode(trueRect_part.x, trueRect_part.y, mathNode);
            //       return icMathNode;
            //     })
            //
            //     const parts           = arr_icMathNode;
            //     const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
            //     const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
            //
            //     const icObj__new = icComposite;
            //
            //     //debug
            //     // const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "new_object");
            //     // // const icObj__new = icText;
            //     // const parts           = [icText];
            //     // const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
            //     // const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
            //     // const icObj__new = icComposite;
            //
            //
            //     // outIcObj = icComposite;
            //     // return outIcObj;
            //     const transformationOutput = new TransformationOutput("new", icObj__new, icObj);
            //     return transformationOutput;
            //   };
            //
            //   operatorConfig.transformationFunc = icObjTransformationFunc;
            // }
            // break;



            case "morpher__math_to_text":
              {
                operatorConfig.name = "morph: math→text";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const str = icObj.mathNode.toString();
                    const icObj__new = infiniteCanvas.createIcText(x, y, str);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "morpher__text_to_math":
              {
                operatorConfig.name = "morph: text→math";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "text") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;

                    const mathNode = math.parse(icObj.text);
                    mathNode.autoSimplify = true;

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "decomposition__product_primes":
              {
                operatorConfig.name = "decomp:prpr";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const mathNode = icObj.mathNode;
                    const mathNode_new = Rewriter.decomposition_product_primes(mathNode);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode_new);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "mark__slash_simplifiable":
              {
                operatorConfig.name = "mark:slash";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const mathNode = icObj.mathNode;

                    //SHU741852
                    const analysisOutput = Analyzer.analyze_simplifiable(mathNode);

                    const mathNode__initial = new math.OperatorNode("x", "multiply", []);
                    const mathNode_new = analysisOutput.arr_simplifiable_pair.reduce((acc, x) => {

                      acc.args.push(x);

                    }, mathNode__initial);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode_new);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);

                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;


            case "simplify__fraction":
              {
                operatorConfig.name = "sf";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const mathNode = icObj.mathNode;
                    const mathNode_new = Simplifier.simplify_fraction(mathNode);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode_new);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;


            case "inverse":
              {
                operatorConfig.name = "inverse";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const mathNode = icObj.mathNode;
                    const mathNode_new = Inverser.inverse(mathNode);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode_new);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "singleOperatorize":
              {
                operatorConfig.name = "s:singleOperatorize";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const mathNode = icObj.mathNode;
                    const mathNode_new = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode_new);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "simplify__topPriorityShell":
              {
                operatorConfig.name = "s:tpsh";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const mathNode = icObj.mathNode;
                    const mathNode_new = Simplifier.simplify_top_priorityShell(mathNode);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode_new);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;



            //object transformations

            case "o:clone":
              {
                const nb_clones = cfg.nb_clones;
                // const nb_clones = 2;

                const string__easy = "clone" + "(" + cfg.nb_clones + ")";
                operatorConfig.name = string__easy;

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  logger.log("o:clone");

                  const arr_clone = [...Array(nb_clones).keys()].map((index) => {
                    const icObj_clone = icObj.deepClone();
                    const id__clone = infiniteCanvas.generateIcObjectId();
                    icObj_clone.id = id__clone;

                    icObj_clone.fill = "yellow";
                    const width__icObj = icObj.size.width;
                    const width__spacing = 50;
                    const offset__x = index * (width__icObj + width__spacing);
                    icObj_clone.position.x = icObj.position.x + offset__x;

                    return icObj_clone;
                  });

                  const arr_icObj = [icObj, ...arr_clone];
                  // const arr_icObj = [icObj];
                  // const arr_icObj = arr_clone;
                  logger.log("arr_icObj", arr_icObj);

                  transformationOutput = new TransformationOutput("new", arr_icObj, icObj);

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "o:scale":
              {
                const string__mode_and_operation = cfg.mode + " " + cfg.operation;
                // operatorConfig.name = gmOperatorType + "(" + string__mode_and_operation + ")";
                operatorConfig.name = string__mode_and_operation;

                const string__mode = cfg.mode;
                const string__operation = cfg.operation;

                function createStandardTransformationFunc(string__mode, string__operation) {

                  var outFunc;

                  //create a mathNode operator
                  const arr_components = string__operation.split(" ");
                  const string__opSymbol = arr_components[0];
                  const string__operand = arr_components[1];

                  const value__operand = Number(string__operand);
                  logger.log("value__operand", value__operand);

                  const op = Operator.fromString_binary(string__opSymbol);
                  const node_b = new math.ConstantNode(value__operand);
                  // const node_b = math.parse(string__operand);
                  const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

                  outFunc = function (icObj) {
                    var outIcObj;

                    var mathNode__in;
                    switch (string__mode) {
                      case "horiz":
                        mathNode__in = new math.ConstantNode(icObj.scale.X);
                        break;
                      case "vert":
                        mathNode__in = new math.ConstantNode(icObj.scale.Y);
                        break;
                    }

                    const mathNode__out = operatorNodeFuncWrapper.func(mathNode__in);
                    logger.log("mathNode__out", mathNode__out);

                    const value__out = mathNode__out.evaluate({});
                    logger.log("value__out", value__out);



                    const icObj_clone = icObj.deepClone();
                    const id__clone = infiniteCanvas.generateIcObjectId();
                    icObj_clone.id = id__clone;

                    switch (string__mode) {
                      case "horiz":
                        icObj_clone.scale.X = value__out;
                        break;
                      case "vert":
                        icObj_clone.scale.Y = value__out;
                        break;
                    }

                    outIcObj = icObj_clone;    //shu: return functional(my life)

                    return outIcObj;
                  };

                  return outFunc;
                }

                function icObjTransformationFunc(icObj) {
                  var transformationOutput;

                  logger.log("o:scale", "icObjTransformationFunc", "icObj.type", icObj.type);
                  switch (icObj.type) {
                    case "composite":
                      {
                        const arr_entry__part_mutated = Object.entries(icObj.parts).map(([partName, icObj__part]) => {
                          const transformationOutput__part = icObjTransformationFunc(icObj__part);
                          const icObj__part__transformed = transformationOutput__part.value;
                          return [partName, icObj__part__transformed];
                        });

                        const parts__mutated = Object.fromEntries(arr_entry__part_mutated);
                        logger.log("parts__mutated", parts__mutated);


                        // const icObj__new = icObj.deepClone();
                        // icObj__new.parts = parts__mutated;

                        const compositeConfig = Compositer.defaultCompositeConfig(parts__mutated, true);
                        const icComposite__new = infiniteCanvas.createIcComposite(trueRect, parts__mutated, compositeConfig);
                        const icObj__new = icComposite__new;

                        transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                      }
                      break;
                    default:
                      {
                        const opString = gmOperatorType;
                        const stdTransformationFunc = createStandardTransformationFunc(string__mode, string__operation);

                        const icObj__new = stdTransformationFunc(icObj);
                        logger.log("icObj__new", icObj__new);

                        transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                      }
                      // {
                      //   logger.log("icObj.type:", icObj.type);
                      //   transformationOutput = new TransformationOutput("old", icObj, icObj);
                      // }
                      break;

                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "o:ucscale":
              {

              }
              break;

            case "o:ucconvert":
              {

              }
              break;




            //image transformations
            case "i:scale":   //== pxscale (mutate image bitmap)
              {

              }
              break;


            //text transformations
            case "t:append":
              {
                const string__ingredient = cfg.text;

                const string__mode_and_operation = cfg.mode + " " + cfg.operation;
                // operatorConfig.name = gmOperatorType + "(" + string__mode_and_operation + ")";
                operatorConfig.name = "append(" + "\"" + string__ingredient + "\"" + ")";

                function createMutationFunc(string__ingredient) {
                  var outFunc;

                  outFunc = function (icObj) {
                    var outIcObj;

                    outIcObj = icObj;
                    outIcObj.text = outIcObj.text + string__ingredient;

                    return outIcObj;
                  };

                  return outFunc;
                }

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "text") {

                    const mutationFunc = createMutationFunc(string__ingredient);

                    const icObj__mutated = mutationFunc(icObj);
                    logger.log("icObj__mutated", icObj__mutated);

                    transformationOutput = new TransformationOutput("mutated", icObj__mutated, icObj);

                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("old", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;




            //text transformations
            case "comp":
              {
                const string__name = cfg.name;
                operatorConfig.name = string__name;

                const dict_op_part = cfg.parts; //this dict contains Operation instances

                switch (cfg.mode) {
                  case "sequential":
                    {
                      const icObjTransformationFunc = (icObj) => {
                        var transformationOutput;

                        const transformationOutput__identity = new TransformationOutput("old", icObj, icObj);

                        transformationOutput = Object.entries(dict_op_part).reduce((acc, [name__op_part, op_part]) => {
                          var out;

                          const input = acc.value;

                          const transformationOutput__step = op_part.transformationFunc(input);

                          return transformationOutput__step;
                        }, transformationOutput__identity);

                        return transformationOutput;
                      };
                    }
                    break;
                  case "parallel":                  //SHU: for parallel operations, we need to promisify all this
                    throw new Error("parallel operations not supported yet");
                    break;
                }

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;



            //composite-munching
            case "c:objectAtIndex":
              {
                const index = cfg.index;

                operatorConfig.name = gmOperatorType + "(" + index + ")";

                function icObjTransformationFunc(icObj) {
                  logger.log("c:objectAtIndex", icObj);
                  var transformationOutput;

                  switch (icObj.type) {
                    case "composite":
                      {
                        const arr_part = Object.values(icObj.parts);
                        const icObj__new = arr_part[index];

                        transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                      }
                      break;
                    default:
                      //do nothing
                      transformationOutput = new TransformationOutput("old", icObj, icObj);
                      break;
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            // case "c:map:1":
            // {
            //   operatorConfig.name = "c:map:" + "" + 1 + "";
            //
            //   function icObjTransformationFunc(icObj) {
            //     logger.log("c:map:1", icObj);
            //     var transformationOutput;
            //
            //     switch(icObj.type) {
            //       case "composite":
            //         {
            //           const arr_part      = Object.values(icObj.parts);
            //           const arr_part__new = arr_part.map(icObj__part => {
            //             var outIcObj;
            //
            //             switch(icObj__part.type) {
            //               case "mathNode":
            //               {
            //                 const mathNode__new   = new math.ConstantNode(1);
            //                 const icMathNode__new = infiniteCanvas.createIcMathNode(icObj__part.position.x, icObj__part.position.y, mathNode__new);
            //                 outIcObj = icMathNode__new;
            //               }
            //               break;
            //               default:
            //                 //do nothing
            //                 outIcObj = icObj;
            //               break;
            //             }
            //
            //             return outIcObj;
            //           });
            //
            //
            //           //create new collection
            //           const arr_entries = arr_part__new.map((icObj__part__new, index) => {
            //             const name__element = "part_" + index;
            //             return [name__element, icObj__part__new];
            //           });
            //
            //           const parts = Object.fromEntries(arr_entries);
            //
            //           const compositeConfig = Object.entries(parts).reduce((acc, [partName, part], index) => {
            //             // const isMobile = (index != 0);
            //             const isMobile = true;
            //
            //             // acc[partName] = {
            //             acc[part.id] = {
            //               isMobile: isMobile,
            //             };
            //             return acc;
            //           }, {});
            //
            //           const icObj__new = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
            //
            //           icComposite.isCollection = true;
            //           icComposite.isTouchable  = true;
            //
            //           transformationOutput = new TransformationOutput("new", icObj__new, icObj);
            //         }
            //         break;
            //       default:
            //         //do nothing
            //         transformationOutput = new TransformationOutput("old", icObj, icObj);
            //         break;
            //     }
            //
            //     return transformationOutput;
            //   };
            //
            //   operatorConfig.transformationFunc = icObjTransformationFunc;
            // }
            // break;

            case "c:map:":
              {
                const operatorString = cfg.operatorString;
                operatorConfig.name = "c:map:" + operatorString;

                function icObjTransformationFunc(icObj) {
                  logger.log(operatorConfig.name, icObj);
                  var transformationOutput;

                  switch (icObj.type) {
                    case "composite":
                      {
                        const arr_part = Object.values(icObj.parts);
                        const arr_part__new = arr_part.map(icObj__part => {
                          var outIcObj;

                          switch (icObj__part.type) {
                            case "mathNode":
                              {
                                const transformationFunc__inner = (new GMOperatorTextChangeEngine()).transformationFuncForText(operatorString);
                                logger.log("transformationFunc__inner", transformationFunc__inner);
                                logger.log("icObj__part", icObj__part);

                                // const operatorConfig__inner     = operatorConfigForType("inverse");
                                // const transformationFunc__inner = operatorConfig__inner.transformationFunc;
                                // const operation__inner = new Operation(transformationFunc__inner);

                                const transformationOutput__inner = transformationFunc__inner(icObj__part);
                                logger.log("transformationOutput__inner", transformationOutput__inner);

                                const icObj__part__new = transformationOutput__inner.value;
                                outIcObj = icObj__part__new;
                              }
                              break;
                            default:
                              //do nothing
                              outIcObj = icObj__part;
                              break;
                          }

                          return outIcObj;
                        });


                        //create new collection
                        const arr_entries = arr_part__new.map((icObj__part__new, index) => {
                          const name__element = "part_" + index;
                          return [name__element, icObj__part__new];
                        });

                        const parts = Object.fromEntries(arr_entries);

                        const compositeConfig = Object.entries(parts).reduce((acc, [partName, part], index) => {
                          // const isMobile = (index != 0);
                          const isMobile = true;

                          // acc[partName] = {
                          acc[part.id] = {
                            isMobile: isMobile,
                          };
                          return acc;
                        }, {});

                        const icObj__new = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);

                        icComposite.isCollection = true;
                        icComposite.isTouchable = true;

                        transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                      }
                      break;
                    default:
                      //do nothing
                      transformationOutput = new TransformationOutput("old", icObj, icObj);
                      break;
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;


            //composite creation
            case "vessel":
              {
                const rgbaString__vessel = cfg.rgbaString;

                operatorConfig.name = "vessel";

                const icObjTransformationFunc = async function (icObj) {
                  var transformationOutput;

                  logger.log("[vessel]");
                  //create vessel
                  const trueRect__icObj = {
                    x: icObj.position.x,
                    y: icObj.position.y,
                    width: icObj.size.width,
                    height: icObj.size.height,
                  };
                  const icVessel = infiniteCanvas.createIcVessel(trueRect__icObj);
                  if (rgbaString__vessel != null) {
                    icVessel.fill = rgbaString__vessel;
                  }

                  transformationOutput = await infiniteCanvas.addIcObject_p(icVessel)
                    .then(rep_free__vessel => {

                      //add icObj to vessel
                      rep_free__vessel.dict_engine["composite"].engine.awoken.addPart(icObj);

                      return rep_free__vessel;
                    })
                    .then(rep_free__vessel => {
                      const transformationOutput = new TransformationOutput("new", rep_free__vessel, icObj);
                      return transformationOutput;
                    });

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "unvessel":
              {
                operatorConfig.name = "unvessel";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  logger.log("[unvessel]");

                  // const rep_free__vessel = infiniteCanvas.get;

                  //remove parts from vessel
                  // rep_free__vessel.engine.awoken.removePart(icObj);

                  transformationOutput = new TransformationOutput("new", arr_icObj, icObj);

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;



            //randomness

            case "random":
              {
                operatorConfig.name = gmOperatorType;

                function icObjTransformationFunc(icObj) {
                  logger.log("random", icObj);
                  var transformationOutput;

                  const mathNode = new math.ConstantNode(0);
                  const value__random = Math.random();
                  mathNode.value = value__random;

                  const trueRect__icObj = {
                    x: icObj.position.x,
                    y: icObj.position.y,
                    width: icObj.size.width,
                    height: icObj.size.height,
                  };
                  const icMathNode = infiniteCanvas.createIcMathNode(trueRect__icObj.x, trueRect__icObj.y, mathNode);

                  transformationOutput = new TransformationOutput("new", icMathNode, icObj);

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "rand_int":
              {
                const int__min = cfg.min;
                const int__max = cfg.max;

                operatorConfig.name = gmOperatorType + "(" + int__min + "," + int__max + ")";

                function icObjTransformationFunc(icObj) {
                  logger.log("rand_int", icObj);
                  var transformationOutput;

                  const mathNode = new math.ConstantNode(0);
                  const value__random = Math.floor(Math.random() * (int__max - int__min)) + int__min;
                  mathNode.value = value__random;

                  const trueRect__icObj = {
                    x: icObj.position.x,
                    y: icObj.position.y,
                    width: icObj.size.width,
                    height: icObj.size.height,
                  };
                  const icMathNode = infiniteCanvas.createIcMathNode(trueRect__icObj.x, trueRect__icObj.y, mathNode);

                  transformationOutput = new TransformationOutput("new", icMathNode, icObj);

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "rand_inArr":
              {
                const arr_value = cfg.arr_value;

                operatorConfig.name = gmOperatorType + "([" + arr_value.join(",") + "])";

                function icObjTransformationFunc(icObj) {
                  logger.log("rand_inArr", icObj);
                  var transformationOutput;

                  const mathNode = new math.ConstantNode(0);
                  const value__random = Utils.randomElementInArray(arr_value);
                  mathNode.value = value__random;

                  const trueRect__icObj = {
                    x: icObj.position.x,
                    y: icObj.position.y,
                    width: icObj.size.width,
                    height: icObj.size.height,
                  };
                  const icMathNode = infiniteCanvas.createIcMathNode(trueRect__icObj.x, trueRect__icObj.y, mathNode);

                  transformationOutput = new TransformationOutput("new", icMathNode, icObj);

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "rand_inBag":
              {
                operatorConfig.name = gmOperatorType;

                function icObjTransformationFunc(icObj) {
                  logger.log("rand_inBag", icObj);
                  var transformationOutput;

                  switch (icObj.type) {
                    case "composite":
                      {
                        const arr_part = Object.values(icObj.parts);
                        const icObj__picked = Utils.randomElementInArray(arr_part);

                        const icObj__new = icObj__picked.deepClone();

                        transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                      }
                      break;
                    default:
                      //do nothing
                      transformationOutput = new TransformationOutput("old", icObj, icObj);
                      break;
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;



          }

          return operatorConfig;
        }


        const operatorConfig = operatorConfigForType(gmOperatorType);

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
          isCollectionOperator: cfg.isCollectionOperator,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_operator";

        // icComposite.isTouchable = false;

        return icComposite;
      }






      createIcGMOperator_editable(trueRect, text_in) {
        console.log("createIcGMOperator", trueRect, text_in);

        const transformationFunc = (new GMOperatorTextChangeEngine()).transformationFuncForText(text_in);

        const operatorConfig = {
          name: text_in,
          transformationFunc: transformationFunc,
        };

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";

        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isTouchable     = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_operator";

        // icComposite.isTouchable = false;


        const engineCarrier = icComposite;
        const engine = new GMOperatorTextChangeEngine();
        const eType = "gmOperator_editable";

        const icEngined = infiniteCanvas.installEngineOnIcObj(engineCarrier, eType, engine);


        return icEngined;
      }




      createIcGMTargetSlot(trueRect) {
        console.log("createIcGMTargetSlot", trueRect);

        const targetValue = -48;

        const text = targetValue.toString(10);
        const backade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        backade.backgroundColor = "grey";
        backade.isMobile = false;
        // backade.isTouchable = false;

        const canSnapFunc = (above, below) => {
          var outBool;

          const canSnapFunc_geometryWise = (above, below) => {
            // return Snap.canSnap(above, below);
            return Snap.canSnap_noSize(above, below);
          };

          // const canSnapFunc_valueWise    = (above, below) => (above.value == targetValue);
          const canSnapFunc_valueWise = (above, below) => {
            const value = parseInt(above.text, 10);
            const isValueValid = (value == targetValue);
            return isValueValid;
          };

          const canSnapFuncs = {
            "geometry": canSnapFunc_geometryWise,
            "value": canSnapFunc_valueWise,
          };

          const canSnapFunc_allWise = (above, below) => Object.entries(canSnapFuncs).reduce((acc, [canSnapFunc_xWiseName, canSnapFunc_xWise]) => {
            const canSnap_xWise = canSnapFunc_xWise(above, below);
            console.log("canSnap_xWise", canSnapFunc_xWiseName, canSnap_xWise);
            return acc && canSnap_xWise;
          }, true);

          const canSnap_allWise = canSnapFunc_allWise(above, below);
          console.log("canSnap_allWise", canSnap_allWise);

          outBool = canSnap_allWise;

          return outBool;
        };
        const canUnsnapFunc = (above, below) => {
          return Snap.canUnsnap(above, below);
        };
        // const snapMutationFunc  = (above, below) => {   //SHU TODO: toSnapState mutations: toPresnapped, toSnapped, toUnsnapped
        //   //how rep_snapped  will differ from rep_official
        //   //how snappedState will differ from rep_official
        // };
        const snapSlotConfig = {
          canSnapFunc: canSnapFunc,
          canUnsnapFunc: canUnsnapFunc,
        };

        const snapSlot = infiniteCanvas.createIcSnapSlot(trueRect, snapSlotConfig);
        snapSlot.fill = "";
        snapSlot.isMobile = false;


        const parts = {
          "backade": backade,
          "snapSlot": snapSlot,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_targetSlot";

        // icComposite.isTouchable = false;


        return icComposite;
      }


      createIcGMTargetTouchSlot(trueRect, targetValue_in) {
        console.log("createIcGMTargetTouchSlot", trueRect);

        var targetValue = targetValue_in;
        if (targetValue == null) {
          targetValue = -48;
        }


        const canTouchFunc_geometryWise = (above, below, context) => {
          // const canTouchFunc = Touch.canTouch;
          const canTouchFunc = Touch2Singleton.sharedInstance().canTouch;

          return canTouchFunc(above, below);
        };

        // const canTouchFunc_valueWise = (above, below) => {
        //   const value = parseInt(above.text,10);
        //   const isValueValid = (value == targetValue);
        //   return isValueValid;
        // };

        const canTouchFunc_valueWise = (above, below, context) => {
          logger.log("canTouchFunc_valueWise", above, below, context);
          var outBool;

          // const touchSlot = below;
          const facade = context.facade;

          var mathNode__above;
          // const mathNode__above = above.mathNode;
          // const mathNode__above = above.parts.facade.mathNode;
          if (above.mathNode != null) {
            mathNode__above = above.mathNode;
          } else if (above.parts.facade.mathNode != null) {
            mathNode__above = above.parts.facade.mathNode;
          } else {
            throw new Error("unsupported situation: canTouchFunc_valueWise");
          }
          logger.log("mathNode__above", mathNode__above);
          // logger.log("mathNode__above.value", mathNode__above.value);

          const mathNode__below = facade.mathNode;
          logger.log("mathNode__below", mathNode__below);
          // logger.log("mathNode__below.value", mathNode__below.value);


          function isSameValue(mathNode_1, mathNode_2) {
            var outBool;

            function isContainingSymbolNode(mathNode) {
              var outBool;

              switch (mathNode.type) {
                case "OperatorNode":
                  {
                    const operatorNode = mathNode;
                    const arr_child = operatorNode.args;
                    outBool = Utils.early_break_reduce(arr_child, (acc, x, i, arr) => {
                      // logger.log("early_break_reduce", x.x);

                      const isChildContainingSymbolNode = isContainingSymbolNode(x);

                      return acc || isChildContainingSymbolNode;
                    }, true, (acc, x, i, arr) => {
                      return (acc == true);
                    });
                  }
                  break;
                case "RelationalNode":
                  {
                    const operatorNode = mathNode;
                    const arr_child = operatorNode.params;
                    outBool = Utils.early_break_reduce(arr_child, (acc, x, i, arr) => {
                      // logger.log("early_break_reduce", x.x);

                      const isChildContainingSymbolNode = isContainingSymbolNode(x);

                      return acc || isChildContainingSymbolNode;
                    }, true, (acc, x, i, arr) => {
                      return (acc == true);
                    });
                  }
                  break;
                case "ParenthesisNode":
                  const parenthesisNode = mathNode;
                  outBool = isContainingSymbolNode(parenthesisNode.content);
                  break;
                case "SymbolNode":
                  outBool = true;
                  break;
                default:
                  outBool = false;
                  break;
              }

              return outBool;
            }

            const isSymbolNode_in_either = isContainingSymbolNode(mathNode_1) || isContainingSymbolNode(mathNode_2);
            if (isSymbolNode_in_either) {

              function evaluateMathNode(mathNode, dict_subst) {
                return mathNode.evaluate(dict_subst);
              }

              function evaluation_grid(mathNode_1, mathNode_2) {
                var outBool;

                const arr_dict_subst = [
                  {
                    x: 0,
                  },
                  {
                    x: 1,
                  },
                  {
                    x: -1,
                  },
                ];

                //early break reduce
                outBool = Utils.early_break_reduce(arr_dict_subst, (acc, x, i, arr) => {
                  // logger.log("early_break_reduce", x.x);

                  const ev_1 = evaluateMathNode(mathNode_1, x);
                  const ev_2 = evaluateMathNode(mathNode_2, x);

                  const isEqual_ev = (ev_1 == ev_2);

                  return acc && isEqual_ev;
                }, true, (acc, x, i, arr) => {
                  return (acc == false);
                });

                return outBool;
              }

              outBool = evaluation_grid(mathNode_1, mathNode_2);
              if (outBool) {
                return outBool;
              }



              var expr__mathNode_1 = mathNode_1.toString();
              expr__mathNode_1 = expr__mathNode_1.replaceAll("×", "*");
              var expr__mathNode_2 = mathNode_2.toString();
              expr__mathNode_2 = expr__mathNode_2.replaceAll("×", "*");

              const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
              const algebrite_result = Algebrite.run(expr__equality);

              outBool = (algebrite_result == true);

            } else {

              const relationalNode = new math.RelationalNode(['equal'], [mathNode__above, mathNode__below]);
              // logger.log("relationalNode", relationalNode);

              outBool = relationalNode.evaluate();
            }

            return outBool;
          }


          const isSameValue_ = isSameValue(mathNode__above, mathNode__below);
          console.log("isSameValue_", isSameValue_);


          outBool = isSameValue_;

          return outBool;
        };


        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value": canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above, below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;

        const transformationFunc = (icObj) => {
          var outIcObj;

          console.log("yey");

          outIcObj = icObj.clone();

          outIcObj.fill = "yellow";
          outIcObj.color = "white";

          // outIcObj.im_dying_now = true;


          // icObj.text = "touched";
          // icObj.text += " : yey!";

          // icObj.mathNode = icObj.mathNode;            //SHU: oh my god.  "Ok."
          // icObj.mathNode = new math.ConstantNode("Super!");


          return outIcObj;
        };

        const touchSlotConfig = {
          canTouchFunc: canTouchFunc,
          transformationFunc: transformationFunc,
          context: {},
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";


        // const text             = targetValue.toString(10);
        // const facade           = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        // facade.backgroundColor = "orange";
        // facade.isTouchable     = false;

        var mathNode;
        if (targetValue instanceof math.Node) {
          mathNode = targetValue;
        } else {
          mathNode = new math.ConstantNode(targetValue);
        }
        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        facade.backgroundColor = "orange";
        // facade.isTouchable     = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };


        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_targetTouchSlot";

        // icComposite.isTouchable = false;


        //enrich touchSlotConfig.context
        infiniteCanvas.onceOnAddRepresentedForIcObject(facade, (facade) => {
          const facade__represented = infiniteCanvas.getRepresented(facade.id);
          // const facade__rep_free     = facade__represented.r_free();
          const facade__rep_official = facade__represented.r_official();

          touchSlotConfig.context.facade = facade__rep_official;
        });


        /*
        // const touchSlotEngine = touchSlot.engine;
        // console.log("touchSlot", touchSlot);
        // Hooker.installHooks(touchSlotEngine, "touch");
        // touchSlotEngine.did["touch"].on((...args) => {
        //   console.log("did touch", ...args);
        //
        //   infiniteCanvas.addNewCircle();
        // });
        infiniteCanvas.onceOnAddRepresentedForIcObject(touchSlot, (touchSlot) => {
          const touchSlot__represented  = infiniteCanvas.getRepresented(touchSlot.id);
          const touchSlot__rep_free     = touchSlot__represented.r_free();

          const touchSlotEngine = touchSlot__rep_free.engine;
          // Hooker.installHooks(touchSlotEngine, "touch");
          // touchSlotEngine.did["touch"].on((...args) => {

          Hooker.installHooks(touchSlotEngine.awoken, "touch");
          touchSlotEngine.awoken.did["touch"].on((...args) => {
            console.log("did touch", ...args);

            infiniteCanvas.addNewCircle();

            const context = touchSlot__rep_free.touchSlotConfig.context;
            const facade__rep_official  = context.facade;                 //SHU: this is context so it is official rep

            const facade__represented = facade__rep_official.represented;
            const facade__rep_free    = facade__represented.r_free();

            // facade__rep_free.text = "Super!";
            // facade__rep_free.mathNode = new math.ConstantNode("Super!");
            facade__rep_free.mathNode = new math.ConstantNode(10000000);

            facade__rep_free.fill     = "darkblue";
            facade__rep_free.stroke   = "yellow";

            //debug
            facade__rep_free.position = {
              x: facade__rep_free.position.x + 100,
              y: facade__rep_free.position.y - 50,
            };

          });
        });
        */

        return icComposite;
      }

      createIcGMEqTargetTouchSlot(trueRect, mathNode__core, mathNode__facade) {
        console.log("createIcGMTargetTouchSlot", trueRect);

        const canTouchFunc_geometryWise = (above, below, context) => {
          // const canTouchFunc = Touch.canTouch;
          const canTouchFunc = Touch2Singleton.sharedInstance().canTouch;

          return canTouchFunc(above, below);
        };

        const canTouchFunc_valueWise = (above, below, context) => {
          logger.log("canTouchFunc_valueWise", above, below, context);
          var outBool;


          var mathNode__above;
          // const mathNode__above = above.mathNode;
          // const mathNode__above = above.parts.facade.mathNode;
          if (above.mathNode != null) {
            mathNode__above = above.mathNode;
          } else if (above.parts.facade.mathNode != null) {
            mathNode__above = above.parts.facade.mathNode;
          } else {
            throw new Error("unsupported situation: canTouchFunc_valueWise");
          }
          logger.log("mathNode__above", mathNode__above);
          // logger.log("mathNode__above.value", mathNode__above.value);



          // const touchSlot = below;
          // const facade    = context.facade;
          const core = context.core;
          // logger.log("core", core);

          const mathNode__below = core.mathNode;
          logger.log("mathNode__below", mathNode__below);
          // logger.log("mathNode__below.value", mathNode__below.value);


          function isSameValue(mathNode_1, mathNode_2) {
            var outBool;

            function isContainingSymbolNode(mathNode) {
              var outBool;

              switch (mathNode.type) {
                case "OperatorNode":
                  {
                    const operatorNode = mathNode;
                    const arr_child = operatorNode.args;
                    outBool = Utils.early_break_reduce(arr_child, (acc, x, i, arr) => {
                      // logger.log("early_break_reduce", x.x);

                      const isChildContainingSymbolNode = isContainingSymbolNode(x);

                      return acc || isChildContainingSymbolNode;
                    }, true, (acc, x, i, arr) => {
                      return (acc == true);
                    });
                  }
                  break;
                case "RelationalNode":
                  {
                    const operatorNode = mathNode;
                    const arr_child = operatorNode.params;
                    outBool = Utils.early_break_reduce(arr_child, (acc, x, i, arr) => {
                      // logger.log("early_break_reduce", x.x);

                      const isChildContainingSymbolNode = isContainingSymbolNode(x);

                      return acc || isChildContainingSymbolNode;
                    }, true, (acc, x, i, arr) => {
                      return (acc == true);
                    });
                  }
                  break;
                case "ParenthesisNode":
                  const parenthesisNode = mathNode;
                  outBool = isContainingSymbolNode(parenthesisNode.content);
                  break;
                case "SymbolNode":
                  outBool = true;
                  break;
                default:
                  outBool = false;
                  break;
              }

              return outBool;
            }

            const isSymbolNode_in_either = isContainingSymbolNode(mathNode_1) || isContainingSymbolNode(mathNode_2);
            if (isSymbolNode_in_either) {

              function evaluateMathNode(mathNode, dict_subst) {
                return mathNode.evaluate(dict_subst);
              }

              function evaluation_grid(mathNode_1, mathNode_2) {
                var outBool;

                const arr_dict_subst = [
                  {
                    x: 0,
                  },
                  {
                    x: 1,
                  },
                  {
                    x: -1,
                  },
                ];

                //early break reduce
                outBool = Utils.early_break_reduce(arr_dict_subst, (acc, x, i, arr) => {
                  // logger.log("early_break_reduce", x.x);

                  const ev_1 = evaluateMathNode(mathNode_1, x);
                  const ev_2 = evaluateMathNode(mathNode_2, x);

                  const isEqual_ev = (ev_1 == ev_2);

                  return acc && isEqual_ev;
                }, true, (acc, x, i, arr) => {
                  return (acc == false);
                });

                return outBool;
              }

              outBool = evaluation_grid(mathNode_1, mathNode_2);
              if (outBool) {
                return outBool;
              }



              var expr__mathNode_1 = mathNode_1.toString();
              expr__mathNode_1 = expr__mathNode_1.replaceAll("×", "*");
              var expr__mathNode_2 = mathNode_2.toString();
              expr__mathNode_2 = expr__mathNode_2.replaceAll("×", "*");

              const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
              const algebrite_result = Algebrite.run(expr__equality);

              outBool = (algebrite_result == true);

            } else {

              const relationalNode = new math.RelationalNode(['equal'], [mathNode__above, mathNode__below]);
              // logger.log("relationalNode", relationalNode);

              outBool = relationalNode.evaluate();
            }

            return outBool;
          }


          const isSameValue_ = isSameValue(mathNode__above, mathNode__below);
          console.log("isSameValue_", isSameValue_);


          outBool = isSameValue_;

          return outBool;
        };


        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value": canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above, below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;

        const transformationFunc = (icObj) => {
          var outIcObj;

          console.log("yey");

          outIcObj = icObj.clone();

          outIcObj.fill = "yellow";
          outIcObj.color = "white";

          // outIcObj.im_dying_now = true;


          // icObj.text = "touched";
          // icObj.text += " : yey!";

          // icObj.mathNode = icObj.mathNode;            //SHU: oh my god.  "Ok."
          // icObj.mathNode = new math.ConstantNode("Super!");


          return outIcObj;
        };

        const touchSlotConfig = {
          canTouchFunc: canTouchFunc,
          transformationFunc: transformationFunc,
          context: {},
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";



        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode__facade);
        facade.backgroundColor = "orange";
        // facade.isTouchable     = false;

        const core = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode__core);
        core.opacity = 0;
        core.backgroundColor = "orange";
        core.isTouchable = false;

        const parts = {
          "core": core,
          "touchSlot": touchSlot,
          "facade": facade,
        };


        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_eq_targetTouchSlot";

        // icComposite.isTouchable = false;


        //enrich touchSlotConfig.context
        infiniteCanvas.onceOnAddRepresentedForIcObject(facade, (facade) => {
          const facade__represented = infiniteCanvas.getRepresented(facade.id);
          // const facade__rep_free     = facade__represented.r_free();
          const facade__rep_official = facade__represented.r_official();

          touchSlotConfig.context.facade = facade__rep_official;
        });

        return icComposite;
      }


      createIcGMBoxTargetTouchSlot(trueRect, targetMathNode) {
        console.log("createIcGMBoxTargetTouchSlot", trueRect, targetMathNode);


        const canTouchFunc_geometryWise = (above, below, context) => {
          // logger.log("canTouchFunc_geometryWise", above);

          // if(above.parts != null && above.parts.contactArea != null) {
          const contactArea = above.parts.contactArea;
          // const canTouchFunc = Touch.canTouch;
          const canTouchFunc = Touch2Singleton.sharedInstance().canTouch;

          return canTouchFunc(above, below);
        };

        const canTouchFunc_valueWise = (above, below, context) => {
          // logger.log("canTouchFunc_valueWise", above, below, context);
          var outBool;

          // const touchSlot = below;
          const facade = context.facade;

          const mathNode__above = above.parts.facade.mathNode;
          console.log("mathNode__above", mathNode__above);
          const mathNode__below = facade.mathNode;
          console.log("mathNode__below", mathNode__below);

          function isSameValue(mathNode_1, mathNode_2) {
            var outBool;

            function isContainingSymbolNode(mathNode) {
              var outBool;

              const arr_symbolNode = mathNode.filter(function (node) { return node.isSymbolNode; });

              outBool = (arr_symbolNode.length > 0);

              return outBool;
            }

            const isSymbolNode_in_either = isContainingSymbolNode(mathNode_1) || isContainingSymbolNode(mathNode_2);
            if (isSymbolNode_in_either) {

              function evaluateMathNode(mathNode, dict_subst) {
                return mathNode.evaluate(dict_subst);
              }

              function evaluation_grid(mathNode_1, mathNode_2) {
                var outBool;

                const arr_dict_subst = [
                  {
                    x: 0,
                  },
                  {
                    x: 1,
                  },
                  {
                    x: -1,
                  },
                ];

                //early break reduce
                outBool = Utils.early_break_reduce(arr_test, (acc, x, i, arr) => {
                  // logger.log("early_break_reduce", x.x);

                  const ev_1 = evaluateMathNode(mathNode_1, x);
                  const ev_2 = evaluateMathNode(mathNode_2, x);

                  const isEqual_ev = (ev_1 == ev_2);

                  return acc && isEqual_ev;
                }, true, (acc, x, i, arr) => {
                  return (acc == false);
                });

                return outBool;
              }

              outBool = evaluation_grid(mathNode_1, mathNode_2);
              if (outBool) {
                return outBool;
              }



              var expr__mathNode_1 = mathNode_1.toString();
              expr__mathNode_1 = expr__mathNode_1.replaceAll("×", "*");
              var expr__mathNode_2 = mathNode_2.toString();
              expr__mathNode_2 = expr__mathNode_2.replaceAll("×", "*");

              const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
              const algebrite_result = Algebrite.run(expr__equality);

              outBool = (algebrite_result == true);

            } else {

              const relationalNode = new math.RelationalNode(['equal'], [mathNode__above, mathNode__below]);
              // logger.log("relationalNode", relationalNode);

              outBool = relationalNode.evaluate();
            }

            return outBool;
          }


          const isSameValue_ = isSameValue(mathNode__above, mathNode__below);
          console.log("isSameValue_", isSameValue_);


          outBool = isSameValue_;

          return outBool;
        };


        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value": canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above, below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;

        const transformationFunc = (icObj) => {
          var outIcObj;

          logger.log("icGMBox original transformation func");

          return outIcObj;
        };

        const touchSlotConfig = {
          canTouchFunc: canTouchFunc,
          transformationFunc: transformationFunc,
          context: {},
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";



        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, targetMathNode);
        facade.backgroundColor = "orange";
        // facade.isTouchable     = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };


        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_boxTargetTouchSlot";

        // icComposite.isTouchable = false;


        //enrich touchSlotConfig.context
        infiniteCanvas.onceOnAddRepresentedForIcObject(facade, (facade) => {
          const facade__represented = infiniteCanvas.getRepresented(facade.id);
          // const facade__rep_free     = facade__represented.r_free();
          const facade__rep_official = facade__represented.r_official();

          touchSlotConfig.context.facade = facade__rep_official;
        });

        return icComposite;
      }


      createIcGMBlob(trueRect, targetMathNode) {
        console.log("createIcGMBlob", trueRect, targetMathNode);

        const canTouchFunc_geometryWise = (above, below, context) => {
          const contactArea = above.parts.contactArea;
          // const canTouchFunc = Touch.canTouch;
          const canTouchFunc = Touch2Singleton.sharedInstance().canTouch;

          return canTouchFunc(above, below);
        };

        const canTouchFunc_valueWise = (above, below, context) => {
          // logger.log("canTouchFunc_valueWise", above, below, context);
          var outBool;

          // const touchSlot = below;
          const facade = context.facade;

          const mathNode__above = above.parts.facade.mathNode;
          console.log("mathNode__above", mathNode__above);
          const mathNode__below = facade.mathNode;
          console.log("mathNode__below", mathNode__below);

          function isSameValue(mathNode_1, mathNode_2) {
            var outBool;

            function isContainingSymbolNode(mathNode) {
              var outBool;

              const arr_symbolNode = mathNode.filter(function (node) { return node.isSymbolNode; });

              outBool = (arr_symbolNode.length > 0);

              return outBool;
            }

            const isSymbolNode_in_either = isContainingSymbolNode(mathNode_1) || isContainingSymbolNode(mathNode_2);
            if (isSymbolNode_in_either) {

              function evaluateMathNode(mathNode, dict_subst) {
                // logger.log("evaluateMathNode, mathNode", mathNode);
                // logger.log("evaluateMathNode, dict_subst", dict_subst);
                return mathNode.evaluate(dict_subst);
              }

              function evaluation_grid(mathNode_1, mathNode_2) {
                var outBool;

                const arr_dict_subst = [
                  {
                    x: 0,
                  },
                  {
                    x: 1,
                  },
                  {
                    x: -1,
                  },
                ];

                //early break reduce
                outBool = Utils.early_break_reduce(arr_dict_subst, (acc, x, i, arr) => {
                  // logger.log("early_break_reduce", x.x);

                  const ev_1 = evaluateMathNode(mathNode_1, x);
                  const ev_2 = evaluateMathNode(mathNode_2, x);

                  const isEqual_ev = (ev_1 == ev_2);

                  return acc && isEqual_ev;
                }, true, (acc, x, i, arr) => {
                  return (acc == false);
                });

                return outBool;
              }

              outBool = evaluation_grid(mathNode_1, mathNode_2);
              if (outBool) {
                return outBool;
              }


              var expr__mathNode_1 = mathNode_1.toString();
              expr__mathNode_1 = expr__mathNode_1.replaceAll("×", "*");
              var expr__mathNode_2 = mathNode_2.toString();
              expr__mathNode_2 = expr__mathNode_2.replaceAll("×", "*");

              const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
              const algebrite_result = Algebrite.run(expr__equality);

              outBool = (algebrite_result == true);

            } else {

              const relationalNode = new math.RelationalNode(['equal'], [mathNode__above, mathNode__below]);
              // logger.log("relationalNode", relationalNode);

              outBool = relationalNode.evaluate();
            }

            return outBool;
          }


          const isSameValue_ = isSameValue(mathNode__above, mathNode__below);
          console.log("isSameValue_", isSameValue_);


          outBool = isSameValue_;

          return outBool;
        };


        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value": canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above, below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;

        const transformationFunc = (icObj) => {
          var outIcObj;

          // logger.log("icGMBox original transformation func");

          return outIcObj;
        };

        const touchSlotConfig = {
          canTouchFunc: canTouchFunc,
          transformationFunc: transformationFunc,
          context: {},
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";



        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, targetMathNode);
        facade.backgroundColor = "orange";
        // facade.isTouchable     = false;

        const curseFacade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "0");

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,

          "curseFacade": curseFacade,
        };


        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_blobTarget";

        // icComposite.isTouchable = false;


        //enrich touchSlotConfig.context
        infiniteCanvas.onceOnAddRepresentedForIcObject(facade, (facade) => {
          const facade__represented = infiniteCanvas.getRepresented(facade.id);
          // const facade__rep_free     = facade__represented.r_free();
          const facade__rep_official = facade__represented.r_official();

          touchSlotConfig.context.facade = facade__rep_official;
        });



        //curse: metamorphosis
        infiniteCanvas.onceOnAddRepresentedForIcObject(icComposite, (icComposite) => {

          const composite_represented = infiniteCanvas.getRepresented(icComposite.id);
          const composite_rep_free = composite_represented.r_free();

          const facade_rep_free = composite_rep_free.parts.facade;
          const curseFacade_rep_free = composite_rep_free.parts.curseFacade;


          // const countDownTrigger = infiniteCanvas.createCurseTrigger_countdown();
          infiniteCanvas.accurse__metamorphosis(facade_rep_free);

          const curseFunc = () => {
            // logger.log("curseFunc, rep_free:", facade_rep_free);
            const mathNode = random_constantNode();
            facade_rep_free.mathNode = mathNode;
            facade_rep_free.curse_metamorphosis.reset();
          };
          facade_rep_free.curse_metamorphosis.curseFunc = curseFunc;



          facade_rep_free.curse_metamorphosis.start();





          const curseTrigger = facade_rep_free.curse_metamorphosis.curseTrigger;
          // logger.log("curseTrigger", curseTrigger);

          // Hooker.installHooks(curseTrigger, "impulse");
          // curseTrigger.did["impulse"].on(() => {
          // logger.log("did impulse");
          // const countDownEngine = curseTrigger.engine;
          // const counter         = countDownEngine.getCounter();
          // curseFacade_rep_free.text = "" + counter;
          // });


          // facade_rep_free.curse_metamorphosis.start();

          facade_rep_free.curse_metamorphosis.rx_countDownCounter.subscribe({
            next: (value) => {
              // logger.log("rx_countDownCounter, next", value);
              // logger.log("curseFacade_rep_free", curseFacade_rep_free);

              curseFacade_rep_free.text = "" + value;
              // facade_rep_free.mathNode = new math.ConstantNode(value);
            },
          });


        });


        return icComposite;


        // keyboard_Rx.rx_keyUp.subscribe({
        //   next: (e) => {
        //     logger.log("e",e);
        //
        //     switch(e.code) {
        //       case "Numpad1":
        //         facade_rep_free.curse_metamorphosis.curseTrigger.impulse();
        //         break;
        //     }
        //
        //   },
        // });


      }



      createIcGMChallenge(trueRect, challengeIndex) {
        console.log("createIcGMChallenge", trueRect);

        const challengeName = "gmChallenge " + "#" + challengeIndex;
        const nameLabel = infiniteCanvas.createIcText(trueRect.x, trueRect.y, challengeName);
        backade.backgroundColor = "brown";
        backade.fill = "white";
        backade.isMobile = false;
        // backade.isTouchable = false;

        const gmChallengeConfig = GMChallengeMama.configForIndex(challengeIndex);

        const well = infiniteCanvas.createIcText(trueRect.x, trueRect.y, challengeName);

        const op1 = infiniteCanvas.createIcText(trueRect.x, trueRect.y, challengeName);

        const parts = {
          "nameLabel": nameLabel,

          "well": well,

          "op1": op1,
          "op2": op2,
          "op3": op3,
          "op4": op4,

          "targetSlot": targetSlot,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_challenge";

        // icComposite.isTouchable = false;


        return icComposite;

      }








      createIcObserver(trueRect, observerConfig_in = null) {
        console.log("createIcObserver");

        const infiniteCanvas = this;

        const type = "observer";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const arr_mathNode = infiniteCanvas.getAllRepresentedWithType("mathNode");
        console.log("arr_mathNode", arr_mathNode);
        // const mathNode_id  = arr_mathNode.find(e => true).id;
        const mathNode_id = arr_mathNode.find(e => true).r_official().id;
        console.log("mathNode_id", mathNode_id);
        const observed = {};
        if (mathNode_id != null) {
          observed[mathNode_id] = true;
        }

        var observerConfig = observerConfig_in;
        if (observerConfig == null) {
          observerConfig = {
            observerEngine: ObserverEngine.defaultInstance(infiniteCanvas, icObj),
            observed: observed,
          };
        }

        //debug
        // observerConfig.observerEngine.did['observe'].on((icObj_incoming) => {
        //   console.log("observerEngine.did['observe']", icObj_incoming);
        // });

        const icObserver_spec = {
          isSnappable: false,

          stroke: "#123123",
          strokeWidth: 5,

          fill: "#789456",

          observerConfig: observerConfig,
        };

        const icObserver = Object.assign(icObj, icObserver_spec);

        //add reactive part
        this.mutateObserver__addReactivePart(icObserver, observerConfig);

        return icObserver;
      }

      mutateObserver__addReactivePart(icObserver, observerConfig) {

        const infiniteCanvas = this;

        const observerEngine = observerConfig.observerEngine;

        observerEngine.start();
        infiniteCanvas.onIcObjUpdate(observerEngine.r_official_update_handler2);
      }

      createIcTrigger(trueRect, triggerConfig = null) {
        console.log("createIcTrigger");

        const infiniteCanvas = this;

        const type = "trigger";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icTrigger_spec = {
          isSnappable: false,

          stroke: "#123123",
          strokeWidth: 5,

          fill: "#888555",

          triggerConfig: triggerConfig,
        };

        const icTrigger = Object.assign(icObj, icTrigger_spec);

        //add reactive part
        this.mutateTrigger__addReactivePart(icTrigger, triggerConfig);

        return icTrigger;
      }

      mutateTrigger__addReactivePart(icTrigger, triggerConfig) {

      }

      createIcEventEmitter(trueRect) {

      }

      createIcEventReceiver(trueRect) {

      }

      createIcEye(trueRect) {
        logger.log("createIcEye", trueRect);
        const infiniteCanvas = this;

        const type = "eye";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icEye_spec = {
          rx: 0,
          ry: 0,
          strokeWidth: 3,
          strokeColor: "lime",
        };

        const icEye = Object.assign(icObj, icEye_spec);
        // return icEye;

        class EyeEngine {
          constructor() {

            this.initialized = false;

            this.initialize = function (scopeObj) {

              //"wake up":
              //bind all funcs
              // function isFunction(functionToCheck) {
              //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
              // }
              const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

              this.awoken = {
                'i_am': "awoken",
              };
              console.log("this.virgin", this.virgin);
              Object.entries(this.virgin)
                .filter(([propName, prop]) => isFunction(prop))
                .forEach(([propName, prop], i) => {
                  this.awoken[propName] = prop.bind(this.awoken);
                });

              // this.scopeObj  = scopeObj;
              //engineCarrier,
              //infiniteCanvas,
              this.awoken.scopeObj = scopeObj;

              this.initialized = true;
            }

            // this.r_official_update_handler2 = function(rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions
            //
            //   // logger.log("r_official_update_handler2", rep_official_incoming);
            //
            //   // console.log("engine::r_official_update_handler2, this", this);
            //   // console.log("this.scopeObj", this.scopeObj);
            //
            // };

            this.start = function () {
              console.log("engine::start, this", this);
              logger.log("dropTouchSlotEngine::start", "this.scopeObj", this.scopeObj);
              const infiniteCanvas = this.scopeObj.infiniteCanvas;
              const icEye = this.scopeObj.engineCarrier;

              // {
              //   function startRefreshLoop() {
              //     logger.log("log1", "startRefreshLoop");
              //
              //     /// get context from canvas (canvas not shown in example)
              //     var ctx    = canvas.getContext('2d'),
              //         toggle = true;                  /// this is used to reduce FPS
              //
              //     /// register refresh loop
              //     function refreshLoop() {
              //
              //         const represented  = infiniteCanvas.getRepresented(icVideo.id);
              //         // console.log("represented", represented);
              //         const rep_official = represented.r_official();
              //         const rep_free     = represented.r_free();
              //
              //         const video = icVideo.video;
              //
              //         /// reduce frame-rate to half
              //         // toggle = !toggle;
              //
              //         // if (toggle) {
              //           captureNewFrame();
              //         // }
              //
              //         function captureNewFrame() {
              //           // logger.log("log1", "setNewFrame");
              //
              //           ImageUtils.imageFromVideo_p(video).then((img) => {
              //             rep_free.img__captured = img;
              //           });
              //
              //           if(icObj.isShouldRequestAnimationFrame) {
              //             requestAnimationFrame(refreshLoop);
              //           }
              //
              //         }
              //
              //     }
              //
              //     icObj.isShouldRequestAnimationFrame = true;
              //     icObj.requestAnimationFrame         = requestAnimationFrame(refreshLoop);
              //
              //   }
              //
              //   startRefreshLoop();
              //
              // }

              //debug
              // setTimeout(function () {
              //   const img__captured = icEye.img__captured;
              //   infiniteCanvas.addNewImage(img__captured);
              // }, 6000);

              //create rx signal



              //listen to signal


            };

            this.stop = function () {
              // delete this.scopeObj;
            };


            this.virgin = Object.assign({}, this);  //virgin == not bound

          }
        }

        const engine = new EyeEngine();
        const eType = "eye";
        const icEngined = infiniteCanvas.installEngineOnIcObj(icEye, eType, engine);

        return icEngined;
      }


      createIcRxSubject(trueRect) {
        console.log("createIcRxSubject", trueRect);

        const infiniteCanvas = this;

        const type = "rxSubject";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRxSubject_spec = {

        };

        const icRxSubject = Object.assign(icObj, icRxSubject_spec);


        const engine = new RxSubjectEngine();
        const eType = "rxSubject";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icRxSubject, eType, engine);

        return icEngined;
      }

      createIcRxSubscription(trueRect) {
        console.log("createIcRxSubscription", trueRect);

        const infiniteCanvas = this;

        const type = "rxSubscription";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRxSubscription_spec = {

        };

        const icRxSubscription = Object.assign(icObj, icRxSubscription_spec);


        const engine = new RxSubscriptionEngine();
        const eType = "rxSubscription";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icRxSubscription, eType, engine);

        return icEngined;
      }





      createIcFacet_mathNode(trueRect) {
        console.log("createIcFacet_mathNode", trueRect);
        const infiniteCanvas = this;

        const mathNode = new math.ConstantNode("");
        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        facade.backgroundColor = "grey";
        facade.isMobile = true;
        // facade.isTouchable = false;

        const observer = infiniteCanvas.createIcObserver(trueRect, null);

        observer.observerConfig.observerEngine.did['observe'].on((icObj_incoming) => {
          const mathNode_incoming = icObj_incoming.mathNode;
          console.log("mathNode_incoming", mathNode_incoming);

          const mathNode_cloned = mathNode_incoming.clone();
          const mathNode_simplified = math.simplify(mathNode_cloned);

          // facade.mathNode = mathNode_simplified;
          const facade_represented = infiniteCanvas.getRepresented(facade.id);
          const facade_rep_free = facade_represented.r_free();

          facade_rep_free.mathNode = mathNode_simplified;
        });

        const parts = {
          "observer": observer,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "facet_mathNode";

        // icComposite.isTouchable = false;


        return icComposite;
      }




      //icEngined

      installEngineOnIcObj(icObj, eType, engine) {
        console.log("promotedToIcEngined", icObj, eType, engine);

        const dict_engine__icObj = icObj.dict_engine;

        var index_start;
        if (dict_engine__icObj == null) {
          index_start = 0;
        } else {
          index_start = Object.values(dict_engine__icObj).reduce((acc, x) => {
            // logger.log("index_start", "x", x);
            const index_start__existingEngine = x.index_start;
            acc = Math.max(index_start__existingEngine, acc);
            return acc;
          }, 0) + 1;
        }

        const icEngined_spec = {
          dict_engine: {
            [eType]: {
              engine: engine,
              index_start: index_start,
            },
          },
        };

        var icEngined;
        if (icObj.dict_engine == null) {
          icEngined = Object.assign(icObj, icEngined_spec);
        } else {
          // Object.assign(icObj.dict_engine, icEngined_spec.dictEngine);
          icObj.dict_engine[eType] = {
            engine: engine,
            index_start: index_start,
          };
          icEngined = icObj;
        }

        Enginiter.installEngine(icEngined, engine);

        return icEngined;
      }

      uninstallEngineOnIcObj(icEngined, eType) {
        console.log("uninstallEngineOnIcObj", icEngined);

        const engine = icEngined.dict_engine[eType];

        Enginiter.uninstallEngine(icEngined, engine);

        const icObj = icEngined;

        delete icObj.dict_engine[eType];
        if (Object.values(icObj.dict_engine).length == 0) {
          delete icObj.dict_engine;
        }

        return icObj;
      }

      createIcEngined_debug(trueRect) {
        console.log("createIcEngined_debug", trueRect);

        const engineCarrier = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "icEngined_debug");
        engineCarrier.backgroundColor = "gold";

        const eType1 = "debug__growText";
        const engine1 = new DebugEngine_growText();
        const icEngined1 = infiniteCanvas.installEngineOnIcObj(engineCarrier, eType1, engine1);
        logger.log("icEngined1", icEngined1);

        const eType2 = "debug__changeColor";
        const engine2 = new DebugEngine_changeColor();
        const icEngined2 = infiniteCanvas.installEngineOnIcObj(icEngined1, eType2, engine2);
        logger.log("icEngined2", icEngined2);

        return icEngined2;
      }





      createIcCountdown(trueRect, countDownConfig_in = null) {
        console.log("createIcCountdown", trueRect);
        const infiniteCanvas = this;

        const mathNode = new math.ConstantNode("");
        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        facade.backgroundColor = "grey";
        facade.isMobile = true;
        facade.isTouchable = true;  //:)

        class CountDownEngine {
          constructor(facade, countDownConfig_in = null) {

            var countDownConfig = countDownConfig_in;
            if (countDownConfig == null) {
              countDownConfig = CountDownConfig.defaultConfig();
            }

            this.counter_start = countDownConfig.value_start;
            this.counter_end = countDownConfig.value_end;

            this.stepFunc = countDownConfig.stepFunc;
            this.stepDuration = countDownConfig.stepDuration;

            const nb_steps = math.abs(this.counter_end - this.counter_start);
            this.nb_steps = nb_steps;

            this.arr_steps = [...new Array(nb_steps).keys()];
            this.step_current = 0;

            this.counter = this.counter_start;

            this.progress = 0;

            this.isPaused = true;

            const duration = this.nb_steps * this.stepDuration;

            this.animatedObj = {
              progress: 0
            };

            const countDownEngine = this;
            const animatedObj = this.animatedObj;
            const animation = anime({
              // targets: countDownEngine,
              targets: animatedObj,

              /*animated props*/
              progress: 1,
              /*--------------*/

              direction: 'normal',
              easing: 'linear',
              duration: duration,

              autoplay: false,

              update: (anim) => {
                const progress = anim.progress / 100;
                countDownEngine.progress = progress;
                countDownEngine.update(progress);
              },
            });

            this.animation = animation;




            this.start = function () {
              const countDownEngine = this;

              countDownEngine.stepFunc(0);
              countDownEngine.play();
            };
            // }.bind(this);

            this.stop = function () {
              const countDownEngine = this;

              countDownEngine.reset();
            };
            // }.bind(this);

            this.play = function () {
              const countDownEngine = this;

              const date_play = new Date();
              countDownEngine.date_play = date_play;

              countDownEngine.isPaused = false;
              countDownEngine.animation.play();
            };
            // }.bind(this);

            this.pause = function () {
              const countDownEngine = this;

              const date_pause = new Date();
              countDownEngine.date_pause = date_pause;

              countDownEngine.animation.pause();
              countDownEngine.isPaused = true;
            };
            // }.bind(this);

            this.reset = function () {
              const countDownEngine = this;

              countDownEngine.animation.reset();
            };
            // }.bind(this);

            this.update = function (progress) {
              console.log("update", progress);
              const countDownEngine = this;

              const cursor = progress * countDownEngine.nb_steps;
              const step_cursor = math.floor(cursor);

              const isStepChanged = (step_cursor - countDownEngine.step_current) >= 1;
              if (isStepChanged) {
                countDownEngine.step_current = step_cursor;
                countDownEngine.stepFunc(step_cursor);
              }
            };
            // }.bind(this);

          }

          /*
          start() {
            this.stepFunc(0);
            this.play();
          }

          stop() {
            this.reset();
          }

          play() {
            const countDownEngine = this;

            const date_play           = new Date();
            countDownEngine.date_play = date_play;

            countDownEngine.isPaused = false;
            countDownEngine.animation.play();
          }

          pause() {
            const countDownEngine = this;

            const date_pause           = new Date();
            countDownEngine.date_pause = date_pause;

            countDownEngine.animation.pause();
            countDownEngine.isPaused = true;
          }

          reset() {
            countDownEngine.animation.reset();
          }

          update(progress) {
            console.log("update", progress);
            const cursor      = progress * this.nb_steps;
            const step_cursor = math.floor(cursor);

            const isStepChanged = (step_cursor - this.step_current) >= 1;
            if(isStepChanged) {
              this.step_current = step_cursor;
              this.stepFunc(step_cursor);
            }
          }
          */

        }

        class CountDownConfig {

          constructor(value_start, value_end, stepFunc, stepDuration) {
            this.value_start = value_start;
            this.value_end = value_end;

            this.stepFunc = stepFunc;
            this.stepDuration = stepDuration;
          }

          static defaultConfig() {
            var outConfig;

            const value_start = 10;
            const value_end = 0;

            const stepFunc = (stepIndex) => {
              console.log("stepFunc", stepIndex);
            };

            const stepDuration = 1000;

            outConfig = new CountDownConfig(value_start, value_end, stepFunc, stepDuration);

            return outConfig;
          }

        }

        const countDownConfig = CountDownConfig.defaultConfig();
        countDownConfig.stepFunc = (stepIndex) => {
          console.log("stepFunc", stepIndex);

          const facade_represented = infiniteCanvas.getRepresented(facade.id);
          const facade_rep_free = facade_represented.r_free();

          const mathNode = new math.ConstantNode(stepIndex);
          facade_rep_free.mathNode = mathNode;
        };

        const engine = new CountDownEngine(facade, countDownConfig);
        console.log("fresh engine", engine);
        const eType = "countdown";

        const icEngined = infiniteCanvas.installEngineOnIcObj(facade, eType, engine);

        return icEngined;
      }



      createIcInteractor(trueRect, interactorConfig_in = null) {
        console.log("createIcCountdown", trueRect);
        const infiniteCanvas = this;

        // const mathNode = new math.ConstantNode("");
        // const facade   = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "interactor");
        facade.backgroundColor = "gold";
        facade.isMobile = true;
        facade.isTouchable = true;  //:)

        class InteractorEngine {
          constructor() {

            this.initialized = false;

            this.initialize = function (scopeObj) {
              this.initialized = true;
              this.scopeObj = scopeObj;
            }

            this.start = function () {
              console.log("this.scopeObj.facade", this.scopeObj.facade);
            };

            this.stop = function () {

            };

            this.interact = function () {
              console.log("interact");

              this.scopeObj.facade.text += "+";
            };

          }
        }

        const engine = new InteractorEngine();
        console.log("fresh engine", engine);
        const eType = "interactor";

        const icEngined = infiniteCanvas.installEngineOnIcObj(facade, eType, engine);

        return icEngined;
      }


      createIcGeminiShade(icObj) {
        console.log("createIcGeminiShade", icObj);
        const infiniteCanvas = this;

        const icObj__clone = icObj.deepClone();
        const id__clone = infiniteCanvas.generateIcObjectId();
        icObj__clone.id = id__clone;

        const icGeminiShade_spec = {
          id__target: icObj.id,

          opacity: 0.666,
          fill: "grey",
        };

        const icGeminiShade = Object.assign(icObj__clone, icGeminiShade_spec);

        const engine = new GeminiShadeEngine();
        const eType = "geminiShade";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icGeminiShade, eType, engine);

        return icEngined;
      }




      //add
      addIcObject(icObj) {
        console.log("addIcObject", icObj);

        const represented = this.createRepresentedIcObject(icObj);
        this.addRepresented(represented);

      }

      addIcObject_p(icObj) {
        var out_p;

        out_p = new Promise((resolve, reject) => {

          infiniteCanvas.onceOnAddRepresentedForIcObject(icObj, async (icObj) => {

            const represented = infiniteCanvas.getRepresented(icObj.id);
            const rep_free = represented.r_free();

            resolve(rep_free);
          });
          infiniteCanvas.addIcObject(icObj);

        });

        return out_p;
      }

      didAddIcObject(icObj) {

      }

      addRepresented(represented) {
        console.log("addRepresented", represented);

        const id_icObj = represented.r_official().id;
        const represented_check = this.getRepresented(id_icObj);
        if (represented_check != null) {
          //ignore
          console.log("represented already added => ignore");
          return;
        }

        this.tetherIcObject(represented);   //== track icObj updates

        this.introduceToExistingObjects(represented);

        //store
        const rep_official = represented.r_official();
        this.represented[rep_official.id] = represented;

        //add free representation
        const rep_free = represented.r_free();
        this.addRepresentation(represented, rep_free);

        if (rep_official.type == "composite") {
          Object.values(represented.parts).forEach((part__represented, i) => {
            this.addRepresented(part__represented);
          });
        }

        this.didAddRepresented(represented);
      }

      didAddRepresented(represented) {
        this.setChanged(true);

        this.didAddRepresentedListeners.forEach((listener, i) => {
          listener(represented);
        });
      }

      onAddRepresented(listener) {
        this.didAddRepresentedListeners.push(listener);
      }

      offAddRepresented(listener) {
        this.didAddRepresentedListeners = Utils.arrayByRemovingElement(this.didAddRepresentedListeners, listener);
      }

      onceOnAddRepresentedForIcObject(icObject, func) {

        var autoUnsub = (represented) => {

          //compare icObject with represented
          const r_official = represented.r_official();
          if (r_official.id == icObject.id) {
            this.offAddRepresented(autoUnsub);
            func(icObject);
          }

        }

        this.onAddRepresented(autoUnsub);
      }

      removeRepresented(represented, shouldAlsoRemoveChildren = false) {
        logger.log("log1", "removeRepresented", represented);

        // if(represented == null) {
        //   throw new Error("represented == null");
        // }

        const id_icObj = represented.r_official().id;
        const represented_check = this.getRepresented(id_icObj);
        if (represented_check == null) {
          //ignore
          console.log("represented already removed => ignore");
          return;
        }

        //remove from parent (if any)
        const rep_free = represented.r_free();
        if (rep_free.compositeId != -1) {
          const rep_free__parent = infiniteCanvas.getRepresented(rep_free.compositeId).r_free();
          rep_free__parent.dict_engine["composite"].engine.awoken.removePart(rep_free);
        }

        if (shouldAlsoRemoveChildren) {
          if (represented.r_official().type == "composite") {
            Object.values(represented.parts).forEach((part__represented, i) => {
              this.removeRepresented(part__represented, shouldAlsoRemoveChildren);
            });
          }
        }

        const isEngined = (represented.r_official().dict_engine != null);
        if (isEngined) {
          Object.keys(represented.r_free().dict_engine).forEach(eType => {
            represented.r_free().dict_engine[eType].engine.awoken.stop();
          });
        }

        if (represented.r_official().type == "video") {
          const video = represented.r_free().video;
          logger.log("log1", "removeRepresented", "video", video);
          video.pause();

          //stop stream if any
          if (video.srcObject instanceof MediaStream) {
            const stream = video.srcObject;
            stream.getTracks().forEach(function (track) {
              track.stop();
            });
          }

          video.remove();
        }



        this.untetherIcObject(represented);   //== stop tracking icObj updates

        this.extroduceFromExistingObjects(represented);

        //unstore
        //representations
        Object.values(represented.reps).forEach((rep, i) => {
          this.removeRepresentation(represented, rep);
        });


        //represented
        const rep_official = represented.r_official();
        const id_represented = rep_official.id;
        // this.represented[id_represented] = null;
        delete this.represented[id_represented];


        //deconstruct
        represented.deconstruct();

        this.didRemoveRepresented(represented);
      }

      didRemoveRepresented(represented) {
        // logger.log("didRemoveRepresented", represented);

        this.setChanged(true);

        this.didRemoveRepresentedListeners.forEach((listener, i) => {
          listener(represented);
        });
      }

      onRemoveRepresented(listener) {
        this.didRemoveRepresentedListeners.push(listener);
      }

      offRemoveRepresented(listener) {
        this.didRemoveRepresentedListeners = Utils.arrayByRemovingElement(this.didRemoveRepresentedListeners, listener);
      }










      addRepresentation(represented, representation) {

        if (this.representations[representation.id_rep] == null) {
          this.representations[representation.id_rep] = representation;
        } else {
          throw new Error("oh, no, id collision for id: " + representation.id_rep);
        }

        this.didAddRepresentation(represented, representation);
      }

      didAddRepresentation(represented, representation) {
        this.setChanged(true);

        this.didAddRepresentationListeners.forEach((listener, i) => {
          listener(represented, representation);
        });

        this.redrawCanvas(RedrawOccasion.objectAdded);
      }

      removeRepresentation(represented, representation) {

        // if(this.representations[representation.id_rep] != null) {
        delete this.representations[representation.id_rep];
        // }

        this.didRemoveRepresentation(represented, representation);
      }

      didRemoveRepresentation(represented, representation) {
        this.setChanged(true);

        // this.didAddObjectListeners.forEach((listener, i) => {
        //   listener(icObj);
        // });

        this.redrawCanvas(RedrawOccasion.objectRemoved);
      }

      addPureIcObject(icObj) {

        this.pure_icObjects["any"].push(icObj);


        if (this.pure_icObjects[icObj.type] == null) {
          this.pure_icObjects[icObj.type] = [];
        }
        this.pure_icObjects[icObj.type].push(icObj);

        this.didAddPureObject(icObj);
      }

      didAddPureObject(icObj) {
        this.didAddPureObjectListeners.forEach((listener, i) => {
          listener(icObj);
        });

        this.redrawCanvas(RedrawOccasion.pureObjectAdded);
      }


      removeIcObject(icObj) {
        console.log("removeIcObject", icObj);

        //SHU TODO: removeIcObject


        this.didRemoveObject_p(icObj);
      }

      didRemoveObject_p(icObj) {
        this.setChanged(true);

        // this.didAddObjectListeners.forEach((listener, i) => {
        //   listener(icObj);
        // });
        //
        // this.redrawCanvas(RedrawOccasion.objectRemoved);
      }

      // manageIcObjUpdate(icObj, requestCanvasRedraw = false) {
      //   console.log("manageIcObjUpdate");
      //
      //   if(icObj.toBeDeleted) {
      //     console.log("this", this);
      //     this.removeIcObject(icObj);
      //   }
      //
      //   this.icObjDidUpdate(icObj);
      //
      //   this.setChanged(true);
      // }



      createIcEvent__icObjUpdate(icObj, outerUpdatesDict) {
        logger.log("createIcEvent", icObj, outerUpdatesDict);
        var outIcEvent;

        const infiniteCanvas = this;

        if (outerUpdatesDict.position) {

          var time = performance.now();
          logger.log("time", time);

          // var timestamp = Date.now();
          // logger.log("timestamp", timestamp);

          const icObj__id = icObj.id;
          const position__new = Object.assign({}, outerUpdatesDict.position.new);

          const revision = infiniteCanvas.generateIcEventIndex();

          const icEvent__move = {
            // type: "move",
            data: {
              id: icObj__id,
              position: position__new,
              time: time,
            },

            //SHU: wolken-related
            context: {
              name: 'ux',
            },
            aggregate: {
              name: 'icObject',
              id: uuid__unknown,
            },
            name: 'icObjMoved',

            metadata: {
              correlationId: uuid__unknown,
              causationId: uuid__unknown,

              revision: revision,
              timestamp: time,
            },

          };

          outIcEvent = icEvent__move;
        }

        //for hexmap
        else if (outerUpdatesDict.isHeld) {

          var time = performance.now();
          logger.log("time", time);

          const icObj__id = icObj.id;
          const isHeld__new = Object.assign({}, outerUpdatesDict.isHeld.new);

          const revision = infiniteCanvas.generateIcEventIndex();

          const icEvent__hold = {
            // type: "hold",
            data: {
              id: icObj__id,
              isHeld: isHeld__new,
              time: time,
            },

            //SHU: wolken-related
            context: {
              name: 'ux',
            },
            aggregate: {
              name: 'icObject',
              id: uuid__unknown,
            },
            name: 'icObjHeld',

            metadata: {
              correlationId: uuid__unknown,
              causationId: uuid__unknown,

              revision: revision,
              timestamp: time,
            },

          };

          outIcEvent = icEvent__hold;
        }

        return outIcEvent;
      }

      recordIcEvent_p(eventstore__, icEvent) {
        var out_p;

        const state = {
          desc: "lolilol",
        };

        async function saveEvent(icEvent) {

          const event = new Event(icEvent);
          // const event = new Event({
          //   context:   icEvent.context,
          //   aggregate: icEvent.aggregate,
          //   name:      icEvent.name,
          //   data:      icEvent.data,
          //   // custom:    icEvent.custom,
          //   metadata:  icEvent.metadata,
          // });
          event.metadata.revision = icEvent.metadata.revision;

          const arr_event__saved = await eventstore__.saveEvents({
            uncommittedEvents: [
              { event: event, state: state },
            ],
          });

          const id__aggregate = uuid__unknown;
          const revision = icEvent.metadata.revision;

          await eventstore__.markEventsAsPublished({
            aggregateId: id__aggregate,
            fromRevision: revision,
            toRevision: revision,
          });

          // const event__last = await eventstore__.getLastEvent(id__aggregate);
          // return event__last;

          return event;
        }

        out_p = saveEvent(icEvent);
        // .then(event__last => {
        //   logger.log("event__last", event__last);
        // });

        return out_p;
      }


      icObjDidUpdate(icObj, outerUpdatesDict) {
        logger.log("icObjDidUpdate", icObj, outerUpdatesDict);

        //SHU FLUID
        //create event
        const icEvent__icObjUpdate = this.createIcEvent__icObjUpdate(icObj, outerUpdatesDict);
        // const icEvent__icObjUpdate = null;   //debug
        if (icEvent__icObjUpdate != null) {
          //"publish" event
          //so that it's somehow saved somewhere
          this.rx_icEvent_subject.next(icEvent__icObjUpdate);
        }


        //original iC update forwarding
        this.icObjListeners.forEach((listener, i) => {
          logger.log("icObjDidUpdate", "listener()", listener);
          listener(icObj, outerUpdatesDict);
        });
      }

      onIcObjUpdate(listener) {
        this.icObjListeners.push(listener);
      }

      offIcObjUpdate(listener) {
        this.icObjListeners = Utils.arrayByRemovingElement(this.icObjListeners, listener);
      }


      addDehydratedIcObject(icObj) {
        const rehydrated = this.rehydrated(icObj);

        this.addIcObject(rehydrated);
      }

      rehydrated(icObj) {
        var rehydrated;

        // rehydrated = icObj.clone();
        rehydrated = icObj.deepClone();


        // switch(icObj.type) {
        //   case "snapSlot":
        //     const icSnapSlot = rehydrated;
        //     //add reactive part
        //     this.mutateSnapSlot__addReactivePart(icSnapSlot);
        //     rehydrated = icSnapSlot;
        //     break;
        //   default:
        //   break;
        // }

        return rehydrated;
      }

      addPastedIcObject(icObj) {
        const infiniteCanvas = this;

        const true_cursor = this.getTrueCursor();

        icObj.position = {
          x: true_cursor.x,
          y: true_cursor.y,
        };

        icObj.homeScale = {
          X: infiniteCanvas.scale.X,
          Y: infiniteCanvas.scale.Y,
        };

        infiniteCanvas.addIcObject(icObj);
      }


      //convenience

      addNewIcObject(icObj) {

        icObj.orientation = this.orientation;

        const inputProperties = this.inputProperties;

        const activeColor = inputProperties.getActiveColor();
        switch (icObj.type) {
          case "rect":
          case "point":
          case "sparkle":
          case "spot":
            icObj.fill = activeColor;
            break;
          case "text":
            icObj.textColor = activeColor;
            break;
          case "circle":
          case "ellipse":
            icObj.stroke = activeColor;
            break;

          case "svg":
            icObj.stroke = activeColor;
            icObj.strokeWidth = 5;

            icObj.fill = "yellow";
            break;

          case "observer":
          case "trigger":
          case "eventEmitter":
          case "eventReceiver":
            break;

          case "eye":
            break;

          case "snapSlot":
            break;
          case "freeDrawing":
            break;

          default:
            icObj.fill = activeColor;
            break;
        }

        icObj.opacity = inputProperties.getActiveOpacity();

        icObj.zIndex = this.getFreshZIndex();

        this.addIcObject(icObj);
      }

      addNewRect() {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const icRect = this.createIcRect_withLTWH(left, top, width, height);
        this.addNewIcObject(icRect);
      }

      addNewText(text = "icText") {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icText = this.createIcText(left, top, text);

        // //debug
        // const width  = 100;   //"information" size
        // const height = 100;
        // icText.width  = width;
        // icText.height = height;

        this.addNewIcObject(icText);
      }

      addNewTag(text = "icTag") {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icTag = this.createIcTag(left, top, text);

        this.addNewIcObject(icTag);
      }


      addNewImage(img) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icImage = this.createIcImage(left, top, img);
        this.addNewIcObject(icImage);
      }

      addNewVideo(video) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icVideo = this.createIcVideo(left, top, video);
        this.addNewIcObject(icVideo);
      }

      addNewCircle() {
        const true_cursor = this.getTrueCursor();
        const radius = 100;

        const icCircle = this.createIcCircle(true_cursor, radius, { isUsingCenterPosition: true, });
        this.addNewIcObject(icCircle);
      }

      addNewPoint() {
        const true_cursor = this.getTrueCursor();

        const icPoint = this.createIcPoint(true_cursor);
        this.addNewIcObject(icPoint);


        /*
        //debug
        const point_from = this.cursor;
        const center     = this.getScreenCenterPoint();

        [10,20,30,70,80,90,  270,300, -85].forEach((angleInDegrees, i) => {

          const screenPoint = Geometry.pointWithRotation(point_from, center, angleInDegrees);
          // console.log("screenPoint", screenPoint);

          this.addPoint(this.toTruePoint(screenPoint));
        });
        */

        // function debugRotation(point_from, center) {
        //
        //   [10,20,30,70,80,90].forEach((angleInDegrees, i) => {
        //
        //     const screenPoint = Geometry.pointWithRotation(point_from, center, angleInDegrees);
        //     this.addPoint(screenPoint);
        //   });
        //
        // }
        //
        // debugRotation(this.cursor, screenCenterPoint);


      }

      addNewSpotPoint() {
        const true_cursor = this.getTrueCursor();

        const size = {
          width:  30,
          height: 30,
        };

        const icSpotPoint = this.createIcSpotPoint(true_cursor, size);
        this.addNewIcObject(icSpotPoint);

      }

      addNewToggleRect() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const activeCfg = {
          fill: "green",
          opacity: 1.0,
        };
        const inactiveCfg = {
          fill: "red",
          opacity: 0.3,
        };

        const isActive = false;

        const icToggleRect = this.createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive);
        this.addNewIcObject(icToggleRect);
      }

      // addPurePoint(point) {
      //   const icPoint = this.createIcPoint(point);
      //   this.addPureIcObject(icPoint);
      // }
      //
      // addPureCircle(center, radius) {
      //
      //   const icCircle = this.createIcCircle(center, radius);
      //   this.addPureIcObject(icCircle);
      //
      // }

      addNewSvg(svgEl) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icSvg = this.createIcSvg(left, top, svgEl);
        this.addNewIcObject(icSvg);
      }

      addNewTex(tex) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icTex = this.createIcTex(left, top, tex);
        this.addNewIcObject(icTex);
      }

      addNewMathNode(mathNode) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icMathNode = this.createIcMathNode(left, top, mathNode);
        this.addNewIcObject(icMathNode);
      }

      addNewMNReictangle(mathNode) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icMNReictangle = this.createIcMNReictangle(left, top, mathNode);
        icMNReictangle.isTouchable = true;
        this.addNewIcObject(icMNReictangle);
      }

      addNewHtmlElt(html_elt) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icHtmlElt = this.createIcHtmlElt(left, top, html_elt);
        this.addNewIcObject(icHtmlElt);
      }


      addNewSnapSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icSnapSlot = this.createIcSnapSlot(trueRect);
        this.addNewIcObject(icSnapSlot);
      }

      addNewSparkle(img) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        // const width  = 100;   //"information" size
        // const height = 100;

        // const trueRect = Geometry.createRect(left, top, width, height);

        const sparkleConfig = {

        };

        // const icSparkle = this.createIcSparkle(trueRect, img, sparkleConfig);
        const icSparkle = this.createIcSparkle(true_cursor, img, sparkleConfig);
        this.addNewIcObject(icSparkle);
      }


      addNewTouchSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };


        const toucher = Toucher.debugInstance();

        const touchSlotConfig = {
          transformationFunc: toucher.transformationFunc,
        };

        const icTouchSlot = this.createIcTouchSlot(trueRect, touchSlotConfig);
        this.addNewIcObject(icTouchSlot);
      }

      getNextTouchSlotRank() {
        var outNumber;
        const arr_touchSlot = Object.values(this.represented)
          .map(represented => represented.r_official())
          .filter(rep => (rep.type == "touchSlot"));
        outNumber = arr_touchSlot.length;
        return outNumber;
      }




      addNewComposite() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icComposite = this.createIcComposite_debug(trueRect);
        this.addNewIcObject(icComposite);
      }

      addNewGreenMouseBox(mathNode) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icComposite = this.createIcGreenMouseBox(trueRect, mathNode);
        this.addNewIcObject(icComposite);
      }

      // composed(trueRect, arr_icObj) {
      //   var outIcObj;
      //
      //   const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
      //   const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
      //
      //   return outIcObj;
      // }


      addNewCollection(collectionStr) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const collectionConfig = this.parseCollectionStr(collectionStr);

        const icCollection = this.createIcCollection(trueRect, collectionConfig);
        this.addNewIcObject(icCollection);
      }

      parseCollectionStr(collectionStr) {
        var outConfig;

        var arr_elements = collectionStr.split("..");
        var min = parseInt(arr_elements[0]);
        var max = parseInt(arr_elements[1]);
        var step = 1;

        outConfig = {
          min: min,
          max: max,
          step: step,
        };

        return outConfig;
      }


      compose(arr_icObj) {
        console.log("compose", arr_icObj);
        const infiniteCanvas = this;

        function debugTrueRect(infiniteCanvas) {
          const true_cursor = infiniteCanvas.getTrueCursor();

          const left = true_cursor.x;
          const top = true_cursor.y;

          const width = 100;   //"information" size
          const height = 100;

          const trueRect = {
            x: left,
            y: top,
            width: width,
            height: height,
          };

          return trueRect;
        }

        const trueRect = debugTrueRect(infiniteCanvas);
        console.log("trueRect", trueRect);

        const parts = arr_icObj; //SHU: arr is an obj with propNames = indexes
        // const parts = {
        //   "1": arr_icObj[0],
        //   "2": arr_icObj[1],
        // };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, true);

        const icComposite = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
        // icComposite.cType = cType;

        icComposite.isTouchable = true;

        icComposite.stroke = "cyan";
        icComposite.strokeWidth = 5;




        //get tag object (if any)
        const tag = arr_icObj.find(icObj => icObj.type == "tag");

        var cType;
        if (tag != null) {
          cType = tag.text;
        } else {
          cType = "anonymous";
        }
        icComposite.cType = cType;


        if (tag != null) {
          //stick tag next to handle

          // tag.isMobile = false;
          // compositeConfig.parts[tag].isMobile = false;

          tag.position = {
            x: icComposite.position.x + icComposite.size.width,
            y: icComposite.position.y,
          };
        }



        this.addNewIcObject(icComposite);
      }

      decompose(icComposite) {
        console.log("decompose", icComposite);

        const arr_parts = Object.values(icComposite.parts);

        // arr_parts.forEach((part, i) => {
        //   part.compositeId     = -1;
        //   part.isCompositePart = false;
        //   // part.isMobile        = false;
        // });

        // icComposite.engine.stop();
        icComposite.dict_engine["composite"].engine.awoken.stop();

        const represented = this.getRepresented(icComposite.id);
        const rep_free = represented.r_free();
        rep_free.im_dying_now = true;

        // this.removeRepresented(represented);
      }

      killComposite(icComposite) {
        console.log("killComposite", icComposite);

        const arr_parts = Object.values(icComposite.parts);



        // icComposite.engine.stop();
        icComposite.dict_engine["composite"].engine.awoken.stop();

        const represented = this.getRepresented(icComposite.id);
        const rep_free = represented.r_free();
        rep_free.im_dying_now = true;

        // this.removeRepresented(represented);



        arr_parts.forEach((icObj, i) => {
          if (icObj.type == "composite") {
            this.killComposite(icObj);
          } else {
            icObj.im_dying_now = true;
          }
        });


      }

      link(icObj__1, icObj__2) {
        logger.log("infiniteCanvas::unlink", icObj__1, icObj__2);

        const infiniteCanvas = this;

        const icObj__link = infiniteCanvas.createIcLink();


      }

      unlink(icObj__link) {
        logger.log("infiniteCanvas::unlink", icObj__link);


      }


      spreadApart__centered(arr_icObj) {
        logger.log("spreadApart", arr_icObj);
        const infiniteCanvas = this;

        var isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);
        logger.log("spreadApart", "isIntersecting", isIntersecting);

        while (isIntersecting) {

          //spread push
          infiniteCanvas.spread_push(arr_icObj);

          isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);

        }

      }

      spreadApart__2by2(arr_icObj) {
        logger.log("spreadApart__2by2", arr_icObj);
        const infiniteCanvas = this;

        var isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);
        logger.log("spreadApart__2by2", "start: isIntersecting (all)", isIntersecting);

        while (isIntersecting) {

          //get all pairs
          const arr_pair = MathUtils.arrOfPairs(arr_icObj);
          logger.log("arr_pair", arr_pair);

          arr_pair.forEach(([icObj_1, icObj_2], i) => {
            logger.log("[icObj_1, icObj_2]", [icObj_1, icObj_2]);

            //spread pair if needed
            const isIntersecting__pairWise = infiniteCanvas.checkIntersecting([icObj_1, icObj_2]);
            if (isIntersecting__pairWise) {
              infiniteCanvas.spread_push__binary([icObj_1, icObj_2]);
            }
          });

          isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);
          logger.log("spreadApart__2by2", "while: isIntersecting (all)", isIntersecting);
        }

      }

      // spreadApart__recursive(arr_icObj) {
      //   logger.log("spreadApart", arr_icObj);
      //   const infiniteCanvas = this;
      //
      //   var isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);
      //   logger.log("spreadApart", "isIntersecting", isIntersecting);
      //
      //   while(isIntersecting) {
      //
      //     //spread push
      //     if(arr_icObj.length > 2) {
      //       const arr_tail = arr_icObj.slice(1);
      //       infiniteCanvas.spreadApart__recursive(arr_tail);
      //       isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);
      //     } else if(arr_icObj.length == 2) {
      //       infiniteCanvas.spread_push__binary(arr_icObj);
      //       isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);
      //     } else {
      //       isIntersecting = false;
      //     }
      //
      //   }
      //
      // }

      getTrueRect_hack(icObj) {
        const infiniteCanvas = this;

        const fObj = fabricIntegration.getFObjForIcObj(icObj);    //SHU: horror
        const screenRect = {
          left: fObj.left,
          top: fObj.top,
          width: fObj.width,
          height: fObj.height,
        };
        const trueRect = infiniteCanvas.toTrueRect(screenRect);
        return trueRect;
      }

      checkIntersecting(arr_icObj) {
        logger.log("checkIntersecting", arr_icObj);
        var outBool;

        const infiniteCanvas = this;

        const arr_pair = MathUtils.arrOfPairs(arr_icObj);

        outBool = Utils.early_break_reduce(arr_pair, (acc, [icObj_1, icObj_2], index, arr) => {

          // const rect__icObj = icObj.getRect();
          const rect__1 = infiniteCanvas.getTrueRect_hack(icObj_1);
          const rect__2 = infiniteCanvas.getTrueRect_hack(icObj_2);

          const isIntersecting__pair = Geometry.intersectRect(rect__1, rect__2);
          logger.log("isIntersecting__pair", icObj_1.id, icObj_2.id, isIntersecting__pair);

          return acc || isIntersecting__pair;
        }, false, (acc, x, i, arr) => {
          return (acc == true);
        });

        return outBool;
      }

      getBarycenter(arr_icObj) {
        var outPoint;

        outPoint = arr_icObj.reduce((acc, icObj) => {
          const pointCenter = {
            x: icObj.position.x + icObj.size.width / 2.0,
            y: icObj.position.y + icObj.size.height / 2.0,
          };
          return {
            x: acc.x + pointCenter.x,
            y: acc.y + pointCenter.y,
          };
        }, {
          x: 0,
          y: 0,
        });

        outPoint.x = math.floor(outPoint.x / arr_icObj.length);
        outPoint.y = math.floor(outPoint.y / arr_icObj.length);

        return outPoint;
      }

      spread_push(arr_icObj) {
        // logger.log("spread_push", arr_icObj);

        const infiniteCanvas = this;

        if (arr_icObj.length == 2) {
          infiniteCanvas.spread_push__binary(arr_icObj);
        } else {
          const point__barycenter = infiniteCanvas.getBarycenter(arr_icObj);
          arr_icObj.forEach((icObj, i) => {
            const factor__push = 1.1;
            infiniteCanvas.centered_push(point__barycenter, icObj, factor__push);
          });
        }

      }

      spread_push__binary(arr_icObj) {
        // logger.log("spread_push__binary", arr_icObj);

        const icObj_1 = arr_icObj[0];
        const icObj_2 = arr_icObj[1];

        // const rect__1 = icObj_1.getRect();
        // const rect__2 = icObj_2.getRect();
        const rect__1 = infiniteCanvas.getTrueRect_hack(icObj_1);
        const rect__2 = infiniteCanvas.getTrueRect_hack(icObj_2);

        // logger.log("rect__1", rect__1);

        const pointCenter1 = Geometry.getCenterPoint(rect__1);
        const pointCenter2 = Geometry.getCenterPoint(rect__2);
        // logger.log("pointCenter1", pointCenter1);

        var v__c1c2 = Geometry.vector_2d(pointCenter1, pointCenter2);
        // logger.log("v__c1c2", v__c1c2);


        const norm__c1c2 = Geometry.norm_2d(v__c1c2);
        // logger.log("norm__c1c2", norm__c1c2);

        const radius_1 = Geometry.getRectRadius(rect__1);
        const radius_2 = Geometry.getRectRadius(rect__2);
        // const radius_avg = (radius_1 + radius_2) / 2.0;
        const radius_max = Math.max(radius_1, radius_2);
        // logger.log("radius_1", radius_1);
        // logger.log("radius_2", radius_2);
        // logger.log("radius_max", radius_max);

        const factor__same = 0.03;
        const isSameCenter = (norm__c1c2 / radius_max) < factor__same;
        // logger.log("isSameCenter", isSameCenter);

        if (isSameCenter) {
          infiniteCanvas.spread_push__disambiguation(icObj_1, icObj_2);
        } else {
          const point__barycenter = infiniteCanvas.getBarycenter(arr_icObj);

          arr_icObj.forEach((icObj, i) => {
            const factor__push = 1.1;
            infiniteCanvas.centered_push(point__barycenter, icObj, factor__push);
          });
        }
      }

      spread_push__disambiguation(icObj_1, icObj_2) {
        // logger.log("spread_push__disambiguation", icObj_1, icObj_2);

        const infiniteCanvas = this;

        const point__barycenter = infiniteCanvas.getBarycenter([icObj_1, icObj_2]);

        const angleInDegrees__random = math.randomInt(0, 360);

        // const rect__1    = icObj_1.getRect();
        // const rect__2    = icObj_2.getRect();
        const rect__1 = infiniteCanvas.getTrueRect_hack(icObj_1);
        const rect__2 = infiniteCanvas.getTrueRect_hack(icObj_2);

        const radius_1 = Geometry.getRectRadius(rect__1);
        const radius_2 = Geometry.getRectRadius(rect__2);
        const radius_max = Math.max(radius_1, radius_2);

        const factor__push = 1.1;
        const radius__disambiguation = radius_max * factor__push;
        const pointOnCircle1 = Geometry.pointOnCircle__angleInDegrees(point__barycenter, radius__disambiguation, angleInDegrees__random);
        const v_trans1 = {
          x: pointOnCircle1.x - point__barycenter.x,
          y: pointOnCircle1.y - point__barycenter.y,
        };
        const v_trans2 = {
          x: -v_trans1.x,
          y: -v_trans1.y,
        };

        //push on opposite directions
        icObj_1.position = {
          x: icObj_1.position.x + v_trans1.x,
          y: icObj_1.position.y + v_trans1.y,
        };
        icObj_2.position = {
          x: icObj_2.position.x + v_trans2.x,
          y: icObj_2.position.y + v_trans2.y,
        };

      }

      centered_push(pointCenter, icObj, factor) {

        const infiniteCanvas = this;

        const pointTL__src = icObj.position;
        const point_center__src = {
          x: pointTL__src.x + icObj.size.width / 2.0,
          y: pointTL__src.y + icObj.size.height / 2.0,
        };
        const point_center__dst = Geometry.pointWithHomothety(point_center__src, pointCenter, factor);
        // logger.log("point_center__dst", point_center__dst);

        const pointTL__dst = {
          x: point_center__dst.x - icObj.size.width / 2.0,
          y: point_center__dst.y - icObj.size.height / 2.0,
        };

        //set new pos
        icObj.position = pointTL__dst;
      }







      getVessel(icObj) {
        var outIcObj;

        const id__parent = icObj.compositeId;
        if (id__parent != -1) {
          const rep_free__parent = this.getRepresented(id__parent).r_free();
          if (rep_free__parent.c_type == "vessel") {
            outIcObj = rep_free__parent;
          }
        }

        return outIcObj;
      }


      getSupervessel() {
        const supervessel__represented = Object.values(this.represented).find(represented => represented.r_official().isSupervessel);
        const supervessel__rep_free = supervessel__represented.r_free();
        return supervessel__rep_free;
      }



      getActiveObject() {

      }

      operateOnActiveObject(opName) {
        return;
      }

      operateOnActiveObject__split() {

        const infiniteCanvas = this;

        //get supervessel
        const rep_free__supervessel = infiniteCanvas.getSupervessel();
        logger.log("rep_free__supervessel", rep_free__supervessel);

        //get cargo
        const arr_cargo = Object.values(rep_free__supervessel.parts);
        if (arr_cargo.length == 0) {
          //ignore            //SHU: ou alors faire surgir des paires du vide canvassien
          return;
        }
        const rep_free__cargo_1 = arr_cargo.find(e => true);

        //split
        function processSplitOutput(arr_components) {
          var outBool;

          if (arr_components.length > 0) {
            //remove original part
            rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(rep_free__cargo_1);

            //add parts: components
            arr_components.forEach((component, i) => {
              //add to infiniteCanvas
              infiniteCanvas.addIcObject(component);

              //get rep_free
              const rep_free__component = infiniteCanvas.getRepresented(component.id).r_free();

              //add to supervessel
              rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__component);
            });

            outBool = true;
          } else {
            outBool = false;
          }

          return outBool;
        }

        //if split was successful: perform replacement in supervessel
        // const arr_components = infiniteCanvas.splitObject(rep_free__cargo_1);
        // processSplitOutput(arr_components);

        infiniteCanvas.splitObject_p(rep_free__cargo_1)
          .then((arr_components) => {
            processSplitOutput(arr_components);
          });

      }

      splitObject(icObj) {
        var outArr;

        const infiniteCanvas = this;

        outArr = [];

        switch (icObj.type) {
          case "mathNode":
            {
              const mathNode = icObj.mathNode;

              const arr_components = Splitter.split_full(mathNode);

              outArr = arr_components.map((mathNode__component, i) => {
                const position = {
                  x: icObj.position.x + 50 * i,
                  y: icObj.position.y + 50 * i,
                };
                const icMathNode = infiniteCanvas.createIcMathNode(position.x, position.y, mathNode__component);
                return icMathNode;
              });

            }
            break;

          case "text":
            {
              const text = icObj.text;
              const arr_components = Splitter.split_string(text);

              outArr = arr_components.map((str__component, i) => {
                const position = {
                  x: icObj.position.x + 50 * i,
                  y: icObj.position.y + 50 * i,
                };
                const icText = infiniteCanvas.createIcText(position.x, position.y, str__component);
                return icText;
              });
            }
            break;

          case "image":
            {
              // const img = icObj.img;
              // // const fObj = icObj;
              //
              // const arr_img = infiniteCanvas.splitImage(img);
              //
              // outArr = arr_img.map((img__component, i) => {
              //   const position = {
              //     x: icObj.position.x + 50 * i,
              //     y: icObj.position.y + 50 * i,
              //   };
              //   const icImage = infiniteCanvas.createIcImage(position.x, position.y, img__component);
              //   return icImage;
              // });
            }
            break;

          case "bag":
            break;


          default:
            break;
        }

        return outArr;
      }

      splitObject_p(icObj) {
        var out_p;

        const infiniteCanvas = this;

        switch (icObj.type) {
          case "mathNode":
            {
              const mathNode = icObj.mathNode;

              const arr_components = Splitter.split_full(mathNode);

              const arr_icObj = arr_components.map((mathNode__component, i) => {
                const position = {
                  x: icObj.position.x + 50 * i,
                  y: icObj.position.y + 50 * i,
                };
                const icMathNode = infiniteCanvas.createIcMathNode(position.x, position.y, mathNode__component);
                return icMathNode;
              });

              out_p = Promise.resolve(arr_icObj);

            }
            break;

          case "text":
            // {
            //   const text = icObj.text;
            //   const arr_components = Splitter.split_string(text);
            //
            //   const arr_icObj = arr_components.map((str__component, i) => {
            //     const position = {
            //       x: icObj.position.x + 50 * i,
            //       y: icObj.position.y + 50 * i,
            //     };
            //     const icText = infiniteCanvas.createIcText(position.x, position.y, str__component);
            //     return icText;
            //   });
            //
            //   out_p = Promise.resolve(arr_icObj);
            // }

            //rainbow split
            {
              const text = icObj.text;
              const arr_components = Splitter.split_string(text);

              const length = arr_components.length;
              const arr_color = ColorUtils.rainbow__random_arr_of_length(length, 1);
              logger.log("log1", "arr_color", arr_color);

              const zip = (a, b) => a.map((k, i) => [k, b[i]]);
              const arr_zipped = zip(arr_components, arr_color);

              const arr_icObj = arr_zipped.map(([str__component, color], i) => {
                const position = {
                  x: icObj.position.x + 50 * i,
                  y: icObj.position.y + 50 * i,
                };
                const icText = infiniteCanvas.createIcText(position.x, position.y, str__component);

                icText.textColor = color;

                return icText;
              });

              out_p = Promise.resolve(arr_icObj);
            }
            break;

          case "image":
            {
              const img = icObj.img;
              // const fObj = icObj;

              // out_p = infiniteCanvas.splitImage_p(img)
              out_p = infiniteCanvas.splitImage2_p(img)
                .then((arr_img) => {

                  const arr_icObj = arr_img.map((img__component, i) => {
                    const position = {
                      x: icObj.position.x + 50 * i,
                      y: icObj.position.y + 50 * i,
                    };
                    const icImage = infiniteCanvas.createIcImage(position.x, position.y, img__component);
                    return icImage;
                  });

                  return arr_icObj;
                })
                .catch((e) => {
                  logger.log(e);
                });
            }
            break;

          // case "bag":
          //   break;
          default:
            out_p = Promise.reject(new Error("splitObject_p, unsupported icObj.type: " + icObj.type));
            break;
        }

        return out_p;
      }

      splitImage_p(img) {
        var out_p;

        // logger.log("splitImage_p, img", img);
        // logger.log("img.src", img.src);

        // img.setAttribute("crossOrigin", "Anonymous");
        // img.crossOrigin = 'Anonymous';

        function createDataURL__img_p(img) {
          var out_p;

          const isSimpleURL = img.src.startsWith("file://")
            || img.src.startsWith("http://")
            || img.src.startsWith("https://");

          if (isSimpleURL) {
            out_p = FileIntegration.dataUrlForImgViaCanvas_p(img);
          } else {
            out_p = Promise.resolve(img.src);
          }

          return out_p;
        }

        function createFObj_p(dataURL__img) {
          var out_p;

          logger.log("dataURL__img", dataURL__img);

          out_p = new Promise((resolve, reject) => {
            fabric.Image.fromURL(dataURL__img, function (fObj, isError) {
              if (isError) {
                const error = new Error("fabric.Image.fromURL, error");
                reject(error);
              }
              resolve(fObj);
            }, { crossOrigin: 'Anonymous' });
          });

          return out_p;
        }

        function splitFObj_p(fObj, width, height) {
          var out_p;

          const fObjOrfCanvas = fObj;

          const height__half = height / 2.0;

          const rect__top = {
            left: 0,
            top: 0,
            width: width,
            height: height__half,
          };
          const dataURL__top = FileIntegration.dataURLForRect(fObjOrfCanvas, rect__top);
          // logger.log("dataURL__top", dataURL__top);
          const img__top_p = FileIntegration.imageFromImgSrc_p(dataURL__top);

          const rect__bottom = {
            left: 0,
            top: height__half,
            width: width,
            height: height__half,
          };
          const dataURL__bottom = FileIntegration.dataURLForRect(fObjOrfCanvas, rect__bottom);
          // logger.log("dataURL__bottom", dataURL__bottom);
          const img__bottom_p = FileIntegration.imageFromImgSrc_p(dataURL__bottom);

          const arr_p = [img__top_p, img__bottom_p];
          out_p = Promise.all(arr_p)
            .then((arr_img) => {

              //clean canvas
              // fabricCanvas__tool.remove(fObj);
              // fabricCanvas__tool.renderAll();

              return arr_img;

              // const arr_img__custom = arr_img.map(img => {
              //   img.setAttribute("crossorigin", "anonymous");
              //   return img;
              // });
              // return arr_img__custom;
            });

          return out_p;
        }




        const width = img.width;
        const height = img.height;

        const fObj_p = createDataURL__img_p(img)
          .then((dataURL__img) => {
            return createFObj_p(dataURL__img);
          });
        // const fCanvas_p = fObj_p.then((fObj) => {
        //   //prepare canvas
        //   fabricCanvas__tool.add(fObj);
        //   fabricCanvas__tool.renderAll();
        //
        //   return fabricCanvas__tool;
        // });

        out_p = fObj_p.then((fObj) => {
          logger.log("fObj", fObj);
          return splitFObj_p(fObj, width, height);
        });

        return out_p;
      }

      splitImage2_p(img) {
        var out_p;

        // logger.log("splitImage_p, img", img);
        // logger.log("img.src", img.src);

        // img.setAttribute("crossOrigin", "Anonymous");
        // img.crossOrigin = 'Anonymous';

        function createDataURL__img_p(img) {
          var out_p;

          const isSimpleURL = img.src.startsWith("file://")
            || img.src.startsWith("http://")
            || img.src.startsWith("https://");

          if (isSimpleURL) {
            out_p = FileIntegration.dataUrlForImgViaCanvas_p(img);
          } else {
            out_p = Promise.resolve(img.src);
          }

          return out_p;
        }

        function createFObj_p(dataURL__img) {
          var out_p;

          logger.log("dataURL__img", dataURL__img);

          out_p = new Promise((resolve, reject) => {
            fabric.Image.fromURL(dataURL__img, function (fObj, isError) {
              if (isError) {
                const error = new Error("fabric.Image.fromURL, error");
                reject(error);
              }
              resolve(fObj);
            }, { crossOrigin: 'Anonymous' });
          });

          return out_p;
        }

        function dataURLForClipPath(fObjOrfCanvas, clipPath) {
          var outDataURL;

          fObjOrfCanvas.clipPath = clipPath;

          //get pixelwise bounding rect     //SHU: TODO

          // const printOptions = Object.assign({}, rect__print);
          const printOptions = {};
          outDataURL = fObjOrfCanvas.toDataURL(printOptions);

          return outDataURL;
        }

        function splitFObj_p(fObj, width, height) {
          var out_p;

          const fObjOrfCanvas = fObj;

          const pointA = Geometry.createPoint(0, 0.2 * height);
          const pointB = Geometry.createPoint(width - 1, 0.7 * height);
          const lineAB = Geometry.createLine(pointA, pointB);

          const pointTL = Geometry.createPoint(0, 0);
          const pointTR = Geometry.createPoint(width, 0);
          const pointBL = Geometry.createPoint(0, height);
          const pointBR = Geometry.createPoint(width, height);

          const polygon__top = new fabric.Polygon([
            pointTL,
            pointTR,
            pointB,
            pointA,
          ]);
          polygon__top.absolutePositioned = true;

          const dataURL__top = dataURLForClipPath(fObjOrfCanvas, polygon__top);
          // logger.log("dataURL__top", dataURL__top);
          const img__top_p = FileIntegration.imageFromImgSrc_p(dataURL__top);

          const polygon__bottom = new fabric.Polygon([
            pointA,
            pointB,
            pointBR,
            pointBL,
          ]);
          polygon__bottom.absolutePositioned = true;

          const dataURL__bottom = dataURLForClipPath(fObjOrfCanvas, polygon__bottom);
          // logger.log("dataURL__top", dataURL__top);
          const img__bottom_p = FileIntegration.imageFromImgSrc_p(dataURL__bottom);

          const arr_p = [img__top_p, img__bottom_p];
          out_p = Promise.all(arr_p)
            .then((arr_img) => {

              //clean canvas
              // fabricCanvas__tool.remove(fObj);
              // fabricCanvas__tool.renderAll();

              return arr_img;

              // const arr_img__custom = arr_img.map(img => {
              //   img.setAttribute("crossorigin", "anonymous");
              //   return img;
              // });
              // return arr_img__custom;
            });

          return out_p;
        }




        const width = img.width;
        const height = img.height;

        const fObj_p = createDataURL__img_p(img)
          .then((dataURL__img) => {
            return createFObj_p(dataURL__img);
          });
        // const fCanvas_p = fObj_p.then((fObj) => {
        //   //prepare canvas
        //   fabricCanvas__tool.add(fObj);
        //   fabricCanvas__tool.renderAll();
        //
        //   return fabricCanvas__tool;
        // });

        out_p = fObj_p.then((fObj) => {
          logger.log("fObj", fObj);
          return splitFObj_p(fObj, width, height);
        });

        return out_p;
      }


      operateOnActiveObject__export_asImg() {

        const infiniteCanvas = this;

        //get supervessel
        const rep_free__supervessel = infiniteCanvas.getSupervessel();
        logger.log("rep_free__supervessel", rep_free__supervessel);

        //get cargo
        const arr_cargo = Object.values(rep_free__supervessel.parts);
        if (arr_cargo.length == 0) {
          //ignore            //SHU: ou alors faire surgir des paires du vide canvassien
          return;
        }
        const rep_free__cargo_1 = arr_cargo.find(e => true);

        //export
        this.exportObj_asImg(rep_free__cargo_1);
      }

      exportObj_asImg(icObj) {
        logger.log("exportObj_asImg", icObj);
        const fObj = fabricIntegration.getFObjForIcObj(icObj);    //SHU: magic rabbit: "fabricIntegration"...
        logger.log("fObj", fObj);

        const rect = {
          left: 0,
          top: 0,
          width: fObj.width,
          height: fObj.height,
        };
        const dataURL = FileIntegration.dataURLForRect(fObj, rect);
        logger.log("dataURL", dataURL);

        // const img = FileIntegration.imageFromImgSrc_p(dataURL);

        FileIntegration.save_image(dataURL);
      }

      exportCanvasRectContainingObj_asImg(icObj) {
        logger.log("exportObj_asImg", icObj);
        const fObj = fabricIntegration.getFObjForIcObj(icObj);    //SHU: magic rabbit: "fabricIntegration"...
        logger.log("fObj", fObj);

        const fCanvas = fabricIntegration.fabricCanvas;

        const rect = {
          left: fObj.left,
          top: fObj.top,
          width: fObj.width,
          height: fObj.height,
        };
        const dataURL = FileIntegration.dataURLForRect(fCanvas, rect);
        logger.log("dataURL", dataURL);

        // const img = FileIntegration.imageFromImgSrc_p(dataURL);

        FileIntegration.save_image(dataURL);
      }


      operateOnActiveObject__join() {

        const infiniteCanvas = this;

        //get supervessel
        const rep_free__supervessel = infiniteCanvas.getSupervessel();
        logger.log("rep_free__supervessel", rep_free__supervessel);

        //get cargo
        const arr_cargo = Object.values(rep_free__supervessel.parts);
        if (arr_cargo.length == 0) {
          //ignore            //SHU: ou alors faire surgir des paires du vide canvassien
          return;
        }

        //join
        const icObj__joined = infiniteCanvas.joinObjects(arr_cargo);

        //if join was successful: perform replacement in supervessel
        if (icObj__joined != null) {
          //remove original parts
          arr_cargo.forEach((rep_free__cargo, i) => {
            rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(rep_free__cargo);
          });

          //add part: joined
          {
            //add to infiniteCanvas
            infiniteCanvas.addIcObject(icObj__joined);

            //get rep_free
            const rep_free__joined = infiniteCanvas.getRepresented(icObj__joined.id).r_free();

            //add to supervessel
            rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__joined);
          }


        }

      }

      joinObjects(arr_icObj) {
        var outIcObj;

        const infiniteCanvas = this;

        const typeDescription = infiniteCanvas.createTypeDescription(arr_icObj);

        if (typeDescription.type == "single") {
          const icObjType = typeDescription.arr_type.find(e => true);
          switch (icObjType) {
            case "mathNode":
              {
                const arr_mathNode = arr_icObj.map(icObj => icObj.mathNode);
                const mathNode__joined = Joiner.random_join(arr_mathNode);

                const icObj = arr_icObj.find(e => true);
                const position = {
                  x: icObj.position.x,
                  y: icObj.position.y,
                };

                const icMathNode = infiniteCanvas.createIcMathNode(position.x, position.y, mathNode__joined);
                outIcObj = icMathNode;
              }
              break;
            case "text":
              {

              }
              break;
            default:
              break;
          }
        } else {

        }

        return outIcObj;
      }

      operateOnActiveObject__coreify() {

        const infiniteCanvas = this;

        //get supervessel
        const rep_free__supervessel = infiniteCanvas.getSupervessel();
        logger.log("rep_free__supervessel", rep_free__supervessel);

        //get cargo
        const arr_cargo = Object.values(rep_free__supervessel.parts);
        if (arr_cargo.length == 0) {
          //ignore            //SHU: ou alors faire surgir des paires du vide canvassien
          return;
        }
        const rep_free__cargo_1 = arr_cargo.find(e => true);


        const specimen = rep_free__cargo_1;

        //create core
        const icCore = infiniteCanvas.createIcCore(specimen);

        //add core
        infiniteCanvas.addIcObject(icCore);



        //find alike
        // const arr_alike = this.getAlikeForIcObject(specimen);

        //set alike
        // icCore.addArrAlike(arr_alike);
      }

      getAlikeForIcObject(icObj) {
        var outArr;

        const arr_sameType = this.getAllRepresentedWithType(icObj.type).map(represented => represented.r_free());

        const identifyingContent__icObj = this.getIdentifyingContentForIcObject(icObj);
        const arr_sameIdentifyingContent = arr_sameType.filter(icObj_candidate => {
          const identifyingContent__candidate = this.getIdentifyingContentForIcObject(icObj_candidate);
          const isSameIdentifyingContent = (identifyingContent__candidate == identifyingContent__icObj);
          return isSameIdentifyingContent;
        });

        outArr = arr_sameIdentifyingContent;

        return outArr;
      }

      getIdentifyingContentForIcObject(icObj) {
        var outObj;

        switch (icObj.type) {
          case "mathNode":
            {
              const mathNode = icObj.mathNode;
              if (mathNode instanceof math.ConstantNode) {
                outObj = icObj.mathNode.value;
              } else if (mathNode instanceof math.SymbolNode) {
                outObj = icObj.mathNode.name;
              } else {
                outObj = icObj.mathNode.toString();
              }
            }
            break;
          case "text":
            {
              outObj = icObj.text;
            }
            break;
          case "image":
            {
              outObj = icObj.img.src;
            }
            break;
          default:
            {
              throw new Error("object has no known identifying content");
            }
            break;
        }

        return outObj;
      }




      scaledObject(icObj, mode, factor) {
        var outIcObj;



        return outIcObj;
      }

      unitCloneScaledObject(icObj, mode, factor) {
        var outIcObj;




        return outIcObj;
      }




      createTypeDescription(arr_icObj) {
        var outTypeDesc = {};

        const arr_type__all = arr_icObj.map(icObj => icObj.type);

        const set_type = new Set(arr_type__all);
        const arr_type__distinct = [...set_type];
        outTypeDesc.arr_type = arr_type__distinct;

        if (arr_type__distinct.length == 1) {
          outTypeDesc.type = "single";
        } else {
          outTypeDesc.type = "multi";
        }

        return outTypeDesc;
      }


      getActiveObject() {
        const infiniteCanvas = this;

        //get supervessel
        const rep_free__supervessel = infiniteCanvas.getSupervessel();
        logger.log("rep_free__supervessel", rep_free__supervessel);

        //get cargo
        const arr_cargo = Object.values(rep_free__supervessel.parts);
        if (arr_cargo.length == 0) {
          //ignore            //SHU: ou alors faire surgir des paires du vide canvassien
          return;
        }

        const icObj = arr_cargo.find(e => true);

        return icObj;
      }

      operateOnActiveObject__executeScript() {
        const infiniteCanvas = this;

        const icObj = infiniteCanvas.getActiveObject();

        const isIcText = icObj.type == "text";
        if (isIcText) {
          const icText = icObj;

          const transformationOutput = infiniteCanvas.executeScript_fromIcText(icText);
          logger.log("transformationOutput", transformationOutput);

          if (transformationOutput.type == "new") {

            const icObj__new = transformationOutput.value;
            icObj__new.fill = "yellow";

            //remove original parts
            arr_cargo.forEach((rep_free__cargo, i) => {
              rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(rep_free__cargo);
            });

            //add part: joined
            {
              //add to infiniteCanvas
              infiniteCanvas.addIcObject(icObj__new);

              //get rep_free
              const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();

              //add to supervessel
              rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new);
            }
          }

        }

      }

      executeScript_fromIcText(icText) {
        var transformationOutput;

        const text = icText.text;

        {
          //script context
          const infiniteCanvas = this;
          const trueRect = {
            x: icText.position.x,
            y: icText.position.y,
            width: icText.size.width,
            height: icText.size.height,
          };

          var scriptOutput;
          // const scriptOutput = eval(text);
          eval(text);
          logger.log("scriptOutput", scriptOutput);

          if (scriptOutput instanceof IcObject) {

            transformationOutput = new TransformationOutput("new", scriptOutput, icText);

          } else {
            transformationOutput = new TransformationOutput("old", icText, icText);
          }
        }

        return transformationOutput;
      }


      operateOnActiveObject__toggleProperty(propName) {

        const infiniteCanvas = this;

        const icObj = infiniteCanvas.getActiveObject();

        const value = icObj[propName];
        if (value != null) {
          if (typeof value == "boolean") {
            icObj[propName] = !value;
          } else {
            throw new Error("icObj[propName] is not boolean");
          }
        } else {
          throw new Error("icObj[propName] == null");
        }

      }

      // operateOnActiveObject__setBehavior(behaviorName, isOn) {
      //
      //   const infiniteCanvas = this;
      //
      //   const icObj = infiniteCanvas.getActiveObject();
      //
      //   const value = icObj[propName];
      //   if(value != null) {
      //     if(typeof value == "boolean") {
      //       icObj[behaviorName] = !value;
      //     } else {
      //       throw new Error("icObj[propName] is not boolean");
      //     }
      //   } else {
      //     throw new Error("icObj[propName] == null");
      //   }
      //
      // }


      createReplicant(icObj) {
        const icObj_clone = icObj.deepClone();
        const id__clone = infiniteCanvas.generateIcObjectId();
        icObj_clone.id = id__clone;

        return icObj_clone;
      }


      operateOnActiveObject__poopSameHomeScaleClone() {
        const infiniteCanvas = this;

        const icObj__mould = infiniteCanvas.getActiveObject();

        const icObj__clone = icObj__mould.deepClone();
        const id__clone = infiniteCanvas.generateIcObjectId();
        icObj__clone.id = id__clone;

        icObj__clone.position = Object.assign({}, icObj__mould.position);
        icObj__clone.position.x = icObj__clone.position.x * 1.10;
        icObj__clone.position.y = icObj__clone.position.y * 1.10;

        infiniteCanvas.onceOnAddRepresentedForIcObject(icObj__clone, (icObj__clone) => {
          const rep_free__clone = infiniteCanvas.getRepresented(icObj__clone.id).r_free();
          rep_free__clone.homeScale = Object.assign({}, icObj__mould.homeScale);

          logger.log("rep_free__clone.id", rep_free__clone.id);
        });

        infiniteCanvas.addIcObject(icObj__clone);
      }

      operateOnActiveObject__poopGeminiShade() {
        const infiniteCanvas = this;

        const icObj__mould = infiniteCanvas.getActiveObject();

        const icObj__geminiShade = infiniteCanvas.createIcGeminiShade(icObj__mould);

        icObj__geminiShade.position = Object.assign({}, icObj__mould.position);
        icObj__geminiShade.position.x = icObj__geminiShade.position.x * 1.10;
        icObj__geminiShade.position.y = icObj__geminiShade.position.y * 1.10;

        infiniteCanvas.addIcObject(icObj__geminiShade);
      }




      addNewLabelValue(text, value) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icLabelValue = this.createIcLabelValue(trueRect, text, value);
        this.addNewIcObject(icLabelValue);
      }


      addNewButton() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icButton = this.createIcButton(trueRect);
        this.addNewIcObject(icButton);
      }

      addNewClickWell(value) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icClickWell = this.createIcClickWell(trueRect, value);
        this.addNewIcObject(icClickWell);
      }

      addNewBornAgainGreenMouse(value) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icBornAgainGreenMouse = this.createIcBornAgainGreenMouse(trueRect, value);
        this.addNewIcObject(icBornAgainGreenMouse);
      }


      addNewGMSafetyZone() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 150;   //"information" size
        const height = 150;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMSafetyZone = this.createIcGMSafetyZone(trueRect);
        this.addNewIcObject(icGMSafetyZone);
      }

      addNewGMOperator() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMOperator = this.createIcGMOperator(trueRect);
        this.addNewIcObject(icGMOperator);
      }

      addNewGMOperator_editable(text) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMOperator = this.createIcGMOperator_editable(trueRect, text);
        this.addNewIcObject(icGMOperator);
      }


      addNewGMOperator_withType(type, cfg = {}) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMOperator = this.createIcGMOperator_withType(trueRect, type, cfg);
        this.addNewIcObject(icGMOperator);
      }


      addNewGMTargetSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMTargetSlot = this.createIcGMTargetSlot(trueRect);
        this.addNewIcObject(icGMTargetSlot);
      }

      addNewGMTargetTouchSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMTargetTouchSlot = this.createIcGMTargetTouchSlot(trueRect);
        this.addNewIcObject(icGMTargetTouchSlot);
      }


      addNewWell() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icWell = this.createIcWell(trueRect);
        this.addNewIcObject(icWell);
      }

      addNewGreenMouseWell() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGreenMouseWell = this.createIcGreenMouseWell(trueRect);
        this.addNewIcObject(icGreenMouseWell);
      }

      addNewGMChallenge(challengeIndex) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMChallenge = this.createIcGMChallenge(trueRect, challengeIndex);
        this.addNewIcObject(icGMChallenge);
      }


      addNewRxSubject(value) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icRxSubject = this.createIcRxSubject(trueRect, value);
        this.addNewIcObject(icRxSubject);
      }

      addNewRxSubscription() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icRxSubscription = this.createIcRxSubscription(trueRect);
        this.addNewIcObject(icRxSubscription);
      }





      addNewObserver() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icObserver = this.createIcObserver(trueRect);
        this.addNewIcObject(icObserver);
      }

      addNewTrigger() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icTrigger = this.createIcTrigger(trueRect);
        this.addNewIcObject(icTrigger);
      }

      addNewEventEmitter() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icEventEmitter = this.createIcEventEmitter(trueRect);
        this.addNewIcObject(icEventEmitter);
      }

      addNewEventReceiver() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icEventReceiver = this.createIcEventReceiver(trueRect);
        this.addNewIcObject(icEventReceiver);
      }

      addNewEye() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icEye = this.createIcEye(trueRect);
        this.addNewIcObject(icEye);
      }


      addNewFacet_mathNode() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icFacet_mathNode = this.createIcFacet_mathNode(trueRect);
        this.addNewIcObject(icFacet_mathNode);
      }

      addNewIcEngined_debug() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icEngined_debug = this.createIcEngined_debug(trueRect);
        this.addNewIcObject(icEngined_debug);
      }

      addNewCountdown() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icCountdown = this.createIcCountdown(trueRect);
        this.addNewIcObject(icCountdown);
      }


      addNewStore() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icStore = this.createIcStore(trueRect);
        this.addNewIcObject(icStore);
      }

      addNewCounter() {
        const infiniteCanvas = this;

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const index__counter = this.index__counter;
        const counterConfig = this.createCounterConfig(index__counter);
        this.index__counter += 1;

        const icCounter = this.createIcCounter(trueRect, counterConfig);
        this.addNewIcObject(icCounter);
      }

      createCounterConfig(index__counter) {
        var outCounterConfig;

        const mathNode = new math.ConstantNode(index__counter);
        const left = 0;
        const top = 0;
        const icMathNode = infiniteCanvas.createIcMathNode(0, 0, mathNode);

        const icObj__specimen = icMathNode;
        outCounterConfig = {
          icObj__specimen: icObj__specimen,

          canCountFunc: (icObj) => {
            var outBool;

            const isValidType = (icObj.type == icObj__specimen.type);
            if (!isValidType) {
              outBool = false;
            } else {
              const isValidValue = (icObj.mathNode.value == icObj__specimen.mathNode.value);
              outBool = isValidValue;
            }

            return outBool;
          }
        };

        return outCounterConfig;
      }


      addNewConductiveOperator_withType(type, cfg = {}) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const conductiveOperator = infiniteCanvas.createIcConductiveOperator(trueRect, type, cfg);
        infiniteCanvas.addIcObject(conductiveOperator);
      }


      spawnImageCart() {

        FileIntegration.importImage_folder_p()
          .then(arr_img => {

            const arr_values = [...Array(10).keys()].map(i => i * 0.5);
            const arr_values__shuffled = Utils.shuffle([...arr_values]);

            const dict_cart = MathUtils.randomCartDictFromArr(arr_img, 10, 3, 6);
            logger.log("log1", "dict_cart", dict_cart);
            Object.entries(dict_cart).forEach(([k, miniDict], i) => {
              logger.log("log1", "k", k);
              const img = miniDict.obj;
              const nb = miniDict.nb;

              [...Array(nb).keys()].forEach((item, i) => {
                infiniteCanvas.manageImageImport(img);
              });

              const value = arr_values__shuffled[i];
              const mathNode__value = new math.ConstantNode(value);
              infiniteCanvas.addNewMathNode(mathNode__value);
            });

            // const isShuffled = true;
            // const arr_cart  = MathUtils.randomCartArrFromArr(arr_img, 10, 3, 6, isShuffled);
            // logger.log("log1", "arr_cart", arr_cart);
            // arr_cart.forEach(img => {
            //   infiniteCanvas.manageImageImport(img);
            // });

          });





      }





      configureInitialIcObjects() {

        // this.addAxes();

      }

      addAxes() {

        const icRectX = this.createIcRect_withLTWH(0, 0, 1000, 10);
        icRectX.fill = "red";
        this.addIcObject(icRectX);

        const icRectY = this.createIcRect_withLTWH(0, 0, 10, 1000);
        icRectY.fill = "blue";
        this.addIcObject(icRectY);

      }





      setupRedrawConditions() {
        // if the window changes size, redraw the canvas
        window.addEventListener("resize", (event) => {
          this.redrawCanvas(RedrawOccasion.windowResize);
        });
      }



      redrawCanvas(redrawOccasion) {

        debug.setScale(this.scale);
        debug.setOffset(this.offset);

        // console.log("this.icObjects", this.icObjects);
        // debug.setNbObjects(Object.values(this.icObjects.any).length);

        /*
        console.log("**reps[[[[[");
        Object.values(this.representations).forEach((rep, i) => {
          console.log("**rep", rep.type, rep.id_rep);
        });
        console.log("**reps]]]]]");
        */

        const nbDisplayedRepresentations = Object.values(this.representations).length;
        debug.setNbObjects(nbDisplayedRepresentations);

        this.redrawCanvasListeners.forEach((listener, i) => {
          listener(redrawOccasion);
        });
      }




      // convert coordinates
      toScreenX(xTrue) {
        return (xTrue + this.offset.dx) * this.scale.X;
      }
      toScreenY(yTrue) {
        return (yTrue + this.offset.dy) * this.scale.Y;
      }
      toScreenPoint(truePoint) {
        return Geometry.createPoint(this.toScreenX(truePoint.x), this.toScreenY(truePoint.y));
      }
      toScreenRect(trueRect) {
        const truePointTL = Geometry.createPoint(trueRect.left, trueRect.top);
        const truePointBR = Geometry.createPoint(trueRect.left + trueRect.width, trueRect.top + trueRect.height);

        const screen_pointTL = this.toScreenPoint(truePointTL);
        const screen_pointBR = this.toScreenPoint(truePointBR);

        const screen_w = screen_pointBR.x - screen_pointTL.x;
        const screen_h = screen_pointBR.y - screen_pointTL.y;

        const screenRect = Geometry.createRect(screen_pointTL.x, screen_pointTL.y, screen_w, screen_h);

        return screenRect;
      }
      toScreenSize(trueSize) {
        const screen_w = trueSize.width / this.scale.X;
        const screen_h = trueSize.height / this.scale.Y;
        return Geometry.createSize(screen_w, screen_h);
      }
      // toScreenLength(trueLength) {
      //   return trueLength * this.scale;
      // }




      getOrientationBaseVectors() {
        return this.getRotationBaseVectors(this.orientation);
      }

      getStdBaseVectors() {
        return this.getRotationBaseVectors(-this.orientation);
      }

      getRotationBaseVectors(angle) {

        const cosTheta = Math.cos(angle * (Math.PI / 180));
        const sinTheta = Math.sin(angle * (Math.PI / 180));

        const orientation_vector_u = {
          x: cosTheta,
          y: sinTheta,
        };

        const orientation_vector_v = {
          x: -sinTheta,
          y: cosTheta,
        };

        const baseVectors = {
          u: orientation_vector_u,
          v: orientation_vector_v,
        };

        return baseVectors;

      }


      // toTrueX(xScreen) {
      //     return (xScreen / this.scale.X) - this.offset.dx;
      // }
      // toTrueY(yScreen) {
      //     return (yScreen / this.scale.Y) - this.offset.dy;
      // }
      toTrueX(screenPoint) {
        // console.log("toTrueX", "screenPoint", screenPoint);
        //
        // console.log("screenPoint.x", screenPoint.x);
        // console.log("this.scale.X", this.scale.X);
        // console.log("this.offset.dx", this.offset.dx);
        // console.log("this.offset", this.offset);


        const v = this.toNoOrPoint(screenPoint);

        const stdBaseVectors = this.getStdBaseVectors();
        // console.log("stdBaseVectors", stdBaseVectors);

        const trueX = Geometry.dotProduct_2d(v, stdBaseVectors.u);

        return trueX;
      }
      toTrueY(screenPoint) {
        const v = this.toNoOrPoint(screenPoint);

        const stdBaseVectors = this.getStdBaseVectors();

        return Geometry.dotProduct_2d(v, stdBaseVectors.v);
      }

      trueWidth() {
        // return canvas.clientWidth / scale;
        return this.canvas.width / this.scale.X;
      }
      trueHeight() {
        // return canvas.clientHeight / scale;
        return this.canvas.height / this.scale.Y;
      }

      toTruePoint(point) {
        const trueX = this.toTrueX(point);
        // console.log("trueX", trueX);

        const trueY = this.toTrueY(point);
        const truePoint = Geometry.createPoint(trueX, trueY);
        // console.log("truePoint", truePoint);
        return truePoint;
      }

      toTrueRect(rect) {
        const pointTL = Geometry.createPoint(rect.left, rect.top);
        const pointBR = Geometry.createPoint(rect.left + rect.width, rect.left + rect.height);

        const true_pointTL = this.toTruePoint(pointTL);
        const true_pointBR = this.toTruePoint(pointBR);

        const true_w = true_pointBR.x - true_pointTL.x;
        const true_h = true_pointBR.y - true_pointTL.y;

        const trueRect = Geometry.createRect(true_pointTL.x, true_pointTL.y, true_w, true_h);

        return trueRect;
      }

      getTrueCursor() {
        return this.toTruePoint(this.cursor);
      }

      truePointFromNoOrPoint(noOrPoint) {

        const stdBaseVectors = this.getStdBaseVectors();
        // console.log("stdBaseVectors", stdBaseVectors);

        const trueX = Geometry.dotProduct_2d(noOrPoint, stdBaseVectors.u);
        const trueY = Geometry.dotProduct_2d(noOrPoint, stdBaseVectors.v);

        const truePoint = Geometry.createPoint(trueX, trueY);

        return truePoint;
      }



      //noOr == no orientation == almost true point (wrong axes orientation)
      toNoOrX(screenX) {
        const noOrX = (screenX / this.scale.X) - this.offset.dx;
        return noOrX;
      }

      toNoOrY(screenY) {
        const noOrY = (screenY / this.scale.Y) - this.offset.dy;
        return noOrY;
      }

      toNoOrPoint(screenPoint) {
        return Geometry.createPoint(this.toNoOrX(screenPoint.x), this.toNoOrY(screenPoint.y));
      }

      toNoOrRect(screenRect) {
        const noOrTL = this.toNoOrPoint(Geometry.getPointTL(screenRect));
        const noOrBR = this.toNoOrPoint(Geometry.getPointBR(screenRect));
        const w = noOrBR.x - noOrTL.x;
        const h = noOrBR.y - noOrTL.y;
        return Geometry.createRect(noOrTL.x, noOrTL.y, w, h);
      }



      getCanvasBoundingRect() {
        // return canvas.getBoundingClientRect();
        return this.canvas.getBoundingClientRect();
      }

      getCanvasBoundingTrueRect() {
        const canvasBoundingRect = this.getCanvasBoundingRect();

        const trueRect = this.toTrueRect(canvasBoundingRect);

        return trueRect;
      }


      getScreenRect() {
        return this.getCanvasBoundingRect();
      }

      getScreenCenterPoint() {
        return Geometry.getCenterPoint(this.getCanvasBoundingRect());
      }

      getTrueCenterPoint() {
        const centerPoint_screen = this.getScreenCenterPoint();
        // console.log("centerPoint_screen", centerPoint_screen);
        const centerPoint_true = this.toTruePoint(centerPoint_screen);
        return centerPoint_true;
      }

      getNoOrCenterPoint() {
        const centerPoint_screen = this.getScreenCenterPoint();
        // console.log("centerPoint_screen", centerPoint_screen);
        const centerPoint_noOr = this.toNoOrPoint(centerPoint_screen);
        return centerPoint_noOr;
      }


      getShownRect() {
        const screenRect = this.getScreenRect();
        const noOrRect = this.toNoOrRect(screenRect);
        const shownRect = Geometry.createXYRect(noOrRect);
        return shownRect;
      }



      //"entry points"

      manageCursorMove_line() {

        /*
        //create line
        const line = {
            x0: prevScaledX,
            y0: prevScaledY,
            x1: scaledX,
            y1: scaledY
        };

        //console.log("line", line);

        // add the line to our drawing history
        drawings.push(line);

        // draw a line
        drawLine(prevCursorX, prevCursorY, cursorX, cursorY);
        */

      }

      manageCursorMove_offset() {

        const noOr_cursor = this.toNoOrPoint(this.cursor);
        const noOr_previousCursor = this.toNoOrPoint(this.previousCursor);

        // move the screen
        const dOffsetX = (noOr_cursor.x - noOr_previousCursor.x) * this.inputProperties.moveProperties.moveMultiplier;
        const dOffsetY = (noOr_cursor.y - noOr_previousCursor.y) * this.inputProperties.moveProperties.moveMultiplier;

        const dOffset = {
          dx: dOffsetX,
          dy: dOffsetY,
        };

        //console.log("offset", offset);
        this.updateDOffset(dOffset);
        this.redrawCanvas(RedrawOccasion.offsetChanged);
      }

      manageCursorMove_rotate() {

        // console.log("this.cursor",         this.cursor);
        // console.log("this.previousCursor", this.previousCursor);

        // const screenRect   = this.getScreenRect();
        // console.log("screenRect", screenRect);
        const screenCenterPoint = this.getScreenCenterPoint();
        // console.log("screenCenterPoint", screenCenterPoint);


        // get rotation angle
        const v1 = {
          x: this.cursor.x - screenCenterPoint.x,
          y: this.cursor.y - screenCenterPoint.y,
        };
        const v2 = {
          x: this.previousCursor.x - screenCenterPoint.x,
          y: this.previousCursor.y - screenCenterPoint.y,
        };

        const norm_v1 = Geometry.norm_2d(v1);
        const norm_v2 = Geometry.norm_2d(v2);

        //angle = arccos[(xa * xb + ya * yb) / (√(xa2 + ya2) * √(xb2 + yb2))]
        const angle_abs = Math.acos(Geometry.dotProduct_2d(v1, v2) / (norm_v1 * norm_v2));
        console.log("mcr", "angle_abs", angle_abs);

        if (isNaN(angle_abs)) {
          //ignore
          console.log("ignore", "isNaN(angle_abs) == true");
          // console.log("norm_v1", norm_v1);
          // console.log("norm_v2", norm_v2);
          return;
        }

        // * this.inputProperties.moveProperties.moveMultiplier

        //get the right sign
        const v1_3d = Geometry.vector_3d(v1);
        const v2_3d = Geometry.vector_3d(v2);
        const vn = {
          x: 0,
          y: 0,
          z: 1,
        };

        const cross = Geometry.crossProduct_3d(v1_3d, v2_3d);
        // console.log("cross", cross);
        const sign = Geometry.dotProduct_3d(vn, cross) < 0 ? +1 : -1;

        const angleInRadians = sign * angle_abs;

        const angleInDegrees = angleInRadians * 180 / Math.PI;
        console.log("mcr", "angleInDegrees", angleInDegrees);

        const rotationCenter = this.getNoOrCenterPoint();
        // console.log("rotationCenter", rotationCenter);

        this.updateWithDRotation(angleInDegrees, rotationCenter);

        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }

      manageCenterRotation(angleInDegrees) {
        const rotationCenter = this.getNoOrCenterPoint();
        // console.log("rotationCenter", rotationCenter);

        this.updateWithDRotation(angleInDegrees, rotationCenter);

        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }

      logCursor() {

        console.log("this.cursor", this.cursor);
        const true_cursor = this.toTruePoint(this.cursor);
        console.log("true_cursor", true_cursor);


        const screenCenterPoint = this.getScreenCenterPoint();
        console.log("screenCenterPoint", screenCenterPoint);

      }




      //   // zoom the page based on where the cursor is
      //   var distX = event.pageX / canvas.clientWidth;
      //   var distY = event.pageY / canvas.clientHeight;
      //
      //   // calculate how much we need to zoom
      //   const unitsZoomedX = trueWidth() * scaleAmount;
      //   const unitsZoomedY = trueHeight() * scaleAmount;
      //
      //   const unitsAddLeft = unitsZoomedX * distX;
      //   const unitsAddTop = unitsZoomedY * distY;
      //
      //   offsetX -= unitsAddLeft;
      //   offsetY -= unitsAddTop;

      manageScaleUpdateWithScaleAmount(scaleAmount) {
        logger.log("log1", "manageScaleUpdateWithScaleAmount", scaleAmount);

        const scale_new = {
          X: this.scale.X * (1 + scaleAmount),
          Y: this.scale.Y * (1 + scaleAmount),
        };
        logger.log("log1", "scale_new.X", scale_new.X);
        logger.log("log1", "scale_new.Y", scale_new.Y);



        // zoom the page based on where the cursor is
        const cursor = this.cursor;
        const screenCenterPoint = this.getScreenCenterPoint();
        const screenRect = this.getScreenRect();

        const cursorRatio = {
          X: cursor.x / screenRect.width,
          Y: cursor.y / screenRect.height,
        };
        console.log("cursorRatio", cursorRatio);

        const noOrRect = this.toNoOrRect(screenRect);

        const unitsZoomed = {
          X: noOrRect.width * scaleAmount,
          Y: noOrRect.height * scaleAmount,
        };
        console.log("unitsZoomed", unitsZoomed);


        // const unitsZoomed = {
        //   X: this.trueWidth()  * scaleAmount,
        //   Y: this.trueHeight() * scaleAmount,
        // };

        // const sign = scaleAmount > 0 ? -1 : +1;

        const dOffset = {
          dx: - unitsZoomed.X * cursorRatio.X,
          dy: - unitsZoomed.Y * cursorRatio.Y,
        };
        console.log("dOffset", dOffset);

        this.updateScaleAndDOffset(scale_new, dOffset);

        this.redrawCanvas(RedrawOccasion.scaleChanged);
      }


      // zIndex

      enterZIndexEditing() {
        this.isZIndexEditing = true;


      }

      leaveZIndexEditing() {
        this.isZIndexEditing = false;


      }

      manageZIndexEditingScrement(screment) {
        console.log("manageZIndexEditingScrement", screment);

        //get selected objects
        const arr_rep_free = Object.values(this.represented).map(represented => represented.r_free());
        const arr_rep_free_selected = arr_rep_free
          .filter(rep_free => {
            return rep_free.isSelected;
          });

        //update zIndex
        arr_rep_free_selected.forEach((rep_free, i) => {
          rep_free.zIndex += screment;
        });

        // if(icObj_active.type == "composite") {
        //
        // } else {
        //   icObj_active.zIndex += screment;
        // }

      }

      getArrZIndex() {
        const arr_represented = Object.values(this.represented);
        // const arr_rep_official = arr_represented.map(represented => represented.r_official());
        const arr_rep_free = arr_represented.map(represented => represented.r_free());

        const arr_zIndex = arr_rep_free.map(rep_free => rep_free.zIndex);
        return arr_zIndex;
      }

      getFreshZIndex() {
        var outIndex;

        const arr_zIndex = this.getArrZIndex();
        if (arr_zIndex.length == 0) {
          outIndex = 0;
        } else {
          const zIndex_max = math.max(arr_zIndex);

          outIndex = zIndex_max + 1;
        }

        return outIndex;
      }





      //events

      manageMoveEvent(moveEvent) {
        logger.log("manageMoveEvent", moveEvent);

        //get icObj
        const id__icObj = moveEvent.data.id;
        const rep_free = this.getRepresented(id__icObj).r_free();

        //"apply" event
        const position__new = moveEvent.data.position;
        rep_free.position = position__new;
      }

      manageMoveEvent_debug() {
        const id__icObj = 1;
        const moveEvent__random = this.createRandomMoveEvent(id__icObj);
        this.manageMoveEvent(moveEvent__random);
      }

      createRandomMoveEvent(id__icObj) {

        const x = Math.random() * 500;
        const y = Math.random() * 500;

        var time = performance.now();
        logger.log("time", time);

        const moveEvent = {
          type: "move",
          time: time,
          data: {
            id: id__icObj,
            position: {
              x: x,
              y: y,
            },
          },
        };

        return moveEvent;
      }


      manageReplay() {

      }

      manageReplay_debug() {

        const infiniteCanvas = this;

        const replayStream_p = eventstore__global.getReplay({
          // fromPosition: 7,
          // toPosition: 23
        });

        replayStream_p.then(readEventStream_p)
          .then(arr_event__replay => {
            // logger.log("arr_event__replay", arr_event__replay);

            const event__first = arr_event__replay[0];
            const time__first = event__first.data.time;
            const arr_replayEvent = arr_event__replay.map(event => {
              const event__clone = Object.assign({}, event);

              const time__event = event__clone.data.time
              event__clone.timeout = time__event - time__first;

              return event__clone;
            });

            arr_replayEvent.forEach((replayEvent, i) => {
              setTimeout(() => {
                infiniteCanvas.manageMoveEvent(replayEvent);
              }, replayEvent.timeout);
            });

          });

      }

      manageReplay_debug__machineGun() {

        const infiniteCanvas = this;

        const replayStream_p = eventstore__global.getReplay({
          // fromPosition: 7,
          // toPosition: 23
        });

        replayStream_p.then(readEventStream_p)
          .then(arr_event__replay => {
            // logger.log("arr_event__replay", arr_event__replay);

            const event__first = arr_event__replay[0];
            const time__first = event__first.data.time;

            const event__last = arr_event__replay[arr_event__replay.length - 1];
            const time__last = event__last.data.time;

            const duration__src = time__last - time__first;

            // const nb__iter         = 1000;
            const nb__iter = 50;

            const duration__all = 10000;
            const duration__dst = duration__all / nb__iter;

            const factor__scaletime = duration__dst / duration__src;

            [...Array(nb__iter).keys()].forEach((index__iter, i) => {

              const arr_replayEvent = arr_event__replay.map(event => {
                const event__clone = Object.assign({}, event);

                const time__event = event__clone.data.time
                event__clone.timeout = index__iter * duration__dst + (time__event - time__first) * factor__scaletime;

                return event__clone;
              });

              arr_replayEvent.forEach((replayEvent, i) => {
                setTimeout(() => {
                  infiniteCanvas.manageMoveEvent(replayEvent);
                }, replayEvent.timeout);
              });

            });


          });

      }


      //recording

      manageEnterOrLeaveRecording() {
        logger.log("manageEnterOrLeaveRecording");

        if (!this.isRecording) {
          this.manageEnterRecording();
        } else {
          this.manageLeaveRecording();
        }
      }

      manageEnterRecording() {
        this.createIcReplay_start();
        this.isRecording = true;
      }

      manageLeaveRecording() {
        this.isRecording = false;
        this.createIcReplay_end();
      }









      //save/load

      createInfinishute_p() {

        const counter = this.counter;
        const offset = this.offset;
        const scale = this.scale;
        const orientation = this.orientation;

        // const arr_icObjects_serial_p = this.icObjects.any.map(icObj => icObj.toSerial_p());
        // console.log("this.icObjects['any'].length", this.icObjects['any'].length);
        // console.log("this.icObjects.any.length",    this.icObjects.any.length);

        const arr_official_serial_p = Object.values(this.represented)
          .filter(represented => {    //don't serialize supervessel
            const isSupervessel = represented.r_official().isSupervessel;
            return !isSupervessel;
          })
          .map(represented => represented.officialSerial_p());
        const all_official_serial_p = Promise.all(arr_official_serial_p);

        // const arr_rep_serial_p = Object.values(this.representations).map(rep => rep.toSerial_p());
        // const all_rep_serial_p = Promise.all(arr_rep_serial_p);

        const infinishute_p = all_official_serial_p.then((arr_official_serial) => {
          const infinishute = {};

          infinishute.offset = offset;
          infinishute.scale = scale;
          infinishute.orientation = orientation;

          infinishute.counter = counter;

          infinishute.official = arr_official_serial.reduce((acc, official) => {
            console.log("official",)
            acc[official.id] = official;
            return acc;
          }, {});

          // infinishute.representations = arr_rep_serial.reduce((acc, rep) => {
          //   acc[rep.id_rep] = rep;
          //   return acc;
          // }, {});

          return infinishute;
        });

        return infinishute_p;
      }

      manageSaveInfinishute_p() {

        const infiniteCanvas = this;
        const infinishute_p = this.createInfinishute_p();

        return infinishute_p

          //debug
          .then(infinishute => {
            console.log("infinishute", infinishute);
            return infinishute;
          })

          .then(infinishute => {
            return FileIntegration.saveInfinishute_p(infinishute);
          })
          .then(success => {
            console.log("saveInfinishute_p", "success", success);
            infiniteCanvas.setChanged(!success);
          });
      }

      manageSaveInfinishute_p_2(infinishute_p) {

        return infinishute_p
          .then(infinishute => {
            return FileIntegration.saveInfinishute_p(infinishute);
          })
          .then(success => {
            console.log("saveInfinishute_p", "success", success);
            infiniteCanvas.setChanged(!success);
          });

      }


      manageLoadInfinishute(json) {
        console.log("manageLoadInfinishute", json);

        this.offset = json.offset;
        this.scale = json.scale;
        this.orientation = json.orientation;

        // this.counter = json.counter;
        this.counter = Math.max(this.counter, json.counter);

        const infiniteCanvas = this;

        const arr_official = Object.values(json.official);

        const arr_icObj_p = arr_official.map((json_icObject, i) => {
          const icObj_p = IcObject.fromJson_p(json_icObject);
          return icObj_p;
        });

        Promise.all(arr_icObj_p)
          .then(arr_icObj => {
            console.log("manageLoadInfinishute", "arr_icObj", arr_icObj);

            arr_icObj.forEach((icObj, i) => {
              logger.log("log1", "manageLoadInfinishute", "icObj", icObj);

              infiniteCanvas.addDehydratedIcObject(icObj);
              // infiniteCanvas.addRepresented(icObj);
            });

            // //sort by zIndex
            // const arr__sorted = [...arr_icObj].sort((icObj1, icObj2) => {
            //   return icObj1.zIndex > icObj2.zIndex;
            // });
            //
            // const zip = (a, b) => a.map((k, i) => [k, b[i]]);
            // const arr_zIndex = [...arr__sorted.keys()].map((index) => {
            //   return index + 100;                                           //because supervessel has zIndex == 0
            // });
            //
            // const arr__rezindexed = zip(arr__sorted, arr_zIndex).map(([icObj, zIndex__new]) => {
            //   icObj.zIndex = zIndex__new;
            //   return icObj;
            // });
            //
            // arr__rezindexed.forEach((icObj, i) => {
            //   logger.log("log1", "manageLoadInfinishute", "icObj", icObj);
            //
            //   infiniteCanvas.addDehydratedIcObject(icObj);
            //   // infiniteCanvas.addRepresented(icObj);

          });

      }


      //core mutators

      updateCursor(cursor) {
        // console.log("updateCursor", cursor);
        this.previousCursor = Object.assign({}, this.cursor);
        this.cursor = Object.assign({}, cursor);
      }


      updateOffset(offset_new) {
        console.log("updateOffset", offset_new);

        this.previousOffset = Object.assign({}, this.offset);

        this.offset = Object.assign({}, offset_new);

        this.dOffset.dx = this.offset.dx - this.previousOffset.dx;
        this.dOffset.dy = this.offset.dy - this.previousOffset.dy;

        // this.redrawCanvas(RedrawOccasion.offsetChanged);
      }

      updateScale(scale_new) {
        this.scale = Object.assign({}, scale_new);
        // this.update("scale", Object.assign({}, scale_new));

        this.didUpdateListenersDict["scaleChanged"].forEach((listener, i) => {
          listener(this);
        });
      }


      updateDOffset(dOffset_new) {
        const offset_new = {
          dx: this.offset.dx + dOffset_new.dx,
          dy: this.offset.dy + dOffset_new.dy,
        };
        this.updateOffset(offset_new);
      }

      updateScaleAndDOffset(scale_new, dOffset) {
        //console.log("updateScaleAndDOffset", scale_new, dOffset);
        this.updateScale(scale_new);
        this.updateDOffset(dOffset);
      }

      updateScaleAndOffset(scale_new, offset) {
        console.log("updateScaleAndOffset", scale_new, offset);
        this.updateScale(scale_new);
        this.updateOffset(offset);
      }

      updateOrientation(orientation_new) {
        console.log("updateOrientation", orientation_new);
        var orientation_bounded = Geometry.boundedAngleInDegrees(orientation_new);
        console.log("orientation_bounded", orientation_bounded);
        this.orientation = orientation_bounded;
      }

      updateWithDRotation(angleInDegrees, noOrCenterPoint) {
        console.log("updateWithDRotation", angleInDegrees, noOrCenterPoint);

        console.log("angleInDegrees", angleInDegrees);

        const radius = Geometry.norm_2d(noOrCenterPoint);

        // this.addPurePoint(centerPoint);
        // this.addPureCircle(centerPoint, radius);

        // this.addPoint(noOrCenterPoint);
        // this.addCircle(noOrCenterPoint, radius);

        const orientation_new = this.orientation - angleInDegrees;
        this.updateOrientation(orientation_new);


        const v = {
          x: noOrCenterPoint.x,
          y: noOrCenterPoint.y,
        };
        // console.log("v.x", v.x);
        // console.log("v.y", v.y);

        const angleInRadians = angleInDegrees / 180 * Math.PI;

        const ddx = Math.cos(angleInRadians) * v.x - Math.sin(angleInRadians) * v.y;
        const ddy = Math.sin(angleInRadians) * v.x + Math.cos(angleInRadians) * v.y;
        // console.log("ddx", ddx);
        // console.log("ddy", ddy);

        const dx = v.x - ddx
        const dy = v.y - ddy;
        // console.log("dx", dx);
        // console.log("dy", dy);


        const doffset_new = {
          dx: dx,
          dy: dy,
        };
        // console.log("doffset_new", doffset_new);

        this.updateDOffset(doffset_new);


      }


      updateWithDOrientation(dOrientation) {
        const orientation_new = this.orientation + dOrientation;
        this.updateOrientation(orientation_new);

        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }


      move_to_initial_position() {
        console.log("move_to_initial_position");
        this.updateScaleAndOffset(this.coords_initial.scale, this.coords_initial.offset);
      }

      move_to_position(position) {
        console.log("move_to_position", position);

        const offset = {
          dx: -position.x,        //SHU: this is a bit ???
          dy: -position.y,
        };
        this.updateScaleAndOffset(this.scale, offset);
        this.redrawCanvas(RedrawOccasion.offsetChanged);
      }



      /* POVs */

      getCurrentPov() {
        return new POV(this.scale, this.offset);
      }

      set_pov(pov) {
        this.updateScaleAndOffset(pov.scale, pov.offset);
        // this.redrawCanvas(RedrawOccasion.povChanged);
        this.redrawCanvas(RedrawOccasion.scaleChanged);
      }

      move_to_pov__animation(pov_to, cfg_anim__easy) {
        const infiniteCanvas = this;

        const pov_from = Object.assign({}, this.getCurrentPov());

        const cfg_anim = Object.assign({
          // targets: countDownEngine,
          targets: [],

          /*animated props*/
          progress: 1,
          /*--------------*/

          direction: 'normal',
          easing: 'linear',
          duration: cfg_anim__easy.duration,

          autoplay: false,

          update: (anim) => {
            const progress = anim.progress / 100;
            const pov__progress = infiniteCanvas.getPovForProgress(pov_from, pov_to, progress);
            logger.log("pov__progress", pov__progress);
            infiniteCanvas.set_pov(pov__progress);
          },
        }, cfg_anim__easy);

        const animation = anime(cfg_anim);
        animation.play();

      }

      getPovForProgress(pov_from, pov_to, progress) {
        const arr_propPaths = [
          "scale.X",
          "scale.Y",
          "offset.dx",
          "offset.dy",
        ];
        function getPropForPropPath(obj, propPath) {
          const arr_path = propPath.split(".");
          return arr_path.reduce((acc, pathElt) => {
            return acc[pathElt];
          }, obj);
        }
        function setPropAtPropPath(obj, propPath, value) {
          const arr_path = propPath.split(".");
          const arr__all_but_last = arr_path.slice(0, -1);
          const penultimate = arr__all_but_last.reduce((acc, pathElt) => {

            //create if not found
            if (acc[pathElt] == null) {
              acc[pathElt] = {};
            }

            return acc[pathElt];
          }, obj);

          const [lastPathElt] = arr_path.slice(-1);
          penultimate[lastPathElt] = value;
        }
        const pov_progress = arr_propPaths.reduce((acc, propPath) => {
          const prop_from = getPropForPropPath(pov_from, propPath);
          const prop_to = getPropForPropPath(pov_to, propPath);

          //linear progress
          const prop_progress = prop_from + (prop_to - prop_from) * progress;

          setPropAtPropPath(acc, propPath, prop_progress);

          return acc;
        }, {});

        return pov_progress;
      }



      show_rect(rect) {
        //get pov to show and contain rect
        const pov = this.centeredPovForRect(rect);

        this.set_pov(pov);
      }

      move_to_rect__animation(rect__dst, cfg_anim__easy) {
        logger.log("move_to_rect__animation", rect__dst, cfg_anim__easy);

        const pov__dst = infiniteCanvas.centeredPovForRect(rect__dst);
        infiniteCanvas.move_to_pov__animation(pov__dst, cfg_anim__easy);
      }

      povForRect(rect_target) {
        throw new Error("lol");
      }

      centeredPovForRect(rect__dst) {
        // logger.log("centeredPovForRect", rect__dst);
        const infiniteCanvas = this;

        const rect__src = infiniteCanvas.getShownRect();
        // logger.log("shownRect", rect__src);
        // logger.log("rect__dst", rect__dst);

        const pointCenter__src = Geometry.getCenterPoint(Geometry.createLTRect(rect__src));
        // logger.log("pointCenter__src", pointCenter__src);

        const pointCenter__dst = Geometry.getCenterPoint(Geometry.createLTRect(rect__dst));
        // logger.log("pointCenter__dst", pointCenter__dst);

        // const length_max__src = Math.max(rect__src.width, rect__src.height);
        // const length_max__dst = Math.max(rect__dst.width, rect__dst.height);
        // const scaleFactor_to_contain_dstRect = 1.0 / (length_max__dst / length_max__src);  //scale works in reverse in iC...

        const length_min__src = Math.min(rect__src.width, rect__src.height);
        const length_min__dst = Math.min(rect__dst.width, rect__dst.height);
        // logger.log("length_min__src", length_min__src);
        // logger.log("length_min__dst", length_min__dst);

        const scaleFactor_to_contain_dstRect = 1.0 / (length_min__dst / length_min__src);  //scale works in reverse in iC...
        // logger.log("scaleFactor_to_contain_dstRect", scaleFactor_to_contain_dstRect);

        const scale__dst = {
          X: infiniteCanvas.scale.X * scaleFactor_to_contain_dstRect,
          Y: infiniteCanvas.scale.Y * scaleFactor_to_contain_dstRect,
        };
        logger.log("scale__dst", scale__dst);


        // const offset__topleftd__dst = {
        //   dx: -rect__dst.x,
        //   dy: -rect__dst.y,
        // };
        // const pov = new POV(scale__dst, offset__topleftd__dst);

        const offset__centered__dst = {
          dx: -(rect__dst.x - rect__dst.width / 2.0),
          dy: -(rect__dst.y /*- rect__dst.height/2.0*/),
        };
        const pov = new POV(scale__dst, offset__centered__dst);

        return pov;
      }










      manageImageImport(img) {
        this.addNewImage(img);
      }

      manageVideoImport(video) {
        this.addNewVideo(video);
      }


      manageTextImport(text) {
        this.addNewText(text);
      }





      //top down request
      requestViewUpdateForIcObj(icObj) {
        console.log("requestViewUpdateForIcObj", icObj);
        this.requestSyncWithIcObjListeners.forEach((listener, i) => {
          listener(icObj);
        });
      }



      //ALL

      vitrify() {
        Object.values(this.represented)
          .forEach((represented, i) => {
            const r_free = represented.r_free();
            r_free.lock();
          });

      }

      vivify() {
        Object.values(this.represented)
          .forEach((represented, i) => {
            const r_free = represented.r_free();
            r_free.unlock();
          });

      }


    }

    class IcObject {

      constructor(id, type, position, size, homeScale) {
        this.id = id;
        this.type = type;

        this.position = position;
        this.size = size;       //"information" size    //gives an idea of the sharpness/heavyness of the object

        this.homeScale = homeScale;

        this.orientation = 0;
        this.scale = {
          X: 1,
          Y: 1,
        };
        this.flip = {
          X: false,
          Y: false,
        };

        this.zIndex = 0;


        this.fill = "";
        this.stroke = "";
        // this.colors = {};
        this.opacity = 1.0;

        this.strokeWidth = 3;

        this.backgroundColor = "";

        // this.hotState = {
        //   toBeDeleted: false,
        //
        //   perceptionScale: {
        //     X:1,
        //    Y:1,
        //   },
        // };

        this.canBeMoved = true;
        this.canBeRotated = true;
        this.canBeResized = true;
        this.canBeSelected = true;

        this.canBeHeld = true;

        // this.isSnapped     = false;
        this.isSnappable = true;
        this.snapState = SnapState.Unsnapped;
        this.snappedTo = -1;

        // this.isTouchable    = true;
        this.isTouchable = false;
        // this.touchState    = TouchState.Untouched;
        this.touchStateDict = {};


        this.cType = "";
        this.isCompositePart = false;
        this.isMobile = false;
        this.compositeId = -1;

        this.isHeld = false;
        // this.addInteraction_hold();

        this.isUsingCenterPosition = false;

        this.isSelected = false;

        // this.exoObject     = null;

        this.didUpdateListeners = [];



        //ugliness from outer space
        this.counter__path = 0;
      }

      static fromJson_p(json_icObject) {
        logger.log("log2", "fromJson_p", json_icObject);

        const id = json_icObject.id;
        const type = json_icObject.type;

        const position = json_icObject.position;
        const size = json_icObject.size;

        const homeScale = json_icObject.homeScale;


        const icObj = new IcObject(id, type, position, size, homeScale);


        const scale = json_icObject.scale;
        icObj.scale = scale;

        const orientation = json_icObject.orientation;
        icObj.orientation = orientation;

        const flip = json_icObject.flip;
        icObj.flip = flip;

        const zIndex = json_icObject.zIndex;
        icObj.zIndex = zIndex;


        const fill = json_icObject.fill;
        icObj.fill = fill;
        const stroke = json_icObject.stroke;
        icObj.stroke = stroke;

        const backgroundColor = json_icObject.backgroundColor;
        icObj.backgroundColor = backgroundColor;

        const opacity = json_icObject.opacity;
        icObj.opacity = opacity;


        const isSnappable = json_icObject.isSnappable;
        icObj.isSnappable = isSnappable;
        const snapState = json_icObject.snapState;
        icObj.snapState = snapState;
        const snappedTo = json_icObject.snappedTo;
        icObj.snappedTo = snappedTo;


        const isTouchable = json_icObject.isTouchable;
        icObj.isTouchable = isTouchable;
        // const touchState = json_icObject.touchState;
        // icObj.touchState = touchState;
        const touchStateDict = json_icObject.touchStateDict;
        icObj.touchStateDict = touchStateDict;

        const isLocked = json_icObject.isLocked;
        icObj.isLocked = isLocked;

        const cType = json_icObject.cType;
        icObj.cType = cType;
        const isCompositePart = json_icObject.isCompositePart;
        icObj.isCompositePart = isCompositePart;
        const isMobile = json_icObject.isMobile;
        icObj.isMobile = isMobile;
        const compositeId = json_icObject.compositeId;
        icObj.compositeId = compositeId;

        // if(json_icObject.engine_serial != null) {
        //   const eType           = json_icObject.eType;
        //   icObj.eType           = eType;
        //   const engine_serial   = json_icObject.engine_serial;

        //   // const engine          = deserialize(engine_serial);
        //   // console.log("rehydrated engine", engine);
        //   // // engine.initialize()
        //   // icObj.engine          = engine;

        //   const virgin          = deserialize(engine_serial);

        //   icObj.engine            = {};
        //   icObj.engine.initialize = virgin.initialize.bind(icObj.engine);
        //   icObj.engine.virgin     = virgin;

        //   console.log("rehydrated engine", icObj.engine);


        //   const getScopeObj = deserialize(json_icObject.getScopeObj);
        //   icObj.getScopeObj = getScopeObj;
        // }
        //SHU: TODO: icObj.dict_engine deserialization

        const isUsingCenterPosition = json_icObject.isUsingCenterPosition;
        icObj.isUsingCenterPosition = snappedTo;


        var icObj_p = Promise.resolve(icObj);

        switch (icObj.type) {
          case "text":
          case "tag":
            const text = json_icObject.text;
            icObj.text = text;
            const textColor = json_icObject.textColor;
            icObj.textColor = textColor;
            const fontSize = json_icObject.fontSize;
            icObj.fontSize = fontSize;

            break;
          case "image":
            const img_serial = json_icObject.img;
            const img_p = FileIntegration.imageFromImgSrc_p(img_serial);

            const arr_p = [icObj_p, img_p];

            icObj_p = Promise.all(arr_p)
              .then(([icObj, img]) => {

                icObj.img = img;

                return icObj;
              });
            break;
          case "circle":
            const radius = json_icObject.radius;

            icObj.radius = radius;
            break;
          case "spotSegment":
            const point_start = json_icObject.point_start;
            const point_end   = json_icObject.point_end;

            icObj.point_start = point_start;
            icObj.point_end = point_end;

            break;

          case "group":
            {
              const children = json_icObject.children;

              const arr_p = children.map(json_child => {
                const icObj = IcObject.fromJson_p(json_child);
                return icObj;
              });

              icObj_p = Promise.all(arr_p)
                .then((arr_icObj) => {
                  icObj.children = arr_icObj;

                  return icObj;
                });
            }
            break;

          case "freeDrawing":
            const exoObject = json_icObject.exoObject;
            icObj.exoObject = exoObject;
            break;

          case "sparkle":
            {
              const img_serial = json_icObject.img;
              const img_p = FileIntegration.imageFromImgSrc_p(img_serial);

              const arr_p = [icObj_p, img_p];

              icObj_p = Promise.all(arr_p)
                .then(([icObj, img]) => {

                  icObj.img = img;

                  return icObj;
                });
            }
            break;

          case "touchSlot":
            {
              const touchSlotConfig_serial = json_icObject.touchSlotConfig_serial;
              const touchSlotConfig = deserialize(touchSlotConfig_serial);

              icObj_p = icObj_p
                .then(icObj => {

                  icObj.touchSlotConfig = touchSlotConfig;

                  return icObj;
                })

            }
            break;

          case "snapSlot":
            {
              const snapSlotConfig_serial = json_icObject.snapSlotConfig_serial;
              const snapSlotConfig = deserialize(snapSlotConfig_serial);

              icObj_p = icObj_p
                .then(icObj => {

                  icObj.snapSlotConfig = snapSlotConfig;

                  return icObj;
                })

            }
            break;

          case "composite":
            {
              const parts = json_icObject.parts;

              // const arr_p = parts.map(json_part => {
              //   const icObj = IcObject.fromJson_p(json_part);
              //   return icObj;
              // });
              // icObj_p = Promise.all(arr_p)
              // .then((arr_icObj) => {
              //   icObj.parts = arr_icObj;
              //
              //   // if(icObj.engine == null) {
              //   //   icObj.engine = Compositer.defaultCompositeEngine(icObj, icObj.parts);
              //   // }
              //
              //   return icObj;
              // });

              const arr_part_serial_miniDict_p = Object.entries(parts).reduce((acc, [partName, json_part]) => {
                const part_miniDict_p = IcObject.fromJson_p(json_part)
                  .then(icObj => {

                    const part_miniDict = {
                      [partName]: icObj,
                    };

                    return part_miniDict;
                  });

                acc.push(part_miniDict_p);
                return acc;
              }, []);

              icObj_p = Promise.all(arr_part_serial_miniDict_p)
                .then((arr_part_miniDict) => {
                  icObj.parts = {};
                  Object.assign(icObj.parts, ...arr_part_miniDict);

                  return icObj;
                });


              const compositeConfig_serial = json_icObject.compositeConfig_serial;
              const compositeConfig = deserialize(compositeConfig_serial);

              icObj_p = icObj_p
                .then(icObj => {
                  icObj.compositeConfig = compositeConfig;
                  return icObj;
                });
            }
            break;

          case "mathNode":
            const mathNode = math.parse(json_icObject.mathNodeString);
            icObj.mathNode = mathNode;
            break;


          // case "engined":
          //
          //   break;

          default:
            break;
        }


        return icObj_p;
      }

      setCenter(pointCenter) {
        if(this.isUsingCenterPosition) {
          this.position = Object.assign({}, pointCenter);
        } else {
          this.position = {
            x: pointCenter.x - this.size.width  /2,
            y: pointCenter.x - this.size.height /2,
          };
        }
      }

      toSerial_p() {
        var out_p;

        const icObj = this;

        const icObj_serial = Object.assign({}, icObj);

        // if(icObj.engine != null) {
        //   const engine = icObj.engine;

        //   //don't serialize engine directly
        //   delete icObj_serial.engine;

        //   //serialize the virgin version of engine (== a version which is context-free and not bound)
        //   const virgin = engine.virgin;

        //   const engine_cloned = Object.assign({}, virgin);
        //   console.log("engine_cloned", engine_cloned);

        //   const engine_serial = serialize(engine_cloned);
        //   icObj_serial.engine_serial = engine_serial;

        //   icObj_serial.getScopeObj = serialize(icObj.getScopeObj);  //SHU: maybe this function is a bit useless
        // }
        //SHU: TODO: icObj.dict_engine serialization

        var icObj_serial_p = Promise.resolve(icObj_serial);

        switch (icObj.type) {
          // case "text":
          //   const text     = icObj.text;
          //   const fontSize = icObj.fontSize;
          //
          //   icObj_serial.text     = text;
          //   icObj_serial.fontSize = fontSize;
          //
          //   break;
          case "image":
            {
              const img = icObj.img;
              const img_serial_p = FileIntegration.dataUrlForImgViaCanvas_p(img);

              const arr_p = [icObj_serial_p, img_serial_p];

              icObj_serial_p = Promise.all(arr_p)
                .then(([icObj_serial, img_serial]) => {

                  icObj_serial.img = img_serial;
                  return icObj_serial;
                });
            }
            break;

          // case "circle":
          //   const radius     = icObj.radius;
          //   icObj_serial.radius = radius;
          //
          //   break;

          // case "group":
          //   const children = icObj.children;
          //   icObj_serial.children = children;
          //
          //   break;

          case "freeDrawing":
            {
              const exoObject = icObj.exoObject;
              logger.log("exoObject", exoObject);

              const exoObject__clone = Object.assign({}, exoObject);
              logger.log("exoObject__clone", exoObject__clone);
              //remove cyclical refs
              exoObject__clone.canvas = null;
              exoObject__clone._cacheCanvas = null;
              exoObject__clone._cacheContext = null;
              exoObject__clone._cacheProperties = null;

              const exoObject_serial = exoObject__clone;
              // const exoObject_serial = JSON.stringify(exoObject__clone);

              icObj_serial.exoObject = exoObject_serial;
            }
            break;

          case "sparkle":
            {
              const img = icObj.img;
              const img_serial_p = FileIntegration.dataUrlForImgViaCanvas_p(img);

              const arr_p = [icObj_serial_p, img_serial_p];

              icObj_serial_p = Promise.all(arr_p)
                .then(([icObj_serial, img_serial]) => {

                  icObj_serial.img = img_serial;
                  return icObj_serial;
                });
            }
            break;

          case "touchSlot":
            {
              const touchSlotConfig = icObj.touchSlotConfig;
              const touchSlotConfig_serial = serialize(touchSlotConfig);

              icObj_serial_p = icObj_serial_p
                .then((icObj_serial) => {

                  icObj_serial.touchSlotConfig_serial = touchSlotConfig_serial;
                  return icObj_serial;
                });
            }
            break;

          case "snapSlot":
            {
              const snapSlotConfig = icObj.snapSlotConfig;
              const snapSlotConfig_serial = serialize(snapSlotConfig);

              icObj_serial_p = icObj_serial_p
                .then((icObj_serial) => {

                  icObj_serial.snapSlotConfig_serial = snapSlotConfig_serial;
                  return icObj_serial;
                });
            }
            break;



          case "composite":
            {
              const parts = icObj.parts;
              const arr_part_serial_miniDict_p = Object.entries(icObj.parts).reduce((acc, [partName, part]) => {
                const part_serial_miniDict_p = part.toSerial_p()
                  .then(part_serial => {

                    const part_serial_miniDict = {
                      [partName]: part_serial,
                    };

                    return part_serial_miniDict;
                  });

                acc.push(part_serial_miniDict_p);
                return acc;
              }, []);

              icObj_serial_p = Promise.all([icObj_serial_p, ...arr_part_serial_miniDict_p])
                .then(([icObj_serial, ...arr_part_serial_miniDict]) => {    //SHU: wow, pas mal le spread operator
                  // icObj_serial.parts = arr_part_serial_miniDict.reduce((acc, x) => {
                  //   Object.assign(acc, x);
                  //   return acc;
                  // }, {});
                  icObj_serial.parts = {};
                  Object.assign(icObj_serial.parts, ...arr_part_serial_miniDict);
                  return icObj_serial;
                });

              const compositeConfig = icObj.compositeConfig;
              const compositeConfig_serial = serialize(compositeConfig);

              icObj_serial_p = icObj_serial_p
                .then((icObj_serial) => {

                  icObj_serial.compositeConfig_serial = compositeConfig_serial;
                  return icObj_serial;
                });
            }
            break;

          case "mathNode":
            {
              const mathNode = icObj.mathNode;
              const mathNodeString = mathNode.toString();
              const mathNode_serial_p = Promise.resolve(mathNodeString);

              const arr_p = [icObj_serial_p, mathNode_serial_p];

              icObj_serial_p = Promise.all(arr_p)
                .then(([icObj_serial, mathNode_serial]) => {

                  icObj_serial.mathNodeString = mathNode_serial;
                  return icObj_serial;
                });
            }
            break;

          default:
            break;
        }

        out_p = icObj_serial_p;

        return out_p;
      }


      addInteraction_hold() {
        console.log("IcObject::addInteraction_hold", "this.id", this.id, this.id_rep);
        const icObj = this;

        icObj.holdListeners = [];
        icObj.nowHeld = () => {
          icObj.isHeld = true;
          icObj.holdListeners.forEach((listener, i) => {
            listener(icObj);
          });
        }
        icObj.onHold = (listener) => {
          icObj.holdListeners.push(listener);
        };
        icObj.offHold = (listener) => {
          icObj.holdListeners = Utils.arrayByRemovingElement(icObj.holdListeners, listener);
        };

        icObj.releaseListeners = [];
        icObj.nowReleased = () => {
          icObj.isHeld = false;
          icObj.releaseListeners.forEach((listener, i) => {
            listener(icObj);
          });
        }
        icObj.onRelease = (listener) => {
          icObj.releaseListeners.push(listener);
        };
        icObj.offRelease = (listener) => {
          icObj.releaseListeners = Utils.arrayByRemovingElement(icObj.releaseListeners, listener);
        };

      }

      addInteraction_edit() {
        const icObj = this;

        icObj.editEnterListeners = [];
        icObj.nowEditEnter = () => {
          icObj.isEditing   = true;
          globalsSingleton.isEditing = true;
          icObj.editEnterListeners.forEach((listener, i) => {
            listener(icObj);
          });
        }
        icObj.onEditEnter = (listener) => {
          icObj.editEnterListeners.push(listener);
        };
        icObj.offEditEnter = (listener) => {
          icObj.editEnterListeners = Utils.arrayByRemovingElement(icObj.editEnterListeners, listener);
        };

        icObj.editExitListeners = [];
        icObj.nowEditExit = () => {
          icObj.isEditing   = false;
          globalsSingleton.isEditing = false;
          icObj.editExitListeners.forEach((listener, i) => {
            listener(icObj);
          });
        }
        icObj.onEditExit = (listener) => {
          icObj.editExitListeners.push(listener);
        };
        icObj.offEditExit = (listener) => {
          icObj.editExitListeners = Utils.arrayByRemovingElement(icObj.editExitListeners, listener);
        };

      }

      addInteraction_click() {
        console.log("IcObject::addInteraction_click", "this.id", this.id, this.id_rep);
        const icObj = this;

        icObj.clickListeners = [];
        icObj.nowClicked = () => {
          icObj.clickListeners.forEach((listener, i) => {
            listener(icObj);
          });
        };
        icObj.onClick = (listener) => {
          icObj.clickListeners.push(listener);
        };

      }

      lock() {
        this.canBeMoved = false;
        this.canBeSelected = false;
        this.canBeResized = false;
        this.canBeRotated = false;
        this.canBeHeld = false;

        this.isLocked = true;
      }

      unlock() {
        this.canBeMoved = true;
        this.canBeSelected = true;
        this.canBeResized = true;
        this.canBeRotated = true;
        this.canBeHeld = true;

        this.isLocked = false;
      }




      getScreenPositionWithoutOffset() {
        const screenX = this.position.x * this.homeScale.X;
        const screenY = this.position.y * this.homeScale.Y;
        return Geometry.createPoint(screenX, screenY);
      }

      getScreenPointBRWithoutOffset() {       //SHU TODO: take orientation into account
        const screenX = (this.position.x + this.size.width) * this.homeScale.X;
        const screenY = (this.position.y + this.size.height) * this.homeScale.Y;
        return Geometry.createPoint(screenX, screenY);
      }

      getScreenRect() {
        const screenPointTL = this.getScreenPositionWithoutOffset();
        const screenPointBR = this.getScreenPointBRWithoutOffset();

        const left = screenPointTL.x;
        const top = screenPointTL.y;
        const width = screenPointBR.x - screenPointTL.x;
        const height = screenPointBR.y - screenPointTL.y;
        return Geometry.createRect(left, top, width, height);
      }



      getHomeScreenSize() {
        return this.size;
      }

      // getTrueSize() {
      //   // const homeScreenSize = this.getHomeScreenSize();
      //   const trueSize = {
      //     width:    this.size.width / this.homeScale.X * this.scale.X,
      //     height:   this.size.width / this.homeScale.Y * this.scale.Y,
      //   }
      //   return trueSize;
      // }

      getRect() {
        const rect = Geometry.createRect(this.position.x, this.position.y, this.size.width, this.size.height);
        return rect;
      }

      getRect2() {
        const trueSize = this.getTrueSize();
        const rect2 = Geometry.createRect(this.position.x, this.position.y, trueSize.width, trueSize.height);
        return rect2;
      }



      update(icObj_new, requestCanvasRedraw) {
        logger.log("icObj.update", "icObj_new", icObj_new);

        const icObj = this;

        if (icObj_new.type != icObj.type) {
          // console.log("invalid type for icObj_new", "icObj", icObj, "icObj_new", icObj_new);
          throw new Error("invalid type for icObj_new" + "icObj" + icObj + "icObj_new" + icObj_new);
        }

        this.position = Object.assign({}, icObj_new.position);
        this.size = Object.assign({}, icObj_new.size);

        this.homeScale = Object.assign({}, icObj_new.homeScale);

        this.scale = Object.assign({}, icObj_new.scale);
        this.orientation = icObj_new.orientation;
        this.flip = Object.assign({}, icObj_new.flip);

        // this.fill        = icObj_new.fill;
        // this.stroke      = icObj_new.stroke;


        // this.perceptionScale = Object.assign({}, icObj_new.perceptionScale);

        if (this.type == "text") {
          this.text = icObj_new.text;
          this.fontSize = icObj_new.fontSize;
        }

        if (this.type == "toggleRect") {
          this.isActive = icObj_new.isActive;
        }

        this.didUpdate(requestCanvasRedraw);
      }


      didUpdate(requestCanvasRedraw) {
        const icObj = this;
        this.didUpdateListeners.forEach((listener, i) => {      //SHU: todo: "everything is promised"
          listener(icObj, requestCanvasRedraw);
        });
      }

      delete_p() {
        return new Promise((resolve, reject) => {

          this.toBeDeleted = true;

          this.didUpdate(false);

          resolve(this);
        });
      }

      clone() {
        const id = this.id;
        const type = this.type;

        const position = this.position;
        const size = this.size;

        const homeScale = this.homeScale;

        const icObj_clone = new IcObject(id, type, position, size, homeScale);

        Object.assign(icObj_clone, this);
        console.log("icObj_clone", icObj_clone);

        return icObj_clone;
      }

      deepClone() { //SHU TODO: pour l'instant j'ai la flemme, mais il faudra des deep copy
        const id = this.id;
        const type = this.type;

        const position = {
          x: this.position.x,
          y: this.position.y,
        };
        const size = {
          width: this.size.width,
          height: this.size.height,
        };

        const homeScale = {
          X: this.homeScale.X,
          Y: this.homeScale.Y,
        };

        const icObj__deepClone = new IcObject(id, type, position, size, homeScale);

        // Object.entries(this).forEach(([key, value], i) => {
        //   // if(icObj_clone[key] == null) {
        //     const valueDeepCopy = JSON.parse(JSON.stringify(value));
        //     icObj_clone[key] = valueDeepCopy;
        //   // }
        // });

        const arr_alreadySet = [
          "id",
          "type",
          "position",
          "size",
          "homeScale",
        ];

        Object.entries(this)
          .filter(([key, value]) => {
            const valueAlreadyCopied = (arr_alreadySet.includes(key));
            // console.log(key, valueAlreadyCopied);
            return !valueAlreadyCopied;
          })
          .forEach(([key, value], i) => {
            // if(icObj_clone[key] == null) {
            // const valueDeepCopy = JSON.parse(JSON.stringify(value));
            // icObj_clone[key] = valueDeepCopy;
            // }
            logger.log("deepClone", key, value);

            switch (key) {
              case "scale":
                {
                  const scale = value;
                  const scale__deepClone = Object.assign({}, scale);
                  icObj__deepClone[key] = scale__deepClone;
                }
                break;
              case "img":
                {
                  const img = value;
                  const img__deepClone = img.cloneNode(true);
                  icObj__deepClone[key] = img__deepClone;
                }
                break;
              case "mathNode":
                {
                  const mathNode = value;
                  const mathNode__deepClone = mathNode.cloneDeep();
                  if (mathNode.autoSimplify != null) {
                    mathNode__deepClone.autoSimplify = mathNode.autoSimplify;
                  }
                  icObj__deepClone[key] = mathNode__deepClone;
                }
                break;
              default:
                {
                  const valueCopy = value;
                  icObj__deepClone[key] = valueCopy;
                }
                break;
            }

          });

        return icObj__deepClone;
      }


    }

  </script>


  <script>
    class Ic_HUD {
      constructor(eltsDict) {
        this.eltsDict = eltsDict;
      }

      setIsRecording(isRecording) {
        this.eltsDict["red_dot"].style.visibility = isRecording ? "visible" : "hidden";
      }

    }
  </script>

  <div id="ic_HUD_container" style="position:absolute; left:0; top: 0; font-size: 60px; pointer-events: none;">
    <div>
      <div
        style="display: block; position:absolute; left: 15px; top: 15px; background-color: red; width: 70px; height: 70px; opacity: 0.7; border-radius: 35px;"
        id="ic_HUD_red_dot"></div>
    </div>
    <script>
      const icHUD_eltsDict = {
        red_dot: document.getElementById("ic_HUD_red_dot"),
      };
      const ic_HUD = new Ic_HUD(icHUD_eltsDict);
    </script>



    <script>
      /*
      class IcComposite {
  
        constructor(handle, otherPartsDict) {
          this.parts  = Object.assign(otherPartsDict, {
            "handle": handle,
          };
        }
  
        getHandle() {
          return this.parts["handle"];
        }
  
        getPart(icObjId) {
          const part = Object.values(this.parts).find(part => (part.icObject.id == icObjId));
          return part;
        }
  
        getIcObject(icObjId) {
          const part = this.getPart(icObjId);
          return part ? part.icObject : null;
        }
  
        managePartUpdate(part, updateDict) {
  
          const icObj_compositePart = part.icObject;
  
          const arr_compositePartIcObj = Object.values(this.parts).map(compositePart => compositePart.icObject);
          const arr_compositePartIcObj__other = arr_compositePartIcObj.filter(icObj => icObj.id != icObj_compositePart.id);
  
          arr_compositePartIcObj__other.forEach((icObj, i) => {
  
            //test
            // icObj.position = Object.assign({}, icObj_compositePart.position);
  
            //get free rep
            // const represented = infiniteCanvas.getRepresented(icObj.id);
            // const rep_free    = represented.r_free();
  
            const rep_free = icObj;
  
            if(outerUpdatesDict.position != null) {
  
              const position_offset = {
                dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
              };
              // console.log("position_offset", position_offset);
  
              const obj = {
                position: {
                  x: rep_free.position.x + position_offset.dx,
                  y: rep_free.position.y + position_offset.dy,
                },
              };
  
              rep_free.syncWith(obj);
  
              //debug
              // rep_free.position = {
              //   x: icObj_compositePart.position.x + 100,
              //   y: icObj_compositePart.position.y + 100,
              // };
  
            }
  
          });
  
        }
  
        outerUpdatePart(part, updateDict) {
  
        }
  
      }
  
      class IcCompositePart {
  
        constructor(icObject, isMobile = false) {
          this.icObject = icObject;
  
          this.isMobile = isMobile;
        }
  
      }
      */







      /* POVs */

      class POV {

        constructor(scale, offset) {
          this.scale = scale;
          this.offset = offset;
        }

        static createPOVWithValues(scale_X, scale_Y, offset_dx, offset_dy) {
          const scale = {
            X: scale_X,
            Y: scale_Y,
          };
          const offset = {
            dx: offset_dx,
            dy: offset_dy,
          };
          return new POV(scale, offset);
        }

        static debugInstance() {
          const scale = {
            X: 2.0,
            Y: 1.5,
          };
          const offset = {
            dx: +100,
            dy: +100,
          };
          return new POV(scale, offset);
        }


      }






      /*****
        REPRESENTATIONS / BACKING OBJECT
      *//////

      var ID = () => {
        let arr = new Uint32Array(8);
        window.crypto.getRandomValues(arr);
        let str = '';
        for (let i = 0; i < arr.length; i++) {
          str += (i < 2 || i > 5 ? '' : '-') + arr[i].toString(16).slice(-4);
        }
        return str;
      };

      class BackingSchema {

        constructor(propsDict) {
          const arr_entries = Object.entries(propsDict).map(([propName, prop]) => {
            var propType;
            if (prop != null) {
              propType = prop.constructor;
            } else {
              propType = Object;
            }
            return [propName, propType];
          });
          const propConstructorsDict = Object.fromEntries(arr_entries);

          Object.assign(this, propConstructorsDict);
        }

        static fromObject(obj) {
          return new BackingSchema(obj);
        }
      }

      class BackingObject {

        constructor(repClass, backingSchema, obj = null) {
          this.id = ID();

          /**/
          //pour la forme
          this.repClass = repClass;
          this.backingSchema = backingSchema;
          /**/

          // this.counter = 0;
          this.representations = {};

          // this.inner = new repClass();                                                     //}
          //this.inner = {};                                                                  //} SHU: ça se discute
          this.innerRep = createRepresentation(obj, "id_inner_rep" + "__" + this.id, []);     //}
          this.addRepresentation(this.innerRep);
        }

        static fromBackingSchemaAndObject(backingSchema, obj) {
          const repClass = obj.constructor;

          const backingObject = new BackingObject(repClass, backingSchema, obj);
          return backingObject;
        }

        static fromObject(obj) {
          const repClass = obj.constructor;
          const backingSchema = BackingSchema.fromObject(obj);

          const backingObject = new BackingObject(repClass, backingSchema, obj);
          return backingObject;
        }

        generateNewRepId() {
          // const id = this.counter;
          // this.counter += 1;
          // return id;

          const id_rep = ID();
          return id_rep;
        }

        getNewRepresentation(repType = "std") {
          var outRep;

          const backingObj = this;

          const id_rep = backingObj.generateNewRepId();

          const target = backingObj.innerRep;
          console.log("target", target);

          const arr_backingObj = [backingObj];

          switch (repType) {
            case "std":
              outRep = createRepresentation(target, id_rep, arr_backingObj);
              break;
            // case "ghost":
            //   outRep = createRepresentation__ghost(target, id_rep, arr_backingObj);
            //   break;
            default:
              throw new Error("Unsupported repType: " + repType);
              break;
          }

          backingObj.addRepresentation(outRep);

          return outRep;
        }

        // updateWithRepresentation(rep__update) {
        //
        //   const arr_affected = Object.values(this.representations).filter(rep => rep.id != rep__update.id);
        //
        //   arr_affected.forEach((rep, i) => {
        //     rep.syncWith(rep__update);
        //   });
        //
        // }

        updateWithPropFromRepresentation(propName, setValue, rep__update) {
          // console.log("updateWithPropFromRepresentation", propName, setValue, rep__update);
          // console.log("rep__update.id_rep", rep__update.id_rep);

          const arr_affected = Object.values(this.representations).filter(rep => rep.id_rep != rep__update.id_rep);
          // console.log("arr_affected", arr_affected.map(rep => rep.id_rep));

          arr_affected.forEach((rep, i) => {
            rep.updateFromOuter(propName, setValue, rep__update);
          });

        }

        addRepresentation(representation) {
          this.representations[representation.id_rep] = representation;
          // this.innerRep.follow(representation);  //SHU: innerRep now useless ?
        }

        removeRepresentation(rep) {
          //rep should no longer get any update from any other rep
          rep.unfollowAll();

          //all following reps must unfollow
          const arr_followers = Object.values(rep.followers);
          arr_followers.forEach((rep_follower) => {
            rep_follower.unfollow(rep);
          });

          //remove reference in dict
          delete this.representations[rep.id_rep];
        }

      }

      //original representation
      // function createRepresentation(target, id_rep, arr_backingObj) {
      //     // console.log("createRepresentation", "target", target);
      //     // console.log("createRepresentation", JSON.stringify(target));
      //
      //     // const targetClass = target.constructor;
      //
      //     const broadcaster = {}; //--> push to backingObject(s)
      //     broadcaster.id_rep = id_rep;
      //     broadcaster.arr_backingObj = arr_backingObj;
      //     broadcaster.addBackingObject = function(backingObj) {
      //       broadcaster.arr_backingObj.push(backingObj);
      //       backingObj.addRepresentation(broadcaster.representation);
      //     };
      //
      //     broadcaster.createSisterRepresentation = function(backingObj = null) {
      //       var targetBackingObj = backingObj;
      //       if(targetBackingObj == null) {
      //         const backingObj_first = broadcaster.arr_backingObj.find(e => true);
      //         targetBackingObj = backingObj_first;
      //       }
      //       return targetBackingObj.getNewRepresentation();
      //     };
      //
      //     const receiver  = {}; //<-- receive updates from backingObject(s)
      //     receiver.id_rep = id_rep;
      //
      //
      //     const inner = target.clone();
      //     // console.log("inner", inner);
      //
      //     const representation = new Proxy({}, {
      //         get: function (obj, propName) {
      //           // console.log("representation.get", propName);
      //           var outProp;
      //
      //           if(propName in broadcaster) {
      //             outProp = broadcaster[propName];//.bind(broadcaster);
      //           } else if(propName in receiver) {
      //             outProp = receiver[propName];//.bind(receiver);
      //           }
      //
      //           else if(propName in inner) {
      //             outProp = inner[propName];//.bind(inner);
      //           }
      //
      //           // else {
      //           //   console.log("representation", obj);
      //           //   throw new Error("unknown propName" + "(" + propName + ")" + " for representation: " + obj);
      //           // }
      //
      //           return outProp;
      //         },
      //         set: function (obj, propName, setValue) {
      //           // console.log("representation.set", propName, setValue);
      //
      //           updateInternals(propName,setValue);
      //           broadcaster.arr_backingObj.forEach((backingObj, i) => {
      //             console.log("representation", broadcaster.representation, "has updated");
      //             // console.log("broadcasting to", backingObj);
      //             backingObj.updateWithPropFromRepresentation(propName, setValue, broadcaster.representation);
      //           });
      //
      //           return true;
      //         },
      //     });
      //
      //     function updateInternals(propName, value) {
      //       // console.log("updateInternals", propName, value);
      //
      //       inner[propName] = value;
      //     }
      //
      //
      //
      //
      //
      //
      //     receiver.updateFromOuter = (propName,value) => {
      //       // console.log("updateFromOuter", propName, value);
      //
      //       updateInternals(propName,value);
      //
      //       // receiver.didUpdateProp(prop,value);
      //
      //       //timeout to avoid calling didUpdate for every updated prop
      //       if(receiver.didUpdateTimeout == null) {
      //         const timeout_delayInMs = 17;
      //         receiver.didUpdateTimeout = setTimeout(() => {
      //           // console.log("didUpdateTimeout", "triggering");
      //           receiver.didUpdate();
      //           receiver.didUpdateTimeout = null;
      //         }, timeout_delayInMs);
      //       }
      //     };
      //
      //     // receiver.didUpdatePropListeners = [];
      //     // receiver.didUpdateProp = (prop,value) => {
      //     //   receiver.didUpdatePropListeners.forEach((listener, i) => {
      //     //     listener(prop,value);
      //     //   });
      //     // }
      //
      //     receiver.didUpdateTimeout   = null;
      //     receiver.didUpdateListeners = [];
      //     receiver.didUpdate = () => {
      //       // console.log("receiver", "didUpdate");
      //       receiver.didUpdateListeners.forEach((listener, i) => {
      //         listener(receiver.representation);
      //       });
      //     };
      //
      //     receiver.addOnOuterUpdate = (listener) => {
      //       receiver.didUpdateListeners.push(listener);
      //     };
      //
      //
      //
      //
      //     const glassFacade = new Proxy(inner, {
      //       get: function (obj, propName) {
      //         // console.log("glassFacade.get", propName);
      //         var outProp;
      //
      //         if (propName === 'toJSON') {
      // 		      return function() { return obj; }
      //         }
      //
      //         if(propName in inner)	{	//Be careful! The in operator matches all object keys, including those in the object's prototype chain.
      //           outProp = inner[propName];
      //         } else {
      //           outProp = representation[propName];
      //         }
      //
      //         return outProp;
      //       },
      //       set: function (obj, propName, setValue) {
      //           //console.log("glassFacade.set", propName /*,setValue*/ );
      //           representation[propName] = setValue;
      //           return true;
      //       },
      //     });
      //
      //     broadcaster.representation = glassFacade;
      //     receiver.representation    = glassFacade;
      //
      //
      //     return glassFacade;
      //   }
      //

      class RepresentationFactory {
        static initial(obj) {
          return BackingObject.fromObject(obj).getNewRepresentation();
        }
      }

      class RepresentedFactory {
        static initial(obj) {
          const backingObj = BackingObject.fromObject(obj);
          const rep_official = backingObj.getNewRepresentation();
          const represented = new Represented(backingObj, rep_official);
          rep_official.represented = represented;
          return represented;
        }
      }

      class Represented {

        constructor(backingObj, rep_official) {
          this.backingObj = backingObj;

          this.reps = {};
          this.reps["official"] = rep_official;
        }

        r_official() {
          return this.reps["official"];
        }

        createNewRepresentation(repName, repType = "std") {
          const rep_new = this.backingObj.getNewRepresentation(repType);
          rep_new.represented = this;

          this.reps[repName] = rep_new;

          return rep_new;
        }

        getRepresentation(repName) {
          return this.reps[repName];
        }

        // removeRepresentation(repName) {
        //   if(repName == "official") {
        //     throw new Error("Represented::removeRepresentation, can't remove official rep");
        //   }
        //   const rep = this.reps[repName];
        //   this.backingObj.removeRepresentation(rep);
        //   delete this.reps[repName];
        // }

        removeRepresentation(rep) {
          if (rep == this.r_official()) {
            throw new Error("Represented::removeRepresentation, can't remove official rep");
          }
          this.backingObj.removeRepresentation(rep);

          const repName = this.getRepNameForRep(rep);
          delete this.reps[repName];
        }

        deconstruct() {
          //warning: this is only to be used when destroying represented
          // this.backingObj = null;
          this.reps = {};
        }

        getRepNameForRep(rep_unknown) {
          var outString;

          const entry_found = Object.entries(this.reps).find(([repName, rep]) => rep == rep_unknown);
          if (entry_found != null) {
            outString = entry_found[0];
          } else {
            console.log("rep not found in represented");
            outString = null;
          }

          return outString;
        }



        //convenience
        r_free() {
          return this.reps["free"];
        }

        r_snapped() {
          return this.reps["snapped"];
        }






        officialSerial_p() {
          const rep = this.r_official();
          const serial_p = rep.toSerial_p();
          return serial_p;
        }





      }

      // class RepresentationNetwork {
      //
      //
      // }
      //
      // class RepresentationNetworkNode {
      //
      //
      // }


      //representation "plus"
      function createRepresentation(target, id_rep, arr_backingObj/*, dict_ignoredPropName = {}*/) {
        // console.log("createRepresentation", "target", target);
        // console.log("createRepresentation", JSON.stringify(target));

        // const targetClass = target.constructor;

        const broadcaster = {}; //--> push to backingObject(s)
        broadcaster.id_rep = id_rep;
        broadcaster.arr_backingObj = arr_backingObj;
        broadcaster.addBackingObject = function (backingObj) {
          broadcaster.arr_backingObj.push(backingObj);
          backingObj.addRepresentation(broadcaster.representation);
        };

        // broadcaster.createSisterRepresentation = function(backingObj = null) {  //~ "gemini rep"
        //   var targetBackingObj = backingObj;
        //   if(targetBackingObj == null) {
        //     const backingObj_first = broadcaster.arr_backingObj.find(e => true);
        //     targetBackingObj = backingObj_first;
        //   }
        //
        //   const rep_elder  = broadcaster.representation;
        //   const rep_sister = targetBackingObj.getNewRepresentation();
        //
        //   rep_sister.follow(rep_elder);
        //   rep_elder.follow(rep_sister);
        //
        //   return rep_sister;
        // };
        //
        // broadcaster.removeSisterRepresentation = (rep) => {
        //   //SHU: TODO
        // };

        broadcaster.followers = {};
        broadcaster.addFollower = function (rep) {
          broadcaster.followers[rep.id_rep] = rep;
        }

        broadcaster.removeFollower = function (rep) {
          delete broadcaster.followers[rep.id_rep];
        }


        broadcaster.didUpdateFromInner = (representation, propName, oldValue, newValue) => {

          broadcaster.didUpdateFromInnerListeners.forEach((listener, i) => {
            // if(!listener) {   //SHU: oulala
            //   // logger.log("broadcaster.didUpdateFromInnerListeners", broadcaster.didUpdateFromInnerListeners);
            //   // throw new Error("listener == null");
            //
            //   return;
            // }
            // logger.log("listener", listener);
            listener(representation, propName, oldValue, newValue);
          });
        };

        // var innerUpdates = {};
        broadcaster.didUpdateFromInnerListeners = [];
        broadcaster.onInnerUpdate = (listener) => {
          broadcaster.didUpdateFromInnerListeners.push(listener);
        };
        broadcaster.offInnerUpdate = (listener) => {
          // logger.log("broadcaster.didUpdateFromInnerListeners, before", broadcaster.didUpdateFromInnerListeners);
          broadcaster.didUpdateFromInnerListeners = Utils.arrayByRemovingElement(broadcaster.didUpdateFromInnerListeners, listener);
          // logger.log("broadcaster.didUpdateFromInnerListeners,  after", broadcaster.didUpdateFromInnerListeners);
        };

        broadcaster.offAllInnerUpdates = () => {
          receiver.didUpdateFromInnerListeners = [];
        };


        const receiver = {}; //<-- receive updates from backingObject(s)
        receiver.id_rep = id_rep;


        const inner = target.clone();
        // console.log("inner", inner);

        const representation = new Proxy({}, {
          get: function (obj, propName) {
            // console.log("representation.get", propName);
            var outProp;

            if (propName in broadcaster) {
              outProp = broadcaster[propName];//.bind(broadcaster);
            } else if (propName in receiver) {
              outProp = receiver[propName];//.bind(receiver);
            }

            else if (propName in inner) {
              outProp = inner[propName];//.bind(inner);
            }

            // else {
            //   console.log("representation", obj);
            //   throw new Error("unknown propName" + "(" + propName + ")" + " for representation: " + obj);
            // }

            return outProp;
          },
          set: function (obj, propName, setValue) {
            if (propName == "touchStateDict") {
              logger.trace("representation.set", propName, setValue);
            }

            if (propName in broadcaster) {
              broadcaster[propName] = setValue;
            } else if (propName in receiver) {
              receiver[propName] = setValue;
            }

            else {
              //setting something in inner

              // const isIgnoredPropName = (dict_ignoredPropName[propName] != null);
              // if(!isIgnoredPropName) {

              const oldValue = inner[propName];
              const newValue = setValue;

              updateInternals(propName, setValue);
              broadcaster.arr_backingObj.forEach((backingObj, i) => {
                // console.log("representation has updated", broadcaster.representation);
                // console.log("broadcasting to", backingObj);
                backingObj.updateWithPropFromRepresentation(propName, setValue, broadcaster.representation);
              });

              broadcaster.didUpdateFromInner(broadcaster.representation, propName, oldValue, newValue);

              // }

            }

            return true;
          },
        });

        function updateInternals(propName, value) {
          // console.log("updateInternals", propName, value);

          inner[propName] = value;
        }

        //follow system

        receiver.followed = {};

        receiver.follow = function (rep) {
          const follower = receiver.representation;
          const followed = rep;

          if (followed == follower) {
            //can't follow self
            //ignore
            return;
          }

          followed.followers[follower.id_rep] = follower;
          follower.followed[followed.id_rep] = followed;
        }

        receiver.unfollow = function (rep) {
          const follower = receiver.representation;
          const followed = rep;

          if (followed.followers[follower.id_rep] != null) {
            delete followed.followers[follower.id_rep];
          }
          if (follower.followed[followed.id_rep] != null) {
            delete follower.followed[followed.id_rep];
          }
        }

        receiver.followAll = function () {
          const arr_repDicts = arr_backingObj.map((backingObj) => backingObj.representations);
          const arr_allreps = arr_repDicts.reduce((acc, repDict) => {
            const arr = acc;
            arr.push(...Object.values(repDict));
            return arr;
          }, []);
          arr_allreps.forEach((rep, i) => {
            receiver.follow(rep);
          });
        }

        receiver.unfollowAll = function () {
          const followed = Object.assign({}, receiver.followed);
          Object.values(followed).forEach((rep, i) => {
            receiver.unfollow(rep);
          });
        }

        // receiver.inner = inner;
        receiver.syncWith = function (rep, set_propName__ignored = null) {
          // Object.entries(rep.inner).forEach(([propName,value], i) => {
          //   updateInternals(propName, value);
          // });

          const arr_propName = Object.keys(inner);

          var arr_propName__filtered;
          if (set_propName__ignored == null) {
            arr_propName__filtered = arr_propName;
          } else {
            arr_propName__filtered = arr_propName.filter(propName => !set_propName__ignored.has(propName));
          }

          arr_propName__filtered.forEach((propName, i) => {
            const value = rep[propName];
            console.log("+++syncWith", propName, value);
            updateInternals(propName, value);
          });

        };

        receiver.syncWithObj = function (obj, set_propName__ignored = null) {

          const arr_propName = Object.keys(obj);

          var arr_propName__filtered;
          if (set_propName__ignored == null) {
            arr_propName__filtered = arr_propName;
          } else {
            arr_propName__filtered = arr_propName.filter(propName => !set_propName__ignored.has(propName));
          }

          arr_propName__filtered.forEach((propName, i) => {
            const value = obj[propName];
            console.log("+++syncWithObj", propName, value);
            updateInternals(propName, value);
          });

        };


        var outerUpdates = {};
        receiver.updateFromOuter = (propName, value, rep) => {
          // console.log("updateFromOuter", propName, value);

          // const isIgnoredPropName = (dict_ignoredPropName[propName] != null);
          // if(isIgnoredPropName) {
          //   return;
          // }

          const isRepFollowed = (receiver.followed[rep.id_rep] == rep);
          if (!isRepFollowed) {
            // console.log("rep not followed", "ignore");
            return;
          }

          // outerUpdates[propName] = value;
          if (outerUpdates[propName] == null) {
            outerUpdates[propName] = {
              old: inner[propName],     //SHU: beware with this

              //debug
              // old: value,
            };
          }
          outerUpdates[propName]["new"] = value;


          updateInternals(propName, value);

          // receiver.didUpdateProp(prop,value);

          function reportOuterUpdates() {
            // console.log("didUpdateTimeout", "triggering");
            receiver.didUpdateFromOuter(outerUpdates);
            receiver.didUpdateFromOuterTimeout = null;
            outerUpdates = {};
          }

          //timeout to avoid calling didUpdate for every updated prop
          if (receiver.didUpdateFromOuterTimeout == null) {

            // const timeout_delayInMs = 17;
            const timeout_delayInMs = 0;
            // const timeout_delayInMs = 500;

            receiver.didUpdateFromOuterTimeout = setTimeout(() => {
              reportOuterUpdates();
            }, timeout_delayInMs);

          }

          // requestAnimationFrame(reportOuterUpdates);

        };


        // receiver.remoteInnerUpdate = (propName, value, rep) => {
        //
        // };


        // receiver.didUpdatePropListeners = [];
        // receiver.didUpdateProp = (prop,value) => {
        //   receiver.didUpdatePropListeners.forEach((listener, i) => {
        //     listener(prop,value);
        //   });
        // }

        receiver.didUpdateFromOuterTimeout = null;
        receiver.didUpdateFromOuterListeners = [];
        receiver.didUpdateFromOuter = (updateDict) => {
          // console.log("receiver", "didUpdate");
          receiver.didUpdateFromOuterListeners.forEach((listener, i) => {
            listener(receiver.representation, updateDict);
          });
        };

        receiver.onOuterUpdate = (listener) => {
          receiver.didUpdateFromOuterListeners.push(listener);
        };

        receiver.offOuterUpdate = (listener) => {
          receiver.didUpdateFromOuterListeners = Utils.arrayByRemovingElement(receiver.didUpdateFromOuterListeners, listener);
        };

        receiver.offAllOuterUpdates = () => {
          receiver.didUpdateFromOuterListeners = [];
        };

        receiver.represented = null;


        receiver.toSerial_p = () => {
          // console.log("inner", inner);
          return inner.toSerial_p();
        }


        const glassFacade = new Proxy(inner, {
          get: function (obj, propName) {
            // console.log("glassFacade.get", propName);
            var outProp;

            if (propName === 'toJSON') {
              return function () { return obj; }
            }

            if (propName in inner) {	//Be careful! The in operator matches all object keys, including those in the object's prototype chain.
              outProp = inner[propName];
            } else {
              outProp = representation[propName];
            }

            return outProp;
          },
          set: function (obj, propName, setValue) {
            //console.log("glassFacade.set", propName /*,setValue*/ );
            representation[propName] = setValue;
            return true;
          },
        });

        broadcaster.representation = glassFacade;
        receiver.representation = glassFacade;


        return glassFacade;
      }


      // function createRepresentation__ghost(target, id_rep, arr_backingObj) {
      //   //feel/channel everything but moves
      //   const dict_ignoredPropName = {
      //     position: true,
      //   };
      //   const rep = createRepresentation(target, id_rep, arr_backingObj, dict_ignoredPropName);
      //
      //   return rep;
      // }



      /*//////
      *********/

      class Enginiter {

        static installEngine(engineCarrier, engine) {

          //install func for engine to work properly
          engineCarrier.getScopeObj = function (engineCarrier) {
            const scopeObj = {
              engineCarrier: engineCarrier,
            };
            return scopeObj;
          };

          //install engine
          // engineCarrier.engine = engine;
        }

      }

      class Engine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }

          this.start = function () {   //SHU: attention, il y a peut-être une drôlerie de closure ici
            logger.log("this.scopeObj.engineCarrier", this.scopeObj.engineCarrier);
            const engineCarrier = this.scopeObj.engineCarrier;
            //do something with engineCarrier
          };

          this.stop = function () {
            // delete this.scopeObj;
          };

          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }

      class DebugEngine_growText {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }

          this.start = function () {   //SHU: attention, il y a peut-être une drôlerie de closure ici
            // logger.log("engine.start()");
            // logger.log("this.scopeObj.engineCarrier", this.scopeObj.engineCarrier);

            const engineCarrier = this.scopeObj.engineCarrier;

            engineCarrier.text += "[]";

            const interval__growth = setInterval(() => {
              // logger.log("debugEngine_growText", "interval");

              engineCarrier.text += "[]";              //linear      growth
              // engineCarrier.text += engineCarrier.text;   //exponential growth

              if (engineCarrier.text.length > 10000) {
                // engineCarrier.engine.stop();
                this.stop();
              }

            }, 1000);


            if (this.scopeObj.running == null) {
              this.scopeObj.running = {};
            }
            this.scopeObj.running["interval"] = {
              interval__growth: interval__growth,
            };
          };

          this.stop = function () {
            // logger.log("engine.stop()");

            if (this.scopeObj.running != null) {
              if (this.scopeObj.running["interval"] != null) {
                const arr_interval = Object.values(this.scopeObj.running["interval"]);

                arr_interval.forEach((interval, i) => {
                  clearInterval(interval);
                });

              }
            }
          };

          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }

      class DebugEngine_changeColor {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }

          this.start = function () {   //SHU: attention, il y a peut-être une drôlerie de closure ici
            // logger.log("engine.start()");
            // logger.log("this.scopeObj.engineCarrier", this.scopeObj.engineCarrier);

            const engineCarrier = this.scopeObj.engineCarrier;

            engineCarrier.backgroundColor = ColorUtils.randomColor();

            const interval__growth = setInterval(() => {
              // logger.log("debugEngine_changeColor", "interval");

              engineCarrier.backgroundColor = ColorUtils.randomColor();

            }, 777);


            if (this.scopeObj.running == null) {
              this.scopeObj.running = {};
            }
            this.scopeObj.running["interval"] = {
              interval__growth: interval__growth,
            };
          };

          this.stop = function () {
            logger.log("engine.stop()");

            if (this.scopeObj.running != null) {
              if (this.scopeObj.running["interval"] != null) {
                const arr_interval = Object.values(this.scopeObj.running["interval"]);

                arr_interval.forEach((interval, i) => {
                  clearInterval(interval);
                });

              }
            }
          };

          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }



      class Toucher {

        constructor() {
          this.transformationFunc = null;
        }

        static debugInstance() {
          const toucher = new Toucher();

          const transformationFunc = (icObject_in) => {
            var outMutationObject = {};

            function randomColor() {
              var r = 255 * Math.random() | 0,
                g = 255 * Math.random() | 0,
                b = 255 * Math.random() | 0;
              return 'rgb(' + r + ',' + g + ',' + b + ')';
            }

            const color = randomColor();
            outMutationObject.fill = color;

            return outMutationObject;
          };

          toucher.transformationFunc = transformationFunc;

          return toucher;
        }

      }


      class TouchSlotEngine {
        // constructor(touchSlotConfig) {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptTouching = function (icObj_slot, icObj_piece) {
            // logger.log("attemptTouching", icObj_slot, icObj_piece);

            const canTouch = this.checkCanTouch(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            // logger.log("attempting to touch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canTouch) {
              console.log("can touch");

              const rep_official = icObj_piece;
              const represented = icObj_piece.represented;
              const rep_free = represented.getRepresentation("free");

              // console.log("rep_free.isHeld", rep_free.isHeld);
              // if(rep_free.isHeld) {
              //   presnap(icObj_slot, icObj_piece);
              // } else {
              //   presnap(icObj_slot, icObj_piece);
              //   snap(icObj_slot, icObj_piece);
              // }

              this.touch(icObj_slot, icObj_piece);

            } else {
              console.log("can't touch");
            }

          };

          this.checkCanTouch = function (icObj_slot, icObj_piece) {
            // logger.log("checkCanTouch", icObj_piece);
            var outBool;

            // outBool = Touch.canTouch(icObj_piece, icObj_slot);

            var canTouchFunc = this.scopeObj.engineCarrier.touchSlotConfig.canTouchFunc;
            if (canTouchFunc == null) {

              // canTouchFunc = Touch.canTouch;

              // const infiniteCanvas = this.scopeObj.infiniteCanvas;
              // canTouchFunc = infiniteCanvas.touch2.canTouch;

              canTouchFunc = Touch2Singleton.sharedInstance().canTouch;
            }

            const context = this.scopeObj.engineCarrier.touchSlotConfig.context;

            outBool = canTouchFunc(icObj_piece, icObj_slot, context);

            return outBool;
          };


          this.touch = async function (icObj_slot, icObj_piece) {
            console.log("touch", icObj_piece);

            const icTouchSlot = this.scopeObj.engineCarrier;


            const rep_official = icObj_piece;
            const represented = icObj_piece.represented;
            const rep_free = represented.getRepresentation("free");
            // const rep_touched  = represented.getRepresentation("snapped");


            //rep_official.touchStateDict[icObj_slot.id] = TouchState.Touched;    //SHU: as of now, don't set prop inside dict
            const touchStateDict__clone = Object.assign({}, rep_official.touchStateDict);
            touchStateDict__clone[icObj_slot.id] = TouchState.Touched;
            // rep_official.touchStateDict = touchStateDict__clone;               //SHU: it does not work well with rep_official, I've tried with rep_free and it seems ok...  (I don't care that much anymore)
            rep_free.touchStateDict = touchStateDict__clone;                  //SHU: as of now, set dict as if it were a depthless prop


            //apply mutation
            console.log("touch: apply mutation");
            // console.log("rep_official.text", rep_official.text);

            // if(rep_official.text != null) {
            //
            //   /*
            //   const number_in   = parseInt(rep_official.text,10);
            //   const number_out  = number_in + 1;
            //
            //   rep_free.text     = "" + number_out;
            //   */
            //
            //   const number_in   = parseInt(rep_official.text,10);
            //   const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            //   const number_out  = transformationFunc(number_in);
            //
            //   rep_free.text     = "" + number_out;
            // }
            // else

            // if(rep_official.mathNode != null) {
            //
            //   // const tex_in    = rep_official.tex;
            //   // const expr_in   = algebra.fromTex(tex_in);
            //   const mathNode_in = rep_official.mathNode;
            //
            //   const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            //   const mathNode_out  = transformationFunc(mathNode_in);
            //
            //   rep_free.mathNode = mathNode_out;
            //
            //   // const tex_out = expr_out.toTex();
            //   // rep_free.tex  = tex_out;
            // }
            // else

            var transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            if (transformationFunc == null) {
              transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc__touch;
            }

            if (transformationFunc != null) {
              console.log("&&&touch");
              console.log("icTouchSlot", icTouchSlot);

              const icObj__touched = rep_free;

              ////temporary
              //// {
              ////   if(icObj__touched.type == "composite" && icObj__touched.parts.contactArea != null) {
              ////     icObj__touched = icObj__touched.parts.facade;
              ////   }
              //// }

              logger.log("icObj__touched", icObj__touched);


              const transformationOutput = await transformationFunc(icObj__touched, icObj_slot);
              switch (transformationOutput.type) {
                case "new":
                  {
                    const infiniteCanvas = this.scopeObj.infiniteCanvas;

                    //get vessel
                    var rep_free__vessel;
                    // if(transformationOutput.vessel != null) {
                    // rep_free__vessel = transformationOutput.vessel;
                    const id__parentVessel = icObj__touched.compositeId;
                    if (id__parentVessel != -1) {
                      logger.log("id__parentVessel != -1", id__parentVessel);
                      const rep_free__parentVessel = infiniteCanvas.getRepresented(id__parentVessel).r_free();
                      rep_free__vessel = rep_free__parentVessel;
                    } else {
                      logger.log("id__parentVessel == -1");
                      const rep_free__supervessel = infiniteCanvas.getSupervessel();
                      rep_free__vessel = rep_free__supervessel;
                    }

                    rep_free__vessel.dict_engine["composite"].engine.awoken.removePart(icObj__touched);

                    //killOld
                    function killOld(icObj__old) {
                      // infiniteCanvas.removeIcObject(icObj__touched);
                      switch (icObj__old.type) {
                        case "composite":
                          {
                            Object.entries(icObj__old.parts).forEach(([partName, icObj__part], i) => {
                              icObj__old.dict_engine["composite"].engine.awoken.removePart(icObj__part);
                              icObj__part.im_dying_now = true;
                            });
                          }
                          break;
                        default:
                          break;
                      }

                      icObj__old.im_dying_now = true;
                    }

                    function findParentInOld(icObj__old, icObj__new) {
                      var outFindResult;

                      const findResult__initial = {
                        isFound: false,
                        parent: null,
                      };

                      outFindResult = findResult__initial;

                      switch (icObj__old.type) {
                        case "composite":
                          {
                            const arr_part = Object.values(icObj__old.parts);

                            //breadth-first
                            outFindResult = Utils.early_break_reduce(arr_part, (acc, x, i, arr) => {
                              const isFound = (x == icObj__new);
                              logger.log("isFound", x, icObj__new, isFound);
                              if (isFound) {
                                acc.parent = icObj__old;
                              }
                              acc.isFound = acc.isFound || isFound;
                              return acc;
                            }, outFindResult, (acc, x, i, arr) => {
                              return (acc.isFound == true);
                            });

                            if (!outFindResult.isFound) {
                              outFindResult = Utils.early_break_reduce(arr_part, (acc, x, i, arr) => {
                                acc = findParentInOld(x, icObj__new);
                                return acc;
                              }, outFindResult, (acc, x, i, arr) => {
                                return (acc.isFound == true);
                              });
                            }

                          }
                          break;
                        default:
                          break;
                      }

                      logger.log("findParentInOld", icObj__old, icObj__new, outFindResult);

                      return outFindResult;
                    }


                    //add new
                    function addNew(icObj__new, isInCanvas) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        Object.entries(icObj__new.parts).forEach(([partName, icObj__part], i) => {
                          icObj__part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      if (!isInCanvas) {
                        infiniteCanvas.addIcObject(icObj__new);
                      }

                      const isPositionCorrection = true;
                      if (isPositionCorrection) {
                        icObj__new.position = {
                          x: rep_free__vessel.position.x,
                          y: rep_free__vessel.position.y,
                        };
                      }

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__vessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new);
                    }

                    const icObj__old = icObj__touched;

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      //if icObj__new belongs to icObj__old hierarchy, remove icObj__new from icObj__old hierarchy
                      const findParentInOld_ = findParentInOld(icObj__old, icObj__new);
                      if (findParentInOld_.isFound) {
                        const composite__parent = findParentInOld_.parent;
                        composite__parent.dict_engine["composite"].engine.awoken.removePart(icObj__new);

                        logger.log("parent", composite__parent);
                        logger.log("removed part", icObj__new);

                        killOld(icObj__old);
                        addNew(icObj__new, true);

                      } else {
                        killOld(icObj__old);
                        addNew(icObj__new, false);
                      }

                    } else if (transformationOutput.value instanceof Array) {

                      logger.log("transformationOutput.value instanceof Array");

                      //SHU: TODO: manage the case "filtering multiple objects in composite"

                      const arr_new = transformationOutput.value;

                      const isOldInArray = arr_new.includes(icObj__old);
                      if (isOldInArray) {

                        const arr__truly_new = arr_new.filter(icObj => icObj != icObj__old);
                        addNew(icObj__old, true);
                        arr__truly_new.forEach((icObj__new, i) => {
                          addNew(icObj__new, false);
                        });

                      } else {
                        killOld(icObj__old);

                        arr_new.forEach((icObj__new, i) => {
                          addNew(icObj__new, false);
                        });
                      }

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);

                    const mutationObj = transformationOutput.value;
                    // icObj__touched.mathNode = mutationObj.mathNode;
                    Object.assign(icObj__touched, mutationObj);
                  }
                  break;
                // case "displaced":
                // {
                //
                // }
                // break;
                case "sadness":
                  {
                    icObj__touched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;

                // case "mathNode":     //SHU: horror code   il serait bon un jour d'harmoniser: tout le monde doit utiliser TransformationOutput
                // case "composite":    //SHU: horror code
                // // {
                // //   // icObj__touched.mathNode = transformationOutput.mathNode;
                // // }
                // break;

                default:
                  logger.log("transformationOutput", transformationOutput);
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }

            } else {
              throw new Error("touch: transformationFunc == null");
            }


          };





          this.attemptUntouching = function (icObj_slot, icObj_piece) {
            console.log("attemptUntouching", icObj_slot, icObj_piece);

            const canUntouch = this.checkCanUntouch(icObj_slot, icObj_piece);
            console.log("canUntouch", canUntouch);

            const rep_official = icObj_piece;
            console.log("attempting to untouch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canUntouch) {
              // console.log("can untouch");
              this.untouch(icObj_slot, icObj_piece);

            } else {
              // console.log("can't untouch");
            }

          };

          this.checkCanUntouch = function (icObj_slot, icObj_piece) {
            logger.log("checkCanUntouch", icObj_piece);
            var outBool;

            outBool = Touch.canUntouch(icObj_piece, icObj_slot);

            return outBool;
          };

          this.untouch = function (icObj_slot, icObj_piece) {
            console.log("untouch", icObj_piece);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;

            // const rep_free     = icObj_piece;   //SHU: this is probably false
            const rep_free = infiniteCanvas.getRepresented(icObj_piece.id).r_free();

            const represented = icObj_piece.represented;
            const rep_official = represented.getRepresentation("official");


            const icTouchSlot = this.scopeObj.engineCarrier;

            const transformationFunc__untouch = icTouchSlot.touchSlotConfig.transformationFunc__untouch;
            if (transformationFunc__untouch != null) {

              const transformationFunc = transformationFunc__untouch;

              const icObj__untouched = rep_free;
              logger.log("icObj__untouched", icObj__untouched);

              const transformationOutput = transformationFunc(icObj__untouched);
              switch (transformationOutput.type) {
                case "new":   //SHU: this code has to be updated
                  {
                    const icTouchSlot = this.scopeObj.infiniteCanvas;

                    const rep_free__supervessel = infiniteCanvas.getSupervessel();

                    rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(icObj__untouched);

                    //remove old
                    {
                      // infiniteCanvas.removeIcObject(icObj__untouched);
                      icObj__untouched.im_dying_now = true;
                    }

                    //add new

                    function addNew(icObj__new) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        icObj__new.parts.forEach((part, i) => {
                          part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      infiniteCanvas.addIcObject(icObj__new);

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new);

                    }

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      addNew(icObj__new);

                    } else if (transformationOutput.value instanceof Array) {

                      transformationOutput.value.forEach((icObj__new, i) => {
                        addNew(icObj__new);
                      });

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);

                    const mutationObj = transformationOutput.value;
                    // icObj__touched.mathNode = mutationObj.mathNode;
                    Object.assign(icObj__untouched, mutationObj);
                  }
                  break;
                // case "displaced":
                // {
                //
                // }
                // break;
                case "sadness":
                  {
                    icObj__untouched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;

                // case "mathNode":     //SHU: horror code   il serait bon un jour d'harmoniser: tout le monde doit utiliser TransformationOutput
                // case "composite":    //SHU: horror code
                // // {
                // //   // icObj__touched.mathNode = transformationOutput.mathNode;
                // // }
                // break;

                default:
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }

            }

            rep_official.touchStateDict[icObj_slot.id] = TouchState.Untouched;
            // rep_free.touchStateDict[icObj_slot.id] = TouchState.Untouched;
          };



          // this.r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
          this.r_official_update_handler = function (icObj_slot, icObj_piece, outerUpdatesDict) {

            // logger.log("r_official_update_handler", icObj_piece);

            const touchState = icObj_piece.touchStateDict[icObj_slot.id];
            logger.log("touchState", touchState);

            if (touchState == TouchState.Untouched) {
              this.attemptTouching(icObj_slot, icObj_piece);
            } else if (touchState == TouchState.Touched) {
              this.attemptUntouching(icObj_slot, icObj_piece);
            }

          };

          // this.r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
          this.r_official_update_handler2 = function (rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions

            // logger.log("r_official_update_handler2", rep_official_incoming);

            // console.log("engine::r_official_update_handler2, this", this);
            // console.log("this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            // console.log("infiniteCanvas", infiniteCanvas);
            const icTouchSlot = this.scopeObj.engineCarrier;

            const represented = infiniteCanvas.getRepresented(icTouchSlot.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const touchSlot = rep_official;
            const incomingObj = rep_official_incoming;

            if (incomingObj != touchSlot) { //don't touch oneself

              if (!incomingObj.isTouchable) {
                //ignore: incomingObj is intangible
              } else {
                this.r_official_update_handler(touchSlot, incomingObj, outerUpdatesDict);
              }

            } else {
              console.log("I won't touch myself");  //SHU: ...
            }

          };


          this.start = function () {
            console.log("engine::start, this", this);
            // logger.log("touchSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icTouchSlot = this.scopeObj.engineCarrier;


            infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);

            //for each existing canvas object, add touchState wrt this new touchSlot
            infiniteCanvas.onceOnAddRepresentedForIcObject(icTouchSlot, (icTouchSlot) => {

              const id_touchSlot = icTouchSlot.id;

              const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
              const arr_official_preexisiting = arr_official.filter(rep => (rep.id != id_touchSlot));
              arr_official_preexisiting.forEach((rep, i) => {

                rep.touchStateDict[id_touchSlot] = TouchState.Untouched;
                //SHU TODO: check if touches

              });

            });

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }


      class DropTouchSlotEngine {
        // constructor(touchSlotConfig) {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptTouching = function (icObj_slot, icObj_piece) {
            // logger.log("DropTouchSlotEngine::attemptTouching", icObj_slot, icObj_piece);

            const canTouch = this.checkCanTouch(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            console.log("attempting to touch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canTouch) {
              console.log("can touch");

              const rep_official = icObj_piece;
              const represented = icObj_piece.represented;
              const rep_free = represented.getRepresentation("free");

              // console.log("rep_free.isHeld", rep_free.isHeld);
              // if(rep_free.isHeld) {
              //   presnap(icObj_slot, icObj_piece);
              // } else {
              //   presnap(icObj_slot, icObj_piece);
              //   snap(icObj_slot, icObj_piece);
              // }

              this.touch(icObj_slot, icObj_piece);

            } else {
              console.log("can't touch");
            }

          };

          this.checkCanTouch = function (icObj_slot, icObj_piece) {
            // logger.log("DropTouchSlotEngine::checkCanTouch", icObj_piece);
            var outBool;

            // outBool = Touch.canTouch(icObj_piece, icObj_slot);

            var canTouchFunc = this.scopeObj.engineCarrier.touchSlotConfig.canTouchFunc;
            if (canTouchFunc == null) {
              // canTouchFunc = Touch.canTouch;
              canTouchFunc = Touch2Singleton.sharedInstance().canTouch;
            }

            const context = this.scopeObj.engineCarrier.touchSlotConfig.context;

            outBool = canTouchFunc(icObj_piece, icObj_slot, context);

            return outBool;
          };


          this.touch = function (icObj_slot, icObj_piece) {
            logger.log("DropTouchSlotEngine::touch", icObj_piece);

            const icTouchSlot = this.scopeObj.engineCarrier;


            const rep_official = icObj_piece;
            // const represented  = icObj_piece.represented;
            // const rep_free     = represented.getRepresentation("free");
            // const rep_touched  = represented.getRepresentation("snapped");

            rep_official.touchStateDict[icObj_slot.id] = TouchState.Touched;

            const represented = icObj_piece.represented;
            const rep_free = represented.getRepresentation("free");

            //apply mutation
            console.log("touch: apply mutation");
            // console.log("rep_official.text", rep_official.text);

            {
              console.log("&&&touch");
              console.log("icDropTouchSlot", icTouchSlot);

              const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc__touch;

              var icObj__touched = rep_free;

              ////temporary
              //// {
              ////   if(icObj__touched.type == "composite" && icObj__touched.parts.contactArea != null) {
              ////     icObj__touched = icObj__touched.parts.facade;
              ////   }
              //// }

              logger.log("icObj__touched", icObj__touched);


              const transformationOutput = transformationFunc(icObj__touched);
              logger.log("transformationOutput", transformationOutput);
              switch (transformationOutput.type) {
                case "new":
                  {
                    const icTouchSlot = this.scopeObj.infiniteCanvas;

                    const rep_free__supervessel = infiniteCanvas.getSupervessel();

                    rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(icObj__touched);

                    //remove old
                    {
                      // infiniteCanvas.removeIcObject(icObj__touched);
                      icObj__touched.im_dying_now = true;
                    }

                    //add new

                    function addNew(icObj__new) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        icObj__new.parts.forEach((part, i) => {
                          part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      infiniteCanvas.addIcObject(icObj__new);

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new);

                    }

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      addNew(icObj__new);

                    } else if (transformationOutput.value instanceof Array) {

                      transformationOutput.value.forEach((icObj__new, i) => {
                        addNew(icObj__new);
                      });

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);
                    //old version
                    // const mutationObj = transformationFunc(icObj__touched);
                    const mutationObj = transformationOutput;

                    switch (transformationOutput.type) {
                      case "mathNode":
                        icObj__touched.mathNode = mutationObj.mathNode;
                        break;
                      default:
                        // throw new Error("unsupported transformationOutput.type: " + transformationOutput.type);      //SHU: careful
                        Object.assign(icObj__touched, mutationObj);
                        break;
                    }
                  }
                  break;
                case "displaced":
                  {
                    logger.log("transformationOutput.type == displaced");
                  }
                  break;
                case "sadness":
                  {
                    icObj__touched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;
                default:
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }


            }


            //debug
            {
              const rep_free__slot = infiniteCanvas.getRepresented(icObj_slot.id).r_free();
              rep_free__slot.fill = ColorUtils.randomColor();
            }



          };





          this.attemptUntouching = function (icObj_slot, icObj_piece) {
            console.log("attemptUntouching", icObj_slot, icObj_piece);

            const canUntouch = this.checkCanUntouch(icObj_slot, icObj_piece);
            console.log("canUntouch", canUntouch);

            const rep_official = icObj_piece;
            console.log("attempting to untouch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canUntouch) {
              // console.log("can untouch");
              this.untouch(icObj_slot, icObj_piece);

            } else {
              // console.log("can't untouch");
            }

          };

          this.checkCanUntouch = function (icObj_slot, icObj_piece) {
            console.log("checkCanUntouch", icObj_piece);
            var outBool;

            outBool = Touch.canUntouch(icObj_piece, icObj_slot);

            return outBool;
          };

          this.untouch = function (icObj_slot, icObj_piece) {
            console.log("untouch", icObj_piece);

            const icTouchSlot = this.scopeObj.engineCarrier;

            const represented = icObj_piece.represented;
            const rep_official = represented.getRepresentation("official");
            const rep_free = represented.getRepresentation("free");

            //apply mutation
            console.log("untouch: apply mutation");
            // console.log("rep_official.text", rep_official.text);

            {
              console.log("&&&untouch");
              console.log("icDropTouchSlot", icTouchSlot);

              const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc__untouch;

              const icObj__untouched = rep_free;

              const transformationOutput = transformationFunc(icObj__untouched);
              logger.log("transformationOutput", transformationOutput);
              switch (transformationOutput.type) {
                case "new":
                  {
                    const icTouchSlot = this.scopeObj.infiniteCanvas;

                    const rep_free__supervessel = infiniteCanvas.getSupervessel();

                    rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(icObj__untouched);

                    //remove old
                    {
                      // infiniteCanvas.removeIcObject(icObj__touched);
                      icObj__untouched.im_dying_now = true;
                    }

                    //add new

                    function addNew(icObj__new) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        icObj__new.parts.forEach((part, i) => {
                          part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      infiniteCanvas.addIcObject(icObj__new);

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new);

                    }

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      addNew(icObj__new);

                    } else if (transformationOutput.value instanceof Array) {

                      transformationOutput.value.forEach((icObj__new, i) => {
                        addNew(icObj__new);
                      });

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);
                    //old version
                    // const mutationObj = transformationFunc(icObj__touched);
                    const mutationObj = transformationOutput;

                    switch (transformationOutput.type) {
                      case "mathNode":
                        icObj__untouched.mathNode = mutationObj.mathNode;
                        break;
                      default:
                        // throw new Error("unsupported transformationOutput.type: " + transformationOutput.type);      //SHU: careful
                        Object.assign(icObj__touched, mutationObj);
                        break;
                    }
                  }
                  break;
                case "displaced":
                  {
                    logger.log("transformationOutput.type == displaced");
                  }
                  break;
                case "sadness":
                  {
                    icObj__untouched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;
                default:
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }


            }


            //debug
            {
              const rep_free__slot = infiniteCanvas.getRepresented(icObj_slot.id).r_free();
              rep_free__slot.fill = ColorUtils.randomColor();
            }



            rep_official.touchStateDict[icObj_slot.id] = TouchState.Untouched;
          };



          // this.r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
          this.r_official_update_handler = function (icObj_slot, icObj_piece, outerUpdatesDict) {

            // logger.log("r_official_update_handler", icObj_piece);

            const touchState = icObj_piece.touchStateDict[icObj_slot.id];
            // logger.log("touchState", touchState);

            if (touchState == TouchState.Untouched) {
              this.attemptTouching(icObj_slot, icObj_piece);
            } else if (touchState == TouchState.Touched) {
              this.attemptUntouching(icObj_slot, icObj_piece);
            }

          };

          this.isObjectIgnored = function (incomingObj) {  // Platform should override this function
            // to allow platform to transport intangible objects
            //ignore: incomingObj is intangible         //  while not allowing 'standard' dropTouchSlot to touch intangible objects
            return !incomingObj.isTouchable;
          };

          // this.r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
          this.r_official_update_handler2 = function (rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions

            // logger.log("r_official_update_handler2", rep_official_incoming, outerUpdatesDict);

            if (outerUpdatesDict.isHeld == null || outerUpdatesDict.isHeld.new == true) {    //this line filters out anything but drop, be it inside or outside
              return;
            } else {
              // logger.log("r_official_update_handler2", rep_official_incoming, outerUpdatesDict);
            }

            // console.log("engine::r_official_update_handler2, this", this);
            // console.log("this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            // console.log("infiniteCanvas", infiniteCanvas);
            const icTouchSlot = this.scopeObj.engineCarrier;

            const represented = infiniteCanvas.getRepresented(icTouchSlot.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const touchSlot = rep_official;
            const incomingObj = rep_official_incoming;

            if (incomingObj != touchSlot) { //don't touch oneself

              const isObjectIgnored_ = this.isObjectIgnored(incomingObj);
              if (!isObjectIgnored_) {
                this.r_official_update_handler(touchSlot, incomingObj, outerUpdatesDict);
              }

            } else {
              console.log("I won't touch myself");  //SHU: ...
            }

          };




          this.start = function () {
            console.log("engine::start, this", this);
            logger.log("dropTouchSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icTouchSlot = this.scopeObj.engineCarrier;


            infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);

            //for each existing canvas object, add touchState wrt this new touchSlot
            infiniteCanvas.onceOnAddRepresentedForIcObject(icTouchSlot, (icTouchSlot) => {

              const id_touchSlot = icTouchSlot.id;

              const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
              const arr_official_preexisiting = arr_official.filter(rep => (rep.id != id_touchSlot));
              arr_official_preexisiting.forEach((rep, i) => {

                rep.touchStateDict[id_touchSlot] = TouchState.Untouched;
                //SHU TODO: check if touches

              });

            });

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }




      class CoreEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          // this.checkCanTouch = function(icObj_slot, icObj_piece) {
          //   // logger.log("checkCanTouch", icObj_piece);
          //   var outBool;

          //   // outBool = Touch.canTouch(icObj_piece, icObj_slot);

          //   var canTouchFunc = this.scopeObj.engineCarrier.coreConfig.canTouchFunc;
          //   if(canTouchFunc == null) {

          //     // canTouchFunc = Touch.canTouch;

          //     // const infiniteCanvas = this.scopeObj.infiniteCanvas;
          //     // canTouchFunc = infiniteCanvas.touch2.canTouch;

          //     canTouchFunc = Touch2Singleton.sharedInstance().canTouch;
          //   }

          //   const context = this.scopeObj.engineCarrier.coreConfig.context;

          //   outBool = canTouchFunc(icObj_piece, icObj_slot, context);

          //   return outBool;
          // };


          this.adsorb = function (icObj_piece) {
            console.log("adsorb", icObj_piece);
            // console.log("adsorb", "this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icCore = this.scopeObj.engineCarrier;

            // const rep_free__piece = infiniteCanvas.getRepresented(icObj_piece.id).r_free();
            const rep_free__core = infiniteCanvas.getRepresented(icCore.id).r_free();

            //add to ghost
            rep_free__core.parts.ghost.dict_engine["composite"].engine.awoken.addPart(icObj_piece);

          };

          this.desorb = function (icObj_piece) {
            console.log("desorb", icObj_piece);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icCore = this.scopeObj.engineCarrier;

            // const rep_free__piece = infiniteCanvas.getRepresented(icObj_piece.id).r_free();
            const rep_free__core = infiniteCanvas.getRepresented(icCore.id).r_free();

            //remove from ghost
            rep_free__core.parts.ghost.dict_engine["composite"].engine.awoken.removePart(icObj_piece);
          };

          this.start = function () {
            console.log("CoreEngine::start, this", this);

            // logger.log("touchSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icCore = this.scopeObj.engineCarrier;
            const icTouchSlot = icCore.parts.touchSlot;

            const rep_free__touchSlot = infiniteCanvas.getRepresented(icTouchSlot.id).r_free();


            // const touchSlotEngine = icTouchSlot.dict_engine["touchSlot"].engine;
            const touchSlotEngine = icTouchSlot.dict_engine["touchSlot"].engine.awoken;


            const touchSlotConfig = {
              transformationFunc: function (icObj) {
                logger.log("icCore.touchSlot", "transformationFunc");

                const coreEngine = icCore.dict_engine["core"].engine.awoken;
                coreEngine.adsorb(icObj);

                return new TransformationOutput("mutated", icObj, icObj);
              },
            };

            rep_free__touchSlot.touchSlotConfig = touchSlotConfig;

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }








      class SnapSlotEngine {
        // constructor(touchSlotConfig) {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptSnapping = function (icObj_slot, icObj_piece) {
            console.log("attemptSnapping", icObj_slot, icObj_piece);

            const canSnap = this.checkCanSnap(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            console.log("attempting to snap with snapState: " + rep_official.snapState);

            // const isValidPieceSnapState = (rep_official.snapState == SnapState.Unsnapped);
            //
            // if(isValidPieceSnapState) {
            //
            // } else {
            //   console.log("can't snap while snapState == " + rep_official.snapState)
            //   // throw new Error("attempting to snap with snapState: " + rep_official.snapState);
            //   return;
            // }

            if (canSnap) {
              console.log("can snap");

              const rep_official = icObj_piece;
              const represented = icObj_piece.represented;
              const rep_free = represented.getRepresentation("free");

              console.log("rep_free.isHeld", rep_free.isHeld);
              if (rep_free.isHeld) {
                this.presnap(icObj_slot, icObj_piece);
              } else {
                this.presnap(icObj_slot, icObj_piece);
                this.snap(icObj_slot, icObj_piece);
              }

            } else {
              console.log("can't snap");
            }

          };


          this.checkCanSnap = function (icObj_slot, icObj_piece) {
            console.log("checkCanSnap", icObj_piece);
            var outBool;

            const icSnapSlot = this.scopeObj.engineCarrier;
            const canSnapFunc = icSnapSlot.snapSlotConfig.canSnapFunc;

            outBool = canSnapFunc(icObj_piece, icObj_slot);

            return outBool;
          };

          var rep_free_onRelease__triggerSnap = null;
          var rep_free_afterPresnap__attemptUnsnapping = null;

          var rep_free_callbacks = {
            onRelease__triggerSnap: null,
            afterPresnap__attemptUnsnapping: null,
          };


          this.presnap = function (icObj_slot, icObj_piece) {
            console.log("presnap", icObj_piece);

            const rep_official = icObj_piece;
            const represented = icObj_piece.represented;
            const rep_free = represented.getRepresentation("free");
            const rep_snapped = represented.createNewRepresentation("snapped");

            rep_official.snapState = SnapState.Presnapped;
            // rep_official.snappedTo = icObj_slot;
            rep_official.snappedTo = icObj_slot.id;


            rep_official.unfollow(rep_free);


            rep_snapped.position = Object.assign({}, icObj_slot.position);
            rep_snapped.homeScale = Object.assign({}, icObj_slot.homeScale);
            rep_snapped.scale = Object.assign({}, icObj_slot.scale);
            rep_snapped.orientation = icObj_slot.orientation;

            rep_snapped.opacity = 0.8;


            //debug
            // rep_snapped.text = "rep_snapped__snapped";

            infiniteCanvas.addRepresentation(represented, rep_snapped);


            // rep_official.syncWith(rep_snapped);
            rep_official.syncWithObj({
              position: rep_snapped.position,
              size: rep_snapped.size,
              homeScale: rep_snapped.homeScale,
              scale: rep_snapped.scale,

              // didUpdateListeners : rep_snapped.didUpdateListeners,
              // holdListeners      : rep_snapped.holdListeners,
              // releaseListeners   : rep_snapped.releaseListeners,
            });
            rep_official.follow(rep_snapped);


            rep_free.opacity = 0.2;
            //debug
            // rep_free.opacity = 1.0;
            // rep_free.fill = "blue";
            // rep_free.text = "rep_free__presnapped";


            //add release listener
            // icObj_fRep.onHold((icObj) => {
            //
            // });

            //add release listener for rep_free
            rep_free_onRelease__triggerSnap = (rep_free) => {
              console.log("rep_free_onRelease__triggerSnap");

              this.snap(icObj_slot, icObj_piece);
            };
            rep_free.onRelease(rep_free_onRelease__triggerSnap);


            //add unsnap listener for rep_free
            rep_free_afterPresnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
              console.log("rep_free_afterPresnap__attemptUnsnapping", rep_free);

              this.attemptUnsnapping(icObj_slot, rep_free);
            };
            rep_free.onInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);

          };


          this.snap = function (icObj_slot, icObj_piece) {
            console.log("snap", icObj_piece);

            const rep_official = icObj_piece;
            const represented = icObj_piece.represented;
            const rep_free = represented.getRepresentation("free");
            const rep_snapped = represented.getRepresentation("snapped");

            console.log("**snap", "rep_free.isHeld", rep_free.isHeld);

            console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
            if (rep_free_afterPresnap__attemptUnsnapping != null) {
              rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
            }
            rep_free_afterPresnap__attemptUnsnapping = null;


            rep_free.offRelease(rep_free_onRelease__triggerSnap);
            rep_free_onRelease__triggerSnap = null;



            // rep_free.syncWith(rep_snapped);
            // rep_free.syncWith(rep_official);

            //SHU TODO: MYSTERE ET BOULE DE GOMME: il y a un truc avec syncWith qui casse rep_free ... ???

            rep_free.syncWithObj({
              position: rep_snapped.position,
              size: rep_snapped.size,
              homeScale: rep_snapped.homeScale,
              scale: rep_snapped.scale,

              // didUpdateListeners : rep_snapped.didUpdateListeners,
              // holdListeners      : rep_snapped.holdListeners,
              // releaseListeners   : rep_snapped.releaseListeners,
            });



            rep_free.opacity = 1.0;
            //debug
            // rep_free.opacity = 1.0;
            // rep_free.fill = "red";
            // rep_free.text = "rep_free__snapped";

            rep_official.unfollow(rep_snapped);
            rep_official.follow(rep_free);
            rep_official.snapState = SnapState.Snapped;
            // rep_official.snappedTo = icObj_slot;
            // rep_official.snappedTo = icObj_slot.id;



            console.log("remove rep_snapped", rep_snapped.id_rep);
            rep_snapped.im_dying_now = true;
            infiniteCanvas.removeRepresentation(represented, rep_snapped);
            represented.removeRepresentation(rep_snapped);

            //add unsnap listener for rep_free
            // rep_free_afterSnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
            //   console.log("rep_free_afterSnap__attemptUnsnapping", rep_free);
            //
            //   attemptUnsnapping(icObj_slot, rep_free);
            // };
            // rep_free.onInnerUpdate(rep_free_afterSnap__attemptUnsnapping);


            //debug
            // rep_free.onHold((rep_free) => {
            //   console.log("###rep_free.id_rep", rep_free.id_rep);
            //   console.log("###rep_free.onHold", "rep_free.isHeld", rep_free.isHeld);
            // });

          };





          this.attemptUnsnapping = function (icObj_slot, icObj_piece) {
            console.log("attemptUnsnapping", icObj_slot, icObj_piece);

            const canUnsnap = this.checkCanUnsnap(icObj_slot, icObj_piece);
            console.log("canUnsnap", canUnsnap);

            const rep_official = icObj_piece;
            console.log("attempting to unsnap with snapState: " + rep_official.snapState);

            // const isValidPieceSnapState = (rep_official.snapState == SnapState.Presnapped);
            //
            // if(isValidPieceSnapState) {
            //
            // } else {
            //   console.log("can't unsnap while snapState == " + rep_official.snapState)
            //   // throw new Error("attempting to unsnap with snapState: " + rep_official.snapState);
            //   return;
            // }

            if (canUnsnap) {
              // console.log("can unsnap");
              this.unsnap(icObj_slot, icObj_piece);     //presnap already sets up an unsnap listener

            } else {
              // console.log("can't unsnap");

              //SHU TODO: hasLeftSlot
              // const hasLeftSlot = Snap.hasLeftSlot()
              const hasLeftSlot = true;

              if (hasLeftSlot) {


                // const rep_official = icObj_piece;
                const represented = icObj_piece.represented;
                const rep_free = represented.getRepresentation("free");

                console.log("#rep_free.id_rep", rep_free.id_rep);
                console.log("#rep_free.isHeld", rep_free.isHeld);

                if (rep_free.isHeld) {
                  if (icObj_piece.snapState == SnapState.Snapped) {
                    this.presnap(icObj_slot, icObj_piece);
                  }
                } else {
                  //do nothing
                  // snap(icObj_slot, icObj_piece);
                }

              } else {
                //do nothing
                // snap(icObj_slot, icObj_piece);
              }



            }

          };

          this.checkCanUnsnap = function (icObj_slot, icObj_piece) {
            console.log("checkCanUnsnap", icObj_piece);
            var outBool;

            const icSnapSlot = this.scopeObj.engineCarrier;
            const canUnsnapFunc = icSnapSlot.snapSlotConfig.canUnsnapFunc;

            outBool = canUnsnapFunc(icObj_piece, icObj_slot);

            return outBool;
          };


          this.unsnap = function (icObj_slot, icObj_piece) {
            console.log("unsnap", icObj_piece);

            // const represented  = icObj_piece.represented;
            // const rep_official = represented.getRepresentation("official");
            // const rep_snapped  = represented.getRepresentation("snapped");

            const rep_unknown = icObj_piece; //SHU TODO: solve snapSlot's rep madness
            const represented = icObj_piece.represented;
            const rep_official = represented.getRepresentation("official");
            const rep_free = represented.getRepresentation("free");
            const rep_snapped = represented.getRepresentation("snapped");


            console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
            if (rep_free_afterPresnap__attemptUnsnapping != null) {
              rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
            }
            rep_free_afterPresnap__attemptUnsnapping = null;

            // if(rep_free_afterSnap__attemptUnsnapping != null) {
            //   rep_free.offInnerUpdate(rep_free_afterSnap__attemptUnsnapping);
            // }
            // rep_free_afterSnap__attemptUnsnapping = null;


            // rep_free.offRelease(rep_free_onRelease__triggerSnap);
            // rep_free_onRelease__triggerSnap = null;

            if (rep_free.offRelease != null) { //****************************************  SHU: il y a un problème ici, quand j'aurai trois neurones de disponibles, j'investiguerai
              rep_free.offRelease(rep_free_onRelease__triggerSnap);
              rep_free_onRelease__triggerSnap = null;
            }                                 //****************************************


            rep_official.syncWith(rep_free);
            rep_official.follow(rep_free);


            if (rep_snapped != null) {
              console.log("remove rep_snapped", rep_snapped.id_rep);
              rep_snapped.im_dying_now = true;
              infiniteCanvas.removeRepresentation(represented, rep_snapped);
              represented.removeRepresentation(rep_snapped);
            } else {
              console.log("rep_snapped already destroyed somewhere else");
            }


            // rep_free.im_dying_now = true; //SHU: this is interesting

            /*
            rep_free.opacity = 1.0;
              //debug
              // rep_free.fill = "lime";
              // rep_free.text = "rep_free__unsnapped";
              // setTimeout(() => {
              //   rep_free.fill = "lime";
              //   rep_free.text = "rep_free__unsnapped";
              // }, 0);
            */

            setTimeout(() => {                  //SHU: looks like setTimeout is needed here
              rep_free.opacity = 1.0;

              rep_official.snapState = SnapState.Unsnapped;
              // rep_official.snappedTo = null;
              rep_official.snappedTo = -1;
            }, 0);

          };






          this.r_official_update_handler = function (icObj_slot, icObj_piece, outerUpdatesDict) {
            console.log("r_official_update_handler", icObj_piece);

            console.log("icObj_piece.snapState", icObj_piece.snapState);

            // if(outerUpdatesDict["snapState"] == SnapState.Snapped) {
            //   //official just changed snapState to .Snapped
            //   //ignore
            //   return;
            // }

            if (icObj_piece.snapState == SnapState.Unsnapped) {
              this.attemptSnapping(icObj_slot, icObj_piece);
            } else if (icObj_piece.snapState == SnapState.Snapped) {
              this.attemptUnsnapping(icObj_slot, icObj_piece);               //SHU666666 : this is the key line to understand what is wrong
            } else if (icObj_piece.snapState == SnapState.Presnapped) {

            }

          };

          this.r_official_update_handler2 = function (rep_official_incoming, outerUpdatesDict) {
            // console.log("r_official_update_handler2", rep_official_incoming);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icSnapSlot = this.scopeObj.engineCarrier;

            const represented = infiniteCanvas.getRepresented(icSnapSlot.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const snapSlot = rep_official;
            const incomingObj = rep_official_incoming;

            if (incomingObj != snapSlot) { //don't snap oneself

              if (!incomingObj.isSnappable) {
                //ignore: incomingObj is diamagnetic
              } else {
                console.log("++++incomingObj.snappedTo", incomingObj.snappedTo);
                // if(incomingObj.snappedTo != null && incomingObj.snappedTo != snapSlot) {
                if (incomingObj.snappedTo != -1 && incomingObj.snappedTo != snapSlot.id) {
                  //ignore: incomingObj is already snapped to another slot
                } else {
                  this.r_official_update_handler(snapSlot, incomingObj, outerUpdatesDict);
                }
              }

            } else {
              console.log("I won't snap myself");
            }

          };




          this.start = function () {
            console.log("engine::start, this", this);
            console.log("snapSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icSnapSlot = this.scopeObj.engineCarrier;

            infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);
          };

          this.stop = function () {
            //SHU TODO: infiniteCanvas.offIcObjUpdate when snap slot is destroyed
          };



          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }


      class CompositeEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          };


          this.createHandleListener = function () {
            const handle__listener = (representation, propName, oldValue, newValue) => {
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.manageHandleUpdate(representation, updatesDict);
            };

            return handle__listener;
          };




          // this.counter__partListeners = 0;
          this.createPartListener = function () {

            // const index__partListener = this.counter__partListeners;

            const part__listener = (representation, propName, oldValue, newValue) => {
              // logger.log("partListener", index__partListener);
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.managePartUpdate(representation, updatesDict);
            };

            // this.counter__partListeners += 1;

            return part__listener;
          };



          this.createListeners = function () {
            var outListenersDict = {};

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;


            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();



            const handle__listener = this.createHandleListener();

            // outListenersDict["handle"] = handle__listener;
            outListenersDict[handle.id] = handle__listener;

            const parts = handle__rep_free.parts;
            const part_listeners = Object.entries(parts).reduce((acc, [partName, part__rep_free]) => {

              const part__listener = this.createPartListener();

              // acc[partName] = part__listener;
              acc[part__rep_free.id] = part__listener;

              return acc;
            }, {});

            Object.assign(outListenersDict, part_listeners);

            return outListenersDict;
          };




          this.getArr_everyone = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;


            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            const parts = handle__rep_free.parts;

            return [handle__rep_free] + Object.values(parts);
          };

          this.getArr_everyoneBut = function (rep) {
            const arr_everyoneElse = this.getArr_everyone().filter(rep => rep.id != solo_rep.id);
            return arr_everyoneElse;
          };

          this.onEveryoneBut = function (solo_rep) {
            const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = this.listeners[rep.id];
              rep.onInnerUpdate(listener);
            });
          };

          this.offEveryoneBut = function (rep) {
            const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = this.listeners[rep.id];
              rep.offInnerUpdate(listener);
            });
          };

          //part update
          this.managePartUpdate = function (icObj_compositePart, outerUpdatesDict) {

            //SHU FLUID

            logger.log("managePartUpdate", icObj_compositePart);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            const compositeConfig = handle.compositeConfig;
            console.log("compositeConfig", compositeConfig);
            const id__compositePart = icObj_compositePart.id;
            console.log("id__compositePart", id__compositePart);

            const isMobile = compositeConfig[id__compositePart].isMobile;

            if (isMobile) {
              //ignore
            } else {

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free = handle__represented.r_free();

              // const part__represented   = infiniteCanvas.getRepresented(icObj_compositePart.id);

              // rep_free__composite.composite.managePartUpdate(rep_free__compositePart, outerUpdatesDict);
              if ( (outerUpdatesDict.position != null) || (outerUpdatesDict.point_start != null) ) {

                var offset;
                if(outerUpdatesDict.position != null) {
                  offset = {
                    dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                    dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
                  };
                } else {
                  //moved part was segment
                  offset = {
                    dx: outerUpdatesDict.point_start.new.x - outerUpdatesDict.point_start.old.x,
                    dy: outerUpdatesDict.point_start.new.y - outerUpdatesDict.point_start.old.y,
                  };
                }

                const parts = handle__rep_free.parts;

                const arr_parts_all = Object.values(parts);
                const arr_parts_other = arr_parts_all.filter(part => part.id != icObj_compositePart.id);

                const arr_handle_and_other = [handle__rep_free, ...arr_parts_other];

                // arr_parts_other.forEach((rep_free, i) => {
                arr_handle_and_other.forEach((rep_free, i) => {

                  const listener = this.listeners[rep_free.id];
                  // console.log("°°°listener", listener);

                  //listen:off
                  rep_free.offInnerUpdate(listener);

                  //mutate
                  // logger.log("mutating part:", rep_free.id);
                  {
                    if(rep_free.position != null) {
                      const position_new = {
                        x: rep_free.position.x + offset.dx,
                        y: rep_free.position.y + offset.dy,
                      };

                      rep_free.position = position_new;
                    } else if(rep_free.point_start != null) {
                      //move other segment parts
                      const point_start_new = {
                        x: rep_free.point_start.x + offset.dx,
                        y: rep_free.point_start.y + offset.dy,
                      };
                      rep_free.point_start = point_start_new;
                      const point_end_new = {
                        x: rep_free.point_end.x + offset.dx,
                        y: rep_free.point_end.y + offset.dy,
                      };
                      rep_free.point_end = point_end_new;
                    }
                  }

                  //listen:on
                  rep_free.onInnerUpdate(listener);

                });


                //   {
                //     const rep_free = handle__rep_free;
                //
                //     //listen:off
                //     rep_free.offInnerUpdate(listener);
                //
                //     //mutate
                //     {
                //       const position_new = {
                //         x: rep_free.position.x + offset.dx,
                //         y: rep_free.position.y + offset.dy,
                //       };
                //
                //       rep_free.position = position_new;
                //     }
                //
                //     //listen:on
                //     rep_free.onInnerUpdate(listener);
                //   }


              }

            }

          };

          //handle update
          this.manageHandleUpdate = function (icObj_composite, outerUpdatesDict) {
            console.log("manageHandleUpdate", icObj_composite);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(icObj_composite.id);
            const handle__rep_free = handle__represented.r_free();

            if (outerUpdatesDict.position != null) {

              const offset = {
                dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
              };

              const parts = handle__rep_free.parts;
              const arr_parts_all = Object.values(parts);
              arr_parts_all.forEach((part__rep_free, i) => {

                const listener = this.listeners[part__rep_free.id];

                //listen:off
                part__rep_free.offInnerUpdate(listener);


                //mutate
                // logger.log("mutating part:", part__rep_free.id);
                {
                    if(part__rep_free.position != null) {
                      const position_new = {
                        x: part__rep_free.position.x + offset.dx,
                        y: part__rep_free.position.y + offset.dy,
                      };

                      part__rep_free.position = position_new;
                    } else if(part__rep_free.point_start != null) {
                      //move segment parts
                      const point_start_new = {
                        x: part__rep_free.point_start.x + offset.dx,
                        y: part__rep_free.point_start.y + offset.dy,
                      };
                      part__rep_free.point_start = point_start_new;
                      const point_end_new = {
                        x: part__rep_free.point_end.x + offset.dx,
                        y: part__rep_free.point_end.y + offset.dy,
                      };
                      part__rep_free.point_end = point_end_new;
                    }
                  }

                //listen:on
                part__rep_free.onInnerUpdate(listener);

              });

            }
            // else if(outerUpdatesDict.parts != null) {
            //   logger.log("outerUpdatesDict.parts", outerUpdatesDict.parts);
            //
            //   // const arr_parts__old = [];
            //   // const arr_parts__new = [];
            //
            //   Object.values(outerUpdatesDict.parts.new).forEach((part__rep_free, i) => {
            //     const part__listener = this.createPartListener();
            //     this.listeners[part__rep_free.id] = part__listener;
            //
            //     if(handle__rep_free.compositeConfig[part__rep_free.id] == null) {
            //       const config__part = {
            //         // isMobile: true,
            //         isMobile: false,
            //       };
            //       handle__rep_free.compositeConfig[part__rep_free.id] = config__part;
            //     }
            //
            //     //'activate' listener
            //     // const part__listener = this.listeners[part__rep_free.id];
            //     part__rep_free.onInnerUpdate(part__listener);
            //
            //   });
            //
            // }

          };


          this.addPart = function (part__rep_free, isMobile = true) {
            // this.addPart = function(part, config__part) {
            // logger.log("addPart", this, part__rep_free);

            //get free_rep
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            //add part to .parts
            const miniDict = {
              [part__rep_free.id]: part__rep_free,
            };

            handle__rep_free.parts = Object.assign({}, handle__rep_free.parts, miniDict);
            // // // Object.assign(handle__rep_free.parts, miniDict);
            // // //handle__rep_free.parts[part.id] = part;

            //add partConfig
            const config__part = {
              // isMobile: true,
              isMobile: isMobile,
            };
            handle__rep_free.compositeConfig[part__rep_free.id] = config__part;

            //parent
            part__rep_free.isCompositePart = true;
            part__rep_free.compositeId = handle.id;

            //setup listener
            //create
            const part__listener = this.createPartListener();
            //store
            this.listeners[part__rep_free.id] = part__listener;
            //activate
            part__rep_free.onInnerUpdate(part__listener);

          };

          this.removePart = function (part__rep_free) {
            // logger.log("removePart", this, part__rep_free);

            //get free_rep
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            //deactivate listener
            //retrieve
            const part__listener = this.listeners[part__rep_free.id];
            //deactivate
            part__rep_free.offInnerUpdate(part__listener);
            delete this.listeners[part__rep_free.id];

            //unparent
            part__rep_free.compositeId = -1;
            part__rep_free.isCompositePart = false;

            //remove part from .parts
            // logger.log(handle__rep_free.parts", handle__rep_free.parts);
            //get key
            const key__part = Object.keys(handle__rep_free.parts).find(key => (handle__rep_free.parts[key] == part__rep_free));
            //update parts dict
            // delete handle__rep_free.parts[key__part];
            const parts__updated = Object.assign({}, handle__rep_free.parts);
            delete parts__updated[key__part];
            handle__rep_free.parts = parts__updated;


            //remove partConfig
            delete handle__rep_free.compositeConfig[part__rep_free.id];

          };




          this.start = function () {
            console.log("CompositeEngine::start, this", this);
            console.log("CompositeEngine::start", "this.scopeObj", this.scopeObj);

            this.listeners = this.createListeners();

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            console.log("CompositeEngine.start", handle.id);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            //listen to handle
            const handle__listener = this.listeners[handle.id];
            handle__rep_free.onInnerUpdate(handle__listener);

            //listen to parts
            const parts = handle__rep_free.parts;
            const arr_parts_all = Object.values(parts);
            arr_parts_all.forEach((part__rep_free, i) => {
              logger.log("part__rep_free", part__rep_free);

              //set compositeId if not done yet         //SHU: horror
              part__rep_free.compositeId = handle__rep_free.id;

              //'activate' listeners
              logger.log("this.listeners", this.listeners);
              const part__listener = this.listeners[part__rep_free.id];
              part__rep_free.onInnerUpdate(part__listener);
            });


            //debug (~tests)
            // setTimeout(() => {
            //   console.log("ççç setTimeout handle__rep_free.id_rep", handle__rep_free.id_rep);
            //
            //   handle__rep_free.position = {
            //     x: handle__rep_free.position.x + 200,
            //     y: handle__rep_free.position.y - 50,
            //   };
            // }, 3000);
            //
            // setTimeout(() => {
            //   const part1 = arr_parts_all[0];
            //   part1.position = {
            //     x: part1.position.x - 200,
            //     y: part1.position.y - 100,
            //   };
            // }, 6000);
            //
            // setTimeout(() => {
            //   const part3 = arr_parts_all[2];
            //   part3.position = {
            //     x: part3.position.x + 150,
            //     y: part3.position.y + 100,
            //   };
            // }, 9000);
          };

          this.stop = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            console.log("compositeEngine.stop", handle);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            const handle__listener = this.listeners[handle.id];
            handle__rep_free.offInnerUpdate(handle__listener);

            const parts = handle__rep_free.parts;
            const arr_parts_all = Object.values(parts);
            arr_parts_all.forEach((part__rep_free, i) => {

              // const part__listener = this.listeners[part__rep_free.id];
              // part__rep_free.offInnerUpdate(part__listener);

              this.removePart(part__rep_free);
            });

          };



          this.virgin = Object.assign({}, this);  //virgin == not bound


        }

      }


      class Compositer {

        // static createPart(icObj, isMobile = true) {
        //   var outPart;
        //
        //   outPart = new CompositePart(icObj, isMobile);
        //
        //   return outPart;
        // }

        static defaultCompositeConfig(parts, isMobile = true) {
          var outConfig;

          outConfig = Object.entries(parts).reduce((acc, [partName, part], index) => {
            // const isMobile = true;

            // acc[partName] = {
            acc[part.id] = {
              isMobile: isMobile,
            };

            return acc;
          }, {});

          return outConfig;
        }

      }


      // class CompositePart {
      //   constructor(icObj, isMobile) {
      //
      //     this.icObj    = icObj;
      //     this.isMobile = isMobile;
      //
      //   }
      // }


      class PlatformEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          };


          this.createHandleListener = function () {
            const handle__listener = (representation, propName, oldValue, newValue) => {
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.manageHandleUpdate(representation, updatesDict);
            };

            return handle__listener;
          };

          this.createPartListener = function () {
            const part__listener = (representation, propName, oldValue, newValue) => {
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.managePartUpdate(representation, updatesDict);
            };

            return part__listener;
          };



          this.createListeners = function () {
            var outListenersDict = {};

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;


            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();



            const handle__listener = this.createHandleListener();

            // outListenersDict["handle"] = handle__listener;
            outListenersDict[handle.id] = handle__listener;

            const parts = handle__rep_free.parts;
            const part_listeners = Object.entries(parts).reduce((acc, [partName, part__rep_free]) => {

              const part__listener = this.createPartListener();

              // acc[partName] = part__listener;
              acc[part__rep_free.id] = part__listener;

              return acc;
            }, {});

            Object.assign(outListenersDict, part_listeners);

            return outListenersDict;
          };




          this.getArr_everyone = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;


            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            const parts = handle__rep_free.parts;

            return [handle__rep_free] + Object.values(parts);
          };

          this.getArr_everyoneBut = function (rep) {
            const arr_everyoneElse = this.getArr_everyone().filter(rep => rep.id != solo_rep.id);
            return arr_everyoneElse;
          };

          this.onEveryoneBut = function (solo_rep) {
            const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = this.listeners[rep.id];
              rep.onInnerUpdate(listener);
            });
          };

          this.offEveryoneBut = function (rep) {
            const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = this.listeners[rep.id];
              rep.offInnerUpdate(listener);
            });
          };

          //part update
          this.managePartUpdate = function (icObj_compositePart, outerUpdatesDict) {
            logger.log("managePartUpdate", icObj_compositePart);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            const compositeConfig = handle.compositeConfig;
            console.log("compositeConfig", compositeConfig);
            const id__compositePart = icObj_compositePart.id;
            console.log("id__compositePart", id__compositePart);

            const isMobile = compositeConfig[id__compositePart].isMobile;

            if (isMobile) {
              //ignore
            } else {

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free = handle__represented.r_free();

              // const part__represented   = infiniteCanvas.getRepresented(icObj_compositePart.id);

              // rep_free__composite.composite.managePartUpdate(rep_free__compositePart, outerUpdatesDict);
              if (outerUpdatesDict.position != null) {

                const offset = {
                  dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                  dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
                };

                const parts = handle__rep_free.parts;

                const arr_parts_all = Object.values(parts);
                const arr_parts_other = arr_parts_all.filter(part => part.id != icObj_compositePart.id);

                const arr_handle_and_other = [handle__rep_free, ...arr_parts_other];

                // arr_parts_other.forEach((rep_free, i) => {
                arr_handle_and_other.forEach((rep_free, i) => {

                  const listener = this.listeners[rep_free.id];
                  // console.log("°°°listener", listener);

                  //listen:off
                  rep_free.offInnerUpdate(listener);

                  //mutate
                  // logger.log("mutating part:", rep_free.id);
                  {
                    const position_new = {
                      x: rep_free.position.x + offset.dx,
                      y: rep_free.position.y + offset.dy,
                    };

                    rep_free.position = position_new;
                  }

                  //listen:on
                  rep_free.onInnerUpdate(listener);

                });


                //   {
                //     const rep_free = handle__rep_free;
                //
                //     //listen:off
                //     rep_free.offInnerUpdate(listener);
                //
                //     //mutate
                //     {
                //       const position_new = {
                //         x: rep_free.position.x + offset.dx,
                //         y: rep_free.position.y + offset.dy,
                //       };
                //
                //       rep_free.position = position_new;
                //     }
                //
                //     //listen:on
                //     rep_free.onInnerUpdate(listener);
                //   }


              }

            }

          };

          //handle update
          this.manageHandleUpdate = function (icObj_composite, outerUpdatesDict) {
            console.log("manageHandleUpdate", icObj_composite);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(icObj_composite.id);
            const handle__rep_free = handle__represented.r_free();

            if (outerUpdatesDict.position != null) {

              const offset = {
                dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
              };

              const parts = handle__rep_free.parts;
              const arr_parts_all = Object.values(parts);
              arr_parts_all.forEach((part__rep_free, i) => {

                const listener = this.listeners[part__rep_free.id];

                //listen:off
                part__rep_free.offInnerUpdate(listener);


                //mutate
                // logger.log("mutating part:", part__rep_free.id);
                {
                  const position_new = {
                    x: part__rep_free.position.x + offset.dx,
                    y: part__rep_free.position.y + offset.dy,
                  };

                  part__rep_free.position = position_new;
                }

                //listen:on
                part__rep_free.onInnerUpdate(listener);

              });

            }
            // else if(outerUpdatesDict.parts != null) {
            //   logger.log("outerUpdatesDict.parts", outerUpdatesDict.parts);
            //
            //   // const arr_parts__old = [];
            //   // const arr_parts__new = [];
            //
            //   Object.values(outerUpdatesDict.parts.new).forEach((part__rep_free, i) => {
            //     const part__listener = this.createPartListener();
            //     this.listeners[part__rep_free.id] = part__listener;
            //
            //     if(handle__rep_free.compositeConfig[part__rep_free.id] == null) {
            //       const config__part = {
            //         // isMobile: true,
            //         isMobile: false,
            //       };
            //       handle__rep_free.compositeConfig[part__rep_free.id] = config__part;
            //     }
            //
            //     //'activate' listener
            //     // const part__listener = this.listeners[part__rep_free.id];
            //     part__rep_free.onInnerUpdate(part__listener);
            //
            //   });
            //
            // }

          };


          this.addPart = function (part__rep_free, isMobile = true) {
            // this.addPart = function(part, config__part) {
            // logger.log("addPart", this, part__rep_free);

            //get free_rep
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            //add part to .parts
            const miniDict = {
              [part__rep_free.id]: part__rep_free,
            };

            handle__rep_free.parts = Object.assign({}, handle__rep_free.parts, miniDict);
            // // // Object.assign(handle__rep_free.parts, miniDict);
            // // //handle__rep_free.parts[part.id] = part;

            //add partConfig
            const config__part = {
              // isMobile: true,
              isMobile: isMobile,
            };
            handle__rep_free.compositeConfig[part__rep_free.id] = config__part;

            //setup listener
            //create
            const part__listener = this.createPartListener();
            //store
            this.listeners[part__rep_free.id] = part__listener;
            //activate
            part__rep_free.onInnerUpdate(part__listener);

          };

          this.removePart = function (part__rep_free) {
            // logger.log("removePart", this, part__rep_free);

            //get free_rep
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            //deactivate listener
            //retrieve
            const part__listener = this.listeners[part__rep_free.id];
            //deactivate
            part__rep_free.offInnerUpdate(part__listener);
            delete this.listeners[part__rep_free.id];

            //remove part from .parts
            const parts__updated = Object.assign({}, handle__rep_free.parts);
            delete parts__updated[part__rep_free.id];
            handle__rep_free.parts = parts__updated;

            //remove partConfig
            delete handle__rep_free.compositeConfig[part__rep_free.id];

          };




          this.start = function () {
            console.log("engine::start, this", this);
            console.log("compositeEngine::start", "this.scopeObj", this.scopeObj);

            this.listeners = this.createListeners();

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            console.log("compositeEngine.start", handle.id);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();


            //listen to handle
            const handle__listener = this.listeners[handle.id];
            handle__rep_free.onInnerUpdate(handle__listener);

            //listen to parts
            const parts = handle__rep_free.parts;
            const arr_parts_all = Object.values(parts);
            arr_parts_all.forEach((part__rep_free, i) => {

              //'activate' listeners
              const part__listener = this.listeners[part__rep_free.id];
              part__rep_free.onInnerUpdate(part__listener);
            });


            //debug (~tests)
            // setTimeout(() => {
            //   console.log("ççç setTimeout handle__rep_free.id_rep", handle__rep_free.id_rep);
            //
            //   handle__rep_free.position = {
            //     x: handle__rep_free.position.x + 200,
            //     y: handle__rep_free.position.y - 50,
            //   };
            // }, 3000);
            //
            // setTimeout(() => {
            //   const part1 = arr_parts_all[0];
            //   part1.position = {
            //     x: part1.position.x - 200,
            //     y: part1.position.y - 100,
            //   };
            // }, 6000);
            //
            // setTimeout(() => {
            //   const part3 = arr_parts_all[2];
            //   part3.position = {
            //     x: part3.position.x + 150,
            //     y: part3.position.y + 100,
            //   };
            // }, 9000);
          };

          this.stop = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            console.log("compositeEngine.stop", handle);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            const handle__listener = this.listeners[handle.id];
            handle__rep_free.offInnerUpdate(handle__listener);

            const parts = handle__rep_free.parts;
            const arr_parts_all = Object.values(parts);
            arr_parts_all.forEach((part__rep_free, i) => {

              const part__listener = this.listeners[part__rep_free.id];
              part__rep_free.offInnerUpdate(part__listener);
            });

          };



          this.virgin = Object.assign({}, this);  //virgin == not bound


        }

      }



      class LinkEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          };


          // this.createLinkListener = function() {
          //   const link__listener = (representation, propName, oldValue, newValue) => {
          //     const updatesDict = {
          //       [propName]: {
          //         old: oldValue,
          //         new: newValue,
          //       },
          //     };
          //     this.manageLinkUpdate(representation, updatesDict);
          //   };
          //
          //   return link__listener;
          // };

          this.createPartListener = function () {
            const part__listener = (representation, propName, oldValue, newValue) => {
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.managePartUpdate(representation, updatesDict);
            };

            return part__listener;
          };



          this.createListeners = function () {
            var outListenersDict = {};

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const link = this.scopeObj.engineCarrier;


            //get free_rep
            const link__represented = infiniteCanvas.getRepresented(link.id);
            const link__rep_free = link__represented.r_free();

            // const link__listener = this.createLinkListener();
            // outListenersDict[link.id] = link__listener;

            const parts = link__rep_free.parts;
            const part_listeners = Object.entries(parts).reduce((acc, [partName, part__rep_free]) => {

              const part__listener = this.createPartListener();

              // acc[partName] = part__listener;
              acc[part__rep_free.id] = part__listener;

              return acc;
            }, {});

            Object.assign(outListenersDict, part_listeners);

            return outListenersDict;
          };




          this.getArr_everyone = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const link = this.scopeObj.engineCarrier;


            //get free_rep
            const link__represented = infiniteCanvas.getRepresented(link.id);
            const link__rep_free = link__represented.r_free();

            const parts = link__rep_free.parts;

            return [link__rep_free] + Object.values(parts);
          };

          this.getArr_everyoneBut = function (solo_rep) {
            const arr_everyoneElse = this.getArr_everyone().filter(rep => rep.id != solo_rep.id);
            return arr_everyoneElse;
          };

          this.onEveryoneBut = function (solo_rep) {
            const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = this.listeners[rep.id];
              rep.onInnerUpdate(listener);
            });
          };

          this.offEveryoneBut = function (rep) {
            const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = this.listeners[rep.id];
              rep.offInnerUpdate(listener);
            });
          };

          //part update
          this.managePartUpdate = function (icObj_compositePart, outerUpdatesDict) {
            logger.log("managePartUpdate", icObj_compositePart);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const link = this.scopeObj.engineCarrier;

            const compositeConfig = handle.compositeConfig;
            console.log("compositeConfig", compositeConfig);
            const id__compositePart = icObj_compositePart.id;
            console.log("id__compositePart", id__compositePart);

            const isMobile = compositeConfig[id__compositePart].isMobile;

            if (isMobile) {
              //ignore
            } else {

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free = handle__represented.r_free();

              // const part__represented   = infiniteCanvas.getRepresented(icObj_compositePart.id);

              // rep_free__composite.composite.managePartUpdate(rep_free__compositePart, outerUpdatesDict);
              if (outerUpdatesDict.position != null) {

                const offset = {
                  dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                  dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
                };

                const parts = handle__rep_free.parts;

                const arr_parts_all = Object.values(parts);
                const arr_parts_other = arr_parts_all.filter(part => part.id != icObj_compositePart.id);

                const arr_handle_and_other = [handle__rep_free, ...arr_parts_other];

                // arr_parts_other.forEach((rep_free, i) => {
                arr_handle_and_other.forEach((rep_free, i) => {

                  const listener = this.listeners[rep_free.id];
                  // console.log("°°°listener", listener);

                  //listen:off
                  rep_free.offInnerUpdate(listener);

                  //mutate
                  // logger.log("mutating part:", rep_free.id);
                  {
                    const position_new = {
                      x: rep_free.position.x + offset.dx,
                      y: rep_free.position.y + offset.dy,
                    };

                    rep_free.position = position_new;
                  }

                  //listen:on
                  rep_free.onInnerUpdate(listener);

                });


                //   {
                //     const rep_free = handle__rep_free;
                //
                //     //listen:off
                //     rep_free.offInnerUpdate(listener);
                //
                //     //mutate
                //     {
                //       const position_new = {
                //         x: rep_free.position.x + offset.dx,
                //         y: rep_free.position.y + offset.dy,
                //       };
                //
                //       rep_free.position = position_new;
                //     }
                //
                //     //listen:on
                //     rep_free.onInnerUpdate(listener);
                //   }


              }

            }

          };

          //link update
          this.manageLinkUpdate = function (icObj_link, outerUpdatesDict) {
            console.log("manageLinkUpdate", icObj_link);

            //get free_rep
            const link__represented = infiniteCanvas.getRepresented(icObj_link.id);
            const link__rep_free = link__represented.r_free();

            // if(outerUpdatesDict.position != null) {
            //
            //   const offset = {
            //     dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
            //     dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
            //   };
            //
            //   const parts           = handle__rep_free.parts;
            //   const arr_parts_all   = Object.values(parts);
            //   arr_parts_all.forEach((part__rep_free, i) => {
            //
            //     const listener = this.listeners[part__rep_free.id];
            //
            //     //listen:off
            //     part__rep_free.offInnerUpdate(listener);
            //
            //
            //     //mutate
            //     // logger.log("mutating part:", part__rep_free.id);
            //     {
            //       const position_new = {
            //         x: part__rep_free.position.x + offset.dx,
            //         y: part__rep_free.position.y + offset.dy,
            //       };
            //
            //       part__rep_free.position = position_new;
            //     }
            //
            //     //listen:on
            //     part__rep_free.onInnerUpdate(listener);
            //
            //   });
            //
            // }
            // // else if(outerUpdatesDict.parts != null) {
            // //   logger.log("outerUpdatesDict.parts", outerUpdatesDict.parts);
            // //
            // //   // const arr_parts__old = [];
            // //   // const arr_parts__new = [];
            // //
            // //   Object.values(outerUpdatesDict.parts.new).forEach((part__rep_free, i) => {
            // //     const part__listener = this.createPartListener();
            // //     this.listeners[part__rep_free.id] = part__listener;
            // //
            // //     if(handle__rep_free.compositeConfig[part__rep_free.id] == null) {
            // //       const config__part = {
            // //         // isMobile: true,
            // //         isMobile: false,
            // //       };
            // //       handle__rep_free.compositeConfig[part__rep_free.id] = config__part;
            // //     }
            // //
            // //     //'activate' listener
            // //     // const part__listener = this.listeners[part__rep_free.id];
            // //     part__rep_free.onInnerUpdate(part__listener);
            // //
            // //   });
            // //
            // // }

          };







          this.start = function () {
            console.log("engine::start, this", this);
            console.log("LinkEngine::start", "this.scopeObj", this.scopeObj);

            this.listeners = this.createListeners();

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const link = this.scopeObj.engineCarrier;

            console.log("linkEngine.start", link.id);

            //get free_rep
            const link__represented = infiniteCanvas.getRepresented(link.id);
            const link__rep_free = link__represented.r_free();


            //listen to link
            const link__listener = this.listeners[link.id];
            link__rep_free.onInnerUpdate(link__listener);

            //listen to parts
            const parts = link__rep_free.parts;
            const arr_parts_all = Object.values(parts);
            arr_parts_all.forEach((part__rep_free, i) => {
              // logger.log("part__rep_free", part__rep_free);

              //'activate' listeners
              const part__listener = this.listeners[part__rep_free.id];
              part__rep_free.onInnerUpdate(part__listener);
            });

          };

          this.stop = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const link = this.scopeObj.engineCarrier;

            console.log("linkEngine.stop", handle);

            //get free_rep
            const link__represented = infiniteCanvas.getRepresented(link.id);
            const link__rep_free = link__represented.r_free();

            const link__listener = this.listeners[link.id];
            link__rep_free.offInnerUpdate(link__listener);

            const parts = link__rep_free.parts;
            const arr_parts_all = Object.values(parts);
            arr_parts_all.forEach((part__rep_free, i) => {

              const part__listener = this.listeners[part__rep_free.id];
              part__rep_free.offInnerUpdate(part__listener);
            });

          };



          this.virgin = Object.assign({}, this);  //virgin == not bound


        }

      }


      class SliderEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          };


          this.createHandleListener = function () {
            const handle__listener = (representation, propName, oldValue, newValue) => {
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.manageHandleUpdate(representation, updatesDict);
            };

            return handle__listener;
          };




          // this.counter__partListeners = 0;
          // this.createPartListener = function () {

          //   // const index__partListener = this.counter__partListeners;

          //   const part__listener = (representation, propName, oldValue, newValue) => {
          //     // logger.log("partListener", index__partListener);
          //     const updatesDict = {
          //       [propName]: {
          //         old: oldValue,
          //         new: newValue,
          //       },
          //     };
          //     this.managePartUpdate(representation, updatesDict);
          //   };

          //   // this.counter__partListeners += 1;

          //   return part__listener;
          // };



          this.createListeners = function () {
            var outListenersDict = {};

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;


            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();



            const handle__listener = this.createHandleListener();

            // outListenersDict["handle"] = handle__listener;
            outListenersDict[handle.id] = handle__listener;

            
            // const parts = handle__rep_free.parts;
            // const part_listeners = Object.entries(parts).reduce((acc, [partName, part__rep_free]) => {

            //   const part__listener = this.createPartListener();

            //   // acc[partName] = part__listener;
            //   acc[part__rep_free.id] = part__listener;

            //   return acc;
            // }, {});

            // Object.assign(outListenersDict, part_listeners);

            return outListenersDict;
          };


          //handle update
          this.manageHandleUpdate = function (icObj_composite, outerUpdatesDict) {
            console.log("manageHandleUpdate", icObj_composite);

            if (outerUpdatesDict.mathNode != null) {
              logger.log("outerUpdatesDict.mathNode != null", outerUpdatesDict.mathNode);

              const mathNode = outerUpdatesDict.mathNode.new;

              this.updateKnobWithMathNode(mathNode);
            }

          };

          this.updateKnobWithMathNode = function(mathNode) {
            var value;
            if(mathNode.value != null) {
              value    = mathNode.value;
            } else {
              value    = mathNode.evaluate({});
            }

            this.updateKnobWithValue(value);
          }

          this.updateKnobWithValue = function(value) {

            const icObj_composite     = this.scopeObj.engineCarrier;

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(icObj_composite.id);
            const handle__rep_free    = handle__represented.r_free();

            const knob__rep_free      = handle__rep_free.parts.knob;

            //compute knob new center position
            const position = this.positionForValue(value);

            //unlock knob position (in composite)
            const compositeConfig = this.scopeObj.engineCarrier.compositeConfig;
            compositeConfig[knob__rep_free.id].isMobile = true;

            //change knob position
            knob__rep_free.position = position;

            //lock knob position (in composite)
            compositeConfig[knob__rep_free.id].isMobile = false;
          };

          //model --> view

          this.positionForValue = function(value) {
            const value__L = this.scopeObj.engineCarrier.value__L;
            const value__R = this.scopeObj.engineCarrier.value__R;

            const progress = (value - value__L) / (value__R - value__L);
            
            const position = this.positionForProgress(progress);

            return position;
          };  

          this.positionForProgress = function(progress) {
            const point__L = this.scopeObj.engineCarrier.parts.pointL.position;
            const point__R = this.scopeObj.engineCarrier.parts.pointR.position;

            const point__progress = Geometry.pointOnSegment__progress(point__L, point__R, progress);

            return point__progress;
          };

          //view --> model

          this.valueForPosition = function(position) {

          };

          this.progressForPosition = function(position) {

          };


          //part update
          this.manageValueUpdate = function (valueUpdateDict) {

            const parts = handle__rep_free.parts;

            const arr_parts_all = Object.values(parts);
            const arr_parts_other = arr_parts_all.filter(part => part.id != icObj_compositePart.id);

            const arr_handle_and_other = [handle__rep_free, ...arr_parts_other];

            // arr_parts_other.forEach((rep_free, i) => {
            arr_handle_and_other.forEach((rep_free, i) => {

              const listener = this.listeners[rep_free.id];
              // console.log("°°°listener", listener);

              //listen:off
              rep_free.offInnerUpdate(listener);

              //mutate
              // logger.log("mutating part:", rep_free.id);
              {
                const position_new = {
                  x: rep_free.position.x + offset.dx,
                  y: rep_free.position.y + offset.dy,
                };

                rep_free.position = position_new;
              }

              //listen:on
              rep_free.onInnerUpdate(listener);

            });

          }

          // this.updateViewWithModel = function(model) {


          // };

          // this.updateKnobWithValue = function(value) {


          // };

          // this.updateKnobWithProgress = function(progress) {


          // };


          this.start = function () {
            console.log("SliderEngine::start, this", this);
            console.log("SliderEngine::start", "this.scopeObj", this.scopeObj);

            //initialize view
            const mathNode = this.scopeObj.engineCarrier.mathNode;
            this.updateKnobWithMathNode(mathNode);


            this.listeners = this.createListeners();

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            //listen to handle
            const handle__listener = this.listeners[handle.id];
            handle__rep_free.onInnerUpdate(handle__listener);



            // //listen to parts
            // const parts = handle__rep_free.parts;
            // const arr_parts_all = Object.values(parts);
            // arr_parts_all.forEach((part__rep_free, i) => {
            //   logger.log("part__rep_free", part__rep_free);

            //   //set compositeId if not done yet         //SHU: horror
            //   part__rep_free.compositeId = handle__rep_free.id;

            //   //'activate' listeners
            //   logger.log("this.listeners", this.listeners);
            //   const part__listener = this.listeners[part__rep_free.id];
            //   part__rep_free.onInnerUpdate(part__listener);
            // });


            //debug (~tests)
            // setTimeout(() => {
            //   console.log("ççç setTimeout handle__rep_free.id_rep", handle__rep_free.id_rep);
            //
            //   handle__rep_free.position = {
            //     x: handle__rep_free.position.x + 200,
            //     y: handle__rep_free.position.y - 50,
            //   };
            // }, 3000);
            //
            // setTimeout(() => {
            //   const part1 = arr_parts_all[0];
            //   part1.position = {
            //     x: part1.position.x - 200,
            //     y: part1.position.y - 100,
            //   };
            // }, 6000);
            //
            // setTimeout(() => {
            //   const part3 = arr_parts_all[2];
            //   part3.position = {
            //     x: part3.position.x + 150,
            //     y: part3.position.y + 100,
            //   };
            // }, 9000);
          };

          this.stop = function () {
            console.log("sliderEngine.stop", handle);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            const handle__listener = this.listeners[handle.id];
            handle__rep_free.offInnerUpdate(handle__listener);

            // const parts = handle__rep_free.parts;
            // const arr_parts_all = Object.values(parts);
            // arr_parts_all.forEach((part__rep_free, i) => {

            //   // const part__listener = this.listeners[part__rep_free.id];
            //   // part__rep_free.offInnerUpdate(part__listener);

            //   this.removePart(part__rep_free);
            // });


            this.listeners = null;

          };



          this.virgin = Object.assign({}, this);  //virgin == not bound


        }

      }







      class ButtonEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }


          this.clickListener = function () {
            const button = this.scopeObj.engineCarrier;
            const buttonFunc = button.buttonConfig.buttonFunc;
            buttonFunc(this.scopeObj);
          };

          this.start = function () {
            console.log("engine::start, this", this);
            console.log("buttonEngine::start", "this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const button = this.scopeObj.engineCarrier;

            console.log("buttonEngine.start", button.id);

            //get free_rep
            const button__represented = infiniteCanvas.getRepresented(button.id);
            const button__rep_free = button__represented.r_free();


            //"prestart"
            button__rep_free.addInteraction_click();


            //listen to button
            const button__listener = this.clickListener;
            button__rep_free.onClick(button__listener);

          };

          this.stop = function () {
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const button = this.scopeObj.engineCarrier;

            console.log("buttonEngine.start", button.id);

            //get free_rep
            const button__represented = infiniteCanvas.getRepresented(button.id);
            const button__rep_free = button__represented.r_free();

            const button__listener = this.clickListener;
            button__rep_free.offClick(button__listener);
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound


        }


      }


      // class ReplayEngine {
      //   constructor() {
      //
      //     this.initialized = false;
      //
      //     this.initialize = function(scopeObj) {
      //
      //       //"wake up":
      //       //bind all funcs
      //       // function isFunction(functionToCheck) {
      //       //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
      //       // }
      //       const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);
      //
      //       this.awoken = {
      //         'i_am': "awoken",
      //       };
      //       console.log("this.virgin", this.virgin);
      //       Object.entries(this.virgin)
      //             .filter(([propName, prop]) => isFunction(prop))
      //             .forEach(([propName, prop], i) => {
      //               this.awoken[propName] = prop.bind(this.awoken);
      //             });
      //
      //       // this.scopeObj  = scopeObj;
      //         //engineCarrier,
      //         //infiniteCanvas,
      //       this.awoken.scopeObj = scopeObj;
      //
      //       this.initialized = true;
      //     }
      //
      //
      //     this.clickListener = function() {
      //       const button     = this.scopeObj.engineCarrier;
      //       const buttonFunc = button.buttonConfig.buttonFunc;
      //       buttonFunc(this.scopeObj);
      //     };
      //
      //     this.start = function() {
      //       console.log("engine::start, this", this);
      //       console.log("buttonEngine::start", "this.scopeObj", this.scopeObj);
      //
      //       const infiniteCanvas = this.scopeObj.infiniteCanvas;
      //       const button         = this.scopeObj.engineCarrier;
      //
      //       console.log("buttonEngine.start", button.id);
      //
      //       //get free_rep
      //       const button__represented = infiniteCanvas.getRepresented(button.id);
      //       const button__rep_free    = button__represented.r_free();
      //
      //
      //       //"prestart"
      //       button__rep_free.addInteraction_click();
      //
      //
      //       //listen to button
      //       const button__listener = this.clickListener;
      //       button__rep_free.onClick(button__listener);
      //
      //     };
      //
      //     this.stop = function() {
      //       const infiniteCanvas = this.scopeObj.infiniteCanvas;
      //       const button         = this.scopeObj.engineCarrier;
      //
      //       console.log("buttonEngine.start", button.id);
      //
      //       //get free_rep
      //       const button__represented = infiniteCanvas.getRepresented(button.id);
      //       const button__rep_free    = button__represented.r_free();
      //
      //       const button__listener = this.clickListener;
      //       button__rep_free.offClick(button__listener);
      //     };
      //
      //
      //     this.virgin = Object.assign({}, this);  //virgin == not bound
      //
      //
      //   }
      //
      //
      // }


      // class PathmadeOperatorEngine {
      //   constructor() {
      //
      //     this.initialized = false;
      //
      //     this.initialize = function(scopeObj) {
      //
      //       //"wake up":
      //       //bind all funcs
      //       // function isFunction(functionToCheck) {
      //       //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
      //       // }
      //       const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);
      //
      //       this.awoken = {
      //         'i_am': "awoken",
      //       };
      //       console.log("this.virgin", this.virgin);
      //       Object.entries(this.virgin)
      //             .filter(([propName, prop]) => isFunction(prop))
      //             .forEach(([propName, prop], i) => {
      //               this.awoken[propName] = prop.bind(this.awoken);
      //             });
      //
      //       // this.scopeObj  = scopeObj;
      //         //engineCarrier,
      //         //infiniteCanvas,
      //       this.awoken.scopeObj = scopeObj;
      //
      //       this.initialized = true;
      //     }
      //
      //
      //     this.clickListener = function() {
      //       const button     = this.scopeObj.engineCarrier;
      //       const buttonFunc = button.buttonConfig.buttonFunc;
      //       buttonFunc(this.scopeObj);
      //     };
      //
      //     this.start = function() {
      //       console.log("engine::start, this", this);
      //       console.log("buttonEngine::start", "this.scopeObj", this.scopeObj);
      //
      //       const infiniteCanvas = this.scopeObj.infiniteCanvas;
      //       const button         = this.scopeObj.engineCarrier;
      //
      //       console.log("buttonEngine.start", button.id);
      //
      //       //get free_rep
      //       const button__represented = infiniteCanvas.getRepresented(button.id);
      //       const button__rep_free    = button__represented.r_free();
      //
      //
      //       //"prestart"
      //       button__rep_free.addInteraction_click();
      //
      //
      //       //listen to button
      //       const button__listener = this.clickListener;
      //       button__rep_free.onClick(button__listener);
      //
      //     };
      //
      //     this.stop = function() {
      //       const infiniteCanvas = this.scopeObj.infiniteCanvas;
      //       const button         = this.scopeObj.engineCarrier;
      //
      //       console.log("buttonEngine.start", button.id);
      //
      //       //get free_rep
      //       const button__represented = infiniteCanvas.getRepresented(button.id);
      //       const button__rep_free    = button__represented.r_free();
      //
      //       const button__listener = this.clickListener;
      //       button__rep_free.offClick(button__listener);
      //     };
      //
      //
      //     this.virgin = Object.assign({}, this);  //virgin == not bound
      //
      //
      //   }
      //
      //
      // }


      class GeminiShadeEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }




          this.start = function () {
            logger.log("GeminiShadeEngine.start", this);
            const engine = this;

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const gemini = this.scopeObj.engineCarrier;
            const id__target = this.scopeObj.engineCarrier.id__target;

            //get free_rep
            const represented__gemini = infiniteCanvas.getRepresented(gemini.id);
            const rep_free__gemini = represented__gemini.r_free();
            const rep_official__gemini = represented__gemini.r_official();


            //get target's free_rep
            const represented__target = infiniteCanvas.getRepresented(id__target);
            const rep_free__target = represented__target.r_free();
            const rep_official__target = represented__target.r_official();




            //create listeners

            const set_propName__ignore = new Set([
              "id",
              "type",

              "position",
              "size",
              "homeScale",
              "orientation",
              "scale",
              "flip",
              "zIndex",

              "fill",
              "stroke",
              "opacity",
              "strokeWidth",
              "backgroundColor",

              "canBeMoved",
              "canBeRotated",
              "canBeResized",
              "canBeSelected",
              "canBeHeld",

              "isSnappable",
              "snapState",
              "snappedTo",

              "isTouchable",
              "touchStateDict",

              "cType",
              "isCompositePart",
              "isMobile",
              "compositeId",

              "isHeld",
              "isUsingCenterPosition",

              "isSelected",
              "didUpdateListeners",

              "edit",

              "holdListeners",
              "nowHeld",
              "onHold",
              "offHold",
              "releaseListeners",
              "nowReleased",
              "onRelease",
              "offRelease",




              "id__target",
              // "eType",
              // "engine",
              "dict_engine",
              "getScopeObj",

              "im_dying_now",
              "im_dead_now",
            ]);

            const set_propName__ignore_in = set_propName__ignore;
            const set_propName__ignore_out = set_propName__ignore;


            const broadcast = function (rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_out.has(propName);
              if (isIgnored) {
                return;
              }
              logger.log("broadcast", propName, newValue);

              //off listener
              if (rep_free__target.didUpdateFromInnerListeners.includes(engine.receive)) {
                rep_free__target.offInnerUpdate(engine.receive);
              }

              //mutate
              rep_free__target[propName] = newValue;

              //on listener
              rep_free__target.onInnerUpdate(engine.receive);

            };

            const receive = function (rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_in.has(propName);
              if (isIgnored) {
                return;
              }
              logger.log("receive", propName, newValue);

              //off listener
              if (rep_free__gemini.didUpdateFromInnerListeners.includes(engine.broadcast)) {
                rep_free__gemini.offInnerUpdate(engine.broadcast);
              }

              //mutate
              rep_free__gemini[propName] = newValue;

              //on listener
              rep_free__gemini.onInnerUpdate(engine.broadcast);

            };

            //store listeners
            engine.broadcast = broadcast;
            engine.receive = receive;

            this.geminiBind = function (gemini, target) {

              target.onInnerUpdate(this.receive);
              gemini.onInnerUpdate(this.broadcast);
              // gemini.follow(target);
              // target.follow(gemini);

              //create and store uninstaller
              this.geminiUnbind = function () {
                gemini.offInnerUpdate(this.broadcast);
                target.offInnerUpdate(this.receive);
                // gemini.unfollow(target);
                // target.unfollow(gemini);
              };

            };

            this.geminiBind(rep_free__gemini, rep_free__target);


            /*
            const broadcast = function(rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_out.has(propName);
              if(isIgnored) {
                return;
              }
              logger.log("broadcast", propName, newValue);

              //off listener
              if(rep_official__target.didUpdateFromInnerListeners.includes(engine.receive)) {
                rep_official__target.offInnerUpdate(engine.receive);
              }

              //mutate
              rep_official__target[propName] = newValue;

              //on listener
              rep_official__target.onInnerUpdate(engine.receive);

            };

            const receive = function(rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_in.has(propName);
              if(isIgnored) {
                return;
              }
              logger.log("receive", propName, newValue);

              //off listener
              if(rep_official__gemini.didUpdateFromInnerListeners.includes(engine.broadcast)) {
                rep_official__gemini.offInnerUpdate(engine.broadcast);
              }

              //mutate
              rep_official__gemini[propName] = newValue;

              //on listener
              rep_official__gemini.onInnerUpdate(engine.broadcast);

            };

            //store listeners
            engine.broadcast = broadcast;
            engine.receive   = receive;

            this.geminiBind(rep_official__gemini, rep_official__target);
            */
          };

          this.stop = function () {
            this.geminiUnbind();

            this.broadcast = null;
            this.receive = null;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound


        }


      }


      class GeminiEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }




          this.start = function () {
            logger.log("GeminiShadeEngine.start", this);
            const engine = this;

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const gemini = this.scopeObj.engineCarrier;
            const id__target = this.scopeObj.engineCarrier.id__target;

            //get free_rep
            const represented__gemini = infiniteCanvas.getRepresented(gemini.id);
            const rep_free__gemini = represented__gemini.r_free();
            const rep_official__gemini = represented__gemini.r_official();


            //get target's free_rep
            const represented__target = infiniteCanvas.getRepresented(id__target);
            const rep_free__target = represented__target.r_free();
            const rep_official__target = represented__target.r_official();




            //create listeners

            const set_propName__ignore = new Set([
              "id",
              "type",

              "position",
              "size",
              "homeScale",
              "orientation",
              "scale",
              "flip",
              "zIndex",

              "fill",
              "stroke",
              "opacity",
              "strokeWidth",
              "backgroundColor",

              "canBeMoved",
              "canBeRotated",
              "canBeResized",
              "canBeSelected",
              "canBeHeld",

              "isSnappable",
              "snapState",
              "snappedTo",

              "isTouchable",
              "touchStateDict",

              "cType",
              "isCompositePart",
              "isMobile",
              "compositeId",

              "isHeld",
              "isUsingCenterPosition",

              "isSelected",
              "didUpdateListeners",

              "edit",

              "holdListeners",
              "nowHeld",
              "onHold",
              "offHold",
              "releaseListeners",
              "nowReleased",
              "onRelease",
              "offRelease",




              "id__target",
              // "eType",
              // "engine",
              "dict_engine",
              "getScopeObj",

              "im_dying_now",
              "im_dead_now",
            ]);

            const set_propName__ignore_in = set_propName__ignore;
            const set_propName__ignore_out = set_propName__ignore;


            const broadcast = function (rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_out.has(propName);
              if (isIgnored) {
                return;
              }
              logger.log("broadcast", propName, newValue);

              //off listener
              if (rep_free__target.didUpdateFromInnerListeners.includes(engine.receive)) {
                rep_free__target.offInnerUpdate(engine.receive);
              }

              //mutate
              rep_free__target[propName] = newValue;

              //on listener
              rep_free__target.onInnerUpdate(engine.receive);

            };

            const receive = function (rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_in.has(propName);
              if (isIgnored) {
                return;
              }
              logger.log("receive", propName, newValue);

              //off listener
              if (rep_free__gemini.didUpdateFromInnerListeners.includes(engine.broadcast)) {
                rep_free__gemini.offInnerUpdate(engine.broadcast);
              }

              //mutate
              rep_free__gemini[propName] = newValue;

              //on listener
              rep_free__gemini.onInnerUpdate(engine.broadcast);

            };

            //store listeners
            engine.broadcast = broadcast;
            engine.receive = receive;

            this.geminiBind = function (gemini, target) {

              target.onInnerUpdate(this.receive);
              gemini.onInnerUpdate(this.broadcast);
              // gemini.follow(target);
              // target.follow(gemini);

              //create and store uninstaller
              this.geminiUnbind = function () {
                gemini.offInnerUpdate(this.broadcast);
                target.offInnerUpdate(this.receive);
                // gemini.unfollow(target);
                // target.unfollow(gemini);
              };

            };

            this.geminiBind(rep_free__gemini, rep_free__target);


            /*
            const broadcast = function(rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_out.has(propName);
              if(isIgnored) {
                return;
              }
              logger.log("broadcast", propName, newValue);

              //off listener
              if(rep_official__target.didUpdateFromInnerListeners.includes(engine.receive)) {
                rep_official__target.offInnerUpdate(engine.receive);
              }

              //mutate
              rep_official__target[propName] = newValue;

              //on listener
              rep_official__target.onInnerUpdate(engine.receive);

            };

            const receive = function(rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_in.has(propName);
              if(isIgnored) {
                return;
              }
              logger.log("receive", propName, newValue);

              //off listener
              if(rep_official__gemini.didUpdateFromInnerListeners.includes(engine.broadcast)) {
                rep_official__gemini.offInnerUpdate(engine.broadcast);
              }

              //mutate
              rep_official__gemini[propName] = newValue;

              //on listener
              rep_official__gemini.onInnerUpdate(engine.broadcast);

            };

            //store listeners
            engine.broadcast = broadcast;
            engine.receive   = receive;

            this.geminiBind(rep_official__gemini, rep_official__target);
            */
          };

          this.stop = function () {
            this.geminiUnbind();

            this.broadcast = null;
            this.receive = null;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound


        }


      }






      class GMOperatorTextChangeEngine {


        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.mathOperatorFuncNameForSymbol = function (mathOperatorSymbol) {
            var outMathOperatorFuncName;

            switch (mathOperatorSymbol) {
              case "+":
              case "plus":
              case "add":
                outMathOperatorFuncName = 'add';
                break;
              case "-":
              case "minus":
              case "subtract":
                outMathOperatorFuncName = 'subtract';
                break;
              case "x":
              case "×":
              case "times":
              case "multiplyBy":
                outMathOperatorFuncName = 'multiply';
                break;
              case "/":
              case "divideBy":
              case "add":
                outMathOperatorFuncName = 'divide';
                break;
              default:
                outMathOperatorFuncName = 'unknown';
                break;
            }

            return outMathOperatorFuncName;
          };

          this.createTransformationFunc = function (mathOperatorSymbol_in, mathOperatorFuncName_in, node_b_in) {
            return (node_a) => {
              var outNode;

              const mathOperatorSymbol = mathOperatorSymbol_in;
              const mathOperatorFuncName = mathOperatorFuncName_in;
              const node_b = node_b_in;

              function standardOperation(node_in) {
                var outNode;

                // const node_b        = new math.ConstantNode(mathValue);
                const node_operator = new math.OperatorNode(mathOperatorSymbol, mathOperatorFuncName, [node_in, node_b]);

                const node_unsimplified = node_operator;

                if (node_in.autoSimplify) {
                  const node_simplified = math.simplify(node_unsimplified);
                  outNode = node_simplified;
                } else {
                  outNode = node_unsimplified;
                }

                outNode.autoSimplify = node_in.autoSimplify;

                return outNode;
              }

              // logger.log("node_a", node_a);
              if (node_a.isEquation) {
                console.log("node_a", node_a);
                const node_left = standardOperation(node_a.params[0]);
                const node_right = standardOperation(node_a.params[1]);
                const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                node_equation.isEquation = true;

                outNode = node_equation;
              } else {
                outNode = standardOperation(node_a);
              }

              // outNode.autoSimplify = node_a.autoSimplify;

              return outNode;
            };
          };

          this.transformationFuncForText = function (text) {

            const components = text.split(" ");
            const mathOperatorSymbol = components[0];
            const mathValueString = components[1];

            // const mathValue          = Number(mathValueString);

            // const mathValueTex       = MathExpression.fromText(mathValueString).toLatex();
            // console.log("mathValueTex", mathValueTex);

            // const node_b             = math.parse(mathValueTex);   //SHU: math only parses expressions written in math.js DSL
            const node_b = math.parse(mathValueString);
            console.log("node_b", node_b);

            const mathOperatorFuncName = this.mathOperatorFuncNameForSymbol(mathOperatorSymbol);

            const transformationFunc = this.createTransformationFunc(mathOperatorSymbol, mathOperatorFuncName, node_b);
            // return transformationFunc;

            const icObjTransformationFunc = (icObj) => {
              var transformationOutput;

              var outIcObj;

              const mathNode__new = transformationFunc(icObj.mathNode);

              /* //does not work well
              // outIcObj = icObj.clone();
              // // logger.log("icObj.mathNode", icObj.mathNode);
              // outIcObj.mathNode = transformationFunc(mathNode__new);
              */
              //does work well
              outIcObj = infiniteCanvas.createIcMathNode(icObj.position.x, icObj.position.y, mathNode__new);

              // transformationOutput = new TransformationOutput("mutated", outIcObj, icObj);
              transformationOutput = new TransformationOutput("new", outIcObj, icObj);

              return transformationOutput;
            };

            return icObjTransformationFunc;
          };


          this.updateTouchSlotWithText = function (text) {

            const gmOperator = this.scopeObj.engineCarrier;
            const touchSlot = gmOperator.parts["touchSlot"];

            const transformationFunc = this.transformationFuncForText(text);
            const touchSlotConfig = {
              transformationFunc: transformationFunc,
            };
            touchSlot.touchSlotConfig = touchSlotConfig;

          };

          this.textChangeListener = function (rep_free_in) {
            console.log("textChangeListener, rep_free_in", rep_free_in);

            //SHU TODO: trouver pourquoi la facade récupérée n'est pas une rep_free   (quel merdier...)
            const rep_free = infiniteCanvas.getRepresented(rep_free_in.id).r_free();
            console.log("textChangeListener, rep_free", rep_free);

            const text = rep_free.text;
            this.updateTouchSlotWithText(text);
          };





          this.start = function () {
            console.log("engine::start, this", this);
            console.log("GMOperatorTextChangeEngine::start", "this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const gmOperator = this.scopeObj.engineCarrier;

            console.log("GMOperatorTextChangeEngine.start", gmOperator);

            const facade = gmOperator.parts["facade"];

            const rep_free = facade;

            if (rep_free.onEditExit == null) {
              rep_free.addInteraction_edit();
            }

            rep_free.onEditExit(this.textChangeListener);
          };

          this.stop = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const gmOperator = this.scopeObj.engineCarrier;

            console.log("GMOperatorTextChangeEngine.stop", gmOperator);

            const rep_free = gmOperator;

            rep_free.offEditExit(this.textChangeListener);
          };



          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

        lol() {



        }

      }



      class GMOperatorMama {

        static operatorConfigForRank(rank) {
          var outOperatorConfig = null;

          var name = null;
          var transformationFunc = null;
          switch (rank) {
            case 0:
              name = "+1";
              // transformationFunc = (number) => (number + 1);
              // transformationFunc = (expr) => {
              // console.log("expr", expr);
              transformationFunc = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  const node_b = new math.ConstantNode(1);
                  const node_operator = new math.OperatorNode('+', 'add', [node_in, node_b]);

                  const node_unsimplified = node_operator;

                  if (node_in.autoSimplify) {
                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;
                  } else {
                    outNode = node_unsimplified;
                  }

                  outNode.autoSimplify = node_in.autoSimplify;

                  return outNode;
                }

                if (node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left = standardOperation(node_a.params[0]);
                  const node_right = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                // outNode.autoSimplify = node_a.autoSimplify;

                return outNode;
              };
              break;
            case 1:
              name = "+10";
              // transformationFunc = (number) => (number + 10);
              // transformationFunc = (expr) => expr.add(10);
              transformationFunc = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  const node_b = new math.ConstantNode(10);
                  const node_operator = new math.OperatorNode('+', 'add', [node_a, node_b]);

                  const node_unsimplified = node_operator;

                  if (node_a.autoSimplify) {
                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;
                  } else {
                    outNode = node_unsimplified;
                  }

                  outNode.autoSimplify = node_a.autoSimplify;

                  return outNode;
                }

                if (node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left = standardOperation(node_a.params[0]);
                  const node_right = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                // outNode.autoSimplify = node_a.autoSimplify;

                return outNode;
              };
              break;
            case 2:
              name = "×2";
              // transformationFunc = (number) => (number * 2);
              // transformationFunc = (expr) => expr.multiply(2);
              const transformationFunc__mathNode = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  const node_b = new math.ConstantNode(2);
                  const node_operator = new math.OperatorNode('x', 'multiply', [node_a, node_b]);

                  const node_unsimplified = node_operator;

                  if (node_a.autoSimplify) {
                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;
                  } else {
                    outNode = node_unsimplified;
                  }

                  outNode.autoSimplify = node_a.autoSimplify;

                  return outNode;
                };

                if (node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left = standardOperation(node_a.params[0]);
                  const node_right = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                // outNode.autoSimplify = node_a.autoSimplify;

                return outNode;

              };

              /*
              const transformationFunc__default = (icObj) => {

                icObj.scale = {
                  X: icObj.scale.X * 2,
                  Y: icObj.scale.Y * 2,
                };

                return icObj;
              }

              transformationFunc = (icObj) => {
                var out;
                console.log("transformationFunc, icObj", icObj);

                switch(icObj.type) {
                  case "mathNode":
                    out = transformationFunc__mathNode(icObj);
                    break;
                  default:
                    out = transformationFunc__default(icObj);
                    break;
                }

                return out;
              }
              */
              transformationFunc = transformationFunc__mathNode;


              break;
            case 3:
              name = "×(-1)";
              // transformationFunc = (number) => (number * (-1));
              // transformationFunc = (expr) => expr.multiply(-1);
              transformationFunc = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  const node_minus_1 = new math.ConstantNode(-1);
                  const node_minus_1_with_parentheses = new math.ParenthesisNode(node_minus_1);
                  const node_b = node_minus_1_with_parentheses;

                  const node_operator = new math.OperatorNode('x', 'multiply', [node_a, node_b]);

                  const node_unsimplified = node_operator;

                  if (node_a.autoSimplify) {
                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;
                  } else {
                    outNode = node_unsimplified;
                  }

                  outNode.autoSimplify = node_a.autoSimplify;

                  return outNode;
                }


                if (node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left = standardOperation(node_a.params[0]);
                  const node_right = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                // outNode.autoSimplify = node_a.autoSimplify;

                return outNode;

              };
              break;
            default:
              break;
          }

          // const operatorConfig = new OperatorConfig(name, transformationFunc);

          const icObjTransformationFunc = (icObj) => {
            var outIcObj;

            outIcObj = icObj.clone();

            outIcObj.mathNode = transformationFunc(icObj.mathNode);

            return outIcObj;
          };
          // const operatorConfig = new OperatorConfig(name, icObjTransformationFunc);


          const transformationFunc_oldStyle = icObjTransformationFunc;
          const transformationFunc_newStyle = function (icObj) {
            var transformationOutput;

            const icObj__mutated = transformationFunc_oldStyle(icObj);
            transformationOutput = new TransformationOutput("mutated", icObj__mutated, icObj);

            return transformationOutput;
          };
          const operatorConfig = new OperatorConfig(name, transformationFunc_newStyle);


          outOperatorConfig = operatorConfig;

          return outOperatorConfig;
        }

      }

      class OperatorConfig {

        constructor(name, transformationFunc) {
          this.name = name;
          this.transformationFunc = transformationFunc;
        }

      }


      class Hooker {

        static createHook() {

          const listeners = [];
          const hookObj = {
            listeners: listeners,
            trigger: (...args) => {
              listeners.forEach((listener, i) => {
                listener(...args);
              });
            },
            on: (listener) => {
              listeners.push(listener);
            },
            off: (listener) => {
              listeners.push(listener);
            },
          };

          return hookObj;
        }

        static installHooks(obj, funcName) {

          const func_original = obj[funcName];
          if (func_original == null) {
            throw new Error('obj["' + funcName + '"]' + " == null");
          }

          //create hooks
          if (obj.will == null) {
            obj.will = {};
          }
          obj.will[funcName] = this.createHook();

          if (obj.did == null) {
            obj.did = {};
          }
          obj.did[funcName] = this.createHook();



          //decorate func                         //SHU: en fait on pourrait ne pas faire assigner obj.will et obj.did et garder ces objects enfermés dans la définition de la fonction décorée
          // const func_original  = obj[funcName];
          const func_decorated = (...args) => {
            // console.log("func_decorated", ...args);
            obj.will[funcName].trigger(...args);
            func_original(...args);
            obj.did[funcName].trigger(...args);
          };

          obj[funcName] = func_decorated;
        }

      }







      /**** view  / controller ****/



      class FabricIntegration {

        constructor(infiniteCanvas, inputProperties) {

          //initialize fabric properties
          // fabric.Object.prototype.transparentCorners = false;
          // fabric.Object.prototype.cornerStyle = 'circle';
          // fabric.Object.prototype.cornerColor = 'black';
          // fabric.Object.prototype.borderColor = 'black';
          // fabric.Object.prototype.padding     = 10;
          //
          //
          fabric.Rect.prototype.rx = 5;    //shuxylo
          fabric.Rect.prototype.ry = 5;


          fabric.Object.prototype.getFObjZIndex = function () {
            // logger.log("this", this);
            // logger.log("this.canvas", this.canvas);
            if (!this.canvas) {          //SHU TODO: understand where this strange state originates from
              return 0;
            }
            return this.canvas.getObjects().indexOf(this);
          };


          // // fabricjs group - always show border
          // fabric.Group.prototype.initialize = (function (initialize) {
          //     return function () {
          //         initialize.apply(this, arguments)
          //         // prepend rect before=behind group objects
          //         this._objects = [
          //         new fabric.Rect({
          //             // position from group center
          //             left: -0.5*this.width,
          //             top: -0.5*this.height,
          //             width: this.width,
          //             height: this.height,
          //
          //             stroke: '#00f',
          //             strokeWidth: 2,
          //             fill: false,
          //         })]
          //         .concat(this._objects)
          //
          //         // TODO repaint border on group resize event
          //
          //         // TODO remove border on group destroy
          //     };
          // })(fabric.Group.prototype.initialize);





          this.infiniteCanvas = infiniteCanvas;
          this.inputProperties = inputProperties;

          this.mouseIntegration = null;   //set after birth

          const fabricCanvas = new fabric.Canvas(infiniteCanvas.canvas.id, {

            // backgroundColor: 'rgb(250,60,60)',     //redish
            // backgroundColor: 'rgb(100,100,100)',
            // backgroundColor: 'rgb(200,200,200)',      //it is important to choose a nice bgColor to stay motivated during dev
            // backgroundColor: 'rgb(210,240,240)',
            // backgroundColor: 'rgb(100,100,100)',
            // backgroundColor: 'rgb(255,255,255)',
            // backgroundColor: 'rgb(200,250,200)',
            backgroundColor: 'rgb(250,190,200)',





            selectionColor: 'blue',
            selectionLineWidth: 2,

            // width:  canvas.width,
            // height: canvas.height,


            // imageSmoothingEnabled: true,
            imageSmoothingEnabled: false,

            preserveObjectStacking: true,
          });

          //debug
          function install_boundingboxing() {

            fabricCanvas.on('after:render', function () {

              fabricCanvas.forEachObject(function (fObj) {

                if (fObj.icObj.isSupervessel) {
                  //ignore
                  return;
                }

                const dataURL = fObj.toDataURL();
                const isDataURL = dataURL.startsWith("data");
                if (isDataURL) {
                  ImageUtils.getImageDataObj(dataURL)
                    .then(function (dataObj) {
                      const data = dataObj.data;
                      const w = dataObj.w;
                      const h = dataObj.h;

                      logger.log("w", w);
                      logger.log("h", h);

                      logger.log("fObj", fObj);

                      var boundRect = fObj.getBoundingRect();
                      logger.log("boundRect", boundRect);
                      fabricCanvas.contextContainer.strokeStyle = 'blue';
                      fabricCanvas.contextContainer.strokeRect(
                        boundRect.left,
                        boundRect.top,
                        boundRect.width,
                        boundRect.height,
                      );

                      // const point__pixel_check = {
                      //   x: 452,
                      //   y: 670,
                      // };
                      // const rgbaColorString__pixel_check = ImageUtils.getPixelRgbaColorString(data, w, h, point__pixel_check.x, point__pixel_check.y);
                      // logger.log("rgbaColorString__pixel_check", rgbaColorString__pixel_check);
                      //
                      // if(rgbaColorString__pixel_check != "rgba(255,0,255,255)") {
                      //   throw new Error("pixel check failed");
                      // } else {
                      //   logger.log("pixel check ok");
                      // }

                      const realBound = ImageUtils.boundingBox__pixelWise(data, w, h);

                      const rect__realBound = {
                        left: realBound.x1,
                        top: realBound.y1,
                        width: realBound.x2 - realBound.x1,
                        height: realBound.y2 - realBound.y1,
                      };

                      fabricCanvas.contextContainer.strokeStyle = 'red';
                      fabricCanvas.contextContainer.strokeRect(
                        (boundRect.left + 10) + rect__realBound.left,
                        (boundRect.top + 10) + rect__realBound.top,
                        rect__realBound.width,
                        rect__realBound.height,
                      );

                    });

                }

              });

            });

          }

          // install_boundingboxing();


          this.fabricCanvas = fabricCanvas;
          this.context = fabricCanvas.getContext("2d");
          //console.log("fabricCanvas", fabricCanvas);

          this.fabric_objects = [];
          // this.inner_fabric_objects = [];
          // this.outer_fabric_objects = [];

          this.fabric_objects__pure = [];


          this.fabric_objects__hud = [];


          this.fObjForIcObj_dict = {};

          this.singleUseBehaviors = {};

          //debug
          {
            // this.isEnabled_supervessel = true;
            this.isEnabled_supervessel = false;
          }

          // this.debugFabric();
          this.synchronizeWithIcObjects(infiniteCanvas.icObjects);

          // this.debugOriginalAxes();

          this.initializeSelectionMgmt();  //shuxylo

          this.initializeFreeDrawing();

          this.initializeFabricObjectCopyCut();

          this.configureActiveSelectionListeners();
        }

        setFabricObjects(fabric_objects__new) {
          this.fabric_objects = fabric_objects__new;
        }

        getFabricObjects() {
          return this.fabric_objects;
        }

        createSupervessel() {
          // logger.log("createSupervessel");

          const infiniteCanvas = this.infiniteCanvas;

          const trueRect_0 = {
            x: 200,
            y: 200,
            width: 100,
            height: 100,
          };

          const parts = [];
          const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
          const icComposite = infiniteCanvas.createIcComposite(trueRect_0, parts, compositeConfig);
          infiniteCanvas.addIcObject(icComposite);

          const rep_free = infiniteCanvas.getRepresented(icComposite.id).r_free();
          const fColor = new fabric.Color("lightgray");
          fColor.setAlpha(0.666);
          const rgbaColorString = fColor.toRgba();
          rep_free.fill = rgbaColorString;

          // rep_free.strokeWidth = 1.5;
          // rep_free.stroke      = "red";

          rep_free.isSupervessel = true;

          return rep_free;
        }

        // createSuperante() {
        //   // logger.log("createSuperante");
        //
        //   const infiniteCanvas = this.infiniteCanvas;
        //
        //   const trueRect_0 = {
        //     x: 100,
        //     y: 100,
        //     width:  50,
        //     height: 50,
        //   };
        //
        //   const parts           = [];
        //   const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
        //   const icComposite     = infiniteCanvas.createIcComposite(trueRect_0, parts, compositeConfig);
        //   infiniteCanvas.addIcObject(icComposite);
        //
        //   const rep_free = infiniteCanvas.getRepresented(icComposite.id).r_free();
        //   const fColor = new fabric.Color("yellow");
        //   fColor.setAlpha(0.666);
        //   const rgbaColorString = fColor.toRgba();
        //   rep_free.fill        = rgbaColorString;
        //
        //   // rep_free.strokeWidth = 1.5;
        //   // rep_free.stroke      = "red";
        //
        //   rep_free.isSuperante = true;
        //
        //   return rep_free;
        // }

        initializeSelectionMgmt() {
          const fabricIntegration = this;

          const fabricCanvas = fabricIntegration.fabricCanvas;

          //create supervessel
          setTimeout(() => {      //SHU: encore une envie de vomir
            const rep_free__supervessel = fabricIntegration.createSupervessel();
            // const rep_free__superante   = fabricIntegration.createSuperante();
          }, 500);

          // fabricCanvas.on('selection:cleared', function(options) {
          //   // console.log("selection:cleared", options);
          //   const selectionMgmtObj = getSelectionMgmtObject(options);
          //   processSelectionMgmtObject(selectionObj);
          // });
          // fabricCanvas.on('selection:created', function(options) {
          //   // console.log("selection:created", options);
          //   const selectionMgmtObj = getSelectionMgmtObject(options);
          //   processSelectionMgmtObject(selectionObj);
          // });
          // fabricCanvas.on('selection:updated', function(options) {
          //   // console.log("selection:updated", options);
          //   const selectionMgmtObj = getSelectionMgmtObject(options);
          //   processSelectionMgmtObject(selectionObj);
          // });

          function selectionHandler__default(options) {
            const selectionMgmtObj = getSelectionMgmtObject(options);
            processSelectionMgmtObject(selectionMgmtObj, options);     //SHU666666 this call is very heavy
          }



          function isSelectionAllowed__scaleWise(icObj) {
            logger.log("isSelectionAllowed__scaleWise", icObj);

            const range_homeScaleX = {
              min: infiniteCanvas.scale.X * 0.90,
              max: infiniteCanvas.scale.X * 1.10,
            };
            logger.log("range_homeScaleX", range_homeScaleX);

            const homeScaleX__icObj = icObj.homeScale.X;
            logger.log("homeScaleX__icObj", homeScaleX__icObj);

            const isInRange_homeScaleX = (homeScaleX__icObj >= range_homeScaleX.min) && (homeScaleX__icObj < range_homeScaleX.max);
            logger.log("isInRange_homeScaleX", isInRange_homeScaleX);

            return isInRange_homeScaleX;
          }

          var shouldCancelFabricSelectionEvent = false; //SHU: this is ugly, I know, but I don't how to do it differently
          var selectionMgmtObj__previous = null;

          fabricCanvas.on('mouse:down:before', (e) => {
            logger.log("mouse:down:before", e);


            if (this.isEnabled_supervessel) {  //SHU: debug clause

              const fObj__supervessel = fabricIntegration.getFObj__supervessel();
              const icObj__supervessel = fObj__supervessel.icObj;

              if (e.target != null) {

                const fObj__clicked = e.target;
                const icObj__clicked = fObj__clicked.icObj;

                if (fObj__clicked == fObj__supervessel) {
                  //ignore
                  return;
                }

                //scale-aware selection     //SHU: disabled for the moment
                // const isSelectionAllowed__scaleWise_ = isSelectionAllowed__scaleWise(icObj__clicked);
                // if(!isSelectionAllowed__scaleWise_) {
                //   // fabricCanvas._setupCurrentTransform(e, fObj__supervessel);
                //   // fabricCanvas.setActiveObject(fObj__supervessel);
                //   const mouseEvent = e.e;
                //   mouseEvent.stopPropagation();
                //
                //   return;
                // }

                if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {   //SHU: ouloulouloulou, aïe aïe aïe aïe aïe...
                  logger.log("lolilol");

                  fabricCanvas._setupCurrentTransform(e, fObj__supervessel);  //magic happens here
                  fabricCanvas.setActiveObject(fObj__supervessel);

                  icObj__supervessel.dict_engine["composite"].engine.awoken.addPart(icObj__clicked);

                  //is it necessary ? {
                  const options = {
                    selected: [fObj__supervessel],
                  };
                  selectionHandler__default(options);
                  //} ?

                } else {

                  const arr_part__supervessel = Object.values(icObj__supervessel.parts);
                  if (arr_part__supervessel.length > 0) {

                    const arr_part = Object.values(icObj__supervessel.parts);
                    arr_part.forEach((part, i) => {
                      icObj__supervessel.dict_engine["composite"].engine.awoken.removePart(part);
                    });

                  }

                  logger.log("icObj__supervessel", icObj__supervessel);

                  icObj__supervessel.zIndex = icObj__clicked.zIndex + 1;
                  icObj__supervessel.position = {
                    x: icObj__clicked.position.x,
                    y: icObj__clicked.position.y,
                  };


                  fabricCanvas._setupCurrentTransform(e, fObj__supervessel);  //magic happens here

                  fabricCanvas.setActiveObject(fObj__supervessel);

                  icObj__supervessel.dict_engine["composite"].engine.awoken.addPart(icObj__clicked);

                  //is it necessary ? {
                  const options = {
                    selected: [fObj__supervessel],
                  };
                  selectionHandler__default(options);
                  //} ?

                }

                // }

              } else {
                // const fObj__supervessel  = fabricIntegration.getFObj__supervessel();
                // const icObj__supervessel = fObj__supervessel.icObj;

                const arr_part = Object.values(icObj__supervessel.parts);
                arr_part.forEach((part, i) => {
                  icObj__supervessel.dict_engine["composite"].engine.awoken.removePart(part);
                });
              }

            }

          });
          fabricCanvas.on('selection:created', (e) => {
            logger.log("selection:created", e);
            selectionHandler__default(e);
          });
          fabricCanvas.on('before:transform', (e) => {
            logger.log("before:transform", e);
          });

          fabricCanvas.on('selection:updated', (e) => {
            logger.log("selection:updated", e);
            selectionHandler__default(e);
          });

          fabricCanvas.on('selection:cleared', (e) => {
            logger.log("selection:cleared", e);
            selectionHandler__default(e);
          });

          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          function getSelectionMgmtObject(options) {
            var outObj;

            const arr_fObj = Object.values(fabricIntegration.fabric_objects);

            var arr_selected = (options.selected != null) ? options.selected : [];

            // //scale-aware selection
            // arr_selected = arr_selected.filter(fObj => {
            //   const icObj = fObj.icObj;
            //
            //   const isSelectionAllowed__scaleWise_ = isSelectionAllowed__scaleWise(icObj);
            //   return isSelectionAllowed__scaleWise_;
            // });

            const difference = arr_fObj.filter(x => !arr_selected.includes(x));
            const arr_unselected = difference;

            outObj = {
              arr_selected: arr_selected,
              arr_unselected: arr_unselected,
            };

            return outObj;
          }

          function processSelectionMgmtObject(selectionMgmtObj, options) {
            logger.log("processSelectionMgmtObject", selectionMgmtObj, options);

            selectionMgmtObj.arr_selected.forEach((fObj, i) => {
              const icObj = fObj.icObj;
              icObj.isSelected = true;
            });
            selectionMgmtObj.arr_unselected.forEach((fObj, i) => {
              const icObj = fObj.icObj;
              icObj.isSelected = false;
            });


            //supervessel
            if (selectionMgmtObj.arr_selected.length == 0) {
              logger.log("selectionMgmtObj.arr_selected.length == 0");

            } else if (selectionMgmtObj.arr_selected.length == 1) {
              logger.log("selectionMgmtObj.arr_selected.length == 1");

              // const fObj__selected  = selectionMgmtObj.arr_selected.find(e => true);
              // const icObj__selected = fObj__selected.icObj;
              // // icObj__selected.nowReleased();
              // //XXX fabricCanvas.dismissActiveObject();
              //
              // const icObj__supervessel = fabricIntegration.getIcObj__supervessel();
              // icObj__supervessel.position = {
              //   x: icObj__selected.position.x,
              //   y: icObj__selected.position.y,
              // };
              //
              // const fObj__supervessel = fabricIntegration.getFObj__supervessel();
              // fabricCanvas.setActiveObject(fObj__supervessel);
              // // icObj__supervessel.nowHeld();
              //
              // const o2 = fObj__supervessel;
              // // fabricCanvas._setupCurrentTransform(o2.e, o2.target);
              //
              // // fabricCanvas.on('mouse:down', function(o) {
              // //   // logger.log("789789");
              // //   // fabricCanvas._setupCurrentTransform(o.e, o.target);
              // //   fabricCanvas._setupCurrentTransform(o2.e, o2.target);
              // // });
              //
              // // fabricCanvas.fire("event:dragleave", () => {
              // //
              // // });
              // // fabricCanvas.fire("event:dragenter", () => {
              // //
              // // });
              //
              // //look for Event instance
              // const e = null;
              // logger.log("options", options);
              // const transform__current = fabricCanvas.getCurrentTransform();
              // logger.log("transform__current", transform__current);
              //
              // fabricCanvas._setupCurrentTransform(e, o2);
              // // fabricCanvas.renderAll();

            } else {
              logger.log("selectionMgmtObj.arr_selected.length > 1");
            }

            selectionMgmtObj__previous = selectionMgmtObj;

          }

        }

        getFObj__supervessel() {
          const fObj__supervessel = this.getFabricObjects().find(fObj => fObj.icObj.isSupervessel);
          return fObj__supervessel;
        }

        getIcObj__supervessel() {
          const icObj__supervessel = this.getFabricObjects().map(fObj => fObj.icObj).find(icObj => icObj.isSupervessel);
          return icObj__supervessel;
        }


        setSupervesselEnabled(enabled) {
          console.log("setSupervesselEnabled", enabled);
          this.isEnabled_supervessel = enabled;
          // this.fabricCanvas.requestRenderAll();
        }


        getFObj__dummy() {
          const fObj__dummy = this.getFabricObjects().find(fObj => fObj.icObj.isDummy);
          return fObj__dummy;
        }




        // debugOriginalAxes() {
        //
        //   this.debugOriginalAxis_X();
        //   this.debugOriginalAxis_Y();
        // }
        //
        // debugOriginalAxis_X() {
        //
        //   // const line = new fabric.Line([0, -100, 0, +100], {
        //   //   left: 0,
        //   //   top: 0,
        //   //   stroke: 'red'
        //   // });
        //   //
        //   // this.addInnerFabricObject(line);
        //
        //   const rect = new fabric.Rect({
        //     left: 0,
        //     top: 0,
        //     width: 1000,
        //     height: 10,
        //     fill: 'blue',
        //   });
        //
        //   this.addInnerFabricObject(rect);
        //
        //
        //
        // }
        //
        // debugOriginalAxis_Y() {
        //
        //   // const line = new fabric.Line([-100, 0, 100, 0], {
        //   //   left: 0,
        //   //   top: 0,
        //   //   stroke: 'red'
        //   // });
        //   //
        //   // this.addInnerFabricObject(line);
        //
        //   const rect = new fabric.Rect({
        //     left: 0,
        //     top: 0,
        //     width: 10,
        //     height: 1000,
        //     fill: 'red',
        //   });
        //
        //   this.addInnerFabricObject(rect);
        //
        // }



        redrawCanvas(redrawOccasion) {
          console.log("redrawCanvas", redrawOccasion);

          switch (redrawOccasion) {

            case RedrawOccasion.offsetChanged:
              this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.scaleChanged: //order is important here
              this.updateFabricObjectsSize(redrawOccasion);
              this.updateFabricObjectsPosition(redrawOccasion);
              break;

            case RedrawOccasion.orientationChanged:
              this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.objectAdded:
              this.updateFabricObjectsPosition(redrawOccasion);
              this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.pureObjectAdded:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.objectRemoved:
              this.updateFabricObjectsPosition(redrawOccasion);
              this.updateFabricObjectsSize(redrawOccasion);
              break;


            case RedrawOccasion.windowResize:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;


            case RedrawOccasion.forceRedraw:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            default:
              throw new Error("unknown redraw occasion:" + redrawOccasion);
              break;
          }

          this.fabricCanvas.renderAll(); //SHU: render only what is visible (is fabric smart enough ?)
        }


        synchronizeWithIcObjects(icObjects) {

          icObjects.any.forEach((icObj, i) => {
            this.addFabricObjectWithIcObj(icObj);
          });

        }

        fObjZIndexForIcObj(icObj) {
          var outIndex;

          //get zIndex-ordered icObj array
          const arr_icObj = Object.values(fabricIntegration.fabric_objects).map(fObj => fObj.icObj);


          //create order dict
          var mapped = arr_icObj.map(function (icObj_elt, i) {
            const mapped_obj = {
              index: i,
              object: icObj_elt,
              sortingValue: icObj_elt.zIndex,
            };

            return mapped_obj;
          })

          mapped.sort(function (a, b) {
            if (a.sortingValue > b.sortingValue) {
              return 1;
            }
            if (a.sortingValue < b.sortingValue) {
              return -1;
            }
            return 0;
          });
          // console.log("mapped", mapped);

          const dict_indexForObjectId = mapped.reduce((acc, mappedObj, index) => {
            // console.log("mappedObj", mappedObj, "index", index);
            const id_object = mappedObj.object.id;
            acc[id_object] = index;
            return acc;
          }, {});
          // console.log("dict_indexForObjectId", dict_indexForObjectId);


          //get index in order dict
          outIndex = dict_indexForObjectId[icObj.id];

          return outIndex;
        }


        addFabricObjectWithIcObj(icObj__r_free) {
          const fabricIntegration = this;
          const fabricCanvas = this.fabricCanvas;

          const infiniteCanvas = this.infiniteCanvas;

          console.log("addFabricObjectWithIcObj", "icObj", icObj__r_free);
          // const fObj = this.createFabricObjectWithIcObj(icObj);

          // var icObj_fRep = icObj__r_free.createSisterRepresentation();
          var icObj_fRep = icObj__r_free;
          const fObj_p = fabricIntegration.createFabricObjectWithIcObj_p(icObj_fRep);

          fObj_p.then(fObj => {
            manageCreatedFObj(fObj);
          });

          function manageCreatedFObj(fObj) {

            function standardRedraw(fObj) {
              const icObj = fObj.icObj;
              fObj.set({
                opacity: icObj.opacity,
                fill: icObj.fill,
              });

              if (icObj.text) {
                console.log("fObj", fObj);
                fObj.set({
                  text: icObj.text,
                  fill: icObj.textColor,
                });
              }

              switch (icObj.type) {
                case "mnrei_rectangle":
                  fObj.set({
                    width: icObj.size.width,
                    height: icObj.size.height,
                  });
                  break;
                case "arc_of_circle":
                  if (fObj.isDirty__clipPath) {
                    logger.log("standardRedraw:", "arc_of_circle", icObj.arcStart, icObj.arcEnd);
                    //set clipPath (arc of square)
                    const clipPath = fabricIntegration.createFabricClipPath_ArcOfSquare(icObj.radius, icObj.strokeWidth, icObj.arcStart, icObj.arcEnd);
                    fObj.set({
                      clipPath: clipPath,
                    });
                    fObj.isDirty__clipPath = false;
                  }
                  break;
                case "image":
                  {
                    // logger.log("standardRedraw:", "image", icObj.img);
                    fObj.setElement(icObj.img);
                    fObj.setCoords();
                  }
                  break;
                case "video":
                  {
                    // logger.log("standardRedraw:", "video", icObj.video);
                    fObj.setElement(icObj.video);
                    fObj.setCoords();
                  }
                  break;
                default:
                  break;
              }

              fabricIntegration.updateFabricObject_size_default(fObj);
              fabricIntegration.updateFabricObject_position_default(fObj);

              fabricCanvas.renderAll();
            }

            function hardRedraw() {   //REDRAw HACK
              infiniteCanvas.updateScaleAndDOffset({
                X: infiniteCanvas.scale.X * (1.0 + 1e-10),
                Y: infiniteCanvas.scale.Y * (1.0 + 1e-10),
              }, { dx: 0, dy: 0 });
              infiniteCanvas.redrawCanvas(RedrawOccasion.scaleChanged);
            }

            const innerUpdateListener = (icObj_fRep, propName, oldValue, newValue) => {
              // logger.log("innerUpdateListener", icObj_fRep.id_rep, propName, newValue);

              if (propName == "im_dying_now") {
                console.log("im_dying_now");
                if (icObj_fRep.im_dying_now) {
                  fabricIntegration.removeFabricObject(fObj);
                  icObj_fRep.im_dying_now = false;
                  icObj_fRep.im_dead_now = true;
                }
              }
              else if (propName == "im_active_now") {
                console.log("im_active_now");
                if (icObj_fRep.im_active_now) {
                  fabricIntegration.fabricCanvas.setActiveObject(fObj);
                }
              }
              else if (propName == "isLocked") {
                console.log("isLocked");
                if (icObj_fRep.isLocked) {
                  fabricIntegration.lockFObj(fObj);
                }
                else {
                  fabricIntegration.unlockFObj(fObj);
                }
              }
              else if (propName == "icObj__activeSelection") {
                console.log("icObj__activeSelection");
                if (icObj_fRep.icObj__activeSelection != null) {
                  //switch to group coordinates

                } else {
                  //back to individual coordinates

                }
              }

              // else if(propName == "isHeld") {
              //   console.log("innerUpdate", "isHeld");
              // }
              else if (propName == "zIndex") {
                const zIndex_icObj = icObj_fRep.zIndex;
                console.log("zIndex_icObj", zIndex_icObj);

                // fObj.moveTo(zIndex_icObj);
                const zIndex_fObj__target = fabricIntegration.fObjZIndexForIcObj(icObj_fRep);
                fObj.moveTo(zIndex_fObj__target);

                //debug
                const zIndex_fObj__actual = fObj.getFObjZIndex();
                console.log("zIndex_fObj__actual", zIndex_fObj__actual);
              }


              // else if(propName == "text") {
              //   logger.log("innerUpdate, text", fObj.text);
              //   standardRedraw(fObj);
              // }
              else if (propName == "tex"
                || propName == "mathNode"
                || propName == "richMathNode") {

                if (fObj.refreshTex_p != null) {
                  fObj.refreshTex_p()
                    .then((fObj) => {
                      standardRedraw(fObj);
                      // hardRedraw();
                    });
                }

              }
              else if (propName == "htmlElt") {
                fObj.refreshScreenshot_p()
                  .then((fObj) => {
                    standardRedraw(fObj);
                  });
              }
              else if (propName == "arcStart" || propName == "arcEnd") {
                fObj.isDirty__clipPath = true;
                standardRedraw(fObj);
              }
              else if (propName == "img") {
                // fObj.refreshImg_p()
                // .then((fObj) => {
                //   standardRedraw(fObj);
                // });
                logger.log("log1", "icObj_fRep", "onInnerUpdate", "img", icObj_fRep);

                fObj.setElement(icObj.img);
                fObj.setCoords();
                fabricCanvas.renderAll();   //added for icVideo img refresh
                // standardRedraw(fObj);
              }
              else if (propName == "video") {
                // fObj.refreshImg_p()
                // .then((fObj) => {
                //   standardRedraw(fObj);
                // });
                console.log("icObj_fRep", "onInnerUpdate", "video", icObj_fRep);
                fObj.setElement(icObj.video);
                fObj.setCoords();
              }
              else if (propName == "backgroundColor") {
                // logger.log("innerUpdateListener", "backgroundColor");
                fObj.set({
                  backgroundColor: newValue,
                });
                standardRedraw(fObj);
              }
              else {
                // logger.log("icObj_fRep","onInnerUpdate", icObj_fRep);
                standardRedraw(fObj);

                // if(icObj.type == "sparkle") {
                //
                // }
              }

            };
            fObj.fListener_inner = innerUpdateListener;
            icObj_fRep.onInnerUpdate(innerUpdateListener);

            // const outerUpdateListener = (icObj_fRep) => {
            const outerUpdateListener = (icObj_fRep, propName, oldValue, newValue) => {
              // logger.log("outerUpdateListener", icObj_fRep.id_rep, propName, newValue);

              if (propName == "im_dying_now") {
                console.log("im_dying_now");
                if (icObj_fRep.im_dying_now) {
                  fabricIntegration.removeFabricObject(fObj);
                  icObj_fRep.im_dying_now = false;
                  icObj_fRep.im_dead_now = true;
                }
              }
              else if (propName == "isLocked") {
                console.log("isLocked");
                if (icObj_fRep.isLocked) {
                  fabricIntegration.lockFObj(fObj);
                }
                else {
                  fabricIntegration.unlockFObj(fObj);
                }
              }
              // else if(propName == "isHeld") {
              //   console.log("outerUpdate", "isHeld");
              // }
              else if (propName == "text") {
                // logger.log("outerUpdate, text", fObj.text);
                standardRedraw(fObj);
              }
              else if (propName == "tex"
                || propName == "mathNode"
                || propName == "richMathNode") {

                if (fObj.refreshTex_p != null) {
                  fObj.refreshTex_p()
                    .then((fObj) => {
                      standardRedraw(fObj);
                      // hardRedraw();
                    });
                }

              }
              else if (propName == "htmlElt") {
                fObj.refreshScreenshot_p()
                  .then((fObj) => {
                    standardRedraw(fObj);
                  });
              }
              else if (propName == "img") {
                console.log("log1", "icObj_fRep", "onOuterUpdate", "img", icObj_fRep);

                // fObj.refreshImg_p()
                // .then((fObj) => {
                //   standardRedraw(fObj);
                // });

                fObj.setElement(icObj.img);
                fObj.setCoords();
              }
              else if (propName == "video") {
                console.log("icObj_fRep", "onOuterUpdate", "video", icObj_fRep);

                // fObj.refreshImg_p()
                // .then((fObj) => {
                //   standardRedraw(fObj);
                // });

                fObj.setElement(icObj.video);
                fObj.setCoords();
              }
              else {
                console.log("icObj_fRep", "onOuterUpdate", icObj_fRep);
                standardRedraw(fObj);
              }

            };
            fObj.fListener_outer = outerUpdateListener;
            icObj_fRep.onOuterUpdate(outerUpdateListener);


            // if(icObj_fRep.onHold != null) {
            //   icObj_fRep.onHold((icObj) => {
            //
            //   });
            // }
            //
            // if(icObj_fRep.onRelease != null) {
            //   icObj_fRep.onRelease((icObj) => {
            //
            //   });
            // }


            if (fObj) {
              fabricIntegration.addOuterFabricObject(fObj);
            }

            //"initial refresh"
            const icObj = fObj.icObj;
            if (icObj.type == "tex"
              || icObj.type == "mathNode"
              || icObj.type == "richMathNode") {

              if (fObj.refreshTex_p != null) {
                fObj.refreshTex_p()
                  .then((fObj) => {
                    fabricCanvas.renderAll();
                    standardRedraw(fObj);         //SHU: rajouté pour que les TeX (tout simples) spawnent correctement
                    // hardRedraw();
                  });
              }

            }
            else if (icObj.type == "htmlElt") {
              fObj.refreshScreenshot_p()
                .then((fObj) => {
                  fabricCanvas.renderAll();
                });
            }


            if (icObj.im_active_now) {
              fabricIntegration.fabricCanvas.setActiveObject(fObj);

              icObj.nowHeld();

              //SHU TODO
              //while held, position offset should follow cursor offset     (a DSL would be nice someday)

            }

            standardRedraw(fObj);

          }

        }

        lockFObj(fObj) {
          fObj.lockMovementX = true;
          fObj.lockMovementY = true;
          fObj.lockRotation = true;
          fObj.lockScalingFlip = true;
          fObj.lockScalingX = true;
          fObj.lockScalingY = true;
          fObj.lockSkewingX = true;
          fObj.lockSkewingY = true;

          fObj.selectable = false;
        }

        unlockFObj(fObj) {
          fObj.lockMovementX = false;
          fObj.lockMovementY = false;
          fObj.lockRotation = false;
          fObj.lockScalingFlip = false;
          fObj.lockScalingX = false;
          fObj.lockScalingY = false;
          fObj.lockSkewingX = false;
          fObj.lockSkewingY = false;

          fObj.selectable = true;
        }


        addFabricObjectWithPureIcObj(icObj) {

          const fObj = this.createFabricObjectWithIcObj(icObj);

          if (fObj) {
            this.addPureOuterFabricObject(fObj);
          }

        }

        createFabricObjectWithIcObj_p(icObj) {
          var fObj_p = null;

          switch (icObj.type) {
            case "rect":
              {
                const fObj = this.createFabricRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "text":
            case "tag":
              {
                const fObj = this.createFabricITextWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "image":
              {
                const fObj = this.createFabricImageWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "video":
              {
                const fObj = this.createFabricVideoWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            case "point":
              {

                var fObj;
                switch (icObj.pointType) {
                  case "rect":
                    fObj = this.createFabricRectWithIcPoint(icObj);
                    break;
                  case "cross":
                    fObj = this.createFabricCrossWithIcObj(icObj);
                    break;
                  case "circle":
                    fObj = this.createFabricCircleWithIcPoint(icObj);
                    break;
                  case "composite":
                    fObj = this.createFabricCompositeWithIcObj__point(icObj);
                    break;
                  default:
                    // fObj = this.createFabricRectWithIcPoint(icObj);
                    fObj = this.createFabricCircleWithIcPoint(icObj);
                    break;
                }

                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "spotPoint":
              {
                const fObj = this.createFabricSpotPointWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            case "circle":
              {
                const fObj = this.createFabricCircleWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "ellipse":
              {
                const fObj = this.createFabricEllipseWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            case "arc_of_square":
              {
                const fObj = this.createFabricArcOfSquareWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "arc_of_circle":
              {
                const fObj = this.createFabricArcOfCircleWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "arc_of_ellipse":
              {
                const fObj = this.createFabricArcOfEllipseWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "arc_of_path":
              {
                const fObj = this.createFabricArcOfPathWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "polygon":
              {
                const fObj = this.createFabricPolygon(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "freeDrawing":
              {
                // fObj = this.createFabricPolylineWithIcFreeDrawing(icObj);

                const fObj = this.createFabricFreeDrawingWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "svg":
              {
                fObj_p = this.createFabricSvgWithIcObj_p(icObj);
              }
              break;

            case "tex":
              {
                const fObj = this.createFabricTexWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "mathNode":
              {
                const fObj = this.createFabricMathNodeWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "richMathNode":
              {
                const fObj = this.createFabricRichMathNodeWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "mnrei_rectangle":
              {
                const fObj = this.createFabricRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "htmlElt":
              {
                const fObj = this.createFabricHtmlEltWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;



            case "group":
              {
                const fObj = this.createFabricGroupWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;





            case "toggleRect":
              {
                const fObj = this.createFabricToggleRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            case "snapSlot":
              {
                const fObj = this.createFabricSnapSlotWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "touchSlot":
              {
                const fObj = this.createFabricTouchSlotWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "dropTouchSlot":
              {
                const fObj = this.createFabricDropTouchSlotWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            case "composite":
              {
                const fObj = this.createFabricCompositeWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "button":
              {
                const fObj = this.createFabricButtonWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;




            case "well":
              {
                const fObj = this.createFabricWellWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "greenMouseWell":
              {
                const fObj = this.createFabricGreenMouseWellWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            case "rxSubject":
              {
                const fObj = this.createFabricRxSubjectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "rxSubscription":
              {
                const fObj = this.createFabricRxSubscriptionWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;



            case "observer":
              {
                const fObj = this.createFabricRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "trigger":
              {
                const fObj = this.createFabricRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "eventEmitter":
              {
                const fObj = this.createFabricRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "eventReceiver":
              {
                const fObj = this.createFabricRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "eye":
              {
                const fObj = this.createFabricEyeWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


              
            case "line":
              {
                const fObj = this.createFabricLineWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "segment":
              {
                const fObj = this.createFabricSegmentWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


              case "spotLine":
              {
                const fObj = this.createFabricLineWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "spotSegment":
              {
                const fObj = this.createFabricSegmentWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "HUD_line":
              {
                const fObj = this.createFabricLineWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "HUD_segment":
              {
                const fObj = this.createFabricSegmentWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            case "replay":
              {
                const fObj = this.createFabricReplayWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "pathmadeOperator":
              {
                const fObj = this.createFabricPathmadeOperatorWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;



            case "sparkle":
              {
                const fObj = this.createFabricSparkleWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            default:
              throw new Error("addFabricObjectWithIcObj " + "unsupported type: " + icObj.type);
              break;
          }

          //common props
          fObj_p = fObj_p.then(fObj => {
            fObj.opacity = icObj.opacity;

            if (icObj.isLocked) {
              this.lockFObj(fObj);
            }

            return fObj;
          });

          return fObj_p;
        }


        createFabricRectWithIcObj(icObj) {
          console.log("createFabricRectWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          // if(icObj.homeScale != null) {
            const position_screen = icObj.getScreenPositionWithoutOffset();
            // console.log("position_screen", position_screen);
            const homeSize_screen = icObj.getHomeScreenSize();
            // console.log("homeSize_screen", homeSize_screen);

            fObj.set({
              left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
              top:  position_screen.y,

              width:  homeSize_screen.width,
              height: homeSize_screen.height,

              scaleX: icObj.scale.X,
              scaleY: icObj.scale.Y,

              flipX: icObj.flip.X,
              flipY: icObj.flip.Y,


              angle: icObj.orientation,


              stroke: icObj.stroke,
              strokeWidth: icObj.strokeWidth,

              // fill: '#f55',
              // fill: 'red',
              fill: icObj.fill,

              // opacity: 0.7,

              // icObjId  : icObj.id,
              // trueRect : trueRect,
              icObj: icObj,
            });
          // } else {

          // }


          

          if (icObj.isSharpRect) {
            fObj.set({
              rx: 0,
              ry: 0,
            });
          }

          if (icObj.originX != null) {
            fObj.set({
              originX: icObj.originX,
            });
          }
          if (icObj.originY != null) {
            fObj.set({
              originY: icObj.originY,
            });
          }

          if (icObj.isUsingCenterPosition != null && icObj.isUsingCenterPosition) {
            fObj.set({
              originX: icObj.originX,
              originY: icObj.originY,
            });
          }

          // console.log("----", "fObj", fObj);

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);




          //debug
          // fObj.setControlsVisibility({
          //    mt: false,
          //    mb: false,
          //    ml: false,
          //    mr: false,
          //
          //    tl: true,
          //    tr: false,
          //    br: false,
          //    bl: false,
          //
          //    mtr: true,
          // });

          // fObj.hasControls = false;
          fObj.hasBorders = true;


          return fObj;

        }

        createFabricRectWithIcPoint(icObj) {
          console.log("createFabricRectWithIcPoint", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          const point_precision_factor = 100;
          const pointSize = {
            width: point_precision_factor,
            height: point_precision_factor,
          };
          const pointScale = {
            X: point_precision_factor * infiniteCanvas.scale.X,
            Y: point_precision_factor * infiniteCanvas.scale.Y,
          };

          var fObj = this.createFabricRectWithIcObj(icObj);
          fObj.set({
            width: pointSize.width,
            height: pointSize.height,

            strokeWidth: 1,
            stroke: "pink",
            fill: "black",

            originX: "center",
            originY: "center",

            icObj: icObj,
          });

          // var fRect = this.createFabricRectWithIcObj(icObj);
          // fRect.set({
          //   width:  pointSize.width,
          //   height: pointSize.height,
          //
          //   strokeWidth: 1,
          //   stroke: "pink",
          //   fill: "black",
          //
          //   originX: "center",
          //   originY: "center",
          // });
          //
          // var fObj = new fabric.Group();
          // fObj.addWithUpdate();
          // fObj.set({
          //   scaleX: pointScale.X,
          //   scaleY: pointScale.Y,
          //
          //   icObj: icObj,
          // });

          return fObj;
        }


        createFabricITextWithIcObj(icObj) {
          // console.log("createFabricITextWithIcObj", icObj);

          const scale = this.infiniteCanvas.scale;

          var fObj = new fabric.IText(icObj.text);
          fObj.set({
            left: icObj.position.x,
            top: icObj.position.y,
            // width:  100,
            // height: 100,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,


            fontSize: icObj.fontSize,

            // scaleX: scale,
            // scaleY: scale,

            // fill: '#f55',
            // fill: 'black',
            fill: icObj.textColor,
            backgroundColor: icObj.backgroundColor ? icObj.backgroundColor : "",

            // opacity: 0.7,


            //~'persistent'
            // birth_scale : birth_scale,

            // trueRect : trueRect,
            // true_fontSize : true_fontSize,
            icObj: icObj,

          });

          //initial size poll
          icObj.size = {          //SHU TODO: convert screen coords to infiniteCanvas coords
            width: fObj.width,
            height: fObj.height,
          };

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          this.addInteraction_editText(fObj);

          return fObj;
        }

        createFabricImageWithIcObj(icObj) {

          // const scale  = infiniteCanvas.scale;

          var fObj = new fabric.Image(icObj.img);

          fObj.set({
            left: icObj.position.x,
            top: icObj.position.y,

            // width:  icObj.img.width,
            // height: icObj.img.height,

            // width:  icObj.size.width,
            // height: icObj.size.height,

            width: 100,
            height: 100,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            icObj: icObj,
          });


          if (icObj.force_width) {
            const factor__force_width = icObj.width / icObj.img.width;
            fObj.set({
              scaleX: fObj.scaleX * factor__force_width,
            });
          }
          if (icObj.force_height) {
            const factor__force_height = icObj.height / icObj.img.height;
            fObj.set({
              scaleY: fObj.scaleY * factor__force_height,
            });
          }

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }

        createFabricVideoWithIcObj(icObj) {
          logger.log("log1", "createFabricVideoWithIcObj", icObj);

          // const scale  = infiniteCanvas.scale;

          var fObj = new fabric.Image(icObj.canvasElt);

          fObj.set({
            left: icObj.position.x,
            top: icObj.position.y,

            // width:  icObj.video.width,
            // height: icObj.video.height,

            // width:  icObj.size.width,
            // height: icObj.size.height,

            width: 100,
            height: 100,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            objectCaching: false,  //??


            strokeWidth: 2,
            stroke: "yellow",

            fill: "cyan",

            icObj: icObj,
          });


          if (icObj.force_width) {
            const factor__force_width = icObj.width / icObj.img.width;
            fObj.set({
              scaleX: fObj.scaleX * factor__force_width,
            });
          }
          if (icObj.force_height) {
            const factor__force_height = icObj.height / icObj.img.height;
            fObj.set({
              scaleY: fObj.scaleY * factor__force_height,
            });
          }

          fObj.setCoords();


          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }






        createFabricSpotPointWithIcObj(icObj) {
          logger.log("createFabricSpotPointWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Circle();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          logger.log("homeSize_screen", homeSize_screen);

          fObj.set({
            // left: position_screen.x,
            // top:  position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            // radius: icObj.radius,
            radius: icObj.size.width / 2.0,

            strokeWidth: icObj.strokeWidth,
            // stroke: 'blue',
            stroke: icObj.stroke,


            // fill: '#f55',
            // fill: 'red',
            // fill: '',
            fill: icObj.fill,


            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          if (icObj.isUsingCenterPosition != null && icObj.isUsingCenterPosition) {
            fObj.set({
              originX: "center",
              originY: "center",
            });
          }

          fObj.setPositionByOrigin(icObj.position, "center", "center");

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }


        createFabricCircleWithIcPoint(icObj) {
          logger.log("createFabricCircleWithIcPoint", icObj);

          const fabricIntegration = this;

          // console.log("createFabricCircleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Circle();

          const radius__default = 5;

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:  position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,


            radius: radius__default,

            // fill: '#f55',
            // fill: 'blue',
            fill: icObj.fillColor,

            stroke: 'black',
            strokeWidth: 2,

            // opacity: 0.7,

            originX: "center",
            originY: "center",

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          // if(icObj.canBeResized) {
          //   this.addInteraction_resize2(fObj);
          // }
          // if(icObj.canBeRotated) {
          //   this.addInteraction_rotate(fObj);
          // }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;

        }

        createFabricCrossWithIcObj(icObj) {
          logger.log("createFabricCrossWithIcObj", icObj);

          const fabricIntegration = this;
          const infiniteCanvas = this.infiniteCanvas;

          const radius__default = 100;
          const strokeWidth__default = 0.05;

          const position_screen = icObj.getScreenPositionWithoutOffset();
          logger.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          logger.log("homeSize_screen", homeSize_screen);

          var fRect1 = new fabric.Rect(); //horizontal rect
          fRect1.set({
            width: 2 * radius__default,
            height: strokeWidth__default,

            originX: "center",
            originY: "center",

            cornerStyle: '',
            rx: 0,
            ry: 0,

            stroke: "black",
            strokeWidth: strokeWidth__default,

            fill: "black",
          });

          var fRect2 = new fabric.Rect(); //vertical rect
          fRect2.set({
            width: strokeWidth__default,
            height: 2 * radius__default,

            originX: "center",
            originY: "center",

            cornerStyle: '',
            rx: 0,
            ry: 0,

            stroke: "black",
            strokeWidth: strokeWidth__default,

            fill: "black",
          });


          var fCross = new fabric.Group();
          fCross.set({
            width: 2 * radius__default,
            height: 2 * radius__default,

            originX: "center",
            originY: "center",
          });
          fCross.add(...[fRect1, fRect2]);
          // fCross.addWithUpdate(...[fRect1,fRect2]);

          var fObj = fCross;
          fCross.set({

            scaleX: infiniteCanvas.scale.X * 100,
            scaleY: infiniteCanvas.scale.X * 100,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,
            // angle : 45,

            // fill: '#f55',
            // fill: 'blue',
            // fill: icObj.fillColor,

            originX: "center",
            originY: "center",


            // opacity: 0.7,
            icObj: icObj,
          });

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          // if(icObj.canBeResized) {
          //   this.addInteraction_resize2(fObj);
          // }
          // if(icObj.canBeRotated) {
          //   this.addInteraction_rotate(fObj);
          // }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }



        createFabricCircleWithIcObj(icObj) {
          logger.log("createFabricCircleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Circle();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,
            top:  position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            radius: icObj.radius,

            strokeWidth: icObj.strokeWidth,
            // stroke: 'blue',
            stroke: icObj.stroke,


            // fill: '#f55',
            // fill: 'red',
            // fill: '',
            fill: icObj.fill,


            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          if (icObj.isUsingCenterPosition != null && icObj.isUsingCenterPosition) {
            fObj.set({
              originX: "center",
              originY: "center",
            });
          }

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }


        createFabricEllipseWithIcObj(icObj) {
          logger.log("createFabricEllipseWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Ellipse();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            //radius: icObj.radius,
            rx: homeSize_screen.width / 2.0,
            ry: homeSize_screen.height / 2.0,

            // fill: '#f55',
            // fill: 'red',
            // fill: '',
            fill: icObj.fill,

            // stroke: 'blue',
            stroke: icObj.stroke,
            strokeWidth: 5,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }


        createFabricArcOfSquareWithIcObj(icObj) {
          logger.log("createFabricArcOfSquareWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          //create square
          var fObj = this.createFabricRectWithIcObj(icObj);

          //set clipPath
          const radius = icObj.radius + icObj.strokeWidth;;

          const point0 = Geometry.createPoint(0, 0);
          const pointC1 = Geometry.pointOnSquare__angleInDegrees(point0, radius, icObj.arcStart);
          const pointC2 = Geometry.pointOnSquare__angleInDegrees(point0, radius, icObj.arcEnd);

          const arr_angle__corners = [...Array(4).keys()].map(index => 45 + index * 90);
          logger.log("arr_angle__corners", arr_angle__corners);
          const dict_point__corners = Object.fromEntries(arr_angle__corners.map(angle => {
            const point = Geometry.pointOnSquare__angleInDegrees(point0, radius, angle);
            return [angle, point];
          }));

          const dict_point__arc = {
            [icObj.arcStart]: pointC1,
            [icObj.arcEnd]: pointC2,
          };

          const dict_point = Object.assign(dict_point__corners, dict_point__arc);
          logger.log("dict_point", dict_point);

          var arr_point = Object.entries(dict_point).filter(([angle, point]) => {
            const isBetween = (icObj.arcStart <= angle) && (angle <= icObj.arcEnd);
            return isBetween;
          }).sort((e1, e2) => {
            return e1.angle < e2.angle;
          }).map(([angle, point]) => point);
          logger.log("arr_point", arr_point);

          arr_point = [point0].concat(arr_point);

          var clipPath = new fabric.Polygon(arr_point);

          logger.log("clipPath", clipPath);
          fObj.clipPath = clipPath;

          return fObj;
        }


        createFabricArcOfCircleWithIcObj(icObj) {
          logger.log("createFabricArcOfCircleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          //create circle
          var fObj = this.createFabricCircleWithIcObj(icObj);

          //set clipPath (arc of square)
          var clipPath = this.createFabricClipPath_ArcOfSquare(icObj.radius, icObj.strokeWidth, icObj.arcStart, icObj.arcEnd);
          logger.log("clipPath", clipPath);

          fObj.clipPath = clipPath;

          return fObj;
        }

        createFabricClipPath_ArcOfSquare(radius_in, strokeWidth, arcStart, arcEnd) {
          const radius = radius_in + strokeWidth;

          const point0 = Geometry.createPoint(0, 0);
          const pointC1 = Geometry.pointOnSquare__angleInDegrees(point0, radius, arcStart);
          const pointC2 = Geometry.pointOnSquare__angleInDegrees(point0, radius, arcEnd);

          const arr_angle__corners = [...Array(4).keys()].map(index => 45 + index * 90);
          logger.log("arr_angle__corners", arr_angle__corners);
          const dict_point__corners = Object.fromEntries(arr_angle__corners.map(angle => {
            const point = Geometry.pointOnSquare__angleInDegrees(point0, radius, angle);
            return [angle, point];
          }));

          const dict_point__arc = {
            [arcStart]: pointC1,
            [arcEnd]: pointC2,
          };

          const dict_point = Object.assign(dict_point__corners, dict_point__arc);
          logger.log("dict_point", dict_point);

          var arr_point = Object.entries(dict_point).filter(([angle, point]) => {
            const isBetween = (arcStart <= angle) && (angle <= arcEnd);
            return isBetween;
          }).sort((e1, e2) => {
            return e1.angle < e2.angle;
          }).map(([angle, point]) => point);
          logger.log("arr_point", arr_point);

          arr_point = [point0].concat(arr_point);

          var clipPath = new fabric.Polygon(arr_point);

          return clipPath;
        }

        createFabricArcOfEllipseWithIcObj(icObj) {
          logger.log("createFabricArcOfEllipseWithIcObj", icObj);


          return fObj;

        }

        createFabricArcOfPathWithIcObj(icObj) {
          logger.log("createFabricArcOfPathWithIcObj", icObj);



          return fObj;

        }

        createFabricPolygon(icObj) {
          logger.log("createFabricPolygon", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          //create polygon
          var fObj = new fabric.Polygon(icObj.arr_point);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,
            top: position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            //radius: icObj.radius,
            rx: homeSize_screen.width / 2.0,
            ry: homeSize_screen.height / 2.0,

            // fill: '#f55',
            // fill: 'red',
            // fill: '',
            fill: icObj.fill,

            // stroke: 'blue',
            stroke: icObj.stroke,
            strokeWidth: 5,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;
        }



        createFabricSvgWithIcFreeDrawing(icObj) {
          console.log("createFabricSvgWithIcFreeDrawing", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,



            fill: icObj.fill,

            // opacity: 0.7,

            icObj: icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }



        createFabricSvgWithIcObj_p(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const dataUrl = SvgHelper.toDataURL(icObj.svg);

          const promise = new Promise((resolve, reject) => {

            fabric.Image.fromURL(dataUrl, function (img) {
              console.log("img", img);
              // fabricCanvas.add(img);
              // console.log('CORS enabled + crossOrigin property - DataURL: ', img.toDataURL());
              resolve(img);
            },
              null,
              {
                crossOrigin: 'Anonymous',
              });

          });

          const promise2 = promise.then((fObj) => {

            fObj.set({
              left: icObj.position.x,
              top: icObj.position.y,

              width: fObj.width,
              height: fObj.height,
              // width:  icObj.size.width,
              // height: icObj.size.height,


              scaleX: icObj.scale.X,
              scaleY: icObj.scale.Y,

              flipX: icObj.flip.X,
              flipY: icObj.flip.Y,

              angle: icObj.orientation,

              icObj: icObj,
            });

            // const width  = icObj.size.width;
            // const height = icObj.size.height;
            // fObj.scaleToHeight(width);
            // fObj.scaleToWidth(height);


            //event listeners
            if (icObj.canBeHeld) {
              this.addInteraction_hold(fObj);
            }
            if (icObj.canBeMoved) {
              this.addInteraction_move(fObj);
            }
            if (icObj.canBeResized) {
              this.addInteraction_resize2(fObj);
            }
            if (icObj.canBeRotated) {
              this.addInteraction_rotate(fObj);
            }


            this.addInteraction_select(fObj);
            // this.addListeners(fObj);

            return fObj;
          });

          return promise2;
        }


        createFabricTexWithIcObj(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left: icObj.position.x,
            top: icObj.position.y,

            width: icObj.size.width,
            height: icObj.size.height,


            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            originX: "left",
            originY: "top",


            icObj: icObj,
          });


          fObj.refreshTex_p = () => {
            console.log("refreshTex");

            const tex = icObj.tex;
            const fill = icObj.fill;

            const svgEl = TexHelper.toSvgEl(tex, fill);
            const dataUrl = SvgHelper.toDataURL(svgEl);
            const fObj_svg_image_p = new Promise((resolve, reject) => {

              fabric.Image.fromURL(dataUrl, function (img) {
                console.log("img", img);
                // fabricCanvas.add(img);
                // console.log('CORS enabled + crossOrigin property - DataURL: ', img.toDataURL());

                // img.set({
                //   originX: "left",
                //   originY: "top",
                //   left:0,
                //   top:0,
                // });
                // img.setCoords();

                resolve(img);
              },
                null,
                {
                  crossOrigin: 'Anonymous',
                });

            });

            const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
              if (fObj.child_tex != null) {
                fObj.remove(fObj.child_tex);
              }

              //add svg image as child
              fObj.child_tex = fObj_child;

              // fObj.add(fObj_child);
              fObj.addWithUpdate(fObj_child);
              console.log("fObj, added child:", fObj_child);

              /*
              fObj.set({
                width:  icObj.size.width,
                height: icObj.size.height,
              });
              */


              function adapt_child() {
                const width = icObj.size.width;
                const height = icObj.size.height;
                fObj_child.scaleToHeight(width);
                fObj_child.scaleToWidth(height);
              }

              function adapt_group() {
                fObj.set({
                  width: fObj_child.width,
                  height: fObj_child.height,
                });
              }

              adapt_child();


              return fObj;
            });

            return add_fObjfObj_svg_image_p;
          };

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          // fObj.refreshTex_p()
          // .then((fObj) => {
          //   fabricCanvas.renderAll();
          // });

          return fObj;
        }


        // createFabricMathNodeWithIcObj(icObj) {
        //
        //   const fabricCanvas = this.fabricCanvas;
        //
        //   const fObj = new fabric.Group();
        //
        //   fObj.set({
        //     left:   icObj.position.x,
        //     top:    icObj.position.y,
        //
        //     width:  icObj.size.width,
        //     height: icObj.size.height,
        //
        //
        //     scaleX: icObj.scale.X,
        //     scaleY: icObj.scale.Y,
        //
        //     flipX:   icObj.flip.X,
        //     flipY:   icObj.flip.Y,
        //
        //     angle :  icObj.orientation,
        //
        //     originX: "left",
        //     originY: "top",
        //
        //
        //     icObj: icObj,
        //   });
        //
        //
        //   fObj.refreshTex_p = () => {
        //     console.log("refreshTex");
        //
        //     const tex   = icObj.mathNode.toTex();
        //     console.log("tex:", tex);
        //
        //     function upgradeTex(tex) {
        //       var outTex;
        //
        //       outTex = tex.replaceAll("\\cdot", "\\times");
        //
        //       return outTex;
        //     }
        //
        //     const tex_upgraded = upgradeTex(tex);
        //
        //     const fill  = icObj.fill;
        //
        //     // const svgEl   = TexHelper.toSvgEl(tex, fill);
        //     const svgEl   = TexHelper.toSvgEl(tex_upgraded, fill);
        //
        //     svgEl.setAttribute("width",  fObj.width);
        //     svgEl.setAttribute("height", fObj.height);
        //
        //     const dataUrl = SvgHelper.toDataURL(svgEl);
        //     const fObj_svg_image_p = new Promise((resolve, reject) => {
        //
        //       fabric.Image.fromURL(dataUrl, function (img) {
        //         // console.log("img", img);
        //
        //         const group = fObj;
        //         img.set({
        //           // left: 0,
        //           // top: 0,
        //           //SHU: that smell of Scotch Tape
        //           left: -group.width/2,
        //           top:  -group.height/2,
        //
        //           //debug
        //           // stroke: "yellow",
        //           // strokeWidth: 2,
        //         });
        //
        //         resolve(img);
        //       },
        //       null,
        //       {
        //         crossOrigin: 'Anonymous',
        //       });
        //
        //     });
        //
        //     const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
        //       if(fObj.child_tex != null) {
        //         fObj.remove(fObj.child_tex);
        //       }
        //
        //       //add svg image as child
        //       fObj.child_tex = fObj_child;
        //
        //       fObj.add(fObj_child);
        //       // fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children
        //       console.log("fObj, added child:", fObj_child);
        //
        //       return fObj;
        //     });
        //
        //     return add_fObjfObj_svg_image_p;
        //   };
        //
        //   //event listeners
        //   if(icObj.canBeHeld) {
        //     this.addInteraction_hold(fObj);
        //   }
        //   if(icObj.canBeMoved) {
        //     this.addInteraction_move(fObj);
        //   }
        //   if(icObj.canBeResized) {
        //     this.addInteraction_resize2(fObj);
        //   }
        //   if(icObj.canBeRotated) {
        //     this.addInteraction_rotate(fObj);
        //   }
        //
        //
        //   this.addInteraction_select(fObj);
        //   // this.addListeners(fObj);
        //
        //   this.addInteraction_doubleClick(fObj);
        //
        //
        //
        //   return fObj;
        // }

        createFabricMathNodeWithIcObj(icObj) {
          // logger.log("createFabricMathNodeWithIcObj", icObj);

          const fabricIntegration = this;
          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left: icObj.position.x,
            top: icObj.position.y,

            // width:  icObj.size.width,
            // height: icObj.size.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            originX: "center",
            // originX: icObj.originX ? icObj.originX : "left",
            originY: "top",


            // fill:         "yellow",
            // stroke:       icObj.stroke,
            // strokeWidth : icObj.strokeWidth,


            icObj: icObj,
          });


          fObj.refreshTex_p = () => {
            console.log("refreshTex");

            const mathNode = icObj.mathNode;

            const tex = mathNode.toTex();
            console.log("tex:", tex);

            function upgradeTex(tex) {
              var outTex;

              outTex = tex.replaceAll("\\cdot", "\\times");

              return outTex;
            }

            const tex_upgraded = upgradeTex(tex);

            const fill = icObj.fill;

            // const svgEl   = TexHelper.toSvgEl(tex, fill);
            const svgEl = TexHelper.toSvgEl(tex_upgraded, fill);

            // svgEl.setAttribute("width",  fObj.width);
            // svgEl.setAttribute("height", fObj.height);
            // logger.log('svgEl.getAttribute("width")',  svgEl.getAttribute("width"));
            // logger.log('svgEl.getAttribute("height")', svgEl.getAttribute("height"));
            const width_ex__svgEl = parseFloat(svgEl.getAttribute("width").replace("ex", ""));
            const height_ex__svgEl = parseFloat(svgEl.getAttribute("height").replace("ex", ""));

            const depth__mathNode = getDepth(icObj.mathNode);

            const scaleFactor = Math.max(20, 70 - depth__mathNode * 8);
            // const scaleFactor     = 10 + depth__mathNode * 10;

            const width_px__svgEl = width_ex__svgEl * scaleFactor;
            const height_px__svgEl = height_ex__svgEl * scaleFactor;
            // logger.log('width_px__svgEl',   width_px__svgEl);
            // logger.log('height_px__svgEl',  height_px__svgEl);

            fObj.set({
              width: width_px__svgEl,
              height: height_px__svgEl,

              // fill:         "yellow",
              // stroke:       icObj.stroke,
              // strokeWidth : icObj.strokeWidth,
            });

            const dataUrl = SvgHelper.toDataURL(svgEl);
            const fObj_svg_image_p = new Promise((resolve, reject) => {

              fabric.Image.fromURL(dataUrl, function (img) {
                // console.log("img", img);

                const group = fObj;
                img.set({
                  // left: 0,
                  // top: 0,
                  //SHU: that smell of Scotch Tape
                  left: -group.width / 2,
                  top: -group.height / 2,

                  // width:  group.width,
                  // height: group.height,
                  // width:  width_px__svgEl,
                  // height: height_px__svgEl,

                  //debug
                  // stroke: "yellow",
                  // strokeWidth: 2,

                  stroke: icObj.stroke,
                  strokeWidth: icObj.strokeWidth,
                });

                img.scaleToWidth(width_px__svgEl);
                img.scaleToHeight(height_px__svgEl);

                resolve(img);
              },
                null,
                {
                  crossOrigin: 'Anonymous',
                });

            });

            const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
              if (fObj.child_tex != null) {
                fObj.remove(fObj.child_tex);
              }

              //add svg image as child
              fObj.child_tex = fObj_child;

              // fObj.add(fObj_child);
              fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children    //SHU: this seems to solve the out-of-bounds drawing issue
              console.log("fObj, added child:", fObj_child);

              return fObj;
            });

            return add_fObjfObj_svg_image_p;
          };

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          this.addInteraction_doubleClick(fObj);



          return fObj;
        }


        createFabricRichMathNodeWithIcObj(icObj) {
          logger.log("createFabricRichMathNodeWithIcObj", icObj);

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left: icObj.position.x,
            top: icObj.position.y,

            // width:  icObj.size.width,
            // height: icObj.size.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            originX: "center",
            // originX: icObj.originX ? icObj.originX : "left",
            originY: "top",

            icObj: icObj,
          });


          fObj.refreshTex_p = () => {
            console.log("refreshTex");

            const richMathNode = icObj.richMathNode;
            const mathNode = richMathNode.mathNode;

            // const tex   = mathNode.toTex();
            const tex = richMathNode.toTex();
            logger.log("tex:", tex);

            function upgradeTex(tex) {
              var outTex;

              outTex = tex.replaceAll("\\cdot", "\\times");

              // outTex = "{\\color{blue} 0} {\\color{white} +} {\\color{red} 1}";

              return outTex;
            }

            const tex_upgraded = upgradeTex(tex);

            const fill = icObj.fill;

            // const svgEl   = TexHelper.toSvgEl(tex, fill);
            const svgEl = TexHelper.toSvgEl(tex_upgraded, fill);

            // svgEl.setAttribute("width",  fObj.width);
            // svgEl.setAttribute("height", fObj.height);
            // logger.log('svgEl.getAttribute("width")',  svgEl.getAttribute("width"));
            // logger.log('svgEl.getAttribute("height")', svgEl.getAttribute("height"));
            const width_ex__svgEl = parseFloat(svgEl.getAttribute("width").replace("ex", ""));
            const height_ex__svgEl = parseFloat(svgEl.getAttribute("height").replace("ex", ""));


            const depth__mathNode = getDepth(mathNode);

            const scaleFactor = Math.max(20, 70 - depth__mathNode * 8);
            // const scaleFactor     = 10 + depth__mathNode * 10;

            const width_px__svgEl = width_ex__svgEl * scaleFactor;
            const height_px__svgEl = height_ex__svgEl * scaleFactor;
            // logger.log('width_px__svgEl',   width_px__svgEl);
            // logger.log('height_px__svgEl',  height_px__svgEl);

            fObj.set({
              width: width_px__svgEl,
              height: height_px__svgEl,
            });

            const dataUrl = SvgHelper.toDataURL(svgEl);
            const fObj_svg_image_p = new Promise((resolve, reject) => {

              fabric.Image.fromURL(dataUrl, function (img) {
                // console.log("img", img);

                const group = fObj;
                img.set({
                  // left: 0,
                  // top: 0,
                  //SHU: that smell of Scotch Tape
                  left: -group.width / 2,
                  top: -group.height / 2,

                  // width:  group.width,
                  // height: group.height,
                  // width:  width_px__svgEl,
                  // height: height_px__svgEl,

                  //debug
                  // stroke: "yellow",
                  // strokeWidth: 2,
                });

                img.scaleToWidth(width_px__svgEl);
                img.scaleToHeight(height_px__svgEl);

                resolve(img);
              },
                null,
                {
                  crossOrigin: 'Anonymous',
                });

            });

            const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
              if (fObj.child_tex != null) {
                fObj.remove(fObj.child_tex);
              }

              //add svg image as child
              fObj.child_tex = fObj_child;

              fObj.add(fObj_child);
              // fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children
              console.log("fObj, added child:", fObj_child);

              return fObj;
            });

            return add_fObjfObj_svg_image_p;
          };

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          this.addInteraction_doubleClick(fObj);



          return fObj;
        }


        createFabricHtmlEltWithIcObj(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left: icObj.position.x,
            top: icObj.position.y,

            width: icObj.size.width,
            height: icObj.size.height,


            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            originX: "left",
            originY: "top",


            icObj: icObj,
          });


          fObj.refreshScreenshot_p = () => {
            console.log("refreshScreenshot_p");

            const html_elt = icObj.htmlElt;
            console.log("html_elt", html_elt);

            // const canvasElt_p = html2canvas(html_elt);
            const canvasElt_p = html2canvas(html_elt, {
              // onclone: function (clone__htmlElt) {
              // clone__htmlElt.style.visibility = "visible";
              // clone__htmlElt.style.display = "block";
              // },
            });

            const fObj_hmtlElt_image_p = canvasElt_p.then((canvasElt) => {

              function getNumericalValueForPxString(pxString) {
                return parseInt(pxString.replace("px", ""));
              }

              const width__canvasElt = getNumericalValueForPxString(canvasElt.style.width);
              const height__canvasElt = getNumericalValueForPxString(canvasElt.style.height);

              const img = new fabric.Image(canvasElt);

              const group = fObj;
              img.set({
                // left: 0,
                // top: 0,
                //SHU: that smell of Scotch Tape
                left: -group.width / 2,
                top: -group.height / 2,

                //debug
                // stroke: "yellow",
                // strokeWidth: 2,
              });

              return img;
            });

            const add_fObjfObj_htmlElt_image_p = fObj_hmtlElt_image_p.then((fObj_child) => {
              if (fObj.child_htmlScreenshot != null) {
                fObj.remove(fObj.child_htmlScreenshot);
              }

              //add image as child
              fObj.child_htmlScreenshot = fObj_child;

              // fObj.add(fObj_child);
              fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children
              console.log("fObj, added child:", fObj_child);

              return fObj;
            });

            return add_fObjfObj_htmlElt_image_p;
          };

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }


        createFabricEyeWithIcObj(icObj) {
          logger.log("log1", "createFabricEyeWithIcObj", icObj);

          // const scale  = infiniteCanvas.scale;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();

          fObj.set({
            left: position_screen.x,
            top: position_screen.y,
            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            objectCaching: false,  //??




            strokeWidth: icObj.strokeWidth,
            stroke: icObj.strokeColor,

            //transparent fill
            fill: "transparent",

            //sharp corners
            rx: icObj.rx,
            ry: icObj.ry,


            icObj: icObj,
          });
          fObj.setCoords();

          logger.log("log1", "fObj", fObj);


          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);



          //image capture loop
          {
            const fabricCanvas = this.fabricCanvas;
            const ctx = fabricCanvas.getContext('2d');

            function startRefreshLoop() {
              logger.log("log1", "startRefreshLoop");

              var counter = 1;                  /// this is used to reduce FPS

              /// register refresh loop
              function refreshLoop() {

                /// reduce frame-rate
                const nb_skipped_frames__eye = 9;
                if (counter % (nb_skipped_frames__eye + 1) == 0) {
                  captureNewFrame();
                  counter = 1;
                } else {
                  counter = counter + 1;
                }

                if (fObj.isShouldRequestAnimationFrame) {
                  requestAnimationFrame(refreshLoop);
                }




                function captureNewFrame() {
                  logger.log("log1", "captureNewFrame");

                  const rect_frame = {
                    left: fObj.left + fObj.strokeWidth,
                    top: fObj.top + fObj.strokeWidth,
                    width: fObj.width - (2 * fObj.strokeWidth),
                    height: fObj.height - (2 * fObj.strokeWidth),
                  }

                  const imageData__captured = ctx.getImageData(rect_frame.left, rect_frame.top, rect_frame.width, rect_frame.height);
                  // logger.log("imageData__captured", imageData__captured);
                  logger.log("fObj.icObj", fObj.icObj);
                  fObj.icObj.imageData__captured = imageData__captured;



                  const img__captured = ImageUtils.imageFromImageData(imageData__captured);
                  // logger.log("img__captured", img__captured);
                  fObj.icObj.img__captured = img__captured;

                }

              }

              fObj.isShouldRequestAnimationFrame = true;
              fObj.requestAnimationFrame = requestAnimationFrame(refreshLoop);

            }

            startRefreshLoop();

          }





          return fObj;
        }



        //group

        createFabricGroupWithIcObj(icObj) {
          console.log("createFabricGroupWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Group();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            fill: icObj.fill,

            // opacity: 0.7,

            icObj: icObj,
          });


          //create inner objects
          const fGroup = fObj;
          const childFObjs = icObj.children.map(icObj => {
            return this.createFabricGroupContentForFabricGroup(icObj, fGroup);
          });

          //add inner objects
          fObj.add(...childFObjs);



          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;

        }

        createFabricGroupContentForFabricGroup(icObj, fGroup) {
          const icGroup = fGroup.icObj;

          var fObj = this.createFabricObjectWithIcObj(icObj);

          //set the right coordinates:
          const icGroup_rect = Geometry.createRect(icGroup.position.x, icGroup.position.y, icGroup.size.width, icGroup.size.height);
          const fGroup_rect = Geometry.createRect(fGroup.left, fGroup.top, fGroup.width, fGroup.height);

          const position = Geometry.getPointFromRectToRect(icObj.position, icGroup_rect, fGroup_rect);

          // const offsetFromCenterToTL = {
          //   dx: -fGroup.width,
          //   dy: -fGroup.height,
          // };

          const offsetFromCenterToTL = {
            dx: -fGroup.width / 2,
            dy: -fGroup.height / 2,
          };

          fObj.set({
            left: position.x + offsetFromCenterToTL.dx,
            top: position.y + offsetFromCenterToTL.dy,
          });

          return fObj;

        }








        createFabricToggleRectWithIcObj(icObj) {
          console.log("createFabricToggleRectWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            strokeWidth: 0,

            icObj: icObj,
          });

          setTimeout(() => {  //SHU: golden hammer? setTimeout!
            configureWithIsActive(fObj, icObj.isActive);
          }, 0);

          function configureWithIsActive(fObj, isActive) {
            logger.log("configureWithIsActive", fObj, isActive);

            const cfg = isActive ? fObj.icObj.activeCfg : fObj.icObj.inactiveCfg;
            logger.log("cfg", cfg);

            fObj.set({
              fill: cfg.fill,
              opacity: cfg.opacity,
            });

            logger.log("fObj", fObj);

            fObj.dirty = true;
          }

          fObj.hasControls = false;
          fObj.hasBorders = true;


          //event listeners
          if (icObj.canBeSelected) {

            this.addInteraction_select(fObj);

            if (icObj.canBeHeld) {
              this.addInteraction_hold(fObj);
            }

            if (icObj.canBeMoved) {
              this.addInteraction_move(fObj);
            }
            if (icObj.canBeResized) {
              this.addInteraction_resize2(fObj);
            }
            if (icObj.canBeRotated) {
              this.addInteraction_rotate(fObj);
            }


            const fabricCanvas = this.fabricCanvas;

            fObj.on('mouseup', function (options) {
              console.log("mouseup", "options", options);

              const icObj = fObj.icObj;

              const isActive_update = !icObj.isActive;

              const icObj_new = Object.assign({}, icObj);
              icObj_new.isActive = isActive_update;

              icObj.update(icObj_new, false);

              configureWithIsActive(fObj, isActive_update);

              fabricCanvas.renderAll();

            });


          } else {
            fObj.selectable = false;
          }

          // this.addListeners(fObj);



          return fObj;

        }


        createFabricSnapSlotWithIcObj(icObj) {
          console.log("createFabricSnapSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj: icObj,
          });


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }

        createFabricTouchSlotWithIcObj(icObj) {
          console.log("createFabricTouchSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj: icObj,
          });


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }

        createFabricDropTouchSlotWithIcObj(icObj) {
          console.log("createFabricDropTouchSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj: icObj,
          });


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }



        createFabricCompositeWithIcObj(icObj) {
          console.log("createFabricCompositeWithIcObj", icObj);

          const fObj = this.createFabricRectWithIcObj(icObj);

          return fObj;
        }

        createFabricCompositePartWithIcObj(icObj) {
          console.log("createFabricCompositeWithIcObj", icObj);

          const fObj = this.createFabricObjectWithIcObj(icObj);

          return fObj;
        }


        createFabricButtonWithIcObj(icObj) {
          console.log("createFabricSnapSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,

            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: icObj.fill,

            icObj: icObj,
          });


          // if(icObj.canBeHeld) {
          //   this.addInteraction_hold(fObj);
          // }
          fObj.selectable = false;
          this.addInteraction_click(fObj);

          return fObj;
        }



        createFabricWellWithIcObj(icObj) {
          console.log("createFabricWellWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj: icObj,
          });


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }

        createFabricGreenMouseWellWithIcObj(icObj) {
          console.log("createFabricGreenMouseWellWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj: icObj,
          });


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }


        createFabricRxSubjectWithIcObj(icObj) {
          return this.createFabricRectWithIcObj(icObj);
        }

        createFabricRxSubscriptionWithIcObj(icObj) {
          return this.createFabricRectWithIcObj(icObj);
        }





        createFabricSegmentWithIcObj(icObj) {
          logger.log("createFabricSegmentWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Line();

          // console.log("line:", fObj);
          // throw new Error("please die here");

          function screenPointWithoutOffset(infiniteCanvas, truePoint) {
            const screenX = truePoint.x * infiniteCanvas.scale.X;
            const screenY = truePoint.y * infiniteCanvas.scale.Y;
            return Geometry.createPoint(screenX, screenY);
          }

          const screenPoint_start = screenPointWithoutOffset(infiniteCanvas, icObj.point_start);
          const screenPoint_end   = screenPointWithoutOffset(infiniteCanvas, icObj.point_end);

          fObj.set({
            x1: screenPoint_start.x,
            y1: screenPoint_start.y,

            x2: screenPoint_end.x,
            y2: screenPoint_end.y,

            // x1:   100,
            // y1:   100,
            //
            // x2:   500,
            // y2:   500,

            stroke: "black",
            strokeWidth: 5,
            fill: "red",

            // stroke:      icObj.stroke,
            // strokeWidth: icObj.strokeWidth,
            // fill:        icObj.fill,

            originY: "center",    //SHU: temporary solution: only working for horizontal segments

            icObj: icObj,
          });



          //write now known icObj props
          // const screenRect = {
          //   left: fObj.left,
          //   top: fObj.top,
          //   width: fObj.width,
          //   height: fObj.height,
          // };

          // const trueRect = infiniteCanvas.toTrueRect(screenRect);

          // icObj.position = {
          //   x: trueRect.x,
          //   y: trueRect.y,
          // };

          // icObj.size = {
          //   width: trueRect.width,
          //   height: trueRect.height,
          // };




          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }



          return fObj;
        }

        createFabricHUDSegmentWithIcObj(icObj) {
          console.log("createFabricSegmentWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Line();

          // console.log("line:", fObj);
          // throw new Error("please die here");

          const screenPoint_start = infiniteCanvas.toScreenPoint(icObj.point_start);
          logger.log("screenPoint_start", screenPoint_start);
          const screenPoint_end   = infiniteCanvas.toScreenPoint(icObj.point_end);
          logger.log("screenPoint_end", screenPoint_end);


          fObj.set({
            x1: screenPoint_start.x,
            y1: screenPoint_start.y,

            x2: screenPoint_end.x,
            y2: screenPoint_end.y,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            // x1:   100,
            // y1:   100,
            //
            // x2:   500,
            // y2:   500,

            stroke: "black",
            strokeWidth: 5,
            fill: "red",

            // stroke:      icObj.stroke,
            // strokeWidth: icObj.strokeWidth,
            // fill:        icObj.fill,

            icObj: icObj,
          });



          //write now known icObj props
          const screenRect = {
            left: fObj.left,
            top: fObj.top,
            width: fObj.width,
            height: fObj.height,
          };
          logger.log("screenRect", screenRect);

          const trueRect = infiniteCanvas.toTrueRect(screenRect);
          logger.log("trueRect", trueRect);


          icObj.position = {
            x: trueRect.left,
            y: trueRect.top,
          };

          icObj.size = {
            width: trueRect.width,
            height: trueRect.height,
          };




          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }

          return fObj;
        }






        createFabricReplayWithIcObj(icObj) {
          console.log("createFabricReplayWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,


            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,

            // fill: '#f55',
            // fill: 'red',
            fill: icObj.fill,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          if (icObj.isSharpRect) {
            fObj.set({
              rx: 0,
              ry: 0,
            });
          }

          // console.log("----", "fObj", fObj);

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);




          //debug
          // fObj.setControlsVisibility({
          //    mt: false,
          //    mb: false,
          //    ml: false,
          //    mr: false,
          //
          //    tl: true,
          //    tr: false,
          //    br: false,
          //    bl: false,
          //
          //    mtr: true,
          // });

          // fObj.hasControls = false;
          fObj.hasBorders = true;


          return fObj;
        }


        createFabricPathmadeOperatorWithIcObj(icObj) {
          console.log("createFabricPathmadeOperatorWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,


            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,

            // fill: '#f55',
            // fill: 'red',
            fill: icObj.fill,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          if (icObj.isSharpRect) {
            fObj.set({
              rx: 0,
              ry: 0,
            });
          }

          // console.log("----", "fObj", fObj);

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);




          //debug
          // fObj.setControlsVisibility({
          //    mt: false,
          //    mb: false,
          //    ml: false,
          //    mr: false,
          //
          //    tl: true,
          //    tr: false,
          //    br: false,
          //    bl: false,
          //
          //    mtr: true,
          // });

          // fObj.hasControls = false;
          fObj.hasBorders = true;


          return fObj;
        }





        createFabricFreeDrawingWithIcObj(icObj) {
          console.log("createFabricFreeDrawingWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          const exoObject = icObj.exoObject;

          var fObj = new fabric.Path(exoObject.path);

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,
            //
            // scaleX:  icObj.scale.X,
            // scaleY:  icObj.scale.Y,
            //
            // flipX:   icObj.flip.X,
            // flipY:   icObj.flip.Y,


            angle: icObj.orientation,


            stroke: exoObject.stroke,
            strokeDashArray: exoObject.strokeDashArray,
            strokeLineCap: exoObject.strokeLineCap,
            strokeLineJoin: exoObject.strokeLineJoin,
            strokeMiterLimit: exoObject.strokeMiterLimit,
            strokeWidth: exoObject.strokeWidth,

            fill: exoObject.fill,

            opacity: icObj.opacity,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);




          //debug
          fObj.setControlsVisibility({
            mt: false,
            mb: false,
            ml: false,
            mr: false,

            tl: true,
            tr: false,
            br: false,
            bl: false,

            mtr: true,
          });

          // fObj.hasControls = false;
          fObj.hasBorders = true;


          return fObj;
        }


        createFabricSparkleWithIcObj(icObj) {
          console.log("createFabricSparkleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          // var fObj = new fabric.Triangle();
          var fObj = new fabric.Image(icObj.img);


          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          // const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,
            width: icObj.img.width,
            height: icObj.img.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            // fill: '#f55',
            // fill: 'red',
            fill: icObj.fill,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          if (icObj.isUsingCenterPosition) {
            fObj.set({
              originX: "center",          //:)
              originY: "center",          //:)
            });
          }


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          return fObj;
        }







        addInteraction_move(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          fabricCanvas.on('before:transform', function (options) {
            logger.log("before:transform", "options", options);

            if(fObj.icObj.type == "segment") {
              fObj.point_start__original = fObj.icObj.point_start;
              fObj.point_end__original   = fObj.icObj.point_end;

              fObj.position__target__original = Geometry.createPoint(options.transform.target.left, options.transform.target.top);
            }

          });

          fObj.on('moving', function (options) {
            logger.log("moving", "options", options);

            const offset = infiniteCanvas.offset;
            const scale  = infiniteCanvas.scale;

            const icObj = fObj.icObj;

            //---new style: rep inner update---
            const rep_free = fObj.icObj;
            console.log("ççç on 'moving' rep_free.id_rep", rep_free.id_rep);
            const listener = fObj.fListener_inner;

            //listen:off
            rep_free.offInnerUpdate(listener);

            //mutate
            switch(icObj.type) {
              case "segment":
                {
                  const transform = options.transform;

                  // const offset__transform__screen1 = Geometry.createPoint(transform.offsetX, transform.offsetY);   //NOT WORKING
                  // logger.log("offset__transform__screen1", offset__transform__screen1);
                  
                  const offset__transform__screen2 = Geometry.createPoint(options.target.left - fObj.position__target__original.x, options.target.top - fObj.position__target__original.y); 
                  logger.log("offset__transform__screen2", offset__transform__screen2);
                  
                  const offset__transform__ic      = infiniteCanvas.toTruePoint(offset__transform__screen2);

                  const v = Geometry.vector_2d(infiniteCanvas.toTruePoint(Geometry.createPoint(0,0)), offset__transform__ic);

                  //update .point_start and .point_end
                  rep_free.point_start = Geometry.translatedPoint(fObj.point_start__original, v);
                  rep_free.point_end   = Geometry.translatedPoint(fObj.point_end__original,   v); 

                }
                break;
              default:
                {
                  const target = options.target;

                  const screenPoint = {
                    x: target.left,
                    y: target.top,
                  };

                  const position_update = infiniteCanvas.toTruePoint(screenPoint);

                  //update .position
                  rep_free.position = position_update;
                }
                break;
            }

            //listen:on
            rep_free.onInnerUpdate(listener);

          });

        }

        // addInteraction_resize(fObj) {
        //
        //   const infiniteCanvas = this.infiniteCanvas;
        //   const fabricCanvas   = this.fabricCanvas;
        //
        //   var isScaling = false;
        //   var original_trueRect = null;
        //   fObj.on('scaling', function(options) {
        //     console.log("scaling", "options", options);
        //     const original = options.transform.original;
        //
        //     const target   = options.transform.target;
        //
        //     if(!isScaling) {
        //       original_trueRect = Geometry.createRect(target.icObj.position.x, target.icObj.position.y, target.icObj.size.width, target.icObj.size.height);
        //       console.log("original_trueRect", original_trueRect);
        //       isScaling = true;
        //     }
        //
        //     const scaleFactorX = target.scaleX / original.scaleX;
        //     const scaleFactorY = target.scaleY / original.scaleY;
        //
        //     console.log("scaleFactorX", scaleFactorX);
        //
        //     const trueRect_width__new  = (original_trueRect.width  * scaleFactorX);
        //     const trueRect_height__new = (original_trueRect.height * scaleFactorY);
        //
        //     console.log("trueRect_width__new", trueRect_width__new);
        //
        //
        //
        //     const offset = infiniteCanvas.offset;
        //     const scale  = infiniteCanvas.scale;
        //
        //     // const trueRect_update = {
        //     //   width:  trueRect_width__new,
        //     //   height: trueRect_height__new,
        //     // };
        //     //
        //     // // Object.assign(target.trueRect, trueRect_update);
        //     // Object.assign(fObj.trueRect, trueRect_update);
        //
        //     const trueRect_update = {
        //       left:  target.left / scale.X - offset.dx,
        //       top:   target.top  / scale.Y - offset.dy,
        //
        //       width:  (original_trueRect.width  * scaleFactorX),
        //       height: (original_trueRect.height * scaleFactorY),
        //     };
        //
        //     const icObj_update = {
        //       position: Geometry.createPoint(trueRect_update.left, trueRect_update.top),
        //       size:     Geometry.createSize(trueRect_update.width, trueRect_update.height),
        //     };
        //
        //     const icObj = fObj.icObj;
        //
        //     const icObj_new = Object.assign({}, icObj);
        //     Object.assign(icObj_new, icObj_update);
        //
        //     icObj.update(icObj_new, false);
        //
        //   });
        //   fObj.on('scaled', function(options) {
        //     console.log("scaled", "options", options);
        //     isScaling = false;
        //     original_trueRect = null;
        //
        //     const original = options.transform.original;
        //     const target   = options.transform.target;
        //
        //     target.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //
        //       //not used:
        //       // width:  target.trueRect.width  * scale,
        //       // height: target.trueRect.height * scale,
        //
        //       //used instead:
        //       // width:  target.trueRect.width,
        //       // height: target.trueRect.height,
        //       width:  target.icObj.size.width,
        //       height: target.icObj.size.height,
        //
        //       scaleX : original.scaleX,
        //       scaleY : original.scaleY,
        //     });
        //     target.setCoords();
        //   });
        //
        // }

        addInteraction_resize2(fObj) {

          const fabricIntegration = this;

          const infiniteCanvas = fabricIntegration.infiniteCanvas;
          const fabricCanvas = fabricIntegration.fabricCanvas;

          var isScaling = false;
          var original_homeScale = null;
          var original_scale = null;

          function doResize(fObj, options) {

            const original = options.transform.original;
            const target = options.transform.target;

            if (!isScaling) {
              original_homeScale = Object.assign({}, target.icObj.homeScale);
              // console.log("original_homeScale", original_homeScale);
              original_scale = Object.assign({}, target.icObj.scale);

              isScaling = true;
            }

            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);

            switch (options.transform.action) {

              case "scale":
                handle_proportionnal_scale();
                break;

              case "scaleX":
              case "scaleY":
                handle_axis_scale();
                // handle_proportionnal_scale();


                break;
            }

            function handle_proportionnal_scale() {

              const icObj = fObj.icObj;

              var homeScale_new;

              // if(fObj instanceof fabric.Text) {

              // const fontSize_fObj = fObj.fontSize;
              // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
              //
              // homeScale_new = {
              //   X: original_homeScale.X,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

              // } else {

              homeScale_new = {
                X: original_homeScale.X / scaleFactor.X,
                Y: original_homeScale.Y / scaleFactor.Y,
              };

              // }
              console.log("homeScale_new", homeScale_new);

              const icObj_update = {
                homeScale: homeScale_new,
              };

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new, icObj_update);

              icObj.update(icObj_new, false);



              //update position
              {

                const fObj_pos = {
                  x: fObj.left,
                  y: fObj.top,
                };

                const position_update = infiniteCanvas.toTruePoint(fObj_pos);

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.position, position_update);

                icObj.update(icObj_new, false);

              }

              // //update flipX
              // {
              //   const flipX_update = fObj.flipX;
              //
              //   const icObj_new = Object.assign({}, icObj);
              //   Object.assign(icObj_new.flipX, flipX_update);
              //
              //   icObj.update(icObj_new, false);
              // }


            }

            function handle_axis_scale() {

              const icObj = fObj.icObj;

              var scale_new;

              // if(fObj instanceof fabric.Text) {

              // const fontSize_fObj = fObj.fontSize;
              // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
              //
              // homeScale_new = {
              //   X: original_homeScale.X,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

              // } else {

              scale_new = {
                X: original_scale.X * scaleFactor.X,
                Y: original_scale.Y * scaleFactor.Y,
              };

              // }
              console.log("scale_new", scale_new);

              const icObj_update = {
                scale: scale_new,
              };

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new, icObj_update);

              icObj.update(icObj_new, false);




              //update position
              {

                const fObj_pos = {
                  x: fObj.left,
                  y: fObj.top,
                };

                const position_update = infiniteCanvas.toTruePoint(fObj_pos);

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.position, position_update);

                icObj.update(icObj_new, false);

              }

              //update flipX
              {
                const flip_update = {
                  X: (fObj.flipX != null) ? fObj.flipX : false,
                  Y: (fObj.flipY != null) ? fObj.flipY : false,
                };

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.flip, flip_update);

                icObj.update(icObj_new, false);
              }



            }

          }

          const icObj = fObj.icObj;

          fObj.on('scaling', function (options) {
            console.log("scaling", "options", options);

            switch (icObj.type) {
              case "composite":
                doResize(fObj, options);
                Object.values(icObj.parts).forEach((icObj__part, i) => {
                  const fObj__part = fabricIntegration.getFObjForIcObj(icObj__part);
                  doResize(fObj__part, options);
                });
                break;
              default:
                doResize(fObj, options);
                break;
            }

          });
          fObj.on('scaled', function (options) {
            console.log("scaled", "options", options);
            isScaling = false;

            /*
            const original = options.transform.original;
            const target   = options.transform.target;

            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);


            const icObj = fObj.icObj;

            var homeScale_new;

            if(fObj instanceof fabric.Text) {

              // const fontSize_fObj = fObj.fontSize;
              // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
              //
              // homeScale_new = {
              //   X: scale.X / scale_fObj.X / scaleFactor__fontSize,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

            } else {

              homeScale_new = {
                X: original_homeScale.X / scaleFactor.X,
                Y: original_homeScale.Y / scaleFactor.Y,
              };

            }
            console.log("homeScale_new", homeScale_new);


            const icObj_update = {
              homeScale: homeScale_new,
            };

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);

            icObj.update(icObj_new, false);
            */

            original_homeScale = null;

          });

        }


        addInteraction_rotate(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          // const fabricCanvas   = this.fabricCanvas;

          // var isRotating = false;

          fObj.on('rotating', function (options) {
            // console.log("rotating", "options", options);

            // if(!isRotating) {
            //   isRotating = true;
            //
            //
            // }

            const original = options.transform.original;


            const target = options.transform.target;

            const icObj = fObj.icObj;

            // const orientation_update = target.angle + infiniteCanvas.orientation;
            const orientation_update = Geometry.boundedAngleInDegrees(target.angle + infiniteCanvas.orientation);
            // console.log("orientation_update", orientation_update);




            // console.log("target.angle",     target.angle);
            // console.log("original.angle", original.angle);
            //
            // const rotationAngle = target.angle - original.angle;
            // const rotationAngle_bounded = Geometry.boundedAngleInDegrees(rotationAngle);
            // console.log("rotationAngle", rotationAngle);
            //
            // const originalRect   = Geometry.createRect(original.left, original.top, target.width, target.height);
            // const originalTL     = Geometry.getPointTL(originalRect);
            // const originalCenter = Geometry.getCenterPoint(originalRect);
            // console.log("originalTL",     originalTL);
            // console.log("originalCenter", originalCenter);
            //
            // const screenTL_new = Geometry.pointWithRotation(originalTL, originalCenter, rotationAngle_bounded);
            // console.log("screenTL_new", screenTL_new);
            //
            //
            //
            //
            //
            //
            // const position_update = infiniteCanvas.toTruePoint(screenTL_new);



            const screenPoint = {
              x: target.left,
              y: target.top,
            };

            const position_update = infiniteCanvas.toTruePoint(screenPoint);


            const icObj_new = Object.assign({}, icObj);
            // Object.assign(icObj_new.orientation, orientation_update);

            icObj_new.orientation = orientation_update;

            Object.assign(icObj_new.position, position_update);

            icObj.update(icObj_new, false);
          });

        }


        addInteraction_select(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas = this.fabricCanvas;


          // fObj.on('selected', function(options) {
          //   console.log("selected", "options", options);
          //
          //   // const activeGroup = fabricCanvas.getActiveGroup();
          //
          //   /*
          //   const activeObject   = fabricCanvas.getActiveObject();
          //
          //   // console.log("activeObject", activeObject);
          //
          //   const icObj = activeObject.icObj;
          //
          //   console.log("icObj.size.width",  icObj.size.width);
          //   console.log("icObj.homeScale.X", icObj.homeScale.X);
          //   console.log("icObj.scale.X",     icObj.scale.X);
          //
          //   console.log("icObj.getTrueSize()", activeObject.icObj.getTrueSize());
          //
          //   console.log("activeObject.scaleX", activeObject.scaleX);
          //   console.log("activeObject.scaleY", activeObject.scaleY);
          //
          //   console.log("infiniteCanvas.scale.X", infiniteCanvas.scale.X);
          //
          //   if(fObj instanceof fabric.Text) {
          //     console.log("icObj.fontSize", icObj.fontSize);
          //     console.log(" fObj.fontSize",  fObj.fontSize);
          //   }
          //   */
          //
          //   const icObj = fObj.icObj;
          //   icObj.isSelected = true;
          //
          // });

          // fObj.on('deselected', function(options) {
          //   console.log("selected", "options", options);
          // });

        }

        addInteraction_hold(fObj) {
          // logger.trace("addInteraction_hold", fObj);

          const fabricIntegration = this;

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas = this.fabricCanvas;

          const icObj = fObj.icObj;

          var isHeld = false;
          //hold
          fObj.on('mousedown', function (options) {
            isHeld = true;
            console.log("isHeld", isHeld);
            console.log("icObj", icObj);
            console.log("fObj.icObj", fObj.icObj);

            icObj.nowHeld();
          });

          //release
          fObj.on('mouseup', function (options) {
            console.log("fObj, mouseup", options);
            isHeld = false;
            console.log("isHeld", isHeld);

            if (fabricIntegration.singleUseBehaviors["stickyRelease"]) {

              // infiniteCanvas.manageStickyRelease(icObj);
              //create composite

              //add parts


              fabricIntegration.singleUseBehaviors["stickyRelease"] = false;
            } else {
              icObj.nowReleased();
            }

          });

        }


        addInteraction_editText(fObj) {

          // fObj.on('changed', function(options) {
          //
          // });

          fObj.on('changed', function (options) {
            console.log("changed", "options", options);

            console.log("fObj.text", fObj.text);

            const text_new = fObj.text;

            const icObj = fObj.icObj;


            //old way
            /*
            const icObj_update = {
              text: text_new,
            };
            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);
            icObj.update(icObj_new, false);
            */

            //new way
            icObj.text = text_new;
          });


          fObj.on('editing:entered', function (options) {
            const icObj = fObj.icObj;
            icObj.nowEditEnter();
          });

          fObj.on('editing:exited', function (options) {
            const icObj = fObj.icObj;
            console.log("editing:exited, icObj", icObj);
            console.log("editing:exited, icObj.text", icObj.text);

            icObj.nowEditExit();
          });

        }

        addInteraction_click(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas = this.fabricCanvas;

          fObj.on('mousedown', function (options) {
            console.log("mousedown", "options", options);

            const icObj = fObj.icObj;

            icObj.nowClicked();
          });

        }

        addInteraction_doubleClick(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          fObj.on('mousedblclick', function (options) {
            console.log("mousedblclick", "options", options);

            const icObj = fObj.icObj;

            icObj.edit.start();
          });

        }


        configureActiveSelectionListeners() {
          // object:moving
          // object:scaling
          // object:rotating
          // object:skewing
          // object:moved
          // object:scaled
          // object:rotated
          // object:skewed

          const fabricIntegration = this;

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas = this.fabricCanvas;

          //creation
          this.fabricCanvas.on("selection:created", (options) => {
            logger.log("selection:created", event);

            const activeObject = this.fabricCanvas.getActiveObject();

            if (activeObject instanceof fabric.ActiveSelection) {
              const activeSelection = activeObject;
              // console.log("activeSelection", activeSelection);

              //inject 'initial' props
              activeSelection.icObj = infiniteCanvas.createIcActiveSelection_from_activeSelectionFObj(activeSelection);

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                setGroupCoords(fObj, activeSelection);
                savePrivateCoords(fObj, activeSelection);
              }, fabricIntegration.fabricCanvas.context);
            }

          });

          function setGroupCoords(fObj, activeSelection) {

            const left__solo = fObj.left;
            const top__solo = fObj.top;

            //set new "group coords"
            const activeSelectionCL = activeSelection.left + activeSelection.width / 2;
            const activeSelectionCT = activeSelection.top + activeSelection.height / 2;
            fObj.left = left__solo - activeSelectionCL;
            fObj.top = top__solo - activeSelectionCT;

          }

          function savePrivateCoords(fObj, activeSelection) {

            //save wrtGroup coords
            fObj.left__wrtGroup = fObj.left;
            fObj.top__wrtGroup = fObj.top;

            const activeSelectionCL = activeSelection.left + activeSelection.width / 2;
            const activeSelectionCT = activeSelection.top + activeSelection.height / 2;

            //save solo coords
            fObj.left__solo = fObj.left__wrtGroup + activeSelectionCL;
            fObj.top__solo = fObj.top__wrtGroup + activeSelectionCT;
          }


          //update
          this.fabricCanvas.on("selection:updated", (options) => {
            logger.log("selection:updated", options);

            //TBD

          });





          //move
          // this.fabricCanvas.on("object:moving", (options) => {
          //   // console.log("object:moving", event);
          //
          //   const target = options.target;
          //   if(target.type == "activeSelection") {
          //     activeSelection_moving(target);
          //   }
          //
          // });
          this.fabricCanvas.on("object:moved", (options) => {
            // console.log("object:moving", event);

            const target = options.target;
            if (target.type == "activeSelection") {
              activeSelection_moved(target);
            }

          });

          //scale
          this.fabricCanvas.on("object:scaling", (options) => {
            // console.log("object:scaling", options);

            const target = options.target;
            if (target.type == "activeSelection") {
              activeSelection_scaling(options);
            }

          });
          this.fabricCanvas.on("object:scaled", (options) => {
            // console.log("object:scaling", event);

            const target = options.target;
            if (target.type == "activeSelection") {
              activeSelection_scaled(target);
            }

          });


          //rotate
          this.fabricCanvas.on("object:rotating", (options) => {
            // console.log("object:rotating", event);

            const target = options.target;
            if (target.type == "activeSelection") {
              activeSelection_rotating(options);
            }

          });







          function activeSelection_moved(activeSelection) {
            logger.log("activeSelection moving");

            //update activeSelection position
            {
              const fObj = activeSelection;

              const icObj = fObj.icObj;

              const fObj_screenPos = {
                x: fObj.left,
                y: fObj.top,
              };

              const position_update = infiniteCanvas.toTruePoint(fObj_screenPos);

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new.position, position_update);

              icObj.update(icObj_new, false);
            }

            //update children position

            function updateChildIcObj_position(fObj) {

              savePrivateCoords(fObj, activeSelection);

              const fObj_screenPos = {
                x: fObj.left__solo,
                y: fObj.top__solo,
              };

              const position_update = infiniteCanvas.toTruePoint(fObj_screenPos);

              const icObj = fObj.icObj;
              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new.position, position_update);

              icObj.update(icObj_new, false);
            }

            activeSelection.forEachObject((fObj, index, arr_fObj) => {
              updateChildIcObj_position(fObj);
              fObj.left = fObj.left__wrtGroup;
              fObj.top = fObj.top__wrtGroup;
            }, fabricIntegration.fabricCanvas.context);


          }



          var isScaling = false;
          var original_props = {};
          function activeSelection_scaling(options) {
            console.log("activeSelection scaling", options);

            const target = options.target;
            const original = options.transform.original;

            const activeSelection = target;

            if (!isScaling) {

              //store original props
              const activeSelection_icObj_propDict = {
                homeScale: Object.assign({}, activeSelection.icObj.homeScale),
                scale: Object.assign({}, activeSelection.icObj.scale),
              };

              original_props["activeSelection_icObj"] = activeSelection_icObj_propDict;

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                const propDict = {
                  homeScale: Object.assign({}, icObj.homeScale),
                  scale: Object.assign({}, icObj.scale),
                };

                original_props[icObj.id] = propDict;

              }, fabricIntegration.fabricCanvas.context);

              isScaling = true;
            }



            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);

            switch (options.transform.action) {

              case "scale":
                handle_proportionnal_scale(activeSelection);
                break;

              case "scaleX":
              case "scaleY":
                handle_axis_scale(activeSelection);

                break;
            }

            function handle_proportionnal_scale(activeSelection) {

              //update activeSelection icObj
              {
                const icObj = activeSelection.icObj;

                var homeScale_new;

                const original_homeScale = original_props["activeSelection_icObj"].homeScale;

                homeScale_new = {
                  X: original_homeScale.X / scaleFactor.X,
                  Y: original_homeScale.Y / scaleFactor.Y,
                };

                console.log("homeScale_new", homeScale_new);

                const icObj_update = {
                  homeScale: homeScale_new,
                };

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new, icObj_update);

                icObj.update(icObj_new, false);
              }


              //update children

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                //update scale
                {
                  var homeScale_new;

                  const original_homeScale = original_props[icObj.id].homeScale;

                  homeScale_new = {
                    X: original_homeScale.X / scaleFactor.X,
                    Y: original_homeScale.Y / scaleFactor.Y,
                  };

                  console.log("homeScale_new", homeScale_new);

                  const icObj_update = {
                    homeScale: homeScale_new,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new, icObj_update);

                  icObj.update(icObj_new, false);
                }


                //update position
                {

                  const activeSelectionCenterX = activeSelection.width / 2;
                  const activeSelectionCenterY = activeSelection.height / 2;

                  const fObj_pos_wrt_ASTL = {
                    left: activeSelectionCenterX + fObj.left,
                    top: activeSelectionCenterY + fObj.top,
                  };

                  const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

                  const fObj_screenPos = {
                    x: activeSelection.left + scaleFactor.X * (Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left - Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top),
                    y: activeSelection.top + scaleFactor.Y * (Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left + Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top),
                  };

                  const position_update = infiniteCanvas.toTruePoint(fObj_screenPos);

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.position, position_update);

                  icObj.update(icObj_new, false);

                }
              });

            }

            function handle_axis_scale(activeSelection) {

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                //update scale
                {
                  var scale_new;

                  const original_scale = original_props[icObj.id].scale;

                  scale_new = {
                    X: original_scale.X * scaleFactor.X,
                    Y: original_scale.Y * scaleFactor.Y,
                  };

                  console.log("scale_new", scale_new);

                  const icObj_update = {
                    scale: scale_new,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new, icObj_update);

                  icObj.update(icObj_new, false);
                }


                var fObj_sign = {
                  X: +1,
                  Y: +1
                };
                switch (options.originX) {
                  case "left":
                    fObj_sign.X = +1;
                    break;
                  case "right":
                    fObj_sign.X = -1;
                    break;
                }

                switch (options.originY) {
                  case "top":
                    fObj_sign.Y = +1;
                    break;
                  case "bottom":
                    fObj_sign.Y = -1;
                    break;
                }


                //update position
                {

                  const activeSelectionCenterX = fObj_sign.X * activeSelection.width / 2;
                  const activeSelectionCenterY = fObj_sign.Y * activeSelection.height / 2;

                  const fObj_pos_wrt_ASTL = {
                    left: activeSelectionCenterX + fObj_sign.X * fObj.left,
                    top: activeSelectionCenterY + fObj_sign.Y * fObj.top,
                  };

                  const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

                  const fObj_screenPos = {
                    x: activeSelection.left + scaleFactor.X * (Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left - Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top),
                    y: activeSelection.top + scaleFactor.Y * (Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left + Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top),
                  };

                  const position_update = infiniteCanvas.toTruePoint(fObj_screenPos);

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.position, position_update);

                  icObj.update(icObj_new, false);

                }

                //update flip
                {
                  const flip_update = {
                    X: (activeSelection.flipX != null) ? activeSelection.flipX : false,
                    Y: (activeSelection.flipY != null) ? activeSelection.flipY : false,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.flip, flip_update);

                  icObj.update(icObj_new, false);
                }

              });

            }


          }

          function activeSelection_scaled(activeSelection) {
            isScaling = false;
            original_props = {};
          }





          function activeSelection_rotating(options) {
            console.log("activeSelection rotating", options);

            const target = options.transform.target;
            // const original = options.transform.original;

            const activeSelection = target;

            activeSelection.forEachObject((fObj, index, arr_fObj) => {
              const icObj = fObj.icObj;

              const activeSelectionCenterX = activeSelection.width / 2;
              const activeSelectionCenterY = activeSelection.height / 2;

              const fObj_pos_wrt_ASTL = {
                left: activeSelectionCenterX + fObj.left,
                top: activeSelectionCenterY + fObj.top,
              };

              const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

              const fObj_screenPos = {
                x: activeSelection.left + Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left - Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top,
                y: activeSelection.top + Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left + Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top,
              };

              const position_update = infiniteCanvas.toTruePoint(fObj_screenPos);




              const fObj_angle = target.angle + fObj.angle;
              const orientation_update = Geometry.boundedAngleInDegrees(fObj_angle + infiniteCanvas.orientation);

              const icObj_new = Object.assign({}, icObj);

              Object.assign(icObj_new.position, position_update);
              icObj_new.orientation = orientation_update;

              icObj.update(icObj_new, false);
            });

          }


        }







        addListeners(fObj) {

          fObj.on('modified', function (options) {
            console.log("modified", "options", options);
          });

        }



        // createFabricSampleObjectWithCanvasBoundingRect(canvasBoundingTrueRect) {
        //
        //   const trueRect = {
        //     left: canvasBoundingTrueRect.left,
        //     top:  canvasBoundingTrueRect.top,
        //     width:  50,
        //     height: 50,
        //   };
        //
        //   var fObj = new fabric.Rect();
        //   fObj.set({
        //     left:   trueRect.left,
        //     top:    trueRect.top,
        //     width:  trueRect.width,
        //     height: trueRect.height,
        //
        //     // fill: '#f55',
        //     fill: 'red',
        //     // opacity: 0.7,
        //
        //     trueRect : trueRect,
        //   });
        //
        //   //event listeners
        //
        //   fObj.on('moving', function(options) {
        //     console.log("moving", "options", options);
        //
        //     const target = options.target;
        //
        //     const trueRect_left__new = (target.left / scale - offset.dx);
        //     const trueRect_top__new  = (target.top  / scale - offset.dy);
        //
        //     const trueRect_update = {
        //       left: trueRect_left__new,
        //       top:  trueRect_top__new,
        //     };
        //
        //     Object.assign(target.trueRect, trueRect_update);
        //     Object.assign(.trueRect, trueRect_update);
        //
        //   });
        //
        //
        //   var isScaling = false;
        //   var original_trueRect = null;
        //   fObj.on('scaling', function(options) {
        //     console.log("scaling", "options", options);
        //     const original = options.transform.original;
        //
        //     const target   = options.transform.target;
        //
        //     if(!isScaling) {
        //       original_trueRect = Object.assign({}, target.trueRect);
        //       console.log("original_trueRect", original_trueRect);
        //       isScaling = true;
        //     }
        //
        //     const scaleFactorX = target.scaleX / original.scaleX;
        //     const scaleFactorY = target.scaleY / original.scaleY;
        //
        //     console.log("scaleFactorX", scaleFactorX);
        //
        //
        //     const trueRect_width__new  = (original_trueRect.width  * scaleFactorX);
        //     const trueRect_height__new = (original_trueRect.height * scaleFactorY);
        //
        //     console.log("trueRect_width__new", trueRect_width__new);
        //
        //     const trueRect_update = {
        //       width:  trueRect_width__new,
        //       height: trueRect_height__new,
        //     };
        //
        //     // Object.assign(target.trueRect, trueRect_update);
        //     Object.assign(fObj.trueRect, trueRect_update);
        //   });
        //   fObj.on('scaled', function(options) {
        //     console.log("scaled", "options", options);
        //     isScaling = false;
        //     original_trueRect = null;
        //
        //     const original = options.transform.original;
        //     const target   = options.transform.target;
        //
        //     target.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //
        //       //not used:
        //       // width:  target.trueRect.width  * scale,
        //       // height: target.trueRect.height * scale,
        //
        //       //used instead:
        //       width:  target.trueRect.width,
        //       height: target.trueRect.height,
        //
        //       scaleX : original.scaleX,
        //       scaleY : original.scaleY,
        //     });
        //     target.setCoords();
        //   });
        //
        //
        //   fObj.on('modified', function(options) {
        //     console.log("modified", "options", options);
        //   });
        //
        //   fObj.on('selected', function(options) {
        //     console.log("selected", "options", options);
        //     const activeObject   = this.infiniteCanvas.canvas.getActiveObject();
        //
        //     console.log("activeObject.trueRect", activeObject.trueRect);
        //     console.log("activeObject.scaleX", activeObject.scaleX);
        //     console.log("activeObject.scaleY", activeObject.scaleY);
        //
        //
        //   });
        //
        //   // fabric.util.addListener(canvas, 'object:modified', function (event, self) {
        //   //   console.log('object:modified', "event", event);
        //   //
        //   // });
        //
        //   return fObj;
        // }



        addOuterFabricObject(fObj) {
          console.log("addOuterFabricObject", fObj);

          const fabricIntegration = this;

          // this.outer_fabric_objects.push(fObj);
          fabricIntegration.fabric_objects.push(fObj);

          const icObj = fObj.icObj;
          fabricIntegration.fObjForIcObj_dict[icObj.id] = fObj;

          fabricIntegration.fabricCanvas.add(fObj);

          const zIndex_fObj__target = fabricIntegration.fObjZIndexForIcObj(fObj.icObj);
          fObj.moveTo(zIndex_fObj__target);

        }

        // addPureOuterFabricObject(fObj) {
        //   console.log("addPureOuterFabricObject", fObj);
        //
        //   // this.outer_fabric_objects.push(fObj);
        //   this.fabric_objects__pure.push(fObj);
        //
        //   this.fabricCanvas.add(fObj);
        // }

        addInnerFabricObject(fObj) {
          console.log("addInnerFabricObject", fObj);

          // this.inner_fabric_objects.push(fObj);
          this.fabric_objects.push(fObj);

          this.fabricCanvas.add(fObj);
        }


        removeFabricObject(fObj) {
          logger.log("log1", "removeFabricObject", fObj);

          if (fObj.icObj.type == "video") {
            fObj.isShouldRequestAnimationFrame = false;

            /* paradoxically, this code generates bad behavior
            // logger.log("log1", "cancelRequestAnimationFrame", fObj.requestAnimationFrame);
            // cancelRequestAnimationFrame(fObj.requestAnimationFrame);
            // fObj.requestAnimationFrame = null;
            */

            fObj.dispose();
          }


          /*
          //nuke
          // this.fabricCanvas.remove(...this.fabricCanvas.getObjects());
          this.fabricCanvas.remove(...this.fabric_objects);
          */

          console.log("this.fabric_objects.length", this.fabric_objects.length);
          {
            const fabric_objects_new = Utils.arrayByRemovingElement(this.fabric_objects, fObj);

            this.setFabricObjects(fabric_objects_new);
          }
          console.log("this.fabric_objects.length", this.fabric_objects.length);


          console.log("this.fabric_objects", this.fabric_objects);




          // fObj.remove();
          this.fabricCanvas.remove(fObj);

          /*
          //antinuke
          this.fabricCanvas.add(...this.fabric_objects);
          */

          // console.log("this.fabricCanvas", this.fabricCanvas);
          // this.fabricCanvas.requestRenderAll();
        }


        selectAll() {
          const fabricCanvas = this.fabricCanvas;

          fabricCanvas.discardActiveObject();
          const arr_affected = fabricCanvas.getObjects()
            .filter(fObj => fObj.icObj.canBeSelected);
          const sel = new fabric.ActiveSelection(arr_affected, {
            canvas: canvas,
          });
          fabricCanvas.setActiveObject(sel);
          fabricCanvas.requestRenderAll();
        }

        deselectAll() {
          const fabricCanvas = this.fabricCanvas;

          fabricCanvas.discardActiveObject();
          fabricCanvas.renderAll();
        }





        // debugFabric() {
        //
        //   const trueRect = {
        //     top:  100,
        //     left: 100,
        //     width: 20,
        //     height: 20,
        //   };
        //
        //   // create a rectangle object
        //   var fObj = new fabric.Rect({
        //     left: trueRect.left,
        //     top: trueRect.top,
        //     fill: 'red',
        //     width: trueRect.width,
        //     height: trueRect.height,
        //     trueRect : trueRect,
        //   });
        //
        //   this.addFabricObject(fObj);
        // }

        // updateFabricObjectsPosition(redrawOccasion) {
        //   console.log("updateFabricObjectsPosition", redrawOccasion);
        //
        //   const offset      = this.infiniteCanvas.offset;
        //   const scale       = this.infiniteCanvas.scale;
        //
        //   this.fabric_objects.forEach((fObj, i) => {
        //     //console.log("fObj A", fObj);
        //
        //     const icObj = fObj.icObj;
        //
        //     const truePos = {
        //       x: icObj.position.x  + offset.dx,
        //       y: icObj.position.y  + offset.dy,
        //     };
        //
        //     fObj.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //       left: truePos.x * scale.X,
        //       top:  truePos.y * scale.Y,
        //     });
        //
        //     // Object.assign(fObj.trueRect, truePos);
        //     fObj.setCoords();
        //
        //     //console.log("fObj B", fObj);
        //
        //   });
        // }

        updateFabricObjectsPosition(redrawOccasion) {

          switch (redrawOccasion) {
            case RedrawOccasion.scaleChanged:
              this.updateFabricObjectsPosition_zScroll(redrawOccasion);
              break;

            // case RedrawOccasion.orientationChanged:
            //   this.updateFabricObjectsPosition_rScroll();
            //   break;

            default:
              this.updateFabricObjectsPosition_default(redrawOccasion);
              break;
          }

        }

        updateFabricObjectsPosition_zScroll(redrawOccasion) {

          const activeObject = this.fabricCanvas.getActiveObject();

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          if (activeObject instanceof fabric.ActiveSelection) {

            const activeSelection = activeObject;

            this.updateFabricObject_position_zScroll__container(activeSelection);

            const arr_affected = activeSelection.getObjects()
              .filter(fObj => fObj.icObj.canBeMoved);

            const arr1 = fabric_objects;
            const arr2 = arr_affected;

            let difference = arr1.filter(x => !arr2.includes(x));
            const arr_unaffected = difference;

            arr_affected.forEach((fObj, i) => {
              this.updateFabricObject_position_zScroll__contained(activeSelection, fObj);
            });

            arr_unaffected.forEach((fObj, i) => {
              this.updateFabricObject_position_default(fObj);
            });

          } else {
            fabric_objects.forEach((fObj, i) => {

              if (fObj == activeObject) {
                this.updateFabricObject_position_zScroll__container(fObj);
              } else {
                this.updateFabricObject_position_default(fObj);
              }

            });
          }

        }

        // updateFabricObjectsPosition_rScroll(redrawOccasion) {
        //
        //   const activeObject = this.fabricCanvas.getActiveObject();
        //
        //   // const fabric_objects = this.fabric_objects;
        //   const fabric_objects = this.getFabricObjects();
        //
        //   fabric_objects.forEach((fObj, i) => {
        //
        //     if(fObj == activeObject) {
        //       this.updateFabricObject_position_rScroll(fObj);
        //     } else {
        //       this.updateFabricObject_position_default(fObj);
        //     }
        //
        //   });
        //
        // }


        updateFabricObjectsPosition_default(redrawOccasion) {

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          var fObjs_to_move = [];

          const activeObject = this.fabricCanvas.getActiveObject();
          if (activeObject instanceof fabric.ActiveSelection) {
            const activeSelection = activeObject;

            fObjs_to_move = [activeSelection];

            const arr_affected = activeSelection.getObjects();

            const arr1 = fabric_objects;
            const arr2 = arr_affected;

            let difference = arr1.filter(x => !arr2.includes(x));
            const arr_unaffected = difference;

            fObjs_to_move.push(...arr_unaffected);

          } else {
            fObjs_to_move = [...fabric_objects];
          }

          fObjs_to_move.forEach((fObj, i) => {
            this.updateFabricObject_position_default(fObj);
          });

        }

        // updateFabricObject_position_rScroll(fObj) {
        //
        //   const infiniteCanvas = this.infiniteCanvas;
        //
        //   const offset      = infiniteCanvas.offset;
        //   const scale       = infiniteCanvas.scale;
        //
        //   const orientation = 0;
        //
        //   const orientationBaseVectors = infiniteCanvas.getOrientationBaseVectors();
        //
        //   // const origin = {
        //   //   x:0,
        //   //   y:0,
        //   // };
        //
        //   // const centerPoint = infiniteCanvas.getTrueCenterPoint();
        //   // console.log("centerPoint", centerPoint);
        //
        //   function compute_fObj_position_vector(icObj) {
        //
        //     const v1_no_orientation = {
        //       x: icObj.position.x,
        //       y: icObj.position.y,
        //     }
        //
        //     const v1_with_orientation = {
        //       x: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.u),
        //       y: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.v),
        //     };
        //
        //     const v1_with_orientation__with_offset = {
        //       x: v1_with_orientation.x + offset.dx,
        //       y: v1_with_orientation.y + offset.dy,
        //     };
        //
        //     const v1_with_orientation__with_offset__scaled = {
        //       x: v1_with_orientation__with_offset.x * scale.X,
        //       y: v1_with_orientation__with_offset.y * scale.Y,
        //     };
        //
        //     return v1_with_orientation__with_offset__scaled;
        //
        //   }
        //
        //
        //
        //   const icObj = fObj.icObj;
        //
        //   const v = compute_fObj_position_vector(icObj);
        //
        //   fObj.set({
        //     // x: x + offsetX,
        //     // y: y + offsetY,
        //     left: v.x,
        //     top:  v.y,
        //
        //     angle: icObj.orientation - orientation,
        //   });
        //
        //   // Object.assign(fObj.trueRect, truePos);
        //   fObj.setCoords();
        //
        // }

        updateFabricObject_position_zScroll__container(fObj) {
          console.log("updateFabricObject_position_zScroll__container", fObj);
          const infiniteCanvas = this.infiniteCanvas;

          const icObj = fObj.icObj;


          var position_update = null;

          const mouseIntegration = this.mouseIntegration;
          if (mouseIntegration.leftMouseDown) {
            // console.log("leftMouseDown zScroll");

            const cursor_truePoint = infiniteCanvas.getTrueCursor();
            //SHU: TODO: (later) prendre en compte le point grâce auquel on a attrapé l'objet (ce n'est pas le coin top left)
            position_update = cursor_truePoint;

          } else {
            // console.log("leftMouseUp zScroll");

            const fObj_screenPos = {
              x: fObj.left,
              y: fObj.top,
            };
            position_update = infiniteCanvas.toTruePoint(fObj_screenPos);
          }


          const icObj_new = Object.assign({}, icObj);
          Object.assign(icObj_new.position, position_update);

          icObj.update(icObj_new, false);

        }

        updateFabricObject_position_zScroll__contained(activeSelection, fObj) {
          console.log("updateFabricObject_position_zScroll", fObj);

          const scaleFactor = {
            X: activeSelection.scaleX,
            Y: activeSelection.scaleY,
          };

          //update position
          {
            const icObj = fObj.icObj;

            const activeSelectionCenterX = activeSelection.width / 2;
            const activeSelectionCenterY = activeSelection.height / 2;

            const fObj_pos_wrt_ASTL = {
              left: activeSelectionCenterX + fObj.left,
              top: activeSelectionCenterY + fObj.top,
            };

            const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

            const fObj_screenPos = {
              x: activeSelection.left + scaleFactor.X * (Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left - Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top),
              y: activeSelection.top + scaleFactor.Y * (Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left + Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top),
            };

            const position_update = infiniteCanvas.toTruePoint(fObj_screenPos);

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new.position, position_update);

            icObj.update(icObj_new, false);

          }

        }


        updateFabricObject_position_default(fObj) {
          // logger.log("updateFabricObject_position_default", fObj);

          //SHU: TODO: update fabric.Line object position
          // if(fObj instanceof fabric.Line) {
          // return;
          // }

          //ignore these types
          switch(fObj.icObj.type) {
            case "HUD_point":
            case "HUD_segment":
            case "HUD_line":
              return;
          }

          // if(fObj.icObj.type == "sparkle") {
          //   return;
          // }


          const infiniteCanvas = this.infiniteCanvas;

          const offset = infiniteCanvas.offset;
          const scale = infiniteCanvas.scale;

          const orientation = infiniteCanvas.orientation;

          const orientationBaseVectors = infiniteCanvas.getOrientationBaseVectors();

          // const origin = {
          //   x:0,
          //   y:0,
          // };

          // const centerPoint = infiniteCanvas.getTrueCenterPoint();
          // console.log("centerPoint", centerPoint);

          function compute_fObj_position_vector(position) {

            const v1_no_orientation = {
              x: position.x,
              y: position.y,
            }

            const v1_with_orientation = {
              x: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.u),
              y: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.v),
            };

            const v1_with_orientation__with_offset = {
              x: v1_with_orientation.x + offset.dx,
              y: v1_with_orientation.y + offset.dy,
            };

            const v1_with_orientation__with_offset__scaled = {
              x: v1_with_orientation__with_offset.x * scale.X,
              y: v1_with_orientation__with_offset.y * scale.Y,
            };

            return v1_with_orientation__with_offset__scaled;

          }


          switch (fObj.icObj.type) {
            case "segment":
            {
              const icObj = fObj.icObj;
            
              const v1 = compute_fObj_position_vector(icObj.point_start);
              const v2 = compute_fObj_position_vector(icObj.point_end);
            
              fObj.set({
                x1: v1.x,
                y1: v1.y,
                x2: v2.x,
                y2: v2.y,
            
                angle: icObj.orientation - orientation,
              });
            }
            break;
            default:
              {
                const icObj = fObj.icObj;

                const v = compute_fObj_position_vector(icObj.position);
                // logger.log("v", v);

                fObj.set({
                  // x: x + offsetX,
                  // y: y + offsetY,
                  left: v.x,
                  top: v.y,

                  angle: icObj.orientation - orientation,
                });
              }
              break;
          }

          fObj.setCoords();
        }






        updateFabricObjectsSize(redrawOccasion) {
          console.log("updateFabricObjectsSize", redrawOccasion);

          switch (redrawOccasion) {
            case RedrawOccasion.scaleChanged:
              this.updateFabricObjectsSize_zScroll();
              break;

            default:
              this.updateFabricObjectsSize_default();
              break;
          }

          // canvas.renderAll();
        }


        updateFabricObjectsSize_zScroll() {

          const activeObject = this.fabricCanvas.getActiveObject();

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          if (activeObject instanceof fabric.ActiveSelection) {

            const activeSelection = activeObject;

            this.updateFabricObject_size_zScroll(activeSelection);

            const arr_affected = activeSelection.getObjects()
              .filter(fObj => fObj.icObj.canBeMoved);


            const arr1 = fabric_objects;
            const arr2 = arr_affected;

            let difference = arr1.filter(x => !arr2.includes(x));
            const arr_unaffected = difference;

            arr_affected.forEach((fObj, i) => {
              this.updateFabricObject_size_zScroll(fObj);
            });

            arr_unaffected.forEach((fObj, i) => {
              this.updateFabricObject_size_default(fObj);
            });

          } else {
            fabric_objects.forEach((fObj, i) => {

              if (fObj == activeObject) {
                this.updateFabricObject_size_zScroll(fObj);
              } else {
                this.updateFabricObject_size_default(fObj);
              }

            });
          }



        }

        updateFabricObjectsSize_default() {
          console.log("updateFabricObjectsSize_default");

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          fabric_objects.forEach((fObj, i) => {
            this.updateFabricObject_size_default(fObj);
          });

        }



        updateFabricObject_size_zScroll(fObj) {
          console.log("updateFabricObject_size_zScroll", fObj);
          console.log("fObj.icObj", fObj.icObj);

          const scale = this.infiniteCanvas.scale;

          // if(fObj instanceof fabric.ActiveSelection) {
          // updateActiveSelectionFObj_size_zScroll(fObj);
          // } else {
          updateStdFObj_size_zScroll(fObj);
          // }



          function updateStdFObj_size_zScroll(fObj) {
            console.log("updateFabricObject_size_zScroll", fObj);

            const scale_fObj = {
              X: fObj.scaleX,
              Y: fObj.scaleY,
            };
            console.log("scale_fObj", scale_fObj);

            const icObj = fObj.icObj;


            var homeScale_new;

            if (fObj instanceof fabric.Text) {

              const fontSize_fObj = fObj.fontSize;
              const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;

              // homeScale_new = {
              //   X: scale.X / scale_fObj.X / scaleFactor__fontSize,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

              homeScale_new = {
                X: scale.X / (scale_fObj.X / icObj.scale.X) / scaleFactor__fontSize,
                Y: scale.Y / (scale_fObj.Y / icObj.scale.Y) / scaleFactor__fontSize,
              };

            } else {

              // homeScale_new = {
              //   X: scale.X / scale_fObj.X,
              //   Y: scale.Y / scale_fObj.Y,
              // };

              homeScale_new = {
                X: scale.X / (scale_fObj.X / icObj.scale.X),
                Y: scale.Y / (scale_fObj.Y / icObj.scale.Y),
              };

            }
            console.log("homeScale_new", homeScale_new);

            const icObj_update = {
              homeScale: homeScale_new,
            };

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);

            icObj.update(icObj_new, false);

            // fObj.setCoords();

          }

          function updateActiveSelectionFObj_size_zScroll(activeSelection) {

            activeSelection.getObjects().forEach((fObj, i) => {
              updateStdFObj_size_zScroll(fObj);
            });


          }






        }

        updateFabricObject_size_default(fObj) {
          console.log("updateFabricObject_size_default", fObj);

          //SHU: TODO: update fabric.Line object position
          // if(fObj instanceof fabric.Line) {
          //   return;
          // }

          //ignore these types
          switch(fObj.icObj.type) {
            case "HUD_point":
            case "HUD_segment":
            case "HUD_line":
              return;
            case "point":
            case "segment":
            case "line":
              return;
          }

          // if(fObj.icObj.type == "sparkle") {
          //   return;
          // }


          const scale = this.infiniteCanvas.scale;
          console.log("scale", scale);

          console.log("scale.X", scale.X);
          console.log("fObj.icObj.homeScale.X", fObj.icObj.homeScale.X);

          const scaleFactorX = scale.X / fObj.icObj.homeScale.X;
          const scaleFactorY = scale.Y / fObj.icObj.homeScale.Y;

          const scaleFactor = {
            X: scaleFactorX,
            Y: scaleFactorY,
          };

          console.log("scaleFactorX", scaleFactorX);



          if (fObj instanceof fabric.Text) {

            // const fontSize = fObj.true_fontSize * scale;
            // const fontSize = fObj.icObj.fontSize * scale.X;
            const fontSize = fObj.icObj.fontSize * scaleFactor.X;

            console.log("fontSize", fontSize);
            // fObj.set({
            //   fontSize: fontSize,
            // });

            const fontSize_max = 10000;
            // if(fontSize > fontSize_max) {
            //
            //   const scaleAmount_fix = (fontSize - fontSize_max) / fontSize_max;
            //   const scale_fix = 1.0 * (1 + scaleAmount_fix);
            //   console.log("scale_fix", scale_fix);
            //
            //   fObj.set({
            //     fontSize: fontSize_max,
            //
            //     scaleX: scale_fix,
            //     scaleY: scale_fix,
            //   });
            //
            // } else {
            //   fObj.set({
            //     fontSize: fontSize,
            //
            //     scaleX: 1,
            //     scaleY: 1,
            //   });
            // }

            function scaleWithTargetFontSize(targetFontSize) {

              const scaleAmount_fix = (fontSize - targetFontSize) / targetFontSize;
              const scale_fix = {
                X: fObj.icObj.scale.X * (1 + scaleAmount_fix),
                Y: fObj.icObj.scale.Y * (1 + scaleAmount_fix),
              };
              console.log("scale_fix", scale_fix);

              fObj.set({
                fontSize: targetFontSize,

                scaleX: scale_fix.X,
                scaleY: scale_fix.Y,
              });

            }

            if (fontSize > fontSize_max) {

              scaleWithTargetFontSize(fontSize_max);

            } else {
              // fObj.set({
              //   fontSize: fontSize,
              //
              //   scaleX: fObj.icObj.scale.X,
              //   scaleY: fObj.icObj.scale.Y,
              // });

              const closestIntegerFontSize = Math.max(1, Math.floor(fontSize));

              scaleWithTargetFontSize(closestIntegerFontSize);

            }



          }
          // else if(fObj instanceof fabric.Image) {
          //
          //   // fObj.scale(scale);
          //
          //   const width  = fObj.icObj.img.width  * scale.X;
          //   const height = fObj.icObj.img.height * scale.Y;
          //
          //   fObj.scaleToWidth(width);
          //   fObj.scaleToHeight(height);
          //
          // } else if(fObj instanceof fabric.Rect) {
          else {

            // if(fObj.icObj.isPoint != null && fObj.icObj.isPoint) {
            //
            //   const point_precision_factor = 100;
            //   fObj.set({
            //     // width:  point_precision_factor * this.infiniteCanvas.scaleX,
            //     // height: point_precision_factor * this.infiniteCanvas.scaleY,
            //
            //     scaleX: point_precision_factor * this.infiniteCanvas.scaleX,
            //     scaleY: point_precision_factor * this.infiniteCanvas.scaleY,
            //   });
            //
            // }
            // else {

            console.log("fObj", fObj);
            fObj.set({
              scaleX: fObj.icObj.scale.X * scaleFactor.X,
              scaleY: fObj.icObj.scale.Y * scaleFactor.Y,
            });

            // }

            //handle when image is forced to scale to icObj's width and height
            if (fObj instanceof fabric.Image) {
              const icObj = fObj.icObj;
              if (icObj.force_width) {
                const factor__force_width = icObj.width / icObj.img.width;
                fObj.set({
                  scaleX: fObj.scaleX * factor__force_width,
                });
              }
              if (icObj.force_height) {
                const factor__force_height = icObj.height / icObj.img.height;
                fObj.set({
                  scaleY: fObj.scaleY * factor__force_height,
                });
              }
            }

          }
          // else {
          //   console.log("unknown instance type");
          // }

          fObj.setCoords();

        }






        updateIcObjWithFObj(fObj) {
          console.log("updateIcObjWithFObj", fObj);

          const offset = this.infiniteCanvas.offset;
          const scale = this.infiniteCanvas.scale;
          console.log("scale", scale);


          const trueRect_update = {
            left: fObj.left / scale.X - offset.dx,
            top: fObj.top / scale.Y - offset.dy,

            width: fObj.width / scale.X,
            height: fObj.height / scale.Y,
          };

          const icObj_update = {
            position: Geometry.createPoint(trueRect_update.left, trueRect_update.top),
            size: Geometry.createSize(trueRect_update.width, trueRect_update.height),
          };

          const icObj = fObj.icObj;

          const icObj_new = Object.assign({}, icObj);
          Object.assign(icObj_new, icObj_update);

          console.log("icObj_new", icObj_new);

          icObj.update(icObj_new, false);

        }









        //free drawing

        initializeFreeDrawing() {

          // this.fabricCanvas.isDrawingMode = true;

          if (fabric.PatternBrush) {
            var vLinePatternBrush = new fabric.PatternBrush(canvas);
            vLinePatternBrush.getPatternSrc = function () {

              var patternCanvas = fabric.document.createElement('canvas');
              patternCanvas.width = patternCanvas.height = 10;
              var ctx = patternCanvas.getContext('2d');

              ctx.strokeStyle = this.color;
              ctx.lineWidth = 5;
              ctx.beginPath();
              ctx.moveTo(0, 5);
              ctx.lineTo(10, 5);
              ctx.closePath();
              ctx.stroke();

              return patternCanvas;
            };

            var hLinePatternBrush = new fabric.PatternBrush(canvas);
            hLinePatternBrush.getPatternSrc = function () {

              var patternCanvas = fabric.document.createElement('canvas');
              patternCanvas.width = patternCanvas.height = 10;
              var ctx = patternCanvas.getContext('2d');

              ctx.strokeStyle = this.color;
              ctx.lineWidth = 5;
              ctx.beginPath();
              ctx.moveTo(5, 0);
              ctx.lineTo(5, 10);
              ctx.closePath();
              ctx.stroke();

              return patternCanvas;
            };

            var squarePatternBrush = new fabric.PatternBrush(canvas);
            squarePatternBrush.getPatternSrc = function () {

              var squareWidth = 10, squareDistance = 2;

              var patternCanvas = fabric.document.createElement('canvas');
              patternCanvas.width = patternCanvas.height = squareWidth + squareDistance;
              var ctx = patternCanvas.getContext('2d');

              ctx.fillStyle = this.color;
              ctx.fillRect(0, 0, squareWidth, squareWidth);

              return patternCanvas;
            };

            var diamondPatternBrush = new fabric.PatternBrush(canvas);
            diamondPatternBrush.getPatternSrc = function () {

              var squareWidth = 10, squareDistance = 5;
              var patternCanvas = fabric.document.createElement('canvas');
              var rect = new fabric.Rect({
                width: squareWidth,
                height: squareWidth,
                angle: 45,
                fill: this.color
              });

              var canvasWidth = rect.getBoundingRect().width;

              patternCanvas.width = patternCanvas.height = canvasWidth + squareDistance;
              rect.set({ left: canvasWidth / 2, top: canvasWidth / 2 });

              var ctx = patternCanvas.getContext('2d');
              rect.render(ctx);

              return patternCanvas;
            };

            // var img = new Image();
            // img.src = 'img/sparkle_gradient.png';
            //
            // var texturePatternBrush = new fabric.PatternBrush(canvas);
            // texturePatternBrush.source = img;
          }

        }

        configureFreeDrawingBrush(brushConfig) {

          this.brushConfig__current = brushConfig;

          const brush = this.fabricCanvas.freeDrawingBrush;

          brush.width = brushConfig.width;
          brush.color = brushConfig.color;
        }

        brushConfig__freeDrawing() {
          var outBrushConfig = {};

          outBrushConfig.width = 20;

          const rgbaColorString = this.inputProperties.getActiveRgbaColorString();
          outBrushConfig.color = rgbaColorString;

          const fColor = new fabric.Color(rgbaColorString);
          logger.log("fColor", fColor);
          outBrushConfig.fColor = fColor;

          return outBrushConfig;
        }


        enterFreeDrawing(cfg) {
          const fabricIntegration = this;

          const brushConfig = this.brushConfig__freeDrawing();
          this.configureFreeDrawingBrush(brushConfig);

          this.fabricCanvas.isDrawingMode = true;

          this.current_freeDrawing_objects = [];
          function freeDrawing_objectAdded(e) {
            console.log("freeDrawing_objectAdded", e);

            const brushConfig = fabricIntegration.brushConfig__current;

            const fColor = brushConfig.fColor;
            const rgbColor = fColor.toRgb();
            const opacity = fColor.getAlpha();

            const fObj = e.target;
            fObj.set({
              stroke: rgbColor,
              opacity: opacity,

              isCosmetic: cfg.isCosmetic,
            });

            fabricIntegration.current_freeDrawing_objects.push(e.target);
            // console.log("fabricIntegration.current_freeDrawing_objects", fabricIntegration.current_freeDrawing_objects);
          }

          this.freeDrawing_objectAdded = freeDrawing_objectAdded;
          this.fabricCanvas.on('object:added', this.freeDrawing_objectAdded);

        }

        leaveFreeDrawing() {
          this.fabricCanvas.isDrawingMode = false;
          this.fabricCanvas.off('object:added', this.freeDrawing_objectAdded);

          //get newly created fabric objects
          // var last = canvas_objects[canvas_objects.length -1]; //Get last object
          const freeDrawing_objects_created = [...this.current_freeDrawing_objects];
          this.current_freeDrawing_objects = [];

          this.manageCreatedFreeDrawingObjects(freeDrawing_objects_created);

        }

        manageCreatedFreeDrawingObjects(arr_fObj) {
          console.log("manageCreatedFreeDrawingObjects", arr_fObj);

          //group newly created fabric objects (or not (for easy delete))

          //create icObj from fObj
          arr_fObj.forEach((fObj) => {
            const icObj = this.infiniteCanvas.createIcFreeDrawing_from_freeDrawingFObj(fObj);
            this.infiniteCanvas.addNewIcObject(icObj);

            //SHU: HERE WE COULD HAVE RECYCLED ALREADY CREATED FOBJ AND AVOID RECREATING A NEW ONE
            this.fabricCanvas.remove(fObj);
          });

        }


        //pathmade

        brushConfig__operatorPathDrawing() {
          var outBrushConfig = {};

          outBrushConfig.width = 90;

          const rgbaColorString = "rgba(233,212,96,0.5)";
          outBrushConfig.color = rgbaColorString;

          const fColor = new fabric.Color(rgbaColorString);
          logger.log("fColor", fColor);
          outBrushConfig.fColor = fColor;

          return outBrushConfig;
        }

        enterPathmadeOperatorPathDrawing(type__pathmadeOp) {
          const fabricIntegration = this;
          const fabricCanvas = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          const brushConfig = fabricIntegration.brushConfig__operatorPathDrawing();

          fabricIntegration.configureFreeDrawingBrush(brushConfig);


          const fColor = brushConfig.fColor;
          const rgbColor = fColor.toRgb();
          const opacity = fColor.getAlpha();

          fabricCanvas.isDrawingMode = true;



          //replay related
          function startRecording(e) {
            // logger.log("startRecording", e);
            fabricCanvas.off('mouse:down:before', startRecording);



            fabricIntegration.current_operatorPathDrawing_objects = [];
            function operatorPathDrawing_objectAdded(e) {
              logger.log("operatorPathDrawing_objectAdded", e);

              const fObj = e.target;
              if (fObj.icObj != null) {
                //ignore
                return;
              } else {

                fObj.set({
                  stroke: rgbColor,
                  opacity: opacity,
                });

                fabricIntegration.current_operatorPathDrawing_objects.push(e.target);

              }

            }

            fabricIntegration.operatorPathDrawing_objectAdded = operatorPathDrawing_objectAdded;
            fabricCanvas.on('object:added', fabricIntegration.operatorPathDrawing_objectAdded);


            function onMouseMove__dummy(e) {
              // logger.log("onMouseMove__dummy", e);
              const rep_free__dummy = fabricIntegration.operatorPathDrawing_dummy;

              const true_cursor = infiniteCanvas.getTrueCursor();
              rep_free__dummy.position = {
                x: true_cursor.x,
                y: true_cursor.y,
              };

            }
            fabricIntegration.operatorPathDrawing_onMouseMove__dummy = onMouseMove__dummy;




            //create dummy
            const true_cursor = infiniteCanvas.getTrueCursor();
            const trueRect = {
              x: true_cursor.x,
              y: true_cursor.y,
              width: 100,
              height: 100,
            };
            const icDummy = infiniteCanvas.createIcDummy(trueRect);
            icDummy.originX = "center";
            icDummy.originY = "center";

            infiniteCanvas.onceOnAddRepresentedForIcObject(icDummy, (icDummy) => {
              const rep_free__dummy = infiniteCanvas.getRepresented(icDummy.id).r_free();
              fabricIntegration.operatorPathDrawing_dummy = rep_free__dummy;
            });
            infiniteCanvas.addIcObject(icDummy);

            //grab dummy
            // setTimeout(() => {
            //   const fObj__dummy = fabricIntegration.getFObj__dummy();
            //   logger.log("fObj__dummy", fObj__dummy);
            //   fabricCanvas._setupCurrentTransform(e, fObj__dummy);  //magic happens here
            //   fabricCanvas.setActiveObject(fObj__dummy);
            // }, 300);

            //make dummy follow cursor
            fabricCanvas.on('mouse:move', fabricIntegration.operatorPathDrawing_onMouseMove__dummy);


            //start pathmadeOperator creation
            infiniteCanvas.createIcPathmadeOperator_start(type__pathmadeOp);
          }

          function stopRecording(e) {
            // logger.log("startRecording", e);
            fabricCanvas.off('mouse:up', stopRecording);

            //kill dummy
            fabricCanvas.off('mouse:move', fabricIntegration.operatorPathDrawing_onMouseMove__dummy);
            if (fabricIntegration.operatorPathDrawing_dummy != null) {
              fabricIntegration.operatorPathDrawing_dummy.im_dying_now = true;
            }


            fabricIntegration.fabricCanvas.off('object:added', fabricIntegration.freeDrawing_objectAdded);

            //get newly created fabric objects
            const operatorPathDrawing_objects_created = [...fabricIntegration.current_operatorPathDrawing_objects];
            fabricIntegration.current_operatorPathDrawing_objects = [];

            fabricIntegration.manageCreatedOperatorPathDrawingObjects(operatorPathDrawing_objects_created);

            //stop pathmadeOperator creation
            infiniteCanvas.createIcPathmadeOperator_end_p()
              .then(icPathmadeOperator => {

                switch (fabricIntegration.buildMode__operatorPathDrawing) {
                  case "grains":
                    {
                      infiniteCanvas.addIcObject(icPathmadeOperator);
                    }
                    break;
                  case "composite":
                    {
                      infiniteCanvas.rx_icPathmadeOperator_subject.next(icPathmadeOperator);
                    }
                    break;
                  default:
                    throw new Error("fabricIntegration.buildMode__operatorPathDrawing, unsupported buildMode: " + fabricIntegration.buildMode__operatorPathDrawing);
                    break;
                }

              });

            //wait for next recording
            fabricCanvas.on('mouse:down:before', startRecording);
            fabricCanvas.on('mouse:up', stopRecording);
          }

          //wait for next recording
          fabricCanvas.on('mouse:down:before', startRecording);
          fabricCanvas.on('mouse:up', stopRecording);

          //store methods for uninstalling
          fabricIntegration.operatorPathDrawing_startRecording = startRecording;
          fabricIntegration.operatorPathDrawing_stopRecording = stopRecording;
        }

        leavePathmadeOperatorPathDrawing() {
          const fabricIntegration = this;
          const fabricCanvas = fabricIntegration.fabricCanvas;

          //stop waiting for next recording
          fabricCanvas.off('mouse:down:before', fabricIntegration.operatorPathDrawing_startRecording);
          delete fabricIntegration.operatorPathDrawing_startRecording;
          fabricCanvas.off('mouse:up', fabricIntegration.operatorPathDrawing_stopRecording);
          delete fabricIntegration.operatorPathDrawing_stopRecording;


          fabricIntegration.fabricCanvas.isDrawingMode = false;
        }

        manageCreatedOperatorPathDrawingObjects(arr_fObj) {
          console.log("manageCreatedOperatorPathDrawingObjects", arr_fObj);

          const fabricIntegration = this;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          if (arr_fObj.length != 1) {
            throw new Error("operatorPath, arr_fObj.length != 1");
          }

          //group newly created fabric objects (or not (for easy delete))

          //create icObj from fObj
          arr_fObj.forEach((fObj) => {
            // const icObj = this.infiniteCanvas.createIcPathmadeOperator_from_operatorPathDrawingFObj(fObj);
            // this.infiniteCanvas.addNewIcObject(icObj);

            const creationManager = infiniteCanvas.creationManagers["pathmadeOperator"];
            const path = fObj.path;
            creationManager.path = path;

            //SHU: HERE WE COULD HAVE RECYCLED ALREADY CREATED FOBJ AND AVOID RECREATING A NEW ONE
            this.fabricCanvas.remove(fObj);
          });

        }





        enterPathmadeOperatorPathDrawing__grains(type__pathmadeOp) {
          const fabricIntegration = this;
          const fabricCanvas = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          //set creationMode
          fabricIntegration.buildMode__operatorPathDrawing = "grains";

          //start drawing mode
          fabricIntegration.enterPathmadeOperatorPathDrawing(type__pathmadeOp);
        }

        leavePathmadeOperatorPathDrawing__grains() {

          const fabricIntegration = this;
          const fabricCanvas = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          //end drawing mode
          fabricIntegration.leavePathmadeOperatorPathDrawing();

          //unset creationMode
          delete fabricIntegration.buildMode__operatorPathDrawing;
        }



        enterPathmadeOperatorPathDrawing__composite(type__pathmadeOp) {
          const fabricIntegration = this;
          const fabricCanvas = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          //start multiPathmadeOperator creation
          infiniteCanvas.createIcMultiPathmadeOperator_start(type__pathmadeOp);

          //set creationMode
          fabricIntegration.buildMode__operatorPathDrawing = "composite";

          //start drawing mode
          fabricIntegration.enterPathmadeOperatorPathDrawing(type__pathmadeOp);
        }

        leavePathmadeOperatorPathDrawing__composite() {

          const fabricIntegration = this;
          const fabricCanvas = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          //end drawing mode
          fabricIntegration.leavePathmadeOperatorPathDrawing();

          //unset creationMode
          delete fabricIntegration.buildMode__operatorPathDrawing;

          //end multiPathmadeOperator creation
          const icMultiPathmadeOperator = infiniteCanvas.createIcMultiPathmadeOperator_end();
          infiniteCanvas.addIcObject(icMultiPathmadeOperator);

        }




        enterSlicing() {
          const fabricIntegration = this;

          const brush = this.fabricCanvas.freeDrawingBrush;

          brush.width = 20;

          // const rgbColor = this.inputProperties.getActiveColor();
          // const opacity  = this.inputProperties.getActiveOpacity();
          const rgbaColorString = this.inputProperties.getActiveRgbaColorString();

          const fColor = new fabric.Color(rgbaColorString);
          logger.log("fColor", fColor);
          const rgbColor = fColor.toRgb();
          const opacity = fColor.getAlpha();

          // brush.color   = this.inputProperties.getActiveColor();
          brush.color = rgbaColorString;

          this.fabricCanvas.isDrawingMode = true;

          this.current_freeDrawing_objects = [];
          function freeDrawing_objectAdded(e) {
            console.log("freeDrawing_objectAdded", e);

            const fObj = e.target;
            fObj.set({
              stroke: rgbColor,
              opacity: opacity,
            });

            fabricIntegration.current_freeDrawing_objects.push(e.target);
            // console.log("fabricIntegration.current_freeDrawing_objects", fabricIntegration.current_freeDrawing_objects);
          }

          this.freeDrawing_objectAdded = freeDrawing_objectAdded;
          this.fabricCanvas.on('object:added', this.freeDrawing_objectAdded);

        }

        leaveSlicing() {
          this.fabricCanvas.isDrawingMode = false;
          this.fabricCanvas.off('object:added', this.freeDrawing_objectAdded);

          //get newly created fabric objects
          // var last = canvas_objects[canvas_objects.length -1]; //Get last object
          const freeDrawing_objects_created = [...this.current_freeDrawing_objects];
          this.current_freeDrawing_objects = [];

          this.manageSlicing(freeDrawing_objects_created);

        }

        manageSlicing(arr_fObj) {
          console.log("manageSlicing", arr_fObj);

          if (arr_fObj.length != 1) {
            throw new Error("slicing requires one stroke only");
          }

          //get fObj under stroke

          //top part:    exclude sawcut
          //bottom part: include sawcut


          //create output objects



          //remove strokes
          arr_fObj.forEach((fObj) => {
            this.fabricCanvas.remove(fObj);
          });

        }

        getPart(fObj__src, fObj__sliceStroke, isTopLeft = true) {
          var outfObj;

          return outFObj;
        }


        enterInnerPainting() {
          const fabricIntegration = this;

          const brush = this.fabricCanvas.freeDrawingBrush;

          brush.width = 20;

          // const rgbColor = this.inputProperties.getActiveColor();
          // const opacity  = this.inputProperties.getActiveOpacity();
          const rgbaColorString = this.inputProperties.getActiveRgbaColorString();

          const fColor = new fabric.Color(rgbaColorString);
          logger.log("fColor", fColor);
          const rgbColor = fColor.toRgb();
          const opacity = fColor.getAlpha();

          // brush.color   = this.inputProperties.getActiveColor();
          brush.color = rgbaColorString;

          this.fabricCanvas.isDrawingMode = true;

          this.current_freeDrawing_objects = [];
          function freeDrawing_objectAdded(e) {
            console.log("freeDrawing_objectAdded", e);

            const fObj = e.target;
            fObj.set({
              stroke: rgbColor,
              opacity: opacity,
            });

            fabricIntegration.current_freeDrawing_objects.push(e.target);
            // console.log("fabricIntegration.current_freeDrawing_objects", fabricIntegration.current_freeDrawing_objects);
          }

          this.freeDrawing_objectAdded = freeDrawing_objectAdded;
          this.fabricCanvas.on('object:added', this.freeDrawing_objectAdded);

        }

        leaveInnerPainting() {
          this.fabricCanvas.isDrawingMode = false;
          this.fabricCanvas.off('object:added', this.freeDrawing_objectAdded);

          //get newly created fabric objects
          // var last = canvas_objects[canvas_objects.length -1]; //Get last object
          const freeDrawing_objects_created = [...this.current_freeDrawing_objects];
          this.current_freeDrawing_objects = [];

          this.manageCreatedFreeDrawingObjects(freeDrawing_objects_created);

        }

        manageInnerPainting(arr_fObj) {
          console.log("manageInnerPainting", arr_fObj);

          //group newly created fabric objects (or not (for easy delete))

          //create icObj from fObj
          arr_fObj.forEach((fObj) => {
            const icObj = this.infiniteCanvas.createIcFreeDrawing_from_freeDrawingFObj(fObj);
            this.infiniteCanvas.addNewIcObject(icObj);

            //SHU: HERE WE COULD HAVE RECYCLED ALREADY CREATED FOBJ AND AVOID RECREATING A NEW ONE
            this.fabricCanvas.remove(fObj);
          });

        }



        getFColor__under_cursor_p() {
          var out_p;

          const fabricIntegration = this;

          const fabricCanvas = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;
          const cursor = infiniteCanvas.cursor;

          logger.log("fabricCanvas", fabricCanvas);

          // //global     //SHU: this is working
          // {
          //   const html_elt = document.body;
          //   logger.log("html_elt", html_elt);
          //
          //   const canvasElt_p = html2canvas(html_elt);
          //
          //   const magicValue = 0.75; //SHU: ugliness is my co-pilot
          //   const pos = {
          //     x: Math.floor(cursor.x * magicValue),
          //     y: Math.floor(cursor.y * magicValue),
          //   };
          //
          //   const color_p = canvasElt_p
          //   // .then((canvasElt) => {
          //   //
          //   //   const dataURL = canvasElt.toDataURL('png');
          //   //   logger.log("dataURL", dataURL);
          //   //   FileIntegration.save_image(dataURL, "canvas_debug");
          //   //
          //   //   return canvasElt;
          //   // })
          //   .then((canvasElt) => {
          //     logger.log("canvasElt", canvasElt);
          //
          //     return fabricIntegration.getFColor__atPos(canvasElt, pos);
          //   });
          //
          //   out_p = color_p;
          // }

          //local 1
          {
            const canvasElt = fabricCanvas;
            // const canvasElt = fabricCanvas.lowerCanvasEl;
            // const canvasElt = fabricCanvas.upperCanvasEl;

            const pos__cursor__ic = infiniteCanvas.toNoOrPoint(cursor);
            const pos__cursor__screen = infiniteCanvas.toScreenPoint(pos__cursor__ic);

            const canvasElt_p = Promise.resolve(canvasElt);

            const color_p = canvasElt_p
              .then((canvasElt) => {
                logger.log("canvasElt", canvasElt);

                return fabricIntegration.getFColor__atPos(canvasElt, pos__cursor__screen);
              });

            out_p = color_p;
          }

          // //local 2
          // {
          //   //get fObj under cursor
          //
          //   //render fObj only
          //
          //   //get color
          // }

          return out_p;
        }

        getFColor__atPos(canvas, pos) {
          var outFColor;

          logger.log("pos", pos.x, pos.y);

          const ctx = canvas.getContext("2d");
          logger.log("ctx", ctx);

          const px = ctx.getImageData(pos.x, pos.y, 1, 1).data;
          //debug
          // const px = ctx.getImageData(180, 180, 1, 1).data;
          // const px = ctx.getImageData(252, 297, 1, 1).data;
          // const px = ctx.getImageData(260, 297, 1, 1).data;

          logger.log("px", px);

          // const dataURL = canvas.toDataURL('png');
          // const fImg = new fabric.Image(dataUrl);

          const r = px[0];
          const g = px[1];
          const b = px[2];
          var a;
          if (px.length == 4) {
            a = px[3] / 255.0;
          } else {
            a = 1;
          }

          const rgbaString = 'rgba(' + [r, g, b, a].join(",") + ')';
          logger.log("rgbaString", rgbaString);

          outFColor = new fabric.Color(rgbaString);

          return outFColor;
        }








        deleteSelection() {
          const fabricIntegration = this;

          const fObj = this.fabricCanvas.getActiveObject();

          fabricIntegration.deleteGeneralFObj(fObj);
        }

        deleteAllObjects() {
          const fabricIntegration = this;

          const arr_fObj = this.fabricCanvas.getObjects();

          arr_fObj.forEach((fObj, i) => {
            fabricIntegration.deleteAtomicFObj(fObj);
          });

        }

        deleteAtomicFObj(fObj_to_delete) {
          const fabricIntegration = this;

          const icObj = fObj_to_delete.icObj;

          if (icObj.isSupervessel) {
            //ignore
            return;
          }

          icObj.delete_p()
            .then(() => {
              fabricIntegration.removeFabricObject(fObj_to_delete);
              icObj.im_dying_now = false;
              icObj.im_dead_now = true;
            })
            .catch(err => {
              console.log("fObj.icObj.delete_p", "error", err);
            });

        }

        deleteGeneralFObj(fObj) {
          const fabricIntegration = this;

          if (fObj instanceof fabric.ActiveSelection) {

            fObj.getObjects().forEach((fObj, i) => {
              fabricIntegration.deleteAtomicFObj(fObj);
            });

            fabricIntegration.fabricCanvas.discardActiveObject();
            fabricIntegration.fabricCanvas.requestRenderAll();

          } else {
            fabricIntegration.deleteAtomicFObj(fObj);
          }

        }



        shouldIgnoreShortcutInput() {
          var outBool;

          const fObj = this.fabricCanvas.getActiveObject();
          if (fObj) {
            outBool = fObj.isEditing;
          } else {
            outBool = false;
          }

          return outBool;
        }




        initializeFabricObjectCopyCut() {
          const fabricIntegration = this;

          const legacyOnCopyFunc = document.oncopy;
          document.oncopy = function (event) {

            if (legacyOnCopyFunc) {
              legacyOnCopyFunc(event);
            }

            fabricIntegration.copySelection(event);
          };

          const legacyOnCutFunc = document.oncut;
          document.oncut = function (event) {

            if (legacyOnCutFunc) {
              legacyOnCutFunc(event);
            }

            fabricIntegration.cutSelection(event);
          };

        }

        copySelection(event) {
          console.log("copySelection", event);

          const clipboardIntegration = this.clipboardIntegration;
          // this.fabricCanvas.getActiveObject().clone(function(cloned) {
          //   clipboardIntegration.manageInnerCopy("fabric.general", cloned);
          // });
          const icObj = this.fabricCanvas.getActiveObject().icObj;
          const cloned = icObj.deepClone();
          cloned.position.x += 10;
          cloned.position.y += 10;

          clipboardIntegration.manageInnerCopy("fabric.general", cloned);
        }

        cutSelection(event) {
          console.log("cutSelection", event);

          //copy
          this.copySelection(event);

          //remove object
          const icObj = this.fabricCanvas.getActiveObject().icObj;
          // const fObj  = this.fabricCanvas.getActiveObject();

          const infiniteCanvas = this.infiniteCanvas;
          infiniteCanvas.removeIcObject(icObj);
        }


        setAntiAliasEnabled(enabled) {
          console.log("setAntiAliasEnabled", enabled);
          this.fabricCanvas.imageSmoothingEnabled = enabled;
          this.fabricCanvas.requestRenderAll();
        }




        //Groups

        groupSelectedObjects() {

          //get selected objects
          const canvas = this.fabricCanvas;

          if (!canvas.getActiveObject()) {
            return;
          }
          if (canvas.getActiveObject().type !== 'activeSelection') {
            return;
          }

          const activeSelection = canvas.getActiveObject();
          console.log("activeSelection to create group", activeSelection);

          const fObj = canvas.getActiveObject().toGroup();
          console.log("fabric created group", fObj);

          // const fObj_childObjects = fObj.getObjects();
          // console.log("fObj_childObjects", fObj_childObjects);

          const icObj = infiniteCanvas.createIcGroup_from_groupFObj(fObj);
          fObj.icObj = icObj;

          //debug
          // const fRect = new fabric.Rect();
          // fRect.set({
          //   left:   fObj.left,
          //   top:    fObj.top,
          //   width:  fObj.width,
          //   height: fObj.height,
          //
          //   fill: 'red',
          // });
          // this.fabricCanvas.add(fRect);

          {
            const fRect = new fabric.Rect();

            const trueRect = infiniteCanvas.toTrueRect(fObj);
            const position = Geometry.getPointTL(trueRect);
            const size = Geometry.createSize(trueRect.width, trueRect.height);

            const homeScale = Object.assign({}, infiniteCanvas.scale);

            const type = "rect";
            const icObj = infiniteCanvas.createIcObject(type, position, size, homeScale);

            const position_screen = icObj.getScreenPositionWithoutOffset();
            // console.log("position_screen", position_screen);
            const homeSize_screen = icObj.getHomeScreenSize();
            // console.log("homeSize_screen", homeSize_screen);

            fRect.set({
              left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
              top: position_screen.y,

              width: homeSize_screen.width,
              height: homeSize_screen.height,

              fill: 'red',
            });

            this.fabricCanvas.add(fRect);
          }



          //test pour le moment
          // this.fabricCanvas.remove(fObj);



          icObj.children.forEach((child_icObj, i) => {
            infiniteCanvas.removeIcObject(child_icObj);
          });
          infiniteCanvas.addIcObject(icObj);


          canvas.requestRenderAll();

        }

        ungroupSelectedObject() {

          const canvas = this.fabricCanvas;

          if (!canvas.getActiveObject()) {
            return;
          }
          if (canvas.getActiveObject().type != 'group') {
            return;
          }
          canvas.getActiveObject().toActiveSelection();
          canvas.requestRenderAll();

        }


        //Composites

        composeSelectedObjects() {
          console.log("composeSelectedObjects");
          const infiniteCanvas = this.infiniteCanvas;

          //get selected objects
          const canvas = this.fabricCanvas;

          const activeObject = canvas.getActiveObject();
          if (activeObject == null) {
            return;
          }
          if (activeObject.type != 'activeSelection') {
            console.log("can only compose objects from an activeSelection");
            return;
          }

          const activeSelection = activeObject;
          console.log("activeSelection", activeSelection);

          const arr_fObj = activeSelection.getObjects();

          this.deselectAll();



          const arr_topLevelFObj = arr_fObj.filter(fObj => {
            const isTopLevelObj = !fObj.icObj.isCompositePart;
            return isTopLevelObj;
          });

          const arr_topLevelIcObj = arr_topLevelFObj.map((fObj, i) => {
            return fObj.icObj;
          });

          const arr_topLevelIcObj_without_supervessel = arr_topLevelIcObj.filter(icObj => {
            const isSupervessel = (icObj.isSupervessel != null) && icObj.isSupervessel;
            return !isSupervessel;
          });

          infiniteCanvas.compose(arr_topLevelIcObj_without_supervessel);

          // this.deselectAll();
          // canvas.renderAll();

        }

        decomposeSelectedObject() {
          console.log("decomposeSelectedObject");
          const infiniteCanvas = this.infiniteCanvas;

          const canvas = this.fabricCanvas;

          var icObj_composite;

          const activeObject = canvas.getActiveObject();
          if (activeObject.type == 'activeSelection') {
            const activeSelection = activeObject;
            const arr_fObj = activeSelection.getObjects();
            const arr_icObj = arr_fObj.map((fObj, i) => {
              return fObj.icObj;
            });
            icObj_composite = arr_icObj.find(icObj => (icObj.type == "composite"));

          } else if (activeObject != null) {
            const fObj = activeObject;
            const icObj = fObj.icObj;

            if (icObj.isSupervessel) {   //SHU: at last...
              //ignore
              return;
            }

            if (icObj.type == "composite") {
              icObj_composite = icObj;
            }
          }

          if (icObj_composite != null) {
            this.deselectAll();
            infiniteCanvas.decompose(icObj_composite);
          }

        }



        //spread
        spreadSelectedObjects() {
          console.log("composeSelectedObjects");
          const infiniteCanvas = this.infiniteCanvas;

          //get selected objects
          const canvas = this.fabricCanvas;

          const activeObject = canvas.getActiveObject();
          if (activeObject == null) {
            return;
          }
          if (activeObject.type != 'activeSelection') {
            console.log("can only compose objects from an activeSelection");
            return;
          }

          const activeSelection = activeObject;
          console.log("activeSelection", activeSelection);

          const arr_fObj = activeSelection.getObjects();

          this.deselectAll();



          const arr_topLevelFObj = arr_fObj.filter(fObj => {
            const isTopLevelObj = !fObj.icObj.isCompositePart;
            return isTopLevelObj;
          });

          const arr_topLevelIcObj = arr_topLevelFObj.map((fObj, i) => {
            return fObj.icObj;
          });

          const arr_topLevelIcObj_without_supervessel = arr_topLevelIcObj.filter(icObj => {
            const isSupervessel = (icObj.isSupervessel != null) && icObj.isSupervessel;
            return !isSupervessel;
          });


          // infiniteCanvas.spreadApart__centered(arr_topLevelIcObj_without_supervessel);
          // infiniteCanvas.spreadApart__recursive(arr_topLevelIcObj_without_supervessel);
          infiniteCanvas.spreadApart__2by2(arr_topLevelIcObj_without_supervessel);
        }




        getFObjForIcObj(icObj) {
          const fObj = this.fObjForIcObj_dict[icObj.id];

          if (!fObj) {
            console.log("icObj", icObj);
            console.log("this.fObjForIcObj_dict", this.fObjForIcObj_dict);
            throw new Error("fObj not found for icObj.id: " + icObj.id);
          }

          return fObj;
        }


        //Composites

        linkSelectedObjects() {
          console.log("linkSelectedObjects");
          const infiniteCanvas = this.infiniteCanvas;

          //get selected objects
          const canvas = this.fabricCanvas;

          const activeObject = canvas.getActiveObject();
          if (activeObject == null) {
            return;
          }
          if (activeObject.type != 'activeSelection') {
            console.log("can only compose objects from an activeSelection");
            return;
          }

          const activeSelection = activeObject;
          console.log("activeSelection", activeSelection);

          const arr_fObj = activeSelection.getObjects();

          this.deselectAll();



          const arr_topLevelFObj = arr_fObj.filter(fObj => {
            const isTopLevelObj = !fObj.icObj.isCompositePart;
            return isTopLevelObj;
          });

          const arr_topLevelIcObj = arr_topLevelFObj.map((fObj, i) => {
            return fObj.icObj;
          });

          const arr_topLevelIcObj_without_supervessel = arr_topLevelIcObj.filter(icObj => {
            const isSupervessel = (icObj.isSupervessel != null) && icObj.isSupervessel;
            return !isSupervessel;
          });

          const icObj__1 = arr_topLevelIcObj_without_supervessel[0];
          const icObj__2 = arr_topLevelIcObj_without_supervessel[1];

          infiniteCanvas.link(icObj__1, icObj__2);
        }

        unlinkSelectedObjects() {
          console.log("unlinkSelectedObjects");
          const infiniteCanvas = this.infiniteCanvas;

          const canvas = this.fabricCanvas;

          var icObj_link;

          const activeObject = canvas.getActiveObject();
          if (activeObject.type == 'activeSelection') {
            const activeSelection = activeObject;
            const arr_fObj = activeSelection.getObjects();
            const arr_icObj = arr_fObj.map((fObj, i) => {
              return fObj.icObj;
            });
            icObj_link = arr_icObj.find(icObj => (icObj.type == "link"));

          } else if (activeObject != null) {
            const fObj = activeObject;
            const icObj = fObj.icObj;

            if (icObj.isSupervessel) {   //SHU: at last...
              //ignore
              return;
            }

            if (icObj.type == "link") {
              icObj_link = icObj;
            }
          }

          if (icObj_link != null) {
            this.deselectAll();
            infiniteCanvas.unlink(icObj_link);
          }

        }



        // syncWithIcObj(icObj) {
        //   const fObj = this.getFObjForIcObj(icObj);
        //   this.updateFObjWithIcObj(fObj, icObj);
        //
        //   this.fabricCanvas.requestRenderAll();
        //   // this.fabricCanvas.renderAll();
        // }
        //

        //
        // updateFObjWithIcObj(fObj, icObj) {
        //   logger.log("updateFObjWithIcObj", fObj, icObj);
        //
        //   function configureWithIsActive(fObj, isActive) {
        //
        //     const cfg = isActive ? fObj.icObj.activeCfg : fObj.icObj.inactiveCfg;
        //
        //     fObj.set({
        //       fill:    cfg.fill,
        //       opacity: cfg.opacity,
        //     });
        //
        //     fObj.set("dirty", true);
        //   }
        //
        //   configureWithIsActive(fObj, icObj.isActive);
        //
        //   // fObj.setCoords();
        // }


        prepareSingleUseBehavior(behaviorName) {
          const fabricIntegration = this;
          fabricIntegration.singleUseBehaviors[behaviorName] = true;
        }


      }


















      /*******************/


      class Geometry {

        static createPoint(x, y) {
          const point = {
            x: x,
            y: y,
          };
          return point;
        }

        static createRect(x, y, w, h) {
          const rect = {
            left: x,
            top: y,
            width: w,
            height: h,
          };
          return rect;
        }

        static createLTRect(xyRect) {
          return Geometry.createRect(xyRect.x, xyRect.y, xyRect.width, xyRect.height);
        }

        static createXYRect(ltRect) {
          const xyRect = {
            x: ltRect.left,
            y: ltRect.top,
            width: ltRect.width,
            height: ltRect.height,
          };
          return xyRect;
        }

        static createCenteredXYRect(pointCenter, w, h) {
          const xyRect = {
            x: pointCenter.x - w / 2.0,
            y: pointCenter.y - h / 2.0,
            width: w,
            height: h,
          };
          return xyRect;
        }



        static getCenterScaledRect(ltRect, scale) {
          const pointCenter = Geometry.getCenterPoint(ltRect);
          const width = ltRect.width * scale;
          const height = ltRect.height * scale;

          const xyRect = Geometry.createCenteredXYRect(pointCenter, width, height);
          return xyRect;
        }

        static getCenterScaledPolygon(arr_point, scale) {
          const rect__enveloppe = Geometry.getEnveloppeRect(arr_point);
          logger.log("rect__enveloppe", rect__enveloppe);
          const pointCenter = Geometry.getCenterPoint(Geometry.createLTRect(rect__enveloppe));
          logger.log("pointCenter", pointCenter);

          const arr_point__scaled = arr_point.map((point) => {
            const point__scaled = Geometry.getCenterScaledPoint(pointCenter, point, scale);
            return point__scaled;
          });
          logger.log("arr_point__scaled", arr_point__scaled);

          return arr_point__scaled;
        }

        static getCenterScaledPoint(pointCenter, pointSrc, scale) {
          const v = {
            X: pointSrc.x - pointCenter.x,
            Y: pointSrc.y - pointCenter.y,
          };
          const x = pointCenter.x + v.X * scale;
          const y = pointCenter.y + v.Y * scale;

          return Geometry.createPoint(x, y);
        }

        static getTranslatedPolygon(arr_point, point__src, point__dst) {
          const v = Geometry.vector_2d(point__src, point__dst);
          const arr_point__translated = arr_point.map((point) => {
            return Geometry.translatedPoint(point, v);
          });
          return arr_point__translated;
        }

        static vector_2d(p1, p2) {
          const v = {
            X: p2.x - p1.x,
            Y: p2.y - p1.y,
          };
          return v;
        }

        static translatedPoint(point, v) {
          const x = point.x + v.X;
          const y = point.y + v.Y;
          return Geometry.createPoint(x, y);
        }


        static createLine(point0, point1) {
          const line = {
            x0: point0.x,
            y0: point0.y,

            x1: point1.x,
            y1: point1.y,
          }
          return line;
        }

        static createTriangle() {
          const pointA = Geometry.createPoint(100, 100);
          const pointB = Geometry.createPoint(0, 300);
          const pointC = Geometry.createPoint(-100, -200);

          const lineAB = Geometry.createLine(pointA, pointB);
          const lineAC = Geometry.createLine(pointA, pointC);
          const lineBC = Geometry.createLine(pointB, pointC);

          const lines = [lineAB, lineAC, lineBC];
          return lines;
        }

        static createAxes() {
          const length = 10000;

          const pointX0 = Geometry.createPoint(0, 0);
          const pointX1 = Geometry.createPoint(length, 0);
          const lineX = Geometry.createLine(pointX0, pointX1);

          const pointY0 = Geometry.createPoint(0, 0);
          const pointY1 = Geometry.createPoint(0, length);
          const lineY = Geometry.createLine(pointY0, pointY1);

          const lines = [lineX, lineY];
          return lines;
        }



        static createSize(width, height) {
          const size = {
            width: width,
            height: height,
          };
          return size;
        }



        static rectForRectRel(rect, rect_rel) {
          var outRect;

          outRect = {
            x: rect.x + rect_rel.l * rect.width,
            y: rect.y + rect_rel.t * rect.height,
            width: (rect_rel.r - rect_rel.l) * rect.width,
            height: (rect_rel.b - rect_rel.t) * rect.height,
          };

          return outRect;
        }




        static containedRect(containerRect, size) {
          var outRect;

          const containerSize = {
            width: containerRect.width,
            height: containerRect.height,
          };
          const containedSize_ = Geometry.containedSize(containerSize, size);


          const center = Geometry.getCenterPoint(containerRect);
          const offset = {
            dx: - containedSize_.width / 2,
            dy: - containedSize_.height / 2,
          };
          const pointTL = Geometry.createPointWithOffset(center, offset);


          outRect = createRect(pointTL.x, pointTL.y, containedSize_.width, containedSize_.height);
          return outRect;
        }

        static getPointTL(rect) {
          const pointTL = Geometry.createPoint(rect.left, rect.top);
          return pointTL;
        }

        static getPointBR(rect) {
          const pointBR = Geometry.createPoint(rect.left + rect.width, rect.top + rect.height);
          return pointBR;
        }

        static getCenterPoint(rect) {
          const pointTL = Geometry.getPointTL(rect);
          const offset = {
            dx: rect.width / 2,
            dy: rect.height / 2,
          };
          return Geometry.createPointWithOffset(pointTL, offset);
        }

        static createPointWithOffset(point, offset) {
          return Geometry.createPoint(point.x + offset.dx, point.y + offset.dy);
        }

        static containedSize(containerSize, size) {
          var outSize;

          const size_ratio__container = containerSize.width / containerSize.height;
          const size_ratio__rect = size.width / size.height;

          //console.log("size_ratio__container", size_ratio__container);
          //console.log("size_ratio__rect", size_ratio__rect);


          var scaleFactor;
          if (size_ratio__container > size_ratio__rect) {
            scaleFactor = containerSize.height / size.height;
          } else {
            scaleFactor = containerSize.width / size.width;
          }

          //console.log("scaleFactor", scaleFactor);


          outSize = {
            width: size.width * scaleFactor,
            height: size.height * scaleFactor,
          }

          return outSize;
        }

        static getRectRadius(rect) {
          const pointTL = Geometry.getPointTL(rect);
          const pointBR = Geometry.getPointBR(rect);
          const v__diagonal = Geometry.vector_2d(pointTL, pointBR);
          const norm__diagonal = Geometry.norm_2d(v__diagonal);
          const radius = norm__diagonal / 2.0;
          return radius;
        }



        static dotProduct_2d(v1, v2) {
          return v1.x * v2.x + v1.y * v2.y;
        }

        static norm_2d(v1_in) {
          logger.log("norm_2d", v1_in);
          var v1 = v1_in;
          if (v1.x == null) {    //SHU: buerk
            v1.x = v1.X;
            v1.y = v1.Y;
          }
          const v1Dotv1 = Geometry.dotProduct_2d(v1, v1);
          logger.log("v1Dotv1", v1Dotv1);
          return Math.sqrt(v1Dotv1);
        }

        static vector_3d(v1, z = 0) {
          return {
            x: v1.x,
            y: v1.y,
            z: z,
          };
        }

        static dotProduct_3d(v1, v2) {
          return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
        }

        static crossProduct_3d(v1, v2) {
          return {
            x: v1.y * v2.z - v1.z * v2.y,
            y: v1.z * v2.x - v1.x * v2.z,
            z: v1.x * v2.y - v1.y * v2.x,
          };
        }

        static boundedAngleInDegrees(angleInDegrees) {

          var angleInDegrees_bounded = angleInDegrees;

          angleInDegrees_bounded = angleInDegrees_bounded % 360;
          if (angleInDegrees_bounded < 0) {
            angleInDegrees_bounded += 360;
          }

          return angleInDegrees_bounded;
        }

        static pointWithRotation(point_from, point_center, angleInDegrees) {
          console.log("pointWithRotation", point_from, point_center, angleInDegrees);

          const v = {
            x: point_from.x - point_center.x,
            y: point_from.y - point_center.y,
          };
          console.log("v.x", v.x);
          console.log("v.y", v.y);

          // const radius = Geometry.norm_2d(v);

          const angleInRadians = angleInDegrees / 180 * Math.PI;

          const dx = Math.cos(angleInRadians) * v.x - Math.sin(angleInRadians) * v.y;
          const dy = Math.sin(angleInRadians) * v.x + Math.cos(angleInRadians) * v.y;
          console.log("dx", dx);
          console.log("dy", dy);


          const point_to = {
            x: point_center.x + dx,
            y: point_center.y + dy,
          };


          return point_to;
        }

        static getPointFromRectToRect(point_from, rect_from, rect_to) {
          const point_to = {
            x: point_from.x * (rect_to.width / rect_from.width),
            y: point_from.y * (rect_to.height / rect_from.height),
          };

          return point_to;
        }


        static createLRTBRect(rect) {
          const lrtb = {
            left: rect.left,
            right: rect.left + rect.width,
            top: rect.top,
            bottom: rect.top + rect.height,
          };
          return lrtb;
        }

        static intersectRect(rect1, rect2) {
          // logger.log("intersectRect", rect1, rect2);

          const r1 = this.createLRTBRect(rect1);
          // logger.log("r1", r1);
          const r2 = this.createLRTBRect(rect2);
          // logger.log("r2", r2);

          return !(r2.left > r1.right ||
            r2.right < r1.left ||
            r2.top > r1.bottom ||
            r2.bottom < r1.top);
        }

        // static intersectRect(rect1, rect2) {
        //   const r1 = {
        //     x: rect1.x,
        //     y: rect1.y,
        //     w: rect1.width,
        //     h: rect1.height,
        //   };
        //   const r2 = {
        //     x: rect2.x,
        //     y: rect2.y,
        //     w: rect2.width,
        //     h: rect2.height,
        //   };
        //
        //   var quickCheck = (r1.x <= r2.x + r2.w &&
        //           r2.x <= r1.x + r1.w &&
        //           r1.y <= r2.y + r2.h &&
        //           r2.y <= r1.y + r1.h);
        //   if (quickCheck) return true;
        //   var x_overlap = Math.max(0, Math.min(r1.x + r1.w, r2.x + r2.w) - Math.max(r1.x, r2.x));
        //   var y_overlap = Math.max(0, Math.min(r1.y + r1.h, r2.y + r2.h) - Math.max(r1.y, r2.y));
        //   var overlapArea = x_overlap * y_overlap;
        //   return !(overlapArea == 0);
        // }



        static distance(p1, p2) {
          const v = {
            x: p2.x - p1.x,
            y: p2.y - p1.y,
          };

          const norm = this.norm_2d(v);

          return norm;
        }

        //point on object

        static pointOnCircle__angleInRadians(pointCenter, radius, angleInRadians) {
          const x = pointCenter.x + radius * Math.cos(-angleInRadians);  //conventional anticlockwise rotation
          const y = pointCenter.y + radius * Math.sin(-angleInRadians);
          const point = Geometry.createPoint(x, y);
          return point;
        }

        static pointOnCircle__angleInDegrees(pointCenter, radius, angleInDegrees) {
          const angleInRadians = angleInDegrees / 180.0 * Math.PI;
          return Geometry.pointOnCircle__angleInRadians(pointCenter, radius, angleInRadians);
        }

        static pointOnCircle__progress(pointCenter, radius, progress) {
          const angleInDegrees = progress * 360.0;
          return Geometry.pointOnCircle__angleInDegrees(pointCenter, radius, angleInDegrees);
        }

        static pointOnEllipse__angleInRadians(pointCenter, rx, ry, angleInRadians) {
          logger.log("pointOnEllipse__angleInRadians", pointCenter, rx, ry, angleInRadians);
          const x = pointCenter.x + rx * Math.cos(-angleInRadians);    //conventional anticlockwise rotation
          const y = pointCenter.y + ry * Math.sin(-angleInRadians);
          const point = Geometry.createPoint(x, y);
          return point;
        }

        static pointOnEllipse__angleInDegrees(pointCenter, rx, ry, angleInDegrees) {
          const angleInRadians = angleInDegrees / 180.0 * Math.PI;
          return Geometry.pointOnEllipse__angleInRadians(pointCenter, rx, ry, angleInRadians);
        }

        static pointOnEllipse__progress(pointCenter, rx, ry, progress) {
          const angleInDegrees = progress * 360.0;
          return Geometry.pointOnEllipse__angleInDegrees(pointCenter, rx, ry, angleInDegrees);
        }

        static pointOnPath__progress(path, progress) {
          //get total path length

          //get point at arc position : progress * total_length

        }

        static pointOnSegment__progress(point1, point2, progress) {
          const v = {
            X: (point2.x - point1.x) * progress,
            Y: (point2.y - point1.y) * progress,
          };
          return Geometry.translatedPoint(point1, v);
        }



        static pointOnSquare__angleInRadians(pointCenter, radius, angleInRadians) {
          var x;
          var y;
          const index_quarter = Math.floor((angleInRadians /*+ Math.PI / 4*/) / (Math.PI / 2));
          logger.log("index_quarter", index_quarter);
          switch (index_quarter) {
            case 0:
              x = pointCenter.x + radius;
              y = pointCenter.y + radius * Math.tan(-angleInRadians);
              break;
            case 1:
              x = pointCenter.y - radius / Math.tan(-angleInRadians);
              y = pointCenter.x - radius;
              break;
            case 2:
              x = pointCenter.x - radius;
              y = pointCenter.y - radius * Math.tan(-angleInRadians);
              break;
            case 3:
              x = pointCenter.y + radius / Math.tan(-angleInRadians);
              y = pointCenter.x + radius;
              break;
            default:
              throw new Error("angleInRadians must be between 0 and 2*Math.PI");
              break;
          }
          const point = Geometry.createPoint(x, y);
          return point;
        }

        static pointOnSquare__angleInDegrees(pointCenter, radius, angleInDegrees) {
          const angleInRadians = angleInDegrees / 180.0 * Math.PI;
          return Geometry.pointOnSquare__angleInRadians(pointCenter, radius, angleInRadians);
        }

        static pointOnSquare__progress(pointCenter, radius, progress) {
          const angleInDegrees = progress * 360.0;
          return Geometry.pointOnSquare__angleInDegrees(pointCenter, radius, angleInDegrees);
        }


        static getEnveloppeRect(arr_point) {

          const point0 = arr_point[0];
          const obj_tlbr = arr_point.reduce((acc, point) => {
            acc.left = Math.min(point.x, acc.left);
            acc.right = Math.max(point.x, acc.right);
            acc.top = Math.min(point.y, acc.top);
            acc.bottom = Math.max(point.y, acc.bottom);
            return acc;
          }, {
            left: point0.x,
            right: point0.x,
            top: point0.y,
            bottom: point0.y,
          });

          const outRect = {
            x: obj_tlbr.left,
            y: obj_tlbr.top,
            width: (obj_tlbr.right - obj_tlbr.left),
            height: (obj_tlbr.bottom - obj_tlbr.top),
          };

          return outRect;
        }

        static pointWithHomothety(pointSrc, pointCenter, factor) {
          const v = {
            x: pointSrc.x - pointCenter.x,
            y: pointSrc.y - pointCenter.y,
          };
          const pointDst = {
            x: pointCenter.x + v.x * factor,
            y: pointCenter.y + v.y * factor,
          };
          return pointDst;
        }


      }


      const SnapState = {
        "Unsnapped": "Unsnapped",
        "Presnapped": "Presnapped",
        "Snapped": "Snapped",
      };

      class Snap { //GeometryWise snapping

        static canSnap(icObj_over, icObj_below) { //SHU: what would be nice would be to use the norm of a transformation matrix to settle threshold
          // const ratio__position        = {
          //   x:  (icObj_over.position.x - icObj_below.position.x) / icObj_below.position.x,
          //   y:  (icObj_over.position.y - icObj_below.position.y) / icObj_below.position.y,
          // };
          // console.log("ratio__position", ratio__position);
          // if(!(Math.abs(ratio__position.x) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__position.y) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__size        = {
          //   width:  (icObj_over.size.width  - icObj_below.size.width)  / icObj_below.size.width,
          //   height: (icObj_over.size.height - icObj_below.size.height) / icObj_below.size.height,
          // };
          // console.log("ratio__size", ratio__size);
          // if(!(Math.abs(ratio__size.width) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__size.height) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__orientation = (icObj_over.orientation - icObj_below.orientation) / icObj_below.orientation;
          // console.log("ratio__orientation", ratio__orientation);
          // if(!(Math.abs(ratio__orientation) < 0.10)) {
          //   return false;
          // }


          //snapping params:
          // const snapping_params = {
          //   // position: {
          //   //   x: 0.10,
          //   //   y: 0.10,
          //   // },
          //   position: {
          //     x: 0.05,
          //     y: 0.05,
          //   },
          //   size: {
          //     width:  0.05,
          //     height: 0.05,
          //   },
          //   homeScale: {
          //
          //   },
          //   orientation: {
          //     orientation: 0.05,
          //   },
          // };

          const snapping_params = {
            // position: {
            //   x: 0.10,
            //   y: 0.10,
            // },
            position: {
              x: 0.50,
              y: 0.50,
            },
            size: {
              width: 0.05,
              height: 0.05,
            },
            // homeScale: {
            //   X:  0.05,
            //   Y:  0.05,
            // },
            orientation: {
              orientation: 0.05,
            },
          };


          //SHU TODO: a nice and complex canSnapFunc
          const canSnapFunc = (icObj_over, icObj_below) => {

          };


          // const unsamenessRatio__position = {
          //   x:  Snap.unsamenessRatio(icObj_over.position.x, icObj_below.position.x),
          //   y:  Snap.unsamenessRatio(icObj_over.position.y, icObj_below.position.y),
          // };
          // if(unsamenessRatio__position.x > snapping_params.position.x) {
          //   return false;
          // }
          // if(unsamenessRatio__position.y > snapping_params.position.y) {
          //   return false;
          // }

          const distance = Geometry.distance(icObj_over.position, icObj_below.position);
          console.log("distance", distance);
          if (distance > 200) {
            return false;
          }

          /*
          const unsamenessRatio__size = {
            width:  Snap.unsamenessRatio(icObj_over.size.width,  icObj_below.size.width),
            height: Snap.unsamenessRatio(icObj_over.size.height, icObj_below.size.height),
          };
          console.log("°°unsamenessRatio__size.width",  unsamenessRatio__size.width);
          console.log("°°icObj_over.size.width",  icObj_over.size.width);
          console.log("°°icObj_below.size.width",  icObj_below.size.width);

          console.log("°°unsamenessRatio__size.height", unsamenessRatio__size.height);
          console.log("°°icObj_over.size.height",  icObj_over.size.height);
          console.log("°°icObj_below.size.height",  icObj_below.size.height);

          if(unsamenessRatio__size.width > snapping_params.size.width) {
            return false;
          }
          if(unsamenessRatio__size.height > snapping_params.size.height) {
            return false;
          }

          const icObj_over__zero_centered_orientation  = (icObj_over.orientation > 180 ? icObj_over.orientation - 180 : icObj_over.orientation);
          const icObj_below__zero_centered_orientation = (icObj_below.orientation > 180 ? icObj_below.orientation - 180 : icObj_below.orientation);

          const unsamenessRatio__orientation = {
            // orientation: Snap.unsamenessRatio(icObj_over.orientation,  icObj_below.orientation),
            // orientation: Math.abs((icObj_over.orientation - icObj_below.orientation) / 360.0),
            orientation: Snap.unsamenessRatio(icObj_over__zero_centered_orientation,  icObj_below__zero_centered_orientation),
          };
          console.log("unsamenessRatio__orientation.orientation", unsamenessRatio__orientation.orientation);
          if(unsamenessRatio__orientation.orientation > snapping_params.orientation.orientation) {
            return false;
          }
          */

          return true;
        }

        static canSnap_noSize(icObj_over, icObj_below) {

          const snapping_params = {
            // position: {
            //   x: 0.10,
            //   y: 0.10,
            // },
            position: {
              x: 0.50,
              y: 0.50,
            },
            // size: {
            //   width:  0.05,
            //   height: 0.05,
            // },
            // homeScale: {
            //   X:  0.05,
            //   Y:  0.05,
            // },
            orientation: {
              orientation: 0.05,
            },
          };


          //SHU TODO: a nice and complex canSnapFunc
          const canSnapFunc = (icObj_over, icObj_below) => {

          };


          const unsamenessRatio__position = {
            x: Snap.unsamenessRatio(icObj_over.position.x, icObj_below.position.x),
            y: Snap.unsamenessRatio(icObj_over.position.y, icObj_below.position.y),
          };
          if (unsamenessRatio__position.x > snapping_params.position.x) {
            return false;
          }
          if (unsamenessRatio__position.y > snapping_params.position.y) {
            return false;
          }

          // const unsamenessRatio__size = {
          //   width:  Snap.unsamenessRatio(icObj_over.size.width,  icObj_below.size.width),
          //   height: Snap.unsamenessRatio(icObj_over.size.height, icObj_below.size.height),
          // };
          // console.log("°°unsamenessRatio__size.width",  unsamenessRatio__size.width);
          // console.log("°°icObj_over.size.width",  icObj_over.size.width);
          // console.log("°°icObj_below.size.width",  icObj_below.size.width);
          //
          // console.log("°°unsamenessRatio__size.height", unsamenessRatio__size.height);
          // console.log("°°icObj_over.size.height",  icObj_over.size.height);
          // console.log("°°icObj_below.size.height",  icObj_below.size.height);
          //
          // if(unsamenessRatio__size.width > snapping_params.size.width) {
          //   return false;
          // }
          // if(unsamenessRatio__size.height > snapping_params.size.height) {
          //   return false;
          // }

          const icObj_over__zero_centered_orientation = (icObj_over.orientation > 180 ? icObj_over.orientation - 180 : icObj_over.orientation);
          const icObj_below__zero_centered_orientation = (icObj_below.orientation > 180 ? icObj_below.orientation - 180 : icObj_below.orientation);

          const unsamenessRatio__orientation = {
            // orientation: Snap.unsamenessRatio(icObj_over.orientation,  icObj_below.orientation),
            // orientation: Math.abs((icObj_over.orientation - icObj_below.orientation) / 360.0),
            orientation: Snap.unsamenessRatio(icObj_over__zero_centered_orientation, icObj_below__zero_centered_orientation),
          };
          console.log("unsamenessRatio__orientation.orientation", unsamenessRatio__orientation.orientation);
          if (unsamenessRatio__orientation.orientation > snapping_params.orientation.orientation) {
            return false;
          }

          return true;
        }


        static canUnsnap(icObj_over, icObj_below) {
          return !this.canSnap(icObj_over, icObj_below);
        }

        /*
        static canUnsnap(icObj_over, icObj_below) { //SHU: what would be nice would be to use the norm of a transformation matrix to settle threshold
          // const ratio__position        = {
          //   x:  (icObj_over.position.x - icObj_below.position.x) / icObj_below.position.x,
          //   y:  (icObj_over.position.y - icObj_below.position.y) / icObj_below.position.y,
          // };
          // console.log("ratio__position", ratio__position);
          // if(!(Math.abs(ratio__position.x) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__position.y) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__size        = {
          //   width:  (icObj_over.size.width  - icObj_below.size.width)  / icObj_below.size.width,
          //   height: (icObj_over.size.height - icObj_below.size.height) / icObj_below.size.height,
          // };
          // console.log("ratio__size", ratio__size);
          // if(!(Math.abs(ratio__size.width) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__size.height) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__orientation = (icObj_over.orientation - icObj_below.orientation) / icObj_below.orientation;
          // console.log("ratio__orientation", ratio__orientation);
          // if(!(Math.abs(ratio__orientation) < 0.10)) {
          //   return false;
          // }


          //snapping params:
          const unsnapping_params = {
            // position: {
            //   x: 0.10,
            //   y: 0.10,
            // },
            position: {
              x: 0.10,
              y: 0.10,
            },
            size: {
              width:  0.10,
              height: 0.10,
            },
            orientation: {
              orientation: 0.10,
            },
          };

          // //SHU TODO: a nice and complex canUnsnapFunc
          // const canUnsnapFunc = (icObj_over, icObj_below) => {
          //
          // };


          const unsamenessRatio__position = {
            x:  Snap.unsamenessRatio(icObj_over.position.x, icObj_below.position.x),
            y:  Snap.unsamenessRatio(icObj_over.position.y, icObj_below.position.y),
          };
          if(unsamenessRatio__position.x < unsnapping_params.position.x) {
            return false;
          }
          if(unsamenessRatio__position.y < unsnapping_params.position.y) {
            return false;
          }

          const unsamenessRatio__size = {
            width:  Snap.unsamenessRatio(icObj_over.size.width,  icObj_below.size.width),
            height: Snap.unsamenessRatio(icObj_over.size.height, icObj_below.size.height),
          };
          if(unsamenessRatio__size.width < unsnapping_params.size.width) {
            return false;
          }
          if(unsamenessRatio__size.height < unsnapping_params.size.height) {
            return false;
          }

          const unsamenessRatio__orientation = {
            orientation: Snap.unsamenessRatio(icObj_over.orientation,  icObj_below.orientation),
          };
          if(unsamenessRatio__orientation.orientation < unsnapping_params.orientation.orientation) {
            return false;
          }

          return true;
        }
        */



        static unsamenessRatio(nb1, nb2) {
          var outNumber;
          outNumber = (nb1 - nb2);
          // if(outNumber != 0) {
          if (nb2 != 0) {
            outNumber = outNumber / nb2;
          }
          outNumber = Math.abs(outNumber);
          return outNumber;
        }

        static snapAnimation(icObj_over, icObj2_below) {

        }



        static defaultSnapEngine(infiniteCanvas, icSnapSlot) {
          var outSnapEngine;

          const canSnapFunc = (above, below) => {
            return Snap.canSnap(above, below);
          };

          const canUnsnapFunc = (above, below) => {
            return Snap.canUnsnap(above, below);
          };

          // const snapEngine = {
          //   canSnapFunc:   canSnapFunc,
          //   canUnsnapFunc: canUnsnapFunc,
          // };
          //
          // outSnapEngine = snapEngine;

          const snapEngine = SnapEngine.defaultInstance(infiniteCanvas, icSnapSlot);

          Hooker.installHooks(snapEngine, "presnap");
          // snapEngine.will["presnap"].on((...args) => {
          //   console.log("will presnap", ...args);
          // });
          // snapEngine.did["presnap"].on((...args) => {
          //   console.log("did presnap", ...args);
          // });
          Hooker.installHooks(snapEngine, "snap");
          Hooker.installHooks(snapEngine, "unsnap");



          snapEngine.canSnapFunc = canSnapFunc;
          snapEngine.canUnsnapFunc = canUnsnapFunc;

          outSnapEngine = snapEngine;

          return outSnapEngine;
        }

        static defaultSnapSlotConfig() {
          const canSnapFunc = (above, below) => {
            return Snap.canSnap(above, below);
          };

          const canUnsnapFunc = (above, below) => {
            return Snap.canUnsnap(above, below);
          };

          const snapSlotConfig = {
            canSnapFunc: canSnapFunc,
            canUnsnapFunc: canUnsnapFunc,
          };

          return snapSlotConfig;
        }

      }

      // class SnapEngine {
      //
      //   constructor() {
      //
      //   }
      //
      //   start() {
      //
      //   }
      //
      //   stop() {
      //
      //   }
      //
      //   static defaultInstance(infiniteCanvas, icSnapSlot) {
      //     var outEngine;
      //
      //     const snapEngine = new SnapEngine();
      //
      //     const attemptSnapping = function(icObj_slot, icObj_piece) {
      //       console.log("attemptSnapping", icObj_slot, icObj_piece);
      //
      //       const canSnap = snapEngine.checkCanSnap(icObj_slot, icObj_piece);
      //
      //       const rep_official = icObj_piece;
      //       console.log("attempting to snap with snapState: " + rep_official.snapState);
      //
      //       // const isValidPieceSnapState = (rep_official.snapState == SnapState.Unsnapped);
      //       //
      //       // if(isValidPieceSnapState) {
      //       //
      //       // } else {
      //       //   console.log("can't snap while snapState == " + rep_official.snapState)
      //       //   // throw new Error("attempting to snap with snapState: " + rep_official.snapState);
      //       //   return;
      //       // }
      //
      //       if(canSnap) {
      //         console.log("can snap");
      //
      //         const rep_official = icObj_piece;
      //         const represented  = icObj_piece.represented;
      //         const rep_free     = represented.getRepresentation("free");
      //
      //         console.log("rep_free.isHeld", rep_free.isHeld);
      //         if(rep_free.isHeld) {
      //           snapEngine.presnap(icObj_slot, icObj_piece);
      //         } else {
      //           snapEngine.presnap(icObj_slot, icObj_piece);
      //           snapEngine.snap(icObj_slot, icObj_piece);
      //         }
      //
      //       } else {
      //         console.log("can't snap");
      //       }
      //
      //     };
      //     snapEngine.attemptSnapping = attemptSnapping;
      //
      //     const checkCanSnap = function(icObj_slot, icObj_piece) {
      //       console.log("checkCanSnap", icObj_piece);
      //       var outBool;
      //
      //       // outBool = Snap.canSnap(icObj_piece, icObj_slot);
      //       outBool = snapEngine.canSnapFunc(icObj_piece, icObj_slot);
      //
      //       return outBool;
      //     };
      //
      //     var rep_free_onRelease__triggerSnap          = null;
      //     var rep_free_afterPresnap__attemptUnsnapping = null;
      //
      //     var rep_free_callbacks = {
      //       onRelease__triggerSnap:          null,
      //       afterPresnap__attemptUnsnapping: null,
      //     };
      //     snapEngine.checkCanSnap = checkCanSnap;
      //
      //     const presnap = function(icObj_slot, icObj_piece) {
      //       console.log("presnap", icObj_piece);
      //
      //       const rep_official = icObj_piece;
      //       const represented  = icObj_piece.represented;
      //       const rep_free     = represented.getRepresentation("free");
      //       const rep_snapped  = represented.createNewRepresentation("snapped");
      //
      //       rep_official.snapState = SnapState.Presnapped;
      //       // rep_official.snappedTo = icObj_slot;
      //       rep_official.snappedTo = icObj_slot.id;
      //
      //
      //       rep_official.unfollow(rep_free);
      //
      //
      //       rep_snapped.position     = Object.assign({}, icObj_slot.position);
      //       rep_snapped.homeScale    = Object.assign({}, icObj_slot.homeScale);
      //       rep_snapped.scale        = Object.assign({}, icObj_slot.scale);
      //       rep_snapped.orientation  = icObj_slot.orientation;
      //
      //       infiniteCanvas.addRepresentation(represented, rep_snapped);
      //
      //
      //       // rep_official.syncWith(rep_snapped);
      //       rep_official.syncWithObj({
      //         position:   rep_snapped.position,
      //         size:       rep_snapped.size,
      //         homeScale:  rep_snapped.homeScale,
      //         scale:      rep_snapped.scale,
      //
      //         // didUpdateListeners : rep_snapped.didUpdateListeners,
      //         // holdListeners      : rep_snapped.holdListeners,
      //         // releaseListeners   : rep_snapped.releaseListeners,
      //       });
      //       rep_official.follow(rep_snapped);
      //
      //
      //       rep_free.opacity = 0.0;
      //         //debug
      //       rep_free.opacity = 1.0;
      //       rep_free.fill = "blue";
      //
      //       //add release listener
      //       // icObj_fRep.onHold((icObj) => {
      //       //
      //       // });
      //
      //       //add release listener for rep_free
      //       rep_free_onRelease__triggerSnap = (rep_free) => {
      //         console.log("rep_free_onRelease__triggerSnap");
      //
      //         snapEngine.snap(icObj_slot, icObj_piece);
      //       };
      //       rep_free.onRelease(rep_free_onRelease__triggerSnap);
      //
      //
      //       //add unsnap listener for rep_free
      //       rep_free_afterPresnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
      //         console.log("rep_free_afterPresnap__attemptUnsnapping", rep_free);
      //
      //         snapEngine.attemptUnsnapping(icObj_slot, rep_free);
      //       };
      //       rep_free.onInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
      //
      //     };
      //     snapEngine.presnap = presnap;
      //
      //
      //     const snap = function(icObj_slot, icObj_piece) {
      //       console.log("snap", icObj_piece);
      //
      //       const rep_official = icObj_piece;
      //       const represented  = icObj_piece.represented;
      //       const rep_free     = represented.getRepresentation("free");
      //       const rep_snapped  = represented.getRepresentation("snapped");
      //
      //       console.log("**snap", "rep_free.isHeld", rep_free.isHeld);
      //
      //       console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
      //       if(rep_free_afterPresnap__attemptUnsnapping != null) {
      //         rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
      //       }
      //       rep_free_afterPresnap__attemptUnsnapping = null;
      //
      //
      //       rep_free.offRelease(rep_free_onRelease__triggerSnap);
      //       rep_free_onRelease__triggerSnap = null;
      //
      //
      //
      //       // rep_free.syncWith(rep_snapped);
      //       // rep_free.syncWith(rep_official);
      //
      //       //SHU TODO: MYSTERE ET BOULE DE GOMME: il y a un truc avec syncWith qui casse rep_free ... ???
      //
      //       rep_free.syncWithObj({
      //         position:   rep_snapped.position,
      //         size:       rep_snapped.size,
      //         homeScale:  rep_snapped.homeScale,
      //         scale:      rep_snapped.scale,
      //
      //         // didUpdateListeners : rep_snapped.didUpdateListeners,
      //         // holdListeners      : rep_snapped.holdListeners,
      //         // releaseListeners   : rep_snapped.releaseListeners,
      //       });
      //
      //
      //
      //       rep_free.opacity = 1.0;
      //         //debug
      //       rep_free.opacity = 1.0;
      //       rep_free.fill = "red";
      //
      //       rep_official.unfollow(rep_snapped);
      //       rep_official.follow(rep_free);
      //       rep_official.snapState = SnapState.Snapped;
      //       // rep_official.snappedTo = icObj_slot;
      //       // rep_official.snappedTo = icObj_slot.id;
      //
      //
      //
      //       console.log("remove rep_snapped", rep_snapped.id_rep);
      //       rep_snapped.im_dying_now = true;
      //       infiniteCanvas.removeRepresentation(represented, rep_snapped);
      //       represented.removeRepresentation(rep_snapped);
      //
      //       //add unsnap listener for rep_free
      //       // rep_free_afterSnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
      //       //   console.log("rep_free_afterSnap__attemptUnsnapping", rep_free);
      //       //
      //       //   attemptUnsnapping(icObj_slot, rep_free);
      //       // };
      //       // rep_free.onInnerUpdate(rep_free_afterSnap__attemptUnsnapping);
      //
      //
      //         //debug
      //       // rep_free.onHold((rep_free) => {
      //       //   console.log("###rep_free.id_rep", rep_free.id_rep);
      //       //   console.log("###rep_free.onHold", "rep_free.isHeld", rep_free.isHeld);
      //       // });
      //
      //     };
      //     snapEngine.snap = snap;
      //
      //
      //
      //
      //
      //     const attemptUnsnapping = function(icObj_slot, icObj_piece) {
      //       console.log("attemptUnsnapping", icObj_slot, icObj_piece);
      //
      //       const canUnsnap = snapEngine.checkCanUnsnap(icObj_slot, icObj_piece);
      //       console.log("canUnsnap", canUnsnap);
      //
      //       const rep_official = icObj_piece;
      //       console.log("attempting to unsnap with snapState: " + rep_official.snapState);
      //
      //       // const isValidPieceSnapState = (rep_official.snapState == SnapState.Presnapped);
      //       //
      //       // if(isValidPieceSnapState) {
      //       //
      //       // } else {
      //       //   console.log("can't unsnap while snapState == " + rep_official.snapState)
      //       //   // throw new Error("attempting to unsnap with snapState: " + rep_official.snapState);
      //       //   return;
      //       // }
      //
      //       if(canUnsnap) {
      //         // console.log("can unsnap");
      //         snapEngine.unsnap(icObj_slot, icObj_piece);     //presnap already sets up an unsnap listener
      //
      //       } else {
      //         // console.log("can't unsnap");
      //
      //         //SHU TODO: hasLeftSlot
      //         // const hasLeftSlot = Snap.hasLeftSlot()
      //         const hasLeftSlot = true;
      //
      //         if(hasLeftSlot) {
      //
      //
      //           // const rep_official = icObj_piece;
      //           const represented  = icObj_piece.represented;
      //           const rep_free     = represented.getRepresentation("free");
      //
      //           console.log("#rep_free.id_rep", rep_free.id_rep);
      //           console.log("#rep_free.isHeld", rep_free.isHeld);
      //
      //           if(rep_free.isHeld) {
      //             if(icObj_piece.snapState == SnapState.Snapped) {
      //               snapEngine.presnap(icObj_slot, icObj_piece);
      //             }
      //           } else {
      //             //do nothing
      //             // snap(icObj_slot, icObj_piece);
      //           }
      //
      //         } else {
      //           //do nothing
      //           // snap(icObj_slot, icObj_piece);
      //         }
      //
      //
      //
      //       }
      //
      //     };
      //     snapEngine.attemptUnsnapping = attemptUnsnapping;
      //
      //     const checkCanUnsnap = function(icObj_slot, icObj_piece) {
      //       console.log("checkCanUnsnap", icObj_piece);
      //       var outBool;
      //
      //       // outBool = Snap.canUnsnap(icObj_piece, icObj_slot);
      //       outBool = snapEngine.canUnsnapFunc(icObj_piece, icObj_slot);
      //
      //       return outBool;
      //     };
      //     snapEngine.checkCanUnsnap = checkCanSnap;
      //
      //
      //     const unsnap = function(icObj_slot, icObj_piece) {
      //       console.log("unsnap", icObj_piece);
      //
      //       // const represented  = icObj_piece.represented;
      //       // const rep_official = represented.getRepresentation("official");
      //       // const rep_snapped  = represented.getRepresentation("snapped");
      //
      //       const rep_unknown  = icObj_piece; //SHU TODO: solve snapSlot's rep madness
      //       const represented  = icObj_piece.represented;
      //       const rep_official = represented.getRepresentation("official");
      //       const rep_free     = represented.getRepresentation("free");
      //       const rep_snapped  = represented.getRepresentation("snapped");
      //
      //
      //       console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
      //       if(rep_free_afterPresnap__attemptUnsnapping != null) {
      //         rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
      //       }
      //       rep_free_afterPresnap__attemptUnsnapping = null;
      //
      //       // if(rep_free_afterSnap__attemptUnsnapping != null) {
      //       //   rep_free.offInnerUpdate(rep_free_afterSnap__attemptUnsnapping);
      //       // }
      //       // rep_free_afterSnap__attemptUnsnapping = null;
      //
      //
      //       // rep_free.offRelease(rep_free_onRelease__triggerSnap);
      //       // rep_free_onRelease__triggerSnap = null;
      //
      //       if(rep_free.offRelease != null) { //****************************************  SHU: il y a un problème ici, quand j'aurai trois neurones de disponibles, j'investiguerai
      //         rep_free.offRelease(rep_free_onRelease__triggerSnap);
      //         rep_free_onRelease__triggerSnap = null;
      //       }                                 //****************************************
      //
      //
      //       rep_official.syncWith(rep_free);
      //       rep_official.follow(rep_free);
      //
      //
      //       if(rep_snapped != null) {
      //         console.log("remove rep_snapped", rep_snapped.id_rep);
      //         rep_snapped.im_dying_now = true;
      //         infiniteCanvas.removeRepresentation(represented, rep_snapped);
      //         represented.removeRepresentation(rep_snapped);
      //       } else {
      //         console.log("rep_snapped already destroyed somewhere else");
      //       }
      //
      //
      //       // rep_free.im_dying_now = true; //SHU: this is interesting
      //
      //       rep_free.opacity = 1.0;
      //         //debug
      //       rep_free.fill = "lime";
      //
      //       rep_official.snapState = SnapState.Unsnapped;
      //       // rep_official.snappedTo = null;
      //       rep_official.snappedTo = -1;
      //
      //     };
      //     snapEngine.unsnap = unsnap;
      //
      //
      //
      //
      //
      //
      //     const r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
      //       console.log("r_official_update_handler", icObj_piece);
      //
      //       console.log("icObj_piece.snapState", icObj_piece.snapState);
      //
      //       // if(outerUpdatesDict["snapState"] == SnapState.Snapped) {
      //       //   //official just changed snapState to .Snapped
      //       //   //ignore
      //       //   return;
      //       // }
      //
      //       if(icObj_piece.snapState == SnapState.Unsnapped) {
      //         snapEngine.attemptSnapping(icObj_slot, icObj_piece);
      //       } else if(icObj_piece.snapState == SnapState.Snapped) {
      //         snapEngine.attemptUnsnapping(icObj_slot, icObj_piece);               //SHU666666 : this is the key line to understand what is wrong
      //       } else if(icObj_piece.snapState == SnapState.Presnapped) {
      //
      //       }
      //
      //     };
      //     snapEngine.r_official_update_handler = r_official_update_handler;
      //
      //     const r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
      //       console.log("r_official_update_handler2", rep_official_incoming);
      //
      //       const represented  = infiniteCanvas.getRepresented(icSnapSlot.id);
      //       console.log("represented", represented);
      //       const rep_official = represented.r_official();
      //
      //       const snapSlot    = rep_official;
      //       const incomingObj = rep_official_incoming;
      //
      //       if(incomingObj != snapSlot) { //don't snap oneself
      //
      //         if(!incomingObj.isSnappable) {
      //           //ignore: incomingObj is diamagnetic
      //         } else {
      //           console.log("++++incomingObj.snappedTo", incomingObj.snappedTo);
      //           // if(incomingObj.snappedTo != null && incomingObj.snappedTo != snapSlot) {
      //           if(incomingObj.snappedTo != -1 && incomingObj.snappedTo != snapSlot.id) {
      //             //ignore: incomingObj is already snapped to another slot
      //           } else {
      //             snapEngine.r_official_update_handler(snapSlot, incomingObj, outerUpdatesDict);
      //           }
      //         }
      //
      //       } else {
      //         console.log("I won't snap myself");
      //       }
      //
      //     };
      //     snapEngine.r_official_update_handler2 = r_official_update_handler2;
      //
      //     outEngine = snapEngine;
      //
      //     return outEngine;
      //   }
      //
      // }



      const TouchState = {
        "Untouched": "Untouched",
        "Touched": "Touched",
      };

      class Touch { //GeometryWise touching

        static canTouch(icObj_over, icObj_below) {

          const rect__over = icObj_over.getRect();
          const rect__below = icObj_below.getRect();

          logger.log("rect__over", rect__over);
          logger.log("rect__below", rect__below);

          const isIntersecting = Geometry.intersectRect(rect__over, rect__below);
          logger.log("isIntersecting", isIntersecting);

          return isIntersecting;
        }

        static canUntouch(icObj_over, icObj_below) {
          return !this.canTouch(icObj_over, icObj_below);
        }

      }


      class Touch2 { //GeometryWise Screen-wise touching

        constructor(fabricIntegration) {
          this.fabricIntegration = fabricIntegration;
        }

        canTouch(icObj_over, icObj_below) {

          //flemme: use fabric fObj.intersectsWithObject(fObj2)

          //const over__represented  = infiniteCanvas.getRepresented(icObj_over.id);
          //const over__rep_free     = over__represented.r_free();
          // const over__fObj         = over__rep_free.fObj;                            //<-- this is not available

          const over__fObj = fabricIntegration.getFObjForIcObj(icObj_over);

          // const below__represented  = infiniteCanvas.getRepresented(icObj_below.id);
          // const below__rep_free     = below__represented.r_free();
          // const below__fObj         = below__rep_free.fObj;                          //<-- this is not available
          const below__fObj = fabricIntegration.getFObjForIcObj(icObj_below);

          const isIntersecting = over__fObj.intersectsWithObject(below__fObj);

          logger.log("isIntersecting", isIntersecting);

          return isIntersecting;
        }

        canUntouch(icObj_over, icObj_below) {
          return !this.canTouch(icObj_over, icObj_below);
        }

      }

      const Touch2Singleton = (function () {
        var instance;

        function createInstance(fabricIntegration) {
          var object = new Touch2(fabricIntegration);
          return object;
        }

        return {
          initializeInstance: function (fabricIntegration) {
            const sharedInstance = createInstance(fabricIntegration);
            instance = sharedInstance;
          },
          sharedInstance: function () {
            if (!instance) {
              // instance = createInstance();
              throw new Error("Touch2Singleton has not been initialized");
            }
            return instance;
          }
        };
      })();










      class Curse {

        constructor(curseTrigger) {
          // logger.log("Curse::constructor", curseTrigger);

          this.curseFunc = null;

          this.curseTrigger = curseTrigger;
          this.curseTrigger.curse = this;
        }

        enact() {
          if (this.curseFunc != null) {
            this.curseFunc();
          }
        }

        start() {
          this.curseTrigger.start();
        }

        stop() {
          this.curseTrigger.stop();
        }

        reset() {

        }

      }


      class CurseTrigger_countdown {

        constructor() {
          this.curse = null;


          const curseTrigger = this;

          const countDownConfig = CountDownConfig.defaultConfig();
          countDownConfig.stepFunc = (countDownObj) => {
            // logger.log("stepFunc", countDownObj);

            if (countDownObj.index == 10) {
              curseTrigger.expulse();
            }
          };

          // const engine    = new CountDownEngine_auto(countDownConfig);
          const engine = new CountDownEngine(countDownConfig);

          this.engine = engine;
        }

        impulse() {
          if (this.engine.impulse != null) {
            this.engine.impulse();
          }
        }

        expulse() {
          this.curse.enact();
        }

        start() {
          this.engine.start();
        }

        stop() {
          this.engine.stop();
        }

      }





      class CountDownConfig {

        constructor(value_start, value_end, stepFunc, stepDuration) {
          this.value_start = value_start;
          this.value_end = value_end;

          this.stepFunc = stepFunc;
          this.stepDuration = stepDuration;
        }

        static defaultConfig() {
          var outConfig;

          const value_start = 10;
          const value_end = 0;

          const stepFunc = (stepIndex) => {
            console.log("stepFunc", stepIndex);
          };

          const stepDuration = 1000;

          outConfig = new CountDownConfig(value_start, value_end, stepFunc, stepDuration);

          return outConfig;
        }

      }




      class CountDownSequencer {

        constructor(value_from, value_to = 0) {

          // const animatedObj = {
          //   value: value_from,
          //
          //   index:    0,
          //   progress: 0,
          // };
          // this.animatedObj = animatedObj;

          const nb_values = (value_from - value_to) + 1;
          const arr_keyframes = [...new Array(nb_values).keys()].reverse().map((value, index) => {
            // logger.log("keyframe: value, index", value, index);

            const progress = (value_from - value) / (value_from - value_to);
            // logger.log("keyframe: progress", progress);


            const keyframe = {
              value: value,

              index: index,
              progress: progress,

              duration: 1,
            };

            return keyframe;
          });
          this.arr_keyframes = arr_keyframes;

          const animatedObj = Object.assign({}, arr_keyframes[0]);
          this.animatedObj = animatedObj;

          const arr_butfirst_keyframes = arr_keyframes.slice(1);
          this.arr_butfirst_keyframes = arr_butfirst_keyframes;

          const stepDuration = 1;
          this.stepDuration = stepDuration;

          const duration = (nb_values - 1) * stepDuration;
          // const duration     = nb_values * stepDuration;

          this.duration = duration;

          const countDownSequencer = this;
          const animation = anime({
            // targets: countDownEngine,
            targets: animatedObj,

            /*animated props*/
            // progress: 1,
            /*--------------*/
            // keyframes: arr_keyframes,
            keyframes: arr_butfirst_keyframes,

            direction: 'normal',
            easing: 'linear',
            duration: duration,

            autoplay: false,

            // update: (anim) => {                        //SHU: this would have been nice, but it triggers bizarrely
            //   countDownSequencer.update(animatedObj);
            // },
          });

          this.animation = animation;

          // this.debugAnimation();
        }

        debugAnimation() {
          const duration = this.duration;

          this.arr_keyframes.forEach((keyframe, i) => {

            const progress__keyframe = keyframe.progress;
            const timestamp__keyframe = progress__keyframe * duration;
            // logger.log("timestamp__keyframe", timestamp__keyframe);

            this.animation.seek(timestamp__keyframe);

            // logger.log("this.animatedObj", this.animatedObj);
          });

          this.animation.seek(0);
        }

        // moveToFirstFrame() {
        //   this.animation.seek(0);
        //   this.update(this.animatedObj);
        // }

        moveToNextFrame() {
          // logger.log("moveToNextFrame");

          const index__current = this.animatedObj.index;
          // logger.log("index__current", index__current);
          const index__next = index__current + 1;
          // logger.log("index__next", index__next);

          if (index__next < this.arr_keyframes.length) {

            const keyframe__next = this.arr_keyframes[index__next];
            // logger.log("keyframe__next", keyframe__next);


            const progress__next = keyframe__next.progress;
            const timestamp__next = progress__next * this.duration;
            // logger.log("timestamp__next", timestamp__next);

            this.animation.seek(timestamp__next);
            // logger.log("this.animation.progress", this.animation.progress);
            this.update();

          } else {
            // logger.log("can't move further");
          }

        }


        update() {
          if (this.countDownEngine != null) {
            const animatedObj = this.animatedObj;
            this.countDownEngine.update(animatedObj);
          }
        }

        // pulse() {
        //   this.moveToNextFrame();
        // }

      }


      class CountDownObj {
        constructor(value_from) {
          this.value = value_from;
          this.progress = 0;
        }
      }

      class CountDownEngine {     //SHU:    /!\ this is not an icEngined engine


        constructor(countDownConfig_in = null) {

          var countDownConfig = countDownConfig_in;
          if (countDownConfig == null) {
            countDownConfig = CountDownConfig.defaultConfig();
          }

          this.counter_start = countDownConfig.value_start;
          this.counter_end = countDownConfig.value_end;

          this.stepFunc = countDownConfig.stepFunc;
          this.stepDuration = countDownConfig.stepDuration;

          const nb_steps = math.abs(this.counter_end - this.counter_start);
          this.nb_steps = nb_steps;

          this.arr_steps = [...new Array(nb_steps).keys()];
          this.step_current = 0;

          this.counter = this.counter_start;

          this.progress = 0;

          this.isPaused = true;

          const duration = this.nb_steps * this.stepDuration;

          const countDownSequencer = new CountDownSequencer(nb_steps);
          countDownSequencer.countDownEngine = this;
          this.countDownSequencer = countDownSequencer;



          const rx_countDownCounter = new ReplaySubject(1);
          const countDownObj = countDownSequencer.animatedObj;
          rx_countDownCounter.next(countDownObj.value);
          this.rx_countDownCounter = rx_countDownCounter;


          this.start = function () {
            const countDownEngine = this;

            // countDownEngine.stepFunc(0);
            // countDownEngine.stepFunc(countDownSequencer.animatedObj);
            countDownEngine.update(countDownSequencer.animatedObj);

            countDownEngine.play();
          };
          // }.bind(this);

          this.stop = function () {
            const countDownEngine = this;

            countDownEngine.reset();
          };
          // }.bind(this);

          this.play = function () {
            const countDownEngine = this;

            const date_play = new Date();
            countDownEngine.date_play = date_play;

            countDownEngine.isPaused = false;
            // countDownEngine.animation.play();
          };
          // }.bind(this);

          this.pause = function () {
            const countDownEngine = this;

            const date_pause = new Date();
            countDownEngine.date_pause = date_pause;

            // countDownEngine.animation.pause();
            countDownEngine.isPaused = true;
          };
          // }.bind(this);

          this.reset = function () {
            const countDownEngine = this;

            // countDownEngine.animation.reset();
          };
          // }.bind(this);

          this.update = function (countDownObj) {
            // logger.log("update", countDownObj);
            const countDownEngine = this;

            countDownEngine.stepFunc(countDownObj);
            countDownEngine.rx_countDownCounter.next(countDownObj.value);
          };
          // }.bind(this);


          this.impulse = function () {
            // this.countDownSequencer.pulse();
            this.countDownSequencer.moveToNextFrame();
          };


          this.getCounter = function () {
            return this.countDownSequencer.animatedObj.value;
          };

        }

      }


      // class CountDownEngine {     //SHU:    /!\ this is not an icEngined engine
      //   constructor(countDownConfig_in = null) {
      //
      //     var countDownConfig = countDownConfig_in;
      //     if(countDownConfig == null) {
      //       countDownConfig = CountDownConfig.defaultConfig();
      //     }
      //
      //     this.counter_start = countDownConfig.value_start;
      //     this.counter_end   = countDownConfig.value_end;
      //
      //     this.stepFunc      = countDownConfig.stepFunc;
      //     this.stepDuration  = countDownConfig.stepDuration;
      //
      //     const nb_steps     = math.abs(this.counter_end - this.counter_start);
      //     this.nb_steps      = nb_steps;
      //
      //     this.arr_steps     = [...new Array(nb_steps).keys()];
      //     this.step_current  = 0;
      //
      //     this.counter = this.counter_start;
      //
      //     this.progress = 0;
      //
      //     this.isPaused = true;
      //
      //     const duration = this.nb_steps * this.stepDuration;
      //
      //     this.animatedObj = {
      //       progress: 0
      //     };
      //
      //     const countDownEngine = this;
      //     const animatedObj = this.animatedObj;
      //     const animation = anime({
      //       // targets: countDownEngine,
      //       targets: animatedObj,
      //
      //       /*animated props*/
      //       progress: 1,
      //       /*--------------*/
      //
      //       direction: 'normal',
      //       easing: 'linear',
      //       duration: duration,
      //
      //       autoplay: false,
      //
      //       update: (anim) => {
      //         const progress = anim.progress / 100;
      //         countDownEngine.progress = progress;
      //         countDownEngine.update(progress);
      //       },
      //     });
      //
      //     this.animation = animation;
      //
      //
      //
      //     this.start = function() {
      //       const countDownEngine = this;
      //
      //       countDownEngine.stepFunc(0);
      //       countDownEngine.play();
      //     };
      //     // }.bind(this);
      //
      //     this.stop = function() {
      //       const countDownEngine = this;
      //
      //       countDownEngine.reset();
      //     };
      //     // }.bind(this);
      //
      //     this.play = function() {
      //       const countDownEngine = this;
      //
      //       const date_play           = new Date();
      //       countDownEngine.date_play = date_play;
      //
      //       countDownEngine.isPaused = false;
      //       countDownEngine.animation.play();
      //     };
      //     // }.bind(this);
      //
      //     this.pause = function() {
      //       const countDownEngine = this;
      //
      //       const date_pause           = new Date();
      //       countDownEngine.date_pause = date_pause;
      //
      //       countDownEngine.animation.pause();
      //       countDownEngine.isPaused = true;
      //     };
      //     // }.bind(this);
      //
      //     this.reset = function() {
      //       const countDownEngine = this;
      //
      //       countDownEngine.animation.reset();
      //     };
      //     // }.bind(this);
      //
      //     this.update = function(progress) {
      //       console.log("update", progress);
      //       const countDownEngine = this;
      //
      //       const cursor      = progress * countDownEngine.nb_steps;
      //       const step_cursor = math.floor(cursor);
      //
      //       const isStepChanged = (step_cursor - countDownEngine.step_current) >= 1;
      //       if(isStepChanged) {
      //         countDownEngine.step_current = step_cursor;
      //         countDownEngine.stepFunc(step_cursor);
      //       }
      //     };
      //     // }.bind(this);
      //
      //   }
      //
      // }




      class RxSubjectEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }





          this.next = function (value) {

            const engineCarrier = this.scopeObj.engineCarrier;
            engineCarrier.value = value;

            this.rxSubject.next(value);
          };

          this.getRxSubject = function () {
            return this.rxSubject;
          };



          this.start = function () {
            console.log("RxSubjectEngine::start, this", this);
            console.log("RxSubjectEngine::start", "this.scopeObj", this.scopeObj);

            const engineCarrier = this.scopeObj.engineCarrier;
            const value = engineCarrier.value;

            const replaySubject = new Rx.ReplaySubject(1);
            replaySubject.next(value);

            this.rxSubject = replaySubject;
          };

          this.stop = function () {

            this.rxSubject.complete();
          };



          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }

      class RxSubscriptionEngine {




      }


      class FacetEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }


          this.react = function (nextObj) {

            const engineCarrier = this.scopeObj.engineCarrier;

            const reactFunc = engineCarrier.reactFunc;

            const result = reactFunc(engineCarrier, nextObj);

            return result;
          };


          this.start = function () {
            console.log("FacetEngine::start, this", this);
            console.log("FacetEngine::start", "this.scopeObj", this.scopeObj);

            const engineCarrier = this.scopeObj.engineCarrier;
            // const core          = engineCarrier.core;

            const rxObservable = engineCarrier.rxObservable;

            this.rxsub = rxObservable.subscribe({
              next: (obj) => {
                this.react(obj);
              },
            });

          };

          this.stop = function () {
            this.rxsub.unsubscribe();
          };



          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }











      class Observe {

      }

      class ObserverEngine {

        constructor() {

        }

        start() {

        }

        stop() {

        }

        observe(icObj_incoming) { //this function is to be hooked

        }

        static defaultInstance(infiniteCanvas, icObserver) {
          var outEngine;

          const observerEngine = new ObserverEngine();
          Hooker.installHooks(observerEngine, "observe");


          const r_official_update_handler = (observer, icObj_incoming, outerUpdatesDict) => {
            console.log("observerEngine::r_official_update_handler", icObj_incoming);

            observerEngine.observe(icObj_incoming);
          };
          observerEngine.r_official_update_handler = r_official_update_handler;

          const r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
            console.log("observerEngine::r_official_update_handler2", rep_official_incoming);

            const represented = infiniteCanvas.getRepresented(icObserver.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const observer = rep_official;
            const incomingObj = rep_official_incoming;
            // console.log("incomingObj.id", incomingObj.id);

            if (incomingObj != observer) { //don't observe oneself

              console.log("observer.observerConfig.observed", observer.observerConfig.observed);
              const isObserved = observer.observerConfig.observed[incomingObj.id];

              if (!isObserved) {
                //ignore: incomingObj is not observed
              } else {
                observerEngine.r_official_update_handler(observer, incomingObj, outerUpdatesDict);
              }

            } else {
              console.log("I won't observe myself");
            }

          };
          observerEngine.r_official_update_handler2 = r_official_update_handler2;

          outEngine = observerEngine;

          return outEngine;
        }

      }




      class FuturingEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }





          this.add = function (transformation) {

          };

          this.abort_current = function () {

          };

          this.abort_all = function () {

          };



          this.start = function () {
            console.log("RxSubjectEngine::start, this", this);
            console.log("RxSubjectEngine::start", "this.scopeObj", this.scopeObj);

            const engineCarrier = this.scopeObj.engineCarrier;

            this.speed = 1.0;

          };

          this.stop = function () {


          };



          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }









      //I/O

      class FileIntegration {

        constructor(clipboardIntegration) {
          this.clipboardIntegration = clipboardIntegration;

          document.onpaste = function (event) {
            logger.log("onpaste", "event", event);

            clipboardIntegration.rx_outerPaste.next(event);
          };

        }

        static openFileDialog(accept, callback) {

          // Create an input element
          var inputElement = document.createElement("input");

          // Set its type to file
          inputElement.type = "file";

          // Set accept to the file types you want the user to select.
          // Include both the file extension and the mime type
          inputElement.accept = accept;

          // set onchange event to call callback when user has selected file
          inputElement.addEventListener("change", callback)

          // dispatch a click event to open the file dialog
          inputElement.dispatchEvent(new MouseEvent("click"));

        }

        static openFile_p(accept) {

          return new Promise((resolve, reject) => {

            FileIntegration.openFileDialog(accept, event => {
              const fileList = event.target.files;
              ////console.log("fileList:", fileList);

              const file = fileList[0];
              //console.log("file", file);

              resolve(file);
            });
          });

        }


        static openFolderDialog(accept, callback) {

          // Create an input element
          var inputElement = document.createElement("input");

          // Set its type to folder
          inputElement.type = "file";

          inputElement.setAttribute("webkitdirectory", "");
          inputElement.setAttribute("mozdirectory", "");
          inputElement.setAttribute("directory", "");

          // Set accept to the file types you want the user to select.
          // Include both the file extension and the mime type
          inputElement.accept = accept;

          // set onchange event to call callback when user has selected file
          inputElement.addEventListener("change", callback)

          // dispatch a click event to open the file dialog
          inputElement.dispatchEvent(new MouseEvent("click"));

        }

        static openFolder_p(accept) {

          return new Promise((resolve, reject) => {

            FileIntegration.openFolderDialog(accept, event => {
              // logger.log("log1", "openFolder_p", "event", event);
              const fileList = event.target.files;
              // logger.log("log1", "fileList", fileList);

              const arr_file = Array.from(fileList);
              resolve(arr_file);
            });
          });

        }

        static openMultipleDialog(accept, callback) {

          // Create an input element
          var inputElement = document.createElement("input");

          // Set its type to folder
          inputElement.type = "file";

          inputElement.setAttribute("multiple", "");

          // Set accept to the file types you want the user to select.
          // Include both the file extension and the mime type
          inputElement.accept = accept;

          // set onchange event to call callback when user has selected file
          inputElement.addEventListener("change", callback)

          // dispatch a click event to open the file dialog
          inputElement.dispatchEvent(new MouseEvent("click"));

        }

        static openMultiple_p(accept) {

          return new Promise((resolve, reject) => {

            FileIntegration.openMultipleDialog(accept, event => {
              // logger.log("log1", "openMultiple_p", "event", event);
              const fileList = event.target.files;
              // logger.log("log1", "fileList", fileList);

              const arr_file = Array.from(fileList);
              resolve(arr_file);
            });
          });

        }

        static fileForImg(img) {
          let dataUrl = img.src.split(',');
          let base64 = dataUrl[1];
          let mime = dataUrl[0].match(/:(.*?);/)[1];
          let bin = atob(base64);
          let length = bin.length;
          // From http://stackoverflow.com/questions/14967647/ (continues on next line)
          // encode-decode-image-with-base64-breaks-image (2013-04-21)
          let buf = new ArrayBuffer(length);
          let arr = new Uint8Array(buf);
          bin
            .split('')
            .forEach((e, i) => arr[i] = e.charCodeAt(0));

          let file = new File([buf], 'filename', { type: mime }); // note: [buf]
          return file;
        }


        // static addImageFromFile_p(file) {
        //
        //   function addZimageForImg(img) {
        //     //console.log("img", img);
        //
        //     // const zimage = createZimageWithCurrentBoundingRect(img);
        //
        //     const canvasBoundingTrueRect = getCanvasBoundingTrueRect();
        //
        //     // object-fit : contain
        //     const img_size = {
        //       width: img.width,
        //       height: img.height
        //     };
        //     const trueRect = containedRect(canvasBoundingTrueRect, img_size);
        //
        //     const zimage = createZimage(img, trueRect);
        //
        //     addZimage(zimage);
        //
        //     redrawCanvas();
        //   }
        //
        //   function addFabricImageForImg(img) {
        //     //console.log("img", img);
        //
        //     // const zimage = createZimageWithCurrentBoundingRect(img);
        //
        //     const canvasBoundingTrueRect = getCanvasBoundingTrueRect();
        //
        //     // object-fit : contain
        //     const img_size = {
        //       width: img.width,
        //       height: img.height
        //     };
        //     const trueRect = containedRect(canvasBoundingTrueRect, img_size);
        //
        //     const fabricImage = createFabricImage(img, trueRect);
        //     addFabricObject(fabricImage);
        //
        //     redrawCanvas();
        //   }
        //
        //   return createImage_p(file)
        //         .then(img => {
        //           // addZimageForImg(img);
        //           addFabricImageForImg(img);
        //         });
        //
        // }



        //IMPORT image

        static accept_image() {
          const accept = ".jpg, .jpeg, .png";
          return accept;
        }

        static importImage_p() {
          const accept = FileIntegration.accept_image();
          return FileIntegration.openFile_p(accept)
            .then(FileIntegration.createImage_p);
        }

        static importImage_folder_p() {
          const accept = FileIntegration.accept_image();
          return FileIntegration.openFolder_p(accept)
            .then(arr_file => {
              return Promise.all(arr_file.map(FileIntegration.createImage_p));
            });
        }

        static importImage_multiple_p() {
          const accept = FileIntegration.accept_image();
          return FileIntegration.openMultiple_p(accept)
            .then(arr_file => {
              return Promise.all(arr_file.map(FileIntegration.createImage_p));
            });
        }

        static createImage_p(file) {
          return FileIntegration.getFileData_p(file)
            .then(FileIntegration.dataToImgSrc_p)
            .then(FileIntegration.imageFromImgSrc_p);
        }

        static imageFromImgSrc_p(imgSrc) {
          logger.log('imgSrc', imgSrc);

          // return new Promise(r => img.onload=r, img.src=imgSrc)
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = (error) => reject(error);

            // img.crossOrigin = 'Anonymous';

            img.src = imgSrc;
          });
        }

        static dataToImgSrc_p(data) {
          var imgSrc_p;

          if (data.startsWith("data:image")) {
            imgSrc_p = Promise.resolve(data);
          } else {
            imgSrc_p = FileIntegration.dataToBlob_p(data)
              .then(blob1 => {
                //change blob type
                const blob2 = new Blob([blob1], { type: 'image/png' })
                return blob2;
              })
              .then(FileIntegration.getFileData_p);
            // .then(blob2 => {
            //   const imgSrc = URL.createObjectURL(blob2);
            //   ////console.log("converted imgSrc:", imgSrc);
            //   //>>converted imgSrc: blob:http://localhost:8080/7243f1de-493f-412b-b1ec-b042b0cbcac4
            //   return imgSrc;
            // });
          }

          return imgSrc_p;
        }

        static dataToBlob_p(data) {
          return fetch(data)
            .then(res => res.blob());
        }

        static imageContentsToBlob_p(img) {
          return this.dataToBlob_p(img.src);
        }


        //IMPORT video

        static accept_video() {
          const accept = ".mp4, .mkv, .avi";
          return accept;
        }

        static importVideo_p() {
          const accept = FileIntegration.accept_video();
          return FileIntegration.openFile_p(accept)
            .then(FileIntegration.createVideo_p);
        }

        static createVideo_p(file) {
          return FileIntegration.getFileData_p(file)
            .then(FileIntegration.dataToVidSrc_p)
            .then(FileIntegration.videoFromVidSrc_p);
        }

        static videoFromVidSrc_p(vidSrc) {
          logger.log('vidSrc', vidSrc);

          return new Promise((resolve, reject) => {
            const video = document.createElement("video");
            // video.onload  =      () => resolve(video);
            // video.onerror = (error) => reject(error);

            // img.crossOrigin = 'Anonymous';

            video.src = vidSrc;

            /// setup with auto preload and loop
            video.preload = 'auto';
            video.loop = true;

            // video.addEventListener('canplay', start, false);

            resolve(video);
          });

        }

        static videoFromWebcam_p() {

          function webcamStream_p() {
            return navigator.mediaDevices
              .getUserMedia({
                video: {
                  facingMode: "user"
                },
                audio: false
              })
              .catch((error) => {
                logger.log("webcamStream_p, error", error);
              })
          }

          const video_p = webcamStream_p()
            .then(function (stream) {
              // track = stream.getTracks()[0];
              // logger.log("log1", "stream", stream);

              const webcamEl = document.createElement('video');

              webcamEl.style.width = "100px";
              webcamEl.style.height = "100px";
              webcamEl.style.display = "none";
              // logger.log("log1", "webcamEl", webcamEl);

              webcamEl.srcObject = stream;

              return webcamEl;
            });

          return video_p;

        }

        videoFromStreamURL_p(streamURL) {
          return null;
        }

        static dataToVidSrc_p(data) {
          var vidSrc_p;

          if (data.startsWith("data:video")) {
            vidSrc_p = Promise.resolve(data);
          } else {
            vidSrc_p = FileIntegration.dataToBlob_p(data)
              .then(blob1 => {
                //change blob type
                const blob2 = new Blob([blob1], { type: 'video/mp4' })
                return blob2;
              })
              .then(FileIntegration.getFileData_p);
          }

          return vidSrc_p;
        }


        //file utils

        static getFileData_p(file) {
          ////console.log("getFileData_p", file);

          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function (evt) {
              const file_url = evt.target.result; //<=> var file_url = reader.result;
              ////console.log("file_url:", file_url);
              resolve(file_url);
            };
            reader.readAsDataURL(file);
          });

        }

        static getFileText_p(file) {
          ////console.log("getFileText_p", file);

          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function (evt) {
              const file_url = evt.target.result; //<=> var file_url = reader.result;
              ////console.log("file_url:", file_url);
              resolve(file_url);
            };
            reader.readAsText(file);
          });

        }

        // static getFile_p(filepath) {
        //   ////console.log("getFileText_p", file);
        //
        //   return FileIntegration.getFileData_p(filepath)
        //   .then((dataURL) => {
        //
        //   });
        //
        // }


        // static getFileImage_p(filename) {
        //   const file_url = "/img/" + filename;
        //   return fetch(file_url)
        //         .then(FileIntegration.createImage_p);
        // }


        //folder utils

        // static importFolder_p() {
        //   return FileIntegration.openFolder_p(accept);
        // }







        //PASTE image


        static getPastedFile_p(event) {
          var outPromise;

          var items = (event.clipboardData || event.originalEvent.clipboardData).items;
          //console.log(JSON.stringify(items)); // will give you the mime types

          const arr_files = Object.values(items)
            .filter(item => item.kind == 'file')
            .map(item => item.getAsFile());

          if (arr_files.length == 1) {
            const file = arr_files.find(e => true);
            outPromise = Promise.resolve(file);
          } else {
            const error = new Error("arr_files.length != 1");
            outPromise = Promise.reject(error);
          }

          return outPromise;
        }





        //SAVE / LOAD

        static save_to_file(obj) {
          logger.log("save_to_file", obj);

          const json = JSON.stringify(obj);

          const filename = "infinishute.json";
          FileIntegration.download(json, filename, 'text/json');
        }

        static download(content, fileName, contentType) {
          var a = document.createElement("a");
          var file = new Blob([content], { type: contentType });
          a.href = URL.createObjectURL(file);
          a.download = fileName;
          a.click();
        }


        static save_image(dataURL, imageName = "image") {
          const filename = "image.png";

          var a = document.createElement("a");
          a.href = dataURL;
          a.download = imageName;
          a.click();
        }


        // static objByConvertingImagesToBase64_p(obj) {
        //
        //   const zimages_raw = obj.zimages;
        //
        //   const arr__zimages_serial_p = zimages_raw.map(zimage => {
        //
        //     //console.log("zimage", zimage);
        //     const imgSrc_base64_p = FileIntegration.dataUrlForImgViaCanvas_p(zimage.img);
        //
        //     return imgSrc_base64_p
        //            .then(imgSrc_base64 => {
        //
        //              const zimage_serial = {
        //                imgSrc_base64:  imgSrc_base64,
        //                trueRect:       zimage.trueRect,
        //              };
        //
        //              return zimage_serial;
        //            });
        //
        //   });
        //
        //   return Promise.all(arr__zimages_serial_p)
        //          .then(arr__zimages_serial => {
        //
        //            const obj2 = {};
        //
        //            obj2.zimages  = arr__zimages_serial;
        //            obj2.drawings = obj.drawings;
        //
        //            return obj2;
        //          });
        // }

        static objByConvertingImagesToBase64_p(obj) {

          const zimages_raw = obj.zimages;

          const arr__zimages_serial_p = zimages_raw.map(zimage => {

            //console.log("zimage", zimage);
            const imgSrc_base64_p = FileIntegration.dataUrlForImgViaCanvas_p(zimage.img);

            return imgSrc_base64_p
              .then(imgSrc_base64 => {

                const zimage_serial = {
                  imgSrc_base64: imgSrc_base64,
                  trueRect: zimage.trueRect,
                };

                return zimage_serial;
              });

          });

          return Promise.all(arr__zimages_serial_p)
            .then(arr__zimages_serial => {

              const obj2 = {};

              obj2.zimages = arr__zimages_serial;
              obj2.drawings = obj.drawings;

              return obj2;
            });
        }



        static saveInfinishute_p(infiniShute) {

          // const obj = {
          //   // zimages  : zimages,
          //   // drawings : drawings,
          //
          //   infiniteCanvas: infiniteCanvas,
          // };
          // //console.log("obj", obj);
          //
          // FileIntegration.objByConvertingImagesToBase64_p(obj)
          // .then(obj2 => {
          //   //console.log("obj2", obj2);
          //   FileIntegration.save_to_file(obj2);
          // });

          FileIntegration.save_to_file(infiniShute);

          //?
          return Promise.resolve(true);
        }

        static loadInfinishute_p() {
          const accept = ".json";
          return FileIntegration.openFile_p(accept)
            .then(FileIntegration.createJson_p)
          // .then(FileIntegration.createInfinishute_p);
          // .then(infinishute => {
          //   configureWithInfinishute(infinishute);
          // });
        }

        static createJson_p(file) {
          return FileIntegration.getFileText_p(file)
            .then(text => {
              //console.log("text:", text);

              const json = JSON.parse(text);
              //console.log("json:", json);
              return json;
            });

        }

        // static createInfinishute_p(json) {
        //   const infinishute = {};
        //
        //   infinishute.drawings = json.drawings;
        //
        //   const zimages_serial = json.zimages;
        //   const arr__zimage_p = zimages_serial.map(zimage_serial => {
        //
        //     const imgSrc = zimage_serial.imgSrc_base64;
        //     return FileIntegration.imageFromImgSrc_p(imgSrc)
        //            .then(image => {
        //              const zimage = {
        //                img: image,
        //                trueRect: zimage_serial.trueRect,
        //              };
        //
        //              return zimage;
        //            });
        //   })
        //
        //   return Promise.all(arr__zimage_p)
        //                 .then(zimages => {
        //                   infinishute.zimages = zimages;
        //
        //                   return infinishute;
        //                 });
        //
        // }

        // static createInfinishute_p(json) {
        //   const infinishute = {};
        //
        //   return json;
        // }


        static dataUrlForImgViaCanvas_p(img) {

          const src = img.src;

          const outputFormat = "image/png";

          return new Promise((resolve, reject) => {
            var imgAux = new Image();

            imgAux.crossOrigin = 'Anonymous';
            imgAux.onload = function () {
              var canvasAux = document.createElement('CANVAS');
              var ctxAux = canvasAux.getContext('2d');
              var dataURL;
              canvasAux.height = this.naturalHeight;
              canvasAux.width = this.naturalWidth;
              ctxAux.drawImage(this, 0, 0);
              dataURL = canvasAux.toDataURL(outputFormat);
              resolve(dataURL);
            };
            imgAux.onerror = (error) => reject(error);

            imgAux.src = src;
          })
            .catch((e) => {
              logger.log("dataUrlForImgViaCanvas_p", e);
            });

        }

        static dataURLForRect(fObjOrfCanvas, rect__print) {
          var outDataURL;

          const printOptions = Object.assign({}, rect__print);
          outDataURL = fObjOrfCanvas.toDataURL(printOptions);

          return outDataURL;
        }

        static dataUrlForImgViaCanvas2_p(img) {   //SHU: tried to create workaround for local files but "Tainted canvases may not be exported"
          var out_p;

          function createFObj_p(img) {
            const fObj = new fabric.Image(img);
            return Promise.resolve(fObj);
          }

          out_p = createFObj_p(img)
            .then((fObj) => {
              //prepare canvas
              fabricCanvas__tool.add(fObj);
              fabricCanvas__tool.renderAll();

              return fabricCanvas__tool;
            }).then((fCanvas) => {

              const width = img.width;
              const height = img.height;

              const rect__print = {
                left: 0,
                top: 0,
                width: width,
                height: height,
              };

              const dataURL = FileIntegration.dataURLForRect(fCanvas, rect__print);

              return dataURL;
            });

          return out_p;
        }



      }




      //Clipboard mgmt

      class ClipboardObject {
        constructor(source, content) {
          this.source = source;
          this.content = content;
        }
      }

      class InnerCopyEvent {
        constructor(clipboardObject) {
          this.timestamp = Date.now();
          this.clipboardObject = clipboardObject;
        }
      }

      class ClipboardIntegration {

        constructor(arr_sources) {
          // this.arr_sources = arr_sources;
          const rx_innerCopy = new Subject();
          this.rx_innerCopy = rx_innerCopy;

          // this.arr_paste_p = arr_sources.map(source => source.paste_p);
          const rx_outerPaste = new Subject();
          this.rx_outerPaste = rx_outerPaste;

          const timestamp__start = Date.now();

          const clipboardIntegration = this;
          // const rx_mixedPaste = Rx.combineLatest(rx_outerPaste, rx_innerCopy)
          const rx_mixedPaste = rx_outerPaste.pipe(Rx_operators.withLatestFrom(rx_innerCopy))
            // .pipe(Rx_operators.map(([clipboardEvent, innerCopyEvent]) => {
            // var outVal;
            .pipe(Rx_operators.mergeMap(([outerPasteEvent, innerCopyEvent]) => {

              var out_p;
              var outObservable;

              console.log("rx_mixedPaste");
              console.log("outerPasteEvent", outerPasteEvent);
              console.log("innerCopyEvent", innerCopyEvent);

              const timestamp_outerPaste = outerPasteEvent.timeStamp;
              const timestamp_innerCopy = innerCopyEvent.timestamp - timestamp__start;

              logger.log("timestamp_outerPaste", timestamp_outerPaste);
              logger.log("timestamp_innerCopy", timestamp_innerCopy);

              // const isInnerMostRecent = timestamp_inner > timestamp_outer;

              //SHU: ok, so i am not able to get "outerCopyEvent.timestamp"
              //so i'll do a workaround
              const isInnerMostRecent = timestamp_outerPaste - timestamp_innerCopy < 5000;       //SHU: you have 5 seconds to inner paste after inner copying
              logger.log("isInnerMostRecent", isInnerMostRecent);

              if (isInnerMostRecent) {
                const icObj = innerCopyEvent.clipboardObject.content;
                icObj.id += 1000;

                //clone newly created, shift it, and copy it {
                const cloned = icObj.deepClone();
                cloned.id += 1000;

                cloned.position.x += 10;
                cloned.position.y += 10;

                clipboardIntegration.manageInnerCopy("fabric.general", cloned);
                //}

                // outVal = icObj;
                out_p = Promise.resolve(icObj);

              } else {
                out_p = clipboardIntegration.outerToInner_p(outerPasteEvent);

                //inner to ic
                // const infiniteCanvas = this.infiniteCanvas;

                out_p = out_p.then(content => {
                  var outIcObj;

                  logger.log("content", content);

                  const true_cursor = infiniteCanvas.getTrueCursor();
                  const trueRect = {
                    x: true_cursor.x,
                    y: true_cursor.y,
                    width: 100,
                    height: 100,
                  };

                  if (typeof content == "string") {
                    const text = content;
                    outIcObj = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
                  } else if (content instanceof Image) {
                    const img = content;
                    outIcObj = infiniteCanvas.createIcImage(trueRect.x, trueRect.y, img);
                  } else {
                    outIcObj = infiniteCanvas.createIcRect(trueRect);
                  }

                  return outIcObj;
                });
              }

              // return outVal;
              // return out_p;
              outObservable = Rx.from(out_p);
              return outObservable;
            }));

          this.rx_mixedPaste = rx_mixedPaste;
        }

        manageInnerCopy(source, content) {

          const cbObj = new ClipboardObject(source, content);

          const innerCopyEvent = new InnerCopyEvent(cbObj);
          this.rx_innerCopy.next(innerCopyEvent);




          //copy to navigator clipboard
          const icObj = content;

          const outerWrapper = outerWrapperForIcObj(icObj);
          if (outerWrapper != null) {

            writeToClipboard_p(outerWrapper)
              .then(success => {
                console.log("writeToClipboard_p, success");
              })
              .catch(err => {
                console.log("writeToClipboard_p, error:" + err);
              });


          }

          function outerWrapperForIcObj(icObj) {
            var out;

            switch (icObj.type) {
              case "image":
                const outerWrapper_image = {
                  type: "image",
                  content: icObj.img,
                };
                out = outerWrapper_image;
                break;
              case "text":
                const outerWrapper_text = {
                  type: "text",
                  content: icObj.text,
                };
                out = outerWrapper_text;
                break;
              default:
                out = null;
                break;
            }

            return out;
          }

          function writeToClipboard_p(outerWrapper) {
            var out_p;

            switch (outerWrapper.type) {
              case "text":
                const text = outerWrapper.content;
                out_p = writeToClipboard_text_p(text);
                break;
              case "image":
                const img = outerWrapper.content;
                //const imgSrc_p = FileIntegration.dataUrlForImgViaCanvas_p(img);
                // out_p = img_serial_p
                //         .then(imgSrc => {
                //           return writeToClipboard_image_p(imgSrc);
                //         });
                out_p = writeToClipboard_image_p(img);
                break;
              // case "mixed":
              //   writeToClipboard_mixed(outerWrapper.content);
              //   break;
              default:
                throw new Error("outerWrapper, unsupported type: " + outerWrapper.type);
            }

            return out_p;
          }

          function writeToClipboard_text_p(text) {
            return navigator.clipboard.writeText(text)
              .then(success => {
                console.log("navigator.clipboard.writeText, success");
              })
              .catch(err => {
                console.log("navigator.clipboard.writeText, error:" + err);
              });
          }

          function writeToClipboard_image_p(img) {
            console.log("writeToClipboard_image", img);

            // const image = await fetch('ceiling-cat.jpg');
            // const blob_image = new Blob([imgSrc], { type: 'image/png' });
            const blob_image_p = FileIntegration.imageContentsToBlob_p(img);

            // const blob_text = new Blob(['Cute sleeping kitten'], {type: 'text/plain'});

            const item_p = blob_image_p.then(blob_image => {
              const item = new ClipboardItem({
                // 'text/plain': blob_text,

                'image/png': blob_image,
              });

              return item;
            });

            return item_p
              .then(item => {
                navigator.clipboard.write([item])
              })
              .then(success => {
                console.log("navigator.clipboard.write, success");
              })
              .catch(err => {
                console.log("navigator.clipboard.write, error:" + err);
              });
          }

        }

        // manageOuterPaste(clipboardEvent) {
        //   this.rx_outerPaste.next(clipboardEvent);
        // }

        outerToInner_p(clipboardEvent) {
          var out_p;
          logger.log("outerToInner_p, clipboardEvent");

          // get text representation of clipboard
          var text = (clipboardEvent.originalEvent || clipboardEvent).clipboardData.getData('text/plain');
          if (text) {
            logger.log("text", text);
            // fileIntegration.onPasteTextListeners.forEach((listener, i) => {
            //   listener(text);
            // });
            out_p = Promise.resolve(text);
          } else {
            logger.log("not a text");

            out_p =
              FileIntegration.getPastedFile_p(clipboardEvent)
                .then(FileIntegration.createImage_p);
            // .then(img => {
            //   fileIntegration.onPasteImageListeners.forEach((listener, i) => {
            //     listener(img);
            //   });
            // });

          }

          return out_p;
        }

        innerToOuter(icObj) {
          return null;
        }

        lol() {
          // pasteFabricObjects(event) {
          //   console.log("pasteFabricObjects", event);
          //
          //   const clipboardData = event.clipboardData;
          //   // _clipboard.clone(function(clonedObj) {
          //   navigator.clipboard.read()
          //   .then((items) => {
          //     console.log("items", items);
          //   })
          //   .catch((err) => {
          //     console.log("err", err);
          //   });
          //
          //
          //   clipboardData.clone(function(clonedObj) {
          //     fabricCanvas.discardActiveObject();
          //     clonedObj.set({
          //       left: clonedObj.left + 10,
          //       top: clonedObj.top + 10,
          //       evented: true,
          //     });
          //     if (clonedObj.type === 'activeSelection') {
          //       // active selection needs a reference to the canvas.
          //       clonedObj.canvas = fabricCanvas;
          //       clonedObj.forEachObject(function(obj) {
          //         fabricCanvas.add(obj);
          //       });
          //       // this should solve the unselectability
          //       clonedObj.setCoords();
          //     } else {
          //       fabricCanvas.add(clonedObj);
          //     }
          //
          //     _clipboard.top += 10;
          //     _clipboard.left += 10;
          //
          //     fabricCanvas.setActiveObject(clonedObj);
          //     fabricCanvas.requestRenderAll();
          //   });
          // }
        }

        lol2() {
          fileIntegration.onPasteImageListeners.push((img) => {
            infiniteCanvas.manageImageImport(img);
          });
          fileIntegration.onPasteTextListeners.push((text) => {
            infiniteCanvas.manageTextImport(text);
          });
        }

      }










      //User Input

      class InputProperties {
        constructor() {
          this.scroll_step__default = 1.0 / 500;
          this.scrollProperties = {
            step: this.scroll_step__default,
          };



          this.scroll_step__slow = this.scroll_step__default / 10;
          this.scroll_step__fast = this.scroll_step__default * 10;


          this.move_multiplier__default = 1.0;
          this.moveProperties = {
            moveMultiplier: this.move_multiplier__default,
          };

          this.move_multiplier__slow = this.move_multiplier__default / 10;
          this.move_multiplier__fast = this.move_multiplier__default * 10;


          this.colorProperties = {
            activeIndex: 5,
            list: [
              "lime",

              "red",
              "green",
              "blue",

              "white",
              "black",

              "orange",
              "purple",
              "yellow",
            ],
          };

          this.setNextColor(0);

          this.opacity = 1.0;
          const screment = 0;
          this.setNextOpacity(screment);


          this.fColor__working = null;
        }

        setScrollStep(value) {
          //console.log("setScrollStep", value);
          this.scrollProperties.step = value;
        }

        setMoveMultiplier(value) {
          //console.log("setMoveMultiplier", value);
          this.moveProperties.moveMultiplier = value;
        }



        getActiveColor() {
          //debug
          // if(this.color__working != null) {
          //   return this.color__working;
          // }
          return this.colorProperties.list[this.colorProperties.activeIndex];
        }

        setNextColor(screment) {
          console.log("setNextColor", screment);

          var index = this.colorProperties.activeIndex;
          index += screment;
          if (index >= this.colorProperties.list.length) {
            index -= this.colorProperties.list.length;
          } else if (index < 0) {
            index += this.colorProperties.list.length;
          }

          this.colorProperties.activeIndex = index;

          {
            const color = this.getActiveColor();
            const opacity = this.getActiveOpacity();

            const fColor = new fabric.Color(color);
            fColor.setAlpha(opacity);

            this.setFColor__working(fColor);
          }



          //debug
          debug.setActiveColor(this.getActiveRgbaColorString());
        }

        setFColor__working(fColor) {
          this.fColor__working = fColor;

          // this.color__working = new fabric.Color(fColor.toRgb());
          this.opacity = fColor.getAlpha();
        }

        // setWorkingOpacity(color) {
        //
        // }



        getActiveOpacity() {
          return this.opacity;
        }

        setNextOpacity(screment) {
          console.log("setNextOpacity", screment);

          const opacity_prev = this.opacity;

          const step_opacity = 0.1;
          const screment_opacity = step_opacity * (-screment);

          const opacity_bounded = Math.min(1.0, Math.max(0.0, opacity_prev + screment_opacity));
          this.opacity = opacity_bounded;

          if (this.fColor__working != null) {
            this.fColor__working.setAlpha(opacity_bounded);
          }

          //debug
          debug.setActiveColor(this.getActiveRgbaColorString());
        }

        getActiveRgbaColorString() {
          var outString;

          if (this.fColor__working != null) {
            outString = this.fColor__working.toRgba();
          } else {
            const color = this.getActiveColor();
            const opacity = this.getActiveOpacity();

            const fColor = new fabric.Color(color);
            fColor.setAlpha(opacity);
            const rgbaColorString = fColor.toRgba();

            outString = rgbaColorString;
          }

          return outString;
        }

      }





      class KeyDownToggle {

        constructor(name, keyDownFunc, keyDownToggleFunc = null) {
          this.name = name;
          this.keyDownFunc = keyDownFunc;
          this.isActive = false;

          this.keyDownToggleFunc = keyDownToggleFunc;
          if (keyDownToggleFunc == null) {
            this.keyDownToggleFunc = KeyDownToggle.keyDownToggleFunc();
          }
        }

        update(e, down) {
          const updateValue = this.keyDownFunc(e, down);
          if (updateValue != null) {
            if (this.isActive != updateValue) {
              this.isActive = updateValue;
              this.keyDownToggleFunc(this.isActive);
            }
          }
        }

        static defaultKeyDownFunc(arr_keyCode) {
          const keyDownFunc = (e, down) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if (keyCode == e.code) {
                acc = down;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyDownFunc;
        }

        static keyDownToggleFunc() {
          return (isActive) => {
            console.log("KeyDownToggle::update", this.name, this.isActive);
          };
        }

      }

      class KeyDownTimeout {

        constructor(name, keyDownFunc, triggeredFunc, delayInMs) {
          this.name = name;
          this.keyDownFunc = keyDownFunc;
          this.triggeredFunc = triggeredFunc;
          this.delayInMs = delayInMs;

          this.isActive = false;
        }

        update(e, down) {
          const updateValue = this.keyDownFunc(e, down);
          if (updateValue != null) {
            if (this.isActive != updateValue) {
              this.isActive = updateValue;
              console.log("KeyDownTimeout::update", this.name, this.isActive);

              const keyDownTimeout = this;

              function theFunc() {
                console.log("KeyDownTimeout", "call triggeredFunc()");
                keyDownTimeout.triggeredFunc();
              }

              function mayRepeat(theFunc) {

                setTimeout(function () {
                  if (keyDownTimeout.isActive) {
                    theFunc();
                    mayRepeat(theFunc);
                  }
                }, keyDownTimeout.delayInMs);
              }

              theFunc();
              mayRepeat(theFunc);

            }
          }
        }

        static defaultKeyDownFunc(arr_keyCode) {
          const keyDownFunc = (e, down) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if (keyCode == e.code) {
                acc = down;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyDownFunc;
        }

      }

      class KeyUpABToggle {

        constructor(name, keyUpFunc, triggeredFunc) {
          this.name = name;
          this.keyUpFunc = keyUpFunc;
          this.triggeredFunc = triggeredFunc;

          this.isModeA = true;
        }

        update(e) {
          const updateValue = this.keyUpFunc(e);
          console.log("updateValue", updateValue);
          if (updateValue) {
            this.isModeA = !this.isModeA;
            console.log("KeyUpABToggle::update", this.name, this.isModeA);

            this.triggeredFunc(this.isModeA);
          }
        }

        static defaultKeyUpFunc(arr_keyCode) {
          const keyUpFunc = (e) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if (keyCode == e.code) {
                acc = true;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyUpFunc;
        }

      }

      class KeyboardIntegration {

        constructor(infiniteCanvas, inputProperties, fileIntegration, fabricIntegration) {
          this.infiniteCanvas = infiniteCanvas;
          this.inputProperties = inputProperties;

          this.fileIntegration = fileIntegration;

          this.fabricIntegration = fabricIntegration;


          // this.altKeyDown = false;
          this.keyDownToggles = {};
          this.keyDownTimeouts = {};

          this.keyUpABToggles = {};


          this.configureKeyboardEventHandlers();
        }

        configureKeyboardEventHandlers() {
          const keyboardIntegration = this;
          const infiniteCanvas = this.infiniteCanvas;

          const fabricIntegration = this.fabricIntegration;

          document.addEventListener('keyup', logKey);
          document.addEventListener('keyup', handleKeyUp);
          document.addEventListener('keydown', handleKeyDown);


          function configureKeyDownToggles() {

            keyboardIntegration.keyDownToggles = {
              // alt: new KeyDownToggle("alt", KeyDownToggle.defaultKeyDownFunc(["AltLeft", "AltRight"])),   //do not use alt, alt is kind of a system key
              r: new KeyDownToggle("r", KeyDownToggle.defaultKeyDownFunc(["KeyR"])),

              c: new KeyDownToggle("c", KeyDownToggle.defaultKeyDownFunc(["KeyC"])),
              v: new KeyDownToggle("v", KeyDownToggle.defaultKeyDownFunc(["KeyV"])),


              shiftLeft: new KeyDownToggle("shiftLeft", KeyDownToggle.defaultKeyDownFunc(["ShiftLeft"]), (isActive) => {
                //only side effect is used
              }),
              altLeft: new KeyDownToggle("altLeft", KeyDownToggle.defaultKeyDownFunc(["AltLeft"]), (isActive) => {
                //only side effect is used
              }),
              ctrlLeft: new KeyDownToggle("ctrlLeft", KeyDownToggle.defaultKeyDownFunc(["ControlLeft"]), (isActive) => {
                //only side effect is used
              }),

              // shiftLeft: new KeyDownToggle("shiftLeft", KeyDownToggle.defaultKeyDownFunc(["ShiftLeft"]), (isActive) => {
              backquote: new KeyDownToggle("backquote", KeyDownToggle.defaultKeyDownFunc(["Backquote"]), (isActive) => {
                /**/

                const isCosmetic = keyboardIntegration.keyDownToggles.altLeft.isActive;
                const cfg = {
                  isCosmetic: isCosmetic,
                };
                if (isActive) {
                  fabricIntegration.enterFreeDrawing(cfg);
                } else {
                  fabricIntegration.leaveFreeDrawing();
                }
                /**/
              }),

              digit1: new KeyDownToggle("digit1", KeyDownToggle.defaultKeyDownFunc(["Digit1"]), (isActive) => {
                /**/
                if (isActive) {
                  fabricIntegration.enterSlicing();
                } else {
                  fabricIntegration.leaveSlicing();
                }
                /**/
              }),

              // digit2: new KeyDownToggle("digit2", KeyDownToggle.defaultKeyDownFunc(["Digit2"]), (isActive) => {
              //   /**/
              //   if(isActive) {
              //     fabricIntegration.enterInnerPainting();
              //   } else {
              //     fabricIntegration.leaveInnerPainting();
              //   }
              //   /**/
              // }),

              zIndexEditing: new KeyDownToggle("zIndexEditing", KeyDownToggle.defaultKeyDownFunc(["Digit2"]), (isActive) => {
                if (isActive) {
                  infiniteCanvas.enterZIndexEditing();
                } else {
                  infiniteCanvas.leaveZIndexEditing();
                }
              }),

              pathmadeOperatorDrawing__conveyor: new KeyDownToggle("Digit5", KeyDownToggle.defaultKeyDownFunc(["Digit5"]), (isActive) => {

                if (isActive) {
                  var type;
                  if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                    type = "vesseler";
                  } else {
                    type = "conveyor";
                  }
                  fabricIntegration.enterPathmadeOperatorPathDrawing__grains(type);
                } else {
                  fabricIntegration.leavePathmadeOperatorPathDrawing__grains();
                }

              }),

              // pathmadeOperatorDrawing__shadePossessor: new KeyDownToggle("Digit4", KeyDownToggle.defaultKeyDownFunc(["Digit4"]), (isActive) => {
              //
              //   if(isActive) {
              //     const type = "shadePossessor";
              //     fabricIntegration.enterPathmadeOperatorPathDrawing__grains(type);
              //   } else {
              //     fabricIntegration.leavePathmadeOperatorPathDrawing__grains();
              //   }
              //
              // }),

              pathmadeOperatorDrawing__shadePossessor: new KeyDownToggle("Digit4", KeyDownToggle.defaultKeyDownFunc(["Digit4"]), (isActive) => {

                if (isActive) {
                  const type = "shadePossessor";
                  fabricIntegration.enterPathmadeOperatorPathDrawing__grains(type);
                } else {
                  fabricIntegration.leavePathmadeOperatorPathDrawing__grains();
                }

              }),

              pathmadeOperatorDrawing__multi: new KeyDownToggle("Digit3", KeyDownToggle.defaultKeyDownFunc(["Digit3"]), (isActive) => {

                if (isActive) {
                  const type = "conveyor";
                  // const type = "shadePossessor";
                  fabricIntegration.enterPathmadeOperatorPathDrawing__composite(type);
                } else {
                  fabricIntegration.leavePathmadeOperatorPathDrawing__composite();
                }

              }),

              // recording: new KeyDownToggle("recording", KeyDownToggle.defaultKeyDownFunc(["Digit6"]), (isActive) => {
              //   if(isActive) {
              //     infiniteCanvas.enterRecording();
              //   } else {
              //     infiniteCanvas.leaveRecording();
              //   }
              // }),

            };

          }
          configureKeyDownToggles();


          function configureKeyDownTimeouts() {

            const default_timeout_delayInMs = 17; //17 ms == 60 fps
            keyboardIntegration.keyDownTimeouts = {

              a: new KeyDownTimeout("a", KeyDownToggle.defaultKeyDownFunc(["KeyQ"]), () => {
                var scaleAmount_for_100ms;

                if (keyboardIntegration.keyDownToggles.ctrlLeft.isActive) {
                  //ignore
                  return;
                }

                if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  scaleAmount_for_100ms = -0.3;
                } else {
                  scaleAmount_for_100ms = -0.1;
                }

                const scaleAmount = default_timeout_delayInMs / 100 * scaleAmount_for_100ms;
                keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
              }, default_timeout_delayInMs),

              z: new KeyDownTimeout("z", KeyDownToggle.defaultKeyDownFunc(["KeyW"]), () => {
                var scaleAmount_for_100ms;

                if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  scaleAmount_for_100ms = +0.3;
                } else {
                  scaleAmount_for_100ms = +0.1;
                }

                const scaleAmount = default_timeout_delayInMs / 100 * scaleAmount_for_100ms;
                keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
              }, default_timeout_delayInMs),
            };

          }
          configureKeyDownTimeouts();


          function configureKeyUpABToggles() {

            keyboardIntegration.keyUpABToggles = {
              ":": new KeyUpABToggle(":", KeyUpABToggle.defaultKeyUpFunc(["Period"]), (isModeA) => {
                keyboardIntegration.fabricIntegration.setAntiAliasEnabled(isModeA);
              }),

              "n": new KeyUpABToggle("n", KeyUpABToggle.defaultKeyUpFunc(["KeyN"]), (isModeA) => {
                keyboardIntegration.fabricIntegration.setSupervesselEnabled(isModeA);
              }),

              "d": new KeyUpABToggle("d", KeyUpABToggle.defaultKeyUpFunc(["KeyD"]), (isModeA) => {
                const infiniteCanvas = keyboardIntegration.infiniteCanvas;
                if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  if (!isModeA) {
                    infiniteCanvas.createIcLine_start();
                  } else {
                    infiniteCanvas.createIcLine_end();
                  }
                } else {
                  if (!isModeA) {
                    infiniteCanvas.createIcHUDLine_start();
                  } else {
                    infiniteCanvas.createIcHUDLine_end();
                  }
                }
              }),

              "KeyZ": new KeyUpABToggle("w", KeyUpABToggle.defaultKeyUpFunc(["KeyZ"]), (isModeA) => {
                const infiniteCanvas = keyboardIntegration.infiniteCanvas;
                if (!isModeA) {
                  infiniteCanvas.createIcBrokenLine_start();
                } else {
                  infiniteCanvas.createIcBrokenLine_end();
                }
              }),

              "^": new KeyUpABToggle("^", KeyUpABToggle.defaultKeyUpFunc(["BracketLeft"]), (isModeA) => {
                const infiniteCanvas = keyboardIntegration.infiniteCanvas;
                if (!isModeA) {
                  infiniteCanvas.debug_sparkleAnims(true);
                } else {
                  infiniteCanvas.debug_sparkleAnims(false);
                }
              }),
            };

          }
          configureKeyUpABToggles();



          function updateKeyDownToggles(e, down) {
            const arr_keyDownToggles = Object.values(keyboardIntegration.keyDownToggles);
            arr_keyDownToggles.forEach((keyDownToggle, i) => {
              keyDownToggle.update(e, down);
            });
          }

          function updateKeyDownTimeouts(e, down) {
            const arr_keyDownTimeouts = Object.values(keyboardIntegration.keyDownTimeouts);
            arr_keyDownTimeouts.forEach((keyDownTimeout, i) => {
              keyDownTimeout.update(e, down);
            });
          }

          function updateKeyUpABToggles(e) {
            const arr_keyUpABToggles = Object.values(keyboardIntegration.keyUpABToggles);
            arr_keyUpABToggles.forEach((keyUpABToggle, i) => {
              keyUpABToggle.update(e);
            });
          }


          function logKey(e) {
            //console.log("logKey", "e.code", e.code);
          }

          function handleKeyUp(e) {
            logger.log("handleKeyUp", "e", e);

            logger.log("globalsSingleton.isEditing", globalsSingleton.isEditing);
            if(globalsSingleton.isEditing) {
              return;
            }

            if (fabricIntegration.shouldIgnoreShortcutInput()) {
              return;
            }

            updateKeyDownToggles(e, false);
            updateKeyDownTimeouts(e, false);
            updateKeyUpABToggles(e);



            switch (e.code) {

              case "KeyQ":
                {
                  if (keyboardIntegration.keyDownToggles.ctrlLeft.isActive) {
                    fabricIntegration.selectAll();
                  }
                }
                break;

              case "KeyI":
                {
                  if (keyboardIntegration.keyDownToggles.ctrlLeft.isActive) {
                    FileIntegration.importVideo_p()
                      .then(video => {
                        infiniteCanvas.manageVideoImport(video);
                        keyboardIntegration.keyDownToggles.ctrlLeft.isActive = false; //force untoggle (bugfix)
                      });
                  }
                  else if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
                    FileIntegration.videoFromWebcam_p()
                      .then(video => {
                        infiniteCanvas.manageVideoImport(video);
                        keyboardIntegration.keyDownToggles.altLeft.isActive = false;
                      });
                  }
                  else if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                    FileIntegration.importImage_folder_p()
                      .then(arr_img => {
                        arr_img.forEach(img => {
                          infiniteCanvas.manageImageImport(img);
                        });
                      });
                  }
                  else {
                    FileIntegration.importImage_multiple_p()
                      .then(arr_img => {
                        arr_img.forEach(img => {
                          infiniteCanvas.manageImageImport(img);
                        });
                      });
                  }
                }

                break;

              case "KeyS":
                {
                  if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                    //compose
                    fabricIntegration.spreadSelectedObjects();
                  } else {
                    infiniteCanvas.manageSaveInfinishute_p()
                      .then((success) => {
                        console.log("success", success);
                      });
                  }
                }
                break;
              case "KeyL":
                {
                  if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                    //lock everything
                    infiniteCanvas.vitrify();
                  } else if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
                    //unlock everything
                    infiniteCanvas.vivify();
                  } else {
                    //load
                    FileIntegration.loadInfinishute_p()

                      //debug
                      .then(infinishute => {
                        console.log("loaded infinishute", infinishute);
                        return infinishute;
                      })

                      .then(infinishute => {
                        infiniteCanvas.manageLoadInfinishute(infinishute);
                      });
                  }
                }

                break;

              /*
              // case "ShiftLeft":
              case "KeyZ":
                handleKey_Shift(e);
                break;
              // case "ControlLeft":
              case "KeyX":
                handleKey_Ctrl(e);
                break;
              */


              case "KeyE":
                {
                  const cursor = null;
                  // fabricIntegration.activateObjectAtCursor();

                  //debug
                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_editable("x 1");

                  keyboardIntegration.infiniteCanvas.operateOnActiveObject__export_asImg();
                }
                break;


              case "KeyF":
                if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  // keyboardIntegration.infiniteCanvas.addNewSpotPoint();
                  keyboardIntegration.infiniteCanvas.addNewPoint();
                } else {
                  keyboardIntegration.infiniteCanvas.addNewRect();
                }
                break;


              // case "KeyF":
              //   handleKeyUp_F(e);
              //   break;

              // case "KeyT":
              //   handleKeyUp_T(e);
              //   break;
              case "KeyT":
                {
                  if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                    //tag
                    const debug_text = "challenge.";
                    keyboardIntegration.infiniteCanvas.addNewTag(debug_text);
                  } else {
                    //text
                    const debug_text = "icText";
                    // const debug_text = "return infiniteCanvas.createIcRect(trueRect);";
                    // const debug_text = "scriptOutput = infiniteCanvas.createIcRect(trueRect);";
                    keyboardIntegration.infiniteCanvas.addNewText(debug_text);
                  }

                }
                break;

              case "KeyA":
                {
                  keyboardIntegration.infiniteCanvas.addNewCircle();
                }
                break;

              case "KeyH":
                {
                  keyboardIntegration.infiniteCanvas.addNewSnapSlot();
                }
                break;

              case "KeyZ":
                {
                  // FileIntegration.importImage_p()
                  //   .then(img => {
                  //     infiniteCanvas.addNewSparkle(img);
                  //   });

                }
                break;

              case "KeyX":
                {
                  // if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  //   keyboardIntegration.infiniteCanvas.operateOnActiveObject__poopGeminiShade();
                  // }
                  // else
                  if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
                    const mathNode = new math.SymbolNode("x");
                    mathNode.autoSimplify = true;

                    keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
                  }
                  else {
                    keyboardIntegration.infiniteCanvas.operateOnActiveObject__poopSameHomeScaleClone();
                  }
                }
                break;

              case "KeyU":
                {
                  // keyboardIntegration.infiniteCanvas.addNewTouchSlot();

                  keyboardIntegration.infiniteCanvas.addNewGMOperator();

                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_editable("x (22/7)");
                }
                break;

              case "KeyY":
                {
                  // keyboardIntegration.infiniteCanvas.addNewGMChallenge(0);

                  if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
                    const mathNode = new math.SymbolNode("y");
                    mathNode.autoSimplify = true;

                    keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
                  }
                  else {
                    keyboardIntegration.infiniteCanvas.addNewStore();
                  }

                }
                break;



              // case "Digit3":
              //   {
              //     // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify__remove_parentheses");
              //
              //     // const mathNode = math.parse("3*2");
              //     // keyboardIntegration.infiniteCanvas.addNewMNReictangle(mathNode);
              //
              //     // const sandBox_doubleObjects = new SandBox_doubleObjects(keyboardIntegration.infiniteCanvas);
              //
              //     keyboardIntegration.infiniteCanvas.addNewToggleRect();
              //   }
              // break;

              // case "Digit4":
              //   {
              //     // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify__remove_parentheses");
              //     // keyboardIntegration.infiniteCanvas.operateOnActiveObject__executeScript();
              //
              //     // keyboardIntegration.infiniteCanvas.operateOnActiveObject__setBehavior("stickyRelease", true);
              //     fabricIntegration.prepareSingleUseBehavior("stickyRelease");
              //   }
              // break;


              // case "Digit5":
              //   {
              //     // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify__remove_parentheses");
              //     // keyboardIntegration.infiniteCanvas.addNewText("=");
              //
              //     fabricIntegration.linkSelectedObjects();
              //   }
              // break;

              case "Digit6":
                {

                  // {
                  //   // const html_elt = document.getElementById("debug_nbObjects");
                  //   // const html_elt = document.body;
                  //
                  //
                  //   const input = document.createElement("INPUT");
                  //   input.setAttribute("type", "text");
                  //   // input.setAttribute("text", "lolilol");
                  //
                  //   input.style.backgroundColor = "yellow";
                  //   document.body.appendChild(input);
                  //
                  //   const html_elt = input;
                  //
                  //
                  //   /*
                  //   const div = document.createElement("DIV");
                  //   div.style.backgroundColor = "yellow";
                  //   div.style.width  = "200px";
                  //   div.style.height = "200px";
                  //
                  //   // div.style.visibility = "hidden";
                  //   // div.style.display = "none";
                  //
                  //   document.body.appendChild(div);
                  //
                  //   const html_elt = div;
                  //   */
                  //
                  //   keyboardIntegration.infiniteCanvas.addNewHtmlElt(html_elt);
                  // }

                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("mark__slash_simplifiable");

                  keyboardIntegration.infiniteCanvas.manageEnterOrLeaveRecording();
                }
                break;

              case "Digit7":
                {
                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify");
                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify__step_by_step");
                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify__top_layer");

                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("equation__add1");

                  keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("split__top_layer");
                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("decomposition__product_primes");

                  // keyboardIntegration.infiniteCanvas.addNewGMSafetyZone();
                }
                break;

              case "Digit8":
                {
                  // keyboardIntegration.infiniteCanvas.addNewTouchSlot();
                  // keyboardIntegration.infiniteCanvas.addNewGMTargetSlot();

                  // keyboardIntegration.infiniteCanvas.addNewGMTargetTouchSlot();

                  keyboardIntegration.infiniteCanvas.operateOnActiveObject__toggleProperty("isTouchable");
                }
                break;

              case "Digit9":
                {
                  // keyboardIntegration.infiniteCanvas.addNewCountdown();
                  keyboardIntegration.infiniteCanvas.addNewIcEngined_debug();

                  // keyboardIntegration.infiniteCanvas.manageMoveEvent_debug();
                  // keyboardIntegration.infiniteCanvas.addNewCounter();
                }
                break;

              case "F2":
                {
                  const cfg = {
                    isConsume: false,
                  };
                  keyboardIntegration.infiniteCanvas.addNewConductiveOperator_withType("randInBag", cfg);
                }
                break;

              case "F4":
                {
                  const cfg = {
                    isConsume: true,
                  };
                  keyboardIntegration.infiniteCanvas.addNewConductiveOperator_withType("randInBag", cfg);
                }
                break;

              case "F8":
                {
                  const cfg = {
                    min: 0,
                    max: 20,
                  };
                  keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("rand_int", cfg);
                }
                break;

              case "F9":
                {

                  // const cfg = {
                  //   f_name: "cos",
                  // };
                  //
                  // if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  //   keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("function", cfg);
                  // } else {
                  //   keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("functionamer", cfg);
                  // }

                  keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("format:toFixed");
                }
                break;

              case "F10":
                {
                  keyboardIntegration.infiniteCanvas.addNewText("=");
                }
                break;


              case "KeyJ":
                {
                  // keyboardIntegration.infiniteCanvas.addNewWell();

                  {
                    const cfg = {
                      index: 1,
                    };
                    keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("c:objectAtIndex", cfg);
                  }

                }
                break;

              case "KeyN":
                {
                  // keyboardIntegration.infiniteCanvas.addNewComposite();
                  // keyboardIntegration.infiniteCanvas.addNewGreenMouseWell();
                }
                break;

              case "KeyM":
                {
                  logger.log("keyM");
                  // keyboardIntegration.infiniteCanvas.addNewTouchSlot();
                  // keyboardIntegration.infiniteCanvas.addNewBornAgainGreenMouse(1);

                  // keyboardIntegration.infiniteCanvas.addNewRxSubject(1);
                  // keyboardIntegration.infiniteCanvas.addNewLabelValue("lol", 9);

                  keyboardIntegration.infiniteCanvas.operateOnActiveObject__split();     // == split supervessel cargo
                }
                break;

              case "Comma":
                {
                  // keyboardIntegration.infiniteCanvas.addNewButton();
                  // keyboardIntegration.infiniteCanvas.addNewRxSubscription();

                  keyboardIntegration.infiniteCanvas.operateOnActiveObject__join();     // == join supervessel cargo
                }
                break;




              case "Quote":
                {
                  const tex = '\\frac{1}{x^2-1}';
                  // const svgEl = TexHelper.toSvgEl(tex);
                  // keyboardIntegration.infiniteCanvas.addNewSvg(svgEl);

                  // keyboardIntegration.infiniteCanvas.addNewTex(tex);

                  // const expression = new algebra.Expression("x");
                  // expression.autoSimplify = false;
                  // keyboardIntegration.infiniteCanvas.addNewExpr(expression);

                  // const equation = new algebra.Equation(new algebra.Expression("x"), new algebra.Expression("3"));
                  // keyboardIntegration.infiniteCanvas.addNewExpr(equation);


                  /*
                  // const mathNode = math.parse("1");
                  const mathNode = new math.ConstantNode(1);
                  // const mathNode = new math.SymbolNode("x");
                  mathNode.autoSimplify = true;
                  // mathNode.autoSimplify = false;
                  keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
                  */

                  // const mathNode = random_mathNode_withDepth(4);
                  // const mathNode = random_mathNode_withDepth_and_nbSymbols(4,0);
                  // const mathNode = random_mathNode_withDepth_and_nbSymbols(4,1);

                  // const mathNode = random_onion_mathNode(5);
                  // const mathNode = random_onion_mathNode(5, false);
                  // const mathNode = random_onion_mathNode(3);

                  // const mathNode = random_onion_mathNode(2);
                  const mathNode = random_onion_mathNode(3);
                  // mathNode.autoSimplify = false;

                  // const mathNode = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
                  // mathNode.autoSimplify = true;

                  keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
                  // keyboardIntegration.infiniteCanvas.addNewGreenMouseBox(mathNode);
                }
                break;

              case "Digit0":
                {
                  // keyboardIntegration.infiniteCanvas.addNewFacet_mathNode();

                  keyboardIntegration.infiniteCanvas.manageReplay_debug();
                  // keyboardIntegration.infiniteCanvas.manageReplay_debug__machineGun();
                }
                break;








              case "Equal":
                {
                  // keyboardIntegration.infiniteCanvas.addNewObserver();
                  keyboardIntegration.infiniteCanvas.addNewClickWell(-22);
                }
                break;

              case "Minus":
                {
                  // keyboardIntegration.infiniteCanvas.addNewTrigger();
                  keyboardIntegration.infiniteCanvas.addNewEye();
                }
                break;

              case "Backslash":
                {
                  // keyboardIntegration.infiniteCanvas.addNewEventEmitter();

                  const mathNode_left = new math.SymbolNode("x");
                  mathNode_left.autoSimplify = false;
                  const mathNode_right = new math.ConstantNode(1);
                  mathNode_right.autoSimplify = true;
                  const mathNode_equation = new math.RelationalNode(["equal"], [mathNode_left, mathNode_right]);
                  // mathNode_equation.params[0].autoSimplify = false;
                  // mathNode_equation.params[1].autoSimplify = true;
                  mathNode_equation.isEquation = true;

                  const mathNode = mathNode_equation;
                  keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
                }
                break;

              case "BracketRight":
                {
                  // keyboardIntegration.infiniteCanvas.addNewClickWell();
                  // keyboardIntegration.infiniteCanvas.addNewEventReceiver();

                  keyboardIntegration.infiniteCanvas.spawnImageCart();
                }
                break;

              case "BracketRight":
                {
                  keyboardIntegration.infiniteCanvas.addNewEventReceiver();
                }
                break;





              case "KeyG":
                {
                  if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                    //compose
                    fabricIntegration.composeSelectedObjects();
                  } else if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
                    //link
                    fabricIntegration.linkSelectedObjects();
                  } else {
                    //group
                    fabricIntegration.groupSelectedObjects();
                  }
                }
                break;

              case "KeyB":
                {
                  if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                    //decompose
                    fabricIntegration.decomposeSelectedObject();
                  } else if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
                    //unlink
                    fabricIntegration.unlinkSelectedObjects();
                  } else {
                    //ungroup
                    fabricIntegration.ungroupSelectedObject();
                  }
                }
                break;




              // case "Digit0":
              // case "Numpad0":
              //   keyboardIntegration.infiniteCanvas.move_to_initial_position();
              //   break;

              case "BackQuote":

                //nothing for now

                break;



              // case "KeyW":
              //   {
              //     const scaleAmount = -0.1;
              //     keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
              //   }
              //   break;
              //
              // case "KeyE":
              //   {
              //     const scaleAmount = 0.1;
              //     keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
              //   }
              //   break;


              // case "KeyM":
              case "Semicolon":
                // if(keyboardIntegration.keyDownToggles.r.isActive) {
                //   keyboardIntegration.infiniteCanvas.manageCenterRotation(-10);
                // } else {
                //   keyboardIntegration.infiniteCanvas.updateWithDOrientation(-10);
                // }

                keyboardIntegration.infiniteCanvas.addNewCollection("1..10");

                break;

              case "KeyP":
                // if(keyboardIntegration.keyDownToggles.r.isActive) {
                //   keyboardIntegration.infiniteCanvas.manageCenterRotation(+10);
                // } else {
                //   keyboardIntegration.infiniteCanvas.updateWithDOrientation(+10);
                // }

                // keyboardIntegration.infiniteCanvas.addNewCollectionOperator("+1");
                // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("c:map:1",  {isCollectionOperator: true});

                if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
                  const mathNode = new math.SymbolNode("y");
                  mathNode.autoSimplify = true;
                  keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);

                }
                else {
                  keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("c:map:", { operatorString: "+ 1" });
                }

                break;

              case "KeyK":
                {
                  // function openUrlInNewTab(url){
                  //   var win = window.open(url, '_blank');
                  // }
                  // openUrlInNewTab("https://www.qwant.com/?l=fr");

                  keyboardIntegration.fabricIntegration.deleteAllObjects();
                }
                break;

              case "KeyC":
                {
                  if (keyboardIntegration.keyDownToggles.backquote.isActive) {
                    const fColor__cursor_p = fabricIntegration.getFColor__under_cursor_p();

                    fColor__cursor_p.then((fColor) => {

                      logger.log("fColor__cursor", fColor);
                      keyboardIntegration.inputProperties.setFColor__working(fColor);

                      //refresh current brush color
                      // fabricIntegration.leaveFreeDrawing();    //SHU: this does not work
                      // fabricIntegration.enterFreeDrawing();

                      const brushConfig = fabricIntegration.brushConfig__freeDrawing();
                      fabricIntegration.configureFreeDrawingBrush(brushConfig);
                    });

                  } else if (keyboardIntegration.keyDownToggles.altLeft.isActive) {

                    //coreify active object
                    keyboardIntegration.infiniteCanvas.operateOnActiveObject__coreify();
                  }
                }
                break;


              // case "AltLeft":
              // case "AltRight":
              //   keyboardIntegration.altKeyDown = false;
              //   break;

              case "Delete":
                fabricIntegration.deleteSelection();
                break;


              case "Space":
                fabricIntegration.deselectAll();
                break;


              default:

                //listen to numpad digits
                const arr_numpad = (e.code).split("Numpad");
                logger.log("arr_numpad", arr_numpad);
                const code__numpad = arr_numpad[1];
                if (code__numpad != null) {
                  logger.log("arr_numpad[1]", arr_numpad[1]);

                  switch (code__numpad) {
                    case "Add":
                      {
                        const cfg = {
                          isConsume: false,
                        };
                        keyboardIntegration.infiniteCanvas.addNewConductiveOperator_withType("+", cfg);

                        //debug (pour les élèves en salle info)
                        // keyboardIntegration.inputProperties.scrollProperties.step *= 2;
                      }
                      break;
                    case "Subtract":
                      {
                        const cfg = {
                          isConsume: false,
                        };
                        keyboardIntegration.infiniteCanvas.addNewConductiveOperator_withType("-", cfg);

                        //debug (pour les élèves en salle info)
                        // keyboardIntegration.inputProperties.scrollProperties.step /= 2;
                      }
                      break;
                    case "Multiply":
                      {
                        const cfg = {
                          isConsume: false,
                        };
                        keyboardIntegration.infiniteCanvas.addNewConductiveOperator_withType("x", cfg);
                      }
                      break;
                    case "Divide":
                      {
                        const cfg = {
                          isConsume: false,
                        };
                        keyboardIntegration.infiniteCanvas.addNewConductiveOperator_withType("/", cfg);
                      }
                      break;
                    default:
                      {
                        const num__code = parseInt(code__numpad);
                        logger.log("num__code", num__code);

                        if (num__code != NaN) {
                          const mathNode = new math.ConstantNode(num__code);
                          mathNode.autoSimplify = true;

                          keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
                        }

                      }
                      break;
                  }

                }

                break;
            }
          }

          function handleKeyDown(e) {
            //console.log("handleKeyDown", "e.code", e.code);

            logger.log("globalsSingleton.isEditing", globalsSingleton.isEditing);
            if(globalsSingleton.isEditing) {
              return;
            }

            if (fabricIntegration.shouldIgnoreShortcutInput()) {
              return;
            }

            updateKeyDownToggles(e, true);
            updateKeyDownTimeouts(e, true);


            switch (e.code) {
              /*
              // case "ShiftLeft":
              case "KeyZ":
                handleKey_Shift(e);
                break;
              // case "ControlLeft":
              case "KeyX":
                handleKey_Ctrl(e);
                break;
              */

              // case "AltLeft":
              // case "AltRight":
              //   keyboardIntegration.altKeyDown = true;
              //   break;

              default:
                break;
            }
          }



          // function handleKeyUp_A(e) {
          //   //console.log("handleKeyUp_A", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const zimage_scream = this.createScreamZimage(canvasBoundingTrueRect);
          //   this.addZimage(zimage_scream);
          //
          //   this.redrawCanvas();
          // }

          // function handleKeyUp_F(e) {
          //   //console.log("handleKeyUp_F", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const fObj = this.createFabricSampleObjectWithCanvasBoundingRect(canvasBoundingTrueRect);
          //   this.addFabricObject(fObj);
          //
          //   this.redrawCanvas();
          // }

          // function handleKeyUp_T(e) {
          //   //console.log("handleKeyUp_T", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const fObj = this.createFabricSampleTextObjectWithCanvasBoundingRect(canvasBoundingTrueRect);
          //   this.addFabricObject(fObj);
          //
          //   this.redrawCanvas();
          // }

          //scroll fast/slow

          /*
                  $(document).keydown(function(event) {
                  if (event.ctrlKey==true && (event.which == '61' || event.which == '107' || event.which == '173' || event.which == '109'  || event.which == '187'  || event.which == '189'  ) ) {
                          event.preventDefault();
                       }
                      // 107 Num Key  +
                      // 109 Num Key  -
                      // 173 Min Key  hyphen/underscor Hey
                      // 61 Plus key  +/= key
                  });

                  $(window).bind('mousewheel DOMMouseScroll', function (event) {
                         if (event.ctrlKey == true) {
                         event.preventDefault();
                         }
                  });
          */



          function handleKey_Shift(e) {
            switch (e.type) {
              case "keydown":
                this.setScrollStep(scroll_step__fast);
                this.setMoveMultiplier(move_multiplier__fast);
                break;
              case "keyup":
                this.setScrollStep(scroll_step__default);
                this.setMoveMultiplier(move_multiplier__default);
                break;
              default:
                break;
            }
          }

          function handleKey_Ctrl(e) {
            switch (e.type) {
              case "keydown":
                this.setScrollStep(scroll_step__slow);
                this.setMoveMultiplier(move_multiplier__slow);
                break;
              case "keyup":
                this.setScrollStep(scroll_step__default);
                this.setMoveMultiplier(move_multiplier__default);
                break;
              default:
                break;
            }
          }

        }


      }



      class MouseIntegration {

        constructor(canvasContainer, infiniteCanvas, inputProperties, keyboardIntegration) {

          this.infiniteCanvas = infiniteCanvas;
          this.inputProperties = inputProperties;

          this.leftMouseDown = false;
          this.rightMouseDown = false;

          this.keyboardIntegration = keyboardIntegration;

          this.configureMouseEventHandlers(canvasContainer);
        }

        // Mouse Event Handlers
        configureMouseEventHandlers(canvasContainer) {
          const mouseIntegration = this;

          const keyboardIntegration = this.keyboardIntegration;
          const inputProperties = this.inputProperties;

          const infiniteCanvas = this.infiniteCanvas;


          canvasContainer.addEventListener('mousedown', onMouseDown);
          canvasContainer.addEventListener('mouseup', onMouseUp, false);
          canvasContainer.addEventListener('mouseout', onMouseUp, false);
          canvasContainer.addEventListener('mousemove', onMouseMove, false);
          canvasContainer.addEventListener('wheel', onMouseWheel, false);

          // mouse functions
          function onMouseDown(event) {

            /*
            // update the cursor coordinates
            const cursor = {
              x: event.pageX,
              y: event.pageY,
            };

            this.infiniteCanvas.updateCursor(cursor);
            */

            // detect left clicks
            if (event.button == 0) {
              mouseIntegration.leftMouseDown = true;
              mouseIntegration.rightMouseDown = false;
            }
            // detect right clicks
            if (event.button == 2) {
              mouseIntegration.rightMouseDown = true;
              mouseIntegration.leftMouseDown = false;
            }
          }

          function onMouseMove(event) {
            // //console.log("onMouseMove", "event", event);

            // update cursor with mouse position
            const cursor = {
              x: event.pageX,
              y: event.pageY,
            };
            mouseIntegration.infiniteCanvas.updateCursor(cursor);


            if (mouseIntegration.leftMouseDown) {
              mouseIntegration.infiniteCanvas.manageCursorMove_line();
            }
            else if (mouseIntegration.rightMouseDown) {
              //console.log("onMouseMove", "rightMouseDown", "event", event);

              // console.log("keyboardIntegration.altKeyDown", keyboardIntegration.altKeyDown);
              // if(keyboardIntegration.keyDownToggles.r.isActive) {
              //   mouseIntegration.infiniteCanvas.manageCursorMove_rotate();
              // } else {
              //   mouseIntegration.infiniteCanvas.manageCursorMove_offset();
              // }
              mouseIntegration.infiniteCanvas.manageCursorMove_offset();

            } else if (keyboardIntegration.keyDownToggles.r.isActive) {
              mouseIntegration.infiniteCanvas.manageCursorMove_rotate();
            }

          }

          function onMouseUp() {
            mouseIntegration.leftMouseDown = false;
            mouseIntegration.rightMouseDown = false;

            mouseIntegration.infiniteCanvas.logCursor();
          }

          function onMouseWheel(event) {

            if (keyboardIntegration.keyDownToggles.c.isActive) {
              colorScroll();
            } else if (keyboardIntegration.keyDownToggles.v.isActive) {
              opacityScroll();
            } else if (infiniteCanvas.isZIndexEditing) {
              zIndexEditingScroll();
            }
            else {
              zoomScroll();
            }

            function colorScroll() {
              const deltaY = event.deltaY;
              const screment = deltaY > 0 ? 1 : -1;
              inputProperties.setNextColor(screment);
            }

            function opacityScroll() {
              const deltaY = event.deltaY;
              const screment = deltaY > 0 ? 1 : -1;
              inputProperties.setNextOpacity(screment);
            }

            function zIndexEditingScroll() {
              const deltaY = event.deltaY;
              const screment = deltaY > 0 ? 1 : -1;
              infiniteCanvas.manageZIndexEditingScrement(screment);
            }

            function zoomScroll() {
              const deltaY = event.deltaY;
              // const scaleAmount = -deltaY / 500;
              const scroll_step = mouseIntegration.inputProperties.scrollProperties.step;
              //console.log("onMouseWheel", "scroll_step", scroll_step);
              const scaleAmount = -deltaY * scroll_step;

              const scaleAmount_max = 0.99;
              const scaleAmount_min = -0.99;
              const scaleAmount_bounded = Math.min(scaleAmount_max, Math.max(scaleAmount_min, scaleAmount));

              mouseIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount_bounded);

              /*
              var zoom = canvas.getZoom();
              zoom *= 0.999 ** deltaY;
              // if (zoom > 20) zoom = 20;
              // if (zoom < 0.01) zoom = 0.01;
              canvas.setZoom(zoom);
              event.preventDefault();
              event.stopPropagation();
              */



              // const scale_new = scale * (1 + scaleAmount);

              /*
              // zoom the page based on where the cursor is
              var distX = event.pageX / canvas.clientWidth;
              var distY = event.pageY / canvas.clientHeight;

              // calculate how much we need to zoom
              const unitsZoomedX = trueWidth() * scaleAmount;
              const unitsZoomedY = trueHeight() * scaleAmount;

              const unitsAddLeft = unitsZoomedX * distX;
              const unitsAddTop = unitsZoomedY * distY;

              const dOffsetX = unitsAddLeft;
              const dOffsetY = unitsAddTop;

              const dOffset = {
                dx: dOffsetX,
                dy: dOffsetY,
              };

              updateScaleAndDOffset(scale_new, dOffset);
              */
            }


          }

          // function onMouseWheel(event) {
          //   const deltaY = event.deltaY;
          //   const scaleAmount = -deltaY / 500;
          //   scale = scale * (1 + scaleAmount);
          //
          //   // zoom the page based on where the cursor is
          //   var distX = event.pageX / canvas.clientWidth;
          //   var distY = event.pageY / canvas.clientHeight;
          //
          //   // calculate how much we need to zoom
          //   const unitsZoomedX = trueWidth() * scaleAmount;
          //   const unitsZoomedY = trueHeight() * scaleAmount;
          //
          //   const unitsAddLeft = unitsZoomedX * distX;
          //   const unitsAddTop = unitsZoomedY * distY;
          //
          //   offsetX -= unitsAddLeft;
          //   offsetY -= unitsAddTop;
          // }

        }

      }

      class TouchIntegration {

        constructor(canvasContainer, infiniteCanvas, inputProperties) {
          // touch functions
          this.prevTouches = [null, null]; // up to 2 touches
          this.singleTouch = false;
          this.doubleTouch = false;

          this.configureTouchEventHandlers(canvasContainer);
        }

        configureTouchEventHandlers(canvasContainer) {
          // Touch Event Handlers
          canvasContainer.addEventListener('touchstart', onTouchStart);
          canvasContainer.addEventListener('touchend', onTouchEnd);
          canvasContainer.addEventListener('touchcancel', onTouchEnd);
          canvasContainer.addEventListener('touchmove', onTouchMove);


          function onTouchStart(event) {
            if (event.touches.length == 1) {
              this.singleTouch = true;
              this.doubleTouch = false;
            }
            if (event.touches.length >= 2) {
              this.singleTouch = false;
              this.doubleTouch = true;
            }

            // store the last touches
            this.prevTouches[0] = event.touches[0];
            this.prevTouches[1] = event.touches[1];

          }

          function onTouchMove(event) {
            // get first touch coordinates
            const touch0X = event.touches[0].pageX;
            const touch0Y = event.touches[0].pageY;
            const prevTouch0X = this.prevTouches[0].pageX;
            const prevTouch0Y = this.prevTouches[0].pageY;

            const pointTouch0 = {

            };

            const pointPrevTouch0 = {

            };

            const scaledX = toTrueX(pointTouch0);
            const scaledY = toTrueY(pointTouch0);
            const prevScaledX = toTrueX(pointPrevTouch0);
            const prevScaledY = toTrueY(pointPrevTouch0);

            if (singleTouch) {
              // add to history
              drawings.push({
                x0: prevScaledX,
                y0: prevScaledY,
                x1: scaledX,
                y1: scaledY
              })
              drawLine(prevTouch0X, prevTouch0Y, touch0X, touch0Y);
            }

            if (doubleTouch) {
              // get second touch coordinates
              const touch1X = event.touches[1].pageX;
              const touch1Y = event.touches[1].pageY;
              const prevTouch1X = prevTouches[1].pageX;
              const prevTouch1Y = prevTouches[1].pageY;

              // get midpoints
              const midX = (touch0X + touch1X) / 2;
              const midY = (touch0Y + touch1Y) / 2;
              const prevMidX = (prevTouch0X + prevTouch1X) / 2;
              const prevMidY = (prevTouch0Y + prevTouch1Y) / 2;

              // calculate the distances between the touches
              const hypot = Math.sqrt(Math.pow((touch0X - touch1X), 2) + Math.pow((touch0Y - touch1Y), 2));
              const prevHypot = Math.sqrt(Math.pow((prevTouch0X - prevTouch1X), 2) + Math.pow((prevTouch0Y - prevTouch1Y), 2));

              // calculate the screen scale change
              var zoomAmount = hypot / prevHypot;
              scale = scale * zoomAmount;
              const scaleAmount = 1 - zoomAmount;

              // calculate how many pixels the midpoints have moved in the x and y direction
              const panX = midX - prevMidX;
              const panY = midY - prevMidY;
              // scale this movement based on the zoom level
              offsetX += (panX / scale);
              offsetY += (panY / scale);

              // Get the relative position of the middle of the zoom.
              // 0, 0 would be top left.
              // 0, 1 would be top right etc.
              var zoomRatioX = midX / canvas.clientWidth;
              var zoomRatioY = midY / canvas.clientHeight;

              // calculate the amounts zoomed from each edge of the screen
              const unitsZoomedX = trueWidth() * scaleAmount;
              const unitsZoomedY = trueHeight() * scaleAmount;

              const unitsAddLeft = unitsZoomedX * zoomRatioX;
              const unitsAddTop = unitsZoomedY * zoomRatioY;

              offsetX += unitsAddLeft;
              offsetY += unitsAddTop;

              redrawCanvas();
            }
            prevTouches[0] = event.touches[0];
            prevTouches[1] = event.touches[1];
          }

          function onTouchEnd(event) {
            singleTouch = false;
            doubleTouch = false;
          }

        }



      }


    </script>





    <script>
      // disable right clicking
      document.oncontextmenu = function () {
        return false;
      }

      class State {

      }

      const inputProperties = new InputProperties();

      const clipboardIntegration = new ClipboardIntegration();
      const fileIntegration = new FileIntegration(clipboardIntegration);


      const infiniteCanvas = new InfiniteCanvas(canvas, inputProperties);
      clipboardIntegration.rx_mixedPaste.subscribe({
        next: (icObj) => {
          logger.log("rx_mixedPaste, next:", icObj);
          infiniteCanvas.addPastedIcObject(icObj);
        },
        error: (e) => {
          logger.log("rx_mixedPaste, error:", e);
        }
      });

      //connect with HUD
      infiniteCanvas.isRecording_observable.subscribe({
        next: (isRecording) => {
          logger.log("isRecording", isRecording);
          ic_HUD.setIsRecording(isRecording);
        },
      });



      // const canvas = document.getElementById("myCanvas");
      const fabricIntegration = new FabricIntegration(infiniteCanvas, inputProperties);
      fabricIntegration.clipboardIntegration = clipboardIntegration;

      //debug {
      // console.log("fabricIntegration.fabricCanvas", fabricIntegration.fabricCanvas);
      // infiniteCanvas.canvasContainer = fabricIntegration.fabricCanvas.contextTop.canvas.parentElement;
      //}

      infiniteCanvas.redrawCanvasListeners.push((redrawOccasion) => {
        fabricIntegration.redrawCanvas(redrawOccasion);
      });
      // infiniteCanvas.didAddObjectListeners.push((icObj) => {
      //   const icObj_free = icObj.r_free();
      //   fabricIntegration.addFabricObjectWithIcObj(icObj_free);
      // });
      infiniteCanvas.didAddRepresentationListeners.push((icObj_represented, icObj_representation) => {
        console.log("infiniteCanvas.didAddRepresentationListeners", icObj_represented, icObj_representation);

        const rep_official = icObj_represented.r_official();
        const rep_free = icObj_represented.r_free();

        //debug
        if (icObj_representation == rep_free) {

          if (rep_official.type == "sparkle") {

            // const homeScale_sparkle = {
            //   X: rep_official.homeScale.X,
            //   Y: rep_official.homeScale.Y,
            // };
            const home_properties = {
              // homeScale: {
              X: rep_official.homeScale.X,
              Y: rep_official.homeScale.Y,
              // },
              orientation: rep_official.orientation,
            };



            var animation = null;

            // var homeScale_animated = {
            //   X: rep_official.homeScale.X,
            //   Y: rep_official.homeScale.Y,
            // };
            var animated_properties = {
              X: home_properties.X,
              Y: home_properties.Y,
              orientation: home_properties.orientation,
            };

            const duration_one_way = 777;
            var moment = 0;

            var timestamp_animStart = -1;

            var from = null;
            var to = null;


            function animationUpdateFunc() {
              // rep_free.homeScale = homeScale_animated;
              rep_free.homeScale = {
                X: animated_properties.X,
                Y: animated_properties.Y,
              };
              rep_free.orientation = animated_properties.orientation;
            }

            function createNewSparkleAnimation(old1, current, old2, new2, new1) {
              console.log("createNewSparkleAnimation");

              const duration_complement = duration_one_way - moment;

              // anime.set(homeScale_animated, current);
              anime.set(animated_properties, current);


              const animation_seam = anime({
                // targets: homeScale_animated,
                targets: animated_properties,
                X: new2.X,
                Y: new2.Y,
                orientation: new2.orientation,

                duration: duration_complement,
                easing: 'easeOutSine',

                update: animationUpdateFunc,

                changeBegin: () => {
                  from = new1;
                  to = new2;

                  timestamp_animStart = Date.now() - moment;
                },

                complete: (anim) => {
                  console.log("@@@ completed");

                  //SHU: un peu sale mais comment faire autrement
                  animation = createAnimation_endless();
                  // setTimeout(() => {
                  //   animation = createAnimation_endless();
                  // }, 0);
                },

                autoplay: false,
              });

              function createAnimation_endless() {

                var isForward = true;

                const animation_endless = anime({
                  // targets: homeScale_animated,
                  // X: new1.X,
                  // Y: new1.Y,
                  targets: animated_properties,
                  X: new1.X,
                  Y: new1.Y,
                  orientation: new1.orientation,

                  direction: 'alternate',
                  easing: 'easeInOutSine',
                  loop: true,


                  autoplay: true,


                  duration: duration_one_way,
                  update: (anim) => {
                    animationUpdateFunc();
                  },

                  loopBegin: function (anim) {

                    if (isForward) {
                      from = new2;
                      to = new1;
                    } else {
                      from = new1;
                      to = new2;
                    }

                    timestamp_animStart = Date.now();
                    moment = 0;

                    isForward = !isForward;
                  },
                  // loopComplete: function(anim) {
                  //
                  // },

                });

                return animation_endless;
              }

              return animation_seam;
            }

            function startAnimation() {
              // animation = createNewSparkleAnimationTimeline(homeScale_sparkle, homeScale_sparkle, infiniteCanvas.scale, infiniteCanvas.scale, homeScale_sparkle);
              // animation = createNewSparkleAnimation(homeScale_sparkle, homeScale_sparkle, infiniteCanvas.scale, infiniteCanvas.scale, homeScale_sparkle);

              const from = {
                X: home_properties.X,
                Y: home_properties.Y,
                orientation: home_properties.orientation,
              };
              const to = {
                X: infiniteCanvas.scale.X,
                Y: infiniteCanvas.scale.Y,
                // orientation: home_properties.orientation + 180,
                orientation: home_properties.orientation + 180 * (home_properties.X / infiniteCanvas.scale.X),
              };
              animation = createNewSparkleAnimation(from, from, to, to, from);

              rep_free.animation = animation;

              animation.play();
              // timestamp_animStart = Date.now() - moment;

            }

            function updateAnimationSeamlessly() {
              console.log("updateAnimationSeamlessly");

              if (animation != null) {
                // console.log("animation before:", animation);

                animation.pause();
                // const homeScale_animated__when_paused = {
                //   X: homeScale_animated.X,
                //   Y: homeScale_animated.Y,
                // };
                // console.log("homeScale_animated__when_paused.X  ", homeScale_animated__when_paused.X);
                const animated_properties_when_paused = {
                  X: animated_properties.X,
                  Y: animated_properties.Y,
                  orientation: animated_properties.orientation,
                };
                console.log("animated_properties_when_paused.X  ", animated_properties_when_paused.X);

                const timestamp_animStop = Date.now();

                moment = (timestamp_animStop - timestamp_animStart);
                console.log("@@@ timestamp_animStart", timestamp_animStart);
                console.log("@@@ timestamp_animStop ", timestamp_animStop);

                console.log("@@@ moment", moment);


                animation.reset();
                animation = null;

                // anime.set(homeScale_animated, homeScale_animated__when_paused);
                // homeScale_animated = homeScale_animated__when_paused;
                anime.set(animated_properties, animated_properties_when_paused);
                animated_properties = animated_properties_when_paused;

                const old1 = from;
                const old2 = to;
                var new1;
                var new2;

                const A = home_properties;
                const B = {
                  X: infiniteCanvas.scale.X,
                  Y: infiniteCanvas.scale.Y,
                  // orientation: home_properties.orientation + 180,
                  orientation: home_properties.orientation + 3.6 * (home_properties.X / infiniteCanvas.scale.X),
                };

                if (old1 == home_properties) {
                  new1 = A;
                  new2 = B;
                } else {
                  new1 = B;
                  new2 = A;
                }

                // animation = createNewSparkleAnimation(old1, homeScale_animated__when_paused, old2, new2, new1);
                animation = createNewSparkleAnimation(old1, animated_properties_when_paused, old2, new2, new1);
                rep_free.animation = animation;

                animation.play();
                // timestamp_animStart = Date.now() - moment;

                // console.log("animation after:", animation);
              }
            }




            startAnimation();

            //listen to infiniteCanvas.scale
            infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
              // console.log("infiniteCanvas.scale.X", infiniteCanvas.scale.X);
              // console.log("infiniteCanvas.scale.Y", infiniteCanvas.scale.Y);

              const isPovTooCloseToSparkle = (home_properties.X < infiniteCanvas.scale.X);

              if (isPovTooCloseToSparkle) {
                if (animation != null) {
                  animation.reset();
                  animation = null;
                }
              } else {
                if (animation != null) {
                  updateAnimationSeamlessly();
                } else {
                  startAnimation();
                }
              }

            });


          }
        }

        fabricIntegration.addFabricObjectWithIcObj(icObj_representation);
      });

      infiniteCanvas.didAddPureObjectListeners.push((icObj) => {
        fabricIntegration.addFabricObjectWithPureIcObj(icObj);
      });

      infiniteCanvas.onAddRepresented((represented) => {
        console.log("onAddRepresented", represented);

        // if(represented.r_official().type == "composite") {
        //   // console.log("---here---");
        //
        //   const icComposite = represented.r_official();
        // }

        // const isEngined = represented.r_official().eType != null;
        const isEngined = represented.r_official().dict_engine != null;
        if (isEngined) {
          logger.log("onAddRepresented", "/", "isEngined");

          // const icEngined = represented.r_official();
          const icEngined = represented.r_free();
          // const icEngined = represented.r_engined();     //SHU: maybe one day...

          const arr_engine__entry__sorted = Object.entries(icEngined.dict_engine).sort(([eType1, eMiniDict1], [eType2, eMiniDict2]) => {
            return eMiniDict1.index_start > eMiniDict2.index_start;
          });

          arr_engine__entry__sorted.forEach(([eType, eMiniDict]) => {
            logger.log("initialize", "eType", eType, eMiniDict.index_start);


            //initialize (==hydrate)
            const scopeObj = icEngined.getScopeObj(icEngined);
            scopeObj.infiniteCanvas = infiniteCanvas;

            eMiniDict.engine.initialize(scopeObj);
            console.log("icEngined.dict_engine[eType].engine.awoken.scopeObj.infiniteCanvas, after ", eMiniDict.engine.awoken.scopeObj.infiniteCanvas);


            //start
            // icEngined.engine.start();
            // icEngined.engine.start(scopeObj);
            eMiniDict.engine.awoken.start();

          });

        }

      });

      // infiniteCanvas.requestSyncWithIcObjListeners.push((icObj) => {
      //   fabricIntegration.syncWithIcObj(icObj);
      // });

      // const touch2 = new Touch2(fabricIntegration);
      // infiniteCanvas.touch2 = touch2;

      Touch2Singleton.initializeInstance(fabricIntegration);


      // const clipboardIntegration = new ClipboardIntegration(fileIntegration, fabricIntegration);

      const keyboardIntegration = new KeyboardIntegration(infiniteCanvas, inputProperties, fileIntegration, fabricIntegration);

      const canvasContainer = document.getElementsByClassName("canvas-container")[0];
      const mouseIntegration = new MouseIntegration(canvasContainer, infiniteCanvas, inputProperties, keyboardIntegration);
      fabricIntegration.mouseIntegration = mouseIntegration;

      // const touchIntegration    = new TouchIntegration(canvasContainer, infiniteCanvas, inputProperties);


    </script>


































    <script>

      class Xylophone {

        constructor(infiniteCanvas, base = 10, exponent_min = -5, exponent_max = +5) {
          this.infiniteCanvas = infiniteCanvas;

          this.base = base;
          this.exponent_min = exponent_min;
          this.exponent_max = exponent_max;

          this.xyloZones = {};

          this.activeNumber = 0;
          this.activeNumberString = "0";  //to avoid decimal <-> binary conversion issues  (0.7 != 0.7000000000000001)

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xylophone = this;
          const infiniteCanvas = this.infiniteCanvas;

          const base = this.base;
          const exponent_min = this.exponent_min;
          const exponent_max = this.exponent_max;

          const arr_exponent = [...Array(exponent_max - exponent_min + 1).keys()].map(i => (exponent_min + i));

          arr_exponent.forEach((exponent, i) => {

            const xyloZone = new XyloZone(infiniteCanvas, base, exponent);

            this.xyloZones[xyloZone.id] = xyloZone;
            xyloZone.didUpdateListeners.push((xyloZone) => {
              this.updateActiveNumber();
            });
          });

        }

        updateActiveNumber() {
          this.activeNumber = Object.values(this.xyloZones)
            .map(xyloZone => xyloZone.activeNumber)
            // .reduce((acc, x) => (acc + x), 0);
            .reduce((acc, x) => (acc.plus(x)), new Decimal(0));
          // console.log("xylophone::updateActiveNumber", this.activeNumber;
          console.log("xylophone::updateActiveNumber", this.activeNumber.toFixed());

          this.didUpdate();
        }

        didUpdate() {
          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }


        getArr_exponent() {
          return Object.values(this.xyloZones).map(xyloZone => xyloZone.exponent);
        }

        getExponent_min() {
          return Math.min(...this.getArr_exponent());
        }

        getExponent_max() {
          return Math.max(...this.getArr_exponent());
        }

      }

      class XyloZone {

        constructor(infiniteCanvas, base, exponent) {
          this.infiniteCanvas = infiniteCanvas;

          const exponentString = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
          const numberString = "" + base + "^" + exponentString;

          this.id = numberString;

          this.base = base;
          this.exponent = exponent;

          this.xylophoneTowers = {};

          this.icObjects = {};

          // this.activeNumber       = 0;
          this.activeNumber = new Decimal(0);
          this.activeNumberString = "" + this.activeNumber;

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xyloZone = this;

          const infiniteCanvas = this.infiniteCanvas;

          function activeCfgForTower(xylophoneTower) {
            var outCfg;

            outCfg = {
              fill: xylophoneTower.color,
              opacity: 1.0,
            };

            return outCfg;
          }

          function inactiveCfgForTower(xylophoneTower) {
            var outCfg;

            if (xylophoneTower.mantissa == 0) {
              outCfg = {
                fill: '',
                opacity: 1.0,
              };
            } else {
              outCfg = {
                fill: xylophoneTower.color,
                opacity: 0.3,
              };
            }

            return outCfg;
          }

          function createCanvasToggleRectForXylophoneTower(xylophoneTower) {
            const trueRect = xylophoneTower.trueRect;

            const activeCfg = activeCfgForTower(xylophoneTower);
            const inactiveCfg = inactiveCfgForTower(xylophoneTower);

            const isActive = false;

            const icToggleRect = infiniteCanvas.createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive);
            icToggleRect.canBeMoved = false;
            icToggleRect.canBeRotated = false;
            icToggleRect.canBeResized = false;
            icToggleRect.canBeSelected = true;

            return icToggleRect;
          }


          const exponent = this.exponent;
          const base = this.base;

          //zero tower
          {
            const xylophoneTower = new XylophoneTower(0, exponent, base);
            xyloZone.xylophoneTowers[xylophoneTower.mantissa] = xylophoneTower;
            xylophoneTower.didUpdateListeners.push((xylophoneTower, source) => {

              switch (source) {
                // case "view":
                //   //no sync needed
                //   xyloZone.updateWithXylophoneTowerViewUpdate(xylophoneTower);
                //   break;
                case "model":
                  //sync needed
                  xylophoneTower.icObj.isActive = xylophoneTower.isActive;
                  infiniteCanvas.requestViewUpdateForIcObj(xylophoneTower.icObj);
                  break;
              }

            });


            const icToggleRect = createCanvasToggleRectForXylophoneTower(xylophoneTower);
            icToggleRect.canBeSelected = false;

            xylophoneTower.icObj = icToggleRect;

            infiniteCanvas.addIcObject(icToggleRect);

            xylophoneTower.updateIsActive(true, "model");
          }

          //other towers
          [...Array(base - 1).keys()].forEach((item, j) => {
            const mantissa = j + 1;

            const xylophoneTower = new XylophoneTower(mantissa, exponent, base);
            xyloZone.xylophoneTowers[xylophoneTower.mantissa] = xylophoneTower;
            xylophoneTower.didUpdateListeners.push((xylophoneTower, source) => {

              switch (source) {
                case "view":
                  //no sync needed
                  xyloZone.updateWithXylophoneTowerViewUpdate(xylophoneTower);
                  break;
                case "model":
                  //sync needed
                  xylophoneTower.icObj.isActive = xylophoneTower.isActive;
                  infiniteCanvas.requestViewUpdateForIcObj(xylophoneTower.icObj);
                  break;
              }

            });

            const icToggleRect = createCanvasToggleRectForXylophoneTower(xylophoneTower);
            xylophoneTower.icObj = icToggleRect;

            infiniteCanvas.addIcObject(icToggleRect);

            icToggleRect.didUpdateListeners.push((icToggleRect) => {
              xylophoneTower.updateIsActive(icToggleRect.isActive, "view");
            });
          });




          //zone-dedicated objects

          // //number text
          // {
          //   const trueRect = this.xylophoneTowers[0].trueRect;
          //
          //   const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "lol");
          //   icText.canBeMoved    = false;
          //   icText.canBeRotated  = false;
          //   icText.canBeResized  = false;
          //   icText.canBeSelected = false;
          //
          //   const scaleFactor = (this.base ** this.exponent);
          //   console.log("number text, scaleFactor", scaleFactor);
          //
          //   icText.homeScale = {
          //     X: icText.homeScale.X / scaleFactor     * 50,
          //     Y: icText.homeScale.Y / scaleFactor     * 50,
          //   };
          //
          //   icText.fill = "yellow";
          //
          //   this.icObjects["numberDisplay"] = icText;
          //
          //   infiniteCanvas.addIcObject(icText);
          //
          //
          //   this.didUpdateListeners.push((xyloZone) => {
          //     const activeNumberString = xyloZone.activeNumber.toFixed();
          //     icText.text = activeNumberString;
          //     // infiniteCanvas.requestViewUpdateForIcObj(icText); //SHU666
          //   });
          // }


        }

        setActiveMantissa(mantissa) {
          const chosenXylophoneTower = this.xylophoneTowers[mantissa];
          chosenXylophoneTower.updateIsActive(true, "model");

          const towers_to_deactivate = Object.values(this.xylophoneTowers).filter(xylophoneTower => xylophoneTower != chosenXylophoneTower);
          towers_to_deactivate.forEach((xylophoneTower, i) => {
            xylophoneTower.updateIsActive(false, "model");
          });

          this.updateActiveNumber();

          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }

        updateWithXylophoneTowerViewUpdate(chosenXylophoneTower) {
          logger.log("updateWithXylophoneTowerViewUpdate", chosenXylophoneTower.mantissa);

          //deactivate all others
          const towers_to_deactivate = Object.values(this.xylophoneTowers).filter(xylophoneTower => xylophoneTower != chosenXylophoneTower);
          towers_to_deactivate.forEach((xylophoneTower, i) => {
            xylophoneTower.updateIsActive(false, "model");
          });

          if (chosenXylophoneTower.isActive) {

          } else {
            const zeroXylophoneTower = this.xylophoneTowers[0];
            zeroXylophoneTower.updateIsActive(true, "model");
          }

          this.updateActiveNumber();
        }

        updateActiveNumber() {
          this.activeNumber = Object.values(this.xylophoneTowers)
            .filter(xylophoneTower => xylophoneTower.isActive)
            .map(xylophoneTower => xylophoneTower.number)
            // .reduce((acc, x) => (acc + x), 0);
            .reduce((acc, x) => (acc.plus(x)), new Decimal(0));
          // console.log("xyloZone::updateActiveNumber", this.activeNumber);
          console.log("xyloZone::updateActiveNumber", this.activeNumber.toFixed());

          this.didUpdate();
        }

        didUpdate() {
          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }

        getTrueRect() {
          const zeroXylophoneTower = this.xylophoneTowers[0];
          return zeroXylophoneTower.trueRect;
        }

      }

      class XylophoneTower {

        constructor(mantissa, exponent, base) {
          const exponentString = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
          const numberString = "" + mantissa + " x " + base + "^" + exponentString;

          this.id = numberString;

          this.mantissa = mantissa;
          this.base = base;
          this.exponent = exponent;

          this.xyloBrickNumber = new XyloBrickNumber(mantissa, exponent, base);

          this.unreliable_number = mantissa * (base ** exponent);
          this.number = null;
          if (base == 10) {
            //'sharp' number (==arbitrary-precision number)
            const decimalNumberFormatString = "" + mantissa + "e" + exponent;
            this.decimal_decimalNumber = new Decimal(decimalNumberFormatString);
            // console.log("this.decimal_decimalNumber", this.decimal_decimalNumber);
            console.log("this.decimal_decimalNumber.toFixed()", this.decimal_decimalNumber.toFixed());


            this.number = this.decimal_decimalNumber;
          } else {
            //SHU TODO: 'sharp management' when base != 10 ...
            //this seems to be linked to the halting problem
            this.number = this.unreliable_number;
          }

          this.successor = (mantissa + 1) * (base ** exponent);
          // this.successorXyloBrickNumber = ;

          this.trueRect = XylophoneTower.trueRectForTower(this);
          this.color = XylophoneTower.colorForMantissa(mantissa);

          this.isActive = false;

          this.didUpdateListeners = [];
        }

        updateIsActive(isActive, source) {
          this.isActive = isActive;

          this.didUpdateListeners.forEach((listener, i) => {
            listener(this, source);
          });

        }

        static trueRectForTower(xylophoneTower) {
          var outTrueRect;

          // const BL = {
          //   x: xylophoneTower.number,
          //   y: 0,
          // };
          // const TR = {
          //   x: xylophoneTower.successor,
          //   y: xylophoneTower.number,
          // }

          if (xylophoneTower.mantissa == 0) {
            const mantissa1_number = (xylophoneTower.base ** xylophoneTower.exponent);
            const nextPower_number = (xylophoneTower.base ** (xylophoneTower.exponent + 1));
            const mantissaN_number = nextPower_number - mantissa1_number;

            outTrueRect = {
              x: mantissa1_number,
              width: nextPower_number - mantissa1_number,

              // y: -nextPower_number,
              // height: nextPower_number,

              y: - mantissaN_number,
              height: mantissaN_number,
            };
          } else {
            outTrueRect = {
              x: xylophoneTower.unreliable_number,
              y: -xylophoneTower.unreliable_number,
              width: (xylophoneTower.base ** xylophoneTower.exponent),
              height: xylophoneTower.unreliable_number,
            };
          }

          return outTrueRect;
        }

        static colorForMantissa(mantissa) {
          var outColor = null;

          switch (mantissa) {
            case 0:
              outColor = "#000000";
              break;

            case 1:
              outColor = "#FF7F0E";
              break;
            case 2:
              outColor = "#2CA02C";
              break;
            case 3:
              outColor = "#D62728";
              break;
            case 4:
              outColor = "#9467BD";
              break;
            case 5:
              outColor = "#8C564B";
              break;
            case 6:
              outColor = "#E377C2";
              break;
            case 7:
              outColor = "#7F7F7F";
              break;
            case 8:
              outColor = "#BCBD22";
              break;
            case 9:
              outColor = "#17BECF";
              break;

            //SHU TODO: colors or patterns for those:
            case 10:  //A
              outColor = "#000000";
              break;
            case 11:  //B
              outColor = "#000000";
              break;
            case 12:  //C
              outColor = "#000000";
              break;
            case 13:  //D
              outColor = "#000000";
              break;
            case 14:  //E
              outColor = "#000000";
              break;
            case 15:  //F
              outColor = "#000000";
              break;

            default:
              throw new Error("unsupported mantissa: " + mantissa);
          }

          return outColor;
        }


      }


      class XyloZonePerception {
        // class XyloZoneDecoration {

        constructor(infiniteCanvas, xyloZone) {
          this.infiniteCanvas = infiniteCanvas;
          this.xyloZone = xyloZone;

          this.trueRect = null;

          this.icObjects = {};

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xyloZonePerception = this;

          const infiniteCanvas = this.infiniteCanvas;

          const xyloZone_trueRect = xyloZonePerception.xyloZone.getTrueRect();

          //listen to xyloZone
          xyloZonePerception.xyloZone.didUpdateListeners.push((xyloZone) => {

          });

        }

        createInfiniteCanvasObjects() {

          function createCanvasToggleRectForXylophonePerception(xylophoneTower) {
            const trueRect = xylophoneTower.trueRect;

            const activeCfg = activeCfgForTower(xylophoneTower);
            const inactiveCfg = inactiveCfgForTower(xylophoneTower);

            const isActive = false;

            const icToggleRect = infiniteCanvas.createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive);
            icToggleRect.canBeMoved = false;
            icToggleRect.canBeRotated = false;
            icToggleRect.canBeResized = false;
            icToggleRect.canBeSelected = true;

            return icToggleRect;
          }

        }

        update(xyloZone) {

        }

      }


      class NumberUtils {

        static randomXylophoneNumber(base, exponent_min, exponent_max) {

          const arr_exponent = [...Array(exponent_max - exponent_min + 1).keys()].map(i => (exponent_min + i));

          const arr_xyloBrickNumber = arr_exponent.map(exponent => {
            const mantissa = Math.floor(Math.random() * 10); // returns a random integer from 0 to 9
            const xyloBrickNumber = new XyloBrickNumber(mantissa, base, exponent);
            return xyloBrickNumber;
          });

          const xylophoneNumber = new XylophoneNumber(arr_xyloBrickNumber);

          return xylophoneNumber;
        }

      }

      class XyloBrickNumber {

        constructor(mantissa, base, exponent) {
          this.mantissa = mantissa;
          this.base = base;
          this.exponent = exponent;

          this.unreliable_number = mantissa * (base ** exponent);

          // const exponentString  = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
          // const sciNumberString = "" + mantissa + " x " + base + "^" + exponentString;
          // this.sciNumberString  = numberString;
          //
          // this.decimalNumberString = DecimalBrickNumber.decimalNumberString(mantissa, base, exponent);
        }

        toDecimalNumber() {
          var outDecimal;

          if (this.base == 10) {
            //'sharp' number (==arbitrary-precision number)
            const decimalNumberFormatString = "" + this.mantissa + "e" + this.exponent;
            const decimalNumber = new Decimal(decimalNumberFormatString);

            outDecimal = decimalNumber;
          } else {
            //SHU TODO: 'sharp management' when base != 10 ...
            //this seems to be linked to the halting problem
            throw new Error("unsupported for now");
          }

          return outDecimal;
        }

        // static decimalNumberString(mantissa, base, exponent) {
        //
        // }

      }

      class XylophoneNumber {

        constructor(arr_xyloBrickNumber) {

          //check not empty
          const isEmpty = (arr_xyloBrickNumber.length == 0);

          if (isEmpty) {
            throw new Error("arr_xyloBrickNumber.length == 0");
          }

          //check same base for all
          const base = arr_xyloBrickNumber.find(e => true).base;
          const isSameBase = arr_xyloBrickNumber.every(xyloBrickNumber => (xyloBrickNumber.base == base));

          if (!isSameBase) {
            console.log("arr_xyloBrickNumber", arr_xyloBrickNumber);
            throw new Error("xyloBrickNumbers have different bases");
          }

          this.base = base;
          this.xyloBrickNumbers = arr_xyloBrickNumber.reduce((acc, xyloBrickNumber) => {
            acc[xyloBrickNumber.exponent] = xyloBrickNumber;
            // acc[xyloBrickNumber.exponent] = xyloBrickNumber.mantissa;
            return acc;
          }, {});

          this.unreliable_number = arr_xyloBrickNumber.reduce((acc, x) => (acc + x.unreliable_number), 0);
        }

        toDecimalNumber() {
          return Object.values(this.xyloBrickNumbers).reduce((acc, x) => {
            const xyloBrickDecimal = x.toDecimalNumber();
            return acc.plus(xyloBrickDecimal);
          }, new Decimal(0));
        }

        // filledToUnit() {
        //
        //   function fillNegative() {
        //     const
        //
        //   }
        //
        //   function fillPositive() {
        //
        //   }
        //
        //
        // }

        // toString() {
        //   const str = Object.keys(this.xyloBrickNumbers).reduce((acc, exponent) => {
        //
        //   }, "");
        //   return str;
        // }

        // isEqual(xylophoneNumber2) {
        //   const xylophoneNumber1 = this;
        //   const areEqual = XylophoneNumber.compare(xylophoneNumber1, xylophoneNumber2) == 0;
        //   return areEqual;
        // }
        //
        // static compare(xylophoneNumber1, xylophoneNumber2) {
        //   var outNumber;
        //
        //   const arr_keys_1 = Object.keys(xylophoneNumber1.xyloBrickNumbers);
        //
        //
        //   return outNumber;
        // }

      }
    </script>
    <!-- <script>
      const xylophone = new Xylophone(infiniteCanvas, 10);
      // const xylophone = null;
      // const xylophone = new Xylophone(infiniteCanvas, 2);    //always a bit confusing

    </script> -->

    <!-- debug -->
    <script>
      class XyloGameHUD {
        constructor(eltsDict) {
          this.eltsDict = eltsDict;
        }

        setCurrentNumberString(numberString) {
          this.eltsDict["currentNumber"].innerHTML = numberString;
        }
        setTargetNumberString(numberString) {
          this.eltsDict["targetNumber"].innerHTML = numberString;
        }
        setCompleted(completed) {
          this.eltsDict["completed"].innerHTML = completed ? "Well done !" : "";
        }
      }
    </script>

    <!-- <div id="xyloGame_container" style="position:absolute; left:0; bottom: 0; font-size: 60px; pointer-events: none;">
      <div>
        <div style="display: inline-block;">current number: </div>
        <div style="display: inline-block;" id="xyloGame_currentNumber"></div>
      </div>
      <div>
        <div style="display: inline-block;">target number: </div>
        <div style="display: inline-block;" id="xyloGame_targetNumber"></div>
      </div>
      <div>
        <div style="display: inline-block;"></div>
        <div style="display: inline-block;" id="xyloGame_completed"></div>
      </div>
    </div>
    <script>
      const xyloGameHUD_eltsDict = {
        currentNumber:  document.getElementById("xyloGame_currentNumber"),
        targetNumber:   document.getElementById("xyloGame_targetNumber"),
        completed:      document.getElementById("xyloGame_completed"),
      };
      const xyloGameHUD = new XyloGameHUD(xyloGameHUD_eltsDict);
    </script> -->


    <script>

      class XylophoneGame1_xyloWrite {

        constructor(xylophone, xyloGameHUD) {
          this.xylophone = xylophone;
          this.xyloGameHUD = xyloGameHUD;

          this.targetXylophoneNumber = null;
          this.targetNumber = null;

          this.initialize();
        }

        initialize() {
          const xylophone = this.xylophone;
          const xyloGameHUD = this.xyloGameHUD;

          const base = xylophone.base;
          const exponent_min = xylophone.getExponent_min();
          const exponent_max = xylophone.getExponent_max();
          const targetXylophoneNumber = NumberUtils.randomXylophoneNumber(base, exponent_min, exponent_max);
          // console.log("targetXylophoneNumber", targetXylophoneNumber.toDecimalNumber().toFixed());

          this.targetXylophoneNumber = targetXylophoneNumber;
          this.targetNumber = targetXylophoneNumber.toDecimalNumber();

          const targetNumberString = this.targetNumber.toFixed();
          xyloGameHUD.setTargetNumberString(targetNumberString);

          const xylophoneNumberString = xylophone.activeNumber.toFixed();
          xyloGameHUD.setCurrentNumberString(xylophoneNumberString);


          xylophone.didUpdateListeners.push((xylophone) => {
            console.log("XylophoneGame1_xyloWrite", "xylophone did update", xylophone);

            // const xylophoneNumberString = xylophone.getActiveNumberString();
            const xylophoneNumberString = xylophone.activeNumber.toFixed();
            console.log("xylophoneNumberString", xylophoneNumberString);
            xyloGameHUD.setCurrentNumberString(xylophoneNumberString);

            const numbersAreEqual = (targetNumberString == xylophoneNumberString);
            xyloGameHUD.setCompleted(numbersAreEqual);
          });
        }

      }

      class XylophoneGame2_xyloRead {

        constructor(infiniteCanvas) {

        }

      }
    </script>
    <!-- <script>
      //SHU: comment //shuxylo line for xylophone to work

      const xylophone = new Xylophone(infiniteCanvas, 10);
      // const xylophone = null;
      // const xylophone = new Xylophone(infiniteCanvas, 2);    //always a bit confusing

      if(xylophone != null) {
        const xyloWrite = new XylophoneGame1_xyloWrite(xylophone, xyloGameHUD);
      }
    </script> -->







    <script>
      class SandBox_doubleObjects {
        constructor(infiniteCanvas) {
          this.infiniteCanvas = infiniteCanvas;

          this.doubleObjects = {};

          this.initialize();
        }

        initialize() {
          const infiniteCanvas = this.infiniteCanvas;

          this.create_doubleObjects_p(infiniteCanvas)
            .then((arr_doubleObject) => {

              const dict_doubleObject = Object.fromEntries(arr_doubleObject.map(dO => [dO.id, dO]));
              Object.assign(this.doubleObjects, dict_doubleObject);

              arr_doubleObject.forEach((doubleObject, i) => {
                this.materialize_doubleObject(doubleObject, infiniteCanvas);
              });

            });

        }

        create_doubleObjects_p(infiniteCanvas) {
          var out_p;

          // //double object #1
          // {
          //   const dO_id        = "dO#1"
          //   const dO_homeScale = {
          //     X:2.0,
          //     Y:2.0,
          //   };
          //
          //   const icRect_front = infiniteCanvas.createIcRect_withLTWH(0, 0, 100, 100);
          //   icRect_front.fill  = "red";
          //   icRect_front.homeScale = dO_homeScale;
          //
          //   const icRect_back = infiniteCanvas.createIcRect_withLTWH(0, 0, 100, 100);
          //   icRect_back.fill = "blue";
          //   icRect_back.homeScale = dO_homeScale;
          //
          //   const doubleObject = new DoubleObject(dO_id, icRect_front, icRect_back);
          //
          //   this.doubleObjects[doubleObject.id] = doubleObject;
          // }

          //double object #2
          const trueRect__dO2 = {
            x: 500,
            y: 500,
            width: 1,
            height: 1,
          };
          const id__dO2 = "dO#2";
          const homeScale__dO2 = {
            X: 2.0,
            Y: 2.0,
          };

          const imgPath__front = "img/double/window_closed.png";
          const imgPath__back = "img/double/window_open.png";

          const do2_p = this.createDoubleObject__imageBased_p(trueRect__dO2, homeScale__dO2, id__dO2, imgPath__front, imgPath__back);

          const arr_p = [do2_p];

          out_p = Promise.all(arr_p);

          return out_p;
        }

        createDoubleObject__imageBased_p(trueRect, homeScale_dO, id_dO, imgPath__front, imgPath__back) {
          var out_p;

          const icObj__front_p = FileIntegration.imageFromImgSrc_p(imgPath__front)
            .then((img__front) => {
              const icObj__front = infiniteCanvas.createIcImage(trueRect.x, trueRect.y, img__front);
              // icObj__front.homeScale = homeScale_dO;
              return icObj__front;
            });
          const icObj__back_p = FileIntegration.imageFromImgSrc_p(imgPath__back)
            .then((img__back) => {
              const icObj__back = infiniteCanvas.createIcImage(trueRect.x, trueRect.y, img__back);
              // img__back.homeScale = homeScale_dO;
              return icObj__back;
            });

          const arr_p = [icObj__front_p, icObj__back_p];
          // const arr_p = [icObj__back_p, icObj__front_p];

          out_p = Promise.all(arr_p)
            .then((arr_icObj) => {
              const icObj__front = arr_icObj[0];
              const icObj__back = arr_icObj[1];
              const doubleObject = new DoubleObject(id_dO, icObj__front, icObj__back);
              return doubleObject;
            })

          return out_p;
        }

        materialize_doubleObject(doubleObject, infiniteCanvas) {
          const icObj_active = doubleObject.getActiveIcObject();
          infiniteCanvas.addIcObject(icObj_active);

          infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
            doubleObject.updateWithObservationScale(infiniteCanvas.scale);
          });

          doubleObject.didUpdateListeners.push((icObj_old, icObj_new) => {
            // infiniteCanvas.requestViewUpdateForIcObj(icObj);

            // logger.log("icObj_old", icObj_old);
            // logger.log("icObj_new", icObj_new);

            // infiniteCanvas.removeIcObject(icObj_old);
            // infiniteCanvas.addIcObject(icObj_new);

            const rep_free__old = infiniteCanvas.getRepresented(icObj_old.id).r_free();
            rep_free__old.im_dying_now = true;

            infiniteCanvas.addIcObject(icObj_new);
          });

        }

      }

      class DoubleObject {

        constructor(id, icObj_front, icObj_back) {
          this.id = id;

          this.icObj_front = icObj_front;
          this.icObj_back = icObj_back;

          logger.log("icObj_front", icObj_front);

          const factor_scaleToggle = 0.90;
          this.scale_toggle = {
            X: icObj_front.homeScale.X * factor_scaleToggle,
            Y: icObj_front.homeScale.Y * factor_scaleToggle,
          };

          // this.icObj_active = null;
          this.icObj_active = icObj_front;

          this.didUpdateListeners = [];
        }

        getActiveIcObject() {
          return this.icObj_active;
        }

        updateWithObservationScale(scale_obs) {
          logger.log("updateWithObservationScale", scale_obs);

          const icObj_active = this.getIcObjectForObservationScale(scale_obs);

          this.setActiveIcObject(icObj_active);
        }

        getIcObjectForObservationScale(scale_obs) {
          var outIcObj;

          // logger.log("scale_obs.X",    scale_obs.X);
          // logger.log("this.scale_toggle.X", this.scale_toggle.X);

          const isFar = scale_obs.X < this.scale_toggle.X && scale_obs.Y < this.scale_toggle.Y;
          // logger.log("isFar", isFar);

          if (isFar) {
            outIcObj = this.icObj_front;
          } else {
            outIcObj = this.icObj_back;
          }

          return outIcObj;
        }

        setActiveIcObject(icObj_new) {

          const icObj_old = this.icObj_active;

          if (icObj_new != icObj_old) {
            this.icObj_active = icObj_new;

            this.didUpdateListeners.forEach((listener, i) => {
              listener(icObj_old, icObj_new);
            });
          }

        }

        // didUpdate() {
        //
        // }



      }

      class ManyAnObject {

      }

        // const sandBox_doubleObjects = new SandBox_doubleObjects(infiniteCanvas);

    </script>


    <script>
      class SandBox_sparkles {
        constructor(infiniteCanvas) {
          this.infiniteCanvas = infiniteCanvas;

          this.objects = {};

          this.initialize();
        }

        initialize() {
          const infiniteCanvas = this.infiniteCanvas;

          this.initialize_objects(infiniteCanvas);

          const arr_objects = Object.values(this.objects);
          arr_objects.forEach((object, i) => {
            this.materialize_object(object, infiniteCanvas);
          });

        }

        initialize_objects(infiniteCanvas) {

          //sparkle #1
          {
            const dO_id = "dO#1"
            const dO_homeScale = {
              X: 20.0,
              Y: 20.0,
            };

            const img_sparkle = "lol";
            const icObj = infiniteCanvas.createIcImage(500, 500, img_sparkle);  //SHU: formally, sparkle could hold any icObject or even more complicated type
            icObj.homeScale = dO_homeScale;                                     //     sparkle can hold any "representable" object

            const sparkle = new Sparkle(dO_id, icObj);
            sparkle.obsScale = infiniteCanvas.scale;

            this.sparkles[sparkle.id] = sparkle;
          }

        }

        materialize_object(object, infiniteCanvas) {

          const sparkle = object;

          const icObj = sparkle.icObj;
          infiniteCanvas.addIcObject(icObj);

          infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
            sparkle.updateWithObservationScale(infiniteCanvas.scale);
          });

          sparkle.didUpdateListeners.push((sparkle) => {
            const icObj = sparkle.icObj;
            infiniteCanvas.requestViewUpdateForIcObj(icObj);
          });

        }

      }

      class Sparkle {

        constructor(id, icObj) {
          this.id = id;

          this.icObj = icObj;

          this.homeScale = Object.assign({}, icObj.homeScale);
          this.obsScale = null;

          this.didUpdateListeners = [];
        }

        updateWithObservationScale(scale_obs) {
          console.log("updateWithObservationScale", scale_obs);
          icObj.homeScale = scale_obs;
        }

        static default_sparkleImage_p() {
          const imageName = "sparkle_gradient.png";



        }

      }

        // const sandBox_sparkles = new SandBox_sparkles(infiniteCanvas);

    </script>

    <script>
      class ZPuzzle {
        constructor(infiniteCanvas) {
          this.infiniteCanvas = infiniteCanvas;

          this.objects = {
            slots: {},
            pieces: {},
          };

          this.initialize();
        }

        initialize() {
          const infiniteCanvas = this.infiniteCanvas;

          this.initialize_objects(infiniteCanvas);

          const arr_slots = Object.values(this.objects.slots);
          arr_slots.forEach((slot, i) => {
            this.materialize_slot(slot, infiniteCanvas);
          });

          const arr_pieces = Object.values(this.objects.pieces);
          arr_pieces.forEach((piece, i) => {
            this.materialize_piece(piece, infiniteCanvas);

            const slot = this.objects.slots[piece.id];
            this.bindSlotAndPiece(slot, piece);
          });

        }

        initialize_objects(infiniteCanvas) {

          //s/p #1
          {
            const id = "id_sp1";
            const icObj = infiniteCanvas.createIcRect_withLTWH(500, 500, 500, 500);
            icObj.fill = ZPuzzle.colorForNumber(1);

            const slotAndPiece = ZPuzzle.debugSlotAndPiece(id, icObj);
            this.objects.slots[id] = slotAndPiece.slot;
            this.objects.pieces[id] = slotAndPiece.piece;
            slotAndPiece.piece.icObj.position = {
              x: slotAndPiece.piece.icObj.position.x + 600,
              y: slotAndPiece.piece.icObj.position.x + 100,
            };
          }

        }



        materialize_slot(slot, infiniteCanvas) {

          const icObj = slot.icObj;
          infiniteCanvas.addIcObject(icObj);

          // infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
          //   sparkle.updateWithObservationScale(infiniteCanvas.scale);
          // });

          // sparkle.didUpdateListeners.push((sparkle) => {
          //   const icObj = sparkle.icObj;
          //   infiniteCanvas.requestViewUpdateForIcObj(icObj);
          // });

        }

        materialize_piece(piece, infiniteCanvas) {

          const icObj = piece.icObj;
          infiniteCanvas.addIcObject(icObj);

          // infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
          //   sparkle.updateWithObservationScale(infiniteCanvas.scale);
          // });

          // sparkle.didUpdateListeners.push((sparkle) => {
          //   const icObj = sparkle.icObj;
          //   infiniteCanvas.requestViewUpdateForIcObj(icObj);
          // });

        }

        bindSlotAndPiece(slot, piece) {
          piece.didUpdateListeners.push((piece) => {
            console.log("piece, didUpdate");

            console.log("piece.isSnapped:", piece.isSnapped);

            if (!piece.isSnapped) {
              slot.attemptSnapping(piece);
            } else {
              // slot.attemptUnsnapping(piece);
            }

          });
        }


        static debugSlotAndPiece(spid, icObj) {
          // const icObj_slot  = icObj.clone();


          // const icObj_slot = backingObj.inner;
          // const backingObj = BackingObject.fromObject(icObj);
          // const icObj_slot = backingObj.getNewRepresentation();
          const icObj_slot = RepresentationFactory.initial(icObj);
          icObj_slot.addOnOuterUpdate((icObj_slot) => {
            console.log("icObj_slot", "onOuterUpdate", icObj_slot);

          });

          icObj_slot.opacity = 0.2;
          const slot = new ZPuzzleSlot(spid, icObj_slot);

          // const icObj_piece = icObj.clone();
          // const icObj_piece = backingObj.getNewRepresentation();
          const icObj_piece = RepresentationFactory.initial(icObj);
          icObj_piece.addOnOuterUpdate((icObj_piece) => {
            console.log("icObj_piece", "onOuterUpdate", icObj_piece);

          });


          //debug
          ///////////////////////
          // icObj_piece.createSisterRepresentation().addOnOuterUpdate((icObj_piece) => {
          //   console.log("icObj_piece sister rep","onOuterUpdate", icObj_piece);
          //
          // });
          //
          // setTimeout(() => {
          //   console.log("setTimeout", "update icObj_piece.position");
          //   icObj_piece.position = {
          //     x: icObj_piece.position.x + 100,
          //     y: icObj_piece.position.y + 100,
          //   };
          // }, 3000);
          //
          // setTimeout(() => {
          //   console.log("setTimeout", "update icObj_piece.position");
          //   icObj_piece.position = {
          //     x: icObj_piece.position.x + 100,
          //     y: icObj_piece.position.y + 100,
          //   };
          // }, 8000);
          ////////////////////////


          const piece = new ZPuzzlePiece(spid, icObj_piece);

          const slotAndPiece = {
            slot: slot,
            piece: piece,
          };

          return slotAndPiece;
        }

        static colorForNumber(number) {
          var outColor;

          switch (number) {
            case 1:
              outColor = "#FF7F0E";
              break;
            case 2:
              outColor = "#2CA02C";
              break;
            case 3:
              outColor = "#D62728";
              break;
            case 4:
              outColor = "#9467BD";
              break;
            case 5:
              outColor = "#8C564B";
              break;
            case 6:
              outColor = "#E377C2";
              break;
            case 7:
              outColor = "#7F7F7F";
              break;
            case 8:
              outColor = "#BCBD22";
              break;
            case 9:
              outColor = "#17BECF";
              break;

            default:
              outColor = "#000000";
              break;
          }

          return outColor;
        }

      }

      class ZPuzzleSlot {

        constructor(id, icObj) {
          this.id = id;

          // this.type = "typeA";

          this.icObj = icObj;

          // this.didUpdateListeners = [];
        }

        attemptSnapping(piece) {
          console.log("attemptSnapping", piece);

          const canSnap = this.checkCanSnap(piece);

          if (canSnap) {
            console.log("can snap");
            this.snap(piece);
          } else {
            console.log("can't snap");
          }

        }

        checkCanSnap(piece) {
          var outBool;

          const slot = this;

          // const isSameType = (piece.type == slot.type);
          // if(!isSameType) {
          //   return false;
          // }

          const isSlotAllowedForPiece = piece.isAllowedSlot(slot);
          if (!isSlotAllowedForPiece) {
            return false;
          }

          const icObj_slot = slot.icObj;
          const icObj_piece = piece.icObj;

          outBool = Snap.canSnap(icObj_piece, icObj_slot);

          return outBool;
        }

        snap(piece) {
          console.log("Zslot", "snap", piece);

          piece.isSnapped = true;


          const icObj_slot = this.icObj;
          const icObj_piece = piece.icObj;

          const icObj_new = Object.assign({}, icObj_piece);
          icObj_new.position = Object.assign({}, icObj_slot.position);
          icObj_new.homeScale = Object.assign({}, icObj_slot.homeScale);
          icObj_new.scale = Object.assign({}, icObj_slot.scale);
          icObj_new.orientation = icObj_slot.orientation;

          icObj_piece.update(icObj_new, "model");
        }

      }

      class ZPuzzlePiece {

        constructor(id, icObj) {
          this.id = id;

          this.icObj = icObj;

          this.isSnapped = false;

          this.didUpdateListeners = [];

          icObj.didUpdateListeners.push((icObj) => {
            console.log("ZPuzzlePiece", "icObj didUpdate", icObj);
            this.didUpdate();
          })
        }

        didUpdate() {
          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }

        isAllowedSlot(slot) {
          var outBool;
          const piece = this;

          const isSameId = (slot.id == piece.id);
          outBool = isSameId;

          return outBool;
        }

      }






        // const zPuzzle_4pieces = ZPuzzle.default_4pieces(infiniteCanvas);
        // const zPuzzle_4pieces = new ZPuzzle(infiniteCanvas);

    </script>



    <script>

      class GolfGame1 {

        constructor(infiniteCanvas, golfGame1Config) {

          this.name = golfGame1Config.name;

          //create objects (courses)
          this.courses = Object.entries(golfGame1Config.golfCourses).reduce((acc, [golfCourseName, golfCourseConfig]) => {

            const golfCourse = new GolfCourse(infiniteCanvas, golfCourseConfig);

            acc[golfCourseName] = golfCourse;

            return acc;
          }, {});


          //add logic
          //segues
          const zip = (a, b) => a.map((k, i) => [k, b[i]]);

          const arr_courses = Object.values(this.courses);
          const arr_courses_from = arr_courses.slice(0, -1);
          const arr_courses_to = arr_courses.slice(1);
          const arr_courses_zipped = zip(arr_courses_from, arr_courses_to);

          this.arr_segues = arr_courses_zipped.map(([course_from, course_to]) => {
            const segueConfig = {};
            const segue = new GolfSegue(infiniteCanvas, segueConfig, course_from, course_to);
            return segue;
          });

          //steps
          // logger.log("golfGame1Config.steps", golfGame1Config.steps);
          this.steps = Object.entries(golfGame1Config.steps)
            // .filter(([stepName, stepConfig]) => (stepName != "begin" && stepName != "end"))
            .reduce((acc, [stepName, stepConfig], i) => {

              const golfCourseName = stepConfig.golfCourseName;
              const golfCourse = this.courses[golfCourseName];

              const segue = this.arr_segues[i];
              console.log("segue", segue);

              const step = new GolfStep(infiniteCanvas, stepConfig, golfCourse, segue);
              acc[stepName] = step;

              return acc;
            }, {});

        }

        static fromJson(json_golfGame) {

        }














        static mini_gameConfig_9() {
          return {
            name: "Parcours entiers relatifs",
            challenges: [
              "11,+ 5,- 2,x 7,/ 2,78;4",
              // "19,+ 1,- 9,x 6,/ 4,30;3",
              // "24,+ 1,- 1,x 7,/ 2,90;5",
              // "51,+ (-1),- (-1),x (-7),/ 4,-91;3",
              // "-9,+ 8,- 5,x (-3),/ (-2),46;5",
              // "20,+ 1,- 7,x 9,/ 3,42;4",
              // "1,+ 2,- 5,x 7,/ 2,-7;4",
              // "20,+ 4,- 6,x 6,/ 4,21;3",
              // "64,+ 8,- 2,x 5,/ 2,85;5",
            ],
          };
        }

        static gameConfig_9() {
          var outConfig;

          const mini_gameConfig_9 = GolfGame1.mini_gameConfig_9();
          const name = mini_gameConfig_9.name;

          const arr_golfStepMiniString = mini_gameConfig_9.challenges;
          // const arr_golfCourseString = GolfGame1.arr_game_9().map(str => str.split(";")[0]);

          // const courseConfig_begin = GolfCourseConfig.instance_begin();
          // const courseConfig_end   = GolfCourseConfig.instance_end();

          const config = arr_golfStepMiniString.reduce((acc, golfStepMiniString, index) => {

            const arr_str_components = golfStepMiniString.split(";");
            const golfCourseMiniString = arr_str_components[0];
            const golfStepConfigMiniString = arr_str_components[1];

            const courseConfig = GolfCourseConfig.challengeCourseConfig_fromMiniString(golfCourseMiniString);
            courseConfig.rect.x = /*(courseConfig_begin.rect.x + 2000) +*/ index * 2000;

            const courseName = "" + index;
            acc.golfCourses[courseName] = courseConfig;





            const par = golfStepConfigMiniString;
            const componentSpecs = {
              "tee": {
                ammo: 8,        //SHU: tee ammo ^^
              },
            };

            const gmItemConfig = GolfGame1.challengeGMItemConfig(courseConfig);

            const stepConfig = new GolfStepConfig("challenge", courseName, par, componentSpecs, gmItemConfig);

            acc.steps[index] = stepConfig;

            return acc;
          }, {
            name: name,
            golfCourses: {
              // "begin": courseConfig_begin,
              // "end":   courseConfig_end,
            },
            steps: {
              // "begin": GolfStepConfig.step_begin("begin"),
              // "end":   GolfStepConfig.step_end("end"),
            },
          });

          // const miniDict__golfCourses_begin_end = {
          //   "begin": courseConfig_begin,
          //   "end":   courseConfig_end,
          // };
          //
          // const miniDict__steps_begin_end = {
          //   "begin": GolfStepConfig.step_begin("begin"),
          //   "end":   GolfStepConfig.step_end("end"),
          // };

          // config.golfCourses["end"].rect.x = config.golfCourses["8"].rect.x + 2000;   //SHU: buark


          outConfig = config;

          return outConfig;
        }

        static seriousInstance(infiniteCanvas) {
          var out;

          const golfGame1Config = GolfGame1.gameConfig_9();
          // const golfGame1Config = GolfGame1.gameConfig_9__frac();

          out = new GolfGame1(infiniteCanvas, golfGame1Config);

          return out;
        }


        static challengeGMItemConfig(courseConfig) {
          // logger.log("random_challengeGMItemConfig");

          // const mathNode__initial = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
          logger.log("courseConfig", courseConfig);
          // throw new Error("please die here");
          const value__initial = courseConfig.initial;
          const mathNode__initial = new math.ConstantNode(value__initial);
          mathNode__initial.autoSimplify = true;
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");

          // const mathNode__target  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
          const value__target = courseConfig.components.hole.config.value;
          const mathNode__target = new math.ConstantNode(value__target);
          const gmItem__target = GMItem.value(mathNode__target, "target", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          // const nb_operators = 4;

          // const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {
          const arr_gmItem_operator = Object.values(courseConfig.components)
            .filter(component => component.type == "gm_operator")
            .map(component => {

              const operatorMiniString = component.config.operatorString;
              const arr_split_operatorMiniString = operatorMiniString.split(" ");
              const opString = arr_split_operatorMiniString[0];
              const valueString_b = arr_split_operatorMiniString[1];
              const value_b = Number(valueString_b);

              const op = Operator.fromString_binary(opString);
              const node_b = new math.ConstantNode(value_b);

              const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

              const name = operatorNodeFuncWrapper.semantics.name;
              const func = operatorNodeFuncWrapper.func;

              const gmItem__operator = GMItem.operator(func, name, "");

              // //666
              // const icObjToIcObjFunc = func;
              // const transformationFunc = (icObj) => {
              //   const icObj__new = icObjToIcObjFunc(icObj);
              //   const transformationOutput = new TransformationOutput("mutated", icObj__new, icObj);
              //   return transformationOutput;
              // };
              // const gmItem__operator = GMItem.operator(transformationFunc, name, "");

              return gmItem__operator;
            });

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,
            operators: arr_gmItem_operator,
          };

          return gmItemConfig;
        }

      }

      class GolfObject {

        constructor(type, icObj) {
          this.type = type;
          this.icObj = icObj;
        }

      }


      class GolfCourseConfig {

        constructor(rect, componentsConfig) {
          this.rect = rect;
          this.componentsConfig = componentsConfig;
        }

        static instance_begin(titleString) {
          var outCourseConfig;

          const courseConfig = GolfCourseConfig.template_begin();

          courseConfig.components.title.config.text = titleString;

          outCourseConfig = courseConfig;

          return outCourseConfig;
        }

        static instance_end(titleString) {
          var outCourseConfig;

          const courseConfig = GolfCourseConfig.template_end();

          courseConfig.components.title.config.text = titleString;

          outCourseConfig = courseConfig;

          return outCourseConfig;
        }

        // static instance_challenge() {
        //
        // }

        static template_begin() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
              },
              rect_rel: {
                l: 0.0,
                r: 1.0,
                t: 0.0,
                b: 1.0,
              },
            },

            "title": {
              type: "rect",
              zIndex: 0,
              config: {
                // fill: "green",
                fill: "almond",
                text: "<title>",
              },
              rect_rel: {
                l: 0.2,
                r: 0.8,
                t: 0.2,
                b: 0.4,
              },
            },

            "button_start": {
              type: "button",
              zIndex: 20,
              config: {
                // fill: "green",
                fill: "almond",
                text: "<start>",
              },
              rect_rel: {
                l: 0.2,
                r: 0.8,
                t: 0.6,
                b: 0.8,
              },
            },
          };

          const config = {
            rect: {
              x: 0,
              y: 0,
              width: 1600,
              height: 1000,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }

        static template_end() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                fill: "orange",

              },
              rect_rel: {
                l: 0.0,
                r: 1.0,
                t: 0.0,
                b: 1.0,
              },
            },

            "title": {
              type: "rect",
              zIndex: 0,
              config: {
                // fill: "green",
                fill: "almond",
                text: "<title>",
              },
              rect_rel: {
                l: 0.2,
                r: 0.8,
                t: 0.2,
                b: 0.4,
              },
            },

            "total_score": {
              type: "labelValue",
              zIndex: 0,
              config: {
                // fill: "green",
                fill: "almond",
                text: "total score:",
              },
              rect_rel: {
                l: 0.3,
                r: 0.7,
                t: 0.3,
                b: 0.5,
              },
            },

            "total_par": {
              type: "labelValue",
              zIndex: 0,
              config: {
                // fill: "green",
                fill: "almond",
                text: "total par:",
              },
              rect_rel: {
                l: 0.3,
                r: 0.7,
                t: 0.5,
                b: 0.8,
              },
            },

            // "medal": {
            //   type: "img",
            //   zIndex: 0,
            //   config: {
            //     // fill: "green",
            //     fill: "almond",
            //   },
            //   rect_rel: {
            //     l: 0.7,
            //     r: 0.9,
            //     t: 0.3,
            //     b: 0.6,
            //   },
            // },

          };

          const config = {
            rect: {
              x: 0,
              y: 0,
              width: 1600,
              height: 1000,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }

        static template_challenge(nb_op) {
          var outConfig;

          switch (nb_op) {
            case 2:
              outConfig = GolfCourseConfig.template_challenge__2();
              break;
            default:
              outConfig = GolfCourseConfig.template_challenge__4();
              break;
          }

          return outConfig;
        }

        static template_challenge__2() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
                fill: "lightyellow",
              },
              rect_rel: {
                l: 0.0,
                r: 1.0,
                t: 0.0,
                b: 1.0,
              },
            },

            "tee": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.40,
                b: 0.50,
              },
            },

            // "bumpers": {
            "bumper1": {
              type: "gm_operator",
              zIndex: 51,
              config: {
                operatorString: "+ 1",
                //SHULOLILOL
                operatorNode: MathSingleton.node__empty,
              },
              rect_rel: {
                l: 0.25,
                r: 0.35,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper2": {
              type: "gm_operator",
              zIndex: 52,
              config: {
                operatorString: "+ 10",
                //SHULOLILOL
                operatorNode: MathSingleton.node__empty,
              },
              rect_rel: {
                l: 0.55,
                r: 0.65,
                t: 0.80,
                b: 0.90,
              },
            },
            // },




            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          const config = {
            rect: {
              x: 0,
              y: 0,
              width: 1600,
              height: 1000,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }

        static template_challenge__4() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
                fill: "lightyellow",
              },
              rect_rel: {
                l: 0.0,
                r: 1.0,
                t: 0.0,
                b: 1.0,
              },
            },

            "tee": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.40,
                b: 0.50,
              },
            },

            // "bumpers": {
            "bumper1": {
              type: "gm_operator",
              zIndex: 51,
              config: {
                operatorString: "+ 1",
                //SHULOLILOL
                operatorNode: MathSingleton.node__empty,
              },
              rect_rel: {
                l: 0.15,
                r: 0.25,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper2": {
              type: "gm_operator",
              zIndex: 52,
              config: {
                operatorString: "+ 10",
                //SHULOLILOL
                operatorNode: MathSingleton.node__empty,
              },
              rect_rel: {
                l: 0.35,
                r: 0.45,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper3": {
              type: "gm_operator",
              zIndex: 53,
              config: {
                operatorString: "x 2",
                //SHULOLILOL
                operatorNode: MathSingleton.node__empty,
              },
              rect_rel: {
                l: 0.55,
                r: 0.65,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper4": {
              type: "gm_operator",
              zIndex: 54,
              config: {
                operatorString: "x (-1)",
                //SHULOLILOL
                operatorNode: MathSingleton.node__empty,
              },
              rect_rel: {
                l: 0.75,
                r: 0.85,
                t: 0.80,
                b: 0.90,
              },
            },
            // },




            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          const config = {
            rect: {
              x: 0,
              y: 0,
              width: 1600,
              height: 1000,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }


        static template_challenge_with_placeholders(nb_op) {
          var outConfig;

          switch (nb_op) {
            case 2:
              outConfig = GolfCourseConfig.template_challenge_with_placeholders__2();
              break;
            default:
              outConfig = GolfCourseConfig.template_challenge_with_placeholders__4();
              break;
          }

          return outConfig;
        }

        static template_challenge_with_placeholders__2() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
                fill: "lightyellow",
              },
              rect_rel: {
                l: 0.0,
                r: 1.0,
                t: 0.0,
                b: 1.0,
              },
            },

            "tee": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.40,
                b: 0.50,
              },
            },

            // "bumpers": {
            "bumper1": {
              type: "gm_operator",
              zIndex: 51,
              config: {
                operatorString: "+ 1",
                //SHULOLILOL
                operatorNode: MathSingleton.node__empty,
              },
              rect_rel: {
                l: 0.25,
                r: 0.35,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper2": {
              type: "gm_operator",
              zIndex: 52,
              config: {
                operatorString: "+ 10",
                //SHULOLILOL
                operatorNode: MathSingleton.node__empty,
              },
              rect_rel: {
                l: 0.55,
                r: 0.65,
                t: 0.80,
                b: 0.90,
              },
            },
            // "bumper3": {
            //   type: "gm_operator",
            //   zIndex: 53,
            //   config: {
            //     operatorString: "x 2",
            //   },
            //   rect_rel: {
            //     l: 0.55,
            //     r: 0.65,
            //     t: 0.80,
            //     b: 0.90,
            //   },
            // },
            // "bumper4": {
            //   type: "gm_operator",
            //   zIndex: 54,
            //   config: {
            //     operatorString: "x (-1)",
            //   },
            //   rect_rel: {
            //     l: 0.75,
            //     r: 0.85,
            //     t: 0.80,
            //     b: 0.90,
            //   },
            // },
            // },

            "operatorWallPlaceholder1": {
              type: "placeholder",
              zIndex: 55,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.25,
                r: 0.35,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder2": {
              type: "placeholder",
              zIndex: 56,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.55,
                r: 0.65,
                t: 0.10,
                b: 0.20,
              },
            },
            // "operatorWallPlaceholder3": {
            //   type: "placeholder",
            //   zIndex: 57,
            //   config: {
            //     fill: "gray",
            //   },
            //   rect_rel: {
            //     l: 0.55,
            //     r: 0.65,
            //     t: 0.10,
            //     b: 0.20,
            //   },
            // },
            // "operatorWallPlaceholder4": {
            //   type: "placeholder",
            //   zIndex: 58,
            //   config: {
            //     fill: "gray",
            //   },
            //   rect_rel: {
            //     l: 0.75,
            //     r: 0.85,
            //     t: 0.10,
            //     b: 0.20,
            //   },
            // },


            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          const config = {
            rect: {
              x: 0,
              y: 0,
              width: 1600,
              height: 1000,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }


        static template_challenge_with_placeholders__4() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
                fill: "lightyellow",
              },
              rect_rel: {
                l: 0.0,
                r: 1.0,
                t: 0.0,
                b: 1.0,
              },
            },

            "tee": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.40,
                b: 0.50,
              },
            },

            // "bumpers": {
            "bumper1": {
              type: "gm_operator",
              zIndex: 51,
              config: {
                operatorString: "+ 1",
                //SHULOLILOL
                operatorNode: MathSingleton.node__empty,
              },
              rect_rel: {
                l: 0.15,
                r: 0.25,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper2": {
              type: "gm_operator",
              zIndex: 52,
              config: {
                operatorString: "+ 10",
                //SHULOLILOL
                operatorNode: MathSingleton.node__empty,
              },
              rect_rel: {
                l: 0.35,
                r: 0.45,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper3": {
              type: "gm_operator",
              zIndex: 53,
              config: {
                operatorString: "x 2",
                //SHULOLILOL
                operatorNode: MathSingleton.node__empty,
              },
              rect_rel: {
                l: 0.55,
                r: 0.65,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper4": {
              type: "gm_operator",
              zIndex: 54,
              config: {
                operatorString: "x (-1)",
                //SHULOLILOL
                operatorNode: MathSingleton.node__empty,
              },
              rect_rel: {
                l: 0.75,
                r: 0.85,
                t: 0.80,
                b: 0.90,
              },
            },
            // },

            "operatorWallPlaceholder1": {
              type: "placeholder",
              zIndex: 55,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.15,
                r: 0.25,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder2": {
              type: "placeholder",
              zIndex: 56,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.35,
                r: 0.45,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder3": {
              type: "placeholder",
              zIndex: 57,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.55,
                r: 0.65,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder4": {
              type: "placeholder",
              zIndex: 58,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.75,
                r: 0.85,
                t: 0.10,
                b: 0.20,
              },
            },


            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          const config = {
            rect: {
              x: 0,
              y: 0,
              width: 1600,
              height: 1000,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }


        static template_challenge__fraction_add() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
                fill: "lightyellow",
              },
              rect_rel: {
                l: 0.0,
                r: 1.0,
                t: 0.0,
                b: 1.0,
              },
            },

            "tee1": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.30,
                b: 0.40,
              },
            },

            "tee2": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.50,
                b: 0.60,
              },
            },

            // "bumpers": {
            "bumper1": {
              type: "gm_fractionOne_operator",
              zIndex: 51,
              config: {
                operatorString: "fractionOne:x 2",
              },
              rect_rel: {
                l: 0.15,
                r: 0.25,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper2": {
              type: "gm_fractionOne_operator",
              zIndex: 52,
              config: {
                operatorString: "fractionOne:x 3",
              },
              rect_rel: {
                l: 0.35,
                r: 0.45,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper3": {
              type: "gm_fractionOne_operator",
              zIndex: 53,
              config: {
                operatorString: "fractionOne:x 5",
              },
              rect_rel: {
                l: 0.55,
                r: 0.65,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper4": {
              type: "gm_fractionOne_operator",
              zIndex: 54,
              config: {
                operatorString: "fractionOne:x 7",
              },
              rect_rel: {
                l: 0.75,
                r: 0.85,
                t: 0.80,
                b: 0.90,
              },
            },
            // },

            "conductiveOp": {
              type: "gm_conductive_operator",
              zIndex: 55,
              config: {
                operatorString: "+",
              },
              rect_rel: {
                l: 0.45,
                r: 0.65,
                t: 0.30,
                b: 0.60,
              },
            },


            // "operatorWallPlaceholder1": {
            //   type: "placeholder",
            //   zIndex: 55,
            //   config: {
            //     fill: "gray",
            //   },
            //   rect_rel: {
            //     l: 0.15,
            //     r: 0.25,
            //     t: 0.10,
            //     b: 0.20,
            //   },
            // },
            // "operatorWallPlaceholder2": {
            //   type: "placeholder",
            //   zIndex: 56,
            //   config: {
            //     fill: "gray",
            //   },
            //   rect_rel: {
            //     l: 0.35,
            //     r: 0.45,
            //     t: 0.10,
            //     b: 0.20,
            //   },
            // },
            // "operatorWallPlaceholder3": {
            //   type: "placeholder",
            //   zIndex: 57,
            //   config: {
            //     fill: "gray",
            //   },
            //   rect_rel: {
            //     l: 0.55,
            //     r: 0.65,
            //     t: 0.10,
            //     b: 0.20,
            //   },
            // },
            // "operatorWallPlaceholder4": {
            //   type: "placeholder",
            //   zIndex: 58,
            //   config: {
            //     fill: "gray",
            //   },
            //   rect_rel: {
            //     l: 0.75,
            //     r: 0.85,
            //     t: 0.10,
            //     b: 0.20,
            //   },
            // },


            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          const config = {
            rect: {
              x: 0,
              y: 0,
              width: 1600,
              height: 1000,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }



        static challengeCourseConfigMiniObj_fromMiniString(challengeCourseMiniString) {

          const arr_courseStringComponent = challengeCourseMiniString.split(",");
          const nb_compoments = arr_courseStringComponent.length;

          const courseConfigMiniObj = arr_courseStringComponent.reduce((acc, x, i) => {

            const componentString = x;

            switch (i) {
              case 0:
                const initial = parseInt(componentString);
                acc["initial"] = initial;
                break;
              case (nb_compoments - 1):
                const target = parseInt(componentString);
                acc["target"] = target;
                break;
              default:
                const operatorString = componentString;
                if (acc["operators"] == null) {
                  acc["operators"] = [];
                }
                acc["operators"].push(operatorString);
                break;
            }

            return acc;
          }, {});

          return courseConfigMiniObj;
        }


        static challengeCourseConfig_fromMiniString(courseMiniString) {
          var outCourseConfig;

          const courseConfigMiniObj = GolfCourseConfig.challengeCourseConfigMiniObj_fromMiniString(courseMiniString);

          const courseConfig = GolfCourseConfig.template_challenge();

          // courseConfig.components.ball.config.value = courseConfigMiniObj.initial;
          courseConfig.initial = courseConfigMiniObj.initial;

          courseConfig.components.hole.config.value = courseConfigMiniObj.target;

          //SHU TODO: remove this ugliness
          // const entries_bumper = Object.entries(courseConfig.components).filter(([componentName, component]) => componentName.startsWith("bumper"));
          const entries_bumper = Object.entries(courseConfig.components).filter(([componentName, component]) => component.type == "gm_operator");
          entries_bumper.forEach(([componentName, component], i) => {
            component.config.operatorString = courseConfigMiniObj.operators[i];
          });

          outCourseConfig = courseConfig;

          return outCourseConfig;
        }

      }


      class GolfCourse {

        constructor(infiniteCanvas, golfCourseConfig) {
          console.log("GolfCourse, constructor", golfCourseConfig);
          this.infiniteCanvas = infiniteCanvas;

          this.rect = golfCourseConfig.rect;

          // this.components =
          const components = Object.entries(golfCourseConfig.components).reduce((acc, [componentName, componentConfig]) => {
            // logger.log("componentName", componentName);

            const icObj = this.createIcObjForComponent(infiniteCanvas, componentConfig);
            infiniteCanvas.addIcObject(icObj);

            const represented = infiniteCanvas.getRepresented(icObj.id);
            const rep_free = represented.r_free();

            const component = new GolfObject(componentConfig.type, rep_free);

            acc[componentName] = component;

            return acc;
          }, {});
          this.components = components;
        }


        createIcObjForComponent(infiniteCanvas, componentConfig) {
          console.log("createIcObjForComponent", componentConfig);
          var outIcObj;

          const rect_rel__component = componentConfig.rect_rel;
          const trueRect__component = Geometry.rectForRectRel(this.rect, rect_rel__component);

          switch (componentConfig.type) {
            case "rect":
              {
                const config = componentConfig.config;
                const fill = config.fill;
                outIcObj = infiniteCanvas.createIcRect(trueRect__component);
                outIcObj.fill = fill;
              }
              break;
            case "gm_clickWell":
              {
                const config = componentConfig.config;
                const value = config.value;
                // outIcObj = infiniteCanvas.createIcGMClickWell(trueRect__component, value);
                outIcObj = infiniteCanvas.createIcBornAgainGreenMouse(trueRect__component, value);
              }
              break;
            case "gm_operator":
              {
                const config = componentConfig.config;
                const operatorString = config.operatorString;
                outIcObj = infiniteCanvas.createIcGMOperator(trueRect__component, operatorString);
              }
              break;

            case "gm_fractionOne_operator":
              {
                // const config         = componentConfig.config;
                // const operatorString = config.operatorString;
                outIcObj = infiniteCanvas.createIcFractionOneOperator(trueRect__component);
              }
              break;
            case "gm_conductive_operator":
              {
                const config = componentConfig.config;
                const operatorString = config.operatorString;
                outIcObj = infiniteCanvas.createIcConductiveOperator(trueRect__component);
              }
              break;

            case "gm_targetTouchSlot":
              {
                const config = componentConfig.config;
                const value__core = config.value;
                const value__facade = config.value__facade;

                const value = config.value;
                outIcObj = infiniteCanvas.createIcGMTargetTouchSlot(trueRect__component, value);

                /*
                const mathNode__core   = math.parse("42");
                const mathNode__facade = math.parse("1000");
                outIcObj = infiniteCanvas.createIcGMEqTargetTouchSlot(trueRect__component, mathNode__core, mathNode__facade);
                */

                // outIcObj = infiniteCanvas.createIcGMBoxTargetTouchSlot(trueRect__component, value);
                // outIcObj = infiniteCanvas.createIcGMBlob(trueRect__component, value);
              }
              break;


            case "button":
              {
                const config = componentConfig.config;
                const fill = config.fill;
                outIcObj = infiniteCanvas.createIcButton(trueRect__component);
                outIcObj.fill = fill;
              }
              break;

            case "labelValue":
              {
                const config = componentConfig.config;
                const fill = config.fill;
                const text = config.text;
                outIcObj = infiniteCanvas.createIcLabelValue(trueRect__component, text, 0);
                outIcObj.fill = fill;
              }
              break;

            // case "img":
            //   {
            //   const config = componentConfig.config;
            //   const fill   = config.fill;
            //   const text   = config.text;
            //   outIcObj = infiniteCanvas.createIcImage(trueRect__component, null);
            //   outIcObj.fill = fill;
            //   }
            //   break;

            case "placeholder":
              {
                // const config = componentConfig.config;
                // const fill   = config.fill;
                // outIcObj = infiniteCanvas.createIcRect(trueRect__component);
                // outIcObj.fill = fill;
                const operatorString = "x 1";
                outIcObj = infiniteCanvas.createIcGMOperator(trueRect__component, operatorString);

                outIcObj.isPlaceholder = true;
              }
              break;


            default:
              throw new Error("unsupported type: " + componentConfig.type);
              break;
          }

          //common props
          const zIndex = componentConfig.zIndex;
          outIcObj.zIndex = zIndex;

          return outIcObj;
        }

        fillHole() {
          const icObj_hole = this.components["hole"].icObj;
          // icObj_hole.parts["facade"].fill = "yellow";
          icObj_hole.parts["touchSlot"].fill = "yellow";
        }

        freeHole() {
          const icObj_hole = this.components["hole"].icObj;
          // icObj_hole.parts["facade"].fill = "yellow";
          icObj_hole.parts["touchSlot"].fill = "";
        }


        mutateIntoScoreLabel(score) {

          const golfCourse = this;
          const infiniteCanvas = this.infiniteCanvas;

          //remove almost all golfCourse components
          // Object.entries(golfCourse.components)
          // .filter(([componentName, component]) => {
          //   return (componentName != "bg");
          // })
          // .forEach(([componentName, component], i) => {
          //   const icObj = component.icObj;
          //
          //   // icObj.im_dying_now = true;
          //   // infiniteCanvas.removeIcObject(icObj);
          //
          //   const represented = icObj.represented;
          //   infiniteCanvas.removeRepresented(represented, true);
          // });

          //change bg color
          const icObj_bg = golfCourse.components["bg"].icObj;

          // function colorForScore(score) {
          //   var outColor;
          //
          //   switch(score.medal) {
          //     case "bronze":
          //     outColor = "bronze";
          //     break;
          //     case "silver":
          //     outColor = "silver";
          //     break;
          //     case "gold":
          //     outColor = "gold";
          //     break;
          //   }
          //
          //   return outColor;
          // }
          icObj_bg.fill = "gold";

          //add score label
          const rect__scoreLabel = {
            x: golfCourse.rect.x,
            y: golfCourse.rect.y,
            width: golfCourse.rect.width,
            height: golfCourse.rect.height,
          };
          const scoreLabel = infiniteCanvas.createIcText(rect__scoreLabel.x, rect__scoreLabel.y, "" + score);     //SHU TODO: createIcLabel(trueRect, text)
          infiniteCanvas.addIcObject(scoreLabel);


        }

      }

      class GolfStepConfig {
        constructor(type, golfCourseName, par, componentSpecs, gmItemConfig) {
          this.type = type;

          this.golfCourseName = golfCourseName;
          this.par = par;

          this.componentSpecs = componentSpecs;
          this.gmItemConfig = gmItemConfig;
        }

        // static step_begin(golfCourseName) {
        //   const type = "begin";
        //   const stepConfig = new GolfStepConfig(type, golfCourseName);
        //   return stepConfig;
        // }

        // static step_end(golfCourseName) {
        //   const type = "end";
        //   const stepConfig = new GolfStepConfig(type, golfCourseName);
        //   return stepConfig
        // }

      }

      class GolfStep {

        constructor(infiniteCanvas, golfStepConfig, golfCourse, segue) {
          // logger.log("GolfStep::constructor", golfStepConfig, golfCourse, segue);

          this.infiniteCanvas = infiniteCanvas;
          // this.golfStepConfig = golfStepConfig;
          this.golfCourse = golfCourse;
          this.segue = segue;

          this.configure(golfStepConfig);

          this.invest(golfCourse);

          // this.possess(golfCourse);
        }

        configure(golfStepConfig) {
          this.par = golfStepConfig.par;
          this.challengeGMItemConfig = golfStepConfig.gmItemConfig;
        }

        addNewBall() {
          const step = this;
          const infiniteCanvas = this.infiniteCanvas;
          const golfCourse = this.golfCourse;


          const icObj__tee = golfCourse.components["tee"].icObj;
          const trueRect__ball = {
            x: icObj__tee.position.x,
            y: icObj__tee.position.y,
            width: 50,
            height: 50,
          };

          // const value = 0;
          //debug
          const mathNode__initial = step.challengeGMItemConfig.initial.content;
          // const value = mathNode__initial.value;

          // const icObj = infiniteCanvas.createIcBornAgainGreenMouseBox(trueRect__ball, mathNode__initial);
          const icObj = infiniteCanvas.createIcGreenMouseBox(trueRect__ball, mathNode__initial);
          // const icObj = infiniteCanvas.createIcMathNode(trueRect__ball.x, trueRect__ball.y, mathNode__initial);

          // const icObj = infiniteCanvas.createIcMathNode(trueRect__ball.x, trueRect__ball.y, mathNode__initial);

          infiniteCanvas.addIcObject(icObj);

          //"exo curse"
          const rep_free__ball = infiniteCanvas.getRepresented(icObj.id).r_free();
          Hooker.installHooks(rep_free__ball, "die");
          rep_free__ball.did["die"].on(() => {
            // logger.log("did die");

            rep_free__ball.parts.facade.im_dying_now = true;
            rep_free__ball.parts.contactArea.im_dying_now = true;

            step.addNewBall();
          });

          step.rep_free__ball = rep_free__ball;
        }

        invest(golfCourse) {

          const step = this;

          //furnish: add objects
          {
            const infiniteCanvas = this.infiniteCanvas;

            //add label/value: score
            function addLabel_score() {
              const rect__score = golfCourse.rect;
              rect__score.width = 300;
              rect__score.height = 150;

              const string__score = "score:";
              const value__score = 0;

              const icObj__score = infiniteCanvas.createIcLabelValue(rect__score, string__score, value__score);
              icObj__score.zIndex = 200;

              infiniteCanvas.addIcObject(icObj__score);

              const rep_free__score_valueLabel = infiniteCanvas.getRepresented(icObj__score.id).r_free();
              step.rep_free__score_valueLabel = rep_free__score_valueLabel;
              step.rep_free__score_value = rep_free__score_valueLabel.parts["value"];
            }
            addLabel_score();

            //add label/value: par
            function addLabelValue_par() {
              const rect__par = {
                x: step.rep_free__score_valueLabel.position.x,
                y: step.rep_free__score_valueLabel.position.y + 120,
                width: 300,
                height: 150,
              };

              const string__par = "par:";
              const value__par = step.par;

              const icObj__par = infiniteCanvas.createIcLabelValue(rect__par, string__par, value__par);
              icObj__par.zIndex = 201;

              infiniteCanvas.addIcObject(icObj__par);

              const rep_free__par_valueLabel = infiniteCanvas.getRepresented(icObj__par.id).r_free();
              step.rep_free__par_valueLabel = rep_free__par_valueLabel;
              step.rep_free__par_value = rep_free__par_valueLabel.parts["value"];

              setTimeout(() => {
                step.rep_free__par_value.position = {
                  x: step.rep_free__score_value.position.x,
                  y: step.rep_free__par_value.position.y,
                };
              }, 20);   //SHU TODO: remove this ugliness
            }
            addLabelValue_par();



            //add button: restart

            //add ball:
            step.addNewBall();
          }


          //invest: "this is mine now"
          {
            // step.rep_free__ball = golfCourse.components["ball"].icObj;

            // this.rep_free__ball = golfCourse.components["ball"].icObj;
            step.rep_free__hole = golfCourse.components["hole"].icObj;
          }


          //employ: now you do X

          //operators
          {
            const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_operator");
            const arr_rep_free__operator = arr_gm_operator.map((gm_operator, i) => {
              const icObj__rep_free = gm_operator.icObj;
              return icObj__rep_free;
            });
            const arr_gmItem_operator = step.challengeGMItemConfig.operators;

            const zip = (a, b) => a.map((k, i) => [k, b[i]]);

            const arr_zipped = zip(arr_rep_free__operator, arr_gmItem_operator);

            arr_zipped.forEach(([rep_free__operator, gmItem_operator], i) => {


              //touchSlot
              const rep_free__touchSlot = rep_free__operator.parts["touchSlot"];

              const mathNodeTransformationFunc = gmItem_operator.content;
              const icObjTransformationFunc = (icObj) => {
                // logger.log("icObjTransformationFunc", icObj);
                var outIcObj;



                outIcObj = icObj.clone();
                // logger.log("outIcObj", outIcObj);

                if (outIcObj.mathNode) {
                  delete outIcObj.mathNode;     //SHU666: true sadness
                }



                if (icObj.cType == "gm_box") {
                  // logger.log("gm_box");

                  const facade = icObj.parts.facade;
                  outIcObj.parts.facade.mathNode = mathNodeTransformationFunc(facade.mathNode);
                }

                // if(icObj.mathNode != null) {
                //   // logger.log("icObj.mathNode", icObj.mathNode);
                //   outIcObj.mathNode = mathNodeTransformationFunc(icObj.mathNode);
                // }

                return outIcObj;
              };
              rep_free__touchSlot.touchSlotConfig.transformationFunc = icObjTransformationFunc;


              //facade
              const rep_free__facade = rep_free__operator.parts["facade"];
              rep_free__facade.text = gmItem_operator.name;

              rep_free__facade.originX = "center";

            });
          }

        }

        possess(golfCourse) {
          this.initializeCompletionListeners();

          this.setupAttemptListeners(golfCourse);

          this.setupCompletionTrigger(golfCourse);
          this.addCompletionListener(golfCourse);
        }

        initializeCompletionListeners() {
          // this.nb_attempts = 0;
          this.arr_attempt = [];

          this.listeners_completed = [];

          this.onCompleted = (listener) => {
            this.listeners_completed.push(listener);
          };
          this.offCompleted = (listener) => {
            this.listeners_completed = Utils.arrayByRemovingElement(this.listeners_completed, listener);
          };
          this.nowCompleted = () => {
            this.listeners_completed.forEach((listener, i) => {
              listener(this);
            });
          };
        }

        setupAttemptListeners(golfCourse) {   //SHU: this is where BigBrother sneaked in from

          // const step = this;
          //
          // function waitForNewAttempt() {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   const createAttemptFunc = () => {
          //
          //       const attempt = new GolfStepAttempt();
          //
          //       step.arr_attempt.push(attempt);
          //
          //       ball__rep_free.offHold(createAttemptFunc);
          //   };
          //
          //   ball__rep_free.onHold(createAttemptFunc);
          // }
          //
          // //gm.onHold(create attempt)
          // {
          //   waitForNewAttempt();
          // }
          //
          // //gm.onTouched(add event to attempt)
          // {
          //
          // }
          //
          // //gm.onRelease(finalize attempt)
          // {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   ball__rep_free.onRelease(waitForNewAttempt);
          // }
          //
          // //create attempt
          //
          //
          //
          //
          //
          //
          // //course use listeners
          //
          // function listenToOperatorTouches(icObj__rep_free) {
          //
          //   const touchSlot__rep_free  = icObj__rep_free.parts["touchSlot"];
          //   // logger.log("touchSlot__rep_free", touchSlot__rep_free);
          //
          //   const touchSlotEngine = touchSlot__rep_free.engine;
          //
          //   Hooker.installHooks(touchSlotEngine.awoken, "touch");
          //   touchSlotEngine.awoken.did["touch"].on((...args) => {
          //     // logger.log("did touch", ...args);
          //
          //     // counter += 1
          //     const attempt = step.getCurrentAttempt();
          //     // logger.log("attempt", attempt);
          //     attempt.manoeuvre.nb_touched += 1;
          //
          //     //debug
          //     step.rep_free__score_value.text = "" + attempt.manoeuvre.nb_touched;
          //   });
          //
          // }
          //
          // const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_operator");
          //
          // arr_gm_operator.forEach((gm_operator, i) => {
          //   const icObj__rep_free = gm_operator.icObj;
          //   listenToOperatorTouches(icObj__rep_free);
          // });

        }

        setupCompletionTrigger(golfCourse) {

          const targetTouchSlot__rep_free = golfCourse.components["hole"].icObj;

          const touchSlot__rep_free = targetTouchSlot__rep_free.parts["touchSlot"];

          const touchSlotEngine = touchSlot__rep_free.engine;

          Hooker.installHooks(touchSlotEngine.awoken, "touch");
          const listener_targetDidTouch = (...args) => {
            logger.log("listener_targetDidTouch", ...args);

            this.nowCompleted();
          };
          this.listener_targetDidTouch = listener_targetDidTouch;
          touchSlotEngine.awoken.did["touch"].on(listener_targetDidTouch);

        }

        addCompletionListener(golfCourse) {

          const step = this;

          this.listener_onCompleted = (golfStep) => {
            // console.log("step, onCompleted", golfStep);
            // logger.log("step, onCompleted", golfStep);

            /*
            const score = golfStep.arr_attempts.length;
            golfCourse.mutateIntoScoreLabel(score);
            */

            step.offCompleted(step.listener_onCompleted);
            step.end();

            step.segue.play(golfStep);
          };

          this.onCompleted(this.listener_onCompleted);
        }

        getCurrentAttempt() {
          return this.arr_attempt[this.arr_attempt.length - 1];
        }


      }

      class GolfStepAttempt {

        constructor() {
          this.evolution = new GolfStepAttemptEvolution();
          this.manoeuvre = new GolfStepAttemptManoeuvre();
        }

      }

      class GolfStepAttemptEvolution {

        constructor() {
          this.nb_touched = 0;
        }

      }

      class GolfStepAttemptManoeuvre {

        constructor() {
          this.nb_touched = 0;
        }

      }


      class GolfSegue {

        constructor(infiniteCanvas, golfSegueConfig, golfCourse_from, golfCourse_to) {
          this.infiniteCanvas = infiniteCanvas;

          this.golfSegueConfig = golfSegueConfig;
          this.configure(golfSegueConfig);

          this.golfCourse_from = golfCourse_from;
          this.golfCourse_to = golfCourse_to;
        }

        configure(golfSegueConfig) {

        }

        play(step_from) {
          // logger.log("GolfSegue::play", step_from);

          const score = 12;
          // this.golfCourse_from.mutateIntoScoreLabel(score);

          this.golfCourse_from.fillHole();

          const position_to = {
            x: this.golfCourse_to.rect.x,
            y: this.golfCourse_to.rect.y,
          };
          this.infiniteCanvas.move_to_position(position_to);

          // this.infiniteCanvas.show_rect(this.golfCourse_to.rect);
          // const rect__makeshift = {
          //   x: this.golfCourse_to.rect.x + this.golfCourse_to.rect.width  / 2.0,
          //   y: this.golfCourse_to.rect.y - this.golfCourse_to.rect.height / 4.0,
          //   width: this.golfCourse_to.rect.x + this.golfCourse_to.rect.width / 1.0,
          //   height: this.golfCourse_to.rect.x + this.golfCourse_to.rect.height / 1.0,
          // };
          // this.infiniteCanvas.show_rect(rect__makeshift);

        }


      }
    </script>
    <!-- <script>
      setTimeout(() => {    //SHU: wait for mathjax to finish loading
        // const golfGame1 = GolfGame1.defaultInstance(infiniteCanvas);
        // const golfGame1 = GolfGame1.debugInstance(infiniteCanvas);
        const golfGame1 = GolfGame1.seriousInstance(infiniteCanvas);        //golf
      }, 1000);
    </script> -->



    <script>

      class GMABChallenge {
        constructor(a, b, arr_operators) {

        }

        isPossible() {

        }

        hasPeriodicSolution() {

        }

      }

      class GMABPath {
        constructor(a, b, st) {

        }

        isPeriodic() {

        }

        getLength() {

        }


      }

      class LasagnaTreeNursery {
        constructor(operators) {
          this.operators = operators;
        }

        treeOfDepth(root, depth) {    //mathNode, gmOperator, mathNode, ...

        }

      }

      class GMItem {
        constructor(type, content, name, description, specs = {}) {
          this.type = type;
          this.content = content;
          this.name = name;
          this.description = description;
          this.specs = specs;     //specific behavior (for example: does not accept symbolic input params)
        }

        clone() {
          var outItem;

          outItem = new GMItem();
          Object.assign(outItem, this);
          outItem.content = this.content.cloneDeep();

          return outItem;
        }

        static value(content, name, description, specs = {}) {
          const type = "value";
          const item = new GMItem(type, content, name, description, specs);
          return item;
        }

        static operator(content, name, description, specs = {}) {
          const type = "operator";
          const item = new GMItem(type, content, name, description, specs);
          return item;
        }

      }

      class GMOperatorGroup {

        constructor(arr_gm_operator) {

        }

      }

      class GMMaker {

        static createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, nb_iter) {
          var outItem;

          const arr_index = [...new Array(nb_iter).keys()];

          const mathNode__initial = gmItem__initial.content;

          const mathNode__initial_clone = mathNode__initial.cloneDeep();
          mathNode__initial_clone.autoSimplify = mathNode__initial.autoSimplify;

          const mathNode__target = arr_index.reduce((acc, x) => {

            const node_a = acc;

            const gmItem_operator = Utils.randomElementInArray(arr_gmItem_operator);

            // const operatorNodeFactoryFunc = gmItem_operator.content;
            const operatorNodeFactoryFunc = gmItem_operator.specs.funcWrapper.func;

            function operateOn(mathNode) {
              var outMathNode;

              switch (mathNode.type) {
                case "RelationalNode":
                  {
                    outMathNode = mathNode.clone();
                    outMathNode.params = outMathNode.params.map((mathNode_child, i) => {
                      return operateOn(mathNode_child);
                    });
                  }
                  break;
                default:
                  {
                    outMathNode = operatorNodeFactoryFunc(mathNode);

                    outMathNode = math.simplify(outMathNode);
                    // outMathNode = Simplifier.simplify(outMathNode);

                    // outMathNode = Simplifier.simplify_top_layer(outMathNode);
                    // outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);
                  }
                  break;
              }

              outMathNode.autoSimplify = mathNode.autoSimplify;
              outMathNode.isEquation = mathNode.isEquation;

              return outMathNode;
            }

            const node_op = operateOn(node_a);

            return node_op;
          }, mathNode__initial_clone);

          outItem = GMItem.value(mathNode__target, "target", "");

          return outItem;
        }


      }


    </script>


    <script>
      class GolfGame__Endless_Practice {

        constructor(infiniteCanvas) {
          this.infiniteCanvas = infiniteCanvas;

          //create golfCourse
          const golfCourseConfig = GolfCourseConfig.template_challenge_with_placeholders();
          // const golfCourseConfig = GolfCourseConfig.template_challenge__fraction_add();

          const golfCourse = new GolfCourse(infiniteCanvas, golfCourseConfig);
          this.golfCourse = golfCourse;

          //prepare golf course
          this.prepareGolfCourse(golfCourse);

          //setup step generator
          //numbers
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance1(infiniteCanvas, golfCourse, stepGeneratorFunc);
          //litterals
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance2(infiniteCanvas, golfCourse, stepGeneratorFunc);
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance3(infiniteCanvas, golfCourse, stepGeneratorFunc);
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance4(infiniteCanvas, golfCourse, stepGeneratorFunc); //broken

          //fractions
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__frac_to_one(infiniteCanvas, golfCourse, stepGeneratorFunc);
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__one_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc);
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__frac_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc);
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__frac_to_frac__decomp(infiniteCanvas, golfCourse, stepGeneratorFunc);
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__frac_to_frac__decomp_simple(infiniteCanvas, golfCourse, stepGeneratorFunc);


          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__one_to_frac__decomp(infiniteCanvas, golfCourse, stepGeneratorFunc);
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__one_to_frac__mixed(infiniteCanvas, golfCourse, stepGeneratorFunc);


          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice__frac_add.randomInstance__frac_add(infiniteCanvas, golfCourse, stepGeneratorFunc);

          //equations
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__equation_1(infiniteCanvas, golfCourse, stepGeneratorFunc);

          //litexp writing
          const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__litexp_writing_1(infiniteCanvas, golfCourse, stepGeneratorFunc);


          //create first step
          // const step = GolfGameStep__Endless_Practice.randomInstance1(infiniteCanvas, golfCourse);
          const step = stepGeneratorFunc();

          //start game
          step.start();
        }

        prepareGolfCourse(golfCourse) {

          const infiniteCanvas = this.infiniteCanvas;

          //clear
          //nothing to clear

          //add "Impossible" button
          {
            const rect_rel__button = {
              l: 0.80,
              r: 0.90,
              t: 0.02,
              b: 0.08,
            };
            const trueRect__button = Geometry.rectForRectRel(golfCourse.rect, rect_rel__button);

            const icObj__button = infiniteCanvas.createIcButton(trueRect__button);
            infiniteCanvas.addIcObject(icObj__button);

            golfCourse.components["button_impossible"] = {
              icObj: icObj__button,
            };

          }



          if (golfCourse.components["hole"]) {
            const icObj__hole = golfCourse.components["hole"].icObj;

            const icObj__facade = icObj__hole.parts["facade"];
            const icObj__touchSlot = icObj__hole.parts["touchSlot"];

            // logger.log("icObj__facade", icObj__facade);
            // icObj__facade.originX = "right";
            // icObj__facade.fill = "blue";
            // logger.log("icObj__facade", icObj__facade);

            const rep_free__hole = infiniteCanvas.getRepresented(icObj__hole.id).r_free();
            const rep_free__facade = rep_free__hole.parts.facade;
            const rep_free__touchSlot = rep_free__hole.parts.touchSlot;

            rep_free__hole.compositeConfig[rep_free__facade.id].isMobile = true;
            rep_free__hole.compositeConfig[rep_free__touchSlot.id].isMobile = true;


            rep_free__facade.originX = "right";
            rep_free__facade.position = {
              x: rep_free__facade.position.x,
              y: rep_free__facade.position.y - 150,
            };

            rep_free__touchSlot.position = {
              x: rep_free__touchSlot.position.x,
              y: rep_free__touchSlot.position.y + 100,
            };


            rep_free__hole.compositeConfig[rep_free__facade.id].isMobile = false;
            rep_free__hole.compositeConfig[rep_free__touchSlot.id].isMobile = false;


          }

        }

        // static random_challengeMathNodeConfig() {
        //   logger.log("random_challengeMathNodeConfig");
        //
        //   const mathNode__initial = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
        //   mathNode__initial.autoSimplify = true;
        //
        //   const mathNode__target  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
        //
        //   // const min__nb_operators = 2;
        //   // const max__nb_operators = 5;
        //   // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
        //   const nb_operators = 4;
        //
        //   const arr_operatorNodeFunc = [...new Array(nb_operators).keys()].map(index => {
        //     const operatorNodeFunc = random_operatorNodeFactoryFunc_binary(["ConstantNode"]);
        //     return operatorNodeFunc;
        //   });
        //
        //   const mathNodeConfig = {
        //     initial: mathNode__initial,
        //     target : mathNode__target,
        //     operatorFuncs: arr_operatorNodeFunc,
        //   };
        //
        //   return mathNodeConfig;
        // }

        static random_challengeGMItemConfig(range_initial, range_target) {
          // logger.log("random_challengeGMItemConfig");

          // const mathNode__initial = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
          const mathNode__initial = random_constantNode(range_initial);
          mathNode__initial.autoSimplify = true;
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");

          // const mathNode__target  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
          const mathNode__target = random_constantNode(range_target);

          const gmItem__target = GMItem.value(mathNode__target, "target", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: -10,
                  max: +10,
                },
              },
            };

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams);
            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const gmItem__operator = GMItem.operator(func, name, "");
            return gmItem__operator;
          });

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,
            operators: arr_gmItem_operator,
          };

          return gmItemConfig;
        }

        static random_challengeGMItemConfig__x_to_expr() {
          // logger.log("random_challengeGMItemConfig__x_to_expr");

          const mathNode__initial = new math.SymbolNode("x");
          // mathNode__initial.autoSimplify = true;
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: -10,
                  max: +10,
                },
              },
            };

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams);
            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const gmItem__operator = GMItem.operator(func, name, "");
            return gmItem__operator;
          });


          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, 4);

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,
            operators: arr_gmItem_operator,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__x_to_expr__shuffled() {
          // logger.log("random_challengeGMItemConfig__x_to_expr__shuffled");

          const mathNode__initial = new math.SymbolNode("y");
          // mathNode__initial.autoSimplify = true;
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: -10,
                  max: +10,
                },
              },
              isShuffled: true,
            };

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams);
            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const gmItem__operator = GMItem.operator(func, name, "");
            return gmItem__operator;
          });


          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, 4);

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,
            operators: arr_gmItem_operator,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__expr_to_x() {
          // logger.log("random_challengeGMItemConfig__expr_to_x");

          const mathNode__target = new math.SymbolNode("x");
          // mathNode__initial.autoSimplify = true;
          const gmItem__target = GMItem.value(mathNode__target, "target", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: -10,
                  max: +10,
                },
              },
            };

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams);
            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };
            const gmItem__operator = GMItem.operator(func, name, "", specs);
            return gmItem__operator;
          });

          const depth__initial = 4;
          // const depth__initial    = 10;

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__target, arr_gmItem_operator, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator__inverse = GMItem.operator(func, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            // operators:  arr_gmItem_operator,
            operators: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        //fractions

        static random_challengeGMItemConfig__frac_to_one() {
          // logger.log("random_challengeGMItemConfig__frac_to_one");

          // const mathNode__target = new math.SymbolNode("x");
          const mathNode__target = new math.ConstantNode(1);
          // mathNode__initial.autoSimplify = true;
          const gmItem__target = GMItem.value(mathNode__target, "target", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const arr_op = [
              op_multiply,
              op_divide,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            // const func_decorated = function(mathNode_in) {
            //   logger.log("func_decorated, mathNode_in", mathNode_in);
            //   var outMathNode;
            //
            //   //legacy
            //   outMathNode = func(mathNode_in);
            //
            //   //decoration
            //   outMathNode = Simplifier.simplify_fraction(outMathNode);
            //   logger.log("func_decorated, outMathNode", outMathNode);
            //
            //
            //   return outMathNode;
            // };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(func, name, "", specs);
            return gmItem__operator;
          });

          const depth__initial = 4;
          // const depth__initial    = 10;

          const gmItem__initial_seed = gmItem__target.clone();
          gmItem__initial_seed.content.autoSimplify = true;
          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial_seed, arr_gmItem_operator, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator__inverse = GMItem.operator(func_decorated, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            // operators:  arr_gmItem_operator,
            operators: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__one_to_frac() {
          // logger.log("random_challengeGMItemConfig__one_to_frac");

          const mathNode__initial = new math.ConstantNode(1);
          mathNode__initial.autoSimplify = true;
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const arr_op = [
              op_multiply,
              op_divide,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(func_decorated, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator__inverse = GMItem.operator(func_decorated, name, "", specs);

            return gmItem__operator__inverse;
          });


          const depth__target = 4;

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const mathNode__target = gmItem__target.content;
          mathNode__target.autoSimplify = true;


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__frac_to_frac() {
          // logger.log("random_challengeGMItemConfig__one_to_frac");

          const mathNode__one = new math.ConstantNode(1);
          mathNode__one.autoSimplify = true;
          const gmItem__one = GMItem.value(mathNode__one, "one", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const arr_op = [
              op_multiply,
              op_divide,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(func_decorated, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator__inverse = GMItem.operator(func_decorated, name, "", specs);

            return gmItem__operator__inverse;
          });


          const depth__initial = 4;

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__inverse, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;


          const depth__target = 4;

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const mathNode__target = gmItem__target.content;
          mathNode__target.autoSimplify = true;


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__frac_to_frac__decomp() {
          // logger.log("random_challengeGMItemConfig__one_to_frac");

          const mathNode__one = new math.ConstantNode(1);
          mathNode__one.autoSimplify = true;
          const gmItem__one = GMItem.value(mathNode__one, "one", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const arr_op = [
              op_multiply,
              op_divide,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(func_decorated, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator__inverse = GMItem.operator(func_decorated, name, "", specs);

            return gmItem__operator__inverse;
          });


          const depth__initial = 4;

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__inverse, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          gmItem__initial.content = Rewriter.decomposition_product_primes(mathNode__initial);
          mathNode__initial.autoSimplify = true;


          const depth__target = 4;

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const mathNode__target = gmItem__target.content;
          gmItem__target.content = Rewriter.decomposition_product_primes(mathNode__target);
          mathNode__target.autoSimplify = true;


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__frac_to_frac__decomp_simple() {
          // logger.log("random_challengeGMItemConfig__one_to_frac");

          const mathNode__one = new math.ConstantNode(1);
          mathNode__one.autoSimplify = true;
          const gmItem__one = GMItem.value(mathNode__one, "one", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                // range: {
                //   min: +1,
                //   max: +10,
                // },
                arr: [2, 3, 5, 7],
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const arr_op = [
              op_multiply,
              op_divide,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(func_decorated, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator__inverse = GMItem.operator(func_decorated, name, "", specs);

            return gmItem__operator__inverse;
          });


          const depth__initial = 4;

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__inverse, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          gmItem__initial.content = Rewriter.decomposition_product_primes(mathNode__initial);
          mathNode__initial.autoSimplify = true;


          const depth__target = 4;

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const mathNode__target = gmItem__target.content;
          gmItem__target.content = Rewriter.decomposition_product_primes(mathNode__target);
          mathNode__target.autoSimplify = true;


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__frac_to_frac__letters() {
          // logger.log("random_challengeGMItemConfig__one_to_frac");

          const mathNode__one = new math.ConstantNode(1);
          mathNode__one.autoSimplify = true;
          const gmItem__one = GMItem.value(mathNode__one, "one", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const arr_op = [
              op_multiply,
              op_divide,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(func_decorated, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator__inverse = GMItem.operator(func_decorated, name, "", specs);

            return gmItem__operator__inverse;
          });


          const depth__initial = 4;

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__inverse, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          gmItem__initial.content = Rewriter.decomposition_product_primes(mathNode__initial);
          mathNode__initial.autoSimplify = true;


          const depth__target = 4;

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const mathNode__target = gmItem__target.content;
          gmItem__target.content = Rewriter.decomposition_product_primes(mathNode__target);
          mathNode__target.autoSimplify = true;


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__frac_add() {
          // logger.log("random_challengeGMItemConfig__one_to_frac");

          // const mathNode__one = new math.ConstantNode(1);
          // mathNode__one.autoSimplify = true;
          // const gmItem__one = GMItem.value(mathNode__one, "one", "");

          function createInitialGMItem(index) {

            const mathNode__numerator = new math.ConstantNode(1);
            const value__denominator = Utils.randomElementInArray([2, 3, 4, 5, 6, 7, 8, 9]);
            const mathNode__denominator = new math.ConstantNode(value__denominator);

            const mathNode__initial = new math.OperatorNode("/", "divide", [mathNode__numerator, mathNode__denominator]);

            const gmItem__initial = GMItem.value(mathNode__initial, "initial_" + index, "");
            gmItem__initial.content = Rewriter.decomposition_product_primes(mathNode__initial);
            gmItem__initial.content.autoSimplify = true;

            return gmItem__initial;
          }

          const nb_initial = 2;
          const arr_gmItem_initial = [...Array(nb_initial).keys()].map(createInitialGMItem);
          const arr_mathNode_initial = arr_gmItem_initial.map(gmItem => gmItem.content);

          const arr_factor = [2, 3, 5, 7];
          const arr_gmItem_operator = arr_factor.map(factor => {

            const op = Operator.fromString_binary("x");
            const node_b = new math.ConstantNode(factor);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_fraction(outMathNode);
              // outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(func_decorated, name, "", specs);
            return gmItem__operator;
          });

          const depth__target = 4;

          const mathNode__target = new math.OperatorNode("+", "add", arr_mathNode_initial);
          const gmItem__target = GMItem.value(mathNode__target, "target", "");
          // gmItem__target.content = Rewriter.decomposition_product_primes(mathNode__target);
          // mathNode__target.autoSimplify = true;


          const gmItemConfig = {
            initial: arr_gmItem_initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            // operators__inverse:  arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }

        //equations

        static random_challengeGMItemConfig__equation_1() {
          logger.log("random_challengeGMItemConfig__equation_1");

          const mathNode__left = new math.SymbolNode("x");

          // const mathNode__right  = new math.ConstantNode(3);
          const mathNode__right = random_terminal_mathNode_withType_inArr(["ConstantNode"]);

          const mathNode__target = new math.RelationalNode(["equal"], [mathNode__left, mathNode__right]);
          mathNode__target.isEquation = true;

          const gmItem__target = GMItem.value(mathNode__target, "target", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const op_add = Operator.fromString_binary("+");
            const op_subtract = Operator.fromString_binary("-");

            const arr_op = [
              op_multiply,
              op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          const depth__initial = 4;
          // const depth__initial    = 10;

          const gmItem__initial_seed = gmItem__target.clone();
          gmItem__initial_seed.content.autoSimplify = true;
          gmItem__initial_seed.content.isEquation = true;

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial_seed, arr_gmItem_operator, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;

          logger.log("gmItem__initial", gmItem__initial);

          // const mathNode__initial = new math.ConstantNode(79);
          // const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");



          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_full(outMathNode);
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator__inverse,
            operators__inverse: arr_gmItem_operator,
          };

          return gmItemConfig;
        }



        //equations

        static random_challengeGMItemConfig__litexp_writing_1() {
          logger.log("random_challengeGMItemConfig__litexp_writing_1");

          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const op_add = Operator.fromString_binary("+");
            const op_subtract = Operator.fromString_binary("-");

            const arr_op = [
              op_multiply,
              op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_equation(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          const depth__target = 4;
          // const depth__target = 10;

          const mathNode__initial = new math.SymbolNode("x");
          const gmItem__initial = GMItem.value(mathNode__initial, "target", "");
          logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          // mathNode__target.autoSimplify = true;



          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_full(outMathNode);
              // outMathNode = Simplifier.simplify_equation(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator__inverse,
            operators__inverse: arr_gmItem_operator,
          };

          return gmItemConfig;
        }

      }





      class GolfGameStep__Endless_Practice {

        constructor(infiniteCanvas, golfStepConfig, golfCourse, stepGeneratorFunc) {

          this.infiniteCanvas = infiniteCanvas;
          // this.golfStepConfig = golfStepConfig;
          this.golfCourse = golfCourse;

          this.stepGeneratorFunc = stepGeneratorFunc;

          this.configure(golfStepConfig);

        }

        static randomInstance1(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          // const game = this;
          // const challengeMathNodeConfig = GolfGame__Endless_Practice.random_challengeMathNodeConfig();
          // const stepConfig = {
          //   challengeMathNodeConfig: challengeMathNodeConfig,
          //   // game: game,
          // };

          const range_initial = { min: 0, max: 10, step: 1 };
          const range_target = { min: -100, max: 100, step: 1 };

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig(range_initial, range_target);
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance2(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          // const game = this;
          // const challengeMathNodeConfig = GolfGame__Endless_Practice.random_challengeMathNodeConfig();
          // const stepConfig = {
          //   challengeMathNodeConfig: challengeMathNodeConfig,
          //   // game: game,
          // };

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__x_to_expr();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance3(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          // const game = this;
          // const challengeMathNodeConfig = GolfGame__Endless_Practice.random_challengeMathNodeConfig();
          // const stepConfig = {
          //   challengeMathNodeConfig: challengeMathNodeConfig,
          //   // game: game,
          // };

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__x_to_expr__shuffled();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance4(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          // const game = this;
          // const challengeMathNodeConfig = GolfGame__Endless_Practice.random_challengeMathNodeConfig();
          // const stepConfig = {
          //   challengeMathNodeConfig: challengeMathNodeConfig,
          //   // game: game,
          // };

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__expr_to_x();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        //fractions

        static randomInstance__frac_to_one(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_one();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static randomInstance__one_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__one_to_frac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static randomInstance__frac_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_frac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance__frac_to_frac__decomp(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_frac__decomp();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance__frac_to_frac__decomp_simple(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_frac__decomp_simple();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance__frac_to_frac__letters(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_frac__letters();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        // static randomInstance__frac_add(infiniteCanvas, golfCourse, stepGeneratorFunc) {
        //
        //   const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_add();
        //   const stepConfig = {
        //     challengeGMItemConfig: challengeGMItemConfig,
        //     challengeType: "frac_add",
        //   };
        //
        //   const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);
        //
        //   return step;
        // }


        static randomInstance__one_to_frac__decomp(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_frac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance__one_to_frac__mixed(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_frac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        //equations

        static randomInstance__equation_1(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__equation_1();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        //litexp

        static randomInstance__litexp_writing_1(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__litexp_writing_1();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }



        configure(golfStepConfig) {
          // this.par = golfStepConfig.par;
          this.nb_attempts = 0;

          // this.challengeMathNodeConfig = golfStepConfig.challengeMathNodeConfig;
          this.challengeGMItemConfig = golfStepConfig.challengeGMItemConfig;
          this.challengeType = golfStepConfig.challengeType;
        }

        start() {
          const golfCourse = this.golfCourse;
          const stepGeneratorFunc = this.stepGeneratorFunc;

          this.invest(golfCourse);

          this.possess(golfCourse);

          this.recurse(stepGeneratorFunc);

          // this.infiniteCanvas.redrawCanvas(RedrawOccasion.forceRedraw);   //SHU666:pour éviter les bugs de non rafraîchissement des teXFObj //ce n'est pas la panacée
        }

        end() {
          // this.golfCourse.fillHole();
          const step = this;
          const infiniteCanvas = this.infiniteCanvas;

          step.rep_free__hole.parts.touchSlot.fill = "yellow";

          //destroy ball
          //end curses
          // step.rep_free__ball.curse_bornAgain_end();
          // step.rep_free__ball.curse_greenMouse_end();
          step.rep_free__ball.parts.facade.curse_greenMouse_end();


          //remove "die" hooks listeners
          step.rep_free__ball.will["die"].listeners = [];

          //remove
          step.rep_free__ball.im_dying_now = true;
          step.rep_free__ball.parts.facade.im_dying_now = true;
          step.rep_free__ball.parts.contactArea.im_dying_now = true;

          // infiniteCanvas.removeRepresented(step.rep_free__ball.represented);

          //remove all listeners
          const touchSlot__rep_free = step.rep_free__hole.parts.touchSlot;
          const touchSlotEngine = touchSlot__rep_free.engine;
          touchSlotEngine.awoken.did["touch"].off(this.listener_targetDidTouch);

        }

        addNewBall() {
          const step = this;
          const infiniteCanvas = this.infiniteCanvas;
          const golfCourse = this.golfCourse;


          const icObj__tee = golfCourse.components["tee"].icObj;
          const trueRect__ball = {
            x: icObj__tee.position.x,
            y: icObj__tee.position.y,
            width: 50,
            height: 50,
          };

          // const value = 0;
          //debug
          const mathNode__initial = step.challengeGMItemConfig.initial.content;
          // const value = mathNode__initial.value;

          // const icObj = infiniteCanvas.createIcBornAgainGreenMouseBox(trueRect__ball, mathNode__initial);
          const icObj = infiniteCanvas.createIcGreenMouseBox(trueRect__ball, mathNode__initial);

          // const icObj = infiniteCanvas.createIcMathNode(trueRect__ball.x, trueRect__ball.y, mathNode__initial);

          infiniteCanvas.addIcObject(icObj);

          const rep_free__ball = infiniteCanvas.getRepresented(icObj.id).r_free();
          Hooker.installHooks(rep_free__ball, "die");
          rep_free__ball.did["die"].on(() => {
            // logger.log("did die");

            rep_free__ball.parts.facade.im_dying_now = true;
            rep_free__ball.parts.contactArea.im_dying_now = true;

            step.addNewBall();
          });

          step.rep_free__ball = rep_free__ball;
        }

        invest(golfCourse) {

          const step = this;
          const infiniteCanvas = this.infiniteCanvas;

          //clear: remove objects



          //furnish: add objects
          {
            const infiniteCanvas = this.infiniteCanvas;

            //add label/value: score
            function addLabel_score() {
              const rect__score = golfCourse.rect;
              rect__score.width = 300;
              rect__score.height = 150;

              const string__score = "score:";
              const value__score = 0;

              const icObj__score = infiniteCanvas.createIcLabelValue(rect__score, string__score, value__score);
              icObj__score.zIndex = 200;

              infiniteCanvas.addIcObject(icObj__score);

              const rep_free__score_valueLabel = infiniteCanvas.getRepresented(icObj__score.id).r_free();
              step.rep_free__score_valueLabel = rep_free__score_valueLabel;
              step.rep_free__score_value = rep_free__score_valueLabel.parts["value"];
            }
            // addLabel_score();

            //add label/value: par
            function addLabelValue_par() {
              const rect__par = {
                x: step.rep_free__score_valueLabel.position.x,
                y: step.rep_free__score_valueLabel.position.y + 120,
                width: 300,
                height: 150,
              };

              const string__par = "par:";
              const value__par = step.par;

              const icObj__par = infiniteCanvas.createIcLabelValue(rect__par, string__par, value__par);
              icObj__par.zIndex = 201;

              infiniteCanvas.addIcObject(icObj__par);

              const rep_free__par_valueLabel = infiniteCanvas.getRepresented(icObj__par.id).r_free();
              step.rep_free__par_valueLabel = rep_free__par_valueLabel;
              step.rep_free__par_value = rep_free__par_valueLabel.parts["value"];

              setTimeout(() => {
                step.rep_free__par_value.position = {
                  x: step.rep_free__score_value.position.x,
                  y: step.rep_free__par_value.position.y,
                };
              }, 20);   //SHU TODO: remove this ugliness
            }
            // addLabelValue_par();


            //add ball:
            step.addNewBall();


            //add button: restart


            //add button: impossible

          }


          //invest: "this is mine now"
          {
            // step.rep_free__ball = golfCourse.components["ball"].icObj;
            step.rep_free__hole = golfCourse.components["hole"].icObj;
          }


          //employ: now you do X
          //initial
          const mathNode__initial = step.challengeGMItemConfig.initial.content;
          step.rep_free__ball.mathNode = mathNode__initial;
          // logger.log("mathNode__initial", mathNode__initial);



          //target
          {
            const mathNode__target = step.challengeGMItemConfig.target.content;
            step.rep_free__hole.parts.touchSlot.fill = "";

            //core
            // step.rep_free__hole.parts.facade.mathNode = mathNode__target;
            // step.rep_free__hole.parts.core.mathNode = mathNode__target;

            //facade
            /*
            // const mathNode__left  = new math.SymbolNode("x");
            // const mathNode__right = new math.SymbolNode(" ?");
            // step.rep_free__hole.parts.facade.mathNode = new math.RelationalNode(["equal"], [mathNode__left, mathNode__right]);
            */
            step.rep_free__hole.parts.facade.mathNode = mathNode__target;

            step.rep_free__hole.parts.facade.originX = "center";


            //touchSlot
            const rep_free__touchSlot = step.rep_free__hole.parts.touchSlot;

            const canTouchFunc_geometryWise = function (above, below, context) {
              // const canTouchFunc = Touch.canTouch;
              const canTouchFunc = Touch2Singleton.sharedInstance().canTouch;

              return canTouchFunc(above, below);
            };

            const canTouchFunc_valueWise = function (icObj) {
              var outBool;

              if (icObj.cType == "gm_box") {

                /* //equations
                // const mathNode__core = step.rep_free__hole.parts.core.mathNode;
                // const isSameRightMember = icObj.parts.facade.mathNode.params[1].value == mathNode__core.params[1].value;
                // outBool = isSameRightMember;
                */

                function isSameExpression(mathNode_1, mathNode_2) {
                  var outBool;

                  var expr__mathNode_1 = mathNode_1.toString();
                  expr__mathNode_1 = expr__mathNode_1.replaceAll("×", "*");
                  var expr__mathNode_2 = mathNode_2.toString();
                  expr__mathNode_2 = expr__mathNode_2.replaceAll("×", "*");

                  const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
                  logger.log("expr__equality", expr__equality);
                  const algebrite_result = Algebrite.run(expr__equality);

                  outBool = (algebrite_result == true);

                  return outBool;
                }

                const mathNode__icObj = icObj.parts.facade.mathNode;
                logger.log("mathNode__icObj", mathNode__icObj);
                const mathNode__hole = step.rep_free__hole.parts.facade.mathNode;
                logger.log("mathNode__hole", mathNode__hole);

                const isSameExpression_ = isSameExpression(mathNode__icObj, mathNode__hole);
                outBool = isSameExpression_;

              } else {
                outBool = false;
              }

              return outBool;
            };

            const canTouchFuncs = {
              "geometry": canTouchFunc_geometryWise,
              "value": canTouchFunc_valueWise,
            };

            const canTouchFunc_allWise = (above, below, context) => {
              return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
                const canTouch_xWise = canTouchFunc_xWise(above, below, context);
                console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
                return acc && canTouch_xWise;
              }, true);
            };

            const canTouchFunc = canTouchFunc_allWise;

            rep_free__touchSlot.touchSlotConfig.canTouchFunc = canTouchFunc;

            const transformationFunc = function (icObj) {
              var transformationOutput;

              transformationOutput = new TransformationOutput("old", icObj, icObj);

              return transformationOutput;
            };
            rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc;
          }


          //operators
          {
            const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_operator");
            const arr_rep_free__operator = arr_gm_operator.map((gm_operator, i) => {
              const icObj__rep_free = gm_operator.icObj;
              return icObj__rep_free;
            });
            const arr_gmItem_operator = step.challengeGMItemConfig.operators;

            const zip = (a, b) => a.map((k, i) => [k, b[i]]);

            const arr_zipped = zip(arr_rep_free__operator, arr_gmItem_operator);

            arr_zipped.forEach(([rep_free__operator, gmItem_operator], i) => {


              //touchSlot
              const rep_free__touchSlot = rep_free__operator.parts["touchSlot"];

              const transformationFunc = gmItem_operator.content;
              const transformationFunc__decorated = function (icObj) {
                var transformationOutput;

                const icObj__new = icObj.clone();
                // logger.log("outIcObj", outIcObj);

                // if(icObj__new.mathNode) {
                //   delete icObj__new.mathNode;     //SHU666: true sadness
                // }

                if (icObj.cType == "gm_box") {
                  // logger.log("gm_box");

                  const facade = icObj.parts.facade;
                  // outIcObj.parts.facade.mathNode = mathNodeTransformationFunc(facade.mathNode);
                  const transformationOutput = transformationFunc(facade);
                  const facade__new = transformationOutput.value;
                  icObj__new.parts.facade.mathNode = facade__new.mathNode;
                }

                transformationOutput = new TransformationOutput("mutated", icObj__new, icObj);

                return transformationOutput;
              };
              rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc__decorated;


              //facade
              const rep_free__facade = rep_free__operator.parts["facade"];
              rep_free__facade.text = gmItem_operator.name;

              rep_free__facade.originX = "center";

            });
          }


          //operators__inverse
          {
            const arr_gm_operator__inverse = Object.values(golfCourse.components).filter(component => component.type == "placeholder");
            const arr_rep_free__operator__inverse = arr_gm_operator__inverse.map((gm_operator, i) => {
              const icObj__rep_free = gm_operator.icObj;
              return icObj__rep_free;
            });
            const arr_gmItem_operator__inverse = step.challengeGMItemConfig.operators__inverse;

            const zip = (a, b) => a.map((k, i) => [k, b[i]]);

            const arr_zipped = zip(arr_rep_free__operator__inverse, arr_gmItem_operator__inverse);

            arr_zipped.forEach(([rep_free__operator, gmItem_operator], i) => {


              //touchSlot
              const rep_free__touchSlot = rep_free__operator.parts["touchSlot"];

              const transformationFunc = gmItem_operator.content;
              const transformationFunc__decorated = function (icObj) {
                var transformationOutput;

                const icObj__new = icObj.clone();
                // logger.log("outIcObj", outIcObj);

                // if(icObj__new.mathNode) {
                //   delete icObj__new.mathNode;     //SHU666: true sadness
                // }

                if (icObj.cType == "gm_box") {
                  // logger.log("gm_box");

                  const facade = icObj.parts.facade;
                  // outIcObj.parts.facade.mathNode = mathNodeTransformationFunc(facade.mathNode);
                  const transformationOutput = transformationFunc(facade);
                  const facade__new = transformationOutput.value;
                  icObj__new.parts.facade.mathNode = facade__new.mathNode;
                }

                transformationOutput = new TransformationOutput("mutated", icObj__new, icObj);

                return transformationOutput;
              };
              rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc__decorated;


              //facade
              const rep_free__facade = rep_free__operator.parts["facade"];
              rep_free__facade.text = gmItem_operator.name;

              rep_free__facade.originX = "center";

            });
          }




          // step.infiniteCanvas.redrawCanvas(RedrawOccasion.forceRedraw);   //SHU666:pour éviter les bugs de non rafraîchissement des teXFObj //ce n'est pas la panacée
        }

        possess(golfCourse) {
          this.initializeCompletionListeners();

          this.setupAttemptListeners(golfCourse);

          this.setupCompletionTrigger(golfCourse);
          this.addCompletionListener(golfCourse);
        }

        recurse(stepGeneratorFunc) {
          const step = this;

          const segueConfig = {};
          const step_from = step;

          const golfCourse_to = step_from.golfCourse;

          const segue = new GolfGameSegue__Endless_Practice(infiniteCanvas, segueConfig, step_from, golfCourse_to, stepGeneratorFunc);

          this.segue = segue;
        }


        initializeCompletionListeners() {
          // this.nb_attempts = 0;
          this.arr_attempt = [];

          this.listeners_completed = [];

          this.onCompleted = (listener) => {
            this.listeners_completed.push(listener);
          };
          this.offCompleted = (listener) => {
            this.listeners_completed = Utils.arrayByRemovingElement(this.listeners_completed, listener);
          };
          this.nowCompleted = () => {
            this.listeners_completed.forEach((listener, i) => {
              listener(this);
            });
          };
        }

        setupAttemptListeners(golfCourse) {   //SHU: this is where BigBrother sneaked in from

          const step = this;

          // function waitForNewAttempt() {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   const createAttemptFunc = () => {
          //
          //       const attempt = new GolfStepAttempt();
          //
          //       step.arr_attempt.push(attempt);
          //
          //       ball__rep_free.offHold(createAttemptFunc);
          //   };
          //
          //   ball__rep_free.onHold(createAttemptFunc);
          // }
          //
          // //gm.onHold(create attempt)
          // {
          //   waitForNewAttempt();
          // }
          //
          // //gm.onTouched(add event to attempt)
          // {
          //
          // }
          //
          // //gm.onRelease(finalize attempt)
          // {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   ball__rep_free.onRelease(waitForNewAttempt);
          // }

          //create attempt






          //course use listeners

          function listenToOperatorTouches(icObj__rep_free) {

            const touchSlot__rep_free = icObj__rep_free.parts["touchSlot"];
            // logger.log("touchSlot__rep_free", touchSlot__rep_free);

            const touchSlotEngine = touchSlot__rep_free.engine;

            Hooker.installHooks(touchSlotEngine.awoken, "touch");
            touchSlotEngine.awoken.did["touch"].on((...args) => {
              // logger.log("did touch", ...args);

              // // counter += 1
              // const attempt = step.getCurrentAttempt();
              // logger.log("attempt", attempt);
              // attempt.manoeuvre.nb_touched += 1;
              //
              // //debug
              // step.rep_free__score_value.text = "" + attempt.manoeuvre.nb_touched;



              // const rep_free__curseFacade = step.rep_free__hole.parts.curseFacade;
              const rep_free__curseFacade = step.rep_free__hole.parts.curseFacade;
              if (rep_free__curseFacade != null) {
                const rep_free__facade = step.rep_free__hole.parts.facade;
                rep_free__facade.curse_metamorphosis.curseTrigger.impulse();
              }


            });

          }

          const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_operator");

          arr_gm_operator.forEach((gm_operator, i) => {
            const icObj__rep_free = gm_operator.icObj;
            listenToOperatorTouches(icObj__rep_free);
          });

        }

        setupCompletionTrigger(golfCourse) {

          const targetTouchSlot__rep_free = golfCourse.components["hole"].icObj;

          const touchSlot__rep_free = targetTouchSlot__rep_free.parts["touchSlot"];

          const touchSlotEngine = touchSlot__rep_free.engine;

          Hooker.installHooks(touchSlotEngine.awoken, "touch");
          const listener_targetDidTouch = (...args) => {
            // logger.log("did touch", ...args);

            this.nowCompleted();
          };
          this.listener_targetDidTouch = listener_targetDidTouch;
          touchSlotEngine.awoken.did["touch"].on(listener_targetDidTouch);

        }

        addCompletionListener(golfCourse) {

          const step = this;

          this.listener_onCompleted = (golfStep) => {
            // console.log("step, onCompleted", golfStep);
            // logger.log("step, onCompleted", golfStep);

            /*
            const score = golfStep.arr_attempts.length;
            golfCourse.mutateIntoScoreLabel(score);
            */

            step.offCompleted(step.listener_onCompleted);
            step.end();

            step.segue.play(golfStep);
          };

          this.onCompleted(this.listener_onCompleted);
        }

        getCurrentAttempt() {
          return this.arr_attempt[this.arr_attempt.length - 1];
        }







      }

      class GolfGameSegue__Endless_Practice {

        constructor(infiniteCanvas, golfSegueConfig, step_from, golfCourse_to, /*step_to = null,*/ stepGeneratorFunc) {
          this.infiniteCanvas = infiniteCanvas;

          this.golfSegueConfig = golfSegueConfig;
          this.configure(golfSegueConfig);

          this.step_from = step_from;

          this.golfCourse_to = golfCourse_to;
          // this.step_to       = step_to;
          this.stepGeneratorFunc = stepGeneratorFunc;
        }

        configure(golfSegueConfig) {

        }

        play(step_from) {
          // logger.log("GolfSegue::play", step_from);

          const golfCourse_to = this.golfCourse_to;

          setTimeout(() => {

            // const position_to = {
            //   x: golfCourse_to.rect.x,
            //   y: golfCourse_to.rect.y,
            // };
            // this.infiniteCanvas.move_to_position(position_to);

            // this.infiniteCanvas.show_rect(golfCourse_to.rect);    //SHU TODO

            const rect__makeshift = {
              x: this.golfCourse_to.rect.x + this.golfCourse_to.rect.width * 0.30,
              y: this.golfCourse_to.rect.y - this.golfCourse_to.rect.height * 0.15,
              width: this.golfCourse_to.rect.width + this.golfCourse_to.rect.width * 0.30 / 1.0,
              height: this.golfCourse_to.rect.height + this.golfCourse_to.rect.height * 0.30 / 1.0,
            };
            this.infiniteCanvas.show_rect(rect__makeshift);


            if (this.step_to == null) {
              // const step = GolfGameStep__Endless_Practice.randomInstance1(infiniteCanvas, golfCourse_to);
              const step = this.stepGeneratorFunc();
              this.step_to = step;
            }
            this.step_to.start();

          }, 500);

        }


      }


      class GolfGameStep__Endless_Practice__frac_add {

        constructor(infiniteCanvas, golfStepConfig, golfCourse, stepGeneratorFunc) {

          this.infiniteCanvas = infiniteCanvas;
          // this.golfStepConfig = golfStepConfig;
          this.golfCourse = golfCourse;

          this.stepGeneratorFunc = stepGeneratorFunc;

          this.configure(golfStepConfig);

        }

        static randomInstance__frac_add(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_add();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
            // challengeType: "frac_add",
          };

          const step = new GolfGameStep__Endless_Practice__frac_add(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }



        configure(golfStepConfig) {
          // this.par = golfStepConfig.par;
          this.nb_attempts = 0;

          // this.challengeMathNodeConfig = golfStepConfig.challengeMathNodeConfig;
          this.challengeGMItemConfig = golfStepConfig.challengeGMItemConfig;
          // this.challengeType = golfStepConfig.challengeType;
        }

        start() {
          const golfCourse = this.golfCourse;
          const stepGeneratorFunc = this.stepGeneratorFunc;

          this.invest(golfCourse);

          this.possess(golfCourse);

          this.recurse(stepGeneratorFunc);

          // this.infiniteCanvas.redrawCanvas(RedrawOccasion.forceRedraw);   //SHU666:pour éviter les bugs de non rafraîchissement des teXFObj //ce n'est pas la panacée
        }

        end() {
          // this.golfCourse.fillHole();
          const step = this;
          const infiniteCanvas = this.infiniteCanvas;

          step.rep_free__hole.parts.touchSlot.fill = "yellow";

          //destroy ball
          const arr_rep_free_ball = [
            step["rep_free__ball" + 0],
            step["rep_free__ball" + 1],
          ];

          arr_rep_free_ball.forEach((rep_free__ball, i) => {

            //end curses
            rep_free__ball.parts.facade.curse_greenMouse_end();

            //remove "die" hooks listeners
            rep_free__ball.will["die"].listeners = [];

            //remove
            rep_free__ball.im_dying_now = true;
            rep_free__ball.parts.facade.im_dying_now = true;
            rep_free__ball.parts.contactArea.im_dying_now = true;
          });

          //remove all listeners
          const touchSlot__rep_free = step.rep_free__hole.parts.touchSlot;
          const touchSlotEngine = touchSlot__rep_free.engine;
          touchSlotEngine.awoken.did["touch"].off(this.listener_targetDidTouch);

        }

        addNewBall(index) {
          const step = this;
          const infiniteCanvas = this.infiniteCanvas;
          const golfCourse = this.golfCourse;

          // logger.log("golfCourse.components", golfCourse.components);
          const name__tee = "tee" + (index + 1);
          const icObj__tee = golfCourse.components[name__tee].icObj;
          const trueRect__ball = {
            x: icObj__tee.position.x,
            y: icObj__tee.position.y,
            width: 50,
            height: 50,
          };

          // const value = 0;
          //debug
          const gmItem__initial = step.challengeGMItemConfig.initial[index];
          const mathNode__initial = gmItem__initial.content;
          // const value = mathNode__initial.value;

          // const icObj = infiniteCanvas.createIcBornAgainGreenMouseBox(trueRect__ball, mathNode__initial);
          const icObj = infiniteCanvas.createIcGreenMouseBox(trueRect__ball, mathNode__initial);

          // const icObj = infiniteCanvas.createIcMathNode(trueRect__ball.x, trueRect__ball.y, mathNode__initial);

          infiniteCanvas.addIcObject(icObj);

          const rep_free__ball = infiniteCanvas.getRepresented(icObj.id).r_free();
          Hooker.installHooks(rep_free__ball, "die");

          const bornAgainFunc = () => {
            logger.log("did die");

            rep_free__ball.parts.facade.im_dying_now = true;
            rep_free__ball.parts.contactArea.im_dying_now = true;

            step.addNewBall(index);
          };
          rep_free__ball.did["die"].on(bornAgainFunc);
          rep_free__ball.bornAgainFunc = bornAgainFunc;

          step["rep_free__ball" + index] = rep_free__ball;
        }

        invest(golfCourse) {

          const step = this;
          const infiniteCanvas = this.infiniteCanvas;

          //clear: remove objects



          //furnish: add objects
          {
            const infiniteCanvas = this.infiniteCanvas;

            //add label/value: score
            function addLabel_score() {
              const rect__score = golfCourse.rect;
              rect__score.width = 300;
              rect__score.height = 150;

              const string__score = "score:";
              const value__score = 0;

              const icObj__score = infiniteCanvas.createIcLabelValue(rect__score, string__score, value__score);
              icObj__score.zIndex = 200;

              infiniteCanvas.addIcObject(icObj__score);

              const rep_free__score_valueLabel = infiniteCanvas.getRepresented(icObj__score.id).r_free();
              step.rep_free__score_valueLabel = rep_free__score_valueLabel;
              step.rep_free__score_value = rep_free__score_valueLabel.parts["value"];
            }
            // addLabel_score();

            //add label/value: par
            function addLabelValue_par() {
              const rect__par = {
                x: step.rep_free__score_valueLabel.position.x,
                y: step.rep_free__score_valueLabel.position.y + 120,
                width: 300,
                height: 150,
              };

              const string__par = "par:";
              const value__par = step.par;

              const icObj__par = infiniteCanvas.createIcLabelValue(rect__par, string__par, value__par);
              icObj__par.zIndex = 201;

              infiniteCanvas.addIcObject(icObj__par);

              const rep_free__par_valueLabel = infiniteCanvas.getRepresented(icObj__par.id).r_free();
              step.rep_free__par_valueLabel = rep_free__par_valueLabel;
              step.rep_free__par_value = rep_free__par_valueLabel.parts["value"];

              setTimeout(() => {
                step.rep_free__par_value.position = {
                  x: step.rep_free__score_value.position.x,
                  y: step.rep_free__par_value.position.y,
                };
              }, 20);   //SHU TODO: remove this ugliness
            }
            // addLabelValue_par();


            //add balls:
            step.addNewBall(0);
            step.addNewBall(1);


            //add button: restart


            //add button: impossible

          }


          //invest: "this is mine now"
          {
            // step.rep_free__ball = golfCourse.components["ball"].icObj;
            step.rep_free__hole = golfCourse.components["hole"].icObj;
          }


          //employ: now you do X
          //initial
          const arr_initial = step.challengeGMItemConfig.initial;
          arr_initial.forEach((gmItem__initial, index) => {
            const mathNode__initial = gmItem__initial.content;
            // logger.log("mathNode__initial", mathNode__initial);
            step["rep_free__ball" + index].mathNode = mathNode__initial;
          });

          //target
          const mathNode__target = step.challengeGMItemConfig.target.content;
          step.rep_free__hole.parts.facade.mathNode = mathNode__target;
          step.rep_free__hole.parts.touchSlot.fill = "";


          //operators
          {
            const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_fractionOne_operator");
            const arr_rep_free__operator = arr_gm_operator.map((gm_operator, i) => {
              const icObj__rep_free = gm_operator.icObj;
              return icObj__rep_free;
            });
            const arr_gmItem_operator = step.challengeGMItemConfig.operators;

            const zip = (a, b) => a.map((k, i) => [k, b[i]]);

            const arr_zipped = zip(arr_rep_free__operator, arr_gmItem_operator);

            arr_zipped.forEach(([rep_free__operator, gmItem_operator], i) => {


              //touchSlot
              const rep_free__touchSlot = rep_free__operator.parts["touchSlot"];

              const mathNodeTransformationFunc = gmItem_operator.content;
              const icObjTransformationFunc = (icObj) => {
                // logger.log("icObjTransformationFunc", icObj);
                var outIcObj;



                outIcObj = icObj.clone();
                // logger.log("outIcObj", outIcObj);

                if (outIcObj.mathNode) {
                  delete outIcObj.mathNode;     //SHU666: true sadness
                }



                if (icObj.cType == "gm_box") {
                  // logger.log("gm_box");

                  const facade = icObj.parts.facade;
                  outIcObj.parts.facade.mathNode = mathNodeTransformationFunc(facade.mathNode);
                }

                // if(icObj.mathNode != null) {
                //   // logger.log("icObj.mathNode", icObj.mathNode);
                //   outIcObj.mathNode = mathNodeTransformationFunc(icObj.mathNode);
                // }

                return outIcObj;
              };
              rep_free__touchSlot.touchSlotConfig.transformationFunc = icObjTransformationFunc;


              //facade
              const rep_free__facade = rep_free__operator.parts["facade"];
              rep_free__facade.text = gmItem_operator.name;

              rep_free__facade.originX = "center";

            });
          }

          //conductive operator
          {
            // rep_free__ball.did["die"].on(bornAgainFunc);
            // rep_free__ball.bornAgainFunc = bornAgainFunc;

            const arr_component_conductive_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_conductive_operator");
            const component__conductive_operator = arr_component_conductive_operator.find(e => true);

            const rep_free__conductive_operator = component__conductive_operator.icObj;

            logger.log("rep_free__conductive_operator", rep_free__conductive_operator);

            const rep_free__dropTouchSlot = rep_free__conductive_operator.parts.platform.parts.dropTouchSlot;

            const transformationFunc__touch = rep_free__dropTouchSlot.touchSlotConfig.transformationFunc__touch;
            const transformationFunc__touch__decorated = (icObj) => {
              var transformationOutput;

              logger.log("rep_free__dropTouchSlot, touch__decorated", icObj);

              // const rep_free__ball = icObj;
              // const bornAgainFunc = rep_free__ball.bornAgainFunc;
              // rep_free__ball.did["die"].off(bornAgainFunc);

              transformationOutput = transformationFunc__touch(icObj);

              return transformationOutput;
            };
            rep_free__dropTouchSlot.touchSlotConfig.transformationFunc__touch = transformationFunc__touch__decorated;

            const transformationFunc__untouch = rep_free__dropTouchSlot.touchSlotConfig.transformationFunc__untouch;
            const transformationFunc__untouch__decorated = (icObj) => {
              var transformationOutput;

              logger.log("rep_free__dropTouchSlot, untouch__decorated", icObj);

              transformationOutput = transformationFunc__untouch(icObj);

              // const rep_free__ball = icObj;
              // const bornAgainFunc = rep_free__ball.bornAgainFunc;
              // rep_free__ball.did["die"].on(bornAgainFunc);

              return transformationOutput;
            };
            rep_free__dropTouchSlot.touchSlotConfig.transformationFunc__untouch = transformationFunc__untouch__decorated;


          }


        }

        possess(golfCourse) {
          this.initializeCompletionListeners();

          this.setupAttemptListeners(golfCourse);

          this.setupCompletionTrigger(golfCourse);
          this.addCompletionListener(golfCourse);
        }

        recurse(stepGeneratorFunc) {
          const step = this;

          const segueConfig = {};
          const step_from = step;

          const golfCourse_to = step_from.golfCourse;

          const segue = new GolfGameSegue__Endless_Practice(infiniteCanvas, segueConfig, step_from, golfCourse_to, stepGeneratorFunc);

          this.segue = segue;
        }


        initializeCompletionListeners() {
          // this.nb_attempts = 0;
          this.arr_attempt = [];

          this.listeners_completed = [];

          this.onCompleted = (listener) => {
            this.listeners_completed.push(listener);
          };
          this.offCompleted = (listener) => {
            this.listeners_completed = Utils.arrayByRemovingElement(this.listeners_completed, listener);
          };
          this.nowCompleted = () => {
            this.listeners_completed.forEach((listener, i) => {
              listener(this);
            });
          };
        }

        setupAttemptListeners(golfCourse) {   //SHU: this is where BigBrother sneaked in from

          const step = this;

          // function waitForNewAttempt() {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   const createAttemptFunc = () => {
          //
          //       const attempt = new GolfStepAttempt();
          //
          //       step.arr_attempt.push(attempt);
          //
          //       ball__rep_free.offHold(createAttemptFunc);
          //   };
          //
          //   ball__rep_free.onHold(createAttemptFunc);
          // }
          //
          // //gm.onHold(create attempt)
          // {
          //   waitForNewAttempt();
          // }
          //
          // //gm.onTouched(add event to attempt)
          // {
          //
          // }
          //
          // //gm.onRelease(finalize attempt)
          // {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   ball__rep_free.onRelease(waitForNewAttempt);
          // }

          //create attempt






          //course use listeners

          function listenToOperatorTouches(icObj__rep_free) {

            const touchSlot__rep_free = icObj__rep_free.parts["touchSlot"];
            // logger.log("touchSlot__rep_free", touchSlot__rep_free);

            const touchSlotEngine = touchSlot__rep_free.engine;

            Hooker.installHooks(touchSlotEngine.awoken, "touch");
            touchSlotEngine.awoken.did["touch"].on((...args) => {
              // logger.log("did touch", ...args);

              // // counter += 1
              // const attempt = step.getCurrentAttempt();
              // logger.log("attempt", attempt);
              // attempt.manoeuvre.nb_touched += 1;
              //
              // //debug
              // step.rep_free__score_value.text = "" + attempt.manoeuvre.nb_touched;



              // const rep_free__curseFacade = step.rep_free__hole.parts.curseFacade;
              const rep_free__curseFacade = step.rep_free__hole.parts.curseFacade;
              if (rep_free__curseFacade != null) {
                const rep_free__facade = step.rep_free__hole.parts.facade;
                rep_free__facade.curse_metamorphosis.curseTrigger.impulse();
              }


            });

          }

          const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_operator");

          arr_gm_operator.forEach((gm_operator, i) => {
            const icObj__rep_free = gm_operator.icObj;
            listenToOperatorTouches(icObj__rep_free);
          });

        }

        setupCompletionTrigger(golfCourse) {

          const targetTouchSlot__rep_free = golfCourse.components["hole"].icObj;

          const touchSlot__rep_free = targetTouchSlot__rep_free.parts["touchSlot"];

          const touchSlotEngine = touchSlot__rep_free.engine;

          Hooker.installHooks(touchSlotEngine.awoken, "touch");
          const listener_targetDidTouch = (...args) => {
            // logger.log("did touch", ...args);

            this.nowCompleted();
          };
          this.listener_targetDidTouch = listener_targetDidTouch;
          touchSlotEngine.awoken.did["touch"].on(listener_targetDidTouch);

        }

        addCompletionListener(golfCourse) {

          const step = this;

          this.listener_onCompleted = (golfStep) => {
            // console.log("step, onCompleted", golfStep);
            // logger.log("step, onCompleted", golfStep);

            /*
            const score = golfStep.arr_attempts.length;
            golfCourse.mutateIntoScoreLabel(score);
            */

            step.offCompleted(step.listener_onCompleted);
            step.end();

            step.segue.play(golfStep);
          };

          this.onCompleted(this.listener_onCompleted);
        }

        getCurrentAttempt() {
          return this.arr_attempt[this.arr_attempt.length - 1];
        }







      }



    </script>
    <script> //SHU777
      // setTimeout(() => {    //SHU: wait for mathjax to finish loading
      //   const golfGame__endless_practice = new GolfGame__Endless_Practice(infiniteCanvas);     //practice
      // }, 1000);
    </script>






    <script>
      class Keyboard_Rx {
        constructor() {
          this.rx_keyUp = new Subject();
          document.addEventListener('keyup', (e) => {
            this.rx_keyUp.next(e);
          });
        }
      }
    </script>
    <script>
      const keyboard_Rx = new Keyboard_Rx();
    </script>





    <script>

      class Atelier__X_X {

        constructor(infiniteCanvas) {
          this.infiniteCanvas = infiniteCanvas;

          // this.debug1();
          // this.debug2();

          // this.debug_countdown_1();

          // this.debug_colored_tex();

          // this.debug_rich_wedding();

          // this.debug_splitter_sptl();
          // this.debug_splitter_spf();

          // this.debug_composite_mutation();
          // this.debug_morpher();

          // this.debug_exoSkeleton();
          // this.debug_exoSkeleton2();

          // this.debug_octomouse();

          //--fractions--
          // this.debug_decomp_product_primes();
          // this.debug_inverse();
          // this.debug_simplify_singleoperatorize();
          // this.debug_simplify_topPriorityShell();

          // this.debug_dropTouchSlot();
          // this.debug_platform();
          // this.debug_conductive_operator();
          // this.debug_fractionOne_operator();
          // this.debug_fractionOne_operator__showcase();

          // this.debug_conductive_compositing();

          // this.debug__fraction_simplification__edudemo1();
          // this.debug__fraction_simplification__edudemo2();
          // this.debug_gmSafetyZone();

          // this.debug_number_reification();
          // this.debug_bloom();
          // this.debug_bloom__fraction_bar_bloom();


          // this.debug__tts();
          // this.debug__stt();


          // this.debug_simplify_litexp();

          // this.debug_edudemo_mario_and_mushrooms();    //mario
          // this.debug_clone();
          // this.debug_unitCloneScale();

          // this.debug_slice_image();

          // this.debug_recording();
          // this.debug_geminiShade();
          // this.debug_triggeredPathmade();
          // this.debug_compositeAsArgument();

          // this.debug_random();

          // this.debug_pathSeams();

          // this.debug_points();
          // this.debug_circles_ellipses_and_arcs();
          //this.debug_progress_marker();

          // this.debug_decomp_prime_disks();

          // this.debug_hexagon();
          // this.debug_hexagon_grid1();
          // this.debug_hexagon_grid2();
          // this.debug_hexagon_fun();

          // this.debug_povs();

          // this.debug_qrcode_1();
          // this.debug_qrcode_2();

          // this.debug_video();

          // this.debug_gemini();

          this.debug_number_line();


          // this.debug_th();

          // this.debug_startingScreen();
        }

        debug1() {

          const infiniteCanvas = this.infiniteCanvas;

          //create targetTouchSlot
          const trueRect_2 = {
            x: 1000,
            y: 500,
            width: 100,
            height: 100,
          };
          const icTargetTouchSlot = infiniteCanvas.createIcGMTargetTouchSlot(trueRect_2, 12);
          infiniteCanvas.addIcObject(icTargetTouchSlot);


          //create var
          const trueRect_1 = {
            x: 500,
            y: 500,
            width: 100,
            height: 100,
          };
          const mathNode = new math.SymbolNode("x");
          const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
          icMathNode.isTouchable = true;
          infiniteCanvas.addIcObject(icMathNode);
        }

        debug2() {

          const infiniteCanvas = this.infiniteCanvas;

          //create icGreenMouseBox
          const trueRect_2 = {
            x: 1000,
            y: 500,
            width: 100,
            height: 100,
          };
          const icGreenMouseBox = infiniteCanvas.createIcGreenMouseBox(trueRect_2, new math.ConstantNode(12));
          // icGreenMouseBox.shouldAlsoRemoveChildren = true;
          infiniteCanvas.addIcObject(icGreenMouseBox);

          setTimeout(() => {
            const represented = infiniteCanvas.getRepresented(icGreenMouseBox.id);
            logger.log("represented", represented);
            represented.r_free().im_dying_now = true;
            represented.r_free().parts.facade.im_dying_now = true;
            represented.r_free().parts.contactArea.im_dying_now = true;
          }, 1000);

        }

        debug_countdown_1() {

          const infiniteCanvas = this.infiniteCanvas;

          //create icGreenMouseBox
          const trueRect = {
            x: 1000,
            y: 500,
            width: 100,
            height: 100,
          };
          // const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2, new math.ConstantNode(12));
          const mathNode = new math.ConstantNode(12);
          const icMathNode = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
          // infiniteCanvas.addIcObject(icMathNode);

          const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "0");
          // infiniteCanvas.addIcObject(icMathNode);

          const parts = {
            curseFacade: icText,
            mathNode: icMathNode,
          };

          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
          const icComposite = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);

          infiniteCanvas.addIcObject(icComposite);



          const facade_represented = infiniteCanvas.getRepresented(icMathNode.id);
          const facade_rep_free = facade_represented.r_free();

          // const countDownTrigger = infiniteCanvas.createCurseTrigger_countdown();
          infiniteCanvas.accurse__metamorphosis(facade_rep_free);

          const curseFunc = () => {
            logger.log("curseFunc, rep_free:", facade_rep_free);
            const mathNode = random_constantNode();
            facade_rep_free.mathNode = mathNode;
            facade_rep_free.curse_metamorphosis.reset();
          };
          facade_rep_free.curse_metamorphosis.curseFunc = curseFunc;



          facade_rep_free.curse_metamorphosis.start();


          //debug?
          // keyboard_Rx.rx_keyUp.subscribe({
          //   next: (e) => {
          //     logger.log("e",e);
          //
          //     switch(e.code) {
          //       case "Numpad1":
          //         facade_rep_free.curse_metamorphosis.curseTrigger.impulse();
          //         break;
          //     }
          //
          //   },
          // });






          const composite_represented = infiniteCanvas.getRepresented(icComposite.id);
          const composite_rep_free = composite_represented.r_free();
          const curseFacade_rep_free = composite_rep_free.parts.curseFacade;

          const curseTrigger = facade_rep_free.curse_metamorphosis.curseTrigger;
          logger.log("curseTrigger", curseTrigger);

          // Hooker.installHooks(curseTrigger, "impulse");
          // curseTrigger.did["impulse"].on(() => {
          // logger.log("did impulse");
          // const countDownEngine = curseTrigger.engine;
          // const counter         = countDownEngine.getCounter();
          // curseFacade_rep_free.text = "" + counter;
          // });


          // facade_rep_free.curse_metamorphosis.start();

          facade_rep_free.curse_metamorphosis.rx_countDownCounter.subscribe({
            next: (value) => {
              logger.log("rx_countDownCounter, next", value);
              logger.log("curseFacade_rep_free", curseFacade_rep_free);

              curseFacade_rep_free.text = "" + value;
              // facade_rep_free.mathNode = new math.ConstantNode(value);
            },
          });


        }


        debug_colored_tex() {

          const infiniteCanvas = this.infiniteCanvas;

          function addRichMathNode() {

            const trueRect = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(123456790);
            const richMathNode = new RichMathNode(mathNode);
            // richMathNode.rich.colorMode = "plain";
            richMathNode.rich.colorMode = "xylophone";
            // richMathNode.rich.colorMode = "evenodd";

            richMathNode.rich.color = "red";


            // const icMathNode = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
            // infiniteCanvas.addIcObject(icMathNode);

            // const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "0");

            // const richMathNodeConfig = {
            //   mathNode: mathNode,
            //   color: "blue",
            // };
            const icRichMathNode = infiniteCanvas.createIcRichMathNode(trueRect.x, trueRect.y, richMathNode);

            infiniteCanvas.addIcObject(icRichMathNode);
          }

          addRichMathNode();

        }

        debug_rich_wedding() {

          const infiniteCanvas = this.infiniteCanvas;

          function addRichMathNode(trueRect, value, colorMode) {

            const mathNode = new math.ConstantNode(value);
            const richMathNode = new RichMathNode(mathNode);
            // richMathNode.rich.colorMode = "plain";
            richMathNode.rich.colorMode = colorMode;
            // richMathNode.rich.colorMode = "evenodd";

            richMathNode.rich.color = "red";


            // const icMathNode = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
            // infiniteCanvas.addIcObject(icMathNode);

            // const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "0");

            // const richMathNodeConfig = {
            //   mathNode: mathNode,
            //   color: "blue",
            // };
            const icRichMathNode = infiniteCanvas.createIcRichMathNode(trueRect.x, trueRect.y, richMathNode);

            infiniteCanvas.addIcObject(icRichMathNode);
          }

          const trueRect_1 = {
            x: 1000,
            y: 500,
            width: 100,
            height: 100,
          };
          const trueRect_1bis = {
            x: trueRect_1.x,
            y: trueRect_1.y + 50,
            width: trueRect_1.width,
            height: trueRect_1.height,
          };
          const trueRect_2 = {
            x: 1500,
            y: 500,
            width: 100,
            height: 100,
          };

          addRichMathNode(trueRect_1, 10023456, "xylophone");
          addRichMathNode(trueRect_1bis, 10023456, "fullplain");

          // addRichMathNode(trueRect_2, 10023456, "plain");

          // addRichMathNode(trueRect_2,  51, "evenOdd");


        }

        debug_splitter_sptl() {

        }

        debug_splitter_spf() {

          //create splitter
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "split__top_layer");
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create joiner
          {
            const trueRect_2 = {
              x: 1300,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "join__top_layer");
            infiniteCanvas.addIcObject(gmOperator);
          }


          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const mathNode = random_onion_mathNode(3);
            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

        }

        debug_composite_mutation() {

          const infiniteCanvas = this.infiniteCanvas;

          //create composite
          const trueRect_0 = {
            x: 200,
            y: 200,
            width: 100,
            height: 100,
          };

          const parts = [];
          const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
          const icComposite = infiniteCanvas.createIcComposite(trueRect_0, parts, compositeConfig);
          infiniteCanvas.addIcObject(icComposite);

          const rep_free__composite = infiniteCanvas.getRepresented(icComposite.id).r_free();
          rep_free__composite.fill = "lightgrey";
          // rep_free.isSupervessel = true;
          logger.log("rep_free__composite.compositeConfig", rep_free__composite.compositeConfig);


          function addMathNode(rep_free__composite) {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const mathNode = new math.SymbolNode("12");
            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);

            const rep_free__mathNode = infiniteCanvas.getRepresented(icMathNode.id).r_free();

            // rep_free__composite.addPart(rep_free__mathNode);
            // rep_free__composite.engine.addPart(rep_free__mathNode);
            rep_free__composite.dict_engine["composite"].engine.awoken.addPart(rep_free__mathNode);      //SHU: un peu de vomi

            return rep_free__mathNode;
          }

          function addRect(rep_free__composite) {
            const trueRect = {
              x: 700,
              y: 700,
              width: 100,
              height: 100,
            };
            const icRect = infiniteCanvas.createIcRect(trueRect);
            infiniteCanvas.addIcObject(icRect);

            const rep_free__rect = infiniteCanvas.getRepresented(icRect.id).r_free();
            rep_free__rect.fill = "yellow";

            const miniDict = {
              [rep_free__rect.id]: rep_free__rect,
            };

            rep_free__composite.parts = Object.assign({}, rep_free__composite.parts, miniDict);
          }


          setTimeout(() => {

            const rep_free__mathNode = addMathNode(rep_free__composite);
            // addRect(rep_free__composite);

            setTimeout(() => {

              rep_free__composite.dict_engine["composite"].engine.awoken.removePart(rep_free__mathNode);

              setTimeout(() => {

                rep_free__composite.dict_engine["composite"].engine.awoken.addPart(rep_free__mathNode);

              }, 2000);

            }, 2000);

          }, 2000);

        }

        debug_morpher() {

          const infiniteCanvas = this.infiniteCanvas;

          // //create supervessel
          // {
          //   const trueRect_0 = {
          //     x: 200,
          //     y: 200,
          //     width: 100,
          //     height: 100,
          //   };
          //
          //   const parts           = [];
          //   const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
          //   const icComposite     = infiniteCanvas.createIcComposite(trueRect_0, parts, compositeConfig);
          //   infiniteCanvas.addIcObject(icComposite);
          //
          //   const rep_free = infiniteCanvas.getRepresented(icComposite.id).r_free();
          //   rep_free.fill = "lightgrey";
          //   rep_free.isSupervessel = true;
          // }



          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const mathNode = new math.ConstantNode(9);
            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create morpher
          {
            const trueRect_2 = {
              x: 1500,
              y: 100,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "morpher__math_to_text");
            infiniteCanvas.addIcObject(gmOperator);
          }
          {
            const trueRect_3 = {
              x: 1500,
              y: 600,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_3, "morpher__text_to_math");
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operators
          {
            const trueRect_2 = {
              x: 1500,
              y: 300,
              width: 100,
              height: 100,
            };
            const cfg__op = {
              text: "123",
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "t:append", cfg__op);
            infiniteCanvas.addIcObject(gmOperator);
          }
          {
            const trueRect_2 = {
              x: 1500,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "× 10");
            infiniteCanvas.addIcObject(gmOperator);
          }
          {
            const trueRect_2 = {
              x: 1500,
              y: 1000,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "simplify:force");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_exoSkeleton() {

          const infiniteCanvas = this.infiniteCanvas;

          const trueRect_1 = {
            x: 500,
            y: 500,
            width: 100,
            height: 100,
          };
          // const icObj__heart = infiniteCanvas.createIcText(trueRect_1.x, trueRect_1.y, "heart");
          const icObj__heart = infiniteCanvas.createIcRect(trueRect_1);
          // infiniteCanvas.addIcObject(icText);


          const exoSkeletonConfig = {
            grab: {
              position_easy: "right",
            },
            contact: {
              position_easy: "bottom",
            },
            display: {
              position_easy: "center",
            },
            // heartArea:
          };

          const icExoSkeleton = infiniteCanvas.createIcExoSkeleton(icObj__heart, exoSkeletonConfig);
          infiniteCanvas.addIcObject(icExoSkeleton);


          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 1");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_exoSkeleton2() {

          const infiniteCanvas = this.infiniteCanvas;

          const trueRect_1 = {
            x: 500,
            y: 500,
            width: 100,
            height: 100,
          };

          const icObj__member_1 = infiniteCanvas.createIcText(trueRect_1.x, trueRect_1.y, "2 + 2");
          // const icObj__equals   = infiniteCanvas.createIcText(trueRect_1.x, trueRect_1.y, "=");
          const icObj__member_2 = infiniteCanvas.createIcText(trueRect_1.x, trueRect_1.y, "5");

          const internalsObj = {
            "member_1": icObj__member_1,
            // "equals": icObj__center,
            "member_2": icObj__member_2,
          };
          // infiniteCanvas.addIcObject(icText);

          const exoSkeletonConfig = {
            internals: internalsObj,

            grab: {
              position_easy: "right_right",
            },

            member_1: {
              display: {
                position_easy: "left",
              },
              contact: {
                position_easy: "bottom_left",
              },
            },

            member_2: {
              display: {
                position_easy: "right",
              },
              contact: {
                position_easy: "bottom_right",
              },
            },


          };

          const icExoSkeleton = infiniteCanvas.createIcExoSkeleton(exoSkeletonConfig);
          infiniteCanvas.addIcObject(icExoSkeleton);


          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 1");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }



        debug_octoMouse() {

        }


        debug_decomp_product_primes() {

          const infiniteCanvas = this.infiniteCanvas;

          //debug: multi factor
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            // const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(7), new math.ConstantNode(7), new math.ConstantNode(7)]);
            const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(120), new math.ConstantNode(7), new math.ConstantNode(7)]);


            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            const mathNode = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(8)]);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "decomposition__product_primes");
            infiniteCanvas.addIcObject(gmOperator);
          }


        }

        debug_inverse() {

          const infiniteCanvas = this.infiniteCanvas;

          //debug: multi factor
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            // const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(7), new math.ConstantNode(7), new math.ConstantNode(7)]);
            const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(120), new math.ConstantNode(7), new math.ConstantNode(7)]);


            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            const mathNode = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(8)]);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "inverse");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_simplify_singleoperatorize() {

          const infiniteCanvas = this.infiniteCanvas;

          //debug: multi factor
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            // const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(7), new math.ConstantNode(7), new math.ConstantNode(7)]);
            const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(120), new math.ConstantNode(7), new math.ConstantNode(7)]);


            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            const mathNode = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(8)]);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "singleOperatorize");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_simplify_topPriorityShell() {

          const infiniteCanvas = this.infiniteCanvas;

          //debug: multi factor
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            // const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(7), new math.ConstantNode(7), new math.ConstantNode(7)]);

            const mathNode_a = new math.ConstantNode(4);
            const mathNode_b = new math.ConstantNode(7);

            const mathNode = new math.OperatorNode("x", "multiply", [mathNode_a, mathNode_b, Inverser.inverse(mathNode_a), Inverser.inverse(mathNode_b)]);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "simplify__topPriorityShell");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_dropTouchSlot() {

          const infiniteCanvas = this.infiniteCanvas;

          //create platform
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 200,
              height: 200,
            };
            const icDropTouchSlot = infiniteCanvas.createIcDropTouchSlot(trueRect_2);
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icDropTouchSlot);
          }


          //mathNode1
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(4);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //mathNode2
          {
            const trueRect_2 = {
              x: 500,
              y: 700,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(7);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          // //create platform
          // {
          //   const trueRect_2 = {
          //     x: 1000,
          //     y: 1000,
          //     width: 200,
          //     height: 200,
          //   };
          //   const icDropTouchSlot = infiniteCanvas.createIcDropTouchSlot(trueRect_2);
          //   icDropTouchSlot.fill = "powderblue";
          //   // conductiveOperator.zIndex = -50;
          //   infiniteCanvas.addIcObject(icDropTouchSlot);
          // }

        }

        debug_platform() {

          const infiniteCanvas = this.infiniteCanvas;

          //create platform
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 200,
              height: 200,
            };
            const icPlatform = infiniteCanvas.createIcPlatform(trueRect_2);
            icPlatform.fill = "darkgray";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icPlatform);
          }

          //create platform2
          {
            const trueRect_2 = {
              x: 1000,
              y: 800,
              width: 200,
              height: 200,
            };
            const icPlatform = infiniteCanvas.createIcPlatform(trueRect_2);
            icPlatform.fill = "orange";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icPlatform);
          }



          //mathNode1
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(4);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //mathNode2
          {
            const trueRect_2 = {
              x: 500,
              y: 700,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(7);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //rect1
          {
            const trueRect_3 = {
              x: 200,
              y: 500,
              width: 100,
              height: 100,
            };

            const icRect = infiniteCanvas.createIcRect(trueRect_3);
            icRect.fill = "lime";
            icRect.isTouchable = true;
            infiniteCanvas.addIcObject(icRect);
          }




        }


        debug_conductive_operator() {

          const infiniteCanvas = this.infiniteCanvas;

          //create conductiveOperator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 200,
              height: 200,
            };
            const conductiveOperator = infiniteCanvas.createIcConductiveOperator(trueRect_2, "+");
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(conductiveOperator);
          }

          //create conductiveOperator2
          {
            const trueRect_2 = {
              x: 1000,
              y: 200,
              width: 200,
              height: 200,
            };
            const conductiveOperator = infiniteCanvas.createIcConductiveOperator(trueRect_2, "-");
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(conductiveOperator);
          }


          //mathNode1
          {
            const trueRect_1 = {
              x: 300,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(4);
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //mathNode2
          {
            const trueRect_2 = {
              x: 300,
              y: 700,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(7);
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //mathNode3
          {
            const trueRect_2 = {
              x: 600,
              y: 400,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("4/11");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //mathNode4
          {
            const trueRect_2 = {
              x: 600,
              y: 700,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("7/11");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //mathNode5
          {
            const trueRect_2 = {
              x: 600,
              y: 100,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("8/13");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


        }


        debug_fractionOne_operator() {

          const infiniteCanvas = this.infiniteCanvas;

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 200,
              height: 200,
            };
            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2);
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator2
          {
            const trueRect_2 = {
              x: 1000,
              y: 200,
              width: 200,
              height: 200,
            };

            const op = Operator.fromString_binary("/");
            const node_b = new math.ConstantNode(2);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }


          //mathNode1
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(4);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create conductiveOperator
          {
            const trueRect_2 = {
              x: 1500,
              y: 300,
              width: 200,
              height: 200,
            };
            const conductiveOperator = infiniteCanvas.createIcConductiveOperator(trueRect_2, "+");
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(conductiveOperator);
          }

        }

        debug_fractionOne_operator__showcase() {

          const infiniteCanvas = this.infiniteCanvas;

          // //create operator  [x1]
          // {
          //   const trueRect_2 = {
          //     x: 400,
          //     y: 700,
          //     width:  150,
          //     height: 150,
          //   };
          //
          //   const op     = Operator.fromString_binary("x");
          //   const node_b = new math.ConstantNode(2);
          //   const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);
          //
          //   const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
          //   icFractionOneOperator.fill = "ivory";
          //   // conductiveOperator.zIndex = -50;
          //   infiniteCanvas.addIcObject(icFractionOneOperator);
          // }

          //create operator  [x2 / x2]
          {
            const trueRect_2 = {
              x: 400,
              y: 700,
              width: 150,
              height: 150,
            };

            const op = Operator.fromString_binary("x");
            const node_b = new math.ConstantNode(2);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator  [/2 / /2]
          {
            const trueRect_2 = {
              x: 400,
              y: 100,
              width: 150,
              height: 150,
            };

            const op = Operator.fromString_binary("/");
            const node_b = new math.ConstantNode(2);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }


          //create operator  [x3 / x3]
          {
            const trueRect_2 = {
              x: 700,
              y: 700,
              width: 150,
              height: 150,
            };

            const op = Operator.fromString_binary("x");
            const node_b = new math.ConstantNode(3);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator  [/3 / /3]
          {
            const trueRect_2 = {
              x: 700,
              y: 100,
              width: 150,
              height: 150,
            };

            const op = Operator.fromString_binary("/");
            const node_b = new math.ConstantNode(3);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator  [x5 / x5]
          {
            const trueRect_2 = {
              x: 1000,
              y: 700,
              width: 150,
              height: 150,
            };

            const op = Operator.fromString_binary("x");
            const node_b = new math.ConstantNode(5);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator  [/5 / /5]
          {
            const trueRect_2 = {
              x: 1000,
              y: 100,
              width: 150,
              height: 150,
            };

            const op = Operator.fromString_binary("/");
            const node_b = new math.ConstantNode(5);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator  [x7 / x7]
          {
            const trueRect_2 = {
              x: 1300,
              y: 700,
              width: 150,
              height: 150,
            };

            const op = Operator.fromString_binary("x");
            const node_b = new math.ConstantNode(7);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator  [/7 / /7]
          {
            const trueRect_2 = {
              x: 1300,
              y: 100,
              width: 150,
              height: 150,
            };

            const op = Operator.fromString_binary("/");
            const node_b = new math.ConstantNode(7);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }



          //create conductiveOperator
          {
            const trueRect_2 = {
              x: 1500,
              y: 300,
              width: 300,
              height: 300,
            };
            const conductiveOperator = infiniteCanvas.createIcConductiveOperator(trueRect_2, "+");
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(conductiveOperator);
          }

          //create operator decomp:prpr
          {
            const trueRect_2 = {
              x: 2100,
              y: 300,
              width: 200,
              height: 200,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "decomposition__product_primes");
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create operator simplify_fraction
          {
            const trueRect_2 = {
              x: 2500,
              y: 650,
              width: 200,
              height: 200,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "simplify__fraction");
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }


          const arr_primes = [2, 3, 5, 7];

          const str__frac1 = "" + Utils.randomElementInArray(arr_primes) + "/" + Utils.randomElementInArray(arr_primes);
          const mathNode__frac1 = math.parse(str__frac1);

          const str__frac2 = "" + Utils.randomElementInArray(arr_primes) + "/" + Utils.randomElementInArray(arr_primes);
          const mathNode__frac2 = math.parse(str__frac2);

          //mathNode1
          {
            const trueRect_1 = {
              x: 100,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = mathNode__frac1.cloneDeep();

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //mathNode2
          {
            const trueRect_1 = {
              x: 100,
              y: 600,
              width: 100,
              height: 100,
            };

            const mathNode = mathNode__frac2.cloneDeep();

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }




          //mathNode1 display
          {

            {
              const trueRect_1 = {
                x: 1600,
                y: 1000,
                width: 100,
                height: 100,
              };

              const mathNode = mathNode__frac1.cloneDeep();

              const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
              icMathNode.isTouchable = true;
              infiniteCanvas.addIcObject(icMathNode);
            }

            {
              const trueRect_plus = {
                x: 1650,
                y: 1050,
                width: 100,
                height: 100,
              };

              const icText__plus = infiniteCanvas.createIcText(trueRect_plus.x, trueRect_plus.y, "+");
              infiniteCanvas.addIcObject(icText__plus);
            }

            {
              const trueRect_2 = {
                x: 1800,
                y: 1000,
                width: 100,
                height: 100,
              };

              const mathNode = mathNode__frac2.cloneDeep();

              const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
              icMathNode.isTouchable = true;
              infiniteCanvas.addIcObject(icMathNode);
            }

            {
              const trueRect_equals = {
                x: 1900,
                y: 1050,
                width: 100,
                height: 100,
              };

              const icText__equals = infiniteCanvas.createIcText(trueRect_equals.x, trueRect_equals.y, "=");
              infiniteCanvas.addIcObject(icText__equals);
            }



          }




        }


        debug_conductive_compositing() {


          //create conductiveCompositingOperator
          {
            const trueRect_2 = {
              x: 1000,
              y: 300,
              width: 200,
              height: 200,
            };
            const conductiveCompositingOperator = infiniteCanvas.createIcConductiveCompositingOperator(trueRect_2);
            infiniteCanvas.addIcObject(conductiveCompositingOperator);
          }




          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 700,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 1");
            gmOperator.isTouchable = false;
            Object.values(gmOperator.parts).forEach((icObj__part, i) => {
              logger.log("icObj__part:", icObj__part);
              icObj__part.isTouchable = false;
            });

            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1200,
              y: 700,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "x 2");
            infiniteCanvas.addIcObject(gmOperator);
          }



          // //create conductiveOperator
          // {
          //   const trueRect_2 = {
          //     x: 1500,
          //     y: 300,
          //     width: 300,
          //     height: 300,
          //   };
          //   const conductiveOperator = infiniteCanvas.createIcConductiveOperator(trueRect_2, "+");
          //   // conductiveOperator.zIndex = -50;
          //   infiniteCanvas.addIcObject(conductiveOperator);
          // }



          //mathNode2
          {
            const trueRect_2 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(7);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }



        }






        debug__fraction_simplification__edudemo1() {

          //create operator decomp:prpr
          {
            const trueRect_2 = {
              x: 50,
              y: 200,
              width: 200,
              height: 200,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "decomposition__product_primes");

            infiniteCanvas.onceOnAddRepresentedForIcObject(icGMOperator, (icGMOperator) => {

              const rep_free__operator = infiniteCanvas.getRepresented(icGMOperator.id).r_free();
              const rep_free__facade = rep_free__operator.parts.facade;
              rep_free__facade.text = "Décomposer";

            });

            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create operator simplify_fraction
          {
            const trueRect_2 = {
              x: 1000,
              y: 200,
              width: 200,
              height: 200,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "simplify__fraction");

            infiniteCanvas.onceOnAddRepresentedForIcObject(icGMOperator, (icGMOperator) => {

              const rep_free__operator = infiniteCanvas.getRepresented(icGMOperator.id).r_free();
              const rep_free__facade = rep_free__operator.parts.facade;
              rep_free__facade.text = "Simplifier";

            });

            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }
        }


        debug__fraction_simplification__edudemo2() {

          {
            const trueRect_2 = {
              x: 300,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = new MySummerNode(1);
            logger.log("mathNode", mathNode);
            mathNode.isSlashed = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          {
            const trueRect_2 = {
              x: 300,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new MySummerNode(3);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }



          //create icTex with strikethrough
          {
            const trueRect_tex = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };

            const icTex = infiniteCanvas.createIcTex(trueRect_tex.x, trueRect_tex.y, "\\not {2}");

            infiniteCanvas.addIcObject(icTex);
          }

        }


        debug_gmSafetyZone() {

          const infiniteCanvas = this.infiniteCanvas;

          //create safetyZone
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 200,
              height: 200,
            };
            const icGMSafetyZone = infiniteCanvas.createIcGMSafetyZone(trueRect_2);
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMSafetyZone);
          }

          //create greenMouse
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(4);

            const icBornAgainGreenMouse = infiniteCanvas.createIcBornAgainGreenMouse(trueRect_1, mathNode);
            icBornAgainGreenMouse.isTouchable = true;
            infiniteCanvas.addIcObject(icBornAgainGreenMouse);
          }


        }

        debug_number_reification() {

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 1");
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "x 2");
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create MNReictangle
          {
            const trueRect_2 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const mathNode = new math.ConstantNode(1);
            const mnReictangle = infiniteCanvas.createIcMNReictangle(trueRect_2.x, trueRect_2.y, mathNode);
            infiniteCanvas.addIcObject(mnReictangle);
          }

        }

        debug_bloom() {

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 1");
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "x 2");
            infiniteCanvas.addIcObject(gmOperator);
          }


          //create bloom
          {
            // const mathNode = new math.ConstantNode(1);
            const mathNode = math.parse("1");
            mathNode.autoSimplify = true;

            const rxSubject = new Subject(mathNode);

            //create icMathNode
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);

            infiniteCanvas.onceOnAddRepresentedForIcObject(icMathNode, (icMathNode) => {

              const rep_free = infiniteCanvas.getRepresented(icMathNode.id).r_free();

              rep_free.onInnerUpdate((rep_free, propName, oldValue, newValue) => {
                logger.log("icMathNode, rep_free.onInnerUpdate", propName);

                if (propName == "mathNode") {
                  logger.log("icMathNode.onInnerUpdate, mathNode", propName, newValue);

                  const mathNode = newValue;
                  rxSubject.next(mathNode);
                }

              });

            });

            // infiniteCanvas.addIcObject(icMathNode);



            //create MNReictangle
            const trueRect_2 = {
              x: 500,
              y: 600,
              width: 100,
              height: 100,
            };
            const length_unit = 100;
            const icMNReictangle = infiniteCanvas.createIcMNReictangle(trueRect_2.x, trueRect_2.y, mathNode, length_unit);
            // icMNReictangle.isTouchable = true;
            icMNReictangle.fill = "orange";
            icMNReictangle.isSharpRect = true;

            // infiniteCanvas.addIcObject(icMNReictangle);


            const engine = new FacetEngine();
            const eType = "facet_mnrei_rectangle";
            const icEngined = infiniteCanvas.installEngineOnIcObj(icMNReictangle, eType, engine);

            // const rxSubject = new Subject(mathNode);
            icEngined.rxObservable = rxSubject.asObservable();
            icEngined.reactFunc = function (facet, nextObj) {
              logger.log("reactFunc", nextObj);
              facet.mathNode = nextObj.clone();
            };
            // infiniteCanvas.addIcObject(icEngined);



            //create MNReictangle
            const trueRect_3 = {
              x: 500,
              y: 630,
              width: 100,
              height: 100,
            };
            const icMNReictangle__unit = infiniteCanvas.createIcMNReictangle(trueRect_3.x, trueRect_3.y, mathNode, length_unit);
            // icMNReictangle.isTouchable = true;
            icMNReictangle__unit.fill = "black";
            icMNReictangle__unit.isSharpRect = true;



            //makeshift bloom
            const parts = {
              "mathNode": icMathNode,
              "reictangle": icEngined,
              "reictangle_unit": icMNReictangle__unit,
            };

            const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

            const icComposite = infiniteCanvas.createIcComposite(trueRect_1, parts, compositeConfig);
            icComposite.cType = "makeshiftBloom";
            icComposite.fill = "";

            infiniteCanvas.addIcObject(icComposite);

          }

        }

        debug_bloom__fraction_bar_bloom() {

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 1");
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "x 2");
            infiniteCanvas.addIcObject(gmOperator);
          }


          //create bloom
          {
            // const mathNode = new math.ConstantNode(1);
            const mathNode = math.parse("1/7");
            mathNode.autoSimplify = true;

            const rxSubject = new Subject(mathNode);

            //create icMathNode
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);

            infiniteCanvas.onceOnAddRepresentedForIcObject(icMathNode, (icMathNode) => {

              const rep_free = infiniteCanvas.getRepresented(icMathNode.id).r_free();

              rep_free.onInnerUpdate((rep_free, propName, oldValue, newValue) => {
                logger.log("icMathNode, rep_free.onInnerUpdate", propName);

                if (propName == "mathNode") {
                  logger.log("icMathNode.onInnerUpdate, mathNode", propName, newValue);

                  const mathNode = newValue;
                  rxSubject.next(mathNode);
                }

              });

            });

            // infiniteCanvas.addIcObject(icMathNode);



            //create MNReictangle
            const trueRect_2 = {
              x: 454,
              y: 579,
              width: 100,
              height: 100,
            };
            const length_unit = 73;
            const icMNReictangle = infiniteCanvas.createIcMNReictangle(trueRect_2.x, trueRect_2.y, mathNode, length_unit);
            // icMNReictangle.isTouchable = true;
            icMNReictangle.fill = "orange";
            icMNReictangle.isSharpRect = true;

            // infiniteCanvas.addIcObject(icMNReictangle);


            const engine = new FacetEngine();
            const eType = "facet_mnrei_rectangle";
            const icEngined = infiniteCanvas.installEngineOnIcObj(icMNReictangle, eType, engine);

            // const rxSubject = new Subject(mathNode);
            icEngined.rxObservable = rxSubject.asObservable();
            icEngined.reactFunc = function (facet, nextObj) {
              logger.log("reactFunc", nextObj);
              facet.mathNode = nextObj.clone();
            };
            // infiniteCanvas.addIcObject(icEngined);



            //makeshift bloom
            const parts = {
              "mathNode": icMathNode,
              "reictangle": icMNReictangle,
            };

            const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

            const icComposite = infiniteCanvas.createIcComposite(trueRect_1, parts, compositeConfig);
            icComposite.cType = "makeshiftBloom";
            icComposite.fill = "";

            infiniteCanvas.addIcObject(icComposite);

          }

        }

        debug__tts() {

        }

        debug__stt() {
          var SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
          var recognition = new SpeechRecognition();

          recognition.continuous = true;

          recognition.onend = function () {
            recognition.start();
          }

          recognition.onresult = function (event) {
            var current = event.resultIndex;
            var transcript = event.results[current][0].transcript;
            speak(transcript)
          }

          recognition.start();
        }


        debug_simplify_litexp() {

          //create operator simplify_fraction
          {
            const trueRect_2 = {
              x: 2500,
              y: 650,
              width: 200,
              height: 200,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "simplify__topPriorityShell");
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //mathNode1
          {
            const trueRect_1 = {
              x: 100,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("(((x + 1) * 2) / 3) / 2");

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

        }


        debug_edudemo_mario_and_mushrooms() {

          //create image
          {
            const trueRect_2 = {
              x: 100,
              y: 300,
              width: 100,
              height: 100,
            };

            const img__file_p = FileIntegration.imageFromImgSrc_p("img/m&m/peach_detouree_cellshadee.png");
            const img_p = img__file_p;

            img_p.then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_2.x, trueRect_2.y, img);
              // icObj_front.scale.X = 1.5;
              // icObj_front.scale.Y = 1.5;

              icObj_front.isTouchable = false;

              infiniteCanvas.addIcObject(icObj_front);
            });
          }


          //create image
          {
            const trueRect_2 = {
              x: 300,
              y: 300,
              width: 100,
              height: 100,
            };

            const img__file_p = FileIntegration.imageFromImgSrc_p("img/m&m/mario_standing__boxed.png");
            const img_p = img__file_p;

            img_p.then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_2.x, trueRect_2.y, img);
              icObj_front.scale.X = 0.25;
              icObj_front.scale.Y = 0.25;

              icObj_front.isTouchable = false;

              infiniteCanvas.addIcObject(icObj_front);
            });
          }

          //create rect
          {
            const trueRect_2 = {
              x: 100,
              y: 800,
              width: 100,
              height: 100,
            };

            const icObj_front = infiniteCanvas.createIcRect(trueRect_2);
            icObj_front.isTouchable = false;
            icObj_front.fill = "lightgreen";

            infiniteCanvas.addIcObject(icObj_front);
          }


          //create x2 vert operator
          {
            const trueRect = {
              x: 500,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "vert",
              operation: "x 2",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create /2 vert operator
          {
            const trueRect = {
              x: 500,
              y: 300,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "vert",
              operation: "/ 2",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }


          //create x2 horiz operator
          {
            const trueRect = {
              x: 1300,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "horiz",
              operation: "x 2",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create /2 horiz operator
          {
            const trueRect = {
              x: 1300,
              y: 300,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "horiz",
              operation: "/ 2",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create /2 prop operator
          {
            const trueRect = {
              x: 1800,
              y: 300,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "prop",
              operation: "/ 2",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create x2 prop operator
          {
            const trueRect = {
              x: 1800,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "prop",
              operation: "x 2",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }



          //Thales
          //create x1.37 vert operator
          {
            const trueRect = {
              x: 500,
              y: 2500,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "vert",
              operation: "x 1.414",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create x1.37 horiz operator
          {
            const trueRect = {
              x: 1300,
              y: 2500,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "horiz",
              operation: "x 1.414",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

        }

        debug_clone() {

          //create rect
          {
            const trueRect = {
              x: 100,
              y: 300,
              width: 100,
              height: 100,
            };
            const icObj = infiniteCanvas.createIcRect(trueRect);
            icObj.fill = "magenta";
            icObj.isTouchable = true;

            infiniteCanvas.addIcObject(icObj);
          }

          //create clone operator
          {
            const trueRect = {
              x: 500,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              nb_clones: 1,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:clone", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

        }

        debug_unitCloneScale() {

          //create image
          {
            const trueRect_2 = {
              x: -100,
              y: 300,
              width: 100,
              height: 100,
            };

            const img__file_p = FileIntegration.imageFromImgSrc_p("img/m&m/mario_standing__boxed.png");
            const img_p = img__file_p;

            img_p.then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_2.x, trueRect_2.y, img);
              icObj_front.isTouchable = true;

              infiniteCanvas.addIcObject(icObj_front);
            });
          }

          //create x3.77 horiz operator
          {
            const trueRect = {
              x: 500,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "horiz",
              operation: "x 3.77",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:ucscale", cfg);

            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create /3.77 horiz operator
          {
            const trueRect = {
              x: 500,
              y: 300,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "horiz",
              operation: "/ 3.77",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:ucscale", cfg);

            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }


          //create x(-1.59) vert operator
          {
            const trueRect = {
              x: 1300,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "vert",
              operation: "x (-1.59)",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:ucscale", cfg);
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create /(-1.59) vert operator
          {
            const trueRect = {
              x: 1300,
              y: 300,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "vert",
              operation: "/ (-1.59)",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:ucscale", cfg);

            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }


        }


        debug_slice_image() {

          //create image
          {
            const trueRect_2 = {
              x: 0,
              y: 0,
              width: 200,
              height: 200,
            };

            const img__file_p = FileIntegration.imageFromImgSrc_p("img/monokuma.png");
            // const dataURL_p = img__file_p.then((img) => {
            //   return FileIntegration.dataUrlForImgViaCanvas2_p(img);
            // });
            // const img__data_p = dataURL_p.then((dataURL) => {
            //   return FileIntegration.imageFromImgSrc_p(dataURL);
            // });

            // const img_p = img__data_p;
            const img_p = img__file_p;

            img_p.then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_2.x, trueRect_2.y, img);
              // icMathNode.isTouchable = true;
              infiniteCanvas.addIcObject(icObj_front);
            });

          }

        }

        debug_recording() {

          //create text
          {
            const trueRect = {
              x: 100,
              y: 100,
              width: 100,
              height: 100,
            };

            const string__greeting = "123";
            const icObj = infiniteCanvas.createIcText(trueRect.x, trueRect.y, string__greeting);
            icObj.isTouchable = true;

            // infiniteCanvas.onceOnAddRepresentedForIcObject(icObj, (icObj) => {
            //   const rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();
            //   rep_free.id = 1000;
            // });

            infiniteCanvas.addIcObject(icObj);
          }

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("0");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 400,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("14");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("x");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 800,
              y: 200,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 1");
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 800,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 10");
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1500,
              y: 200,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "x 2");
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1500,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "x (-1)");
            infiniteCanvas.addIcObject(gmOperator);
          }


        }

        debug_geminiShade() {

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("0");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;

            infiniteCanvas.onceOnAddRepresentedForIcObject(icMathNode, (icMathNode) => {

              const represented = infiniteCanvas.getRepresented(icMathNode.id);
              const rep_official = represented.r_official();
              // const rep_free     = represented.r_free();

              //create gemini shade
              const icGeminiShade = infiniteCanvas.createIcGeminiShade(rep_official);
              icGeminiShade.position = {
                x: icGeminiShade.position.x + 100,
                y: icGeminiShade.position.y + 100,
              };

              infiniteCanvas.addIcObject(icGeminiShade);

            });


            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 800,
              y: 200,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 1");
            infiniteCanvas.addIcObject(gmOperator);
          }

          // //create operator
          // {
          //   const trueRect_2 = {
          //     x: 800,
          //     y: 800,
          //     width: 100,
          //     height: 100,
          //   };
          //   const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 10");
          //   infiniteCanvas.addIcObject(gmOperator);
          // }
          //
          // //create operator
          // {
          //   const trueRect_2 = {
          //     x: 1500,
          //     y: 200,
          //     width: 100,
          //     height: 100,
          //   };
          //   const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "x 2");
          //   infiniteCanvas.addIcObject(gmOperator);
          // }
          //
          // //create operator
          // {
          //   const trueRect_2 = {
          //     x: 1500,
          //     y: 800,
          //     width: 100,
          //     height: 100,
          //   };
          //   const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "x (-1)");
          //   infiniteCanvas.addIcObject(gmOperator);
          // }


        }

        debug_triggeredPathmade() {

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("1");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;

            infiniteCanvas.addIcObject(icMathNode);
          }

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 600,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("2");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;

            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 800,
              y: 200,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 1");
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1500,
              y: 600,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "x 2");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }


        debug_compositeAsArgument() {

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("1");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;

            infiniteCanvas.addIcObject(icMathNode);
          }

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 600,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("2");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;

            infiniteCanvas.addIcObject(icMathNode);
          }


          //create clone operator
          {
            const trueRect = {
              x: 500,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              nb_clones: 1,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:clone", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create objectAtIndex operator
          {
            const trueRect = {
              x: 1000,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              index: 1,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "c:objectAtIndex", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create vessel operator
          {
            const trueRect = {
              x: 1000,
              y: 200,
              width: 100,
              height: 100,
            };

            const fColor = new fabric.Color("crimson");
            fColor.setAlpha(0.666);
            const rgbaColorString = fColor.toRgba();

            const cfg = {
              rgbaColorString: rgbaColorString,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "vessel", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create unvessel operator
          {
            const trueRect = {
              x: 1000,
              y: 600,
              width: 100,
              height: 100,
            };

            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "unvessel");
            infiniteCanvas.addIcObject(icGMOperator);
          }

          // //create operator
          // {
          //   const trueRect_2 = {
          //     x: 800,
          //     y: 200,
          //     width: 100,
          //     height: 100,
          //   };
          //   const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 1");
          //   infiniteCanvas.addIcObject(gmOperator);
          // }
          //
          // //create operator
          // {
          //   const trueRect_2 = {
          //     x: 1500,
          //     y: 600,
          //     width: 100,
          //     height: 100,
          //   };
          //   const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "x 2");
          //   infiniteCanvas.addIcObject(gmOperator);
          // }

        }

        debug_random() {

          //create random operator
          {
            const trueRect = {
              x: 1000,
              y: 200,
              width: 100,
              height: 100,
            };

            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "random");
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create rand_int operator
          {
            const trueRect = {
              x: 1000,
              y: 600,
              width: 100,
              height: 100,
            };

            const cfg = {
              min: 1,
              max: 100,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "rand_int", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create rand_inArr operator
          {
            const trueRect = {
              x: 1500,
              y: 400,
              width: 100,
              height: 100,
            };

            const cfg = {
              arr_value: [1, 1, 1, 2, 2, 2, 2, 2, 2, 3],
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "rand_inArr", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create rand_inBag operator
          {
            const trueRect = {
              x: 1500,
              y: 800,
              width: 100,
              height: 100,
            };

            const cfg = {

            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "rand_inBag", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }



        }

        debug_pathSeams() {


        }

        debug_points() {

          //create rect
          {
            const trueRect = {
              x: 0,
              y: 0,
              width: 300,
              height: 400,
            };

            const icRect = infiniteCanvas.createIcRect(trueRect);
            icRect.cornerStyle = '';
            // icRect.rx = 0;
            // icRect.ry = 0;
            icRect.fill = "grey";
            icRect.strokeWidth = 0.1;
            icRect.stroke = "yellow";

            infiniteCanvas.addIcObject(icRect);
          }

          //create points
          {
            const arr_coords = [[0, 0], [300, 0], [300, 400], [0, 400]];

            arr_coords.forEach((item, i) => {
              const x = item[0];
              const y = item[1];
              const point = Geometry.createPoint(x, y);

              const icPoint = infiniteCanvas.createIcPoint(point);
              icPoint.pointType = "rect";
              // icPoint.pointType = "cross";
              infiniteCanvas.addIcObject(icPoint);

              /*
              const trueRect = {
                x:      point.x,
                y:      point.y,

                //bad precision: something small seen from short range
                // width:  0.05,
                // height: 0.05,

                //good precision: something big seen from afar
                width:  100,
                height: 100,
              };
              const icRect = infiniteCanvas.createIcRect(trueRect);
              icRect.isUsingCenterPosition = true;
              icRect.fill = "magenta";
              icRect.homeScale.X = 100;
              icRect.homeScale.Y = 100;
              infiniteCanvas.addIcObject(icRect);
              */


            });

          }



        }


        debug_circles_ellipses_and_arcs() {

          //create circle
          // {
          //   const pointCenter = {
          //     x: 200,
          //     y: 200,
          //   };
          //
          //   const radius = 100;
          //
          //   const cfg = {
          //     strokeColor: "red",
          //     fillColor:   "blue",
          //   };
          //
          //   const icCircle = infiniteCanvas.createIcCircle(pointCenter, radius, cfg);
          //   infiniteCanvas.addIcObject(icCircle);
          // }

          //create ellipse
          {
            const trueRect = {
              x: 500,
              y: 500,
              width: 300,
              height: 100,
            };

            const cfg = {
              strokeColor: "magenta",
              fillColor: "cyan",
            };

            const icEllipse = infiniteCanvas.createIcEllipse(trueRect, cfg);
            infiniteCanvas.addIcObject(icEllipse);

            // //create point on ellipse
            // {
            //   const rect = {
            //     left:   trueRect.x,
            //     top:    trueRect.y,
            //     width:  trueRect.width,
            //     height: trueRect.height,
            //   };
            //   const pointCenter = Geometry.getCenterPoint(rect);
            //   const rx = trueRect.width/2;
            //   const ry = trueRect.height/2;
            //
            //   //debug
            //   // [...Array(10).keys()].forEach((item, i) => {
            //   //   const pointOnEllipse = Geometry.pointOnEllipse__angleInDegrees(pointCenter, rx, ry, 0 + i * 15);
            //   //
            //   //   {
            //   //     const icPoint = infiniteCanvas.createIcPoint(pointOnEllipse);
            //   //     icPoint.pointType = "cross";
            //   //     infiniteCanvas.addIcObject(icPoint);
            //   //   }
            //   //
            //   //   {
            //   //     const icPoint = infiniteCanvas.createIcPoint(pointOnEllipse);
            //   //     icPoint.pointType = "rect";
            //   //     infiniteCanvas.addIcObject(icPoint);
            //   //   }
            //   //
            //   // });
            //
            //
            //
            // }


          }

          //create rect
          {
            const trueRect = {
              x: 650,
              y: 550,
              width: 150,
              height: 1,
            };

            const icRect = infiniteCanvas.createIcRect(trueRect);
            icRect.cornerStyle = '';
            icRect.rx = 0;
            icRect.ry = 0;
            icRect.fill = "black";
            infiniteCanvas.addIcObject(icRect);
          }

          //create square
          {
            const trueRect = {
              x: 0,
              y: 0,
              width: 400,
              height: 400,
            };

            const icRect = infiniteCanvas.createIcRect(trueRect);
            icRect.cornerStyle = '';
            icRect.rx = 0;
            icRect.ry = 0;
            icRect.fill = "yellow";
            infiniteCanvas.addIcObject(icRect);
          }

          //create arc of square
          {
            const pointCenter = {
              x: 200,
              y: 200,
            };

            const radius = 200;
            const angleStart = 40;
            const angleEnd = 300;

            const cfg = {
              strokeColor: "grey",
              fillColor: "pink",
            };

            const icArcOfSquare = infiniteCanvas.createIcArcOfSquare(pointCenter, radius, angleStart, angleEnd, cfg);
            infiniteCanvas.addIcObject(icArcOfSquare);
          }


          //create arc of circle
          {
            const pointCenter = {
              x: 200,
              y: 200,
            };

            const radius = 200;
            const angleStart = 120;
            const angleEnd = 150;

            const cfg = {
              strokeColor: "red",
              fillColor: "",
            };

            const icCircle = infiniteCanvas.createIcArcOfCircle(pointCenter, radius, angleStart, angleEnd, cfg);
            infiniteCanvas.addIcObject(icCircle);
          }

          //create arc
          // {
          //   const trueRect = {
          //     x: 200,
          //     y: 200,
          //     width: 300,
          //     height: 300,
          //   };
          //
          //   const cfg = {
          //     angle1: 0,
          //     angle2: 180,
          //   };
          //
          //   const icArc = infiniteCanvas.createIcArc(trueRect, cfg);
          //   infiniteCanvas.addIcObject(icArc);
          // }

          // //create progress arc
          // const icProgressArc = infiniteCanvas.createIcProgressArc(trueRect, cfg);
          // infiniteCanvas.addIcObject(icProgressArc);
          //
          // //create segmented progress arc
          // const icSegmentedProgressArc = infiniteCanvas.createIcSegmentedProgressArc(trueRect, cfg);
          // infiniteCanvas.addIcObject(icSegmentedProgressArc);


        }

        debug_progress_marker() {

          //create crown
          // {
          //   const arr_point__crown = [
          //     Geometry.createPoint(  0, 100),
          //     Geometry.createPoint(100, 150),
          //     Geometry.createPoint(250,   0),
          //     Geometry.createPoint(400, 150),
          //     Geometry.createPoint(500, 100),
          //     Geometry.createPoint(400, 400),
          //     Geometry.createPoint(100, 400),
          //   ];
          //
          //   const cfg = {
          //     strokeColor: "grey",
          //     strokeWidth: 5,
          //
          //     fillColor:   "gold",
          //   };
          //
          //   const icPolygon = infiniteCanvas.createIcPolygon(arr_point__crown, cfg);
          //   infiniteCanvas.addIcObject(icPolygon);
          // }

          //create progress marker
          {
            const trueRect = {
              x: 400,
              y: 400,
              width: 200,
              height: 200,
            };

            const cfg = {
              levels: [
                {
                  color: "green",
                  nb_sectors: 7,
                },
                {
                  color: "blue",
                  nb_sectors: 8,
                },
                {
                  color: "red",
                  nb_sectors: 9,
                },
              ],
              // crown_symbol: null,
            };

            const progress = 0.30;

            const icProgressMarker = infiniteCanvas.createIcProgressMarker(trueRect, progress, cfg);
            infiniteCanvas.addIcObject(icProgressMarker);
          }

        }

        debug_decomp_prime_disks() {
          const pointCenter = Geometry.createPoint(200, 100);
          // const number = 20;
          const number = 11628;
          const icDecompPrimeDisk = infiniteCanvas.createIcProductOfPrimesDisk(pointCenter, number);
          infiniteCanvas.addIcObject(icDecompPrimeDisk);
        }


        debug_hexagon() {
          const pointTL = Geometry.createPoint(100, 100);
          const length = 100;
          const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length);
          infiniteCanvas.addIcObject(icHexagon);
        }

        debug_hexagon_grid1() {

          const length = 100;

          //hexagon1
          {
            const pointTL = Geometry.createPoint(0, 0);
            const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length);
            infiniteCanvas.addIcObject(icHexagon);
          }

          //hexagon2
          {
            const row = 0;
            const col = 2;
            const pointTL = Geometry.createPoint((col + 1.0) * length, row * length * math.sqrt(3) / 2.0);
            const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length);
            infiniteCanvas.addIcObject(icHexagon);
          }

          //hexagon3
          {
            const row = 1;
            const col = 1;
            const pointTL = Geometry.createPoint((col + 0.5) * length, row * length * math.sqrt(3) / 2.0);
            const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length);
            infiniteCanvas.addIcObject(icHexagon);
          }

        }

        debug_hexagon_grid2() {

          const arr_type = [
            "water",
            "sand",
            "soil",
            "mud",
            "grass",
            "tree__small",
            "tree__big",
          ];

          function easyConfig(type) {

            var fillColor;
            switch (type) {
              case "water":
                fillColor = "cyan";
                break;
              // case "water_deep":
              // fillColor = "blue";
              // break;
              case "sand":
                fillColor = "gold";
                break;
              case "tree__big":
                fillColor = "black";
                break;
              case "tree__small":
                fillColor = "gray";
                break;
              case "grass":
                fillColor = "green";
                break;
              case "soil":
                fillColor = "red";
                break;
              case "mud":
                fillColor = "brown";
                break;

              default:
                fillColor = "";
                break;
            }

            const cfg = {
              strokeColor: "white",
              fillColor: fillColor,
            };

            return cfg;
          }

          function easyHexagon(row, col, type) {
            const length = 50;

            const factor__col = (col % 2 == 0) ? (col + 1.0) : (col + 0.5);
            const x = 3 * col * length + ((row % 2 == 0) ? 0 : 1.5) * length;
            const y = row * length * math.sqrt(3) / 2.0;
            const pointTL = Geometry.createPoint(x, y);

            const cfg = easyConfig(type);

            const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length, cfg);
            return icHexagon;
          }

          const w = 10;
          const h = 10;

          const arr_x = [...Array(w).keys()];
          const arr_y = [...Array(h).keys()];

          const arr_hexagon = arr_x.map(x => {
            return arr_y.map(y => {
              const type = Utils.randomElementInArray(arr_type);
              const icHexagon = easyHexagon(x, y, type);
              return icHexagon;
            });
          }).flat();

          arr_hexagon.forEach((icHexagon, i) => {
            infiniteCanvas.addIcObject(icHexagon);
          });

        }

        debug_hexagon_fun() {

          function loadAssets_p() {
            const dict_image_path = {
              "water": "img/oyagame/water__ok.png",
              "sand": "img/oyagame/sand.png",
              "soil": "img/oyagame/soil.png",
              "mud": "img/oyagame/mud.png",
              "grass": "img/oyagame/grass.png",
              "tree__small": "img/oyagame/tree__small.png",
              "tree__big": "img/oyagame/tree__big.png",
            };

            var dict_image = {};
            const arr_p = Object.entries(dict_image_path).map(([type, image_path]) => {
              const img__file_p = FileIntegration.imageFromImgSrc_p(image_path);
              const img_p = img__file_p;

              return img_p.then(img => {
                dict_image[type] = img;
                logger.log("loaded image for" + " " + type);
              });
            });

            const assets_p = Promise.all(arr_p)
              .then(arr => {
                return dict_image;
              });

            return assets_p;
          }

          const arr_type = [
            "water",
            "sand",
            "soil",
            "mud",
            "grass",
            "tree__small",
            "tree__big",
          ];

          function easyConfig(type) {

            var fillColor;
            switch (type) {
              case "water":
                fillColor = "cyan";
                break;
              // case "water_deep":
              // fillColor = "blue";
              // break;
              case "sand":
                fillColor = "gold";
                break;
              case "tree__big":
                fillColor = "black";
                break;
              case "tree__small":
                fillColor = "gray";
                break;
              case "grass":
                fillColor = "green";
                break;
              case "soil":
                fillColor = "red";
                break;
              case "mud":
                fillColor = "brown";
                break;

              default:
                fillColor = "";
                break;
            }

            const cfg = {
              strokeColor: "white",
              fillColor: fillColor,
            };

            return cfg;
          }

          function easyHexagon(row, col, type, dict_image) {
            const length = 50;

            const factor__col = (col % 2 == 0) ? (col + 1.0) : (col + 0.5);
            const x = 3 * col * length + ((row % 2 == 0) ? 0 : 1.5) * length;
            const y = row * length * math.sqrt(3) / 2.0;
            const pointTL = Geometry.createPoint(x, y);

            const cfg = easyConfig(type);

            // const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length, cfg);
            // return icHexagon;

            const img = dict_image[type];
            const icImage = infiniteCanvas.createIcImage(pointTL.x, pointTL.y, img);
            const width__tile = 2 * length;
            const height__tile = math.sqrt(3) * length;
            icImage.width = width__tile;
            icImage.height = height__tile;
            icImage.force_width = true;
            icImage.force_height = true;

            // const img_clone = img.clone();
            // const icImage = infiniteCanvas.createIcImage(pointTL.x, pointTL.y, img_clone);
            return icImage;
          }

          function easyDictAbcHexagon() {

            const w = 10;
            const h = 10;

            function empty_dict(w, h) {
              const arr_x = [...Array(w).keys()];
              const arr_y = [...Array(h).keys()];

              const arr_entryX = arr_x.map(x => {
                const arr_entryY = arr_y.map(y => {
                  const entryY = [y, null];
                  return entryY;
                });
                const dict = Object.fromEntries(arr_entryY);
                const entryX = [x, dict];
                logger.log("entryX", entryX);
                return entryX;
              });
              logger.log("arr_entryX", arr_entryX);

              const dict = Object.fromEntries(arr_entryX);
              logger.log("dictXX", dict);
              return dict;
            }

            function arr_prob_gen(type) {

              const dict = {
                "water": [25, 25, 5, 25, 10, 5, 5],
                "sand": [25, 25, 5, 5, 5, 10, 25],
                "soil": [5, 5, 25, 25, 15, 15, 10],
                "mud": [15, 0, 15, 25, 15, 15, 15],
                "tree__big": [0, 0, 10, 10, 35, 25, 20],
                "tree__small": [0, 5, 10, 10, 25, 35, 15],
                "grass": [0, 5, 10, 15, 15, 20, 35],
              };

              var arr_prob = dict[type];
              arr_prob = arr_prob.map(x => x / 100.0);

              return arr_prob;
            }



            function easyType(arr_type__surrounding) {
              var outType;

              logger.log("arr_type__surrounding", arr_type__surrounding);

              outType = "sand";

              if (arr_type__surrounding.length == 0) {
                outType = Utils.randomElementInArray(arr_type);
              } else {
                const arr_arr_weight = arr_type__surrounding.map(type => arr_prob_gen(type));
                logger.log("arr_arr_weight", arr_arr_weight);
                var arr_weight = arr_arr_weight.reduce((acc, x) => {
                  if (acc != null) {
                    acc = x.map(function (e, i) {
                      const sum_ = acc[i] + x[i];
                      return sum_;
                    });
                  } else {
                    acc = x;
                  }
                  return acc;
                });
                arr_weight = arr_weight.map(sum_ => sum_ * 1.0 / arr_type__surrounding.length);

                outType = Utils.randomElementInArray__weighted(arr_type, arr_weight);
              }

              return outType;
            }

            const dict_abcHexagon = empty_dict(w, h);
            logger.log("empty_dict", dict_abcHexagon);

            //generation
            var x = 0;
            var y = 0;
            while (x < w) {
              while (y < h) {
                if (dict_abcHexagon[x][y] == null) {

                  const arr_abcHexagon__surrounding = [
                    dict_abcHexagon[x + 1] ? dict_abcHexagon[x + 1][y + 1] : null,
                    dict_abcHexagon[x] ? dict_abcHexagon[x][y + 2] : null,
                    dict_abcHexagon[x - 1] ? dict_abcHexagon[x - 1][y + 1] : null,
                    dict_abcHexagon[x - 1] ? dict_abcHexagon[x - 1][y - 1] : null,
                    dict_abcHexagon[x] ? dict_abcHexagon[x][y - 2] : null,
                    dict_abcHexagon[x + 1] ? dict_abcHexagon[x + 1][y - 1] : null,
                  ];
                  logger.log("arr_abcHexagon__surrounding", arr_abcHexagon__surrounding);
                  const arr_type__surrounding = arr_abcHexagon__surrounding.filter(abcHex => abcHex != null && abcHex != undefined).map(abcHex => abcHex.type);
                  const type = easyType(arr_type__surrounding);

                  const abcHexagon = {
                    row: x,
                    col: y,
                    type: type,
                  };

                  dict_abcHexagon[x][y] = abcHexagon;
                }
                y = y + 1;
              }
              x = x + 1;
              y = 0;
            }

            return dict_abcHexagon;
          }

          const dict_abcHexagon = easyDictAbcHexagon();
          logger.log("dict_abcHexagon", dict_abcHexagon);

          {
            const w = 10;
            const h = 10;

            const arr_x = [...Array(w).keys()];
            const arr_y = [...Array(h).keys()];

            function icHexagonFromAbcHexagon(abcHexagon, dict_image) {
              const row = abcHexagon.row;
              const col = abcHexagon.col;
              const type = abcHexagon.type;
              return easyHexagon(row, col, type, dict_image);
            }


            loadAssets_p().then(dict_image => {

              arr_x.forEach(x => {
                arr_y.forEach(y => {
                  const abcHexagon = dict_abcHexagon[x][y];
                  const icHexagon = icHexagonFromAbcHexagon(abcHexagon, dict_image);
                  infiniteCanvas.addIcObject(icHexagon);
                });
              });

            });





          }

        }


        debug_povs() {

          //show border rect for starting pov
          const rect__start = infiniteCanvas.getShownRect();
          const icRect__start = infiniteCanvas.createIcRect(rect__start);
          icRect__start.fill = "red";
          infiniteCanvas.addIcObject(icRect__start);

          {
            const rect__1 = {
              x: 2000,
              y: 2000,
              width: 50,
              height: 50,
            };

            const icRect__1 = infiniteCanvas.createIcRect(rect__1);
            icRect__1.fill = "blue";
            infiniteCanvas.addIcObject(icRect__1);


            //animate move to rect1/pov1
            const cfg_anim__easy = {
              duration: 3000,
            };
            infiniteCanvas.move_to_rect__animation(rect__1, cfg_anim__easy);

          }

          {
            const rect__2 = {
              x: -3000,
              y: 2000,
              width: 500,
              height: 500,
            };

            const icRect__2 = infiniteCanvas.createIcRect(rect__2);
            icRect__2.fill = "green";
            infiniteCanvas.addIcObject(icRect__2);


            //animate move to rect2/pov2
            const cfg_anim__easy = {
              duration: 2000,
            };

            setTimeout(() => {
              infiniteCanvas.move_to_rect__animation(rect__2, cfg_anim__easy);
            }, 5000);

            // setTimeout(() => {
            //   infiniteCanvas.move_to_rect__animation(rect__start, cfg_anim__easy);
            // }, 5000);

          }


        }

        debug_qrcode_1() {

          const trueRect = {
            x: 500,
            y: 500,
            width: 100,
            height: 100,
          };


          {
            // const videoEl = document.getElementById('myVideo');
            const videoEl = document.createElement('video');
            videoEl.src = "http://html5demos.com/assets/dizzy.mp4";
            // document.getElementById('myCanvas').appendChild(webcamEl);
            videoEl.style.width = "100px";
            videoEl.style.height = "100px";
            // videoEl.style.display = "none";
            logger.log("log1", "videoEl", videoEl);

            const icVideo = infiniteCanvas.createIcVideo(trueRect.x, trueRect.y, videoEl);

            // const imgEl = document.getElementById("myImage");
            // const icVideo = infiniteCanvas.createIcVideo(trueRect.x, trueRect.y, imgEl);
            logger.log("log1", "icVideo", icVideo);

            infiniteCanvas.addIcObject(icVideo);


            // const canvas = fabricIntegration.fabricCanvas;
            // var video = new fabric.Image(videoEl, {
            //   left: 539,
            //   top: 328,
            //   angle: 94.5,
            //   originX: 'center',
            //   originY: 'center',
            //   objectCaching: false,
            // });
            // canvas.add(video);
            // video.moveTo(0); // move webcam element to back of zIndex stack
            // // video.getElement().play();
            // //
            // // fabric.util.requestAnimFrame(function render() {
            // //   canvas.renderAll();
            // //   fabric.util.requestAnimFrame(render);
            // // });


            // document.getElementById("myButton").addEventListener("click", e => {
            //   logger.log("log1", "myButton.onclick");
            //   videoEl.play();
            //
            //   const rep_free = infiniteCanvas.getRepresented(icVideo.id).r_free();
            //   const fVideo   = fabricIntegration.getFObjForIcObj(rep_free);
            //   // rep_free.position.x = 100;
            //   // rep_free.size.width  = 100;
            //   // rep_free.size.height = 100;
            //
            //   // rep_free.strokeColor = "yellow";
            //
            //   // rep_free.video = videoEl;
            //
            //   fabric.util.requestAnimFrame(function render() {
            //     fabricIntegration.fabricCanvas.requestRenderAll();
            //     fabric.util.requestAnimFrame(render);
            //   });

            // function playTrigger() {
            //   // if(v.paused || v.ended) return false;
            //   // vid.set('time', v.currentTime)
            //   // console.log('current time:', v.currentTime)
            //
            //   const rep_free = infiniteCanvas.getRepresented(icVideo.id).r_free();
            //   const fVideo   = fabricIntegration.getFObjForIcObj(rep_free);
            //
            //   // fVideo.element = document.getElementById('myImage');
            //   rep_free.src = "https://i.stack.imgur.com/8fooU.png";
            //
            //   // infiniteCanvas.updateScaleAndDOffset({
            //   //   X: infiniteCanvas.scale.X * (1.0 + 1e-10),
            //   //   Y: infiniteCanvas.scale.Y * (1.0 + 1e-10),
            //   // }, {dx: 0, dy: 0});
            //   // infiniteCanvas.redrawCanvas(RedrawOccasion.scaleChanged);
            //   // setTimeout(playTrigger,20);
            // }
            //
            // playTrigger();

          }

          {
            // function webcamStream_p() {
            //   return navigator.mediaDevices
            //   .getUserMedia({
            //     video: {
            //       facingMode: "user"
            //     },
            //     audio: false
            //   });
            // }
            //
            // webcamStream_p()
            // .then(function(stream) {
            //   // track = stream.getTracks()[0];
            //   logger.log("log1", "stream", stream);
            //
            //
            //   const webcamEl = document.getElementById('myVideo');
            //   // const webcamEl = document.createElement('video');
            //   // document.getElementById('myCanvas').appendChild(webcamEl);
            //   webcamEl.style.width  = "100px";
            //   webcamEl.style.height = "100px";
            //   webcamEl.style.display = "none";
            //   logger.log("log1", "webcamEl", webcamEl);
            //
            //   // webcamEl.srcObject = stream;
            //   // webcamEl.src = "http://tecfa.unige.ch/guides/html/html5-video/videos/state-of-wikipedia-480x272.mp4";
            //   webcamEl.play();
            //
            //
            //   const icVideo = infiniteCanvas.createIcVideo(trueRect.x, trueRect.y, webcamEl);
            //   logger.log("log1", "icVideo", icVideo);
            //
            //   infiniteCanvas.addIcObject(icVideo);
            //
            //   fabric.util.requestAnimFrame(function render() {
            //     fabricIntegration.fabricCanvas.renderAll();
            //     fabric.util.requestAnimFrame(render);
            //   });
            //
            //
            //   // infiniteCanvas.onceOnAddRepresentedForIcObject(icVideo, (icVideo) => {
            //   //
            //   //   setTimeout(function () {
            //   //
            //   //     logger.log("log1", "fabricIntegration.fObjForIcObj_dict", fabricIntegration.fObjForIcObj_dict);
            //   //
            //   //     const rep_free = infiniteCanvas.getRepresented(icVideo.id).r_free();
            //   //     const fVideo   = fabricIntegration.getFObjForIcObj(rep_free);
            //   //     logger.log("log1", "fVideo", fVideo);
            //   //     fVideo.getElement().play();
            //   //
            //   //     fabric.util.requestAnimFrame(function render() {
            //   //       fabricIntegration.fabricCanvas.renderAll();
            //   //       fabric.util.requestAnimFrame(render);
            //   //     });
            //   //
            //   //   }, 100);
            //   //
            //   // });
            //
            //
            //
            //   // const canvas = fabricIntegration.fabricCanvas;
            //   //
            //   // var webcam = new fabric.Image(webcamEl, {
            //   //   left: 539,
            //   //   top: 328,
            //   //   angle: 94.5,
            //   //   originX: 'center',
            //   //   originY: 'center',
            //   //   objectCaching: false,
            //   // });
            //   //
            //   // canvas.add(webcam);
            //   // webcam.moveTo(0); // move webcam element to back of zIndex stack
            //   // webcam.getElement().play();
            //   //
            //   // fabric.util.requestAnimFrame(function render() {
            //   //   canvas.renderAll();
            //   //   fabric.util.requestAnimFrame(render);
            //   // });
            //
            // })
            // .catch(function(error) {
            //   console.error("Oops. Something is broken.", error);
            // });
          }

        }

        debug_qrcode_2() {

          const trueRect_img = {
            x: 900,
            y: 760,
            width: 100,
            height: 100,
          };

          qrcodeImg_p("get100__[x 2]")
            .then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img);
              icObj_front.scale.X = 1.0;
              icObj_front.scale.Y = 1.0;
              // icObj_front.width  = trueRect_img.width;
              // icObj_front.height = trueRect_img.height;
              infiniteCanvas.addIcObject(icObj_front);
            });

          qrcodeImg_p("get100__[x 3]123456789123456789")
            .then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img);
              icObj_front.scale.X = 1.0;
              icObj_front.scale.Y = 1.0;
              // icObj_front.width  = trueRect_img.width;
              // icObj_front.height = trueRect_img.height;
              infiniteCanvas.addIcObject(icObj_front);
            });


          const trueRect_icEye = {
            x: 880,
            y: 740,
            width: 200,
            height: 200,
          };

          const icEye = infiniteCanvas.createIcEye(trueRect_icEye);
          infiniteCanvas.onceOnAddRepresentedForIcObject(icEye, (icEye) => {

            const rep_free = infiniteCanvas.getRepresented(icEye.id).r_free();

            function attemptDecoding() {
              logger.log("rep_free", rep_free);

              // const imageData = rep_free.imageData__captured;
              // ImageUtils.qrcode__decode_imageData(imageData);

              const img = rep_free.img__captured;
              ImageUtils.qrcode__decode_image_p(img)
                .then((result) => {
                  logger.log("result", result);
                  // document.getElementById('result').textContent = result.text
                }).catch((err) => {
                  console.error(err);
                  // document.getElementById('result').textContent = err
                });
            }

            function loopDecode() {

              setTimeout(function () {

                attemptDecoding();
                loopDecode();

              }, 3000);

            }

            loopDecode();

          });
          infiniteCanvas.addIcObject(icEye);


        }

        debug_video() {



        }


        debug_gemini() {

          //debug
          const mathNode1 = new math.ConstantNode(5);
          mathNode1.value = 7;
          logger.log("mathNode1.value", mathNode1.value);

          const trueRect_mathNode1 = {
            x: 0,
            y: 0,
            width: 100,
            height: 100,
          };
          const icMathNode1 = infiniteCanvas.createIcMathNode(trueRect_mathNode1.x, trueRect_mathNode1.y, mathNode1);
          infiniteCanvas.addIcObject(icMathNode1);


          // const mathNode2 = new math.ConstantNode(10);

          // const geminiObject = new GeminiObject();
          logger.log("GeminiObject.createGemini", GeminiObject.createGemini);
          const gemini__mathNode1 = GeminiObject.createGemini(mathNode1);
          logger.log("gemini__mathNode1.value", gemini__mathNode1.value);

          logger.log("GeminiObject.createMiniGemini", GeminiObject.createMiniGemini);
          const miniGemini__mathNode1 = GeminiObject.createMiniGemini(mathNode1, {
            value: null,
          });
          logger.log("miniGemini__mathNode1.value", miniGemini__mathNode1.value);
          logger.log("miniGemini__mathNode1", miniGemini__mathNode1);



          mathNode1.value = 10;
          logger.log("mathNode1.value", mathNode1.value);
          logger.log("gemini__mathNode1.value", gemini__mathNode1.value);

          setTimeout(() => {
            gemini__mathNode1.value = 20;
            logger.log("gemini__mathNode1.value", gemini__mathNode1.value);
            logger.log("mathNode1.value", mathNode1.value);
          }, 5000);

          setTimeout(() => {

            const rep_free = infiniteCanvas.getRepresented(icMathNode1.id).r_free();
            const gemini__icMathNode_free = GeminiObject.createGemini(rep_free);

            gemini__icMathNode_free.mathNode = new math.ConstantNode(20);
            infiniteCanvas.addIcObject(gemini__icMathNode_free);
          }, 5000);




        }


        debug_number_line() {

          const trueRect = {
            x: 200,
            y: 200,
            width: 800,
            height: 200,
          };

          const sliderConfig = {
            value__L: -100,
            value__R: +100,

            value: +27,
          };

          const icSlider = infiniteCanvas.createIcSlider(trueRect, sliderConfig);
          infiniteCanvas.addIcObject(icSlider);





          const mathNode1 = new math.ConstantNode(7);
          logger.log("mathNode1.value", mathNode1.value);

          const trueRect_mathNode1 = {
            x: 500,
            y: 500,
            width:  100,
            height: 100,
          };
          const icMathNode1 = infiniteCanvas.createIcMathNode(trueRect_mathNode1.x, trueRect_mathNode1.y, mathNode1);
          infiniteCanvas.addIcObject(icMathNode1);


          

          //debug
          // infiniteCanvas.onceOnAddRepresentedForIcObject(icSlider, (icSlider) => {
            
          const rep_free__slider    = infiniteCanvas.getRepresented(icSlider.id).r_free();
          const rep_free__mathNode1 = infiniteCanvas.getRepresented(icMathNode1.id).r_free();

          rep_free__mathNode1.onInnerUpdate((rep_free__mathNode1, propName, oldValue, newValue) => {
            logger.log("log3, rep_free__mathNode1.onInnerUpdate", "propName", propName);
            if(propName == "mathNode") {
              rep_free__slider.mathNode = newValue;
            }            
          });

          // rep_free__mathNode1.onOuterUpdate((rep_free__mathNode1, updateDict) => {
          //   logger.log("log3, rep_free__mathNode1.onOuterUpdate", "updateDict", updateDict);
          //   if(updateDict.propName == "mathNode") {
          //     rep_free__slider.mathNode = updateDict.mathNode.new;
          //   }            
          // });

        }





        debug_th() {
          infiniteCanvas.manageLoadInfinishute(infinishute_th_nostalgie);
        }


        debug_startingScreen() {

          //create text
          {
            const trueRect = {
              x: 100,
              y: 100,
              width: 100,
              height: 100,
            };

            const string__greeting = "Salut user, ça va ?";
            const icObj = infiniteCanvas.createIcText(trueRect.x, trueRect.y, string__greeting);

            // infiniteCanvas.onceOnAddRepresentedForIcObject(icObj, (icObj) => {
            //   const rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();
            //   rep_free.id = 1000;
            // });

            infiniteCanvas.addIcObject(icObj);
          }

          //create text
          {
            const trueRect = {
              x: 100,
              y: 300,
              width: 100,
              height: 100,
            };

            const string__directions = "Load \n /saves/infinishute_tutorial.json \n for tutorial \n (Press L)";
            const icObj = infiniteCanvas.createIcText(trueRect.x, trueRect.y, string__directions);

            // infiniteCanvas.onceOnAddRepresentedForIcObject(icObj, (icObj) => {
            //   const rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();
            //   rep_free.id = 1001;
            // });

            infiniteCanvas.addIcObject(icObj);
          }

          //create text 2
          {
            const trueRect = {
              x: 900,
              y: 760,
              width: 100,
              height: 100,
            };

            const string__clear = "Press K to clear canvas";
            const icObj = infiniteCanvas.createIcText(trueRect.x, trueRect.y, string__clear);
            icObj.fontSize = 30;
            icObj.opacity = 0.5;

            infiniteCanvas.addIcObject(icObj);
          }

          //load logo
          {
            //image
            {
              const trueRect_img = {
                x: 900,
                y: 42,
                width: 100,
                height: 100,
              };

              // const file = new File("saves/last/infinishute_ic3.json");
              // Promise.resolve(file)
              // .then(FileIntegration.createJson_p)
              // .then(infinishute => {
              //   infiniteCanvas.manageLoadInfinishute(infinishute);
              // });

              const img__file_p = FileIntegration.imageFromImgSrc_p("img/ic_better_logo_simple_trans_2.png");
              const img_p = img__file_p;

              img_p.then(img => {
                const icObj_front = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img);
                icObj_front.scale.X = 0.5;
                icObj_front.scale.Y = 0.5;
                infiniteCanvas.addIcObject(icObj_front);
              });
            }

            //text
            {
              const trueRect_txt = {
                x: 900,
                y: 300,
                width: 100,
                height: 100,
              };

              const string__logo = "infiniteCanvas";
              const icObj = infiniteCanvas.createIcText(trueRect_txt.x, trueRect_txt.y, string__logo);
              icObj.scale.X = 0.8;
              icObj.scale.Y = 0.8;
              infiniteCanvas.addIcObject(icObj);
            }

          }

        }


      }

    </script>
    <script>
      setTimeout(() => {    //SHU: wait for mathjax to finish loading
        const atelier__X_X = new Atelier__X_X(infiniteCanvas);          //atelier
      }, 1000);
    </script>









    <script>

      const HexType = [
        "blank",


        "water",
        "sand",
        "soil",
        "mud",
        "grass",
        "tree__small",
        "tree__big",
      ];

      class HexCoordinates {    //hexagonal axial coordinates

        constructor(x, z) {
          this.x = x;
          this.z = z;
        }

        static fromOffsetCoordinates(x, z) {
          // return new HexCoordinates(x - z/2, z);
          return new HexCoordinates(x, z - ((x % 2 == 0) ? x / 2 : (x - 1) / 2));
        }

        getY() {
          return -this.x - this.z;
        }

        distanceTo(other) {
          const x = this.x;
          const y = this.getY();
          const z = this.z;

          const other_y = other.getY();

          const distance =
            ((x < other.x ? other.x - x : x - other.x) +
              (y < other_y ? other_y - y : y - other_y) +
              (z < other.z ? other.z - z : z - other.z)) / 2;
          return distance;
        }

        toString() {
          return "" + this.x + "," + this.z;
        }

      }

      class HexCell {

        constructor(x, y, type = "blank") {

          //squareXY-based coordinates
          this.x = x;
          this.y = y;
          // this.coords_squareXY = new HexCoordinates(x,y);

          //offset coordinates
          this.coords_offset = new HexCoordinates(2 * x + ((y % 2 == 0) ? 0 : 1), (y - ((y % 2 == 0) ? 0 : 1)) / 2);
          //axial  coordinates
          this.coords_axial = HexCoordinates.fromOffsetCoordinates(this.coords_offset.x, this.coords_offset.z);

          this.type = type;

          //flemme
          this.elevation = 0;


          //rx
          this.rx_subject = new Rx.Subject();
          this.rx_observable = this.rx_subject.asObservable();
        }

        setType2(type) {
          this.type = type;
          this.rx_subject.next(this);
        }

        clone_deep() {
          var outCell;

          outCell = new HexCell(this.x, this.y, this.type);

          return outCell;
        }

        static fromAxialCoords(x, z, type = "blank") {
          const x_sq = (x % 2 == 0) ? x / 2 : (x - 1) / 2;
          const y_sq = 2 * z + x;
          return new HexCell(x_sq, y_sq, type);
        }

      }

      class ProtoCell {

        constructor(cell) {
          this.cell = cell;

          this.elevation = 0;
        }

        x() {
          return this.cell.x;
        }

        y() {
          return this.cell.y;
        }

        getPreparedCell() {
          var outCell;

          outCell = this.cell.clone_deep();
          outCell.type = HexMapGenerator.typeForElevation(this.elevation);

          return outCell;
        }

      }

      class PathElement {

        constructor(elt, from) {
          this.elt = elt;
          this.from = from;
        }

      }

      class SearchElement {

        constructor(pathElt, distance_traveled, heuristic_remaining) {
          this.pathElt = pathElt;

          this.distance_traveled = distance_traveled;    //exactly       traveled
          this.heuristic_remaining = heuristic_remaining;  //estimation of remaining
        }

        getPriority() {
          return this.distance_traveled + this.heuristic_remaining;
        }

      }

      class HexMap {

        constructor(type_map) {
          this.type_map = type_map;

          //init
          this.dict_landTypeShare = HexMap.dictLandTypeShareForMapType(this.type_map);
          // logger.log("this.dict_landTypeShare", this.dict_landTypeShare);
          this.average_elevation = HexMap.computeAverageElevation(this.dict_landTypeShare);
        }

        static dictLandTypeShareForMapType(type_map) {
          var outDict;

          switch (type_map) {
            case "forest":
              outDict = {
                "water": 10,
                "sand": 0,
                "soil": 5,
                "mud": 10,
                "grass": 5,
                "tree__small": 30,
                "tree__big": 40,
              };
              break;

            case "river":
              outDict = {
                "water": 60,
                "sand": 10,
                "soil": 0,
                "mud": 10,
                "grass": 0,
                "tree__small": 0,
                "tree__big": 20,
              };
              break;
            case "clear":
            case "village":
            case "fruitland":
            default:
              outDict = {
                "water": 20,
                "sand": 10,
                "soil": 10,
                "mud": 10,
                "grass": 10,
                "tree__small": 20,
                "tree__big": 20,
              };
              break;
          }

          return outDict;
        }

        static elevationForTypeLand(type_land) {
          const arr_type__practical = HexType.slice(0);
          return arr_type__practical.indexOf(type_land);
        }

        static computeAverageElevation(dictLandTypeShare) {
          return Object.entries(dictLandTypeShare).reduce((acc, [type_land, share_land]) => {
            const elevation_type_land = HexMap.elevationForTypeLand(type_land);
            return acc + elevation_type_land * (share_land / 100.0);
          }, 0);
        }

      }

      class HexMapGenerator {

        constructor(grid) {
          this.grid = grid;
        }

        generateMap() {

          //--fill with stuff--
          this.createLand();
        }

        // raiseTerrain(chunkSize) {
        //
        //   // for (var i = 0; i < chunkSize; i++) {
        //   //   this.grid.getRandomCell().type = "grass";
        //   //   // this.grid.getRandomCell().typeIndex = 1;
        //   // }
        //
        //   // {
        //   //   //get cells with same z
        //   //   this.grid.cells.filter(hexCell_i => {
        //   //     // return hexCell_i.coords_offset.z == 10;
        //   //     return hexCell_i.coords_axial.z == 10;
        //   //   }).forEach((hexCell_near, i) => {
        //   //     hexCell_near.type = "sand";
        //   //   });
        //   // }
        //   //
        //   // {
        //   //   //get cells with same x
        //   //   this.grid.cells.filter(hexCell_i => {
        //   //     // return hexCell_i.coords_offset.x == 3;
        //   //     return hexCell_i.coords_axial.x == 3;
        //   //   }).forEach((hexCell_near, i) => {
        //   //     hexCell_near.type = "mud";
        //   //   });
        //   // }
        //
        //   // {
        //   //   //drop of land
        //   //   const hexCell_r = this.grid.getRandomCell();
        //   //   hexCell_r.type = "water";
        //   //
        //   //   this.grid.cells.filter(hexCell_i => {
        //   //     const distance = hexCell_i.coords_axial.distanceTo(hexCell_r.coords_axial);
        //   //     logger.log("distance", distance);
        //   //     return distance == 1;
        //   //   }).forEach((hexCell_near, i) => {
        //   //     hexCell_near.type = "tree__big";
        //   //   });
        //   //
        //   //   this.grid.getCellsAtAxialDistance(hexCell_r, 4)
        //   //   .forEach((hexCell) => {
        //   //     hexCell.type = "grass";
        //   //   });
        //   //
        //   // }
        //
        //   // {
        //   //   //drop of land
        //   //   const hexCell_r = this.grid.getRandomCell();
        //   //   hexCell_r.type = "sand";
        //   //
        //   //   const hexCell_NE = this.grid.getNeighborAtDirection(hexCell_r, "NE");
        //   //   if(hexCell_NE != null) {
        //   //     hexCell_NE.type = "grass";
        //   //   }
        //   //
        //   // }
        //
        //   /*
        //   function typeForDirection(direction) {
        //     var outType;
        //
        //     switch(direction) {
        //       case "N":
        //         outType = "sand";
        //         break;
        //       case "NE":
        //         outType = "soil";
        //         break;
        //       case "SE":
        //         outType = "mud";
        //         break;
        //       case "S":
        //         outType = "grass";
        //         break;
        //       case "SO":
        //         outType = "tree__small";
        //         break;
        //       case "NO":
        //         outType = "tree__big";
        //         break;
        //       default:
        //         throw new Error("unsupported direction: " + direction);
        //         break;
        //     }
        //
        //     return outType;
        //   }
        //
        //   function typeForNeighborIndex(nIndex) {
        //     const dict_type = {
        //       0: "sand",
        //       1: "soil",
        //       2: "mud",
        //       3: "grass",
        //       4: "tree__small",
        //       5: "tree__big",
        //     };
        //     return dict_type[nIndex];
        //   }
        //
        //   {
        //     //drop of land
        //     const hexCell_r = this.grid.getCellAtPos(5,5);
        //     hexCell_r.type = "water";
        //
        //     ["N", "NE", "SE", "S", "SO", "NO"].map(direction => {
        //       const hexCell_neighbor = this.grid.getNeighborAtDirection(hexCell_r, direction);
        //       return [direction, hexCell_neighbor];
        //     })
        //     .forEach(([direction, hexCell]) => {
        //       const type = typeForDirection(direction);
        //       hexCell.type = type;
        //     });
        //
        //   }
        //
        //   {
        //     //drop of land
        //     const hexCell_r = this.grid.getRandomCell();
        //     hexCell_r.type = "water";
        //
        //     Object.entries(this.grid.getDictNeighbor(hexCell_r))
        //     .forEach(([nIndex, hexCell]) => {
        //       const type = typeForNeighborIndex(nIndex);
        //       hexCell.type = type;
        //     });
        //   }
        //   */
        //
        //
        //   /*
        //   {
        //     //find path between cells
        //     const hexCell_from = this.grid.getRandomCell();
        //     logger.log("hexCell_from", [hexCell_from.x, hexCell_from.y]);
        //     hexCell_from.type  = "water";
        //     const hexCell_to   = this.grid.getRandomCell();
        //     logger.log("hexCell_to", [hexCell_to.x, hexCell_to.y]);
        //     hexCell_to.type    = "sand";
        //
        //     // const arr_path = this.grid.findShortestPath(hexCell_from, hexCell_to);
        //     // const arr_path = this.grid.findShortestPath__withHeuristic(hexCell_from, hexCell_to);
        //     const arr_path = this.grid.findShortestPath__withHeuristic__withPQ(hexCell_from, hexCell_to);
        //     logger.log("arr_path", arr_path);
        //     arr_path.slice(1,-1).forEach((hexCell, i) => {
        //       logger.log("hexCell", [hexCell.x, hexCell.y]);
        //       hexCell.type = "mud";
        //     });
        //   }
        //   */
        //
        //   /*
        //   [...Array(5).keys()].forEach((i) => {
        //     const hexCell_r = this.grid.getRandomCell();
        //     hexCell_r.type  = "grass";
        //     // const arr_chunk = this.grid.findAChunk__withHeuristic__withPQ(hexCell_r, 10);
        //     const arr_chunk = this.grid.findAChunk__withHeuristic__withPQ(hexCell_r, 30);
        //
        //     arr_chunk.forEach((hexCell, i) => {
        //       // logger.log("hexCell", [hexCell.x, hexCell.y]);
        //       hexCell.type = "mud";
        //     });
        //   });
        //   */
        //
        // }

        static typeForElevation(elevation_in) {
          var outType;

          const arr_type__practical = HexType.slice(0);
          const nb_type__practical = arr_type__practical.length;

          const elevation = math.min(elevation_in, nb_type__practical - 1);

          outType = arr_type__practical[elevation];

          return outType;
        }

        createLand() {

          const nb_cells = this.grid.cells.length;
          const type_map = "forest";
          // const type_map = "river";
          // const type_map = "clear";

          const hexMap = new HexMap(type_map);
          const dict_landTypeShare = hexMap.dict_landTypeShare;
          const average_elevation = hexMap.average_elevation;

          const share_drop = 10;
          const percentage_drop = share_drop / 100.0;
          const size_drop = math.floor(percentage_drop * nb_cells);

          const nb_drop = math.floor(average_elevation / percentage_drop);
          this.elevateUsingDrops(nb_drop, size_drop);

          this.diffuseToMatchShares(dict_landTypeShare);

          this.cleanOutArtefacts();
        }

        elevateUsingDrops(nb_drop, size_drop) {

          //drops
          [...Array(nb_drop).keys()].forEach((i) => {
            const hexCell_r = HexGridUtils.getRandomCell(this.grid);
            const arr_chunk = HexGridUtils.findAChunk__withHeuristic__withPQ(this.grid, hexCell_r, size_drop);
            arr_chunk.forEach((hexCell, i) => {
              hexCell.elevation += 1;
            });
          });

          //assign types
          this.grid.cells.forEach((cell, i) => {
            cell.type = HexMapGenerator.typeForElevation(cell.elevation);
          });

        }

        diffuseToMatchShares(dict_landTypeShare) {

          const nb_cells = this.grid.cells.length;
          logger.log("nb_cells", nb_cells);

          //sort shares
          const arr_entry_share__sorted = Object.entries(dict_landTypeShare).sort(([k1, v1], [k2, v2]) => {
            return v1 < v2;
          });

          arr_entry_share__sorted.slice(0, -1).forEach(([type, share], i) => {

            //determine nb of cells to paint
            const nb_cells_of_type__target = math.floor(share / 100.0 * nb_cells);
            logger.log("nb_cells_of_type__target", type, nb_cells_of_type__target);
            // if(nb_cells_of_type__target > 0) {

            var nb_cells_of_type__current = this.grid.cells.filter(cell => cell.type == type).length;
            // logger.log("nb_cells_of_type__current", nb_cells_of_type__current);

            if (nb_cells_of_type__current < nb_cells_of_type__target) {

              while (nb_cells_of_type__current < nb_cells_of_type__target) {
                //inject a cell of type
                logger.log("inject a cell of type", type);

                var cell_injection;

                //get a cell in which to inject type
                // const cell_of_type = this.grid.cells.find(cell => cell.type == type);
                const cell_of_type = Utils.randomElementInArray([...this.grid.cells.filter(cell => cell.type == type)]);
                if (cell_of_type != null) {
                  const arr_outerShell = HexGridUtils.findOuterShell_of_area_with_type(this.grid, cell_of_type);
                  // logger.log("arr_outerShell", arr_outerShell);

                  //filter out types that already have correct number of cells
                  const arr_type__too_many = arr_entry_share__sorted.filter(([type, share]) => {
                    const nb_current = this.grid.cells.filter(cell => cell.type == type).length;
                    const nb_target = math.floor(share / 100.0 * nb_cells);
                    return nb_current > nb_target;
                  }).map(([type, share]) => type);

                  const arr_outerShell__filtered = arr_outerShell.filter(cell_outerShell => {
                    return arr_type__too_many.includes(cell_outerShell.type);
                  });

                  if (arr_outerShell__filtered.length > 0) {
                    cell_injection = Utils.randomElementInArray(arr_outerShell__filtered);
                  } else {
                    cell_injection = HexGridUtils.getRandomCell(this.grid);
                    while (!arr_type__too_many.includes(cell_injection.type)) {
                      cell_injection = HexGridUtils.getRandomCell(this.grid);
                    }
                  }

                } else {
                  cell_injection = HexGridUtils.getRandomCell(this.grid);
                  while (!arr_type__too_many.includes(cell_injection.type)) {
                    cell_injection = HexGridUtils.getRandomCell(this.grid);
                  }
                }

                //change type
                cell_injection.type = type;

                nb_cells_of_type__current = this.grid.cells.filter(cell => cell.type == type).length;
                logger.log("nb_cells_of_type__current", nb_cells_of_type__current);
              }

            } else {

              while (nb_cells_of_type__current > nb_cells_of_type__target) {
                //remove a cell of type
                logger.log("remove a cell of type", type);

                //get a cell in which to change type
                // const cell_of_type = this.grid.cells.find(cell => cell.type == type);
                const cell_of_type = Utils.randomElementInArray([...this.grid.cells.filter(cell => cell.type == type)]);

                //change type
                const entry__next = arr_entry_share__sorted[i + 1];
                const type__next = entry__next[0];
                cell_of_type.type = type__next;

                nb_cells_of_type__current = this.grid.cells.filter(cell => cell.type == type).length;
                logger.log("nb_cells_of_type__current", nb_cells_of_type__current);
              }

            }

            // }

          });

          //color blank cells with major type
          const entry__last = arr_entry_share__sorted[arr_entry_share__sorted.length - 1];
          const type__last = entry__last[0];
          this.grid.cells.filter(cell => cell.type == "blank").forEach((cell_blank, i) => {
            cell_blank.type = type__last;
          });



          //debug
          const dict_nb_cell_for_type = Object.fromEntries(arr_entry_share__sorted.map(([type, share]) => {
            const nb_cells_for_type = this.grid.cells.filter(cell => cell.type == type).length;
            const nb_cells_of_type__target = math.floor(share / 100.0 * nb_cells);
            return [type, {
              target: nb_cells_of_type__target,
              actual: nb_cells_for_type,
            }];
          }));
          logger.log("dict_nb_cell_for_type", dict_nb_cell_for_type);

        }

        cleanOutArtefacts() {

        }

      }

      class HexGrid_Rect {

        constructor(w, h) {
          this.w = w;
          this.h = h;
          this.cells = [];

          this.initialize();
        }

        initialize() {
          const nb_cells = this.w * this.h;
          this.cells = [...Array(nb_cells).keys()].map(i => {
            const y = math.floor(i / this.w);
            const x = i - y * this.w;
            const hexCell = new HexCell(x, y, "blank");
            return hexCell;
          })
        }

        getCellAtIndex(i) {
          var outCell = null;
          if (0 <= i && i < this.cells.length) {
            outCell = this.cells[i];
          }
          return outCell;
        }

        getCellAtPos(x, y) {
          var outCell = null;

          const is_invalid_x = (x < 0 || x >= this.w);
          const is_invalid_y = (y < 0 || y >= this.h);
          const is_invalid_xy = is_invalid_x || is_invalid_y;
          if (!is_invalid_xy) {
            outCell = this.getCellAtIndex(x + y * this.w);
          }

          return outCell;
        }

      }

      class HexGrid_Hex {

        constructor(l) {
          this.l = l;
          this.cells = [];

          this.initialize();
        }

        initialize() {

          if (this.l == 0) {
            this.cells = [];
            return;
          }

          if (this.l == 1) {
            const cell__center = new HexCell(0, 0);
            this.cells = [cell__center];
            return;
          }

          function arrCoordsAxialNeighbors(x, z) {
            return [
              new HexCoordinates(x, z - 1),
              new HexCoordinates(x + 1, z - 1),
              new HexCoordinates(x + 1, z),
              new HexCoordinates(x, z + 1),
              new HexCoordinates(x - 1, z + 1),
              new HexCoordinates(x - 1, z),
            ];
          }

          const cell__center = new HexCell(0, 0);
          const dict_cells = [...Array(this.l - 1).keys()].reduce((acc, i) => {

            const dict_current = acc.dict;
            const arr_frontier = acc.frontier;
            logger.log("arr_frontier.length", arr_frontier.length);

            //create outerShell cells
            return arr_frontier.reduce((acc2, cell_frontier) => {
              const x = cell_frontier.coords_axial.x;
              const z = cell_frontier.coords_axial.z;
              const arr_coords_neighbor = arrCoordsAxialNeighbors(x, z);
              const arr_coords_neighbor_fresh = arr_coords_neighbor.filter(coords => {
                const string_coords = coords.toString();
                // logger.log("string_coords", string_coords);
                const isAlreadyInDict = (dict_current[string_coords] != null);
                // logger.log("isAlreadyInDict", isAlreadyInDict);
                return !isAlreadyInDict;
              });
              // logger.log("___");

              const arr_cell_neighbor_fresh = arr_coords_neighbor_fresh.map((coords_axial, i) => {
                return HexCell.fromAxialCoords(coords_axial.x, coords_axial.z);
              });

              const dict_fresh = Object.fromEntries(arr_cell_neighbor_fresh.map(cell => {
                const string_coords = cell.coords_axial.toString();
                return [string_coords, cell];
              }));

              const arr_frontier_out = acc2.frontier.concat(arr_cell_neighbor_fresh);
              const dict_out = Object.assign(acc2.dict, dict_fresh);

              return {
                dict: dict_out,
                frontier: arr_frontier_out,
              };

            }, {
              dict: acc.dict,
              frontier: [],
            });

          }, {
            dict: {
              [cell__center.coords_axial.toString()]: cell__center,
            },
            frontier: [cell__center],
          }).dict;

          this.cells = Object.values(dict_cells);
        }

        getCellAtIndex(i) {
          var outCell = null;
          if (0 <= i && i < this.cells.length) {
            outCell = this.cells[i];
          }
          return outCell;
        }

        getCellAtPos(x, y) {
          var outCell = null;

          outCell = this.cells.find(cell => (cell.x == x && cell.y == y));  //moche mais fu

          return outCell;
        }

      }

      class HexGrid_fromHexGridSeed {

        constructor(grid_seed, n) {
          this.grid_seed = grid_seed;
          this.n = n;

          this.cells = [];

          this.initialize();
        }

        initialize() {
          const nb_cells = this.w * this.h;
          this.cells = [...Array(nb_cells).keys()].map(i => {
            const y = math.floor(i / this.w);
            const x = i - y * this.w;
            const hexCell = new HexCell(x, y, "blank");
            return hexCell;
          });
        }

        getCellAtIndex(i) {
          var outCell = null;
          if (0 <= i && i < this.cells.length) {
            outCell = this.cells[i];
          }
          return outCell;
        }

        getCellAtPos(x, y) {
          var outCell = null;

          const is_invalid_x = (x < 0 || x >= this.w);
          const is_invalid_y = (y < 0 || y >= this.h);
          const is_invalid_xy = is_invalid_x || is_invalid_y;
          if (!is_invalid_xy) {
            outCell = this.getCellAtIndex(x + y * this.w);
          }

          return outCell;
        }

      }

      class HexGridUtils {

        static getRandomCell(grid) {
          return Utils.randomElementInArray(grid.cells);
        }


        //cell neighbors

        static getNeighborAtDirection(grid, hexCell, direction) {

          const is_y_even = (hexCell.y % 2 == 0);
          const dx_y_evenodd = is_y_even ? -1 : 0;

          const dict_xy = {
            N: { x: 0, y: -2 },
            NE: { x: 1 + dx_y_evenodd, y: -1 },
            SE: { x: 1 + dx_y_evenodd, y: 1 },
            S: { x: 0, y: 2 },
            SO: { x: 0 + dx_y_evenodd, y: 1 },
            NO: { x: 0 + dx_y_evenodd, y: -1 },
          };

          const dxdy = dict_xy[direction];
          const x = hexCell.x + dxdy.x;
          const y = hexCell.y + dxdy.y;

          return grid.getCellAtPos(x, y);
        }

        static getNeighborAtIndex(grid, hexCell, index) {

          const is_y_even = (hexCell.y % 2 == 0);
          const dx_y_evenodd = is_y_even ? -1 : 0;

          const dict_xy = {
            0: { x: 0, y: -2 },
            1: { x: 1 + dx_y_evenodd, y: -1 },
            2: { x: 1 + dx_y_evenodd, y: 1 },
            3: { x: 0, y: 2 },
            4: { x: 0 + dx_y_evenodd, y: 1 },
            5: { x: 0 + dx_y_evenodd, y: -1 },
          };

          const dxdy = dict_xy[index];
          const x = hexCell.x + dxdy.x;
          const y = hexCell.y + dxdy.y;

          return grid.getCellAtPos(x, y);
        }

        static getDictNeighbor(grid, hexCell) {
          const arr_entry = [...Array(6).keys()].map(index => {
            const hexCell_neighbor = this.getNeighborAtIndex(grid, hexCell, index);
            return [index, hexCell_neighbor];
          }).filter(([index, hexCell]) => {
            return hexCell != null;
          });
          const dict_neighbor = Object.fromEntries(arr_entry);
          return dict_neighbor;
        }

        static getNeighborAtIndex__alternative_order(grid, hexCell, index) {

          const is_y_even = (hexCell.y % 2 == 0);
          const dx_y_evenodd = is_y_even ? -1 : 0;

          const dict_xy = {
            0: { x: 1 + dx_y_evenodd, y: 1 },
            1: { x: 1 + dx_y_evenodd, y: -1 },
            2: { x: 0, y: 2 },
            3: { x: 0, y: -2 },
            4: { x: 0 + dx_y_evenodd, y: 1 },
            5: { x: 0 + dx_y_evenodd, y: -1 },
          };

          const dxdy = dict_xy[index];
          const x = hexCell.x + dxdy.x;
          const y = hexCell.y + dxdy.y;

          return grid.getCellAtPos(x, y);
        }

        static getDictNeighbor__alternative_order(grid, hexCell) {
          const arr_entry = [...Array(6).keys()].map(index => {
            const hexCell_neighbor = this.getNeighborAtIndex__alternative_order(grid, hexCell, index);
            return [index, hexCell_neighbor];
          }).filter(([index, hexCell]) => {
            return hexCell != null;
          });
          const dict_neighbor = Object.fromEntries(arr_entry);
          return dict_neighbor;
        }


        //distances

        static getDistance__axial(hexCell_from, hexCell_to) {
          return hexCell_from.coords_axial.distanceTo(hexCell_to.coords_axial);
        }

        static getCellsAtAxialDistance(grid, hexCell_c, distance_axial) {

          const dict_cellsAtDistance = grid.cells.map((hexCell_i, i) => {
            const distance = this.getDistance__axial(hexCell_i, hexCell_c);
            const miniDict = {
              i: i,
              hexCell: hexCell_i,
              distance: distance,
            };
            return miniDict;
          }).reduce((acc, x) => {
            if (acc[x.distance] == null) {
              acc[x.distance] = [];
            }
            acc[x.distance].push(x.hexCell);
            return acc;
          }, {});
          // logger.log("dict_cellsAtDistance", dict_cellsAtDistance);

          const arr_cell = dict_cellsAtDistance[distance_axial];
          return arr_cell;
        }


        static getArrDistanceTo__axial(grid, hexCell) {
          const arr_distance = grid.cells.map(hexCell_i => {
            return this.getDistance__axial(hexCell, hexCell_i);
          });
          return arr_distance;
        }

        static getArrDistanceTo__pathfinding(grid, hexCell) {
          const arr_distance = grid.cells.map(hexCell_i => {
            return hexCell.findShortestPathTo(hexCell_i).length;
          });
          return arr_distance;
        }

        static findShortestPathDistance(grid, cell_from, cell_to) {
          return (this.findShortestPath(grid, cell_from, cell_to).length - 1);
        }

        static findShortestPath(grid, cell_from, cell_to) {
          var outArr;

          const is_same_x = (cell_from.x == cell_to.x);
          const is_same_y = (cell_from.y == cell_to.y);
          const is_same_xy = is_same_x && is_same_y;
          if (is_same_xy) {
            return [];
          }

          const queue_frontier = new Queue();

          const pathElt_from = new PathElement(cell_from, null);
          queue_frontier.enqueue(pathElt_from);

          var isReached = false;
          while (!isReached) {
            const pathElt_current = queue_frontier.dequeue();
            const cell_current = pathElt_current.elt;
            const arr_cell_neighbor = Object.values(this.getDictNeighbor(grid, cell_current));

            isReached = arr_cell_neighbor.includes(cell_to);
            if (isReached) {
              //we have found a path
              const pathElt_to = new PathElement(cell_to, pathElt_current);

              //let's rebuild the path
              outArr = this.rebuildPath(pathElt_to);

            } else {
              //continue searching
              const arr_pathElt = arr_cell_neighbor.map(cell => {
                return new PathElement(cell, pathElt_current);
              });

              // queue_frontier.enqueue(...arr_pathElt);    //not working
              arr_pathElt.forEach((pathElt, i) => {
                const arr_cell_frontier = queue_frontier.getArr().map(pathElt => pathElt.elt);
                const is_already_in_queue = arr_cell_frontier.includes(pathElt.elt);
                if (!is_already_in_queue) {
                  queue_frontier.enqueue(pathElt);
                }
              });

              // logger.log("queue_frontier.getLength()", queue_frontier.getLength());
            }
          }

          return outArr;
        }

        static rebuildPath(pathElt_to) {
          var outArr;

          const arrPath_backwards = [];
          arrPath_backwards.push(pathElt_to.elt);

          var pathElt_w = pathElt_to;
          while (pathElt_w.from != null) {
            const pathElt_from = pathElt_w.from;
            arrPath_backwards.push(pathElt_from.elt);

            pathElt_w = pathElt_from;
          }

          outArr = [...arrPath_backwards].reverse();

          return outArr;
        }



        static findShortestPath__withHeuristic(grid, cell_from, cell_to) {
          var outArr;

          const is_same_x = (cell_from.x == cell_to.x);
          const is_same_y = (cell_from.y == cell_to.y);
          const is_same_xy = is_same_x && is_same_y;
          if (is_same_xy) {
            return [];
          }

          // const queue_frontier = new Queue();
          var queue_frontier = [];

          const pathElt_from = new PathElement(cell_from, null);
          const searchElt_from = new SearchElement(pathElt_from, 0, -1);
          queue_frontier.push(searchElt_from);

          var isReached = false;
          var distance_traveled = 0;
          while (!isReached) {
            const dequeued = queue_frontier[0];
            queue_frontier = queue_frontier.slice(1);

            const searchElt_current = dequeued;

            const pathElt_current = searchElt_current.pathElt;
            const cell_current = pathElt_current.elt;
            const arr_cell_neighbor = Object.values(this.getDictNeighbor(grid, cell_current));

            isReached = arr_cell_neighbor.includes(cell_to);
            if (isReached) {
              //we have found a path
              const pathElt_to = new PathElement(cell_to, pathElt_current);

              //let's rebuild the path
              outArr = this.rebuildPath(pathElt_to);

            } else {
              //continue searching
              distance_traveled += 1;

              const arr_searchElt = arr_cell_neighbor.map(cell => {
                const heuristic_remaining = this.getDistance__axial(cell, cell_to);
                const pathElt = new PathElement(cell, pathElt_current);
                const searchElt = new SearchElement(pathElt, distance_traveled, heuristic_remaining);
                return searchElt;
              });

              arr_searchElt.forEach((searchElt, i) => {
                const arr_cell_frontier = queue_frontier.map(searchElt => searchElt.pathElt.elt);
                const is_already_in_queue = arr_cell_frontier.includes(searchElt.pathElt.elt);
                if (!is_already_in_queue) {
                  queue_frontier.push(searchElt);
                }
              });

              //sort frontier using priority
              queue_frontier.sort((searchElt1, searchElt2) => {
                return searchElt1.getPriority() < searchElt2.getPriority();
              });

            }
          }

          return outArr;
        }

        static findShortestPath__withHeuristic__withPQ(cell_from, cell_to) {
          var outArr;

          const is_same_x = (cell_from.x == cell_to.x);
          const is_same_y = (cell_from.y == cell_to.y);
          const is_same_xy = is_same_x && is_same_y;
          if (is_same_xy) {
            return [];
          }

          // const queue_frontier = new Queue();
          var pqueue_frontier = new PriorityQueue();

          const pathElt_from = new PathElement(cell_from, null);
          const searchElt_from = new SearchElement(pathElt_from, 0, -1);
          const pqe_from = new PriorityQueueElement(searchElt_from, searchElt_from.getPriority());
          pqueue_frontier.enqueue(pqe_from);

          var isReached = false;
          var distance_traveled = 0;
          while (!isReached) {
            const pqe_dequeued = pqueue_frontier.dequeue();
            const searchElt_current = pqe_dequeued.payload;
            const pathElt_current = searchElt_current.pathElt;
            const cell_current = pathElt_current.elt;
            // const arr_cell_neighbor = Object.values(this.getDictNeighbor(grid, cell_current));
            // const arr_cell_neighbor = Utils.shuffle(Object.values(this.getDictNeighbor(grid, cell_current)));
            const arr_cell_neighbor = Object.values(this.getDictNeighbor__alternative_order(grid, cell_current));

            isReached = arr_cell_neighbor.includes(cell_to);
            if (isReached) {
              //we have found a path
              const pathElt_to = new PathElement(cell_to, pathElt_current);

              //let's rebuild the path
              outArr = this.rebuildPath(pathElt_to);

            } else {
              //continue searching
              distance_traveled += 1;

              const arr_pqe_neighbor = arr_cell_neighbor.map(cell => {
                const heuristic_remaining = this.getDistance__axial(cell, cell_to);
                const pathElt = new PathElement(cell, pathElt_current);
                const searchElt = new SearchElement(pathElt, distance_traveled, heuristic_remaining);
                const pqe = new PriorityQueueElement(searchElt, searchElt.getPriority());
                return pqe;
              });

              arr_pqe_neighbor.forEach((pqe_neighbor, i) => {
                const cell_neighbor = pqe_neighbor.payload.pathElt.elt;

                const arr_pqe_frontier = pqueue_frontier.arr_priority
                  .filter(priority => priority != null)
                  .reduce((acc, priority_i) => {
                    const arr_priority_i = pqueue_frontier.dict_pqe[priority_i];
                    return acc.concat(arr_priority_i);
                  }, []);
                // logger.log("pqueue_frontier.arr_priority", pqueue_frontier.arr_priority);
                // logger.log("arr_pqe_frontier", arr_pqe_frontier);
                const arr_cell_frontier = arr_pqe_frontier.map(pqe => pqe.payload.pathElt.elt);
                // logger.log("arr_cell_frontier", arr_cell_frontier);

                const is_already_in_queue = arr_cell_frontier.includes(cell_neighbor);

                if (!is_already_in_queue) {
                  //add to frontier
                  pqueue_frontier.enqueue(pqe_neighbor);
                }
                /*
                else {
                  logger.log("is_already_in_queue");

                  //get corresponding existing pqe
                  const pqe_existing = arr_pqe_frontier.find(pqe_frontier => {   //on refait un petit tour pour le plaisir
                    const cell_frontier = pqe_frontier.payload.pathElt.elt;
                    return (cell_frontier == cell_neighbor);
                  });
                  logger.log("pqe_existing.priority", pqe_existing.priority);
                  logger.log("pqe_neighbor.priority", pqe_neighbor.priority);

                  //update priority if better
                  if(pqe_existing.priority > pqe_neighbor.priority) {
                    logger.log("found better");

                    pqueue_frontier.remove(pqe_existing);
                    pqueue_frontier.enqueue(pqe_neighbor);
                  }

                }
                */

              });

            }
          }

          return outArr;
        }


        static findShortestPath__withHeuristic__andObstacles(cell_from, cell_to) {
          var outArr;


          return outArr;
        }



        static findAChunk__withHeuristic__withPQ(grid, cell_from, nb_cells) {
          var outArr;

          const dict_chunk = {};

          // const queue_frontier = new Queue();
          var pqueue_frontier = new PriorityQueue();

          const pathElt_from = new PathElement(cell_from, null);
          const searchElt_from = new SearchElement(pathElt_from, 0, -1);
          const pqe_from = new PriorityQueueElement(searchElt_from, searchElt_from.getPriority());
          pqueue_frontier.enqueue(pqe_from);

          var isEnough = false;
          var distance_traveled = 0;
          while (!isEnough) {

            const arr_chunk = Object.values(dict_chunk);
            isEnough = (arr_chunk.length >= nb_cells);
            if (isEnough) {

              //let's crop the correct number of cells
              outArr = arr_chunk.slice(0, nb_cells);

            } else {
              //continue searching
              distance_traveled += 1;

              const pqe_dequeued = pqueue_frontier.dequeue();
              // logger.log("pqe_dequeued.priority", pqe_dequeued.priority);
              const searchElt_current = pqe_dequeued.payload;
              const pathElt_current = searchElt_current.pathElt;
              const cell_current = pathElt_current.elt;
              const arr_cell_neighbor = Utils.shuffle(Object.values(this.getDictNeighbor(grid, cell_current)));

              arr_cell_neighbor.forEach((cell_neighbor, i) => {

                // const heuristic_remaining = 0;
                const heuristic_remaining = math.randomInt(0, 50);

                const pathElt_neighbor = new PathElement(cell_neighbor, pathElt_current);
                const searchElt_neighbor = new SearchElement(pathElt_neighbor, distance_traveled, heuristic_remaining);
                const pqe_neighbor = new PriorityQueueElement(searchElt_neighbor, searchElt_neighbor.getPriority());

                const string_xy = cell_neighbor.x + "," + cell_neighbor.y;
                const is_already_in_queue = dict_chunk[string_xy] != null;

                if (!is_already_in_queue) {
                  dict_chunk[string_xy] = cell_neighbor;
                  //add to frontier
                  pqueue_frontier.enqueue(pqe_neighbor);
                }

              });

            }
          }

          return outArr;
        }

        static findABChunk__withHeuristic__withPQ(cell_from, cell_to, nb_cells) {
          var outArr;

          return outArr;
        }

        static isContiguous(grid, arr_cell) {

        }

        static sortedClockwise(arr_cell) {

        }

        static findShellCell(grid, arr_cell) {
          var outCell;

          var isFound = false;
          var index = 0;
          while (!isFound) {

            isFound = null;
            if (isFound) {
              outCell = null;
            }

          }

          return outCell;
        }

        static findShellsDict(grid, arr_shell) {

        }

        static findAllInShell(grid, arr_shell) {
          const isContiguous = this.isContiguous(arr_shell);

          if (!isContiguous) {
            throw new Error("arr_shell is not contiguous");
          }

          const dict_shells = this.findShellsDict(grid, arr_shell);

        }

        static findInnerShell(grid, arr_cell_seed) {
          return arr_cell_seed.filter(cell => {
            const isInnerShellCell = (Object.values(this.getDictNeighbor(grid, cell)).length < 6);
            return isInnerShellCell;
          });
        }

        static findOuterShell(grid, arr_cell_seed) {

          const arr_innerShell = this.findInnerShell(grid, arr_cell_seed);



          // arr_cell_neighbor.forEach((cell_neighbor, i) => {
          //
          //   // const heuristic_remaining = 0;
          //   const heuristic_remaining = math.randomInt(0, 50);
          //
          //   const pathElt_neighbor      = new PathElement(cell_neighbor, pathElt_current);
          //   const searchElt_neighbor    = new SearchElement(pathElt_neighbor, distance_traveled, heuristic_remaining);
          //   const pqe_neighbor          = new PriorityQueueElement(searchElt_neighbor, searchElt_neighbor.getPriority());
          //
          //   const string_xy           = cell_neighbor.x + "," + cell_neighbor.y;
          //   const is_already_in_queue = dict_chunk[string_xy] != null;
          //
          //   if(!is_already_in_queue) {
          //     dict_chunk[string_xy] = cell_neighbor;
          //     //add to frontier
          //     pqueue_frontier.enqueue(pqe_neighbor);
          //   }

        }



        static findShellChunk(grid, arr_cell_seed, nb_shell_layers) {
          return [...Array(nb_shell_layers).keys()].reduce((acc, i) => {
            const arr_outerShell = this.findOuterShell(grid, acc);
            return acc.concat(arr_outerShell);
          }, [...arr_cell_seed]);
        }

        static findArea_with_element_of_type(grid, cell_from) {
          var outArr;

          const type__target = cell_from.type;

          const dict_chunk = {};

          const string_xy = cell_from.x + "," + cell_from.y;
          dict_chunk[string_xy] = cell_from;

          // const queue_frontier = new Queue();
          var pqueue_frontier = new PriorityQueue();

          const pathElt_from = new PathElement(cell_from, null);
          const searchElt_from = new SearchElement(pathElt_from, 0, -1);
          const pqe_from = new PriorityQueueElement(searchElt_from, searchElt_from.getPriority());
          pqueue_frontier.enqueue(pqe_from);

          var isFull = false;
          var distance_traveled = 0;
          while (!isFull) {

            //continue searching
            distance_traveled += 1;

            const pqe_dequeued = pqueue_frontier.dequeue();
            // logger.log("pqe_dequeued.priority", pqe_dequeued.priority);
            const searchElt_current = pqe_dequeued.payload;
            const pathElt_current = searchElt_current.pathElt;
            const cell_current = pathElt_current.elt;
            const arr_cell_neighbor = Utils.shuffle(Object.values(this.getDictNeighbor(grid, cell_current)));

            arr_cell_neighbor.forEach((cell_neighbor, i) => {

              // const heuristic_remaining = 0;
              const heuristic_remaining = math.randomInt(0, 50);

              const pathElt_neighbor = new PathElement(cell_neighbor, pathElt_current);
              const searchElt_neighbor = new SearchElement(pathElt_neighbor, distance_traveled, heuristic_remaining);
              const pqe_neighbor = new PriorityQueueElement(searchElt_neighbor, searchElt_neighbor.getPriority());

              const isValidType = (cell_neighbor.type == type__target);
              // logger.log("isValidType", isValidType);

              if (isValidType) {

                const string_xy = cell_neighbor.x + "," + cell_neighbor.y;
                const is_already_in_queue = dict_chunk[string_xy] != null;

                if (!is_already_in_queue) {
                  dict_chunk[string_xy] = cell_neighbor;
                  //add to frontier
                  pqueue_frontier.enqueue(pqe_neighbor);
                }

              }

            });

            isFull = pqueue_frontier.isEmpty();
          }

          const arr_chunk = Object.values(dict_chunk);
          outArr = arr_chunk;

          return outArr;
        }

        static findOuterShell_of_area_with_type(grid, cell_of_type) {

          const arr_area = this.findArea_with_element_of_type(grid, cell_of_type);
          // logger.log("arr_area.length", arr_area.length);

          const dict_outerShell = arr_area.reduce((acc, cell_area) => {
            const arr_cell_neighbor = Object.values(this.getDictNeighbor(grid, cell_area));
            // logger.log("arr_cell_neighbor", arr_cell_neighbor);
            arr_cell_neighbor.forEach((cell_neighbor, i) => {
              const isOuterCell = (cell_neighbor.type != cell_area.type);
              // logger.log("isOuterCell", isOuterCell);
              if (isOuterCell) {
                const string_xy = cell_neighbor.x + "," + cell_neighbor.y;
                if (!acc[string_xy]) {
                  acc[string_xy] = cell_neighbor;
                }
              }
            });
            return acc;
          }, {});

          const arr_outerShell = Object.values(dict_outerShell);

          return arr_outerShell;
        }

      }

      class Bridge__Crossroads {

        constructor() {
          this.dict_crossroads = {};
        }

        crossroadsObj(id_any) {
          return this.dict_crossroads[id_any];
        }

        add(crossroadsObj) {
          crossroadsObj.getRoads().forEach((road, i) => {
            const identified = crossroadsObj.identifiedForRoad(road);
            const id_ = identified.id();
            // logger.log("setting", id_);
            this.dict_crossroads[id_] = crossroadsObj;
          });
        }

        remove(crossroadsObj) {
          crossroadsObj.getRoads().forEach((road, i) => {
            const identified = crossroadsObj.identifiedForRoad(road);
            const id_ = identified.id();
            delete this.dict_crossroads[id_];
          });
        }

      }

      class Identified {
        constructor(obj, func_id) {
          this.obj = obj;
          this.func_id = func_id;
        }

        id() {
          return this.func_id(this.obj);
        }
      }

      class CrossroadsObj {

        constructor(dict_identified) {
          this.dict_identified = dict_identified;
        }

        getRoads() {
          return Object.keys(this.dict_identified);
        }

        identifiedForRoad(road) {
          return this.dict_identified[road];
        }

        objectForRoad(road) {
          return this.identifiedForRoad(road).obj;
        }

      }

      class OyaGame {

        /* still_river

          hexCoordinates:
            square-xy-based
            offset
            axial

          0 raccourcis clavier pour spawn
              joueurs
              animaux
              symboles (croix, triangle de danger)

          0 pour faire plus vrai:
              les maps d'évènements sont spawnées après que le MJ a zoomé
              le MJ peut ensuite les effacer si ça fait ramer la page

          0 missing assets:
              river Oyapock (story map)

          22 décembre 2021:
            ANNIV LOIC
            plusieurs façons de générer:
              proche en proche probabiliste
              placer des fils au fur et à mesure
              placer des fractales au fur et à mesure
              faire des patates, avec des patates dedans

              grossir des zones en "consommant la frontière"

            0 path between 2 selected cells

            0 définir la "distance de traversée" pour passer d'une cellule d'un type X à une cellule d'un type Y
                espace dual

            0 afficher tous les chemins les plus courts différents

          23 décembre 2021:
            1 A*
              0 sorted list
              0 priority queue:
                change neighbor priority if a shorter route has been found

          26 décembre 2021:
            0 creating a terrain chunk can be done via:
                moving out of a center cell
                moving in to a destination center cell (like the end of a pathfinding)

            0X avoid repainting (==overlapping) what has already been painted
              => actually it is another key element of terrain generation

          27 décembre 2021:
            =>=> GENERATION PAR TACHES ! et contrôle au fur et à mesure
              "créer de l'existant" (==premier(s) jet(s)) pour ensuite le retravailler

            0 essayer sans overlap et avec des gouttes de plus en plus petites (share wrt remaining)

            0 Hexagonal map !
                et la route vers le fractal
                0 faire simple

            0 any shape map

            0 paint/drip

          28 décembre 2021:
            0 corriger le premier jet

          29 décembre 2021:
            0 fill tool
              0 event: cell selected : get "HexModel" object
                => Bridge__Crossroads
                => Reactive bridge

                0 remove biobj when removing cell
              0 highlight selection
              0 area of type

          11 janvier 2022:
            1 retour sur la génération retravaillée
              1 il faut ne pas toucher à nouveau aux types que l'on a ajustés
                => outerShell().filter(ne garder que les types qui ont des cellules en trop)
                   random(grid.cells.filter(ne garder que les types qui ont des cellules en trop))
              |-> l'algorithme a pour effet de "rejeter la boue sur les côtés"...
                    (les types avec des petites parts de marché sont relégués à la périphérie)
              0? trouver une autre façon de rétablir les pourcentages
          13 janvier 2022:
              => 1 utiliser random(arr.filter()) à la place de arr.find()

              0 utiliser une hierarchie de mutabilité
                0 ou utiliser un système de poussée: si sand devient water alors un des voisins de sand devient sand

            0 endless loop when share tree__big too small ( "river" map  usecase)
                while() loops are kind of evil...

          19 janvier 2022:
            LOIC:
            0 ligne de commande pour muter une cellule avec son identifiant
            0 carte de l'Oyapock : possibilité de zoomer et respecter les cours d'eau et l'élévation


        */

        constructor() {

          this.arr_map_types = [
            "forest",
            "river",
            "clear",
            "village",
            "fruitland",
          ];

          this.w = 14;
          this.h = 28;

          // this.hexGrid      = new HexGrid_Rect(this.w,this.h);
          this.hexGrid = new HexGrid_Hex(this.w);

          this.mapGenerator = new HexMapGenerator(this.hexGrid);

          this.bridge = new Bridge__Crossroads();

          this.initialize();
        }

        initialize() {
          this.mapGenerator.generateMap();

          //bind to events
          infiniteCanvas.rx_icEvent_observable.subscribe({
            next: (value) => {
              console.log("rx_icEvent_subject", "next", value);

              const icEvent = value;

              const id_icObj = icEvent.data.id;
              const crossroadsObj = this.bridge.crossroadsObj(id_icObj);
              const hexCell = crossroadsObj.objectForRoad("hexCell");

              // hexCell.type = "sand";
              hexCell.setType2("sand");

            },
          });

          this.loadAssets_p()
            .then(dict_image => {

              this.dict_image = dict_image;

              this.render(dict_image);
            });
        }

        loadAssets_p() {
          const dict_image_path = {
            "water": "img/oyagame/water__ok.png",
            "sand": "img/oyagame/sand.png",
            "soil": "img/oyagame/soil.png",
            "mud": "img/oyagame/mud.png",
            "grass": "img/oyagame/grass.png",
            "tree__small": "img/oyagame/tree__small.png",
            "tree__big": "img/oyagame/tree__big.png",
          };

          var dict_image = {};
          const arr_p = Object.entries(dict_image_path).map(([type, image_path]) => {
            const img__file_p = FileIntegration.imageFromImgSrc_p(image_path);
            const img_p = img__file_p;

            return img_p.then(img => {
              dict_image[type] = img;
              logger.log("loaded image for" + " " + type);
            });
          });

          const assets_p = Promise.all(arr_p)
            .then(arr => {
              return dict_image;
            });

          return assets_p;
        }

        render(dict_image) {

          this.hexGrid.cells.map(hexCell => {

            const icHexagon = this.createIcObjectForHexCell(hexCell, dict_image);

            //bridge
            const crossroadsObj = new CrossroadsObj({
              "hexCell": new Identified(hexCell, this.id_hexCell),
              "icObj": new Identified(icHexagon, this.id_icObj),
            });
            this.bridge.add(crossroadsObj);

            //bind
            hexCell.rx_observable.subscribe({
              next: (value) => {
                logger.log("hexCell.rx_observable", "next", value);
                this.updateIcObj(icHexagon, hexCell);
              },
            })

            infiniteCanvas.addIcObject(icHexagon);
          });

        }

        id_hexCell(hexCell) {
          return hexCell.coords_axial.toString();
        }

        id_icObj(icObj) {
          return icObj.id;
        }

        hexCellForIcObj(icObj) {
          const id = this.id_icObj(icObj);
          logger.log("id", id);
          const crossroadsObj = this.bridge.crossroadsObj(id);
          return crossroadsObj.objectForRoad("hexCell");
        }

        icObjForHexCell(hexCell) {
          const id = this.id_hexCell(hexCell);
          logger.log("id", id);
          const crossroadsObj = this.bridge.crossroadsObj(id);
          return crossroadsObj.objectForRoad("icObj");
        }



        easyConfig(type) {

          var fillColor;
          switch (type) {
            case "blank":
              fillColor = "white";
              break;


            case "water":
              fillColor = "cyan";
              break;
            // case "water_deep":
            // fillColor = "blue";
            // break;
            case "sand":
              fillColor = "gold";
              break;
            case "tree__big":
              fillColor = "black";
              break;
            case "tree__small":
              fillColor = "gray";
              break;
            case "grass":
              fillColor = "green";
              break;
            case "soil":
              fillColor = "red";
              break;
            case "mud":
              fillColor = "brown";
              break;

            default:
              fillColor = "";
              break;
          }

          const cfg = {
            strokeColor: "white",
            fillColor: fillColor,
          };

          return cfg;
        }

        createIcObjectForHexCell(hexCell, dict_image) {
          var outIcObj;

          // const length = 50;
          const length = 20;

          const row = hexCell.y;
          const col = hexCell.x;

          const factor__col = (col % 2 == 0) ? (col + 1.0) : (col + 0.5);
          const x = 3 * col * length + ((row % 2 == 0) ? 0 : 1.5) * length;
          const y = row * length * math.sqrt(3) / 2.0;
          const pointTL = Geometry.createPoint(x, y);


          const type = hexCell.type;
          const cfg = this.easyConfig(type);

          switch (type) {
            case "blank":
              {
                const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length, cfg);
                outIcObj = icHexagon;
              }
              break;
            default:
              // throw new Error("unsupported type:" + type);
              {
                const img = dict_image[type];
                const icImage = infiniteCanvas.createIcImage(pointTL.x, pointTL.y, img);
                // const img_clone = img.clone();
                // const icImage = infiniteCanvas.createIcImage(pointTL.x, pointTL.y, img_clone);
                const width__tile = 2 * length;
                const height__tile = math.sqrt(3) * length;
                icImage.width = width__tile;
                icImage.height = height__tile;
                icImage.force_width = true;
                icImage.force_height = true;

                outIcObj = icImage;
              }
              break;
            // break;
          }

          return outIcObj;
        }

        updateIcObj(icObj, hexCell) {
          // icObj.strokeWidth = 5;
          // icObj.strokeColor = "cyan";

          const type = hexCell.type;
          const img = this.dict_image[type];

          //get free rep
          const represented = infiniteCanvas.getRepresented(icObj.id);
          const rep_free = represented.r_free();

          rep_free.img = img;
        }

      }

    </script>
    <script>
      // const oyagame = new OyaGame();
    </script>




    <script>
      class GET100_Game {

        constructor(infiniteCanvas) {
          this.infiniteCanvas = infiniteCanvas;

          const value__initial = 0;
          const value__target = 100;

          //model
          this.gameState = new GET100_GameState(value__initial, value__target);
          this.rx_subject__gameState = new Subject();
          this.rx_observable__gameState = this.rx_subject__gameState.asObservable();

          this.gameInput = new GET100_GameInput();

          this.cardCollection = new GET100_CardCollection();
          Object.defineProperty(this, "dict_card", {
            get() {
              return this.cardCollection.dict_card;
            }
          });
          Object.defineProperty(this, "arr_card", {
            get() {
              return this.cardCollection.arr_card;
            }
          });

          //view
          this.dict_view = {};
          this.bindToIc__state_and_input(infiniteCanvas);
          // this.bindToIc__cards(infiniteCanvas);


          //"outer" view
          this.bindToIc__webcam(infiniteCanvas);
          // this.managePrintedCards();


          this.start();
        }



        bindToIc__state_and_input(infiniteCanvas) {
          const game = this;

          //spawn
          const ic__gameState = GET100_Game.ic__gameState(infiniteCanvas, this.gameState);
          infiniteCanvas.onceOnAddRepresentedForIcObject(ic__gameState, (ic__gameState) => {
            const rep_free = infiniteCanvas.getRepresented(ic__gameState.id).r_free();
            rep_free.position = {
              x: 50,
              y: 0,
            };
          });
          infiniteCanvas.addIcObject(ic__gameState);
          this.dict_view["gameState"] = ic__gameState;




          const ic__gameInput = this.ic__gameInput(infiniteCanvas, this.gameInput);
          infiniteCanvas.onceOnAddRepresentedForIcObject(ic__gameInput, (ic__gameInput) => {
            const rep_free = infiniteCanvas.getRepresented(ic__gameInput.id).r_free();
            rep_free.position = {
              x: 50,
              y: 400,
            };
          });
          infiniteCanvas.addIcObject(ic__gameInput);
          this.dict_view["gameInput"] = ic__gameInput;



          function func_validInput() {
            func_gameInputColorBlink("lime", 300);
          }
          this.dict_view["func_validInput"] = func_validInput;

          function func_invalidInput() {
            func_gameInputColorBlink("red", 300);
          }
          this.dict_view["func_invalidInput"] = func_invalidInput;


          function func_gameInputColorBlink(colorName, duration_in_milliseconds) {
            const rep_free = infiniteCanvas.getRepresented(ic__gameInput.id).r_free();
            const fColor__fill = new fabric.Color(colorName);
            fColor__fill.setAlpha(0.5);
            rep_free.fill = fColor__fill.toRgba();
            setTimeout(function () {
              rep_free.fill = "transparent";
            }, duration_in_milliseconds);
          }


          //--control--

          //forward gameState updates
          this.rx_observable__gameState.subscribe({
            next: (gameState) => {
              logger.log("rx_observable__gameState", "next", gameState.value__current);

              const rep_free = infiniteCanvas.getRepresented(ic__gameState.id).r_free();
              rep_free.parts.icMathNode__current.mathNode = new math.ConstantNode(gameState.value__current);
              rep_free.parts.icMathNode__target.mathNode = new math.ConstantNode(gameState.value__target);

            },
          });


        }

        bindToIc__cards(infiniteCanvas) {
          const game = this;


          const ic__dict_card = {};
          this.arr_card.forEach((card, i) => {
            const ic__card = GET100_Game.ic__card(infiniteCanvas, card);
            infiniteCanvas.addIcObject(ic__card);

            const identifier = card.getIdentifier();
            ic__dict_card[identifier] = ic__card;
          });
          this.dict_view["dict_card"] = ic__dict_card;


          //--control--

          //hooks
          Hooker.installHooks(GET100_Game, "manageGameAction__playCard");      //SHU: I tried to install hooks on instance but it did not work... (does it really matter ?)
          GET100_Game.did["manageGameAction__playCard"].on((game, card) => {
            logger.log("did playCard", game, card);

            //destroy view
            const identifier = card.getIdentifier();
            const ic__card = game.dict_view.dict_card[identifier];
            const rep_free = infiniteCanvas.getRepresented(ic__card.id).r_free();
            infiniteCanvas.killComposite(rep_free);

            //destroy model
            const opSimpleName = card.get100Operator.getSimpleName();
            const index_card = card.index;
            delete game.dict_card[opSimpleName][index_card];
          });


        }

        bindToIc__webcam(infiniteCanvas) {
          const game = this;

          //spawn
          GET100_Game.ic__webcam_p(infiniteCanvas).then(ic__webcam => {

            infiniteCanvas.onceOnAddRepresentedForIcObject(ic__webcam, (ic__webcam) => {
              const rep_free = infiniteCanvas.getRepresented(ic__webcam.id).r_free();
              rep_free.position = {
                x: 50,
                y: 400,
              };
              // rep_free.scale.X = 0.31;
              // rep_free.scale.Y = 0.31;
              rep_free.scale.X = 0.62;
              rep_free.scale.Y = 0.62;
              // rep_free.scale.X = 1;
              // rep_free.scale.Y = 1;
            });
            infiniteCanvas.addIcObject(ic__webcam);
            this.dict_view["webcam"] = ic__webcam;

          });
        }

        static ic__gameState(infiniteCanvas, gameState) {

          const icComposite = GET100_Game.ic_template__gameState(infiniteCanvas);

          //invest
          const value__current = gameState.value__current;
          const mathNode__current = new math.ConstantNode(value__current);
          icComposite.parts.icMathNode__current.mathNode = mathNode__current;

          const value__target = gameState.value__target;
          const mathNode__target = new math.ConstantNode(value__target);
          icComposite.parts.icMathNode__target.mathNode = mathNode__target;

          return icComposite;
        }

        static ic_template__gameState(infiniteCanvas) {
          var outIcObj;

          const trueRect_background = {
            x: 0,
            y: 0,
            width: 200,
            height: 400,
          };
          const icRect = infiniteCanvas.createIcRect(trueRect_background);
          icRect.fill = "blanchedalmond";

          //current
          //label: current
          const trueRect_label__current = {
            x: 5,
            y: 5,
            width: 100,
            height: 100,
          };
          const icLabel__current = infiniteCanvas.createIcText(trueRect_label__current.x, trueRect_label__current.y, "current:");

          //mathNode: current
          const trueRect_mathNode__current = {
            x: 50,
            y: 100,
            width: 100,
            height: 100,
          };
          const mathNode__current = new math.ConstantNode(0);
          const icMathNode__current = infiniteCanvas.createIcMathNode(trueRect_mathNode__current.x, trueRect_mathNode__current.y, mathNode__current);

          //target
          //label: target
          const trueRect_label__target = {
            x: 5,
            y: 205,
            width: 100,
            height: 100,
          };
          const icLabel__target = infiniteCanvas.createIcText(trueRect_label__target.x, trueRect_label__target.y, "target:");

          //mathNode: target
          const trueRect_mathNode__target = {
            x: 50,
            y: 300,
            width: 100,
            height: 100,
          };
          const mathNode__target = new math.ConstantNode(100);
          const icMathNode__target = infiniteCanvas.createIcMathNode(trueRect_mathNode__target.x, trueRect_mathNode__target.y, mathNode__target);




          //composite
          const parts = {
            "bg": icRect,

            "icLabel__current": icLabel__current,
            "icMathNode__current": icMathNode__current,

            "icLabel__target": icLabel__target,
            "icMathNode__target": icMathNode__target,
          };

          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);


          const trueRect_composite = {
            x: 0,
            y: 0,
            width: 200,
            height: 400,
          };

          const icComposite = infiniteCanvas.createIcComposite(trueRect_composite, parts, compositeConfig);
          icComposite.cType = "GET100_GameState";
          icComposite.fill = "";

          outIcObj = icComposite;

          return outIcObj;
        }

        ic__gameInput(infiniteCanvas, gameInput) {
          const game = this;

          const trueRect_icEye = {
            x: 50,
            y: 200,
            width: 300,
            height: 300,
          };

          const icEye = infiniteCanvas.createIcEye(trueRect_icEye);
          icEye.zIndex = 100;

          infiniteCanvas.onceOnAddRepresentedForIcObject(icEye, (icEye) => {

            const rep_free = infiniteCanvas.getRepresented(icEye.id).r_free();

            function attemptDecoding() {

              const img = rep_free.img__captured;

              if (img != null) {
                ImageUtils.qrcode__decode_image_p(img)
                  .then((result) => {
                    logger.log("result", result);
                    if (result != null) {
                      // const str__result = result.text;
                      const str__result = result;

                      const rawInput = str__result;
                      game.manageGameInput__rawInput(rawInput);
                    }
                  }).catch((err) => {
                    // console.error(err);
                  });
              }

            }

            function loopDecode() {

              setTimeout(function () {

                attemptDecoding();
                loopDecode();

              }, 300);

            }

            loopDecode();

          });

          return icEye;
        }

        static ic__card(infiniteCanvas, card) {

          //card template
          const icCard = GET100_Game.ic_template__card(infiniteCanvas);

          //invest
          infiniteCanvas.onceOnAddRepresentedForIcObject(icCard, (icCard) => {

            const rep_free__composite = infiniteCanvas.getRepresented(icCard.id).r_free();

            //qrcode img
            qrcodeImg_p(card.getIdentifier())
              .then(img => {
                rep_free__composite.parts.image.img = img;
              });

            //operator
            rep_free__composite.parts.label__operator.text = card.get100Operator.getSimpleName();

          });

          return icCard;
        }

        static ic_template__card(infiniteCanvas) {
          var outIcObj;

          const trueRect_background = {
            x: 0,
            y: 0,
            width: 250,
            height: 350,
          };
          const icRect = infiniteCanvas.createIcRect(trueRect_background);
          icRect.fill = "grey";

          //img
          const trueRect_img = {
            x: 75,
            y: 75,
            width: 100,
            height: 100,
          };
          const icImage = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, null);

          //operator
          const trueRect_operator = {
            x: 75,
            y: 200,
            width: 100,
            height: 100,
          };
          // const icGMOperator = infiniteCanvas.createIcGMOperator(trueRect_operator, "x 2");
          const icLabel__operator = infiniteCanvas.createIcText(trueRect_operator.x, trueRect_operator.y, "");



          //composite
          const parts = {
            "bg": icRect,
            "image": icImage,
            // "gmOperator": icGMOperator,
            "label__operator": icLabel__operator,
          };

          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);


          const trueRect_composite = {
            x: 500,
            y: 0,
            width: 250,
            height: 350,
          };

          const icComposite = infiniteCanvas.createIcComposite(trueRect_composite, parts, compositeConfig);
          icComposite.cType = "GET100_Card";
          icComposite.fill = "";

          outIcObj = icComposite;

          return outIcObj;
        }

        static ic__webcam_p(infiniteCanvas) {
          const trueRect_webcam = {
            x: 0,
            y: 0,
            width: 200,
            height: 200,
          };
          var out_p = FileIntegration.videoFromWebcam_p()
            .then(video => {
              const left = trueRect_webcam.x;
              const top = trueRect_webcam.y;

              const icVideo = infiniteCanvas.createIcVideo(left, top, video);
              return icVideo;
            });
          return out_p;
        }



        start() {
          const game = this;

          this.gameInput.rx_observable__gameInput.subscribe({
            next: (card) => {
              GET100_Game.manageGameAction__playCard(game, card);
            },
          });

          this.rx_observable__gameState.subscribe({
            next: (gameState) => {
              const value__current = gameState.value__current;
              if (value__current == gameState.value__target) {
                gameState.value__target = 100 - value__current;

                //notify update
                game.rx_subject__gameState.next(game.gameState);   //SHU: un peu cracra
              }
            },
          });

        }


        manageGameInput__rawInput(rawInput) {
          const card = this.cardCollection.getCardWithIdentifier(rawInput);
          if (card != null) {
            this.gameInput.rx_subject__gameInput.next(card);
          } else {
            throw new Error("no card found for input: " + rawInput);
          }
        }


        static manageGameAction__playCard(game, card) {
          logger.log("manageGameAction__playCard", game, card);

          //green blink
          game.dict_view.func_validInput();


          const value__current = game.gameState.value__current;
          const mathNode__current = new math.ConstantNode(value__current);
          mathNode__current.autoSimplify = true;

          const get100Operator = card.get100Operator;
          const func = get100Operator.operatorNodeFactoryFuncWrapper.func;
          const mathNode__result = func(mathNode__current);

          game.gameState.value__current = mathNode__result.value;

          //notify update
          game.rx_subject__gameState.next(game.gameState);
        }

      }

      class GET100_GameState {

        constructor(value__initial, value__target) {
          this.value__initial = value__initial;
          this.value__current = this.value__initial;

          this.value__target = value__target;
        }

      }

      class GET100_GameInput {

        constructor() {
          this.rx_subject__gameInput = new Subject();
          this.rx_observable__gameInput = this.rx_subject__gameInput.asObservable();
        }

      }

      class GET100_Operator {

        constructor(operatorNodeFactoryFuncWrapper) {
          this.operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper;
        }

        getSimpleName() {
          return GET100_Operator.operatorSimpleName(this.operatorNodeFactoryFuncWrapper);
        }

        static operatorSimpleName(operatorNodeFactoryFuncWrapper) {
          return operatorNodeFactoryFuncWrapper.semantics.name;
        }

      }

      class GET100_Card {

        constructor(get100Operator, index) {
          this.get100Operator = get100Operator;
          this.index = index;
        }

        getIdentifier() {
          const str__id = "GET100__" + this.get100Operator.getSimpleName();
          const str__index = "#" + this.index;
          const str__full = str__id + "" + str__index;
          return str__full;
        }

      }

      class GET100_CardCollection {

        constructor() {
          const arr_operator = this.createArrOperator();  //may contain an operator multiple times

          this.dict_card = this.createDictCard(arr_operator); //example of use: dict.operator[opSimpleName].arr_instance[2]
          this.arr_card = this.createArrCard(this.dict_card);
        }

        createDictCard(arr_operator) {
          var outDict;

          outDict = arr_operator.reduce((acc, op) => {
            const str__opSimpleName = op.getSimpleName();

            if (acc[str__opSimpleName] == null) {
              acc[str__opSimpleName] = {};
            }

            const index_card = [...Object.values(acc[str__opSimpleName])].length;
            const card = new GET100_Card(op, index_card);
            acc[str__opSimpleName][index_card] = card;

            return acc;
          }, {});

          return outDict;
        }

        createArrCard(dict_card) {
          var outArr;

          const arr_card = [...Object.values(dict_card)].reduce((acc, x) => {
            return acc.concat([...Object.values(x)]);
          }, []);

          const arr_card__shuffled = Utils.shuffle([...arr_card]);
          outArr = arr_card__shuffled;
          return outArr;
        }

        createArrOperator() {
          var outArr;

          const arr_operatorNodeFactoryFuncWrapper = this.createArrOperatorNodeFactoryFuncWrapper();

          outArr = arr_operatorNodeFactoryFuncWrapper.map(operatorNodeFactoryFuncWrapper => {
            return new GET100_Operator(operatorNodeFactoryFuncWrapper);
          });

          return outArr;
        }

        createArrOperatorNodeFactoryFuncWrapper() {
          var outArr;

          // const arr_opSymbol = ["+", "-", "x", "/"];
          // const arr_opSymbol = ["+", "x"];
          // const arr_value_b  = [0,1,2,3,4,5,6,7,8,9];

          // const arr_opSymbol = ["+", "+"];
          // const arr_value_b  = [0,1,2,3,0,1,2,3];

          // const arr_opSymbol = ["+"];
          // const arr_value_b  = [100];
          // const arr_opSymbol_valueb =  [["+", 100]];

          const arr_add = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15].map(value_b => ["+", value_b]);
          // const arr_add      = [0,1,2,3,4,5,6,7,8,9,10].map(value_b => ["+", value_b]);
          const arr_subtract = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(value_b => ["-", value_b]);
          const arr_multiply = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(value_b => ["x", value_b]);
          const arr_divide = [1, 2, 3, 4, 5, 6, 7, 8, 9].map(value_b => ["/", value_b]);

          const arr_opSymbol_valueb = [...arr_add,
          ...arr_add,
          ...arr_subtract,
          ...arr_subtract,
          ...arr_multiply,
          ...arr_divide];

          // const arr_opSymbol_valueb =  [...arr_add];

          outArr = arr_opSymbol_valueb.map(([string__opSymbol, value_b]) => {
            const op = Operator.fromString_binary(string__opSymbol);
            const node_b = new math.ConstantNode(value_b);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);
            return operatorNodeFactoryFuncWrapper;
          });

          return outArr;
        }

        getCardWithIdentifier(identifier__card) {
          logger.log("getCardWithIdentifier", identifier__card);

          //parsing
          const arr_elt = identifier__card.split("#");
          const index = arr_elt[1];
          // logger.log("index", index);

          const opSimpleName = arr_elt[0].split("__")[1];
          // logger.log("opSimpleName", opSimpleName);

          const card = this.dict_card[opSimpleName][index];
          // logger.log("card", card);

          return card;
        }

      }


      class GET100_PrintableCardSheet {

        constructor(infiniteCanvas, arr_card, nb_row, nb_col) {
          logger.log("arr_card", arr_card);

          this.infiniteCanvas = infiniteCanvas;
          this.arr_card = arr_card;

          this.nb_col = nb_row;
          this.nb_row = nb_col;

          this.width = 2100;
          this.height = 2970;


          this.arr_rect_front = this.createArrRect_front();
          this.arr_rect_back = this.createArrRect_back();

        }

        export() {

        }


        getCardX(index_col) {
          return index_col * this.getCardWidth();
        }

        getCardX__mirrored(index_col) {
          return ((this.nb_col - 1) - index_col) * this.getCardWidth();
        }

        getCardY(index_row) {
          return index_row * this.getCardHeight();
        }

        getCardWidth() {
          return this.width / this.nb_col;
        }

        getCardHeight() {
          return this.height / this.nb_row;
        }



        createArrRect_front() {
          //create card rects array
          const arr_index_row = [...Array(this.nb_row).keys()];
          const arr_index_col = [...Array(this.nb_col).keys()];

          return arr_index_row.map(index_row => {
            return arr_index_col.map(index_col => {
              const rect_card = {
                x: this.getCardX(index_col),
                y: this.getCardY(index_row),
                width: this.getCardWidth(),
                height: this.getCardHeight(),
              };
              return rect_card;
            });
          }).flat();
        }

        createArrRect_back() {
          //create card rects array
          const arr_index_row = [...Array(this.nb_row).keys()];
          const arr_index_col = [...Array(this.nb_col).keys()];

          return arr_index_row.map(index_row => {
            return arr_index_col.map(index_col => {
              const rect_card = {
                x: this.getCardX__mirrored(index_col),
                y: this.getCardY(index_row),
                width: this.getCardWidth(),
                height: this.getCardHeight(),
              };
              return rect_card;
            });
          }).flat();
        }

        //front

        ic__page_front() {
          var outIcObj;

          const infiniteCanvas = this.infiniteCanvas;
          const arr_card = this.arr_card;


          const trueRect_background = {
            x: 0,
            y: 0,
            width: this.width,
            height: this.height,
          };
          const icRect = infiniteCanvas.createIcRect(trueRect_background);
          icRect.fill = "white";
          icRect.rx = 0;
          icRect.ry = 0;
          icRect.zIndex = -10;

          //cards
          const arr_card_icPrintableCardFront = arr_card.map((card, i) => {
            const trueRect_card = this.arr_rect_front[i];
            logger.log("trueRect_card", trueRect_card);

            const icPrintableCardFront = GET100_PrintableCardSheet.ic__printableCard_front(infiniteCanvas, card, trueRect_card);
            return [card, icPrintableCardFront];
          });


          //composite
          //parts
          const parts = {
            "bg": icRect,
          };
          const dict_card = arr_card_icPrintableCardFront.reduce((acc, [card, icPrintableCardFront]) => {
            const identifier = card.getIdentifier();
            acc[identifier] = icPrintableCardFront;
            return acc;
          }, {});
          Object.assign(parts, dict_card);


          //SHU: since icPrintableCardFront is a composite, we need to add it to ic before creating mother composite
          //this is a lasting temporary workaround
          infiniteCanvas.addIcObject(icRect);
          arr_card_icPrintableCardFront.forEach(([card, icPrintableCardFront], i) => {
            infiniteCanvas.addIcObject(icPrintableCardFront);
          });


          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);


          const trueRect_composite = trueRect_background;
          const icComposite = infiniteCanvas.createIcComposite(trueRect_composite, parts, compositeConfig);
          icComposite.cType = "GET100_PrintableCardSheet_front";
          icComposite.fill = "";

          outIcObj = icComposite;

          return outIcObj;
        }

        static ic__printableCard_front(infiniteCanvas, card, trueRect_card) {
          logger.log("ic__printableCard_front", card, trueRect_card);

          //card template
          const icPrintableCard_front = GET100_PrintableCardSheet.ic_template__printableCard_front(infiniteCanvas, trueRect_card);


          //invest

          //position
          infiniteCanvas.onceOnAddRepresentedForIcObject(icPrintableCard_front, (icPrintableCard_front) => {

            const rep_free__composite = infiniteCanvas.getRepresented(icPrintableCard_front.id).r_free();
            rep_free__composite.position = {
              x: trueRect_card.x,
              y: trueRect_card.y,
            };

          });


          //content
          infiniteCanvas.onceOnAddRepresentedForIcObject(icPrintableCard_front, (icPrintableCard_front) => {

            const rep_free__composite = infiniteCanvas.getRepresented(icPrintableCard_front.id).r_free();

            //operator
            rep_free__composite.parts.label__operator.text = card.get100Operator.getSimpleName();

          });

          return icPrintableCard_front;
        }

        static ic_template__printableCard_front(infiniteCanvas, trueRect_card) {
          var outIcObj;

          const trueRect_background = {
            x: 0,
            y: 0,
            width: trueRect_card.width,
            height: trueRect_card.height,
          };
          const icRect = infiniteCanvas.createIcRect(trueRect_background);
          icRect.fill = "white";
          icRect.strokeWidth = 2;
          icRect.stroke = "black";


          //img
          // const trueRect_img = {
          //   x: 75,
          //   y: 75,
          //   width:  100,
          //   height: 100,
          // };
          // const icImage = infiniteCanvas.createIcImage(trueRect_img.x,trueRect_img.y,null);

          //operator
          const trueRect_operator = {
            x: trueRect_background.width * 0.15,
            y: trueRect_background.height * 0.15,
            width: 100,
            height: 100,
          };
          // const icGMOperator = infiniteCanvas.createIcGMOperator(trueRect_operator, "x 2");
          const icLabel__operator = infiniteCanvas.createIcText(trueRect_operator.x, trueRect_operator.y, "");



          //composite
          const parts = {
            "bg": icRect,
            // "image":      icImage,
            // "gmOperator": icGMOperator,
            "label__operator": icLabel__operator,
          };

          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);


          const trueRect_composite = trueRect_background;
          const icComposite = infiniteCanvas.createIcComposite(trueRect_composite, parts, compositeConfig);
          icComposite.cType = "GET100_PrintableCard_front";
          icComposite.fill = "";

          outIcObj = icComposite;

          return outIcObj;
        }





        //back

        ic__page_back() {
          var outIcObj;

          const infiniteCanvas = this.infiniteCanvas;
          const arr_card = this.arr_card;


          const trueRect_background = {
            x: 0,
            y: 0,
            width: this.width,
            height: this.height,
          };
          const icRect = infiniteCanvas.createIcRect(trueRect_background);
          icRect.fill = "white";
          icRect.rx = 0;
          icRect.ry = 0;
          icRect.zIndex = -10;

          //cards
          const arr_card_icPrintableCardBack = arr_card.map((card, i) => {
            const trueRect_card = this.arr_rect_back[i];
            logger.log("trueRect_card", trueRect_card);

            const icPrintableCardBack = GET100_PrintableCardSheet.ic__printableCard_back(infiniteCanvas, card, trueRect_card);
            return [card, icPrintableCardBack];
          });


          //composite
          //parts
          const parts = {
            "bg": icRect,
          };
          const dict_card = arr_card_icPrintableCardBack.reduce((acc, [card, icPrintableCardBack]) => {
            const identifier = card.getIdentifier();
            acc[identifier] = icPrintableCardBack;
            return acc;
          }, {});
          Object.assign(parts, dict_card);


          //SHU: since icPrintableCardFront is a composite, we need to add it to ic before creating mother composite
          //this is a lasting temporary workaround
          infiniteCanvas.addIcObject(icRect);
          arr_card_icPrintableCardBack.forEach(([card, icPrintableCardBack], i) => {
            infiniteCanvas.addIcObject(icPrintableCardBack);
          });


          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);


          const trueRect_composite = trueRect_background;
          const icComposite = infiniteCanvas.createIcComposite(trueRect_composite, parts, compositeConfig);
          icComposite.cType = "GET100_PrintableCardSheet_front";
          icComposite.fill = "";

          outIcObj = icComposite;

          return outIcObj;
        }

        static ic__printableCard_back(infiniteCanvas, card, trueRect_card) {
          logger.log("ic__printableCard_back", card, trueRect_card);

          //card template
          const icPrintableCard_back = GET100_PrintableCardSheet.ic_template__printableCard_back(infiniteCanvas, trueRect_card);


          //invest

          //position
          infiniteCanvas.onceOnAddRepresentedForIcObject(icPrintableCard_back, (icPrintableCard_back) => {

            const rep_free__composite = infiniteCanvas.getRepresented(icPrintableCard_back.id).r_free();
            rep_free__composite.position = {
              x: trueRect_card.x,
              y: trueRect_card.y,
            };

          });


          //content
          infiniteCanvas.onceOnAddRepresentedForIcObject(icPrintableCard_back, (icPrintableCard_back) => {

            const rep_free__composite = infiniteCanvas.getRepresented(icPrintableCard_back.id).r_free();

            //img
            qrcodeImg_p(card.getIdentifier())
              .then(img => {
                logger.log("qrcodeImg_p", "img", img);
                // img.width  = 100;
                // img.height = 100;

                // rep_free__composite.parts.image.force_width  = true;
                // rep_free__composite.parts.image.force_height = true;
                rep_free__composite.parts.image.img = img;

                rep_free__composite.parts.image.scale.X = 3;
                rep_free__composite.parts.image.scale.Y = 3;

              });

          });

          return icPrintableCard_back;
        }

        static ic_template__printableCard_back(infiniteCanvas, trueRect_card) {
          var outIcObj;

          const trueRect_background = {
            x: 0,
            y: 0,
            width: trueRect_card.width,
            height: trueRect_card.height,
          };
          const icRect = infiniteCanvas.createIcRect(trueRect_background);
          icRect.fill = "white";
          icRect.strokeWidth = 2;
          icRect.stroke = "black";


          //img
          const trueRect_img = {
            x: trueRect_background.width * 0.15,
            y: trueRect_background.height * 0.15,
            width: trueRect_background.width * 0.66,
            height: trueRect_background.width * 0.66,
          };
          const icImage = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, null);

          //operator
          // const trueRect_operator = {
          //   x: trueRect_background.width  * 0.15,
          //   y: trueRect_background.height * 0.15,
          //   width: 100,
          //   height: 100,
          // };
          // // const icGMOperator = infiniteCanvas.createIcGMOperator(trueRect_operator, "x 2");
          // const icLabel__operator = infiniteCanvas.createIcText(trueRect_operator.x, trueRect_operator.y, "");



          //composite
          const parts = {
            "bg": icRect,
            "image": icImage,
            // "gmOperator": icGMOperator,
            // "label__operator": icLabel__operator,
          };

          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);


          const trueRect_composite = trueRect_background;
          const icComposite = infiniteCanvas.createIcComposite(trueRect_composite, parts, compositeConfig);
          icComposite.cType = "GET100_PrintableCard_back";
          icComposite.fill = "";

          outIcObj = icComposite;

          return outIcObj;
        }


      }

      class GET100_PrintableCardCollection {

        constructor(cardCollection, nb_row__page, nb_col__page) {

          this.cardCollection = cardCollection;

          this.nb_row__page = nb_row__page;
          this.nb_col__page = nb_col__page;
          this.nb_card__page = nb_row__page * nb_col__page;

        }

        spawn_to_ic() {

          const nb_row = this.nb_row__page;
          const nb_col = this.nb_col__page;

          const arr_partition = Utils.partitionArray(this.cardCollection.arr_card, this.nb_card__page);
          arr_partition.forEach((arr_card, i) => {
            const printableCardSheet = new GET100_PrintableCardSheet(infiniteCanvas, arr_card, nb_row, nb_col);

            const trueRect_page_front = {
              x: (2 * i) * (printableCardSheet.width + 50),
              y: i * (printableCardSheet.height + 50),
              width: printableCardSheet.width,
              height: printableCardSheet.height,
            };

            const icPage_front = printableCardSheet.ic__page_front();
            infiniteCanvas.onceOnAddRepresentedForIcObject(icPage_front, (icPage_front) => {

              const rep_free__composite = infiniteCanvas.getRepresented(icPage_front.id).r_free();
              rep_free__composite.position = {
                x: trueRect_page_front.x,
                y: trueRect_page_front.y,
              };

            });
            infiniteCanvas.addIcObject(icPage_front);

            const trueRect_page_back = {
              x: (2 * i + 1) * (printableCardSheet.width + 50),
              y: i * (printableCardSheet.height + 50),
              width: printableCardSheet.width,
              height: printableCardSheet.height,
            };

            const icPage_back = printableCardSheet.ic__page_back();
            infiniteCanvas.onceOnAddRepresentedForIcObject(icPage_back, (icPage_back) => {

              const rep_free__composite = infiniteCanvas.getRepresented(icPage_back.id).r_free();
              rep_free__composite.position = {
                x: trueRect_page_back.x,
                y: trueRect_page_back.y,
              };

            });
            infiniteCanvas.addIcObject(icPage_back);


            //save as img
            setTimeout(function () {
              infiniteCanvas.exportCanvasRectContainingObj_asImg(icPage_front);
              infiniteCanvas.exportCanvasRectContainingObj_asImg(icPage_back);
            }, 6000 + i * 3000);

          });

        }
      }


      class GET100__Atelier {

        constructor() {

        }

        static spawn_virtual_card() {
          //debug
          const trueRect_img = {
            x: 0,
            y: 0,
            width: 100,
            height: 100,
          };
          qrcodeImg_p("GET100__+ 2#0")
            .then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img);
              icObj_front.scale.X = 1.0;
              icObj_front.scale.Y = 1.0;
              icObj_front.zIndex = 100;
              // icObj_front.width  = trueRect_img.width;
              // icObj_front.height = trueRect_img.height;
              infiniteCanvas.addIcObject(icObj_front);
            });

        }

        static debug_filters() {

          setTimeout(function () {

            const icEye = infiniteCanvas.getAllRepresentedWithType("eye")[0].r_official();
            logger.log("log2", "icEye", icEye);
            const rep_free__eye = infiniteCanvas.getRepresented(icEye.id).r_free();
            const img__captured = rep_free__eye.img__captured;

            const arr_brightness = [...Array(11).keys()].map(index => index * 0.1);
            const arr_contrast = [...Array(11).keys()].map(index => index * 0.1);

            arr_brightness.forEach((value__brightness, i) => {
              arr_contrast.forEach((value__contrast, j) => {
                // logger.log("log2", "value__brightness", value__brightness, "value__contrast", value__contrast);
                const img__filtered_p = ImageUtils.image_filtered_p(img__captured, value__brightness, value__contrast);

                img__filtered_p.then(img__filtered => {
                  logger.log("log2", "img__filtered", img__filtered);

                  const trueRect_img = {
                    x: i * 100,
                    y: j * 100,
                    width: 100,
                    height: 100,
                  };

                  const icObj_img = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img__filtered);
                  infiniteCanvas.onceOnAddRepresentedForIcObject(icObj_img, (icObj_img) => {
                    logger.log("log2", "icObj_img", icObj_img.position.x, icObj_img.size.width);

                    const rep_free = infiniteCanvas.getRepresented(icObj_img.id).r_free();
                    rep_free.position = {
                      x: trueRect_img.x,
                      y: trueRect_img.y,
                    };

                  });
                  infiniteCanvas.addIcObject(icObj_img);

                });

              });
            });

          }, 6000);

        }

        static debug_filters_2() {

          setTimeout(function () {

            const icEye = infiniteCanvas.getAllRepresentedWithType("eye")[0].r_official();
            logger.log("log2", "icEye", icEye);
            const rep_free__eye = infiniteCanvas.getRepresented(icEye.id).r_free();
            const img__captured = rep_free__eye.img__captured;

            const value__brightness = 0.3;
            const value__contrast = 0.3;

            const img__filtered_p = ImageUtils.image_filtered_p(img__captured, value__brightness, value__contrast);

            img__filtered_p.then(img__filtered => {
              logger.log("log2", "img__filtered", img__filtered);

              const trueRect_img = {
                x: 100,
                y: 100,
                width: 100,
                height: 100,
              };

              const icObj_img = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img__filtered);
              infiniteCanvas.onceOnAddRepresentedForIcObject(icObj_img, (icObj_img) => {
                logger.log("log2", "icObj_img", icObj_img.position.x, icObj_img.size.width);

                const rep_free = infiniteCanvas.getRepresented(icObj_img.id).r_free();
                rep_free.position = {
                  x: trueRect_img.x,
                  y: trueRect_img.y,
                };

              });
              infiniteCanvas.addIcObject(icObj_img);

            });

          }, 6000);

        }

      }

    </script>
    <script>
    //launch game
    // const game__GET100 = new GET100_Game(infiniteCanvas);

    //to print cards
    // const cardCollection          = new GET100_CardCollection();
    // const printableCardCollection = new GET100_PrintableCardCollection(cardCollection,4,4);
    // printableCardCollection.spawn_to_ic();

    //debug
    // GET100__Atelier.spawn_virtual_card();
    // GET100__Atelier.debug_filters();
    // GET100__Atelier.debug_filters_2();
    </script>





    <script>

      class TargetM100100Game {

        

      }




    </script>
    <script>
      //launch game
      const game__targetM100100 = new TargetM100100Game(infiniteCanvas);

    </script>



</body>

</html>