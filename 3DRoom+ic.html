<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- <meta name="viewport" content= "width=device-width, user-scalable=no">--> <!--does not work -->
  <title>3DRoom+iC</title>

  <style>
    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;

      /* 17756649/disable-the-horizontal-scroll */
      max-width: 100%; overflow-x: hidden;

      max-height: 100%; overflow-y: hidden;

      /* Prevent document pinch-zoom & touch-hold-to-highlight */
      touch-action: none;

      -webkit-touch-callout: none;
      /* iOS Safari */
      -webkit-user-select: none;
      /* Safari */
      -khtml-user-select: none;
      /* Konqueror HTML */
      -moz-user-select: none;
      /* Old versions of Firefox */
      -ms-user-select: none;
      /* Internet Explorer/Edge */
      user-select: none;
      /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
    }
  </style>

</head>

  <script>
    //misc tests
    
    //const myDict = {
    //  a: "a",
    //  b: "b",
    //  a: "c",
    //};
    //console.log("myDict:", myDict);
    
  </script>


  <!--<script src="still_shute.js" type='text/javascript'></script>-->


  <!-- <video id="myVideo"></video> -->
  <!-- <button id="myButton"></button> -->
  <!-- <img id="myImage" src="https://i.stack.imgur.com/8fooU.png"></img> -->

  <!-- <script src='saves/th_nostalgie.js' type='text/javascript'> </script> -->


  <link href="lib/video-js.min.css" rel="stylesheet">
  <script src="lib/video.min.js" type='text/javascript'></script>

  <!-- <script src="lib/wad.min.js" type='text/javascript'></script> -->

  <!-- wouldnt it be nice ?! ... --> 
  <!--<link  href="lib/dropzone/dropzone.min.css" rel="stylesheet">               -->
  <!--<script src="lib/dropzone/dropzone.min.js" type='text/javascript'></script> -->
  

  <script src="lib/pdf/pdfjs/pdf.min.js" type='text/javascript'></script>
  <script>
    // console.log("pdfjsLib", pdfjsLib);
    const PDFJS = pdfjsLib;
    // console.log("logPDF", "PDFJS:", PDFJS);
  </script>
  <script src="lib/pdf/jspdf@2.5.1.umd.min.js" type='text/javascript'></script>
  <script>
    // import { jsPDF } from "jspdf";
    const jsPDF = window.jspdf.jsPDF;
    // console.log("logPDF", "jsPDF:", jsPDF);
  </script>


  <script src="lib/jszip.min.js"     type='text/javascript'> </script>
  <script src="lib/FileSaver.min.js" type='text/javascript'> </script>

  <script src="lib/epub/epub.min.js" type='text/javascript'></script>
  <!-- <script>
    console.log("logEPUB", "ePub:", ePub);
  </script> -->

  <!-- <script src="lib/epub/epub-maker/vendor/jszip.min.js"        type='text/javascript'></script> -->
  <!-- <script src="lib/epub/epub-maker/vendor/FileSaver.min.js"    type='text/javascript'></script> -->
  <script src="lib/epub/epub-maker/vendor/jszip-utils.min.js"       type='text/javascript'></script>
  <script src="lib/epub/epub-maker/vendor/handlebars.min.js"        type='text/javascript'></script>
  <script src="lib/epub/epub-maker/vendor/beautify-html.js"         type='text/javascript'></script>
  <script src="lib/epub/epub-maker/vendor/underscore.string.min.js" type='text/javascript'></script>
  <script src="lib/epub/epub-maker/epub-maker.min.js"               type='text/javascript'></script>
  <!-- <script>
    console.log("logEPUB", "EpubMaker:", EpubMaker);
  </script> -->

  <!-- <script src="lib/panzoom.min.js" type='text/javascript'></script> -->

  <!-- global -->
  <script>

    class Globals {
      constructor() {
        this.isEditing = false;
      }
    }

    const globalsSingleton = new Globals();

  </script>

  <script src='lib/FunctionCallsQueue.js'  type='text/javascript'></script>
  <script>
    globalsSingleton.functionCallsQueue = new FunctionCallsQueue(true);
  </script>

  <!-- utils -->
  <script>

    class Utils {

      static arrayByRemovingElement(src_arr, elt) {

        const index = src_arr.indexOf(elt);

        return this.arrayByRemovingElementAtIndex(src_arr, index);
      }

      static arrayByRemovingElementAtIndex(src_arr, index) {

        const arr = [...src_arr]; //create shallow copy of src_arr

        const arr_removed = arr.splice(index, 1);   //starting at index, remove 1 element
        const arr_new = arr;                    //array is mutated in place

        return arr;
      }

      static partition(arr, size) {
        var p = [];
        for (var i=Math.floor(arr.length/size); i-- > 0;) {
            p[i]=arr.slice(i*size, (i+1)*size);
        }
        return p;
      }

      static randomElementInArray(arr) {
        const elt = arr[Math.floor(Math.random() * arr.length)];

        // "~~" for a closest "int"
        // const elt = arr[~~(arr.length * Math.random())];

        // "|" for a kinda "int div"
        // const elt = arr[arr.length * Math.random() | 0];

        return elt;
      }

      static randomElementInArray__weighted(arr, arr_weight_in) {
        var i;

        const arr_weight = [...arr_weight_in];

        for (i = 0; i < arr_weight.length; i++)
          arr_weight[i] += arr_weight[i - 1] || 0;

        const random = Math.random() * arr_weight[arr_weight.length - 1];

        for (i = 0; i < arr_weight.length; i++)
          if (arr_weight[i] > random)
            break;

        return arr[i];
      }

      static randomElementsInArray(arr, nb_elts, isDistinct) {
        return [...Array(nb_elts).keys()].reduce((acc, index) => {
          var arr_sub;
          if(isDistinct) {
            arr_sub = arr.filter(elt => !(acc.includes(elt)));
          } else {
            arr_sub = arr;
          }
          const elt = Utils.randomElementInArray(arr_sub);
          return [...acc, elt];
        }, []);
      }

      static early_break_reduce(arr, reduce_callback, initial, checkStopFunc) {
        const x = [...arr]                         // create copy of "array" for iterating
          .reduce((acc, x, i, arr) => {
            if (checkStopFunc(acc, x, i, arr)) {
              arr.splice(1);     // eject early by mutating iterated copy
              return acc;
            }
            return reduce_callback(acc, x, i, arr);
          }, initial);
        return x;
      }


      static randomSubArrWithArray(arr_src_in, nb) {
        var arr_src = [...arr_src_in];
        return [...Array(nb).keys()].reduce((acc, x) => {
          const arr_index = [...Array(arr_src.length).keys()]
          const index_random = Utils.randomElementInArray(arr_index);
          const elt_picked = arr_src[index_random];
          arr_src = Utils.arrayByRemovingElementAtIndex(arr_src, index_random);
          return [...acc, elt_picked];
        }, []);
      }



      /**
       * Shuffles array in place.
       * @param {Array} a items An array containing the items.
       */
      static shuffle(a) {
        var j, x, i;
        for (i = a.length - 1; i > 0; i--) {
          j = Math.floor(Math.random() * (i + 1));
          x = a[i];
          a[i] = a[j];
          a[j] = x;
        }
        return a;
      }

      //creates new shuffled array
      static shuffled(a) {
        return Utils.shuffle([...a]);
      }

      static shuffled_all_same(...arr_arr) {
        const arr_zip = Utils.zip(...arr_arr);
        Utils.shuffle(arr_zip);
        const arr_dezip = Utils.dezip(arr_zip);
        return arr_dezip;
      }

      static shuffled_mimic(arr, arr_shuffled__indexes) {
        return arr_shuffled__indexes.reduce((acc,x) => {
          acc.push(arr[x]);
          return acc;
        }, []);
      }

      static shuffled_dna(...arr_arr) {
        const arr_first = arr_arr.find(e => true);
        const arr_indexes = Utils.arr_indexes(arr_first);

        const arr_true_false = [true, false];
        const arr_boolean__dna_shuffle = arr_indexes.map(index => {
          return Utils.randomElementInArray(arr_true_false);
        });

        const func_dna_shuffle = Utils.shuffled; 

        logger.log("arr_arr", arr_arr);
        const arr_arr__zipped = Utils.zip(...arr_arr);
        logger.log("arr_arr__zipped", arr_arr__zipped);
        
        const arr_arr__shuffled__zipped = arr_arr__zipped.reduce((acc, arr_items_i, i) => {
          var arr_items_i__refined; 

          const isShouldShuffle = arr_boolean__dna_shuffle[i];
          if(isShouldShuffle) {
            arr_items_i__refined = func_dna_shuffle(arr_items_i);
          } else {
            arr_items_i__refined = arr_items_i;
          }
          
          acc.push(arr_items_i__refined);

          return acc;
        }, []);
        logger.log("arr_arr__shuffled__zipped", arr_arr__shuffled__zipped);

        const arr_arr__shuffled = Utils.dezip(arr_arr__shuffled__zipped);
        logger.log("arr_arr__shuffled", arr_arr__shuffled);

        return arr_arr__shuffled;
      }


      static arr_shuffled_indexes(arr) {
        const arr_indexes = Utils.arr_indexes(arr);
        const arr_indexes__shuffled = Utils.shuffled(arr_indexes);
        return arr_indexes__shuffled;
      }

      static arr_indexes(arr) {
        return [...Array(arr.length).keys()];
      }


      static arr_progress(nb_steps) {
        var outArr;

        outArr = [...Array(nb_steps).keys()].map(index => {
          const progress = 1.0 * index / (nb_steps - 1);
          return progress;
        });
        logger.log("log1", "arr_progress", outArr);

        return outArr;
      }

      static partitionArray(arr, spacing) {
        var output = [];

        for (var i = 0; i < arr.length; i += spacing) {
          output[output.length] = arr.slice(i, i + spacing);
        }

        return output;
      }


      static randomKanji(seed = null) {
        const string__kanji_list = "亜哀挨愛曖悪握圧扱宛嵐安案暗以衣位囲医依委威為畏胃尉異移萎偉椅彙意違維慰遺緯域育一壱逸茨芋引印因咽姻員院淫陰飲隠韻右宇羽雨唄鬱畝浦運雲永泳英映栄営詠影鋭衛易疫益液駅悦越謁閲円延沿炎怨宴媛援園煙猿遠鉛塩演縁艶汚王凹央応往押旺欧殴桜翁奥横岡屋億憶臆虞乙俺卸音恩温穏下化火加可仮何花佳価果河苛科架夏家荷華菓貨渦過嫁暇禍靴寡歌箇稼課蚊牙瓦我画芽賀雅餓介回灰会快戒改怪拐悔海界皆械絵開階塊楷解潰壊懐諧貝外劾害崖涯街慨蓋該概骸垣柿各角拡革格核殻郭覚較隔閣確獲嚇穫学岳楽額顎掛潟括活喝渇割葛滑褐轄且株釜鎌刈干刊甘汗缶完肝官冠巻看陥乾勘患貫寒喚堪換敢棺款間閑勧寛幹感漢慣管関歓監緩憾還館環簡観韓艦鑑丸含岸岩玩眼頑顔願企伎危机気岐希忌汽奇祈季紀軌既記起飢鬼帰基寄規亀喜幾揮期棋貴棄毀旗器畿輝機騎技宜偽欺義疑儀戯擬犠議菊吉喫詰却客脚逆虐九久及弓丘旧休吸朽臼求究泣急級糾宮救球給嗅窮牛去巨居拒拠挙虚許距魚御漁凶共叫狂京享供協況峡挟狭恐恭胸脅強教郷境橋矯鏡競響驚仰暁業凝曲局極玉巾斤均近金菌勤琴筋僅禁緊錦謹襟吟銀区句苦駆具惧愚空偶遇隅串屈掘窟熊繰君訓勲薫軍郡群兄刑形系径茎係型契計恵啓掲渓経蛍敬景軽傾携継詣慶憬稽憩警鶏芸迎鯨隙劇撃激桁欠穴血決結傑潔月犬件見券肩建研県倹兼剣拳軒健険圏堅検嫌献絹遣権憲賢謙鍵繭顕験懸元幻玄言弦限原現舷減源厳己戸古呼固股虎孤弧故枯個庫湖雇誇鼓錮顧五互午呉後娯悟碁語誤護口工公勾孔功巧広甲交光向后好江考行坑孝抗攻更効幸拘肯侯厚恒洪皇紅荒郊香候校耕航貢降高康控梗黄喉慌港硬絞項溝鉱構綱酵稿興衡鋼講購乞号合拷剛傲豪克告谷刻国黒穀酷獄骨駒込頃今困昆恨根婚混痕紺魂墾懇左佐沙査砂唆差詐鎖座挫才再災妻采砕宰栽彩採済祭斎細菜最裁債催塞歳載際埼在材剤財罪崎作削昨柵索策酢搾錯咲冊札刷刹拶殺察撮擦雑皿三山参桟蚕惨産傘散算酸賛残斬暫士子支止氏仕史司四市矢旨死糸至伺志私使刺始姉枝祉肢姿思指施師恣紙脂視紫詞歯嗣試詩資飼誌雌摯賜諮示字寺次耳自似児事侍治持時滋慈辞磁餌璽鹿式識軸七叱失室疾執湿嫉漆質実芝写社車舎者射捨赦斜煮遮謝邪蛇尺借酌釈爵若弱寂手主守朱取狩首殊珠酒腫種趣寿受呪授需儒樹収囚州舟秀周宗拾秋臭修袖終羞習週就衆集愁酬醜蹴襲十汁充住柔重従渋銃獣縦叔祝宿淑粛縮塾熟出述術俊春瞬旬巡盾准殉純循順準潤遵処初所書庶暑署緒諸女如助序叙徐除小升少召匠床抄肖尚招承昇松沼昭宵将消症祥称笑唱商渉章紹訟勝掌晶焼焦硝粧詔証象傷奨照詳彰障憧衝賞償礁鐘上丈冗条状乗城浄剰常情場畳蒸縄壌嬢錠譲醸色拭食植殖飾触嘱織職辱尻心申伸臣芯身辛侵信津神唇娠振浸真針深紳進森診寝慎新審震薪親人刃仁尽迅甚陣尋腎須図水吹垂炊帥粋衰推酔遂睡穂随髄枢崇数据杉裾寸瀬是井世正生成西声制姓征性青斉政星牲省凄逝清盛婿晴勢聖誠精製誓静請整醒税夕斥石赤昔析席脊隻惜戚責跡積績籍切折拙窃接設雪摂節説舌絶千川仙占先宣専泉浅洗染扇栓旋船戦煎羨腺詮践箋銭潜線遷選薦繊鮮全前善然禅漸膳繕狙阻祖租素措粗組疎訴塑遡礎双壮早争走奏相荘草送倉捜挿桑巣掃曹曽爽窓創喪痩葬装僧想層総遭槽踪操燥霜騒藻造像増憎蔵贈臓即束足促則息捉速側測俗族属賊続卒率存村孫尊損遜他多汰打妥唾堕惰駄太対体耐待怠胎退帯泰堆袋逮替貸隊滞態戴大代台第題滝宅択沢卓拓託濯諾濁但達脱奪棚誰丹旦担単炭胆探淡短嘆端綻誕鍛団男段断弾暖談壇地池知値恥致遅痴稚置緻竹畜逐蓄築秩窒茶着嫡中仲虫沖宙忠抽注昼柱衷酎鋳駐著貯丁弔庁兆町長挑帳張彫眺釣頂鳥朝貼超腸跳徴嘲潮澄調聴懲直勅捗沈珍朕陳賃鎮追椎墜通痛塚漬坪爪鶴低呈廷弟定底抵邸亭貞帝訂庭逓停偵堤提程艇締諦泥的笛摘滴適敵溺迭哲鉄徹撤天典店点展添転填田伝殿電斗吐妬徒途都渡塗賭土奴努度怒刀冬灯当投豆東到逃倒凍唐島桃討透党悼盗陶塔搭棟湯痘登答等筒統稲踏糖頭謄藤闘騰同洞胴動堂童道働銅導瞳峠匿特得督徳篤毒独読栃凸突届屯豚頓貪鈍曇丼那奈内梨謎鍋南軟難二尼弐匂肉虹日入乳尿任妊忍認寧熱年念捻粘燃悩納能脳農濃把波派破覇馬婆罵拝杯背肺俳配排敗廃輩売倍梅培陪媒買賠白伯拍泊迫剥舶博薄麦漠縛爆箱箸畑肌八鉢発髪伐抜罰閥反半氾犯帆汎伴判坂阪板版班畔般販斑飯搬煩頒範繁藩晩番蛮盤比皮妃否批彼披肥非卑飛疲秘被悲扉費碑罷避尾眉美備微鼻膝肘匹必泌筆姫百氷表俵票評漂標苗秒病描猫品浜貧賓頻敏瓶不夫父付布扶府怖阜附訃負赴浮婦符富普腐敷膚賦譜侮武部舞封風伏服副幅復福腹複覆払沸仏物粉紛雰噴墳憤奮分文聞丙平兵併並柄陛閉塀幣弊蔽餅米壁璧癖別蔑片辺返変偏遍編弁便勉歩保哺捕補舗母募墓慕暮簿方包芳邦奉宝抱放法泡胞俸倣峰砲崩訪報蜂豊飽褒縫亡乏忙坊妨忘防房肪某冒剖紡望傍帽棒貿貌暴膨謀頬北木朴牧睦僕墨撲没勃堀本奔翻凡盆麻摩磨魔毎妹枚昧埋幕膜枕又末抹万満慢漫未味魅岬密蜜脈妙民眠矛務無夢霧娘名命明迷冥盟銘鳴滅免面綿麺茂模毛妄盲耗猛網目黙門紋問冶夜野弥厄役約訳薬躍闇由油喩愉諭輸癒唯友有勇幽悠郵湧猶裕遊雄誘憂融優与予余誉預幼用羊妖洋要容庸揚揺葉陽溶腰様瘍踊窯養擁謡曜抑沃浴欲翌翼拉裸羅来雷頼絡落酪辣乱卵覧濫藍欄吏利里理痢裏履璃離陸立律慄略柳流留竜粒隆硫侶旅虜慮了両良料涼猟陵量僚領寮療瞭糧力緑林厘倫輪隣臨瑠涙累塁類令礼冷励戻例鈴零霊隷齢麗暦歴列劣烈裂恋連廉練錬呂炉賂路露老労弄郎朗浪廊楼漏籠六録麓論和話賄脇惑枠湾腕";
        const index = seed % string__kanji_list.length;
        const string__kanji = string__kanji_list.slice(index, index + 1);
        return string__kanji;
      }

      static chunkString(str__in, length__chunk) {
        const arr_str = str__in.match(new RegExp('(.|[\r\n]){1,' + length__chunk + '}', 'g'));
        return arr_str;
      }


      // static zip(a, b) {
      //   return a.map((k, i) => [k, b[i]]);
      // }
      static zip(...arr_arr) {
        return arr_arr[0].map(function(_,i){
          return arr_arr.map(function(array){return array[i]})
        });
      }

      static dezip(arr_zip) {
        const arr_arr_empty = [...Array(arr_zip.length).keys()].map((i) => []);
        return arr_zip.reduce((acc,x) => {
          x.forEach((elt, i) => {
            acc[i].push(elt);
          });
          return acc;
        }, arr_arr_empty);
      }

      static cartesianProduct(a, b) {
        return a.reduce((p, x) => [...p, ...b.map(y => [x, y])], []);
      }

      static dictFromArr(a) {
        return a.reduce((acc, x, i) => {
          acc[i] = x;
          return acc;
        }, {});
      }


      static getMethods(obj) {
        let properties = new Set();
        let currentObj = obj;
        do {
          Object.getOwnPropertyNames(currentObj).map(item => properties.add(item));
        } while ((currentObj = Object.getPrototypeOf(currentObj)));
        return [...properties.keys()].filter(item => typeof obj[item] === 'function');
      }


      static repeat(func, nb) {
        [...Array(nb).keys()].forEach((item, i) => {
          func();
        });
      }


      static getPropDict__shallow(obj, arr_propName) {
        return arr_propName.reduce((acc, propName) => {
          acc[propName] = obj[propName];
          return acc;
        }, {});
      }

      static getPropDict__deep(obj, arr_propName) {
        throw new Error("SHU TODO");
        // return arr_propName.reduce((acc, propName) => {
        //   acc[propName] = obj[propName];
        //   return acc;
        // }, {});   
      }

      static isString(x) {
        return (Object.prototype.toString.call(x) === "[object String]");
      }

      static getPropForPropPath(obj, propPath) {
        const arr_path = propPath.split(".");
        return arr_path.reduce((acc, pathElt) => {
          return acc[pathElt];
        }, obj);
      }
        
      static setPropAtPropPath(obj, propPath, value, isShouldForce = true) {
        const arr_path = propPath.split(".");
        const arr__all_but_last = arr_path.slice(0, -1);
        const penultimate = arr__all_but_last.reduce((acc, pathElt) => {

          if(isShouldForce) {
            //create if not found
            if (acc[pathElt] == null) {
             acc[pathElt] = {};
            }
          }

          return acc[pathElt];
        }, obj);

        const [lastPathElt] = arr_path.slice(-1);
        penultimate[lastPathElt] = value;
      }

    }

    class StringUtils {
      static count(string, word) {
        return string.split(word).length - 1;
     }
    }

    class FuncUtils {
      static tryCatch_wrapper(func, fallback_output = null) {
        try {
          return func();
        } catch(e) {
          return fallback_output;
        }
      }
    }


    class ColorUtils {

      static randomColor__dict() {
        var r = 255 * Math.random() | 0,
            g = 255 * Math.random() | 0,
            b = 255 * Math.random() | 0;
        return {
          r: r,
          g: g,
          b: b,
         };
      }

      static randomColor() {
        const dict__rgb = this.randomColor__dict();
        var r = dict__rgb.r,
            g = dict__rgb.g,
            b = dict__rgb.b;
        return 'rgb(' + r + ',' + g + ',' + b + ')';
      }

      static rgbaColorString(r,g,b,a) {
        const rgbaString = 'rgba(' + [r, g, b, a].join(",") + ')';
        return rgbaString;
      }





      static rainbow__color_with_progress(progress, nb_cycles) {
        var outString;
        const value_h = math.floor(360 * progress * nb_cycles) % 360;
        const color = new Color("hsl(" + value_h + ",80%,50%)");
        logger.log("log1", "rainbow__color_with_progress", color);

        // outString = color.toString({format: "hex"});
        function hslToHex(h, s, l) {
          l /= 100;
          const a = s * Math.min(l, 1 - l) / 100;
          const f = n => {
            const k = (n + h / 30) % 12;
            const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return Math.round(255 * color).toString(16).padStart(2, '0');   // convert to Hex and prefix "0" if needed
          };
          return `#${f(0)}${f(8)}${f(4)}`;
        }

        outString = hslToHex(color.h, color.s, color.l);

        logger.log("log1", "rainbow__color_with_progress", outString);

        return outString;
      }

      static rainbow__random_arr_of_length(length, nb_cycles) {
        var outArr;

        outArr = Utils.arr_progress(length)
          .map(progress => {
            return ColorUtils.rainbow__color_with_progress(progress, nb_cycles);
          });

        return outArr;
      }

      static hexToArrRgba(hex, opacity255) {
        opacity = Math.round(opacity * 255) || 255;
        hex = hex.replace('#', '');
        var rgb = [], re = new RegExp('(.{' + hex.length / 3 + '})', 'g');
        hex.match(re).map(function (l) {
          rgb.push(parseInt(hex.length % 2 ? l + l : l, 16));
        });
        return rgb.concat(opacity);
      }

      static arrRgbaFromRgbaString(rgbaString) {
        const fColor = new fabric.Color(rgbaString);
        const arr_comp = [...fColor.getSource()];
        arr_comp[3] = Math.floor(arr_comp[3] * 255);
        return arr_comp;
      }

      static intForHexString(string__hex) {
        const hex = string__hex.replace('#', '');
        var rgb = [], re = new RegExp('(.{' + hex.length / 3 + '})', 'g');
        const rgb_number = rgb.reduce((acc, x, i) => acc + x * (10 ^ 3) ^ i, 0);
        return rgb_number;
      }

      static hexStringForInt(n) {
        return math.hex(n);
      }


      static colorWithLightness(color, lightness) {

      }

      static fColorWithLightness(fColor, lightness) {
        var outFColor;

        const hslaString__old = fColor.toHsla();
        logger.log("logColor", "hslaString__old", hslaString__old);

        //example: "hsla( 300 , 50% , 80% , 0.5 )"
        const regex__lightness = /(hsla\(.*,.*,)(.*)(%,.*\))/;

        const str__lightness__new = math.floor(lightness * 100);

        const hslaString__new = hslaString__old.replace(regex__lightness, "$1" + str__lightness__new + "$3");
        logger.log("logColor", "hslaString__new", hslaString__new);

        outFColor = fabric.Color.fromHsla(hslaString__new);

        return outFColor;
      }


    }

    class PathUtils {

      static startingPointFromPath(path) {
        logger.log("logPathUtils", "startingPointFromPath", path);

        var outPoint;

        //["M", 406.91, 627.09]
        const elt__first = path[0];
        const x = elt__first[1];
        const y = elt__first[2];

        outPoint = {
          x: x,
          y: y,
        };

        return outPoint;
      }

      static endingPointFromPath(path) {
        logger.log("logPathUtils", "endingPointFromPath", path);

        var outPoint;

        //["L", 406.91, 627.09]
        const elt__last = path.slice(-1)[0];
        const x = elt__last[1];
        const y = elt__last[2];

        outPoint = {
          x: x,
          y: y,
        };

        return outPoint;
      }

    }


    class CompositeUtils {

      static traverseComposite(icObj__composite, func_callback/*, isBreadthFirst = true*/) {
        func_callback(icObj__composite);
        const arr_entry_part = Object.entries(icObj__composite.parts);
        var arr_entry_contentAndParts;
        const content = icObj__composite.content;
        if(content != null) {
          arr_entry_contentAndParts = [[content.id, content], ...arr_entry_part];
        } else {
          arr_entry_contentAndParts = arr_entry_part;
        }
        arr_entry_contentAndParts.forEach(([partName, icObj__part], i) => {
          if(icObj__part.type == "composite") {
            this.traverseComposite(icObj__part, func_callback);
          } else {
            func_callback(icObj__part);
          }
        });
      }

      static traverseCompositeDoppel(arr_icObj__composite, func_callback/*, isBreadthFirst = true*/) {
        func_callback(arr_icObj__composite);
        // const arr_arr_entry_parts = arr_icObj__composite.map((icObj__composite) => {
        //   return Object.entries(icObj__composite.parts);
        // });
        // const arr_zip_entry_parts = Utils.zip(...arr_arr_entry_parts);
        // arr_zip_entry_parts.forEach((arr_entry, i) => {
        //   const arr_icObj__part = arr_entry.map((entry) => {return entry[1];});
        //   const icObj_sample = arr_icObj__part.find(e => true);
        //   if(icObj_sample.type == "composite") {
        //     this.traverseCompositeDoppel(arr_icObj__part, func_callback);
        //   } else {
        //     func_callback(arr_icObj__part);
        //   }
        // });
        const arr_arr_entry_contentAndParts = arr_icObj__composite.map((icObj__composite) => {
          var outArr;
          const arr_entry_parts = Object.entries(icObj__composite.parts);
          const content = icObj__composite.content;
          if(content != null) {
            outArr = [[content.id, content], ...arr_entry_parts];
          } else {
            outArr = arr_entry_parts;
          }
          return outArr;
        });
        const arr_zip_entry_contentAndParts = Utils.zip(...arr_arr_entry_contentAndParts);
        arr_zip_entry_contentAndParts.forEach((arr_entry, i) => {
          const arr_icObj__contentAndPart = arr_entry.map((entry) => {return entry[1];});
          const icObj_sample = arr_icObj__contentAndPart.find(e => true);
          if(icObj_sample.type == "composite") {
            this.traverseCompositeDoppel(arr_icObj__contentAndPart, func_callback);
          } else {
            func_callback(arr_icObj__contentAndPart);
          }
        });
      }

      static shiftToNextAvailableId(icObj__cloned, icObj__composite, infiniteCanvas) {

        //prepare id shift
        const id__min__in_composite = this.getId__min(icObj__composite);
        const id__next__in_iC       = infiniteCanvas.pollNextAvailableId();
        const value_offset_id       = id__next__in_iC - id__min__in_composite;

        function translatedId(id) {
          const id__translated = id + value_offset_id;

          //update ic's counter if needed
          if(id__translated > infiniteCanvas.counter) {
            infiniteCanvas.counter = id__translated; 
          }

          return id__translated; 
        }

        //perform id shift
        this.traverseCompositeDoppel([icObj__composite, icObj__cloned], ([icObj_src, icObj_clo]) => {
          
          //update id
          icObj_clo.id = translatedId(icObj_src.id);
          
          if(icObj_clo.type == "composite") {
            //update id in compositeConfig
            icObj_clo.compositeConfig = Object.entries(icObj_src.compositeConfig)
                                            .reduce((acc, [str__id_part__src, miniDict__src]) => {
                                              const id__part__prev = parseInt(str__id_part__src);
                                              const id__part__new  = translatedId(id__part__prev);
                                              const str__id_part__new = "" + id__part__new;
                                              acc[str__id_part__new] = Object.assign({}, miniDict__src);
                                              return acc;
                                            }, {});
          }

          //update compositeId
          if(icObj_clo.compositeId != -1) {
            icObj_clo.compositeId = translatedId(icObj_src.compositeId);
          }

        });
      }

      static getId__min(icObj__composite) {
        var id__min = icObj__composite.id;
        this.traverseComposite(icObj__composite, (icObj) => {
          if(icObj.id < id__min) {
            id__min = icObj.id;
          }
        });
        return id__min;
      }

      //SHU TODO
      // static reduce(icObj__composite, func_callback, value_initial) {
      //   this.traverseComposite(icObj__composite, func_callback)
      // }


      static shiftToPositionAndScale(icObj__composite, position_dst, homeScale_dst) {

        const position__root__old  = Object.assign({}, icObj__composite.position);
        const homeScale__root__old = Object.assign({}, icObj__composite.homeScale);

        const dHomeScale = {
          X: homeScale__root__old.X / homeScale_dst.X,
          Y: homeScale__root__old.Y / homeScale_dst.Y,
        };

        this.traverseComposite(icObj__composite, (icObj) => {

          if(icObj.compositeId != -1) {

            const offset__wrt_root = {
              dx: icObj.position.x - position__root__old.x, 
              dy: icObj.position.y - position__root__old.y,
            };

            const true_offset__wrt_root = {
              dx: offset__wrt_root.dx * dHomeScale.X,
              dy: offset__wrt_root.dy * dHomeScale.Y,
            }; 

            const position__new = {
              x: position_dst.x + true_offset__wrt_root.dx,
              y: position_dst.y + true_offset__wrt_root.dy,               
            };

            const homeScale__new = {
              X: icObj.homeScale.X / dHomeScale.X,
              Y: icObj.homeScale.Y / dHomeScale.Y,
            };


            icObj.position  = position__new;
            icObj.homeScale = homeScale__new;

          } else {
            //root composite
            icObj.position  = Object.assign({}, position_dst);
            icObj.homeScale = homeScale_dst;
          }

        });

      }

      static shiftToPositionAndScale2(icObj__composite__root, position_dst, homeScale_dst, icObj__composite_in = null, position_new_in = null, homeScale_new_in = null) {
        logger.log("shiftToPositionAndScale2", icObj__composite__root, position_dst, homeScale_dst, icObj__composite_in, position_new_in, homeScale_new_in);

        //take care of null params
        var icObj__composite = icObj__composite_in;
        if(icObj__composite == null) {
          icObj__composite = icObj__composite__root;
        }

        var position_new = position_new_in;
        if(position_new == null) {
          position_new = position_dst;
        }

        var homeScale_new = homeScale_new_in;
        if(homeScale_new == null) {
          homeScale_new = homeScale_dst;
        }



        const position__root__old  = Object.assign({}, icObj__composite__root.position);
        const homeScale__root__old = Object.assign({}, icObj__composite__root.homeScale);
        const dHomeScale = {
          X: homeScale__root__old.X / homeScale_dst.X,
          Y: homeScale__root__old.Y / homeScale_dst.Y,
        };
        // logger.log("logCU", "shiftToPositionAndScale2", "dHomeScale:", dHomeScale);

        const position__old  = Object.assign({}, icObj__composite.position);
        const homeScale__old = Object.assign({}, icObj__composite.homeScale);


          //shift children
        Object.values(icObj__composite.parts).forEach((icObj__child) => {

          //use absolute position and homeScale (i.e. refer to root, to old grandpa)
          const position_new__child = {
            x: position_dst.x + (icObj__child.position.x - position__root__old.x) * dHomeScale.X,
            y: position_dst.y + (icObj__child.position.y - position__root__old.y) * dHomeScale.Y,
          };

          const homeScale_new__child = {
            X: icObj__child.homeScale.X / dHomeScale.X,
            Y: icObj__child.homeScale.Y / dHomeScale.Y,
          };
          // logger.log("logCU", "shiftToPositionAndScale2", "homeScale__new:", homeScale__new);


          if(icObj__child.type == "composite") {
            CompositeUtils.shiftToPositionAndScale2(icObj__composite__root, position_dst, homeScale_dst, icObj__child, position_new__child, homeScale_new__child);
          } else {
            icObj__child.position  = Object.assign({}, position_new__child);
            icObj__child.homeScale = Object.assign({}, homeScale_new__child);
          }

        });

          //shift composite
        icObj__composite.position  = Object.assign({}, position_new);
        icObj__composite.homeScale = Object.assign({}, homeScale_new);

      }



      static getAllContained(icObjComposite) {
        var outArray = [];
        CompositeUtils.traverseComposite(icObjComposite, (icObj) => {
          outArray.push(icObj);
        });
        return outArray;
      }

      static getAllContained_filtered(icObjComposite, filterFunc) {
        var outArray = [];
        CompositeUtils.traverseComposite(icObjComposite, (icObj) => {
          if(filterFunc(icObj)) {
            outArray.push(icObj);
          }
        });
        return outArray;
      }

      static isContainerOf(icObjCandidate, icObj) {
        //hard no brainer
        var outBool;

        if(icObjCandidate.type == "composite") {
          const arr_contained = CompositeUtils.getAllContained(icObjCandidate);
          const isFound = (arr_contained.find((icObjContained) => (icObjContained.id == icObj.id)) != null);
          outBool = isFound;
        } else {
          outBool = false;
        }

        return outBool;
      }

      static isHavingCommonContainer(icObj1, icObj2, infiniteCanvas) {
        // logger.log("isHavingCommonContainer", "icObj1:", icObj1, "icObj2:", icObj2);

        const rootObject1 = icObj1.getRootObject(infiniteCanvas);
        // logger.log("isHavingCommonContainer", "rootObject1:", rootObject1);
        
        const rootObject2 = icObj2.getRootObject(infiniteCanvas);
        // logger.log("isHavingCommonContainer", "rootObject1:", rootObject1);

        const isSameRootObject = (rootObject1 == rootObject2);
        // logger.log("isHavingCommonContainer", "isSameRootObject:", isSameRootObject);

        const isHavingCommonCont = isSameRootObject || CompositeUtils.isContainerOf(rootObject1, rootObject2) ||  CompositeUtils.isContainerOf(rootObject2, rootObject1);
        return isHavingCommonCont;
      }

      static getHighestRootObjectBefore(icObj, icCompositeCeiling) {
        var outIcObj;
        
        //find part of compositeCeiling which contains icObj
        const arr_part = Object.values(icCompositeCeiling.parts);
        const icObj_composite__highestRoot = arr_part.find((icObj_composite) => CompositeUtils.isContainerOf(icObj_composite, icObj));
        if(icObj_composite__highestRoot != null) {
          outIcObj = icObj_composite__highestRoot;
        } else {
          outIcObj = icObj;
        }

        return outIcObj;
      }

    }




    class Vibration {

      constructor(seed_in = null) {
        const seed = seed_in ? seed_in : math.randomInt(1, 1000000000) * 3000;
        this.func__vibration = Vibration.createFunc(seed);
        this.counter = 0;
      }

      // next(x) {
      //   return (this.func__vibration)(x);
      // }

      next() {
        this.counter += 1;
        return (this.func__vibration)(this.counter);
      }

      static createFunc(seed) {
        const nb_func = 10;
        const magicValue__modulo_amplitude = 77;
        const magicValue__modulo_frequency = 777;

        const arr_amplitude = [...Array(nb_func).keys()].map(i => (i * seed) % magicValue__modulo_amplitude);
        const arr_frequency = [...Array(nb_func).keys()].map(i => (i * seed) % magicValue__modulo_frequency);
        // logger.log("seed", seed);
        // logger.log("arr_amplitude", arr_amplitude);
        // logger.log("arr_frequency", arr_frequency);

        const arr_func_sine = Utils.zip(arr_amplitude, arr_frequency).map(([k, v]) => {
          const func_sine = function (x) {
            return k * math.sin(v * x);
          };
          return func_sine;
        });

        const func_vibration = function (x) {
          const amp__raw = arr_func_sine.reduce((acc, func_sine) => {
            return acc + func_sine(x);
          }, 0);
          // logger.log("func_vibration(", x, ")", x__transformed);
          const amplitude__sum = arr_amplitude.reduce((acc, x) => acc + x, 0);
          const amp__normalized = 0.5 + 0.5 * ((amp__raw) / (amplitude__sum));  //to yield number in [0,1]
          logger.log("amp__normalized", amp__normalized);

          return amp__normalized;
        };

        return func_vibration;
      }

    }




    class Logger {

      constructor() {
        this.initialize();

        // this.hush(this);
      }

      initialize() {
        this.invest(console);
        this.hush(console);
      }

      invest(obj) {
        this.log = obj.log;
        this.trace = obj.trace;
      }

      hush(obj) {
        obj.log = function () { };
        obj.trace = function () { };
      }


    }

    const logger = new Logger();

  </script>
  <!-- <script>
      //debug
      const arr_test = [1,2,3,4,5,6];
      const s = Utils.early_break_reduce(arr_test, (acc,x,i,arr) => {
        logger.log("x", x);
        return acc + x;
      }, 0, (acc, x, i, arr) => {
        return i > 2;
      });
      logger.log("s", s);
    </script> -->

  <!-- <script src='lib/base64.js' type='text/javascript'></script> -->

  <script>
    //more utils

    String.prototype.insert = function (index, string) {
      var ind = index < 0 ? this.length + index  :  index;
      return  this.substring(0, ind) + string + this.substr(ind);
    };

  </script>

  <script src='lib/Queue.js' type='text/javascript'> </script>
  <script src='lib/PriorityQueue.js' type='text/javascript'> </script>

  <!-- GEMINI -->
  <!-- <script src='lib/gemini.browserified.bundle.js' type='text/javascript'> </script>
    <script>
      logger.log("Bundle_GMN", Bundle_GMN);
      const Gemini = Bundle_GMN.Gemini.Gemini;
      logger.log("Gemini", Gemini);
      const GeminiObject = Bundle_GMN.GeminiObject.Gemini_Object;
      logger.log("GeminiObject", GeminiObject);
    </script> -->
  <!-- <script src='lib/gemini/Gemini_All.js' type='text/javascript'> </script> -->
  <!-- <script>
    logger.log("Gemini", Gemini);
    logger.log("GeminiObject", GeminiObject);
    logger.log("GeminiHatch", GeminiHatch);
    logger.log("Mini", Mini);
  </script> -->

  <script src='lib/decoration+infiltration.js' type='text/javascript'> </script>


  <script src='lib/peerjs@1.4.7.min.js' type='text/javascript'> </script>


  <!-- pre UI -->
  <script src='lib/curve/curve.min.js'        type='text/javascript'></script>
  <script src='lib/curve/curve_calc.min.js'   type='text/javascript'></script>
  <script src='lib/curve/zCurve.js'        type='text/javascript'></script>

  <!--<script src='lib/curve/curve.js'        type='text/javascript'></script>-->
  <!--<script src='lib/curve/curve_func.min.js'   type='text/javascript'></script>-->
  



  <!-- UI -->
  <script src='lib/fabric.531.min.js'      type='text/javascript'></script>
    <!-- debug -->
    <!-- <script src='lib/fabric.531.js'      type='text/javascript'></script> -->
    

  <script src='lib/fabric+zIndex.js'       type='text/javascript'></script>

  <script src='lib/fabric+brushPreview.js'             type='text/javascript'></script>
  <script src='lib/fabric+path_with_brush_property.js' type='text/javascript'></script>
  <script src='lib/fabric+brushClone.js'               type='text/javascript'></script>
  
  <script src='lib/CircularBuffer.js'      type='text/javascript'></script>
  <script src='lib/fabric+comb.js'         type='text/javascript'></script>

  <script src='lib/fabric+straightStroke.js'  type='text/javascript'></script>

  
  <script src='lib/fabricjs+floodFill.js'  type='text/javascript'></script>

  <script src='lib/fabricjs+curve3.js'  type='text/javascript'></script>

  <script src='lib/fabricjs+stickerStroke.js'  type='text/javascript'></script>



  <script>
    class FabricUtils {

      static isIntersecting__pixelWise(fObj1, fObj2) {
        
        //get bounding rect containing fObj1 and fObj2


        //quadrichotomic search (square-chotomic search)
        
      }

    }
  </script>





  <!-- "tool canvas" -->
  <!-- <canvas id="canvas__tool" style="visibility:hidden;">Your browser does not support HTML5 canvas</canvas> -->
  <!-- <script>
      const canvas__tool = document.getElementById("canvas__tool");
      canvas__tool.width  = window.innerWidth;
      canvas__tool.height = window.innerHeight;
    </script> -->
  <script>
    const canvas__tool = document.createElement("canvas");
    canvas__tool.id = "canvas__tool";
    canvas__tool.width = 1000;
    canvas__tool.height = 1000;
      // canvas__tool.style.visibility = 'hidden';
      // document.body.appendChild(canvas__tool);
  </script>
  <!-- <script>
      const fabricCanvas__tool = new fabric.Canvas(canvas__tool.id, {
        backgroundColor: 'rgba(0,0,0,0)',
        // backgroundColor: 'rgb(0,0,0)',

        width:  canvas__tool.width,
        height: canvas__tool.height,
      });
      logger.log("fabricCanvas__tool", fabricCanvas__tool);
    </script> -->

  <script>
    class ImageUtils {

      static boundingBox__pixelWise(imageData, w, h) {
        var outBoundingBox;

        const arr_x = [...Array(w).keys()];
        const arr_y = [...Array(h).keys()];

        const mat_xy = arr_x.map(x => {
          return arr_y.map(y => {
            const point = {
              x: x,
              y: y,
            };
            return point;
          });
        }).flat();

        outBoundingBox = mat_xy.reduce((acc, point) => {

          const x = point.x;
          const y = point.y;

          const arr_rgba = ImageUtils.getPixelArrRgba(imageData, w, h, x, y);

          const r = arr_rgba[0];
          const g = arr_rgba[1];
          const b = arr_rgba[2];
          const a = arr_rgba[3];

          const isRgbNonZero = (r != 0) || (g != 0) || (b != 0);
          const isAlphaNonZero = (a != 0);

          const isNonEmpty = isRgbNonZero && isAlphaNonZero;
          if (isNonEmpty) {
            // logger.log("x", x, "y", y);
            // logger.log("arr_rgba", arr_rgba);

            acc.x1 = Math.min(acc.x1, point.x);
            acc.y1 = Math.min(acc.y1, point.y);
            acc.x2 = Math.max(acc.x2, point.x);
            acc.y2 = Math.max(acc.y2, point.y);
          }

          return acc;
        }, {
          x1: w - 1,
          y1: h - 1,
          x2: 0,
          y2: 0,
        });

        return outBoundingBox;
      }

      static getImageDataObj(dataUrl) {

        const ctx = canvas__tool.getContext("2d");
        logger.log("ctx", ctx);
        ctx.width = canvas__tool.width;
        ctx.height = canvas__tool.height;

        //clear context
        ctx.clearRect(0, 0, ctx.width, ctx.width);

        return new Promise(function (resolve, reject) {
          if (dataUrl == null) return reject();

          var image = new Image();
          image.addEventListener('load', function () {
            const w = image.width;
            const h = image.height;

            var width__ctx_old = ctx.width;
            if (w > ctx.width) {
              ctx.width = w;
            }
            var height__ctx_old = ctx.height;
            if (h > ctx.height) {
              ctx.height = h;
            }

            ctx.drawImage(image, 0, 0, w, h);

            // const imageData = ctx.getImageData(0, 0, w, h).data.buffer;
            const imageData = ctx.getImageData(0, 0, w, h);

            const imageDataObj = {
              data: imageData,
              w: w,
              h: h,
            };

            ctx.width = width__ctx_old;
            ctx.height = height__ctx_old;

            resolve(imageDataObj, false);
          });
          image.src = dataUrl;
        });

      }

      static imageFromImageData(imagedata) {
        var ctx = canvas__tool.getContext('2d');
        canvas__tool.width = imagedata.width;
        canvas__tool.height = imagedata.height;
        ctx.putImageData(imagedata, 0, 0);

        var image = new Image();
        image.src = canvas__tool.toDataURL();
        return image;
      }

      static imageFromDataUrl_p(dataUrl) {
        const image_p = new Promise(function (resolve, reject) {
          if (dataUrl == null) return reject();

          var image = new Image();
          image.addEventListener('load', function () {
            resolve(image, false);
          });
          image.src = dataUrl;
        });
        return image_p;
      }

      static imageFromVideo_p(video) {

        canvas__tool.height = video.videoHeight;
        canvas__tool.width = video.videoWidth;

        const ctx = canvas__tool.getContext("2d");
        logger.log("ctx", ctx);

        ctx.drawImage(video, 0, 0, canvas__tool.width, canvas__tool.height);
        const dataUrl = canvas__tool.toDataURL();

        const image_p = new Promise(function (resolve, reject) {
          if (dataUrl == null) return reject();

          var image = new Image();
          image.addEventListener('load', function () {
            resolve(image, false);
          });
          image.src = dataUrl;
        });

        return image_p;

      }

      static getPixelArrRgba(imageData, w, h, x, y) {
        // logger.log("getPixel", imageData, w, h, x, y);

        // const data = new Uint32Array(imageData);
        // logger.log("data.length", data.length);
        // logger.log("w * h", w * h);

        // const index__pixel = y * w + x;
        // const value__pixel = data[index__pixel];
        // return value__pixel;

        const data = imageData.data;
        const index__pixel = y * w + x;
        const index__pixel4 = index__pixel * 4;

        const index__r = index__pixel4;
        const index__g = index__pixel4 + 1;
        const index__b = index__pixel4 + 2;
        const index__a = index__pixel4 + 3;

        const r = data[index__r];
        const g = data[index__g];
        const b = data[index__b];
        const a = data[index__a];

        return [r, g, b, a];
      }

      static getPixelRgbaColorString(imageData, w, h, x, y) {
        const arr_rgba = ImageUtils.getPixelArrRgba(imageData, w, h, x, y);

        const rgbaColorString = "rgba(" + arr_rgba.join(",") + ")";

        return rgbaColorString;
      }

      // static qrcode__decode_image(img) {
      //   const imageData = ImageUtils.getImageDataObj(img);
      //   return ImageUtils.qrcode__decode_imageData(imageData);
      // }


      // static qrcode__decode_image_p__zxing(img) {
      //   const codeReader = new ZXing.BrowserMultiFormatReader();
      //   // logger.log("codeReader", codeReader);
      //   return codeReader.decodeFromImage(img);
      // }

      // static qrcode__decode_imageData__zxing(imageData) {
      //   logger.log("log1", "qrcode__decode_imageData", imageData);
      //
      //   const BarcodeFormat      = ZXing.BarcodeFormat;
      //   const DecodeHintType     = ZXing.DecodeHintType;
      //   const MultiFormatReader  = ZXing.MultiFormatReader;
      //   const RGBLuminanceSource = ZXing.RGBLuminanceSource;
      //   const BinaryBitmap       = ZXing.BinaryBitmap;
      //   const HybridBinarizer    = ZXing.HybridBinarizer;
      //
      //
      //   const hints   = new Map();
      //   const formats = [BarcodeFormat.QR_CODE, ZXing.BarcodeFormat.DATA_MATRIX/*, ...*/];
      //
      //   hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);
      //
      //   const reader = new MultiFormatReader();
      //
      //   const imgByteArray = imageData.data;
      //   const imgWidth     = imageData.width;
      //   const imgHeight    = imageData.height;
      //
      //   const luminanceSource = new RGBLuminanceSource(imgByteArray, imgWidth, imgHeight);
      //   const binaryBitmap    = new BinaryBitmap(new HybridBinarizer(luminanceSource));
      //
      //   return reader.decode(binaryBitmap, hints);
      // }




      static qrcode__decode_image_p(img, shouldTryWithFilters = true) {

        //create
        const id__reader = "reader";

        const readerElt = document.createElement("div");
        logger.log("readerElt", readerElt);
        readerElt.setAttribute("id", id__reader);
        readerElt.setAttribute("width", "600px");
        // readerElt.setAttribute("width","100px"); //test

        document.body.appendChild(readerElt);

        const reader = new Html5Qrcode(id__reader, { formatsToSupport: [Html5QrcodeSupportedFormats.QR_CODE] });
        logger.log("reader", reader);

        const file = FileIntegration.fileForImg(img);

        const result_p = reader.scanFile(file, true)
          .then(decodedText => {
            logger.log("decodedText", decodedText);
            return decodedText;
          })
          .catch(err => {
            // failure, handle it.
            logger.log(`Error scanning file. Reason: ${err}`);

            if (shouldTryWithFilters) {
              //retry with different brightness and contrast
              const value__brightness = 0.10;
              const value__contrast = 0.30;

              const img__filtered_p = ImageUtils.image_filtered_p(img, value__brightness, value__contrast);
              const decodedText__filtered_p = img__filtered_p.then(image_filtered => {
                return ImageUtils.qrcode__decode_image_p(img__filtered, false);
              });

              return decodedText__filtered_p;
            }

          })
          .finally(() => {
            readerElt.remove();
          });

        return result_p;
      }


      //filters

      static image_filtered_p(img, value_brightness, value_contrast) {
        const fObj = new fabric.Image(img);
        const filter__brightness = new fabric.Image.filters.Brightness({
          brightness: value_brightness,
        });
        const filter__contrast = new fabric.Image.filters.Contrast({
          contrast: value_contrast,
        });
        fObj.filters.push(filter__brightness);
        fObj.filters.push(filter__contrast);
        fObj.applyFilters();

        //get image from fObj
        const dataUrl = fObj.toDataURL();
        const img__filtered_p = ImageUtils.imageFromDataUrl_p(dataUrl);
        return img__filtered_p;
      }

    }

  </script>

  <script src='lib/anime.min.js' type='text/javascript'></script>
  <script src='lib/color.global.min.js' type='text/javascript'></script>

  <!-- QRCODE -->
  <!-- <script src='lib/instascan.browserified.bundle.js' type='text/javascript'></script>
    <script>
      const Instascan = Bundle_IS.Instascan;
      logger.log("log1", "Instascan", Instascan);
    </script> -->
  <!-- debug -->
  <!-- <video id="preview"></video> -->
  <!-- <script>
      let scanner = new Instascan.Scanner({ video: document.getElementById('preview') });
      scanner.addListener('scan', function (content) {
        alert(content);
      });
      Instascan.Camera.getCameras().then(function (cameras) {
        if (cameras.length > 0) {
          scanner.start(cameras[0]);
        } else {
          console.error('No cameras found.');
        }
      }).catch(function (e) {
        console.error(e);
      });
    </script> -->
  <!-- <script src='lib/zxingjs.browserified.bundle.js' type='text/javascript'></script>
    <script>
      const ZXing = Bundle_ZX.ZXing;
      // logger.log("log1", "ZXing", ZXing);
    </script> -->
  <script src="lib/html5-qrcode.min.js" type="text/javascript"></script>
  <!-- <script>
      logger.log("log1", "Html5Qrcode", Html5Qrcode);
    </script> -->

  <script src='lib/nodeqrcode.browserified.bundle.js' type='text/javascript'></script>
  <script>
    const NodeQRCode = Bundle_NQ.NodeQRCode;
      // logger.log("log1", "NodeQRCode", NodeQRCode);
  </script>
  <!-- convenience -->
  <script>
    function qrcodeImg_p(str_in) {
      const dataURL_p = NodeQRCode.toDataURL(str_in);
      const img_p = dataURL_p.then((dataURL) => {
        logger.log("log1", "qrcodeImg_p, dataURL", dataURL);
        return FileIntegration.imageFromImgSrc_p(dataURL);
      });
      return img_p;
    }
  </script>

  <!-- GameController -->
  <script src='lib/gamecontroller.min.js' type='text/javascript'></script>


  <!-- MathJax -->
  <script>
    //setup
    const loadMathJax_p = new Promise((resolve, reject) => {

      MathJax = {
        loader: {
          load: [
            '[tex]/color',
            '[tex]/newcommand',
          ],
        },
        tex: {
          packages: {
            '[+]': [
              'color',
              'newcommand'
            ],
          },
        },
        startup: {
          ready: () => {

            logger.log('MathJax is loaded, but not yet initialized');
            MathJax.startup.defaultReady();
            logger.log('MathJax is initialized, and the initial typeset is queued');
            // logger.log("MathJax", MathJax);

            resolve(MathJax);

            //newcommand
            // //discovery
            // MathJax.tex2svg("\\newcommand{\\braket}[1]{\\langle #1 \\rangle}");

            // //centernot / fsl(Feynman slash)
            // // MathJax.tex2svg("\\newcommand{\\fsl}[1]{\\ensuremath{\\mathrlap{\\!\\not{\\phantom{#1}}}#1}}");
            // // MathJax.tex2svg("\\newcommand{\\fsl}[1]{{\\ooalign{\\(#1\\)\\cr\\hidewidth\\(/\\)\\hidewidth\\cr}}");
            // // MathJax.tex2svg("\\newcommand{\\fsl}[1]{{\\centernot{#1}}}");

            // //colored operation
            // MathJax.tex2svg("\\newcommand{\\redbraket}[1]{\\color{red}{\\langle} \\color{black}{#1} \\color{red}{\\rangle}}");
            // // MathJax.tex2svg("\\newcommand{\\colorbraket}[2]{\\color{#1}{\\langle} #2 \\color{#1}{\\rangle}}");
            // // MathJax.tex2svg("\\newcommand{\\blueoline}[1]{\\colorlet{temp}{.}\\color{blue}\\overline{\\color{temp}#1}\\color{temp}}");
            // // MathJax.tex2svg("\\newcommand{\\colorbraket}[2]{\\colorlet{temp}{.} \\color{#1}{\\langle} \\color{temp}{#2} \\color{#1}{\\rangle} \\color{temp}}");

            // const mathJaxContainer_svg = MathJax.tex2svg("{\\color{red} 13}");
            // logger.log("mathJaxContainer_svg", mathJaxContainer_svg);
          },
        },
      };

      // MathJax = {
      //   tex: {
      //     autoload: {
      //       color: ['color', 'definecolor', 'textcolor', 'colorbox', 'fcolorbox'],
      //     },
      //   },
      // };

    });

    globalsSingleton.functionCallsQueue.add_promise(loadMathJax_p);

  </script>
  <!-- <script src='lib/mathjax.tex-mml-chtml.js' type='text/javascript'></script> -->
  <script src='lib/mathjax.tex-svg.js' type='text/javascript'></script>
  <!-- <script>
    //test
    logger.log("MathJax", MathJax);
    logger.log("MathJax.tex2svg", MathJax.tex2svg);
      // MathJax.tex2svg("{\\color(red) 13}");
  </script> -->

  <script>
    //integration
    class TexHelper {
      static toSvgEl(tex, color = "red") {
        const mathJaxContainer_svg = MathJax.tex2svg(tex);

        const htmlCollection = mathJaxContainer_svg.children;
        const svgEl = htmlCollection.item(0);
        console.log("svgEl", svgEl);

        svgEl.style.color = color;
        // svgEl.style.color2 = "blue";

        return svgEl;
      }
    }

    class SvgHelper {

      static toDataURL(svgEl) {
        var outDataUrl;

        // const svgSource = svgEl.outerHTML;

        const serializer = new XMLSerializer();
        const svgSource  = serializer.serializeToString(svgEl);

        // svgSource = svgSource.replaceAll('http://', 'https://');
        console.log("svgSource", svgSource);

        const dataUrl = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svgSource)));

        outDataUrl = dataUrl;

        return outDataUrl;
      }

      // static fromString(str_in) {
      //   var outSvgEl;

      //   const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      //   svg.innerHTML = str_in;

      //   outSvgEl = svg;

      //   return outSvgEl;
      // }

    }
  </script>
  <!-- <script>
      //discovery
      console.log("MathJax", MathJax);
      // const mathJaxContainer_svg = MathJax.tex2svg('\\frac{1}{x^2-1}', {display: true});
      const mathJaxContainer_svg = MathJax.tex2svg('\\frac{1}{x^2-1}');
      console.log("mathJaxContainer_svg", mathJaxContainer_svg);
    </script> -->

  <!-- <script src='lib/countdown.min.js' type='text/javascript'></script> -->
  <!-- <script>
      //discovery
      var timerId =
        countdown(
          new Date(),
          function(ts) {
            console.log("countdown::ts", ts);
            if(ts.value > 3000) {
              stop();
            }
          },
          countdown.HOURS|countdown.MINUTES|countdown.SECONDS);
      console.log("countdown::timerId", timerId);

      function stop() {
        clearInterval(timerId);
      }
    </script> -->
  <script src='lib/html2canvas.min.js' type='text/javascript'></script>
  <!-- <div id="lolilol" style="width: 100px; height: 100px; background-color:yellow">123456789</div>
    <script>
      //discovery
      html2canvas(document.getElementById("lolilol")).then(function(canvas) {
        // document.body.appendChild(canvas);
        console.log("html2canvas, canvas", canvas);
      });
    </script> -->



  <!-- Maths -->

  <link rel="stylesheet" href="lib/mathquill/mathquill.css" />
  <script src='lib/mathquill/jquery-3.5.1.min.js' type='text/javascript'></script>
  <script src='lib/mathquill/mathquill.min.js' type='text/javascript'></script>
  <script>
    const MQ = MathQuill.getInterface(2);
    logger.log("logNumberTyping", "MQ", MQ);

    // function decorate_keystroke_forClass(klass) {
    //   const keystroke__old = klass.keystroke;
    //   klass.keystroke = function(key, e, ctrlr) {
    //     logger.log("logNumberTyping", "MQ.keystroke", key, e, ctrlr);
    //     if(key === 'KeyZ') {
    //       e.preventDefault();
    //       return;
    //     } else {
    //       keystroke__old(key, e, ctrlr);
    //     }
    //   };
    // }
    // decorate_keystroke_forClass(MQ.MathBlock);
    // decorate_keystroke_forClass(MQ.RootTextBlock);
    // decorate_keystroke_forClass(MQ.LatexCommandInput);
    // decorate_keystroke_forClass(MQ.EditableField);


    function createMathField() {
      var outMathField;

      const span = document.createElement("span");

      if (span.style == null) { span.style = {}; }
      span.style.backgroundColor = "yellow";
      // span.style.width  = "100px";
      // span.style.height = "100px";
      span.style.fontSize = "80pt";
      span.style.color    = "purple";


      span.style.textAlign     = "center";
      span.style.verticalAlign = "middle";


      function handler__edit(mathField) {
        handler__edit__replace__cdot__with__times(mathField);
        handler__edit__replace__bar_caret_gt__with__rbararrow(mathField);
        handler__edit__replace__bar_caret_question_caret_gt__with__question_arrow(mathField);
      }

      function handler__edit__replace__cdot__with__times(mathField) {
        const tex = mathField.latex();

        //debug
        // {
        //   const cursor = mathField.__controller.cursor;
        //   logger.log("logNumberTyping", "getCursorIndex", "cursor:", cursor);
        // }

        function checkNeedsUpgrade(tex) {
          var outBool;
          outBool = tex.includes("\\cdot");
          return outBool;
        }

        function upgradedTex(tex) {
          var outTex;
          outTex = tex.replaceAll("\\cdot", "×");
          return outTex;
        }

        function getMathFieldElement__withFilter(mathField, func__filter) {
          // logger.log("logNumberTyping", "getMathFieldElement__withFilter", "mathField:", mathField);
          var outEl;

          const el__start = mathField.__controller.root.ends[-1];
          if((el__start != null) && (el__start != 0) && func__filter(el__start)) {
            outEl = el__start;
          } else {
            var found = false;
            var el = el__start[1];
            while(!found) {
              // logger.log("logNumberTyping", "getMathFieldElement__withFilter", "el:", el);
              found = (el != null) && (el != 0) && func__filter(el);
              if(!found) {
                if(el != null) {
                  el = el[1];
                } else {
                  break;
                }
              }
            }
            outEl = el;
          }

          return outEl;
        }

        function getMathFieldElement__withId(mathField, id__el) {
          return getMathFieldElement__withFilter(mathField, (el) => (el.id == id__el));
        }

        function getMathFieldElement__withString(mathField, str__el) {
          return getMathFieldElement__withFilter(mathField, (el) => (el.ctrlSeq == str__el));
        }

        const isNeedUpgrade = checkNeedsUpgrade(tex);
        if(isNeedUpgrade) {

          //cursor hack (idea 1):  insert str__salt at cursor index, 
          //              make update, 
          //              get cursor back using str__salt 
          //              remove str__salt

          //disable edit handler
          const handler__edit__prev = mathField.__options.handlers.fns.edit;
          mathField.__options.handlers.fns.edit = (mathField) => {};

            //store id of first element (before upgrade)
          const el__first__beforeUpgrade     = getMathFieldElement__withFilter(mathField, (el) => true);
          const id__el__first__beforeUpgrade = el__first__beforeUpgrade.id;

          // var cursorOffset__beforeUpgrade = mathField.__controller.cursor.offset();
          // if (!cursorOffset__beforeUpgrade) {
          //   cursorOffset__beforeUpgrade = { 'top': 0, 'left': 0 }
          // }

          const str__salt = "𓀴";  //== "\ud80c\udc34" 
          // const index__cursor__old = getCursorIndex(mathField);
          // const tex__salted        = tex.insert(index__cursor, str__salt);
          mathField.write(str__salt); //write str__salt at current cursor
          const tex__salted = mathField.latex();
          
          const tex__salted__upgraded = upgradedTex(tex__salted);
          // const index__cursor__new    = tex__salted__upgraded.indexOf(str__salt);
          const el__beside_salt       = getMathFieldElement__withString(mathField, "\ud80c")[-1];
          const id__el__beside_salt   = el__beside_salt.id;
          logger.log("logNumberTyping", "id__el__beside_salt:", id__el__beside_salt);
          // const el__beside_salt__2    = getMathFieldElement__withString(mathField, "\udc34")[1];
          // var id__el__beside_salt__2;
          // if(el__beside_salt__2 != null && el__beside_salt__2 != 0) {
          //   id__el__beside_salt__2 = el__beside_salt__2.id;
          // }
          // logger.log("logNumberTyping", "id__el__beside_salt__2:", id__el__beside_salt__2);
          
          const tex__upgraded         = tex__salted__upgraded.replace(str__salt, "");

          //perform update
          mathField.latex("");
          mathField.write(tex__upgraded);
          logger.log("logNumberTyping", "mathField__new:", mathField);

          // mathField.reflow();

          //set cursor index
          // setCursorIndex(mathField, index__cursor__new);

            //store id of first element (after upgrade)
          const el__first__afterUpgrade     = getMathFieldElement__withFilter(mathField, (el) => true);
          const id__el__first__afterUpgrade = el__first__afterUpgrade.id;
          
 
          const offset__id                        = id__el__first__afterUpgrade - id__el__first__beforeUpgrade - 1;
          logger.log("logNumberTyping", "offset__id:", offset__id);
          
          const id__el__beside_salt__afterUpgrade = id__el__beside_salt + offset__id;
          logger.log("logNumberTyping", "id__el__beside_salt__afterUpgrade:", id__el__beside_salt__afterUpgrade);
          const el__beside_salt__afterUpgrade     = getMathFieldElement__withId(mathField, id__el__beside_salt__afterUpgrade);
          logger.log("logNumberTyping", "el__beside_salt__afterUpgrade:", el__beside_salt__afterUpgrade);

          // var id__el__beside_salt__2__afterUpgrade;
          // var el__beside_salt__2__afterUpgrade;
          // if(id__el__beside_salt__2 != null) {
          //   id__el__beside_salt__2__afterUpgrade = id__el__beside_salt__2 + offset__id;
          //   logger.log("logNumberTyping", "id__el__beside_salt__2__afterUpgrade:", id__el__beside_salt__2__afterUpgrade);
          //   el__beside_salt__2__afterUpgrade     = getMathFieldElement__withId(mathField, id__el__beside_salt__afterUpgrade);
          //   logger.log("logNumberTyping", "el__beside_salt__afterUpgrade:", el__beside_salt__afterUpgrade);
          // }

          if(el__beside_salt__afterUpgrade != null) {
            // el__beside_salt__afterUpgrade.jQ.focus();

            // mathField.blur();

            const cursor = mathField.__controller.cursor;
            logger.log("logNumberTyping", "cursor:", cursor);

            // cursor.hide();

            cursor.hide();
            mathField.blur();

            cursor[-1]    = el__beside_salt__afterUpgrade;
            cursor[+1]    = el__beside_salt__afterUpgrade[1];
            // cursor.parent = mathField;

            // cursor.insAtRightEnd(el__beside_salt__afterUpgrade);
            // mathField.finalizeInsert(cursor.options, cursor);
 
            // const func__old = mathField.__controller.textarea.focus;
            // mathField.__controller.textarea.focus = () => {};
            // mathField.__controller.textarea.focus = func__old;

            // // if(el__beside_salt__2__afterUpgrade != null) {
            // //   cursor.insAtLeftEnd(el__beside_salt__2__afterUpgrade);
            // // }

            mathField.focus();
            cursor.show();
           
          }
          // mathField.__controller.cursor[-1] = el;
          // mathField.__controller.cursor[+1] = 
          // mathField.__controller.cursor.hide();
          // mathField.__controller.cursor.show();
          // logger.log("logNumberTyping", "cursor__prev", mathField.__controller.cursor);

          // mathField.__controller.cursor.offset = cursorOffset__beforeUpgrade;

          //reenable edit handler
          mathField.__options.handlers.fns.edit = handler__edit__prev;
        }

      }

      function handler__edit__replace__bar_caret_gt__with__rbararrow(mathField) {
        const tex = mathField.latex();

        function checkNeedsUpgrade(tex) {
          var outBool;
          outBool = tex.includes("\\left|->");
          outBool = outBool || tex.includes("<-");
          return outBool;
        }

        function upgradedTex(tex) {
          var outTex;
          
          //from |-> to ↦
          outTex =    tex.replaceAll("\\left|->", "↦");
          outTex = outTex.replaceAll("\\right|", "");

          //from <- to ←
          outTex = outTex.replaceAll("<-", "←");

          return outTex;
        }

        const isNeedUpgrade = checkNeedsUpgrade(tex);
        if(isNeedUpgrade) {

          //disable edit handler
          const handler__edit__prev = mathField.__options.handlers.fns.edit;
          mathField.__options.handlers.fns.edit = (mathField) => {};

          const tex__upgraded = upgradedTex(tex);

          mathField.latex("");
          mathField.write(tex__upgraded);

          //reenable edit handler
          mathField.__options.handlers.fns.edit = handler__edit__prev;
        }

      }

      function handler__edit__replace__bar_caret_question_caret_gt__with__question_arrow(mathField) {
        const tex = mathField.latex();

        function checkNeedsUpgrade(tex) {
          var outBool;
          outBool = tex.includes("\\left|-?->");
          return outBool;
        }

        function upgradedTex(tex) {
          var outTex;
          
          //from |-> to ↦
          outTex =    tex.replaceAll("\\left|-?->", "⊢?→");
          outTex = outTex.replaceAll("\\right|", "");

          return outTex;
        }

        const isNeedUpgrade = checkNeedsUpgrade(tex);
        if(isNeedUpgrade) {

          //disable edit handler
          const handler__edit__prev = mathField.__options.handlers.fns.edit;
          mathField.__options.handlers.fns.edit = (mathField) => {};

          const tex__upgraded = upgradedTex(tex);

          mathField.latex("");
          mathField.write(tex__upgraded);

          //reenable edit handler
          mathField.__options.handlers.fns.edit = handler__edit__prev;
        }

      }

      const mathField = MQ.MathField(span, {
        handlers: {
          edit: handler__edit,
        }
      }); 
      logger.log("logNumberTyping", "mathField:", mathField);

      // const keystroke__old = mathField.keystroke;
      // mathField.keystroke = function(key, e, ctrlr) {
      //   logger.log("logNumberTyping", "MQ.keystroke", key, e, ctrlr);
      //   if(key === 'KeyZ') {
      //     e.preventDefault();
      //     return;
      //   } else {
      //     keystroke__old(key, e, ctrlr);
      //   }
      // };

      outMathField = mathField;

      return outMathField;
    }

  </script>

  <script src='lib/written-number.min.js'  type='text/javascript'></script>
  <script>
    writtenNumber.defaults.lang = 'fr';
    //logger.log("logWN", "writtenNumber(1234)", writtenNumber(1234));
  </script>


  <script src='lib/decimal.min.js'  type='text/javascript'></script>
  <!-- <script src='lib/fraction.min.js' type='text/javascript'></script> --> <!--already included in math.js-->
  <!-- <script>
    //discovery
    logger.log("logFraction", "Fraction", Fraction);
    var value__fraction = new Fraction(1.88);
    logger.log("logFraction", "value__fraction:", value__fraction);
    
    const value__fraction__2 = (new Fraction(1)).div(98).mul(98);
    logger.log("logFraction", "value__fraction__2:", value__fraction__2);
  </script> -->

  <script src='lib/math.js' type='text/javascript'></script>
  <script>
    //discovery
    {
      // const mathNode__fraction = math.parse("math.fraction(2,3)");
      // logger.log("logMathJS", "mathNode__fraction:", mathNode__fraction);
    }
  </script>
  <script>

    //custom functions
    {
      const customFunctions = {
        //custom divide functions
        divide__div: function (a, b) {
          return math.divide(x, y);
        },
        divide__slash: function (a, b) {
          return math.divide(x, y);
        },
        divide__colon: function (a, b) {
          return math.divide(x, y);
        },



        assign_recur: function(mathNode_tree, mathNode__assignment) {
          const mathNode__from = mathNode__assignment.object;
          const mathNode_to    = mathNode__assignment.value;

          return mathNode_tree.transform(function (node, path, parent) {
            var outNode;

            // const isFound = (new math.RelationalNode(["equal"], [node, mathNode__from])).evaluate();
            const isFound = node instanceof math.SymbolNode;

            if (isFound) {
              outNode = mathNode_to;
            }
            else {
              outNode = node;
            }

            return outNode;
          });
        },



        // myApply: function(mathNode__operand, objectNode__operator) {
        //   var outMathNode;

        //   switch(objectNode__operator.properties.type.name) {
        //     case "anonFunction":
        //       {
        //         const mathNode__arr_var = objectNode__operator.properties["arr_var"];
        //         const dict__var         = Object.entries(mathNode__arr_var).reduce((acc, x) => {
        //           const name = x.name;
        //           acc[name] = x;
        //           return acc;
        //         }, {});
        //         const mathNode__expr    = objectNode__operator.properties["expr"];
                

        //         outMathNode = mathNode__expr.transform(function (node, path, parent) {
        //           var outNode2; 
      
        //           var node__subst;
        //           if (node.isSymbolNode) {
        //             node__subst = dict__var[node.name];
        //             if(node__subst != null) {
        //               outNode2 = node__subst.cloneDeep();
        //             } else {
        //               outNode2 = node;
        //             }
        //           }
        //           else {
        //             outNode2 = node;
        //           }
        //           logger.log("logMJS", "myApply", "outNode2", outNode2);
      
        //           return outNode2;
        //         });
        //       }
        //       break;
        //     default:
        //       {
        //         throw new Error("Unsupported type for objectNode__operator:", objectNode__operator.properties.type.name);
        //         outMathNode = mathNode__operand;
        //       }
        //       break;
        //   }

        //   return outMathNode;
        // }


      };

      customFunctions.divide__div.toTex = function (node, options) { //handler function
        const str__op = "÷";
        return node.args[0].toTex(options) + " " + str__op + " " + node.args[1].toTex(options);
      }

      customFunctions.divide__slash.toTex = function (node, options) { //handler function
        const str__op = "/";
        return node.args[0].toTex(options) + " " + str__op + " " + node.args[1].toTex(options);
      }

      customFunctions.divide__colon.toTex = function (node, options) { //handler function
        const str__op = ":";
        return node.args[0].toTex(options) + " " + str__op + " " + node.args[1].toTex(options);
      }

      math.import(customFunctions);
    }

    //overridden functions wrt type
    {
      //SHU: DOES NOT WORK {
      // // define a new datatype
      // math.typed.addType({
      //   name: 'Anon5050Function',
      //   test: function (x) {
      //     const isAnon5050Function =  x && x instanceof MyAnon5050FunctionObjectNode;
      //     logger.log("logAnon5050", "math.typed", "Anon5050Function.test", "isAnon5050Function:", x);
      //     return isAnon5050Function;
      //   },
      // });

      // // use the type in a new typed function
      // const evaluate = math.typed('evaluate', {
      //   'Anon5050Function': function (a) {
      //     logger.log("logAnon5050", "math.typed", "Anon5050Function.evaluate:", a);
      //     return MyAnon5050FunctionObjectNode.evaluateInstance(a);
      //   },
      // });
      //
      // math.import({evaluate: evaluate});
      //SHU: DOES NOT WORK }
    }


    //customization

    class MySummerNode extends math.ConstantNode {

      // toTex() {
      //   if(this.value == 1) {
      //     // return "un";
      //     return "\\not{1}";
      //   }
      //   return super.toTex();
      // }

      toTex() {
        var outTex;

        const tex__legacy = super.toTex();

        if (this.isSlashed) {
          return "\\not{" + tex__legacy + "}";
        } else {
          outTex = tex__legacy;
        }

        return outTex;
      }

    }

    class EmptySymbolNode extends math.SymbolNode {

      constructor() {
        super("");
        this.isNodeEmpty = true;
      }

      cloneDeep() {
        const mathNode__clone = super.cloneDeep();
        mathNode__clone.isNodeEmpty = this.isNodeEmpty;
        return mathNode__clone;
      }

    }


    class FixedDecimalConstantNode extends math.ConstantNode {

      constructor(bignumber, precision = null) {
        super(bignumber);

        this.precision = precision;
      }

      toTex() {
        var outTex;
        outTex = this.toString();
        return outTex;
      }

      toString() {
        var outString;
        outString = math.format(this.value, {notation: 'fixed', precision: this.precision});
        return outString;
      }

    }


    class SignedConstantNode extends math.ConstantNode {

      constructor(value, isColored = false) {
        super(value);
        this.isColored = isColored;
      }

      toTex() {
        var outTex;

        const tex__legacy = super.toTex();

        //sign
        if(this.value > 0) {
          outTex = "+" + " " + tex__legacy;
        } else {
          outTex = tex__legacy;
        }


        //color
        const color__pos  = "#FF0000";
        const color__zero = "#000000";
        const color__neg  = "#FFFFFF";

        var color;
        if(this.value > 0) {
          color = color__pos;
        } else if(this.value == 0) {
          color = color__zero;
        } else {
          color = color__neg;
        }

        outTex = TexEnricher.color(outTex, color);


        return outTex;
      }

    }


    class SignedFixedDecimalConstantNode extends math.ConstantNode {

      constructor(value, isColored = false) {
        super(value);
        this.isColored = isColored;
      }

      toTex() {
        var outTex;

        const tex__legacy = this.toTex__fixed_decimal();

        //sign
        if(this.value > 0) {
          outTex = "+" + " " + tex__legacy;
        } else {
          outTex = tex__legacy;
        }


        //color
        const color__pos  = "#FF0000";
        const color__zero = "#000000";
        const color__neg  = "#FFFFFF";

        var color;
        if(this.value > 0) {
          color = color__pos;
        } else if(this.value == 0) {
          color = color__zero;
        } else {
          color = color__neg;
        }

        outTex = TexEnricher.color(outTex, color);


        return outTex;
      }

      toTex__fixed_decimal() {
        var outTex;
        outTex = this.toString__fixed_decimal();
        return outTex;
      }

      toString__fixed_decimal() {
        var outString;
        outString = math.format(this.value, {notation: 'fixed', precision: this.precision});
        return outString;
      }

    }



    

    class HorizSquaresBarIntegerConstantNode extends math.ConstantNode {

      constructor(value, isColored = false) {
        super(value);
        if(!math.isInteger(value)) {
          throw new Error("HorizSquaresBarIntegerConstantNode must be initialized with an integer value");
        }
        this.isColored = isColored;
      }

      toTex() {
        logger.log("logHSBI", "toTex()");
        var outTex;

        //squaresBarize
        outTex = "█".repeat(this.value);

        //colorize
        const color = HorizSquaresBarIntegerConstantNode.colorForValue(this.value);
        outTex = TexEnricher.color(outTex, color);

        return outTex;
      }

      cloneDeep() {
        return new HorizSquaresBarIntegerConstantNode(this.value, this.isColored);
      }

      static colorForValue(value) {
        var outColor;

        switch(value) {
          case 0:
            outColor = "#000000";
            break;

          case 1:
            outColor = "#FF7F0E";
            break;
          case 2:
            outColor = "#2CA02C";
            break;
          case 3:
            outColor = "#D62728";
            break;
          case 4:
            outColor = "#9467BD";
            break;
          case 5:
            outColor = "#8C564B";
            break;
          case 6:
            outColor = "#E377C2";
            break;
          case 7:
            outColor = "#7F7F7F";
            break;
          case 8:
            outColor = "#BCBD22";
            break;
          case 9:
            outColor = "#17BECF";
            break;

          default:
            outColor = "#000000";
            break;
        }

        return outColor;
      }

    }

    class MyFunctionAssignmentNode extends math.FunctionAssignmentNode {

      toTex() {
        var outTex;

        const tex__legacy = super.toTex();
        logger.log("log1", "tex__legacy", tex__legacy);

        //remove f() and add "arrow from bar" (or "barrow")  ////ESCAPE!!
        const re = new RegExp('\\\\mathrm\{f\}\\\\left\\\((.*)\\\\right\\\):=(.*)');

        const arr = re.exec(tex__legacy);
        // logger.log("log1", "arr", arr);
        outTex = arr[1] + '\\mapsto' + arr[2];
        // logger.log("log1", "outTex", outTex);

        //2 ✕ x -> 2x
        outTex = outTex.replaceAll("\\cdot", "");

        return outTex;
      }

    }

    class My5050FunctionAssignmentNode extends math.FunctionAssignmentNode {

      toTex() {
        var outTex;

        const tex__legacy = super.toTex();
        logger.log("logAnon5050", "toTex", "tex__legacy:", tex__legacy);

        //remove f() and add "arrow from bar with question mark"  ////ESCAPE!!
        const re = new RegExp('\\\\mathrm\{f\}\\\\left\\\((.*)\\\\right\\\):=(.*)');

        const arr = re.exec(tex__legacy);
        // logger.log("log1", "arr", arr);
        outTex = arr[1] + '⊢?→' + arr[2];
        // logger.log("log1", "outTex", outTex);

        //2 ✕ x -> 2x
        outTex = outTex.replaceAll("\\cdot", "");

        return outTex;
      }

    }

    class MyAPLArrayNode extends math.ArrayNode {

      toTex() {
        var outTex;

        const tex__legacy = super.toTex();
        logger.log("logAPL", "tex__legacy", tex__legacy);

        outTex = tex__legacy;
        outTex = outTex.replaceAll("bmatrix", "matrix");
        outTex = outTex.replaceAll("\\\\", "&");

        return outTex;
      }

    }

    //class My5050ObjectNode extends math.ObjectNode {
    //
    //  evaluate() {
    //    
    //  }
    //
    //}

    class MyAnonFunctionObjectNode extends math.ObjectNode {

      static createInstance(arr_bound_var, mathNode__expr) {
        const dict__cfg = {
          type: new math.SymbolNode("anonFunction"),
          mathNode__arr_bound_var: new math.ArrayNode(arr_bound_var),
          expr:                    mathNode__expr,
        }
        return new MyAnonFunctionObjectNode(dict__cfg);
      }

    }

    class MyAnon5050FunctionObjectNode extends math.ObjectNode {

      static createInstance(arr_bound_var, arr_expr) {
        const dict__cfg = {
          type: new math.SymbolNode("anon5050Function"),
          mathNode__arr_bound_var: new math.ArrayNode(arr_bound_var),
          mathNode__arr_expr:      new math.ArrayNode(arr_expr),
        }
        return new MyAnon5050FunctionObjectNode(dict__cfg);
      }

      static evaluateInstance(mathNode_in) {  //pick a random expression and build an anonFunc with it
        const arr_bound_var = mathNode_in.properties["mathNode__arr_bound_var"].items;

        const arr_expr      = mathNode_in.properties["mathNode__arr_expr"].items;
        const mathNode__expr = Utils.randomElementInArray(arr_expr);

        const mathNode__anonFunction = MyAnonFunctionObjectNode.createInstance(arr_bound_var, mathNode__expr);

        return mathNode__anonFunction;
      }

    }

  </script>


  <!-- <script src='lib/algebra-0.2.6.min.js' type='text/javascript'></script> -->
  <!-- <script>

      //discovery
      {
        // const chain = math.chain(1);
        //OR
        const chain = math.chain();
        chain.value = 1;
        console.log("debug::chain, initial", chain);

        const step1 = chain.add(8);
        const r1    = step1.done();
        // const r1 = chain.valueOf();
        console.log("debug::chain, r1", r1);

        const step2 = step1.multiply(100);
        const r2    = step2.done();
        console.log("debug::chain, r2", r2);

        console.log("debug::chain is not mutated in place");     //which is nice and not surprising from a functional programming pov
        console.log("debug::chain.done()", chain.done());
      }

      //chaining on expression
      /*
      { //SHU: THE DREAM
        const math_with_algebra = math.create(math.all);
        math_with_algebra.import(algebra, {wrap: true, silent: true});
        // math_with_algebra.import(algebra, {override: true, wrap: true, silent: true});

        const chain = math_with_algebra.chain();

        // const expr   = new algebra.Expression("x");
        const expr   = new math_with_algebra.Expression("x");
        // const expr = "x";

        console.log("expr", expr);
        chain.value = expr;                                             //SHU TODO: make this possible
        console.log("debug::chain, initial", chain);

        // const step1 = chain.add(8);                                      //SHU: en fait c'est peut-être juste un problème de coercion.
        const step1 = chain.add(new math_with_algebra.Expression(8));    //SHU: Ah non. Dommage.

        const r1    = step1.done();
        // const r1 = chain.valueOf();
        console.log("debug::chain, r1", r1);

        const step2 = chain.multiply(100);
        const r2    = step2.done();
        console.log("debug::chain, r2", r2);
      }
      */

      /*
      { //SHU: THE WORKAROUND
        var expr   = new algebra.Expression("x");
        expr = expr.multiply(2);
        expr = expr.multiply("x");
        expr = expr.multiply(new algebra.Expression("x"));
        expr = expr.add("y");
        expr = expr.add(new algebra.Fraction(1, 3));
        expr = expr.add("y");                                       //SHU: oh, no. There is automatic reducing.
        console.log("expr", expr.toString());

        //Simplification
        //All expression operations accept a simplify argument that will yield an unsimplified expression when set to false.
        //You can then get a simplified expression with Expression.simplify.

        var expr   = new algebra.Expression("x");
        expr = expr.multiply(2,false);
        expr = expr.multiply("x",false);
        expr = expr.multiply(new algebra.Expression("x"),false);
        expr = expr.add("y",false);
        expr = expr.add(new algebra.Fraction(1, 3),false);
        expr = expr.add(new algebra.Expression("y"),false);
        console.log("expr", expr.toString());                       //SHU: unsimplified expression terms order is wrong
        expr = expr.simplify();                                     //SHU TODO: show correct terms order
        console.log("expr", expr.toString());
      }
      */

    </script> -->

  <!-- <script src='lib/math-expressions.js' type='text/javascript'></script> -->
  <!-- <script src='lib/math-expressions_umd.js' type='text/javascript'></script> -->
  <script src='lib/math-expressions.browserified.bundle.js' type='text/javascript'></script>
  <script>
    const MathExpression = Bundle_ME.MathExpression;
  </script>
  <!-- <script>
      //discovery
      const mathExpression1      = MathExpression.fromText("sin^2 (x^3)");
      const tex__mathExpression1 = mathExpression1.tex();
      console.log("MathExpression, tex__mathExpression1", tex__mathExpression1);

      const mathExpression2       = MathExpression.fromTex("5 \\times 3");
      const text__mathExpression2 = mathExpression2.toString();
      console.log("MathExpression, text__mathExpression2", text__mathExpression2);
    </script> -->



  <script src='lib/ngraph.graph.min.js' type='text/javascript'></script>
  <!-- <script>
      //discovery
      const g = createGraph();

      g.addNode('hello');
      g.addNode('world');
      //Now graph g contains two nodes: hello and world. You can also use addLink() method to grow a graph. Calling this method with nodes which are not present in the graph creates them:

      g.addLink('space', 'bar'); // now graph 'g' has two new nodes: 'space' and 'bar'
      //If nodes already present in the graph 'addLink()' makes them connected:

      // Only a link between 'hello' and 'world' is created. No new nodes.
      g.addLink('hello', 'world');

      console.log("g", g);
    </script> -->


  <script src='lib/algebrite.bundle-for-browser.js' type='text/javascript'></script>
  <script>

    //discovery
    const equality_1 = Algebrite.run('x + y + x == y + 2x');
    logger.log("equality_1", equality_1);

    const equality_2 = Algebrite.run('4(x + y) - x == 4y + 3x');
    logger.log("equality_2", equality_2);


    const equality_3 = Algebrite.run('4z(x + y) - zx == 4yz + 3xz');    //SHU: software is dumb and intelligent: a priori, xz != zx ( or maybe it's something else ... )
    logger.log("equality_3", equality_3);

    const equality_4 = Algebrite.run('4z(x + y) - zx == 4zy + 3zx');
    logger.log("equality_4", equality_4);

  </script>

  <!-- custom maths stuff -->
  <script>

    const dict_opConfig = {
      1: {
        minus: {
          arity: 1,
          symbol: "-",
          name: "unaryMinus",
          precedence: 6,
        },
        inverse: {
          arity: 1,
          symbol: "/",
          name: "inverse",
          precedence: "?",
        },

        magic_lhs_add: {
          arity: 1,
          symbol: "-↷+",
          name: "magic_lhs_add",
          precedence: "?",

          inverse: "magic_rhs_sub",
        },
        magic_lhs_sub: {
          arity: 1,
          symbol: "+↷-",
          name: "magic_lhs_sub",
          precedence: "?",

          inverse: "magic_rhs_add",
        },
        magic_lhs_multiply: {
          arity: 1,
          symbol: "÷↷✕",
          name: "magic_lhs_multiply",
          precedence: "?",

          inverse: "magic_rhs_divide",
        },
        magic_lhs_divide: {
          arity: 1,
          symbol: "✕↷÷",
          name: "magic_lhs_divide",
          precedence: "?",

          inverse: "magic_rhs_multiply",
        },

        magic_rhs_add: {
          arity: 1,
          symbol: "+↶-",
          name: "magic_rhs_add",
          precedence: "?",

          inverse: "magic_lhs_sub",
        },
        magic_rhs_sub: {
          arity: 1,
          symbol: "-↶+",
          name: "magic_rhs_sub",
          precedence: "?",

          inverse: "magic_lhs_add",
        },
        magic_rhs_multiply: {
          arity: 1,
          symbol: "✕↶÷",
          name: "magic_rhs_multiply",
          precedence: "?",

          inverse: "magic_lhs_divide",
        },
        magic_rhs_divide: {
          arity: 1,
          symbol: "÷↶✕",
          name: "magic_rhs_divide",
          precedence: "?",

          inverse: "magic_lhs_multiply",
        },



      },
      2: {
        plus: {
          arity: 2,
          symbol: "+",
          // name: "plus",
          name: "add",
          precedence: 9,

          inverse: "minus",
        },
        minus: {
          arity: 2,
          symbol: "-",
          // name: "minus",
          name: "subtract",
          precedence: 9,

          inverse: "plus",
        },
        multiply: {
          arity: 2,
          symbol: "×",

          name: "multiply",
          precedence: 8,

          inverse: "divide",
        },
        divide: {
          arity: 2,
          symbol: "/",
          name: "divide",
          precedence: 8,

          inverse: "multiply",
        },

        pow: {
            arity: 2,
            symbol: "^",
            name: "pow",
            precedence: 5,

            inverse: "root",
          },

        root: {
          arity: 2,
          symbol: "√",
          name: "root",
          precedence: 5,

          inverse: "pow",
        },

        eval: {
          arity: 2,
          symbol: "eval",
          name: "eval",
          precedence: 1,

          inverse: "deval",
        },

        // myApply: {
        //   arity: 2,
        //   symbol: "*",
        //   name: "myApply",
        //   precedence: 1,

        //   inverse: "unMyApply",
        // },

      },
      n: {
        plus: {
          arity: "n",
          symbol: "+",
          // name: "plus",
          name: "add",
          precedence: 9,

          inverse: "minus",
        },
        multiply: {
          arity: "n",
          symbol: "×",
          name: "multiply",
          precedence: 8,

          inverse: "divide",
        },
      },
    };


    // (...) [...] {...}		            1
    // x(...) x[...] obj.prop :		    2
    // '		                            3
    // !		                            4
    // ^, .^		                        5
    // +, -, ~, not		                6
    // See section below		            7
    // *, /, .*, ./, %, mod		        8
    // +, -		                        9
    // :		                           10
    // to, in		                     11
    // <<, >>, >>>		                 12
    // Err :501		                   13
    // &		                           14
    // ^|		                         15
    // |		                           16
    // and		                         17
    // xor		                         18
    // or		                         19
    // ?, :		                       20
    // =		                           21
    // ,		                           22
    // ;		                           23
    // \n, ;		                       24
    const precedenceDict = {
      "unaryPlus": 6,
      "unaryMinus": 6,

      "multiply": 8,
      "divide": 8,

      "add": 9,
      "subtract": 9,
    };


    class Operator {

      constructor(arity, easyName, symbol, name, inverseName = null) {
        this.arity = arity;
        this.easyName = easyName;

        this.op = symbol;
        this.symbol = symbol;

        this.name = name;

        this.inverseName = inverseName;
      }

      static fromConfig(opConfig) {
        const op = new Operator(opConfig.arity, "lolilol", opConfig.symbol, opConfig.name, opConfig.inverse);
        return op;
      }

      static randomInstance(arity) {

        const arr_opConfig = Object.values(dict_opConfig[arity]);
        const opConfig__random = Utils.randomElementInArray(arr_opConfig);

        const op__random = Operator.fromConfig(opConfig__random);
        return op__random;
      }


      inverse() {   //what did you expect ?
        const arity = this.arity;
        const inverseName = this.inverseName;

        const opConfig__inverse = dict_opConfig[arity][inverseName];

        const op__inverse = Operator.fromConfig(opConfig__inverse);
        return op__inverse;
      }


      static multiply() {
        var outOp;

        const opConfig = dict_opConfig[2]["multiply"];
        outOp = Operator.fromConfig(opConfig);

        return outOp;
      }

      static divide() {
        var outOp;

        const opConfig = dict_opConfig[2]["divide"];
        outOp = Operator.fromConfig(opConfig);

        return outOp;
      }

      static eval() {
        var outOp;

        const opConfig = dict_opConfig[2]["eval"];
        outOp = Operator.fromConfig(opConfig);

        return outOp;
      }

      static funcNameForSymbolString(str__mathOperatorSymbol) {
        var outMathOperatorFuncName;

        switch (str__mathOperatorSymbol) {
          case "+":
          case "plus":
          case "add":
            outMathOperatorFuncName = 'add';
            break;
          case "-":
          case "minus":
          case "subtract":
            outMathOperatorFuncName = 'subtract';
            break;
          case "x":
          case "×":
          case "times":
          case "multiplyBy":
            outMathOperatorFuncName = 'multiply';
            break;
          case "/":
          case "divideBy":
          case "add":
            outMathOperatorFuncName = 'divide';
            break;
          default:
            outMathOperatorFuncName = 'unknown';
            break;
        }

        return outMathOperatorFuncName;
      }

      static fromOpString_binary(opString) {
        var outOp;

        function fnString_for_opString(opString) {
          var outString;

          switch (opString) {
            case "+":
              outString = "plus";
              break;
            case "-":
              outString = "minus";
              break;
            case "x":
            case "×":
            case "*":
              outString = "multiply";
              break;
            case "/":
            case "÷":
              outString = "divide";
              break;

            case "^":
              outString = "pow";
              break;

            case "√":
              outString = "root";
              break;

              
            case "eval":
              outString = "eval";
              break;
          }

          return outString;
        }

        const fnString = fnString_for_opString(opString);

        outOp = Operator.fromString_binary(fnString);

        return outOp;
      }

      static fromString_binary(fnString) {
        var outOp;

        const opConfig = dict_opConfig[2][fnString];
        outOp = Operator.fromConfig(opConfig);

        return outOp;
      }


      static fromString_unary(opString) {
          var outOp;

          function fnString_for_opString(opString) {
            var outString;

            switch(opString) {
              case "magic:lhs+":
                outString = "magic_lhs_add";
                break;
              case "magic:lhs-":
                outString = "magic_lhs_sub";
                break;
              case "magic:lhsx":
                outString = "magic_lhs_multiply";
                break;
              case "magic:lhs/":
                outString = "magic_lhs_divide";
                break;

              case "magic:rhs+":
                outString = "magic_rhs_add";
                break;
              case "magic:rhs-":
                outString = "magic_rhs_sub";
                break;
              case "magic:rhsx":
                outString = "magic_rhs_multiply";
                break;
              case "magic:rhs/":
                outString = "magic_rhs_divide";
                break;



              default:
                break;
            }

            return outString;
          }

          const fnString = fnString_for_opString(opString);

          const opConfig = dict_opConfig[1][fnString];
          outOp = Operator.fromConfig(opConfig);

          return outOp;
        }

        static displayStringForOp(op_magic) {
          var outString;

          switch(op_magic.name) {
            case "magic_lhs_add":
              outString = "- ↷ +";
              break;
            case "magic_lhs_sub":
              outString = "+ ↷ -";
              break;
            case "magic_lhs_multiply":
              outString = "÷ ↷ ✕";
              break;
            case "magic_lhs_divide":
              outString = "✕ ↷ ÷";
              break;

            case "magic_rhs_add":
              outString = "+ ↶ -";
              break;
            case "magic_rhs_sub":
              outString = "- ↶ +";
              break;
            case "magic_rhs_multiply":
              outString = "✕ ↶ ÷";
              break;
            case "magic_rhs_divide":
              outString = "÷ ↶ ✕";
              break;

          }

          return outString;
        }

    }

    class Operation {

      constructor(transformationFunc) {
        this.transformationFunc = transformationFunc;
      }

    }





    function random_op(arity) {
      const op = Operator.randomInstance(arity);
      return op;
    }
    // console.log("random_op", random_op(2));

    function random_number(range) {
      //min included
      //max included (but very rare)
      const span = range.max - range.min;
      const number = Math.floor(range.min + Math.random() * span);
      return number;
    }

    const arr_symbols = ["x", "y"];
    // const arr_symbols = ["x", "y", "z", "t", "a", "b"];

    function random_symbol() {
      const symbol = Utils.randomElementInArray(arr_symbols);
      return symbol;
    }

    function arityForArr(arr) {
      var outArity;

      switch (arr.length) {
        // case 0:
        //   outArity = 0;     //everything or nothing
        // break;
        case 1:
          outArity = 1;
          break;
        case 2:
          outArity = 2;
          break;
        default:
          outArity = "n";
          break;
      }

      return outArity;
    }

    //////////////////////

    function random_constantNode(range = { min: 0, max: 100, step: 1 }) {
      const number = random_number(range);
      const constantNode = new math.ConstantNode(number);
      return constantNode;
    }

    function random_symbolNode() {
      const symbol = random_symbol();
      const symbolNode = new math.SymbolNode(symbol);
      return symbolNode;
    }

    function random_terminal_mathNode_withType(type) {
      var outMathNode;

      switch (type) {
        case "ConstantNode":
          outMathNode = random_constantNode();
          break;
        case "SymbolNode":
          outMathNode = random_symbolNode();
          break;
        // case "operator":
        // break;
      }

      return outMathNode;
    }

    function random_terminal_mathNode_withType_inArr(arr_type) {
      const type = Utils.randomElementInArray(arr_type);
      const mathNode = random_terminal_mathNode_withType(type);
      return mathNode;
    }

    function random_terminal_mathNode_withType_inArr_and_isEnvelopped(arr_type, isEnvelopped) {

      var mathNode = random_terminal_mathNode_withType_inArr(arr_type);
      if (isEnvelopped) {
        mathNode = new math.ParenthesisNode(mathNode);
      }

      return mathNode;
    }

    function random_operatorNode(/*arity,*/ arr_node) {
      const arity = arityForArr(arr_node);
      const op = random_op(arity);
      const operatorNode = new math.OperatorNode(op.op, op.name, arr_node);
      return operatorNode;
    }


    function createFuncWrapper(op, node_b, func) {  //work horse

      const simpleName = op.op + " " + node_b.toString();

      const funcWrapper = {
        semantics: {
          operator: op,
          node_b: node_b.cloneDeep(),
          node__operatorNode: new math.OperatorNode(op.op, op.name, [MathSingleton.node__empty, node_b.cloneDeep()]),
          name: simpleName,
        },
        display: {
          node__display: null,
        },
        func: func,
        inverse: null,  //set later
      };

      return funcWrapper;
    }

    function createFuncWrapper__with_order(op, arr_arg_in, func) {  //work horse

      // const simpleName = op.op + " " + node_b.toString();
      const simpleName = arr_arg_in[0] + " " + op.op + " " + arr_arg_in[1];

      const node_b  = arr_arg_in.find((mathNode) => mathNode != MathSingleton.node__empty);
      const arr_arg = arr_arg_in.map((mathNode) => {
        var outNode;
        if(mathNode == node_b) {
          outNode = mathNode.cloneDeep();
        } else {
          outNode = mathNode;
        }
        return outNode;
      })

      const funcWrapper = {
        semantics: {
          operator: op,
          node_b: node_b.cloneDeep(),
          node__operatorNode: new math.OperatorNode(op.op, op.name, arr_arg),
          name: simpleName,
        },
        display: {
          node__display: null,
        },
        func: func,
        inverse: null,  //set later
      };

      return funcWrapper;
    }


    function random_operatorNodeFactoryFunc_binary(arr_type) {
      var outFunc;

      const arity = 2
      const op = random_op(arity);

      const node_b = random_terminal_mathNode_withType_inArr(arr_type);

      outFunc = (node_a) => {
        const arr_node = [node_a, node_b];
        const operatorNode = new math.OperatorNode(op.op, op.name, arr_node);
        return operatorNode;
      };

      return outFunc;
    }

    function createMathNodeTransformationFunc_binary(mathOperatorSymbol_in, mathOperatorFuncName_in, node_b_in, isShuffled = false) {
      return (node_a) => {
        var outNode;

        const mathOperatorSymbol = mathOperatorSymbol_in;
        const mathOperatorFuncName = mathOperatorFuncName_in;
        const node_b = node_b_in;

        function standardOperation(node_in) {
          var outNode;

          // const node_b        = new math.ConstantNode(mathValue);

          var arr_child = [node_in, node_b];
          logger.log("logGolf", "arr_child, before:", arr_child);
          if (isShuffled) {
            switch (mathOperatorFuncName) {
              case "add":
              case "multiply":
                {
                  const shuffle = arr =>
                    [...arr].reduceRight((res, _, __, s) =>
                      (res.push(s.splice(0 | Math.random() * s.length, 1)[0]), res), []);

                  arr_child = shuffle(arr_child);
                  // logger.log("arr_child, after", arr_child);
                }
                break;
              default:
                //do nothing
                break;
            }
          }

          const node_operator     = new math.OperatorNode(mathOperatorSymbol, mathOperatorFuncName, arr_child);
          const node_unsimplified = node_operator;

          if (node_in.autoSimplify) {
            // const node_simplified = math.simplify(node_unsimplified);
            const node_simplified = Simplifier.simplify_top_layer(node_unsimplified);
            outNode = node_simplified;
          } else {
            outNode = node_unsimplified;
          }

          outNode.autoSimplify = node_in.autoSimplify;

          return outNode;
        }

        const standardOperation__withArrayNodeSupport = MathUtils.decorate__support__arrayNode(standardOperation);

        // logger.log("node_a", node_a);
        if (node_a.isEquation) {
          console.log("node_a", node_a);
          // const node_left  = standardOperation(node_a.params[0]);
          // const node_right = standardOperation(node_a.params[1]);
          const node_left  = standardOperation__withArrayNodeSupport(node_a.params[0]);
          const node_right = standardOperation__withArrayNodeSupport(node_a.params[1]);
          const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
          node_equation.isEquation = true;

          outNode = node_equation;
        } else {
          // outNode = standardOperation(node_a);
          outNode = standardOperation__withArrayNodeSupport(node_a);
        }

        // outNode.autoSimplify = node_a.autoSimplify;

        return outNode;
      };
    }

    function createMathNodeTransformationFunc_binary__with_order(mathOperatorSymbol_in, mathOperatorFuncName_in, arr_arg_in) {
      return (node_a) => {
        var outNode;

        const mathOperatorSymbol   = mathOperatorSymbol_in;
        const mathOperatorFuncName = mathOperatorFuncName_in;

        // const node_b = arr_arg_in.filter((mathNode) => mathNode != MathSingleton.node__empty);

        function standardOperation(node_in) {
          var outNode;

          const arr_child__substituted = arr_arg_in.map((mathNode) => {
            var outNode;
            if(mathNode == MathSingleton.node__empty) {
              outNode = node_in;
            } else {
              outNode = mathNode;
            }
            return outNode;
          });

          const node_operator     = new math.OperatorNode(mathOperatorSymbol, mathOperatorFuncName, arr_child__substituted);
          const node_unsimplified = node_operator;

          if (node_in.autoSimplify) {
            // const node_simplified = math.simplify(node_unsimplified);
            const node_simplified = Simplifier.simplify_top_layer(node_unsimplified);
            outNode = node_simplified;
          } else {
            outNode = node_unsimplified;
          }

          outNode.autoSimplify = node_in.autoSimplify;

          return outNode;
        }

        // outNode = standardOperation(node_a);

        const standardOperation__withArrayNodeSupport = MathUtils.decorate__support__arrayNode(standardOperation);

        // logger.log("node_a", node_a);
        if (node_a.isEquation) {
          console.log("node_a", node_a);
          // const node_left  = standardOperation(node_a.params[0]);
          // const node_right = standardOperation(node_a.params[1]);
          const node_left  = standardOperation__withArrayNodeSupport(node_a.params[0]);
          const node_right = standardOperation__withArrayNodeSupport(node_a.params[1]);
          const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
          node_equation.isEquation = true;

          outNode = node_equation;
        } else {
          // outNode = standardOperation(node_a);
          outNode = standardOperation__withArrayNodeSupport(node_a);
        }

        // outNode.autoSimplify = node_a.autoSimplify;

        return outNode;
      };
    }

    function random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op = null) {
      var outFuncWrapper;

      const arr_type__node_b = operatorParams.node_b.types;
      const isShuffled       = (operatorParams.isShuffled != null) ? operatorParams.isShuffled : false;

      function createPremultiplied(node_b, premultiplier) {
        var outNode;

        if(premultiplier.n_type == "integer") {

          const range__premultiplier = operatorParams.premultiplier.range;
  
          const val_constant = math.randomInt(range__premultiplier.min, range__premultiplier.max);
          if(val_constant == 1) {
            // node_b = node_b;
          } else {
            const node_constant = new math.ConstantNode(val_constant);
            outNode = new math.OperatorNode("×", "multiply", [node_constant, node_b]);
          }

        } else if(premultiplier.n_type == "frac") {

          const range__premultiplier__num = operatorParams.premultiplier.range__num;
          const range__premultiplier__den = operatorParams.premultiplier.range__den;
  
          const val__num = math.randomInt(range__premultiplier__num.min, range__premultiplier__num.max);
          const val__den = math.randomInt(range__premultiplier__den.min, range__premultiplier__den.max);

          const val__frac = math.fraction(val__num, val__den);

          const node__premultiplier_frac = new math.ConstantNode(val__frac);

          if((node_b.value == 1) && (val__frac == 1)) {
            outNode = node_b;
          } else if(node_b.value == 1) {
            outNode = node__premultiplier_frac;
          } else if(val__frac == 1) {
            outNode = node_b;
          } else {
            outNode = new math.OperatorNode("×", "multiply", [node__premultiplier_frac, node_b]);
          }

          
        } else {
          throw new Error("Unknown premultiplier n_type: " + premultiplier.n_type);
        }

        return outNode;
      }


      const arity = 2
      var op;
      if (arr_op != null) {
        op = Utils.randomElementInArray(arr_op);
      } else {
        op = random_op(arity);
      }

      var node_b = random_terminal_mathNode_withType_inArr(arr_type__node_b);
      // logger.log("random_operatorNodeFactoryFuncWrapper_binary, node_b", node_b);
      if (node_b.type == "ConstantNode") {

        if(operatorParams.node_b.isComplex) {

          function randomValue(range__value) {
            return math.randomInt(range__value.min, range__value.max);
          }
  
          function createNewValue(range__value, arr__value) {
            var value;
            if (arr__value != null) {
              value = Utils.randomElementInArray(arr__value);
            } else {
              value = randomValue(range__value);
            }
            // logger.log("value:", value);
            if (op.name == "divide") {
              while (value == 0) {
                value = randomValue(range__value);
              }
            }
            return value;
          }

          const range__node_b__re    = operatorParams.node_b.range__re;
          const arr__node_b__re      = operatorParams.node_b.arr__re;
  
          const value__re = createNewValue(range__node_b__re, arr__node_b__re);

          const range__node_b__im    = operatorParams.node_b.range__im;
          const arr__node_b__im      = operatorParams.node_b.arr__im;

          const value__im = createNewValue(range__node_b__im, arr__node_b__im);
  
          node_b = new math.ConstantNode(math.complex(value__re,value__im));


          if(operatorParams.premultiplier != null) {

            try {
              node_b = createPremultiplied(node_b, operatorParams.premultiplier);
            } catch(e) {
              logger.log("logError", e);
            }
  
          } else {
            node_b = new math.ParenthesisNode(node_b);
          }
          

        } else {

          const range__node_b    = operatorParams.node_b.range;
          const arr__node_b      = operatorParams.node_b.arr;

          function randomValue() {
            return math.randomInt(range__node_b.min, range__node_b.max);
          }
  
          var value;
          if (arr__node_b != null) {
            value = Utils.randomElementInArray(arr__node_b);
          } else {
            value = randomValue();
          }
          // logger.log("value:", value);
          if (op.name == "divide") {
            while (value == 0) {
              value = randomValue();
            }
          }
  
  
          node_b = new math.ConstantNode(value);
  
          if (node_b.value < 0) {
            node_b = new math.ParenthesisNode(node_b);
          }

        }

      } else if(node_b.type == "SymbolNode") {

        const range__node_b    = operatorParams.node_b.range;
        const arr__node_b      = operatorParams.node_b.arr;

        if(arr__node_b != null) {
          var value = Utils.randomElementInArray(arr__node_b);
          node_b = new math.SymbolNode(value);
        }

        if(operatorParams.premultiplier != null) {

          node_b = createPremultiplied(node_b, operatorParams.premultiplier);

        }

      }

      outFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b, isShuffled);

      return outFuncWrapper;
    }

    function operatorNodeFactoryFuncWrapper_binary(op, node_b, isShuffled = false) {
      var outFuncWrapper;

      const func = createMathNodeTransformationFunc_binary(op.op, op.name, node_b, isShuffled);

      const funcWrapper = createFuncWrapper(op, node_b, func);
      if(op.name != "myApply") {
        const op__inverse   = op.inverse();
        const func__inverse = createMathNodeTransformationFunc_binary(op__inverse.op, op__inverse.name, node_b, isShuffled);
        const funcWrapper__inverse = createFuncWrapper(op__inverse, node_b, func__inverse);
        funcWrapper.inverse = funcWrapper__inverse;
      }
      outFuncWrapper = funcWrapper;

      return outFuncWrapper;
    }

    function operatorNodeFactoryFuncWrapper_binary__with_order(op, arr_arg) {
      var outFuncWrapper;

      const func = createMathNodeTransformationFunc_binary__with_order(op.op, op.name, arr_arg);

      const funcWrapper = createFuncWrapper__with_order(op, arr_arg, func);
      // if(op.name != "myApply") {
      //   const op__inverse   = op.inverse();
      //   const func__inverse = createMathNodeTransformationFunc_binary(op__inverse.op, op__inverse.name, node_b);
      //   const funcWrapper__inverse = createFuncWrapper__with_order(op__inverse, arr_arg, func__inverse);
      //   funcWrapper.inverse = funcWrapper__inverse;
      // }
      outFuncWrapper = funcWrapper;

      return outFuncWrapper;
    }

    function cloneOperatorNodeFactoryFuncWrapper_binary(operatorNodeFactoryFuncWrapper) {
      const op     = operatorNodeFactoryFuncWrapper.semantics.operator;
      const node_b = operatorNodeFactoryFuncWrapper.semantics.node_b;
      return operatorNodeFactoryFuncWrapper_binary(op, node_b);
    }






    function operatorNodeFactoryFuncWrapper_unary(op) {
      var outFuncWrapper;

      const func = createMathNodeTransformationFunc_unary(op.op, op.name);

      const op__inverse   = op.inverse();
      const func__inverse = createMathNodeTransformationFunc_unary(op__inverse.op, op__inverse.name);

      const funcWrapper          = createFuncWrapper(op, MathSingleton.node__empty, func);
      const funcWrapper__inverse = createFuncWrapper(op__inverse, MathSingleton.node__empty, func__inverse);
      funcWrapper.inverse = funcWrapper__inverse;

      outFuncWrapper = funcWrapper;

      return outFuncWrapper;
    }


    function createMathNodeTransformationFunc_unary(mathOperatorSymbol_in, mathOperatorFuncName_in) {

      function createFuncForMagic(magicName) {  
        return (node_a) => {
          var outNode;

          if(node_a.isEquation) {
            const node_lhs = node_a.params[0];
            const node_rhs = node_a.params[1];

            function findSymbolBranch(mathNode) {
              var outNode = null;
              if(mathNode.isSymbolNode) {
                outNode = mathNode;
              } else {
                if(mathNode instanceof math.OperatorNode) {
                  outNode = mathNode.args.reduce((acc, x) => {
                    if(acc == null) {
                      const isFound = x.filter(mathNode_f => {
                        return findSymbolBranch(mathNode_f);
                      }) != null;
                      if(isFound) {
                        acc = x;
                      }
                    }
                    return acc;
                  }, null);
                } else if(mathNode instanceof math.RelationalNode) {
                  outNode = mathNode.params.reduce((acc, x) => {
                    if(acc == null) {
                      const isFound = x.filter(mathNode_f => {
                        return findSymbolBranch(mathNode_f);
                      }) != null;
                      if(isFound) {
                        acc = x;
                      }
                    }
                    return acc;
                  }, null);
                } else if(mathNode instanceof math.ParenthesisNode) {
                  outNode = findSymbolBranch(mathNode.content);
                } else {
                  //??
                  outNode = null;
                }
              } 
              return outNode;
            }


            function isOpNode_binary_(mathNode) { //, fn) {
              const isOpNode = (mathNode instanceof math.OperatorNode); //&& (mathNode.fn == fn);
              const isBinary = mathNode.args.length == 2;
              return isOpNode && isBinary;
            }


            function magicFunc_lhs(node_lhs, node_rhs, magicName) {
              var outNode;

              const node_term__symbol   = findSymbolBranch(node_lhs);
              logger.log("node_term__symbol", node_term__symbol);
              const node_term__other = node_lhs.args.find(mathNode => mathNode != node_term__symbol);

              const isOpNode_binary = isOpNode_binary_(node_lhs);
              if(isOpNode_binary) {

                const dict_magic_for_opName = {
                  "add"     : "magic_lhs_sub",
                  "subtract": "magic_lhs_add",
                  "multiply": "magic_lhs_divide",
                  "divide":   "magic_lhs_multiply",
                };

                const op_lhs               = node_lhs.op;
                logger.log("op_lhs", op_lhs);
                const operator_symbol_side = Operator.fromOpString_binary(op_lhs);
                const opName               = operator_symbol_side.name;

                const magicForOpName = dict_magic_for_opName[opName];
                logger.log("magicForOpName", magicForOpName);
                logger.log("magicName", magicName);

                const isValidMagic   = (magicForOpName == magicName);

                if(isValidMagic) {

                  const operator_inverse  = operator_symbol_side.inverse();
                  logger.log("operator_inverse", operator_inverse);

                  const mathNode_lhs__new = node_term__symbol;
                  const mathNode_rhs__new = new math.OperatorNode(operator_inverse.symbol, operator_inverse.name, [node_rhs, node_term__other]);

                  outNode = new math.RelationalNode(["equal"], [mathNode_lhs__new, mathNode_rhs__new]);

                } else {
                  outNode = node_a;
                }

              } else {
                outNode = node_a;
              }

              return outNode;

            }

            function magicFunc_rhs(node_lhs, node_rhs, magicName) {
              var outNode;

              const node_term__symbol   = findSymbolBranch(node_rhs);
              logger.log("node_term__symbol", node_term__symbol);
              const node_term__other = node_rhs.args.find(mathNode => mathNode != node_term__symbol);

              const isOpNode_binary = isOpNode_binary_(node_rhs);
              if(isOpNode_binary) {

                const dict_magic_for_opName = {
                  "add"     : "magic_rhs_sub",
                  "subtract": "magic_rhs_add",
                  "multiply": "magic_rhs_divide",
                  "divide":   "magic_rhs_multiply",
                };

                const op_rhs               = node_rhs.op;
                logger.log("op_rhs", op_rhs);
                const operator_symbol_side = Operator.fromOpString_binary(op_rhs);
                const opName               = operator_symbol_side.name;

                const magicForOpName = dict_magic_for_opName[opName];
                logger.log("magicForOpName", magicForOpName);
                logger.log("magicName", magicName);

                const isValidMagic   = (magicForOpName == magicName);

                if(isValidMagic) {

                  const operator_inverse  = operator_symbol_side.inverse();
                  logger.log("operator_inverse", operator_inverse);

                  const mathNode_lhs__new = new math.OperatorNode(operator_inverse.symbol, operator_inverse.name, [node_lhs, node_term__other]);
                  const mathNode_rhs__new = node_term__symbol;

                  outNode = new math.RelationalNode(["equal"], [mathNode_lhs__new, mathNode_rhs__new]);

                } else {
                  outNode = node_a;
                }

              } else {
                outNode = node_a;
              }

              return outNode;

            }

            logger.log("logEq4", "magicName:", magicName);
            const isMagic_lhs     = magicName.startsWith("magic_lhs");
            const isSymbol_in_lhs = (findSymbolBranch(node_lhs) != null);
            if(isMagic_lhs && isSymbol_in_lhs) {
              outNode = magicFunc_lhs(node_lhs, node_rhs, magicName);
            } else if(!isMagic_lhs && !isSymbol_in_lhs) {
              outNode = magicFunc_rhs(node_lhs, node_rhs, magicName);
            } else {
              outNode = node_a;
            }
            

          }
          else {
            outNode = node_a;
          }

          return outNode;
        };
      }

      function standardOperation(node_in) {
        var outNode;

        var arr_child = [node_in];

        const node_operator = new math.OperatorNode(mathOperatorSymbol, mathOperatorFuncName, arr_child);

        const node_unsimplified = node_operator;

        if (node_in.autoSimplify) {
          // const node_simplified = math.simplify(node_unsimplified);
          const node_simplified = Simplifier.simplify_top_layer(node_unsimplified);
          outNode = node_simplified;
        } else {
          outNode = node_unsimplified;
        }

        outNode.autoSimplify = node_in.autoSimplify;

        return outNode;
      }


      function mathNodeTransformationFunc(node_a) {
        var outNode;

        const mathOperatorSymbol   = mathOperatorSymbol_in;
        const mathOperatorFuncName = mathOperatorFuncName_in;

        // logger.log("node_a", node_a);
        const isMagic = mathOperatorFuncName_in.startsWith("magic");
        if(isMagic) {
          if (node_a.isEquation) {
            const func__magic = createFuncForMagic(mathOperatorFuncName_in);
            outNode = func__magic(node_a);
          } else {
            //???
          }
        } else {
          if (node_a.isEquation) {
            console.log("node_a", node_a);
            const node_left  = standardOperation(node_a.params[0]);
            const node_right = standardOperation(node_a.params[1]);
            const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
            node_equation.isEquation = true;

            outNode = node_equation;
          } else {
            outNode = standardOperation(node_a);
          }
        }

        // outNode.autoSimplify = node_a.autoSimplify;

        return outNode;
      }

      return mathNodeTransformationFunc;
    }



    function operatorNodeFactoryFuncWrapper_from_operatorNode(mathNode__operator, isShuffled = false) {
      logger.log("logOp", "operatorNodeFactoryFuncWrapper_from_operatorNode", mathNode__operator, isShuffled);
      var outFuncWrapper;

      // const arity__outer = 

      const nb_arg__empty = new Array(mathNode__operator.args.filter((mathNode) => (mathNode == MathSingleton.node__empty))).length; 
      const arity__inner  = nb_arg__empty + 1;

      switch(arity__inner) {
        case 1:
          {
            // const op   = 
            // const name =

            // const outFuncWrapper = operatorNodeFactoryFuncWrapper_unary()
          }
          break;
        case 2:
          {
            const op     = Operator.fromOpString_binary(mathNode__operator.op);
            // const node_b = mathNode__operator.args.find((mathNode) => (mathNode != MathSingleton.node__empty));

            const arr_arg = mathNode__operator.args.map((mathNode) => {
              var outNode;
              if(mathNode == MathSingleton.node__empty) {
                outNode = mathNode;
              } else {
                outNode = mathNode;
              }
              return outNode;
            });

            // outFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b, isShuffled);
            outFuncWrapper = operatorNodeFactoryFuncWrapper_binary__with_order(op, arr_arg, isShuffled);
          }
          break;
        default:
          //SHU TODO: arity:n (+,x) ... [[collection]] * [+] = [[reduce(+, collection)]]
          break;
      }

      return outFuncWrapper;
    }




    function random_operatorNode_debug() {
      const arr_nodes = [
        random_symbolNode(),
        random_constantNode(),
      ];
      const operatorNode = random_operatorNode(arr_nodes);
      return operatorNode;
    }
    console.log("random_operatorNode_debug", random_operatorNode_debug());



    function random_operatorNode_binary_withDepth(depth) {
      if (depth < 2) {
        throw new Error("operatorNode is has min depth: 2");
      } else if (depth == 2) {
        const arr_node = [0, 1].map(index => random_terminal_mathNode_withType_inArr(["ConstantNode", "SymbolNode"]));
        const operatorNode = random_operatorNode(arr_node);
        return operatorNode;
      } else {
        const arr_node = [0, 1].map(index => random_operatorNode_binary_withDepth(depth - 1));
        const operatorNode = random_operatorNode(arr_node);
        return operatorNode;
      }
    }

    function random_mathNode_withDepth(depth) {
      var outMathNode;

      if (depth < 1) {
        throw new Error("mathNode is has min depth: 1");
      } else if (depth == 1) {
        const terminalNode = random_terminal_mathNode_withType_inArr(["ConstantNode", "SymbolNode"]);
        outMathNode = terminalNode;
      } else {
        const operatorNode = random_operatorNode_binary_withDepth(depth);
        outMathNode = operatorNode;
      }

      return outMathNode;
    }
    console.log("random_mathNode_withDepth", random_mathNode_withDepth(4));





    //only n symbols

    function getNbSymbolNodes(mathNode) {
      var outInt = 0;

      switch (mathNode.type) {
        case "SymbolNode":
          outInt = 1;
          break;
        case "OperatorNode":
          outInt = operator.params.reduce((acc, x) => acc + getNbSymbolNodes(x), 0);
      }

      return outInt;
    }

    function arr_terminalTypes_for_nbSymbols(nb_symbols) {
      const arr_terminalTypes = ["ConstantNode"];
      if (nb_symbols > 0) {
        arr_terminalTypes.push("SymbolNode");
      }
      return arr_terminalTypes;
    }

    function random_reduceObj__operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols) {   //SHU: it's nb_symbols_remaining
      var outObj;
      var outNode;
      var outNbSymbols;

      const depth_min = 2;

      if (depth < depth_min) {
        throw new Error("operatorNode is has min depth: 2");
      };

      var nb_symbols_curr = nb_symbols;
      if (depth == 2) {

        const arity = 2;
        const arr_nodeIndex = [...new Array(arity).keys()];

        const reducedObj2 = arr_nodeIndex.reduce((acc2, nodeIndex) => {
          const arr_terminalTypes = arr_terminalTypes_for_nbSymbols(acc2.nb_symbols);
          const mathNode = random_terminal_mathNode_withType_inArr(arr_terminalTypes);

          if (mathNode.type == "SymbolNode") {
            acc2.nb_symbols -= 1;
          }

          acc2.arr_mathNode.push(mathNode);

          return acc2;
        }, {
          nb_symbols: nb_symbols_curr,
          arr_mathNode: [],
        });

        outNbSymbols = reducedObj2.nb_symbols;

        const operatorNode = random_operatorNode(reducedObj2.arr_mathNode);
        outNode = operatorNode;
      } else {

        const arity = 2;
        const arr_nodeIndex = [...new Array(arity).keys()];

        const reducedObj2 = arr_nodeIndex.reduce((acc2, nodeIndex) => {
          const reducedObj_ = random_reduceObj__operatorNode_binary_withDepth_and_nbSymbols(depth - 1, acc2.nb_symbols);

          acc2.nb_symbols = reducedObj_.nb_symbols;

          const mathNode = reducedObj_.mathNode;
          acc2.arr_mathNode.push(mathNode);

          return acc2;
        }, {
          nb_symbols: nb_symbols_curr,
          arr_mathNode: [],
        });

        outNbSymbols = reducedObj2.nb_symbols;

        const operatorNode = random_operatorNode(reducedObj2.arr_mathNode);
        outNode = operatorNode;
      }

      outObj = {
        nb_symbols: outNbSymbols,
        mathNode: outNode,
      };
      console.log("depth", depth, "outNbSymbols", outNbSymbols);

      return outObj;
    }

    function random_operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols = 1) {
      const reduceObj = random_reduceObj__operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols);
      return reduceObj.mathNode;
    }

    function random_mathNode_withDepth_and_nbSymbols(depth, nb_symbols = 1) {
      var outMathNode;

      if (depth < 1) {
        throw new Error("mathNode is has min depth: 1");
      } else if (depth == 1) {
        const terminalNode = random_terminal_mathNode_withType_inArr(["ConstantNode", "SymbolNode"]);
        outMathNode = terminalNode;
      } else {
        const operatorNode = random_operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols);
        outMathNode = operatorNode;
      }

      return outMathNode;
    }

    function random_onion_mathNode(depth, isWithExplicitationParentheses = true, isWithRandomParentheses = false) {
      var outMathNode;

      if (depth < 1) {
        throw new Error("mathNode is has min depth: 1");
      } else if (depth == 1) {

        const random_boolean = Math.random() < 0.5;
        const isEnvelopped = random_boolean;

        const terminalNode = random_terminal_mathNode_withType_inArr_and_isEnvelopped(["SymbolNode"], isEnvelopped);

        outMathNode = terminalNode;
      } else {
        const innerOnionNode = random_onion_mathNode(depth - 1, isWithExplicitationParentheses);

        const layerTerminalNode = random_terminal_mathNode_withType_inArr(["ConstantNode"]);

        const layerNode = random_operatorNode([innerOnionNode, layerTerminalNode]);
        console.log("layerNode", layerNode);

        outMathNode = layerNode;

        if (isWithExplicitationParentheses) {
          if (innerOnionNode.type == "OperatorNode") {
            console.log("innerOnionNode", innerOnionNode);

            const opFuncName__innerOnionNode = innerOnionNode.fn;
            const opFuncName__layerNode = layerNode.fn;

            const precedence__innerOnionNode = precedenceDict[opFuncName__innerOnionNode];
            const precedence__layerNode = precedenceDict[opFuncName__layerNode];

            const isSamePrecedence = (precedence__innerOnionNode == precedence__layerNode);

            if (isSamePrecedence) {
              var enveloppedInnerOnionNode;
              if (innerOnionNode.type == "ParenthesisNode") {    //already envelopped
                enveloppedInnerOnionNode = innerOnionNode;
              } else {
                enveloppedInnerOnionNode = new math.ParenthesisNode(innerOnionNode);
              }

              const layerNode_explicit = new math.OperatorNode(layerNode.op, layerNode.fn, [enveloppedInnerOnionNode, layerTerminalNode]);

              outMathNode = layerNode_explicit;
            }

          }

        }

      }

      return outMathNode;
    }

    // //debug
    // {
    //   const debugNode = random_mathNode_withDepth_and_nbSymbols(4, 2);
    //   console.log("debugNode(4,2)", debugNode);
    //   console.log("getDepth(debugNode)", getDepth(debugNode));
    // }





    function random_operatorNode_consumePool(pool) {

    }





    /*UTILS*/

    function getDepth(mathNode) {
      var outInt;

      switch (mathNode.type) {
        case "OperatorNode":
          {
            const arr_child_node = mathNode.args;
            const arr_child_node_depth = arr_child_node.map(node => getDepth(node));
            const max_child_depth = Math.max(...arr_child_node_depth);
            outInt = 1 + max_child_depth;
          }
          break;
        default:
          outInt = 1;
          break;
      }

      console.log("outInt", outInt);
      return outInt;
    }

    function getArr_all_leaves__node(mathNode) {
      var outArray;

      switch (mathNode.type) {
        case "OperatorNode":
          {
            const depth = getDepth(mathNode);
            if (depth == 2) {
              const arr_child = mathNode.args;
              outArray = arr_child;
            } else {
              outArray = mathNode.args.reduce((acc, child) => {
                const arr_grandChild = child.args;

                var arr_grandChild_sorted_by_decreasing_depth = arr_grandChild.slice();
                arr_grandChild_sorted_by_decreasing_depth.sort(function (a, b) {
                  const depth_a = getDepth(a);
                  const depth_b = getDepth(b);

                  if (depth_a > depth_b) {
                    return 1;
                  }
                  if (depth_a < depth_b) {
                    return -1;
                  }
                  return 0;
                });

                arr_grandChild_sorted_by_decreasing_depth.forEach((grandChild, i) => {
                  const arr_sub = getArr_all_leaves__node(grandChild);
                  console.log("arr_sub", arr_sub);
                  acc.push(...arr_sub);
                });

                return acc;

              }, []);
            }
          }
          break;
        default:
          outArray = [mathNode];
          break;
      }

      return outArray;
    }

    function getArr_all_leaves__treeObj(mathNode, parentPath = []) {
      var outArray;

      switch (mathNode.type) {
        case "OperatorNode":
          {
            const depth = getDepth(mathNode);
            if (depth == 2) {
              const arr_child = mathNode.args;
              outArray = arr_child.map((child, childIndex) => {
                const treeObj = {
                  node: child,
                  path: parentPath.concat([childIndex]),
                };
                return treeObj;
              });
            } else {
              outArray = mathNode.args.reduce((acc, child, childIndex) => {
                const arr_grandChild = child.args;

                var arr_grandChild_sorted_by_decreasing_depth = arr_grandChild.slice();
                arr_grandChild_sorted_by_decreasing_depth.sort(function (a, b) {
                  const depth_a = getDepth(a);
                  const depth_b = getDepth(b);

                  if (depth_a > depth_b) {
                    return 1;
                  }
                  if (depth_a < depth_b) {
                    return -1;
                  }
                  return 0;
                });

                arr_grandChild_sorted_by_decreasing_depth.forEach((grandChild, grandChildIndex) => {
                  const path = parentPath.concat([childIndex, grandChildIndex]);
                  const arr_sub = getArr_all_leaves__treeObj(grandChild, path);
                  console.log("arr_sub", arr_sub);
                  acc.push(...arr_sub);
                });

                return acc;

              }, []);
            }
          }
          break;
        default:
          const treeObj = {
            node: mathNode,
            path: parentPath/*.concat([0])*/,
          };
          outArray = [treeObj];
          break;
      }

      return outArray;
    }

    function getArr_all_nodes_at_depth(mathNode, depth) {
      var outArray;

      if (depth < 1) {
        throw new Error("depth must be > 1");
      } else if (depth == 1) {
        outArray = [mathNode];
      } else {
        const arr_child = mathNode.args;

        outArray = arr_child.reduce((acc, child) => {
          const arr_nodes__one_deeper = getArr_all_nodes_at_depth(child, depth - 1);

          acc.push(...arr_nodes__one_deeper);

          return acc;
        }, []);
      }

      return outArray;
    }

    function getArr_deep_first__treeObj(mathNode, parentPath = []) {
      var outArray;

      const depth = getDepth(mathNode);
      const arr_depth__increasing = [...new Array(depth).keys()].map(i => i + 1);
      const arr_depth__decreasing = arr_depth__increasing.slice().reverse();

      outArray = arr_depth__decreasing.reduce((acc, depth) => {

        const arr_all_treeObj_at_depth = getArr_all_treeObj_at_depth(mathNode, depth, parentPath);
        acc.push(...arr_all_treeObj_at_depth);

        return acc;
      }, []);

      return outArray;
    }

    function getArr_all_treeObj_at_depth(mathNode, depth, parentPath = []) {
      var outArray;

      if (depth < 1) {
        throw new Error("depth must be > 1");
      } else if (depth == 1) {
        const treeObj = {
          node: mathNode,
          path: parentPath,
        };
        outArray = [treeObj];
      } else {
        var arr_child = mathNode.args;

        if (arr_child == null) {
          arr_child = [];
        }

        outArray = arr_child.reduce((acc, child, childIndex) => {
          const child_path = parentPath.concat(childIndex);
          const arr_treeObj__one_deeper = getArr_all_treeObj_at_depth(child, depth - 1, child_path);

          acc.push(...arr_treeObj__one_deeper);

          return acc;
        }, []);

      }

      return outArray;
    }


    function getArr_deep_first__treeObj(mathNode, parentPath = []) {
      var outArray;

      const depth = getDepth(mathNode);
      const arr_depth__increasing = [...new Array(depth).keys()].map(i => i + 1);
      const arr_depth__decreasing = arr_depth__increasing.slice().reverse();

      outArray = arr_depth__decreasing.reduce((acc, depth) => {

        const arr_all_treeObj_at_depth = getArr_all_treeObj_at_depth(mathNode, depth);
        acc.push(...arr_all_treeObj_at_depth);

        return acc;
      }, []);

      return outArray;
    }





    function operatorNodeBySettingNodeAtPath(operatorNode_in, node_l, path) {
      var outOperatorNode;

      const operatorNode_cloned = operatorNode_in.clone();
      // const operatorNode_cloned = operatorNode_in.cloneDeep();

      //get target inner parentNode
      const path__all_but_last = path.slice(0, -1);
      const targetParentNode = path__all_but_last.reduce((acc, x) => {
        return acc.args[x];
      }, operatorNode_cloned);

      //mutate target inner parentNode
      const path__last = path[path.length - 1];
      targetParentNode.args[path__last] = node_l;

      outOperatorNode = operatorNode_cloned;

      return outOperatorNode;
    }

      // //debug
      // {
      //   const debugNode = random_mathNode_withDepth_and_nbSymbols(4, 2);
      //   console.log("debugNode(4,2)", debugNode);
      //   console.log("getDepth(debugNode)", getDepth(debugNode));
      //   console.log("getArr_all_leaves__node(debugNode)", getArr_all_leaves__node(debugNode));
      // }

  </script>
  <script>
    /*
    class InverseNode extends math.Node {   //ClassicInverseNode
      constructor(node_in) {

      }
    }
    math.InverseNode = InverseNode;                 //SHU: pas obligé mais pourquoi pas
    */

    class Inverser {
      static inverse(mathNode) {
        var outMathNode;

        switch (mathNode.type) {
          case "ConstantNode":
          case "SymbolNode":
            {
              const mathNode_ONE = new math.ConstantNode(1);
              const mathNode_clone = mathNode.cloneDeep();
              outMathNode = new math.OperatorNode("/", "divide", [mathNode_ONE, mathNode_clone]);
            }
            break;

          case "OperatorNode":
            {
              const operatorNode = mathNode;
              switch (operatorNode.fn) {
                case "divide":
                  {
                    const mathNode_firstArg = operatorNode.args[0];
                    if (mathNode_firstArg.type == "ConstantNode" && mathNode_firstArg.value == 1) {
                      //'simplification'
                      const mathNode_secondArg_clone = operatorNode.args[1].cloneDeep();
                      outMathNode = mathNode_secondArg_clone;
                    } else {
                      const mathNode_clone = mathNode.cloneDeep();
                      mathNode_clone.args = mathNode_clone.args.slice().reverse();
                      outMathNode = mathNode_clone;
                    }
                  }
                  break;
                default:
                  {
                    const mathNode_ONE = new math.ConstantNode(1);
                    const mathNode_clone = mathNode.cloneDeep();
                    outMathNode = new math.OperatorNode("/", "divide", [mathNode_ONE, mathNode_clone]);
                  }
                  break;
              }
            }
            break;
          case "ParenthesisNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;


          //maybe one day
          case "BlockNode":
          case "ObjectNode":
          case "ConditionalNode":
          case "FunctionNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;

          case "ArrayNode":
          case "AssignmentNode":
          case "FunctionAssignmentNode":
          case "RelationalNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;

          default:
            throw new Error("unsupported type: " + mathNode.type);
            break;
        }

        return outMathNode;
      }


      static opposite(mathNode) {
        var outMathNode;

        switch (mathNode.type) {
          case "ConstantNode":
          case "SymbolNode":
            {
              const mathNode_ZERO = new math.ConstantNode(0);
              const mathNode_clone = mathNode.cloneDeep();
              outMathNode = new math.OperatorNode("-", "subtract", [mathNode_ZERO, mathNode_clone]);
            }
            break;

          case "OperatorNode":
            {
              const operatorNode = mathNode;
              switch (operatorNode.fn) {
                case "subtract":
                  {
                    const mathNode_firstArg = operatorNode.args[0];
                    if (mathNode_firstArg.type == "ConstantNode" && mathNode_firstArg.value == 0) {
                      //'simplification'
                      const mathNode_secondArg_clone = operatorNode.args[1].cloneDeep();
                      outMathNode = mathNode_secondArg_clone;
                    } else {
                      const mathNode_clone = mathNode.cloneDeep();
                      mathNode_clone.args = mathNode_clone.args.slice().reverse();
                      outMathNode = mathNode_clone;
                    }
                  }
                  break;
                default:
                  {
                    const mathNode_ZERO = new math.ConstantNode(0);
                    const mathNode_clone = mathNode.cloneDeep();
                    outMathNode = new math.OperatorNode("-", "subtract", [mathNode_ZERO, mathNode_clone]);
                  }
                  break;
              }
            }
            break;
          case "ParenthesisNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;


          //maybe one day
          case "BlockNode":
          case "ObjectNode":
          case "ConditionalNode":
          case "FunctionNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;

          case "ArrayNode":
          case "AssignmentNode":
          case "FunctionAssignmentNode":
          case "RelationalNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;

          default:
            throw new Error("unsupported type: " + mathNode.type);
            break;
        }

        return outMathNode;
      }

    }

    /*
    class GeneralInverseOperatorDuo extends math.OperatorNode {
      constructor(, )
    }
    math.GeneralInverseNode = GeneralInverseNode;


    class GeneralInverseNode extends math.OperatorNode {
      constructor(operatorDuo, node) {

      }
    }
    math.GeneralInverseNode = GeneralInverseNode;
    */


    class Simplifier {

      constructor() {

      }

      static simplify_top_layer(node_in) {
        var outNode;

        if (node_in.type == "OperatorNode") {

          const depth = getDepth(node_in);

          if (depth > 2) {
            console.log("___st A");

            //'outermost first' simplify

            const operator__layerN = node_in;
            const arr_child__layerN = operator__layerN.args;
            var terminal__layerN = arr_child__layerN.filter(child => Simplifier.isTerminalType(child)).find(e => true);
            terminal__layerN = Simplifier.getTerminalMathNode(terminal__layerN);

            const operator__layerN_minus_1 = arr_child__layerN.filter(child => (child.type == "OperatorNode")).find(e => true);
            const arr_child__layerN_minus_1 = operator__layerN_minus_1.args;
            // const terminal__layerN_minus_1      = arr_child__layerN_minus_1.filter(child => isTerminalType(child)).find(e => true);
            var arr_terminal__layerN_minus_1 = arr_child__layerN_minus_1.filter(child => Simplifier.isTerminalType(child));
            arr_terminal__layerN_minus_1 = arr_terminal__layerN_minus_1.map(mathNode => Simplifier.getTerminalMathNode(mathNode));

            const sameTerminal = arr_terminal__layerN_minus_1.find(term__layerN_minus_1 => Simplifier.isSameTerminal(terminal__layerN, term__layerN_minus_1));
            if (!sameTerminal) {
              return node_in;
            }

            const isInverseOperators_ = Simplifier.isInverseOperators(operator__layerN_minus_1, operator__layerN);
            console.log("isInverseOperators_", isInverseOperators_);
            if (!isInverseOperators_) {
              return node_in;
            }

            const node__layerN_minus_2 = arr_child__layerN_minus_1.filter(child => child != sameTerminal).find(e => true);

            //remove parentheses if any
            // if(node__layerN_minus_2.type == "ParenthesisNode") {
            //   const contentNode = node__layerN_minus_2.content;
            //   outNode = contentNode;
            // } else {
            //   outNode = node__layerN_minus_2;
            // }

            outNode = node__layerN_minus_2;

          } else {
            console.log("___st B");

            //simple simplify

            const node_unsimplified = node_in;

            const node_simplified = math.simplify(node_unsimplified);
            node_simplified.isSimplified = true;

            outNode = node_simplified;

          }

        } else {
          console.log("___st C");
          logger.log("node_in", node_in);

          //simple simplify

          const node_unsimplified = node_in;

          const node_simplified = math.simplify(node_unsimplified);   //SHU: boom
          node_simplified.isSimplified = true;

          outNode = node_simplified;

        }

        outNode.autoSimplify = node_in.autoSimplify;

        return outNode;
      }

      static isOne(mathNode) {
        return Simplifier.isOne_strict(mathNode) || Simplifier.isOne_wide(mathNode);
      }

      static isOne_strict(mathNode) {
        return (mathNode.type == "ConstantNode") && (mathNode.value == 1);
      }

      static isOne_wide(mathNode) {
        // return (mathNode.type == "ConstantNode") && (mathNode.value == 1);
        return false;
      }

      static isZero_strict(mathNode) {
        return (mathNode.type == "ConstantNode") && (mathNode.value == 0);
      }

      static simplify_singleOperatorize_topPriorityShell(mathNode) {
        var outMathNode;

        logger.log("simplify_singleOperatorize_topPriorityShell", mathNode);

        switch (mathNode.type) {
          case "OperatorNode":
            {
              const operatorNode = mathNode;

              // if(operatorFn == "multiply") {
              switch (operatorNode.fn) {
                case "multiply":
                  {
                    //1. transform children
                    const arr_child = operatorNode.args.map(mathNode_child => Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_child));

                    //2. merge (~aggregate, ~flatten)
                    const arr_child2 = arr_child.reduce((acc, x) => {

                      switch (x.type) {
                        case "OperatorNode":
                          {
                            switch (x.fn) {
                              case "multiply":
                                {
                                  acc.push(...x.args);
                                }
                                break;
                              default:
                                acc.push(x);
                                break;
                            }
                          }
                          break;
                        default:
                          acc.push(x);
                          break;
                      }

                      return acc;
                    }, []);

                    //3. filter out ONEs
                    const arr_child3 = arr_child2.filter(mathNode => {
                      const isOne = Simplifier.isOne(mathNode);
                      return !isOne;
                    });

                    if (arr_child3.length > 1) {
                      outMathNode = new math.OperatorNode("x", "multiply", arr_child3);
                    } else {
                      outMathNode = arr_child2.find(e => true);
                    }

                  }
                  break;
                case "divide":
                  {
                    // const mathNode_firstArg = operatorNode.args[0];
                    // if(mathNode_firstArg.type == "ConstantNode" && mathNode_firstArg.value == 1) {
                    //   //'simplification'
                    //   const mathNode_secondArg_clone = operatorNode.args[1].cloneDeep();
                    //   outMathNode = mathNode_secondArg_clone;
                    // } else {
                    //   const mathNode_clone = mathNode.cloneDeep();
                    //   mathNode_clone.args = mathNode_clone.args.slice().reverse();
                    //   outMathNode = mathNode_clone;
                    // }


                    //1. transform children
                    //transform numerator   (left side)
                    const mathNode_numerator = operatorNode.args[0];
                    const mathNode_numerator_transformed = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_numerator);
                    //transform denominator (right side)
                    const mathNode_denominator = operatorNode.args[1];
                    const mathNode_denominator_transformed = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_denominator);

                    //2.transform into multiplication
                    var arr_mathNode_denominator;
                    switch (mathNode_denominator_transformed.type) {
                      case "OperatorNode":
                        {
                          const operatorNode = mathNode_denominator_transformed;
                          switch (operatorNode.fn) {
                            case "multiply":
                              {
                                arr_mathNode_denominator = operatorNode.args;
                              }
                              break;
                            default:
                              {
                                arr_mathNode_denominator = [mathNode_denominator_transformed];
                              }
                              break;
                          }
                        }
                        break;
                      default:
                        {
                          arr_mathNode_denominator = [mathNode_denominator_transformed];
                        }
                        break;
                    }

                    const arr_factor = [mathNode_numerator_transformed, ...arr_mathNode_denominator.map(Inverser.inverse)];

                    outMathNode = new math.OperatorNode("x", "multiply", arr_factor);

                  }
                  break;

                case "add":
                  {
                    //1. transform children
                    const arr_child = operatorNode.args.map(mathNode_child => Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_child));

                    //2. merge (~aggregate, ~flatten)
                    const arr_child2 = arr_child.reduce((acc, x) => {

                      switch (x.type) {
                        case "OperatorNode":
                          {
                            switch (x.fn) {
                              case "add":
                                {
                                  acc.push(...x.args);
                                }
                                break;
                              default:
                                acc.push(x);
                                break;
                            }
                          }
                          break;
                        default:
                          acc.push(x);
                          break;
                      }

                      return acc;
                    }, []);

                    //3. filter out ZEROs
                    const arr_child3 = arr_child2.filter(mathNode => {
                      const isZero = Simplifier.isZero_strict(mathNode);
                      return !isZero;
                    });

                    if (arr_child3.length > 1) {
                      outMathNode = new math.OperatorNode("+", "add", arr_child3);
                    } else {
                      outMathNode = arr_child2.find(e => true);
                    }
                  }
                  break;

                case "subtract":
                  {
                    //1. transform children
                    const [mathNode_diminuend, ...arr_mathNode_diminutor] = operatorNode.args;
                    //transform diminuend (left side)
                    const mathNode_diminuend_transformed = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_diminuend);
                    //transform diminutor (right side)
                    const arr_mathNode_diminutor_transformed = arr_mathNode_diminutor.map((mathNode_diminutor) => {
                      return Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_diminutor);
                    });
                    
                    //2.transform into addition
                    const arr_actor = [mathNode_diminuend_transformed, ...arr_mathNode_diminutor_transformed.map(Inverser.opposite)];

                    outMathNode = new math.OperatorNode("+", "add", arr_actor);
                  }
                  break;

                default:
                  outMathNode = mathNode;
                  break;
              }
              // } else {
              //   throw new Error("unsupported operatorFn: " + operatorFn);
              // }

            }
            break;
          case "ParenthesisNode":
            {
              const parenthesisNode = mathNode;
              //check content
              const mathNode__content = parenthesisNode.content;
              outMathNode = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode__content);
            }
            break;
          default:
            outMathNode = mathNode;
            break;
        }

        return outMathNode;
      }


      static isConstant(mathNode) {
        return (mathNode.type == "ConstantNode");
      }

      static isConstantOrInverse(mathNode) {
        return Simplifier.isConstant(mathNode) || Simplifier.isInverse(mathNode);
      }

      static isInverse(mathNode) {
        var outBool;

        const isDivide = (mathNode.type == "OperatorNode") && (mathNode.fn == "divide");
        if (isDivide) {
          const mathNode_numerator = mathNode.args[0];
          const isNumeratorOne = Simplifier.isOne_strict(mathNode_numerator);

          const mathNode_denominator = mathNode.args[1];
          const isDenominatorConstant = Simplifier.isConstant(mathNode_denominator);

          outBool = isNumeratorOne && isDenominatorConstant;
        } else {
          outBool = false;
        }

        return outBool;
      }

      static isConstantOrOpposite(mathNode) {
        return Simplifier.isConstant(mathNode) || Simplifier.isOpposite(mathNode);
      }

      static isOpposite(mathNode) {
        var outBool;

        const isSubtract = (mathNode.type == "OperatorNode") && (mathNode.fn == "subtract");
        if (isSubtract) {
          const mathNode_diminuend = mathNode.args[0];
          const isDiminuendZero = Simplifier.isZero_strict(mathNode_diminuend);

          const mathNode_diminutor = mathNode.args[1];
          const isDiminutorConstant = Simplifier.isConstant(mathNode_diminutor);

          outBool = isDiminuendZero && isDiminutorConstant;
        } else {
          outBool = false;
        }

        return outBool;
      }


      static simplify_top_priorityShell(node_in) {
        var outNode;

        logger.log("simplify_top_priorityShell", node_in);

        const mathNode = node_in;

        //1. singleOperatorize
        const node_singleOperatorized = Simplifier.simplify_singleOperatorize_topPriorityShell(node_in);
        logger.log("node_singleOperatorized", node_singleOperatorized);

        switch (node_singleOperatorized.type) {
          case "OperatorNode":
            {
              // const depth = getDepth(node_w);
              // if(depth > 2) {

              switch (node_singleOperatorized.fn) {
                case "multiply":
                  {

                    //2. look for inverse matches : count plus and minus
                    const arr_mathNode_factor_all = node_singleOperatorized.args;
                    logger.log("arr_mathNode_factor_all", arr_mathNode_factor_all);

                    if (arr_mathNode_factor_all == null) {     //SHU: the downfall
                      return mathNode;
                    }
                    if (arr_mathNode_factor_all.length < 2) {
                      return mathNode;
                    }

                    const obj_factors = arr_mathNode_factor_all.reduce((acc, mathNode_factor, index) => {

                      var value;
                      var multiplicity;

                      const isConstantOrInverse = Simplifier.isConstantOrInverse(mathNode_factor);
                      if (isConstantOrInverse) {

                        const isInverse = (mathNode_factor.type == "OperatorNode") && (mathNode_factor.fn == "divide");
                        if (isInverse) {
                          const mathNode_inverse = mathNode_factor;
                          const mathNode_denominator = mathNode_inverse.args[1];
                          const mathNode_averse = mathNode_denominator;
                          value = mathNode_averse.value;
                          multiplicity = -1;
                        } else {
                          const mathNode_averse = mathNode_factor;
                          value = mathNode_averse.value;
                          multiplicity = +1;
                        }

                        const valueStr = "" + value;

                        if (acc.portion_valued[valueStr] == null) {
                          acc.portion_valued[valueStr] = 0;
                        }

                        acc.portion_valued[valueStr] += multiplicity;

                      } else {
                        acc.portion_indexed[index] = mathNode_factor;
                      }

                      return acc;
                    }, {
                      portion_valued: {},
                      portion_indexed: {},
                    });
                    logger.log("obj_factors", obj_factors);   //SHU: acc[value] stringifies value

                    const arr_mathNode_factor_simplified = Object.entries(obj_factors.portion_valued)
                      .filter(([valueStr, multiplicity]) => multiplicity != 0)
                      .map(([valueStr, multiplicity]) => {
                        var outArr;

                        logger.log("valueStr, multiplicity", valueStr, multiplicity);

                        const value = Number(valueStr);

                        const multiplicity_abs = math.abs(multiplicity);

                        if (multiplicity > 0) {
                          outArr = [...Array(multiplicity_abs).keys()].map(index => {
                            const mathNode_averse = new math.ConstantNode(value);
                            return mathNode_averse;
                          });
                        } else {
                          outArr = [...Array(multiplicity_abs).keys()].map(index => {
                            const mathNode_averse = new math.ConstantNode(value);
                            const mathNode_inverse = Inverser.inverse(mathNode_averse);
                            return mathNode_inverse;
                          });
                        }

                        return outArr;
                      })
                      .flat();
                    logger.log("arr_mathNode_factor_simplified", arr_mathNode_factor_simplified);


                    const arr_mathNode_factor_simplified_merged = [...arr_mathNode_factor_simplified, ...Object.values(obj_factors.portion_indexed)];
                    logger.log("arr_mathNode_factor_simplified_merged", arr_mathNode_factor_simplified_merged);


                    const nb_factors = arr_mathNode_factor_simplified_merged.length;
                    if (nb_factors == 0) {
                      outNode = new math.ConstantNode(1);
                    } else if (nb_factors == 1) {
                      const mathNode_a = arr_mathNode_factor_simplified_merged.find(e => true);
                      outNode = mathNode_a;
                    } else {
                      outNode = new math.OperatorNode("x", "multiply", arr_mathNode_factor_simplified_merged);
                    }

                  }
                  break;

                case "add":
                  {

                    //2. look for inverse matches : count plus and minus
                    const arr_mathNode_actor_all = node_singleOperatorized.args;
                    logger.log("arr_mathNode_actor_all", arr_mathNode_actor_all);

                    if (arr_mathNode_actor_all == null) {
                      return mathNode;
                    }
                    if (arr_mathNode_actor_all.length < 2) {
                      return mathNode;
                    }

                    const obj_actors = arr_mathNode_actor_all.reduce((acc, mathNode_actor, index) => {

                      var value;
                      var multiplicity;

                      const isConstantOrOpposite = Simplifier.isConstantOrOpposite(mathNode_actor);
                      if (isConstantOrOpposite) {

                        const isOpposite = (mathNode_actor.type == "OperatorNode") && (mathNode_actor.fn == "subtract");
                        if (isOpposite) {
                          const mathNode_opposite = mathNode_actor;
                          const mathNode_diminutor = mathNode_opposite.args[1];
                          const mathNode_averse = mathNode_diminutor;
                          value = mathNode_averse.value;
                          multiplicity = -1;
                        } else {
                          const mathNode_averse = mathNode_actor;
                          value = mathNode_averse.value;
                          multiplicity = +1;
                        }

                        const valueStr = "" + value;

                        if (acc.portion_valued[valueStr] == null) {
                          acc.portion_valued[valueStr] = 0;
                        }

                        acc.portion_valued[valueStr] += multiplicity;

                      } else {
                        acc.portion_indexed[index] = mathNode_actor;
                      }

                      return acc;
                    }, {
                      portion_valued: {},
                      portion_indexed: {},
                    });
                    logger.log("obj_actors", obj_actors);   //SHU: acc[value] stringifies value

                    const arr_mathNode_actor_simplified = Object.entries(obj_actors.portion_valued)
                      .filter(([valueStr, multiplicity]) => multiplicity != 0)
                      .map(([valueStr, multiplicity]) => {
                        var outArr;

                        logger.log("valueStr, multiplicity", valueStr, multiplicity);

                        const value = Number(valueStr);

                        const multiplicity_abs = math.abs(multiplicity);

                        if (multiplicity > 0) {
                          outArr = [...Array(multiplicity_abs).keys()].map(index => {
                            const mathNode_averse = new math.ConstantNode(value);
                            return mathNode_averse;
                          });
                        } else {
                          outArr = [...Array(multiplicity_abs).keys()].map(index => {
                            const mathNode_averse = new math.ConstantNode(value);
                            const mathNode_opposite = Inverser.opposite(mathNode_averse);
                            return mathNode_opposite;
                          });
                        }

                        return outArr;
                      })
                      .flat();
                    logger.log("arr_mathNode_actor_simplified", arr_mathNode_actor_simplified);


                    const arr_mathNode_actor_simplified_merged = [...arr_mathNode_actor_simplified, ...Object.values(obj_actors.portion_indexed)];
                    logger.log("arr_mathNode_actor_simplified_merged", arr_mathNode_actor_simplified_merged);


                    const nb_actors = arr_mathNode_actor_simplified_merged.length;
                    if (nb_actors == 0) {
                      outNode = new math.ConstantNode(0);
                    } else if (nb_actors == 1) {
                      const mathNode_a = arr_mathNode_actor_simplified_merged.find(e => true);
                      outNode = mathNode_a;
                    } else {
                      outNode = new math.OperatorNode("+", "add", arr_mathNode_actor_simplified_merged);
                    }

                  }
                  break;

                default:
                  outNode = node_singleOperatorized;
                  break;

                // } else {
                //   // throw new Error("depth <= 2");
                //   outNode = node_singleOperatorized;
                // }
              }

            }
            break;
          case "ParenthesisNode":
            {
              const parenthesisNode = mathNode;
              const contentNode = parenthesisNode.content;
              outNode = Simplifier.simplify_top_priorityShell(contentNode);
            }
            break;
          default:
            outNode = mathNode;
            break;
        }

        outNode.autoSimplify = node_in.autoSimplify;

        return outNode;
      }

      static simplify_fraction_into_product(mathNode_fraction) {
        var outMathNode;

        outMathNode = Rewriter.decomposition_product_primes(mathNode_fraction);
        outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);

        return outMathNode;
      }

      static simplify_fraction(mathNode_fraction) {
        var outMathNode;

        // outMathNode = Rewriter.decomposition_product_primes(mathNode_fraction);
        // outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);
        // outMathNode = math.simplify(outMathNode);

        //SHU: ou plus simplement ---___---
        outMathNode = math.simplify(mathNode_fraction);

        return outMathNode;
      }

      static simplify_litexp(mathNode_litexp) {
        var outMathNode;

        outMathNode = mathNode_litexp;

        // outMathNode = Rewriter.decomposition_product_primes_and_symbols(outMathNode);
        // outMathNode = Simplifier.simplify_fraction(outMathNode);
        // outMathNode = Simplifier.simplify_singleOperatorize_topPriorityShell(outMathNode);

        var isSimplifiedFully = false;
        while (!isSimplifiedFully) {
          const mathNode__prev = outMathNode;
          outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);
          const mathNode__new = outMathNode;
          const str__prev = mathNode__prev.toString();
          const str__new = mathNode__new.toString();
          isSimplifiedFully = (str__prev == str__new);
        }

        outMathNode = Rewriter.removeUnnecessaryOnesInLitexp(outMathNode);
        outMathNode = math.simplify(outMathNode);

        return outMathNode;
      }

      static simplify_litexp_2(mathNode_litexp) {
        logger.log("logSimplify", "simplify_litexp_2", "mathNode_litexp:", mathNode_litexp);
        
        var str__raw = mathNode_litexp.toString();
        str__raw = str__raw.replaceAll("×", "*");
        str__raw = str__raw.replaceAll("+ -", "-");

        // str__raw = str__raw.replaceAll(".", "*");

        logger.log("logSimplify", "simplify_litexp_2", "str__raw:", str__raw);

        const str__simplified = Algebrite.run(str__raw);
        logger.log("logSimplify", "simplify_litexp_2", "str__simplified:", str__simplified);

        const mathNode__parsed = math.parse(str__simplified);
        logger.log("logSimplify", "simplify_litexp_2", "mathNode__parsed:", mathNode__parsed);

        return mathNode__parsed;
      }

      static simplify_litexp_3(mathNode_litexp) {
          var str__raw = mathNode_litexp.toString();
          str__raw = str__raw.replaceAll("×", "*");

          const str__simplified = Algebrite.run(str__raw);
          logger.log("str__simplified", str__simplified);

          //remove "..." at end of string
          const str__prepared = str__simplified.replace("...", "");

          const mathNode = math.parse(str__prepared);
          return mathNode;
        }

      static simplify_equation(mathNode_equation) {
        var outMathNode;

        logger.log("math.simplify.rules", math.simplify.rules);
        logger.log("math.simplify.rules[0].toString()", math.simplify.rules[0].toString());
        logger.log("math.simplify.rules[16].toString()", math.simplify.rules[16].toString());

        function simplify_child(mathNode_child) {
          return Simplifier.simplify_litexp(mathNode_child);
        }

        outMathNode = mathNode_equation.clone();
        outMathNode.params = outMathNode.params.map((mathNode_child, i) => {
          return simplify_child(mathNode_child);
        });

        return outMathNode;
      }


      static simplify_full(mathNode) { //SHU: TODO
        var outMathNode;

        //1. transform was is likely to be a binary tree into a nary tree with [+] and [x] as nary operators and [opposite] and [inverse] as unary operators (([0 -] and [1 /]))

        //2. simplify (== look for opposite matches) from bottom to top, as much as needed

        throw new Error("Not implemented yet");
        return outMathNode;
      }

      static isTerminalType(mathNode) {
        var outBool;

        const type = mathNode.type;

        switch (type) {
          case "ConstantNode":
          case "SymbolNode":
            outBool = true;
            break;
          case "ParenthesisNode":
            {
              //check content
              const mathNode__content = mathNode.content;
              outBool = this.isTerminalType(mathNode__content);
            }
            break;
          default:
            outBool = false;
            break;
        }

        return outBool;
      }

      static getTerminalMathNode(mathNode) {
        var outMathNode;

        const type = mathNode.type;

        switch (type) {
          case "ConstantNode":
          case "SymbolNode":
            outMathNode = mathNode;
            break;
          case "ParenthesisNode":
            {
              //check content
              const mathNode__content = mathNode.content;
              outMathNode = this.getTerminalMathNode(mathNode__content);
            }
            break;
          default:
            // outMathNode = null;
            throw new Error("no terminal node to fetch");
            break;
        }

        return outMathNode;
      }

      static isSameTerminal(termNode1, termNode2) {
        var outBool;

        function isSameTerminalType(termNode1, termNode2) {
          return (termNode1.type == termNode2.type);
        }

        const isSameTerminalType_ = isSameTerminalType(termNode1, termNode2);
        console.log("isSameTerminalType_", isSameTerminalType_);

        if (!isSameTerminalType_) {
          return false;                 //j'aime pas trop ça mais bon...
        }

        function isSameTerminalContent(termNode1, termNode2) {
          console.log("isSameTerminal", termNode1, termNode2);
          var outBool;

          switch (termNode1.type) {
            case "SymbolNode":
              outBool = (termNode1.name == termNode2.name);
              break;
            case "ConstantNode":
              outBool = (termNode1.value == termNode2.value);
              break;
            default:
              throw new Error("unsupported type", termNode1.type);
              break;
          }

          return outBool;
        }

        outBool = isSameTerminalContent(termNode1, termNode2);

        return outBool;
      }

      static isInverseOperators(opNode1, opNode2) {
        console.log("isInverseOperators", opNode1, opNode2);
        var outBool;

        const set_opFunc = new Set([opNode1.fn, opNode2.fn]);
        console.log("set_opFunc", set_opFunc);

        /*Set utils*/
        function eqSet(as, bs) {
          return as.size === bs.size && all(isIn(bs), as);
        }

        function all(pred, as) {
          for (var a of as) if (!pred(a)) return false;
          return true;
        }

        function isIn(as) {
          return function (a) {
            return as.has(a);
          };
        }
        /**/



        const arr_set_inverse = [
          new Set(["multiply", "divide"]),
          new Set(["add", "subtract"]),
        ];

        outBool = arr_set_inverse.reduce((acc, x) => {
          if (eqSet(set_opFunc, x)) {
            acc = true;
          }
          return acc;
        }, false);

        return outBool;
      }


      static simplify_level1(mathNode) {
        var outMathNode;

        //0. check if candidate (== legitimate operand)
        switch (mathNode) {
          case "OperatorNode":
            break;
          case "ParenthesisNode":
            const mathNode__content = mathNode.content;
            const mathNode__result = Simplifier.simplify_level1(mathNode__content);
            const mathNode__paren = mathNode.clone();
            mathNode__paren.content = mathNode__result;
            return mathNode__paren;
          default:
            //ignore
            return mathNode;        //SHU: un return dans un switch ! hahaha
        }

        const operatorNode = mathNode;

        //1. get level1 node(s) with lower depth
        const dict_arrForDepth = operatorNode.args.reduce((acc, mathNode_child) => {
          const depth = getDepth(mathNode_child);
          if (acc[depth] == null) {
            acc[depth] = [];
          }
          acc[depth].push(mathNode_child);
          return acc;
        }, {});

        //temporarily: work only with depth 1
        const arr_depth1 = dict_arrForDepth[1];
        if (arr_depth1 == null) {
          return mathNode;
        }

        //2. try to find inverse wrt mathNode fn
        const mathNode_slasher = null;
        const mathNode_victim = null;

        return outMathNode;
      }

      static simplify_level1_recursively(mathNode) {
        var outMathNode;



        return outMathNode;
      }

    }





  </script>
  <script>
    class Rewriter {

      constructor() {

      }

      static decomposition_product_primes(mathNode) {
        var outNode;

        switch (mathNode.type) {
          case "ConstantNode":
            const value = mathNode.value;
            const arr_values = MathUtils.primeFactorization(value);

            // const joinreduce = function(joinFunc, )
            const value_first = arr_values[0];
            const arr_butfirst = arr_values.slice(1);
            const mathNode_initial = new math.ConstantNode(value_first);
            outNode = arr_butfirst.reduce((acc, x) => {
              const mathNode_arg2 = new math.ConstantNode(x);
              return new math.OperatorNode("×lol×", "multiply", [acc, mathNode_arg2]);
            }, mathNode_initial);

            break;
          case "OperatorNode":
            const operatorNode = mathNode;
            logger.log("operatorNode", operatorNode);
            // switch(operatorNode.op) {
            //   case "/":
            //   break;
            // }
            outNode = new math.OperatorNode(operatorNode.op, operatorNode.fn, operatorNode.args.map(Rewriter.decomposition_product_primes));
            break;
          default:
            throw new Error("unsupported type: " + mathNode.type);
            break;
        }

        return outNode;
      }


      static decomposition_product_primes__vpadiq(mathNode) {
          var outNode;

          switch(mathNode.type) {
            case "ConstantNode":
              const value = mathNode.value;

              const dict_decomp = MathUtils.primeFactorizationDict(value);
              const arr_entry   = Object.entries(dict_decomp);

              const entry_first      = arr_entry[0];

              const number_first     = Number(entry_first[0]);
              const exponent_first   = entry_first[1];
              const mathNode_first   = mathNodeForNumberAtPositiveExponent(number_first, exponent_first);

              const arr_butfirst     = arr_entry.slice(1);

              function mathNodeForNumberAtPositiveExponent(number, exponent) {
                var outMathNode;

                switch(exponent) {
                  case 0:
                    outMathNode = new math.ConstantNode(1);
                  break;
                  case 1:
                    outMathNode = new math.ConstantNode(number);
                  break;
                  default:
                    outMathNode = new math.OperatorNode("^", "pow", [new math.ConstantNode(number), new math.ConstantNode(exponent)]);
                    break;
                }

                return outMathNode;
              }

              outNode = arr_butfirst.reduce((acc, x) => {
                const entry = x;
                const number   = Number(entry[0]);
                const exponent = entry[1];
                const mathNode_arg2 = mathNodeForNumberAtPositiveExponent(number, exponent);
                return new math.OperatorNode("×", "multiply", [acc, mathNode_arg2]);
              }, mathNode_first);

              break;
            case "OperatorNode":
              const operatorNode = mathNode;
              // logger.log("operatorNode", operatorNode);
              // switch(operatorNode.op) {
              //   case "/":
              //   break;
              // }

              // outNode = new math.OperatorNode(operatorNode.op, operatorNode.fn, operatorNode.args.map(Rewriter.decomposition_product_primes__vpadiq));


              const rules = [
                'n1 × n1 -> n1^2',
                '(n1^c1) × (n1^c2) -> n1^(c1+c2)',
              ];

              logger.log("operatorNode, before", operatorNode.toString());
              outNode = math.simplify(operatorNode, rules);
              logger.log("operatorNode, after", outNode.toString());

              break;
            default:
              throw new Error("unsupported type: " + mathNode.type);
              break;
          }

          return outNode;
        }


      static decomposition_product_primes_and_symbols(mathNode) {
        var outNode;

        switch (mathNode.type) {
          case "ConstantNode":
            const value = mathNode.value;
            const arr_values = MathUtils.primeFactorization(value);

            // const joinreduce = function(joinFunc, )
            const value_first = arr_values[0];
            const arr_butfirst = arr_values.slice(1);
            const mathNode_initial = new math.ConstantNode(value_first);
            outNode = arr_butfirst.reduce((acc, x) => {
              const mathNode_arg2 = new math.ConstantNode(x);
              return new math.OperatorNode("×lol×", "multiply", [acc, mathNode_arg2]);
            }, mathNode_initial);

            break;
          case "OperatorNode":
            const operatorNode = mathNode;
            logger.log("operatorNode", operatorNode);
            // switch(operatorNode.op) {
            //   case "/":
            //   break;
            // }
            outNode = new math.OperatorNode(operatorNode.op, operatorNode.fn, operatorNode.args.map(Rewriter.decomposition_product_primes_and_symbols));

            break;
          case "SymbolNode":
            outNode = mathNode;
            break;

          default:
            throw new Error("unsupported type: " + mathNode.type);
            break;
        }

        return outNode;
      }

      static removeUnnecessaryOnesInLitexp(mathNode_litexp) {
        var outMathNode;

        const rules = [
          "1 * n1 -> n1",
          "n1 * 1 -> n1",
        ];

        outMathNode = math.simplify(mathNode_litexp, rules);

        return outMathNode;
      }

      static rewriteOperatorNode__constant__to_pow1(node_in) {
          var outNode;

          if(node_in instanceof math.ConstantNode) {
            outNode = new math.OperatorNode("^", "pow", [node_in, new math.ConstantNode(1)]);
          } else {
            outNode = node_in;
          }

          return outNode;
        }

        static rewriteOperatorNode__divide_to_multinv(node_in) {
          var outNode;

          if(node_in instanceof math.OperatorNode) {
            if(node_in.fn == "divide") {

              //transform into product
              const mathNode__numerator      = Rewriter.rewriteOperatorNode__mult__flatten(node_in.args[0]);
              var arr_num;
              if(mathNode__numerator instanceof math.OperatorNode) {
                arr_num = mathNode__numerator.args;
              } else {
                arr_num = [mathNode__numerator];
              }

              const mathNode__denominator    = Rewriter.rewriteOperatorNode__mult__flatten(node_in.args[1]);
              var arr_den;
              if(mathNode__numerator instanceof math.OperatorNode) {
                arr_den = mathNode__denominator.args;
              } else {
                arr_den = [mathNode__denominator];
              }

              const mathNode_denominator_transformed = Rewriter.rewriteOperatorNode__divide_to_multinv(mathNode__denominator);
              const arr_inverse_den = arr_den.map(mathNode => new math.OperatorNode("/", "divide", [new math.ConstantNode(1), mathNode]));

              outNode = new math.OperatorNode("*", "multiply", [...arr_num, ...arr_inverse_den]);
            } else {
              outNode = node_in;
            }
          } else {
            outNode = node_in;
          }

          return outNode;
        }


      static rewriteOperatorNode__mult__flatten(node_in) {
          var outNode;

          if(node_in instanceof math.OperatorNode) {

            if(node_in.fn == "multiply") {
              const arr_args = node_in.args;
              const arr_args__flattened = arr_args.map(Rewriter.rewriteOperatorNode__mult__flatten);

              const arr_args__merged = arr_args__flattened.reduce((acc, x) => {
                var arr__to_merge;

                if(x instanceof math.OperatorNode) {
                  if(x.fn == "multiply") {
                    arr__to_merge = x.args;
                  }
                  else {
                    arr__to_merge = [x];
                  }
                } else {
                  arr__to_merge = [x];
                }

                acc = acc.concat(arr__to_merge);
                return acc;
              }, []);

              outNode = new math.OperatorNode("*", "multiply", arr_args__merged);
              // outNode = new math.OperatorNode("×", "multiply", arr_args__merged);

            }
            else if(node_in.fn == "divide") {
              if(node_in.isAtomicInverse) {
                //ignore
                outNode = node_in;
              } else {
                outNode = Rewriter.rewriteOperatorNode__divide_to_multinv(node_in);
              }
            }
            else if(node_in.fn == "pow") {
              const value    = node_in.args[0].value;
              const exponent = node_in.args[1].value;
              if(exponent == 1) {
                //ignore
                outNode = node_in;
              } else if(exponent > 1) {
                const arr_node = [...Array(exponent).keys()].map(i => new math.ConstantNode(value));
                outNode = new math.OperatorNode("*", "multiply", arr_node);
                // outNode = new math.OperatorNode("×", "multiply", arr_node);
              } else {
                const arr_node = [...Array(-exponent).keys()].map(i => {
                  const mathNode__denominator = new math.ConstantNode(value);
                  const mathNode_inverse = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), mathNode__denominator]);
                  mathNode_inverse.isAtomicInverse = true;
                  return mathNode_inverse;
                });
                outNode = new math.OperatorNode("*", "multiply", arr_node);
                // outNode = new math.OperatorNode("×", "multiply", arr_node);
              }
            }
            else {
              outNode = node_in;
            }

          } else if(node_in instanceof math.ParenthesisNode) {

            //check if flattenable
            const node_content = node_in.content;
            const isConstantNode       = node_content instanceof math.ConstantNode;
            const isOperatorNode__mult = node_content instanceof math.OperatorNode && node_content.fn == "multiply";
            const isOperatorNode__pow  = node_content instanceof math.OperatorNode && node_content.fn == "pow";
            const isFlattenable = isConstantNode || isOperatorNode__mult || isOperatorNode__pow;

            if(isFlattenable) {
              outNode = Rewriter.rewriteOperatorNode__mult__flatten(node_content);
            } else {
              outNode = node_in;
            }

          } else if(node_in instanceof math.ConstantNode) {
            outNode = Rewriter.rewriteOperatorNode__constant__to_pow1(node_in);
          } else {
            outNode = node_in;
          }

          return outNode;
        }

        static rewriteOperatorNode__mult__sort(node_in) {
          var outNode;

          function compare__node(node1, node2) {
            if(node1 instanceof math.ConstantNode && node2 instanceof math.ConstantNode) {
              return math.compare(node1.value,node2.value);
            }
            return 1;
          }

          if(node_in instanceof math.OperatorNode) {

            if(node_in.fn == "multiply") {
              const arr_args__sorted = [...node_in.args].toSorted(compare__node);
              outNode = new math.OperatorNode("*", "multiply", arr_args__sorted);
              // outNode = new math.OperatorNode("×", "multiply", arr_args__sorted);
            } else {
              outNode = node_in;
            }

          } else {
            outNode = node_in;
          }
          return outNode;
        }

        static rewriteOperatorNode__mult__sortpow(node_in) {
          var outNode;

          function compare__node(node1, node2) {
            function isValidNode(node) {
              return (node instanceof math.OperatorNode) && (node.fn == "pow") && (node.args[0] instanceof math.ConstantNode);
            }
            const isNode1__valid = isValidNode(node1);
            const isNode2__valid = isValidNode(node2);
            function getNumberOfInterest(node) {
              return node.args[0].value;
            }
            if(isNode1__valid && isNode2__valid) {
              const value_1 = getNumberOfInterest(node1);
              const value_2 = getNumberOfInterest(node2);
              return math.compare(value_1,value_2);
            }
            return 1;
          }

          if(node_in instanceof math.OperatorNode) {

            if(node_in.fn == "multiply") {
              const arr_args__sorted = [...node_in.args].toSorted(compare__node);
              outNode = new math.OperatorNode("*", "multiply", arr_args__sorted);
              // outNode = new math.OperatorNode("×", "multiply", arr_args__sorted);
            } else {
              outNode = node_in;
            }

          } else {
            outNode = node_in;
          }
          return outNode;
        }

        // static rewriteOperatorNode__mult__factorize_into_pow(node_in) {
        //   var outNode;

        //   if(node_in instanceof math.OperatorNode) {

        //     const arr_node   = [...node_in.args];
        //     const arr_values = arr_node.map(node => node.value);
        //     // logger.log("rewriteOperatorNode", arr_values);

        //     const dict_pow = arr_values.reduce((acc, x) => {
        //       const str__x = "" + x;
        //       if(acc[str__x] == null) {
        //         acc[str__x] = 0;
        //       }
        //       acc[str__x] += 1;
        //       return acc;
        //     }, {});
        //     const arr_entry = Object.entries(dict_pow);

        //     const arr_pow   = arr_entry.reduce((acc, x) => {
        //       const entry = x;
        //       const str__value = entry[0];
        //       const value      = math.parse(str__value);
        //       const exponent   = entry[1];

        //       const mathNode__value    = new math.ConstantNode(value);
        //       const mathNode__exponent = new math.ConstantNode(exponent);

        //       var mathNode_pow;
        //       if(exponent != 1) {
        //         mathNode_pow = new math.OperatorNode("^", "pow", [mathNode__value, mathNode__exponent]);
        //       } else {
        //         mathNode_pow = mathNode__value;
        //       }
        //       acc = acc.concat([mathNode_pow]);
        //       return acc;
        //     }, []);

        //     if(arr_pow.length == 1) {
        //       outNode = arr_pow[0];
        //     } else {
        //       outNode = new math.OperatorNode("*", "multiply", arr_pow);
        //       // outNode = new math.OperatorNode("×", "multiply", arr_pow);
        //     }

        //   } else {
        //     outNode = node_in;
        //   }

        //   return outNode;
        // }

        static rewriteOperatorNode__mult__factorize_into_pow(node_in) {
          var outNode;

          if(node_in instanceof math.OperatorNode) {

            const arr_node   = [...node_in.args];
            // const arr_values = arr_node.map(node => node.value);
            // // logger.log("rewriteOperatorNode", arr_values);
            //
            // const dict_pow = arr_values.reduce((acc, x) => {
            //   const str__x = "" + x;
            //   if(acc[str__x] == null) {
            //     acc[str__x] = 0;
            //   }
            //   acc[str__x] += 1;
            //   return acc;
            // }, {});

            function getPowObj(node) {
              var outObj;

              if(node instanceof math.ConstantNode) {
                outObj = {
                  value: node.value,
                  exponent: 1,
                };
              } else if(node instanceof math.OperatorNode) {
                if(node.fn == "divide") {
                  outObj = {
                    value: node.args[1].value,
                    exponent: -1,
                  };
                } else if(node.fn == "pow") {
                  outObj = {
                    value: node.args[0].value,
                    exponent: node.args[1].value,
                  };
                } else {
                  outObj = {};
                }
              } else {
                outObj = {};
              }

              return outObj;
            }

            const dict_pow = arr_node.reduce((acc, x) => {
              const obj_pow = getPowObj(x);
              const str__x = "" + obj_pow.value;
              if(acc[str__x] == null) {
                acc[str__x] = 0;
              }
              acc[str__x] += obj_pow.exponent;
              return acc;
            }, {});

            const arr_entry = Object.entries(dict_pow);

            const arr_pow   = arr_entry.reduce((acc, x) => {
              const entry = x;
              const str__value = entry[0];
              const value      = math.parse(str__value);
              const exponent   = entry[1];

              const mathNode__value    = new math.ConstantNode(value);
              const mathNode__exponent = new math.ConstantNode(exponent);

              var mathNode_pow;
              if(exponent != 1) {
                mathNode_pow = new math.OperatorNode("^", "pow", [mathNode__value, mathNode__exponent]);
              } else {
                mathNode_pow = mathNode__value;
              }
              acc = acc.concat([mathNode_pow]);
              return acc;
            }, []);

            const arr_pow__filtered = arr_pow.filter(node => {
              var outBool;

              if(node instanceof math.ConstantNode) {
                outBool = (node.value != 1);
              } else if(node instanceof math.OperatorNode) {
                const isNot1    = (node.args[0].value != 1);
                const isNotExp0 = (node.args[1].value != 0);
                outBool = isNot1 && isNotExp0;
              } else {
                outBool = true;
              }

              return outBool;
            });

            if(arr_pow__filtered.length == 0) {
              outNode = new math.ConstantNode(1);
            }
            else if(arr_pow__filtered.length == 1) {
              outNode = arr_pow__filtered[0];
            }
            else {
              outNode = new math.OperatorNode("*", "multiply", arr_pow__filtered);
              // outNode = new math.OperatorNode("×", "multiply", arr_pow);
            }

          } else {
            outNode = node_in;
          }

          return outNode;
        }

        static rewriteOperatorNode__mult__inflate_to_binary_tree(node_in) {
          return node_in;
        }


        static rewriteOperatorNode__pow__flatten(node_in) {
          var outNode;

          if(node_in instanceof math.OperatorNode) {

            if(node_in.fn == "pow") {
              const arr_args = node_in.args;
              const arr_args__flattened = arr_args.map(Rewriter.rewriteOperatorNode__pow__flatten);

              const mathNode__base     = arr_args__flattened[0];
              const mathNode__exponent = arr_args__flattened[1];

              if(mathNode__base instanceof math.OperatorNode) {

                if(mathNode__base.fn == "pow") {

                  const mathNode__baseF      = Rewriter.rewriteOperatorNode__pow__flatten(mathNode__base);
                  const mathNode__baseF_base = mathNode__baseF.args[0];
                  const mathNode__baseF_exp  = mathNode__baseF.args[1];

                  const isConstantNode__baseF_exp = mathNode__baseF_exp instanceof math.ConstantNode
                  const isConstantNode__exp       = mathNode__exponent  instanceof math.ConstantNode;

                  const isFlattenable = isConstantNode__baseF_exp && isConstantNode__exp;

                  if(isFlattenable) {
                    const value__exp__prod    = mathNode__baseF_exp.value * mathNode__exponent.value;
                    const mathNode__exp__prod = new math.ConstantNode(value__exp__prod);
                    outNode = new math.OperatorNode("^", "pow", [mathNode__baseF_base, mathNode__exp__prod]);
                  } else {
                    outNode = node_in;
                  }

                } else {
                  outNode = node_in;
                }

              } else {
                outNode = node_in;
              }

            }
            else if (node_in.fn == "multiply") {
              outNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(node_in);
            }
            else {
              outNode = node_in;
            }

          } else if(node_in instanceof math.ParenthesisNode) {

            //check if flattenable
            const node_content = node_in.content;
            // const isConstantNode       = node_content instanceof math.ConstantNode;
            const isOperatorNode__mult = node_content instanceof math.OperatorNode && node_content.fn == "multiply";
            const isOperatorNode__pow  = node_content instanceof math.OperatorNode && node_content.fn == "pow";
            const isFlattenable = /*isConstantNode*/ isOperatorNode__mult || isOperatorNode__pow;

            if(isFlattenable) {
              outNode = Rewriter.rewriteOperatorNode__pow__flatten(node_content);
            } else {
              outNode = node_in;
            }

          } else {
            outNode = node_in;
          }

          return outNode;
        }



        static substitute(mathNode_in, func_isNodeFrom, func_nodeTo) {

          const mathNode__transformed = mathNode_in.transform(function (node, path, parent) {
            // if (node.isSymbolNode && node.name === 'x') {
            if(func_isNodeFrom(node)) {
              return func_nodeTo(node);
            }
            else {
              return node;
            }
          });

          return mathNode__transformed;

        }


        static rewriteSumWithSymbolsFirst(mathNode_in) {
          var outMathNode;

          if(MathUtils.isContainingSymbolNode(mathNode_in)) {

            outMathNode = mathNode_in.transform((mathNode) => {
              var outMathNode2;

              if(MathUtils.isContainingSymbolNode(mathNode)) {

                switch(mathNode.type) {
                  case "OperatorNode":
                    {
                      switch(mathNode.fn) {
                        case "add":
                          {
                            outMathNode2 = new math.OperatorNode(mathNode.op, mathNode.fn, mathNode.args.sort((mathNode1, mathNode2) => {
                              const isContainingSymbol__mathNode1 = MathUtils.isContainingSymbolNode(mathNode1);
                              const isContainingSymbol__mathNode2 = MathUtils.isContainingSymbolNode(mathNode2);
                              if(isContainingSymbol__mathNode1 && isContainingSymbol__mathNode2) {
                                return 0;
                              } else if(isContainingSymbol__mathNode1) {
                                return -1;
                              } else if(isContainingSymbol__mathNode2) {
                                return +1;
                              } else {
                                return 0;
                              }
                            }));
                          }
                          break;
                        default:
                          {
                            outMathNode2 = mathNode;
                          }
                          break;
                      }
                    }
                    break;
                  default:
                    {
                      outMathNode2 = mathNode;
                    }
                    break;
                }

              } else {
                outMathNode2 = mathNode;
              }
  
              return outMathNode2;
            });

          } else {
            outMathNode = mathNode_in;
          }

          return outMathNode;
        }




        static test_simplification_rules() {

          {
            // const mathNode_prod = new math.OperatorNode("*", "multiply", [new math.ConstantNode(2), new math.ConstantNode(3), new math.ConstantNode(2), new math.ConstantNode(7)]);
            const mathNode_prod = new math.OperatorNode("*", "multiply", [new math.ConstantNode(2), new math.ConstantNode(3), new math.ConstantNode(2), new math.ConstantNode(2),new math.ConstantNode(2)]);
            logger.log("mathNode_prod", mathNode_prod);

            function createOperatorNodeTree_mult(...arr_numbers) {
              return arr_numbers.slice(1).reduce((acc, x) => {
                const node_a = acc;
                const node_b = new math.ConstantNode(x);
                acc = new math.OperatorNode("*", "multiply", [node_a,node_b]);
                return acc;
              }, new math.ConstantNode(arr_numbers[0]));
            }

          }

          {
            const mathNode_prod = new math.OperatorNode("*", "multiply", [2,3,2,2,3,2,5,4,2,3,5].map(value => new math.ConstantNode(value)));
            logger.log("test_simplification_rules, mathNode_factpow", mathNode_prod);

            const mathNode_factpow = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(mathNode_prod);
            logger.log("test_simplification_rules, mathNode_factpow", mathNode_factpow);

          }

          {
            const mathNode_prod = math.parse("((2 * 3^2 * 5 * 3) * 2) * 5");
            logger.log("test_simplification_rules, mathNode_prod", mathNode_prod.toString());

            const mathNode_flatten = Rewriter.rewriteOperatorNode__mult__flatten(mathNode_prod);
            logger.log("test_simplification_rules, mathNode_flatten", mathNode_flatten.toString());

            const mathNode_factpow = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(mathNode_flatten);
            logger.log("test_simplification_rules, mathNode_factpow", mathNode_factpow.toString());

          }

        }

    }
  </script>
  <script>
    class Parser {

      static parse__rational__repeating_decimal(str__repeating_decimal) {
        var outMathNode;

        const value = math.fraction("0." + "'" + str__repeating_decimal + "'");
        outMathNode = new math.ConstantNode(value);

        return outMathNode;
      }

      static parse__rational__explicit(str__rational__explicit) {
        logger.log("logNT", "parse__rational__explicit", str__rational__explicit);

        var outMathNode;

        const str__sign = (str__rational__explicit[0] == "-") ? "-" : "+";
        var str__wo_dots__wo_sign;
        if(/^[+-]/.test(str__rational__explicit)) {
          str__wo_dots__wo_sign = str__rational__explicit.slice(1);
        } else {
          str__wo_dots__wo_sign = str__rational__explicit;
        }

        const [str__left, str__right] = str__wo_dots__wo_sign.split(".");
        // logger.log("logNT", "str__right:", str__right);
        const arr_match  = str__right.match(/^(.*)\'(.*?)\'$/);
        // logger.log("logNT", "arr_match:", arr_match);

        const str__unrepeated_decimal = arr_match[1];
        const str__repeating_decimal  = arr_match[2];
        const int__decimal_place__of_repeating = str__rational__explicit.indexOf(".") - str__rational__explicit.indexOf("'"); 
        // logger.log("logNT", "int__decimal_place__of_repeating:", int__decimal_place__of_repeating);

        const mathNode__sign   = math.parse(str__sign + "1");
        const mathNode__left   = math.parse(str__left);
        const mathNode__right1 = math.parse("0." + str__unrepeated_decimal);

        const mathNode__right2__1 = new math.OperatorNode("^", "pow", [new math.ConstantNode(10), new math.ConstantNode(int__decimal_place__of_repeating + 1)]);
        const mathNode__right2__2 = Parser.parse__rational__repeating_decimal(str__repeating_decimal);
        const mathNode__right2 = new math.OperatorNode("*", "multiply", [mathNode__right2__1, mathNode__right2__2]);

        outMathNode = new math.OperatorNode("+", "add", [mathNode__left, mathNode__right1, mathNode__right2]);
        outMathNode = new math.ConstantNode(outMathNode.evaluate({}));
        // logger.log("logNT", "outMathNode:", outMathNode);

        outMathNode = new math.OperatorNode("*", "multiply", [mathNode__sign, outMathNode]);
        outMathNode = new math.ConstantNode(outMathNode.evaluate({}));
        // logger.log("logNT", "outMathNode:", outMathNode);
        
        return outMathNode;
      }

      static getRepeatingTrailingPatternInString(str_in) {
        var outString;

        function maxRepeat__atEnd(input) {
          var reg = /(?=((.+)(?:.*?\2)+))/g;
          var sub = ""; //somewhere to stick temp results
          var maxstr = ""; // our maximum length repeated string
          reg.lastIndex = 0; // because reg previously existed, we may need to reset this
          sub = reg.exec(input); // find the first repeated string
          while (!(sub == null)){
            if ((!(sub == null)) && (sub[2].length > maxstr.length)){
            maxstr = sub[2];
            }
            sub = reg.exec(input);
            reg.lastIndex++; // start searching from the next position
          }
          return maxstr;
        }

        if(str_in.length == 1) {
          outString = str_in;
        } else {
          outString = maxRepeat__atEnd(str_in);
        }
        
        return outString;
      }

      static parse__rational__implicit(str__rational__implicit) {
        logger.log("logNT", "parse__rational__implicit", str__rational__implicit);

        var outMathNode;

        const str__without_trailing_dots = str__rational__implicit.replace("...","");

        const str__sign = (str__without_trailing_dots[0] == "-") ? "-" : "+";
        var str__wo_dots__wo_sign;
        if(/^[+-]/.test(str__without_trailing_dots)) {
          str__wo_dots__wo_sign = str__without_trailing_dots.slice(1);
        } else {
          str__wo_dots__wo_sign = str__without_trailing_dots;
        }

        const [str__left, str__right] = str__wo_dots__wo_sign.split(".");
        // logger.log("logNT", "str__right:", str__right);

        const str__repeating_decimal  = Parser.getRepeatingTrailingPatternInString(str__right);
        // logger.log("logNT", "str__repeating_decimal:", str__repeating_decimal);

        const index__repeating_decimal         = str__right.indexOf(str__repeating_decimal);
        const int__decimal_place__of_repeating = -index__repeating_decimal - 1;
        // logger.log("logNT", "int__decimal_place__of_repeating:", int__decimal_place__of_repeating);

        const str__unrepeated_decimal = str__right.slice(0, index__repeating_decimal);
        // logger.log("logNT", "str__unrepeated_decimal:", str__unrepeated_decimal);


        const mathNode__sign   = math.parse(str__sign + "1");
        const mathNode__left   = math.parse(str__left);
        const mathNode__right1 = math.parse("0." + str__unrepeated_decimal);

        const mathNode__right2__1 = new math.OperatorNode("^", "pow", [new math.ConstantNode(10), new math.ConstantNode(int__decimal_place__of_repeating + 1)]);
        const mathNode__right2__2 = Parser.parse__rational__repeating_decimal(str__repeating_decimal);
        const mathNode__right2 = new math.OperatorNode("*", "multiply", [mathNode__right2__1, mathNode__right2__2]);

        // logger.log("logNT", "mathNode_left:",      mathNode__left);
        // logger.log("logNT", "mathNode_right1:",    mathNode__right1);
        // logger.log("logNT", "mathNode_right2__1:", mathNode__right2__1);
        // logger.log("logNT", "mathNode_right2__2:", mathNode__right2__2);
        // logger.log("logNT", "mathNode_right2:",    mathNode__right2);

        outMathNode = new math.OperatorNode("+", "add", [mathNode__left, mathNode__right1, mathNode__right2]);
        outMathNode = new math.ConstantNode(outMathNode.evaluate({}));

        outMathNode = new math.OperatorNode("*", "multiply", [mathNode__sign, outMathNode]);
        outMathNode = new math.ConstantNode(outMathNode.evaluate({}));
        // logger.log("logNT", "outMathNode:", outMathNode);
        
        return outMathNode;
      }

    }
  </script>



  <script>
    class Splitter {

      constructor() {

      }

      static split_top_layer(mathNode) {
        var outArr;

        switch (mathNode.type) {
          case "OperatorNode":
            {
              const arr_args = mathNode.args;

              // const operatorNode__nude = mathNode.clone();
              // operatorNode__nude.args = [];
              //
              // outArr = [...arr_args, operatorNode__nude];

              const symbolNode__operator = new math.SymbolNode(mathNode.op);
              outArr = [symbolNode__operator, ...arr_args];
            }
            break;
          case "ParenthesisNode":
            {
              const symbolNode__operator = new math.SymbolNode("()");
              outArr = [symbolNode__operator, mathNode.content];

              // const symbolNode__operatorOpen  = new math.SymbolNode("(");
              // const symbolNode__operatorClose = new math.SymbolNode(")");
              // outArr = [symbolNode__operatorOpen, mathNode.content, symbolNode__operatorClose];
            }
            break;
          default:
            outArr = [mathNode];
            break;
        }

        return outArr;
      }

      static split_full(mathNode) {
        var outArr;

        const arr_components = Splitter.split_top_layer(mathNode);
        if (arr_components.length > 1) {
          outArr = arr_components.reduce((acc, x) => {
            const arr_mathNode = Splitter.split_full(x);
            acc.push(...arr_mathNode);
            return acc;
          }, []);
        } else {
          outArr = arr_components;
        }

        return outArr;
      }

      static geometry__fireworks(center, nb_sparks) {
        var outGeometryObj;


        return outGeometryObj;
      }



      static split_string(str_in) {
        var outArr;

        outArr = str_in.split("");

        return outArr;
      }

    }

  </script>
  <script>
    class Joiner {
      constructor() {

      }

      /**
      *   create a mathNode using all mathNodes in arr_mathNode
      */
      static random_join(arr_mathNode) {
        var outMathNode;

        const nb_max_try = 1000;

        var found = false;
        var nb_try = 0;
        //ugly brute            //SHU: sometimes, one can be proud of one's hideousness
        while (!found && nb_try < nb_max_try) {
          try {
            const join_workz = Joiner.random_join_workz(arr_mathNode, true);
            outMathNode = join_workz.output;
            found = true;
          }
          catch (e) {
            logger.log(e);
            found = false;
          }
          nb_try += 1;
        }

        if (!found) {
          outMathNode = new math.SymbolNode("error");
        }

        // logger.log("outMathNode", outMathNode);

        return outMathNode;
      }

      // static random_join_workz(arr_mathNode, isExhaustive = false) {
      //   logger.log("random_join_workz", arr_mathNode);
      //   var outWorkz;
      //
      //   outWorkz = {
      //     output:   null,
      //     arr_rest: [],
      //   };
      //
      //   var isTerminal;
      //   if(isExhaustive) {
      //     const isOneNodeArray = (arr_mathNode.length == 1);
      //     isTerminal = isOneNodeArray;
      //   } else {
      //     //randomly terminal
      //     const random_boolean = Math.random() < 0.5;
      //     isTerminal = random_boolean;
      //   }
      //
      //
      //   if(isTerminal) {
      //     //get a terminal node
      //     const arr_terminalNode     = arr_mathNode.filter(mathNode => {
      //       const isConstantNode       = (mathNode.type == "ConstantNode");
      //       const isTerminalSymbolNode = (mathNode.type == "SymbolNode") && (Joiner.filter_operatorSymbols([mathNode]).length == 0);
      //       return isConstantNode || isTerminalSymbolNode;
      //     });
      //     Utils.shuffle(arr_terminalNode);
      //
      //     const terminalNode = arr_terminalNode.find(e => true);
      //
      //     outWorkz.output   = terminalNode;
      //     outWorkz.arr_rest = arr_mathNode.filter(mathNode => mathNode != terminalNode);
      //
      //   } else {
      //     //1. get an operator
      //     const arr_symbolNode       = Joiner.filter_operatorSymbols(arr_mathNode);
      //     Utils.shuffle(arr_symbolNode);
      //
      //     const symbolNode__operator = arr_symbolNode.find(e => true);
      //     logger.log("symbolNode__operator", symbolNode__operator);
      //
      //     const arr_mathNode_rest    = arr_mathNode.filter(mathNode => mathNode != symbolNode__operator);
      //
      //     //2. get operands
      //     const nb_operands = 2;
      //     const obj_operands = [...new Array(nb_operands).keys()].reduce((acc, x, index) => {
      //       const arr_component__before = acc.arr_component;
      //
      //       const isExhaustive = (index == (nb_operands - 1));
      //       const join_workz = Joiner.random_join_workz(arr_component__before, isExhaustive);
      //
      //       acc.arr_component = join_workz.arr_rest;
      //       const mathNode__operand = join_workz.output;
      //       acc.arr_out.push(mathNode__operand);
      //
      //       return acc;
      //     }, {
      //       arr_component: arr_mathNode_rest,
      //       arr_out: [],
      //     });
      //
      //     const operatorNode = Joiner.operatorNodeForOperatorSymbolNode(symbolNode__operator);
      //     operatorNode.args = obj_operands.arr_out;
      //     logger.log("operatorNode")
      //
      //     outWorkz.output   = operatorNode;
      //     outWorkz.arr_rest = obj_operands.arr_component;
      //   }
      //
      //   return outWorkz;
      // }

      static random_join_workz(arr_mathNode, isExhaustive = false) {
        logger.log("random_join_workz", arr_mathNode);
        var outWorkz;

        outWorkz = {
          output: null,
          arr_rest: [],
        };

        var isTerminal;
        if (isExhaustive) {
          const isOneNodeArray = (arr_mathNode.length == 1);
          isTerminal = isOneNodeArray;
        } else {
          //randomly terminal
          const random_boolean = Math.random() < 0.5;
          isTerminal = random_boolean;
        }


        if (isTerminal) {
          //get a terminal node
          const arr_terminalNode = arr_mathNode.filter(mathNode => {
            const isConstantNode = (mathNode.type == "ConstantNode");
            const isTerminalSymbolNode = (mathNode.type == "SymbolNode") && (Joiner.filter_operatorSymbols([mathNode]).length == 0);
            return isConstantNode || isTerminalSymbolNode;
          });
          Utils.shuffle(arr_terminalNode);

          const terminalNode = arr_terminalNode.find(e => true);

          outWorkz.output = terminalNode;
          outWorkz.arr_rest = arr_mathNode.filter(mathNode => mathNode != terminalNode);

        } else {
          //1. get an operator
          const arr_symbolNode = Joiner.filter_operatorSymbols(arr_mathNode);
          Utils.shuffle(arr_symbolNode);

          const symbolNode__operator = arr_symbolNode.find(e => true);
          logger.log("symbolNode__operator", symbolNode__operator);

          const arr_mathNode_rest = arr_mathNode.filter(mathNode => mathNode != symbolNode__operator);

          const specializedNode = Joiner.specializedNodeForSymbolNode(symbolNode__operator);

          //2. get operands
          const nb_operands = Joiner.arityForSymbolNode(symbolNode__operator);
          const obj_operands = [...new Array(nb_operands).keys()].reduce((acc, x, index) => {
            const arr_component__before = acc.arr_component;

            const isExhaustive = (index == (nb_operands - 1));
            const join_workz = Joiner.random_join_workz(arr_component__before, isExhaustive);

            acc.arr_component = join_workz.arr_rest;
            const mathNode__operand = join_workz.output;
            acc.arr_out.push(mathNode__operand);

            return acc;
          }, {
            arr_component: arr_mathNode_rest,
            arr_out: [],
          });

          const arr_operands = obj_operands.arr_out;

          switch (specializedNode.type) {
            case "ParenthesisNode":
              const parenthesisNode = specializedNode;
              const contentNode = arr_operands.find(e => true);
              parenthesisNode.content = contentNode;
              break;
            case "OperatorNode":
              const operatorNode = specializedNode;
              operatorNode.args = arr_operands;
              break;
            default:
              throw new Error("unsupported specializedNode type : " + specializedNode.type);
              break;
          }

          logger.log("operatorNode")

          outWorkz.output = specializedNode;
          outWorkz.arr_rest = obj_operands.arr_component;
        }

        return outWorkz;
      }


      static filter_operatorSymbols(arr_mathNode) {
        var outArr;

        function isOperatorSymbolNode(symbolNode) {
          var outBool;

          switch (symbolNode.name) {
            case "+":
            case "-":
            case "×":
            case "/":
              outBool = true;
              break;

            case "()":
              outBool = true;
              break;

            default:
              outBool = false;
              break;
          }

          return outBool;
        }

        outArr = arr_mathNode
          .filter(mathNode => (mathNode.type == "SymbolNode"))
          .filter(isOperatorSymbolNode);

        return outArr;
      }

      static operatorNodeForOperatorSymbolNode(symbolNode) {
        var outOperatorNode;

        const op = symbolNode.name;

        var funcName;
        switch (op) {
          case "+":
            funcName = "add";
            break;
          case "-":
            funcName = "subtract";
            break;
          case "×":
            funcName = "multiply";
            break;
          case "/":
            funcName = "divide";
            break;
          default:
            throw new Error("unsupported op symbol : " + op);
            break;
        }

        outOperatorNode = new math.OperatorNode(op, funcName, []);

        return outOperatorNode;
      }

      static specializedNodeForSymbolNode(symbolNode) {
        var outSpecializedNode;

        const op = symbolNode.name;

        var funcName;
        switch (op) {
          case "+":
            funcName = "add";
            outSpecializedNode = new math.OperatorNode(op, funcName, []);
            break;
          case "-":
            funcName = "subtract";
            outSpecializedNode = new math.OperatorNode(op, funcName, []);
            break;
          case "×":
            funcName = "multiply";
            outSpecializedNode = new math.OperatorNode(op, funcName, []);
            break;
          case "/":
            funcName = "divide";
            outSpecializedNode = new math.OperatorNode(op, funcName, []);
            break;

          case "()":
            const mathNode__placeholder = new math.SymbolNode("placeholder");
            outSpecializedNode = new math.ParenthesisNode(mathNode__placeholder);   //SHU: ni propre, ni sale. Juste un peu dérangeant.
            break;

          default:
            throw new Error("unsupported op symbol : " + op);
            break;
        }

        return outSpecializedNode;
      }

      static arityForSymbolNode(symbolNode) {
        var outInt;

        const op = symbolNode.name;

        var funcName;
        switch (op) {
          case "+":
          case "-":
          case "×":
          case "/":
            outInt = 2;
            break;
          case "()":
            outInt = 1;
            break;
          default:
            throw new Error("unsupported op symbol : " + op);
            break;
        }

        return outInt;
      }

    }
  </script>
  <script>
    class MathUtils {

      static arr_integer_in_range(range) {
        const span = range.max - range.min;
        return [...Array(span).keys()].map(index => index + range.min);
      }

      static primeFactorization(number, result) {
        var result = (result || []);
        var root = Math.sqrt(number);
        var x = 2;

        if (number % x) {
          x = 3;

          while ((number % x) && ((x = (x + 2)) < root)) { }
        }

        x = (x <= root) ? x : number;

        result.push(x);

        return (x === number) ? result : MathUtils.primeFactorization((number / x), result);
      }

      static arr_prime(length) {
        var outArr = [];

        // return [...Array(length).keys()].map(index => )

        var nb_remaining = length;
        var running = 2;
        while (nb_remaining > 0) {
          if (math.isPrime(running)) {
            outArr.push(running);
            nb_remaining -= 1;
          }
          running += 1;
        }

        return outArr;
      }

      static arr_prime_in_range(range) {
        const span = range.max - range.min;
        return [...Array(span).keys()].map(index => index + range.min).filter(math.isPrime);
      }

      static randomIntegerInRange(range) {
        const span = range.max - range.min;
        return Math.floor(range.min + Math.random() * span);
      }

      static randomPrimeInRange(range) { //may return null if nothing found
        const arr_prime = MathUtils.arr_prime_in_range(range);
        return Utils.randomElementInArray([...arr_prime, null]);
      }

      static isCoprimes(a, b) {
        return math.gcd(a, b) == 1;
      }

      static arr_coprimeOf_in_range(a, range) {
        const arr_integer   = MathUtils.arr_integer_in_range(range);
        const arr_coprimeOf = arr_integer.filter(n => MathUtils.isCoprimes(a,n));
        return arr_coprimeOf;
      }

      static arr2_randomCoprimesInRange(range) {
        //pick random integer in range
        const a     = MathUtils.randomIntegerInRange(range);
        const arr_b = MathUtils.arr_coprimeOf_in_range(a, range);
        //pick random coprime in range
        const b     = Utils.randomElementInArray(arr_b);
        return [a, b];
      }

      static isFraction(mathNode) {
        var outBool;

        if (mathNode.type == "OperatorNode" && mathNode.fn == "divide") {

          const operatorNode = mathNode;

          const mathNode__numerator = operatorNode.args[0];
          const isTerminalNode__numerator = Simplifier.isTerminalType(mathNode__numerator);

          const mathNode__denominator = operatorNode.args[1];
          const isTerminalNode__denominator = Simplifier.isTerminalType(mathNode__denominator);

          outBool = isTerminalNode__numerator && isTerminalNode__denominator;

        } else {
          outBool = false;
        }

        return outBool;
      }

      static isContainingSymbolNode(mathNode) {
        var outBool;

        const arr_symbolNode = mathNode.filter(function (node) { return node.isSymbolNode; });

        outBool = (arr_symbolNode.length > 0);

        return outBool;
      }

      static randomCartDictFromArr(arr_elts, nb, min_nb_families_in = 1, max_nb_families_in = -1) {
        var outDict;

        var min_nb_families = min_nb_families_in;
        if (min_nb_families <= 0) { min_nb_families = 1 };

        var max_nb_families = max_nb_families_in;
        if (max_nb_families == -1) {
          max_nb_families = arr_elts.length;
        } else if (max_nb_families > arr_elts.length) {
          max_nb_families = arr_elts.length;
        };

        var nb_families  = math.randomInt(min_nb_families, max_nb_families + 1);
        logger.log("logRandom", "nb_families:", nb_families);

        if(nb_families > nb) {
          nb_families = nb;
        }

        const arr_families = Utils.randomSubArrWithArray(arr_elts, nb_families);
        logger.log("logRandom", "arr_families:", arr_families);

        //mandat
        const dict__mandat = Object.entries(arr_families).reduce((acc, [index, elt]) => {
          var currDict = acc;

          const miniDict = {
            obj: elt,
            nb: 1,
          };
          var id = "obj_" + index;
          currDict[id] = miniDict;

          return acc;
        }, {});

        //filler
        outDict = [...Array(nb - nb_families).keys()].reduce((acc, index) => {
          var currDict = acc;

          const index_random = Utils.randomElementInArray([...arr_families.keys()]);
          const elt = arr_families[index_random];
          // logger.log("elt", elt);

          var id;
          // if(elt.id != null) {
          //   id = elt.id;
          // } else {
          id = "obj_" + index_random;
          // }
          if (currDict[id] == null) {
            const miniDict = {
              obj: elt,
              nb: 0,
            };
            currDict[id] = miniDict;
          }

          currDict[id].nb += 1;

          return currDict;
        }, dict__mandat);

        return outDict;
      }

      static randomCartArrFromArr(arr_elts, nb, min_families = -1, max_families = -1, isShuffled = false) {
        var outArr;

        const dict_cart = MathUtils.randomCartDictFromArr(arr_elts, nb, min_families, max_families);
        outArr = MathUtils.arrFromOccurenceDict(dict_cart);

        if (isShuffled) {
          const arr_cart__shuffled = Utils.shuffle([...outArr]);
          outArr = arr_cart__shuffled;
        }

        return outArr;
      }

      static arrFromOccurenceDict(dict_occurence) {
        var outArr;

        outArr = Object.entries(dict_occurence).reduce((acc, entry) => {
          const id = entry[0];

          const obj = entry[1].obj;
          const nb = entry[1].nb;

          return [...acc, ...([...Array(nb)].map(e => obj))];
        }, []);

        return outArr;
      }

      static arrOfPairs(arr) {
        var outArr;

        outArr = arr.reduce((acc, x, index) => {
          var outArr;
          const arr_index__tail = [...Array(arr.length).keys()].slice(index + 1);
          const arr_pairs = arr_index__tail.map(index_tail => [arr[index], arr[index_tail]]);
          outArr = [...acc, ...arr_pairs];
          return outArr;
        }, []);

        return outArr;
      }

      static arrOfPairs__indexes(arr) {
        var outArr;

        outArr = arr.reduce((acc, x, index) => {
          const arr_index__tail = [...Array(arr.length).keys()].slice(index + 1);
          const arr_pairs = arr_index__tail.map(index_tail => [index, index_tail]);
          return [...acc, ...arr_pairs];
        }, []);

        return outArr;
      }



      static randomSymbolNode__kanji(seed = null) {
        const string__kanji = Utils.randomKanji(seed);
        const symbolNode__kanji = new math.SymbolNode(string__kanji);
        return symbolNode__kanji;
      }

      static decorate__support__arrayNode(func__mathNode) {
        function func__decorated(mathNode_in) {
          if(mathNode_in.type == "ArrayNode") {
            // return new math.ArrayNode(mathNode_in.items.map((mathNode__item) => func__decorated(mathNode__item)));
            return new MyAPLArrayNode(mathNode_in.items.map((mathNode__item) => func__decorated(mathNode__item)));
          } else {
            return func__mathNode(mathNode_in);
          }
        }
        return func__decorated;
      }


      static shape__arrayNode(mathNode__arrayNode) {
        var outNode;

        function createConstantNode(n) {
          var outNode;
              
          const mathNode__n = new math.ConstantNode(n);
          mathNode__n.autoSimplify = true;
          
          outNode = mathNode__n;
          return outNode;
        }

        const arr__shape = this.shape__arr(mathNode__arrayNode.items);

        if(arr__shape.length > 1) {
          outNode = new MyAPLArrayNode(arr__shape.map(n => {
            return createConstantNode(n);
          }));
        } else if(arr__shape.length == 1) {
          outNode = createConstantNode(arr__shape[0]);
        } else {
          outNode = createConstantNode(0);
        }

        return outNode;
      }

      static shape__arr(arr) {
        return math.size(arr);
      }

    }

    const MathSingleton = {
      node__empty: new EmptySymbolNode(),
    };


    Math.sum = (...a) => Array.prototype.reduce.call(a,(a,b) => a+b)
    Math.avg = (...a) => Math.sum(...a)/a.length;

  </script>
  <script>
    //debug
    const arr_src = [...Array(20).keys()];

    const dict_cart = MathUtils.randomCartDictFromArr(arr_src, 10, 3, 6);
    logger.log("log1", "dict_cart", dict_cart);
    const arr_cart = MathUtils.randomCartArrFromArr(arr_src, 10, 3, 6);
    logger.log("log1", "arr_cart", arr_cart);

  </script>


  <!-- icObj transformation stuff -->
  <script>
    class Combiner {
      constructor() {

      }

      static combine(arr_icObj) {
        var outIcObj;


        return outIcObj;
      }

    }
  </script>
  <script>
    class TransformationOutput {

      constructor(type, value, from) {
        this.type = type;
        this.value = value;
        this.from = from;
      }

    }
  </script>
  <script>

    class RichMathNode {

      constructor(mathNode) {
        this.mathNode = mathNode;
        this.rich = {};
      }

      configure(config) {
        this.rich.colorMode = config.colorMode;
        this.rich.color = config.color;
      }

      toTex() {
        var outString;

        const colorMode = this.rich.colorMode;

        switch (colorMode) {
          case "xylophone":
            {
              if (this.mathNode.type == "ConstantNode") {
                const positionalNumber = new PositionalNumber(this.mathNode.value);
                outString = positionalNumber.toTex("xylophone");
              } else {
                throw new Error("colorMode:xylophone only compatible with ConstantNode");
              }
            }
            break;
          case "fullplain":
            {
              const color = this.rich.color;
              if (this.mathNode.type == "ConstantNode") {
                const positionalNumber = new PositionalNumber(this.mathNode.value);
                outString = positionalNumber.toTex(color);
              } else {
                throw new Error("colorMode:xylophone only compatible with ConstantNode");
              }
            }
            break;
          case "evenodd":
            {
              const color__even = "#FFFFFF";
              const color__odd = "#000000";

              var color;
              if (this.rich.isEven) {
                color = color__even;
              } else {
                color = color__odd;
              }

              const tex__mathNode = this.mathNode.toTex();
              outString = TexEnricher.color(tex__mathNode, color);
            }
            break;
          case "plain":
            {
              const tex__mathNode = this.mathNode.toTex();

              //color
              if (this.rich.color != null) {
                const color = this.rich.color;
                outString = TexEnricher.color(tex__mathNode, color);
              } else {
                throw new Error("no color specified for colorMode: " + colorMode);
              }

            }
            break;
          default:
            {
              const tex__mathNode = this.mathNode.toTex();
              outString = tex__mathNode;
            }
            // throw new Error("unknown colorMode: " + colorMode);
            break;
        }

        return outString;
      }

      clone() {
        return;
      }

    }

    class TexEnricher {

      static color(tex_in, color_in) {
        var outString;

        outString = "{\\color{" + color_in + "} " + tex_in + " }";

        return outString;
      }

      // static font(tex_in, font_in) {
      //   var outString;
      //
      //   outString = "{\\fontfamily{pag}\\selectfont " + tex_in  + "}";
      //
      //   return outString;
      // }

    }

    // class UnfoldedNumber {
    class PositionalNumber {

      constructor(number, base = 10) {
        this.arr_digit = ("" + number).split("").map(digitStr => parseInt(digitStr));
        this.base = base;
      }

      toTex(color) {
        var outString;

        outString = this.arr_digit.reduce((acc, x) => {
          acc += PositionalNumber.texForDigit(x, color);
          return acc;
        }, "");

        return outString;
      }

      static texForDigit(digit, color_in) {

        var outString;

        outString = "" + digit;

        var color = color_in;
        if (color == "xylophone") {


          if (digit == 0) {
            // outString = "{\\fbox {}}";
            // outString = "{\\fbox {?}}";
            // outString = "\\enspace";

            // outString = "{\\mbox {0}}";

            // outString = "▢";
            // outString = "▫";
            // outString = "☐";
            // outString = "𖡄";
            outString = "?";


            ///not working
            // outString = "{\\fbox {\\hspace{1cm}} }";

          } else {
            color = PositionalNumber.colorForDigit(digit);
          }

          outString = TexEnricher.color(outString, color);

        } else {
          outString = TexEnricher.color(outString, color);
        }

        return outString;
      }

      static colorForDigit(digit) {
        var outColor = null;

        switch (digit) {
          case 0:
            outColor = "#000000";
            break;

          case 1:
            outColor = "#FF7F0E";
            break;
          case 2:
            outColor = "#2CA02C";
            break;
          case 3:
            outColor = "#D62728";
            break;
          case 4:
            outColor = "#9467BD";
            break;
          case 5:
            outColor = "#8C564B";
            break;
          case 6:
            outColor = "#E377C2";
            break;
          case 7:
            outColor = "#7F7F7F";
            break;
          case 8:
            outColor = "#BCBD22";
            break;
          case 9:
            outColor = "#17BECF";
            break;

          //SHU TODO: colors or patterns for those:
          case 10:  //A
            outColor = "#000000";
            break;
          case 11:  //B
            outColor = "#000000";
            break;
          case 12:  //C
            outColor = "#000000";
            break;
          case 13:  //D
            outColor = "#000000";
            break;
          case 14:  //E
            outColor = "#000000";
            break;
          case 15:  //F
            outColor = "#000000";
            break;

          default:
            throw new Error("unsupported digit: " + digit);
        }

        return outColor;
      }



    }

  </script>

  <!-- LOGIC -->
  <script src="lib/logic/tau-prolog.js"></script>
  <script>
    //Create a session
    var prolog_session = pl.create();
  </script>
  <script>
    //discovery

    prolog_session.consult(`
        likes(sam, salad).
        likes(dean, pie).
        likes(sam, apples).
        likes(dean, whiskey).
    `, {
        success: function() { /* Program loaded correctly */ },
        error: function(err) { /* Error parsing program */ }
    });

    prolog_session.query("likes(sam, X).", {
        success: function(goal) { 
          /* Goal loaded correctly */ 
          logger.log("logProlog", "goal:", goal);
        },
        error: function(err) { /* Error parsing goal */ }
    });

    prolog_session.answer({
        success: function(answer) {
            logger.log("logProlog", "answer1:", prolog_session.format_answer(answer)); // X = salad ;
            //another answer plz
            prolog_session.answer({
                success: function(answer) {
                    logger.log("logProlog", "answer2:", prolog_session.format_answer(answer)); // X = apples ;
                },
                // ...
            });
        },
        fail: function() { /* No more answers */ },
        error: function(err) { /* Uncaught exception */ },
        limit: function() { /* Limit exceeded */ }
    });

  </script>



  <!-- UX -->
  <script type="text/javascript" src="lib/rxjs.umd.min.js"></script> <!-- for easy inner/outer copy|paste -->
  <script>
    const Rx = rxjs;
    const Rx_operators = rxjs.operators;

    const Subject = Rx.Subject;
    const ReplaySubject = Rx.ReplaySubject;
  </script>
  <!-- <script>
      //discovery
      const rx_debug__subject    = new Subject();
      const rx_debug__observable = rx_debug__subject.asObservable();
      const rx_debug__sub        = rx_debug__observable.subscribe({
        next: (value) => {
          console.log("value", value);
        },
      });
      rx_debug__subject.next(10);
      rx_debug__subject.next(100);
      rx_debug__subject.next(1000);
    </script> -->
  <script>//for easy html element observation

    function mutationCallback__debug(mutationsList, observer) {
      console.log(mutationsList);
      console.log(observer);
      for (const mutation of mutationsList) {
        if (mutation.type === 'childList') {
          console.log('A child node has been added or removed.');
        } else if (mutation.type === 'attributes') {
          console.log('The ' + mutation.attributeName + ' attribute was modified.');
        } else {
          console.log('mutation.type: ' + mutation.type);
          console.log('New value ' + JSON.stringify(mutation.target.data));
        }
      }
    }

    function createHtmlEltObserver(htmlElt) {

      // Observation medium
      const rx_subject__mutation = new Subject();

      function mutationCallback(mutationsList, observer) {
        console.log(mutationsList);
        console.log(observer);

        const mutation = mutationsList.find(e => true);

        switch (mutation.type) {
          case "childList":
            rx_subject__mutation.next(htmlElt);
            break;
          case "attributes":
            // /!\ .attr() != .prop()
            break;
          default:
            console.log('mutation.type: ' + mutation.type);
            console.log('New value ' + JSON.stringify(mutation.target.data));
            break;
        }

        // rx_subject__mutation.next(htmlElt);
      }

      // Create an observer instance linked to the callback function
      const observer = new MutationObserver(mutationCallback);
      observer.rx_observable__mutation = rx_subject__mutation.asObservable();

      // What to observe
      const mutationConfig = { attributes: true, childList: true, subtree: true, characterData: true };

      // Start observation
      observer.observe(htmlElt, mutationConfig);

      return observer;
    }

  </script>
  <!-- <script>
      //discovery

      document.addEventListener("DOMContentLoaded", function () {
        const htmlElt = document.getElementById("debug_nbObjects");
        const observer = createObserver(htmlElt);

        setTimeout(() => {
          htmlElt.innerHTML = 123456;
        }, 5000);

      });

    </script> -->



  <!-- information -->
  <!-- <script type="text/javascript" src="lib/serialize-javascript.browserified.main.js"></script> -->
  <script type="text/javascript" src="lib/serialize-javascript.browserified.bundle.js"></script>
  <script>
    // console.log("Bundle_SJ", Bundle_SJ);
    const serialize   = Bundle_SJ.serialize;
    const deserialize = Bundle_SJ.deserialize;
  </script>
  <!-- <script>
      //discovery
      const sj__obj = {
        myFunc: (x) => x + 1,
      };
      const sj__serialized = serialize(sj__obj);
      console.log("serialize-javascript::sj__serialized", sj__serialized);
      const sj__deserialized = deserialize(sj__serialized);
      console.log("serialize-javascript::sj__deserialized", sj__deserialized);
      const sj__myFunc_result = sj__deserialized.myFunc(0);
      console.log("serialize-javascript::sj__myFunc_result", sj__myFunc_result);
    </script> -->

  <!-- <script type="text/javascript" src="lib/eventstore/eventstore.browserified.bundle.js"></script>
    <script>
      logger.log("Bundle_ES", Bundle_ES);
      const eventstore = Bundle_ES.eventstore;

      const es_options = {
        emitStoreEvents: false,
      };
      const es         = eventstore(es_options);
      logger.log("es", es);

      es.init(function (err) {
        // this callback is called when all is ready...
        logger.log("es.init", "done", es);
      });
    </script>
    <script>
      //discovery
      setTimeout(() => {

        es.defineEventMappings({
          id:             'id',
          commitId:       'commitId',
          commitSequence: 'commitSequence',
          commitStamp:    'commitStamp',
          streamRevision: 'streamRevision'
        });

        // es.commit({lol : "lol"});
        const event__0 = {
          id: 0,
        };
        const eventStream = [event__0];

        // const eventStream = new EventStream();
        // eventStream.addEvent(event__0);

        // es.addEventStream(eventStream);

        es.store.addEvents([event__0], (err) => {
          if(err != null) {
            logger.log("err", err);
          }
        });

      }, 1000);

    </script>
    <script type="text/javascript" src="lib/eventstore/eventstore-client.browserified.bundle.js"></script>
    <script>
      logger.log("Bundle_ESC", Bundle_ESC);
      const eventstoreClient = Bundle_ESC.eventstoreClient;

      const esc_options = {

      };
      const esc         = eventstoreClient(esc_options);
      logger.log("esc", esc);


    </script> -->


  <!-- <script type="text/javascript" src="lib/js-event-sourcing-example/bundle.js"></script>
    <script>

    </script>
    <script>
      //discovery


    </script> -->

  <!-- <script type="text/javascript" src="lib/coriolis/coriolis.browserified.bundle.js"></script>
    <script>
      logger.log("Bundle_CORIO", Bundle_CORIO);
      const coriolis = Bundle_CORIO.coriolis;

      // const eventStore = coriolis.createStore({});

    </script>
    <script>
      //discovery

      const projection__currentCount = ({ useState, useEvent }) => (
        useState(0),
        useEvent(),
        (state, event) => {
          switch (event.type) {
            case 'incremented':
              return state + 1

            case 'decremented':
              return state - 1

            default:
              return state
          }
        }
      );

      const eventStore = coriolis.createStore(({ withProjection, dispatch }) => {

        withProjection(projection__currentCount).subscribe((count) => logger.log(count));
        // 0

        dispatch({ type: 'incremented' });
        // 1

        dispatch({ type: 'incremented' });
        // 2

        dispatch({ type: 'decremented' });
        // 1
      });

      logger.log("eventStore", eventStore);

    </script> -->

  <script type="text/javascript" src="lib/uuid.browserified.bundle.js"></script>
  <script>
    logger.log("Bundle_UUID", Bundle_UUID);

    const uuidv4 = Bundle_UUID.uuidv4;
    const id__test = uuidv4();

    logger.log("id__test", id__test);

  </script>


  <script type="text/javascript" src="lib/jwt.browserified.bundle.js"></script>
  <script>
    logger.log("Bundle_JWT", Bundle_JWT);

    var counter__jwt = 0;
    const string__private = "lolilol";
    const getJwt = () => {
      counter__jwt = counter__jwt + 1;
      const token = Bundle_JWT.jwt.sign({ counter__jwt: counter__jwt }, string__private);
      return token;
    };

  </script>
  <!-- <script>
      //discovery
      const token = getJwt();
      logger.log("token", token);

      logger.log("getJwt()", getJwt());
      logger.log("getJwt()", getJwt());
  </script> -->
  <script>
    Utils.generateRandomToken = function() {
      const string__private = "jwt__utils";
      const token = Bundle_JWT.jwt.sign({ counter__jwt: math.randomInt(0,1e10) }, string__private);
      return token;
    };
    const session__uuid = Utils.generateRandomToken();
    const Session = {
      uuid: session__uuid,
    };
  </script>

  <!-- <script type="text/javascript" src="lib/wolkenkit-eventstore/wolkenkit-eventstore.browserified.bundle.edited.js"></script> -->
  <script type="text/javascript" src="lib/wolkenkit-eventstore/wolkenkit-eventstore.browserified.bundle.js"></script>
  <script>
    logger.log("Bundle_WKES", Bundle_WKES);
    const Eventstore = Bundle_WKES.eventstore.Eventstore;
    const Event = Bundle_WKES.eventstore.Event;
    const Command = Bundle_WKES.eventstore.Command;
    // const EventEmitter = Bundle_WKES.eventstore.EventEmitter;

    const eventstore__global = new Eventstore();
    eventstore__global.initialize();
    logger.log("eventstore__global", eventstore__global);

    // const eventPublisher = new EventEmitter();
    const uuid__unknown = '123e4567-e89b-42d3-a456-426614174000';

    function readEventStream_p(eventStream) {
      logger.log("readEventStream_p", eventStream);

      return new Promise((resolve, reject) => {

        var arr_event = [];

        eventStream.on('readable', function () {
          // logger.log("eventStream.on('readable')");
          while ((evt = eventStream.read()) != null) {
            arr_event.push(evt);
          }
        });

        eventStream.on('end', function () {
          // logger.log("eventStream.on('end')");
          resolve(arr_event);
        });

      });

    };

  </script>
  <!-- <script>
      //discovery
      // eventstore__global.destroy();

      //create commands and events
      {
        const command = new Command({
          context: {
            name: 'network'
          },
          aggregate: {
            name: 'node',
            id: '85932442-bf87-472d-8b5a-b0eac3aa8be9'
          },
          name: 'ping',
          data: {
            ttl: 10 * 1000
          },
          custom: {
            sourceIp: '127.0.0.1'
          }
        });
        logger.log("command", command);

        const token = getJwt();
        logger.log("token.sub", token.sub());
        const initiator = {
          id: token.sub(),
        };
        command.addInitiator(initiator);

        const event = new Event({
          context: {
            name: 'network'
          },
          aggregate: {
            name: 'node',
            id: '85932442-bf87-472d-8b5a-b0eac3aa8be9'
          },
          name: 'pinged',
          data: {
            ttl: 10 * 1000
          },
          custom: {
            sourceIp: '127.0.0.1'
          },
          metadata: {
            correlationId: '13505cab-0ca2-4502-b8c9-8f3ce63ae390',
            causationId: '124885f3-d35e-43a6-84eb-e28c70b5be66'
          }
        });

        event.addInitiator(command.initiator);

      }

      //store event
      {

        const id__aggregate = '85932442-bf87-472d-8b5a-b0eac3aa8be9';

        const event__1 = new Event({
          context: {
            name: 'network'
          },
          aggregate: {
            name: 'node',
            id: id__aggregate,
          },
          name: 'pinged',
          data: {
            ttl: 10 * 1000
          },
          custom: {
            sourceIp: '127.0.0.1'
          },
          metadata: {
            correlationId: '13505cab-0ca2-4502-b8c9-8f3ce63ae390',
            causationId: '124885f3-d35e-43a6-84eb-e28c70b5be66'
          }
        });
        event__1.metadata.revision = 1;

        const event__2 = new Event({
          context: {
            name: 'network'
          },
          aggregate: {
            name: 'node',
            id: id__aggregate,
          },
          name: 'lolilol',
          data: {
            ttl: 10 * 1000
          },
          custom: {
            sourceIp: '127.0.0.1'
          },
          metadata: {
            correlationId: '13505cab-0ca2-4502-b8c9-8f3ce63ae390',
            causationId: '124885f3-d35e-43a6-84eb-e28c70b5be66'
          }
        });
        event__2.metadata.revision = 2;


        const arr_event__saved = eventstore__global.saveEvents({
          uncommittedEvents: [
            { event: event__1, state: {desc: "state1"} },
            { event: event__2, state: {desc: "state2"} }
          ]
        });

        const arr_event__stored = eventstore__global.getStoredEvents();
        logger.log("arr_event__stored", arr_event__stored);

        eventstore__global.getLastEvent(id__aggregate).then(event__last => {
          logger.log("event__last", event__last);
        });

        const eventStream_p = eventstore__global.getEventStream({aggregateId: id__aggregate});
        eventStream_p.then(readEventStream_p)
        .then(arr_event__eventStream => {
          logger.log("arr_event__eventStream", arr_event__eventStream);
        });

      }

      //store event again
      {

        const id__aggregate = uuidv4();
        // const id__aggregate = uuid__unknown;

        const id__correlation = uuidv4();
        const id__causation   = uuidv4();

        const event__3 = new Event({
          context: {
            name: 'ux'
          },
          aggregate: {
            name: 'node',
            id: id__aggregate,
          },
          name: 'grabbed',
          data: {},
          custom: {},
          metadata: {
            correlationId: id__correlation,
            causationId:   id__causation,
          }
        });
        event__3.metadata.revision = 1;

        const event__4 = new Event({
          context: {
            name: 'ux'
          },
          aggregate: {
            name: 'node',
            id: id__aggregate,
          },
          name: 'moved',
          data: {},
          custom: {},
          metadata: {
            correlationId: id__correlation,
            causationId:   id__causation
          }
        });
        event__4.metadata.revision = 2;


        const arr_event__saved = eventstore__global.saveEvents({
          uncommittedEvents: [
            { event: event__3, state: {desc: "state3"} },
            { event: event__4, state: {desc: "state4"} }
          ]
        });

        const arr_event__stored = eventstore__global.getStoredEvents();
        logger.log("arr_event__stored", arr_event__stored);

        eventstore__global.getLastEvent(id__aggregate).then(event__last => {
          logger.log("event__last", event__last);
        });

        const eventStream_p = eventstore__global.getEventStream({aggregateId: id__aggregate});
        eventStream_p.then(readEventStream_p)
        .then(arr_event__eventStream => {
          logger.log("arr_event__eventStream", arr_event__eventStream);
        });

      }



      //replay
      {
        const replayStream_p = eventstore__global.getReplay({
          // fromPosition: 7,
          // toPosition: 23
        });

        replayStream_p.then(readEventStream_p)
        .then(arr_event__replay => {
          logger.log("arr_event__replay", arr_event__replay);
        });

      }

    </script> -->

  <!-- <script type="text/javascript" src="lib/bluebird.min.js"></script> -->
  <script type="text/javascript" src="lib/bluebird.browserified.bundle.js"></script>
  <script>
    logger.log("Bundle_BBIRD", Bundle_BBIRD);

    const bluebird = Bundle_BBIRD.bluebird;
  </script>
  <!-- <script>
      //discovery
      const arr_promise = [...Array(10).keys()].map(index => {
        return bluebird.delay(index * 1000, index);
      });

      const sum_p = bluebird.reduce(arr_promise, (acc,x) => {
        logger.log("acc", acc);
        return acc + x;
      }, 0);

      sum_p.then(value => {
        logger.log("sum_p", value);
      });
    </script> -->


  <!-- query variables -->
  <script>

    function getQueryVariable(variable)
    {
      var query = window.location.search.substring(1);
      var vars = query.split("&");
      for (var i=0;i<vars.length;i++) {
              var pair = vars[i].split("=");
              if(pair[0] == variable){return pair[1];}
      }
      return(false);
    }

    function getQueryVariablesDict()
    {
      const query = window.location.search.substring(1);  //remove starting string '?' 
      logger.log("logQuery", "query:", query);
      const arr__var_kv = query.split("&");
      const dict_kv = arr__var_kv.reduce((acc, str_kv) => {
        var [k,v] = str_kv.split("=");
        switch(k) {
          case "challenge":
          case "worldType":
            //don't try to math.parse
            break;
          default:
          {
            if(v != null) {
              const mathNode = math.parse(v);
              if(mathNode != null) {
                v = mathNode;
              }
            }
          }
          break;
        }
        acc[k] = v;
        return acc;
      }, {});
      logger.log("logQuery", "dict_kv:", dict_kv);
      return dict_kv;
    }

  </script>
  <script>
    globalsSingleton.dict_query_var = getQueryVariablesDict();
  </script>



  
  <!-- <canvas id="myCanvas">Your browser does not support HTML5 canvas</canvas> -->
  <style>
    #container__for_canvases {
      position: relative;
      border: 0px solid black;
      width:  100%;
      height: 100%;
    }

    #myCanvas {
      position: absolute;
      left: 0;
      top: 0;
      border: 0px solid green;
      width: 100%;
      height: 100%;
    }

    #innerContainer__for_hud_canvas {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      border: 0px solid red;
    }

    #hudCanvas {
      opacity: .5;
    }
  </style>
  <div id="container__for_canvases">
    <canvas id="myCanvas">
    <div id="innerContainer__for_hud_canvas">
      <canvas id="hudCanvas">
    </div>
  </div>
  <script>
    const canvas  = document.getElementById("myCanvas");
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
  </script>

  <!-- <script>
    Dropzone.autoDiscover = false;
    //const dropzone = new Dropzone("canvas#myCanvas", { url: "/file/post" });
    //const dropzone = new Dropzone("canvas#myCanvas", { 
    const dropzone = new Dropzone("div#container__for_canvases", { 
      url: "/",
      addRemoveLinks: true,
      acceptedFiles: "image/jpeg, image/png, image/avif",
      maxFileSize: 10, //MB
      maxFiles: 10,
      init: function() {

        this.on("addedFile", function(file) {
          logger.log("logDropZone", "addedFile", "file:", file);
        });

        this.on("removedFile", function(file) {
          logger.log("logDropZone", "removedFile", "file:", file);
        });

      },
    });

    logger.log("logDropZone", "dropzone:", dropzone);
  </script> -->

  <!-- <script>
    {
      const canvas = document.getElementById("myCanvas");
      panzoom(canvas);
    }  
  </script> -->

  <!-- <style>
    #rendererCanvas {
      position: absolute;
      left: 0;
      top:  0;
      border: 0px solid green;
      width:  100%;
      height: 100%;
    }
  </style> -->
  <!-- <canvas id="rendererCanvas"></canvas> -->

  <!-- 3DRoom -->
  <!-- <div id="renderer">
  </div> -->


  <!-- debug -->
  <div id="debug_container" style="position:absolute; left:0; top: 0; font-size: 60px; pointer-events: none;">
    <div>
      <div style="display: inline-block;">current scale: </div>
      <div style="display: inline-block;" id="debug_scale"></div>
    </div>
    <div>
      <div style="display: inline-block;">offset: </div>
      <div style="display: inline-block;" id="debug_offset"></div>
    </div>
    <div>
      <div style="display: inline-block;">nb objects: </div>
      <div style="display: inline-block;" id="debug_nbObjects"></div>
    </div>
    <div>
      <div style="display: inline-block;">current object rect: </div>
      <div style="display: inline-block;" id="debug_currObjRect"></div>
    </div>
    <div>
      <div style="display: inline-block;">activeColor: </div>
      <div style="display: inline-block;" id="debug_activeColor">" "</div>
    </div>
  </div>

  <script>
    class Debug {
      constructor(eltsDict) {
        this.eltsDict = eltsDict;

        this.eltsDict["container"].style.visibility = "hidden";
      }

      setScale(scale) {
        this.eltsDict["scale"].innerHTML = JSON.stringify(scale);
      }
      setOffset(offset) {
        this.eltsDict["offset"].innerHTML = JSON.stringify(offset);
      }
      setNbObjects(nb_objects) {
        this.eltsDict["nb_objects"].innerHTML = nb_objects;
      }
      setCurrentObjectRect(current_object_rect) {
        this.eltsDict["current_object_rect"].innerHTML = JSON.stringify(current_object_rect);
      }

      setActiveColor(color) {
        this.eltsDict["active_color"].style.backgroundColor = color;
      }

    }

    const debugEltsDict = {
      container: document.getElementById("debug_container"),

      scale: document.getElementById("debug_scale"),
      offset: document.getElementById("debug_offset"),
      nb_objects: document.getElementById("debug_nbObjects"),
      current_object_rect: document.getElementById("debug_currObjRect"),

      active_color: document.getElementById("debug_activeColor"),
    };
    const debug = new Debug(debugEltsDict);

  </script>




  <script>

    /**** model  ****/

    const RedrawOccasion = {
      // "forceRedraw"   : 0,
      "forceRedraw": "forceRedraw",


      // "offsetChanged" : 10,
      "offsetChanged": "offsetChanged",
      // "scaleChanged"  : 11,
      "scaleChanged": "scaleChanged",
      "orientationChanged": "orientationChanged",


      // "objectAdded"   : 20,
      "objectAdded": "objectAdded",
      "pureObjectAdded": "pureObjectAdded",

      "objectRemoved": "objectRemoved",



      // "windowResize"  : 100,
      "windowResize": "windowResize",

      "animation_bounce": "animation_bounce", 
    };


    class InfiniteCanvas {

      constructor(canvas, inputProperties) {

        this.canvas = canvas;
        this.inputProperties = inputProperties;

        //--properties

        this.coords_initial = {
          scale: {
            X: 1,
            Y: 1,
          },
          offset: {
            dx: 0,
            dy: 0,
          },
          orientation: 0,
        };

        // coordinates of our cursor
        this.cursor = {
          x: 0,
          y: 0,
        };
        this.previousCursor = Object.assign({}, this.cursor);


        // distance from origin
        this.offset = Object.assign({}, this.coords_initial.offset);
        this.previousOffset = Object.assign({}, this.offset);
        this.dOffset = {
          dx: 0,
          dy: 0,
        };

        // zoom amount
        this.scale = Object.assign({}, this.coords_initial.scale);
        // this.rx_scale_subject    = new Subject();
        // this.rx_scale_observable = rx_scale_subject.asObservable();

        this.orientation = this.coords_initial.orientation;

        this.didUpdateListeners = [];


        //--objects

        this.icObjects = {
          any: [],
        };
        this.didAddObjectListeners = [];

        this.pure_icObjects = {
          any: [],
        };
        this.didAddPureObjectListeners = [];

        this.creationManagers = {};

        this.dict_pov = {};



        this.represented = {};
        this.didAddRepresentedListeners = [];
        this.didRemoveRepresentedListeners = [];

        this.representations = {};
        this.didAddRepresentationListeners = [];


        this.didUpdateListenersDict = {
          // "objectAdded": [],
          "scaleChanged": [],
        };

        this.requestSyncWithIcObjListeners = [];

        this.icObjListeners = [];       //listen to all objects
        this.icObjListeners__dict = {}; //listen to specific object


        this.redrawCanvasListeners = [];
        this.setupRedrawConditions();

        this.counter = 0;
        this.counter__freeDrawing_frameskip = 0;
        this.counter__freeDrawing_once = 0;



        this.configureInitialIcObjects();

        this.isZIndexEditing = false;

        this.isNumberTyping         = false;
        this.mathField_numberTyping = null;
        this.mathNode_numberTyping  = null;

        this.isIOPasting            = false;
        this.isBatchPasting         = false;

        this.isAltering             = false;
        this.isDeepAltering         = false;

        this.lock_homeScale_isActive = false;

        this.isFreeDrawingPan      = false;
        this.hasBeenFreeDrawingPan = false;

        this.isObjectHoldingPan      = false;
        this.hasBeenObjectHoldingPan = false;

        this.isZScrollingPan      = false;
        this.hasBeenZscrollingPan = false;

        this.isZSegmentDrawingMode              = false;
        this.isZSegmentDrawingMode_zPointMoving = false;
        this.id__zSegment                       = -1;
        this.id__zPointMoving                   = -1;

        this.adhesive__support__icObj = null;
        this.adhesive__isAdhesiveKick = false;


        this.isCombSetup            = false;
        this.step__combSetup        = 0;
        // this.counter__comb          = 0;

        this.isColorPickerAvailable         = true;
        this.isApparentWidthPickerAvailable = true;

        this.isDryScrolling         = false;

        this.isTransportationMode = false;
        this.isPovBeing_setPovd__portal_crossing = false;

        this.counter__event = 1;  //shu: this starts at 1

        // this.isRecording = false;
        this.isRecording_subject = new Rx.BehaviorSubject(false);
        this.isRecording_observable = this.isRecording_subject.asObservable();
        this.rx_icEvent_subject = new Rx.Subject();
        this.rx_icEvent_observable = this.rx_icEvent_subject.asObservable();

        // this.isRecordingPathmade_subject    = new Rx.BehaviorSubject(false);
        // this.isRecordingPathmade_observable = this.isRecordingPathmade_subject.asObservable();

        this.rx_icPathmadeOperator_subject = new Rx.Subject();
        this.rx_icPathmadeOperator_observable = this.rx_icPathmadeOperator_subject.asObservable();



        this.index__counter = 1;

        this.debug__offset__pdf_load = 0;


        //--track changes

        // this.lastChangeTimestamp = null;
        this.changed = false;



        var mySaveTimeout = null;

        const infiniteCanvas = this;
        window.addEventListener("beforeunload", (e) => {
          console.log("beforeunload", e);

          if (infiniteCanvas.changed /*&& !infiniteCanvas.leaveWithoutSaving*/) {

            const infiniteCanvas = this;
            const infinishute_p = this.createInfinishute_p();

            function userStaysOnPage() {
              infiniteCanvas.manageSaveInfinishute_p_2(infinishute_p);
            }

            setTimeout(function () {                   //the nested setTimeout is the working way :)
              mySaveTimeout = setTimeout(() => {
                userStaysOnPage();
              }, 100);
            }, 1);

          }

        });

        window.addEventListener('unload', function onUnload(e) {
          console.log("onUnload", e);
          clearTimeout(mySaveTimeout);
        });

      }
      get isRecording() {
        return this.isRecording_subject.value;
      }
      set isRecording(value) {
        this.isRecording_subject.next(value);
      }




      setChanged(changed) {
        //uncomment for promptWhenUnsavedChanges
        // this.changed = changed;
        this.changed = false;


        if (this.changed) {
          window.onbeforeunload = () => {
            return "You have unsaved changes;";
          };

        } else {
          window.onbeforeunload = null;
        }

      }

      //properties

      update(propName, newValue) {
        const oldValue = this[propName];
        this[propName] = newValue;
        this.didUpdate(propName, oldValue, newValue);
      }

      didUpdate(propName, oldValue, newValue) {
        this.didUpdateListeners.forEach((listener, i) => {
          listener(this, propName, oldValue, newValue);
        });
      }


      //objects
      //creation

      pollNextAvailableId() {   //no side effect
        var id__new;
        const id_added__max = this.getId__max();

        if(this.counter < id_added__max) {
          id__new = id_added__max + 1;
        } else {
          id__new = this.counter + 1; 
        }

        return id__new;
      }

      generateIcObjectId() {   //with side effect
        var id__new;

        id__new = this.pollNextAvailableId();

        this.counter = id__new;
         
        return id__new;
      }

      generateIcEventIndex() {
        const id = this.counter__event;
        this.counter__event += 1;
        return id;
      }

      createIcObject(type, position, size, homeScale) {

        const id = this.generateIcObjectId();

        const icObj = new IcObject(id, type, position, size, homeScale);
        return icObj;

        // return this.createRepresentedIcObject(icObj);
      }

      createRepresentedIcObject(icObj) {

        var icObj__represented;

        if (icObj.type == "composite"
          || icObj.type == "compositeSegment") {


          //create represented for content (if needed)
          var content__represented;
          var content__rep_official;
          var content__rep_free;

          const content    = icObj.content;

          if(content != null) {
            const id_content = content.id;
            const represented_check__content = this.getRepresented(id_content);

            if (represented_check__content != null) {
              logger.log("represented already added for content", content);

              content__represented  = represented_check__content;
              content__rep_official = content__represented.r_official();
              content__rep_free     = content__represented.r_free();

            } else {

              logger.log("create represented for content", content);

              content__represented  = this.createRepresentedIcObject(content);
              content__rep_official = content__represented.r_official();
              content__rep_free     = content__represented.createNewRepresentation("free");
              if (content__rep_free.nowHeld == null) {
                content__rep_free.addInteraction_hold();
              }

            }

          }


          //create represented for parts (if needed)
          const parts__represented  = {};
          const parts__rep_official = {};
          const parts__rep_free     = {};

          const parts = icObj.parts;

          Object.entries(parts)
            .forEach(([partName, part_icObj], i) => {

              const id_icObj = part_icObj.id;
              const represented_check = this.getRepresented(id_icObj);
              if (represented_check != null) {
                logger.log("represented already added for part", part_icObj);

                // if(part_icObj.isMobile) {
                const part__represented  = represented_check;
                const part__rep_official = part__represented.r_official();
                const part__rep_free     = part__represented.r_free();
                // if(part__rep_free.holdListeners == null) {
                //   part__rep_free.addInteraction_hold();
                // }
                // }

                parts__represented[partName]  = part__represented;
                parts__rep_official[partName] = part__rep_official;
                parts__rep_free[partName]     = part__rep_free;
                // icObj__represented.compositeConfig.parts[partName]  = part__represented;
                // icObj__rep_official.compositeConfig.parts[partName] = part__rep_official;
                // icObj__rep_free.compositeConfig.parts[partName]     = part__rep_free;

              } else {
                logger.log("create represented for part", part_icObj);

                const part__represented  = this.createRepresentedIcObject(part_icObj);
                const part__rep_official = part__represented.r_official();
                const part__rep_free     = part__represented.createNewRepresentation("free");
                if (part__rep_free.nowHeld == null) {
                  part__rep_free.addInteraction_hold();
                }

                parts__represented[partName]  = part__represented;
                parts__rep_official[partName] = part__rep_official;
                parts__rep_free[partName]     = part__rep_free;

              }

            });


          //create representations
          icObj__represented = RepresentedFactory.initial(icObj);
          icObj__represented.parts   = parts__represented;

          const icObj__rep_official = icObj__represented.r_official();
          icObj__rep_official.parts   = parts__rep_official;

          const icObj__rep_free = icObj__represented.createNewRepresentation("free");
          icObj__rep_free.parts   = parts__rep_free;
          icObj__rep_free.addInteraction_hold();

          if(content != null) {
            icObj__represented.content  = content__represented;
            icObj__rep_official.content = content__rep_official;
            icObj__rep_free.content     = content__rep_free;
          }

        } else {

          //create representations
          icObj__represented = RepresentedFactory.initial(icObj);
          const icObj__rep_official = icObj__represented.r_official();
          const icObj__rep_free     = icObj__represented.createNewRepresentation("free");
          icObj__rep_free.addInteraction_hold();
        }

        return icObj__represented;
      }

      tetherIcObject(represented) {
        // logger.log("tetherIcObject", represented.r_official().id);

        const infiniteCanvas = this;

        // icObj.didUpdateListeners.push((icObj, requestCanvasRedraw) => {
        //   infiniteCanvas.manageIcObjUpdate(icObj, requestCanvasRedraw);
        // });

        //report updates
        const rep_official = represented.r_official();
        rep_official.onOuterUpdate((rep_official, updateDict) => {
          // console.log("rep_official", "onOuterUpdate", rep_official);
          infiniteCanvas.icObjDidUpdate(rep_official, updateDict);
        });

        //await object death
        const death_handler = (rep_official_incoming, outerUpdatesDict) => {
          // logger.log("death_handler", rep_official_incoming, outerUpdatesDict);

          const isDead = (outerUpdatesDict["im_dead_now"] != null) && (outerUpdatesDict["im_dead_now"].new == true);
          if (isDead) {
            const represented = rep_official_incoming.represented;
            // logger.log("isDead", represented.r_official().id);

            if (represented.r_official() != null) {  //SHU666: deeper into sadness
              var shouldAlsoRemoveChildren = represented.r_official().shouldAlsoRemoveChildren ? represented.r_official().shouldAlsoRemoveChildren : false;

              infiniteCanvas.removeRepresented(represented, shouldAlsoRemoveChildren);

              infiniteCanvas.offIcObjUpdate(death_handler);
            }

          }
        };
        infiniteCanvas.onIcObjUpdate(death_handler);


        //official rep follows free rep
        const rep_free = represented.r_free();
        rep_official.follow(rep_free);

      }

      untetherIcObject(represented) {
        const infiniteCanvas = this;

        const rep_official = represented.r_official();
        rep_official.offAllOuterUpdates();

        const rep_free = represented.r_free();
        rep_official.unfollow(rep_free);
      }





      introduceToExistingObjects(represented) {

        //introduce object to existing touchSlots
        this.introduceToExistingType_touchSlot(represented);

        const type__represented = represented.r_official().type;

        switch (type__represented) {
          case "touchSlot":
          case "dropTouchSlot":
          case "diveSlot":

          case "pokeSlot":
            {
              //introduce touchslot to existing objects

              const touchSlot    = represented.r_official();
              const id_touchSlot = touchSlot.id;

              const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());

              arr_official.forEach((rep_official, i) => {
                rep_official.touchStateDict[id_touchSlot] = TouchState.Untouched;
              });
            }
            break;
          default:
            break;
        }

      }

      introduceToExistingType_touchSlot(represented) {

        const rep_official__incoming = represented.r_official();

        // const existing_type = "touchSlot";

        const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
        // const arr_official_exisitingType = arr_official.filter(rep => (rep.type == existing_type));
        const arr_official_exisitingType = arr_official.filter(rep => {
          var outBool;

          outBool = (rep.type == "touchSlot") 
                 || (rep.type == "dropTouchSlot") 
                 || (rep.type == "diveSlot")
                 
                 || (rep.type == "pokeSlot");

          return outBool;
        });

        arr_official_exisitingType.forEach((rep, i) => {

          const id_touchSlot = rep.id;

          if (rep_official__incoming.touchStateDict[id_touchSlot] == null) {
            rep_official__incoming.touchStateDict[id_touchSlot] = TouchState.Untouched;
          }
          //SHU TODO: check if touches

        });

      }

      extroduceFromExistingObjects(represented) {
        console.log("extroduceFromExistingObjects", represented);

      }




      getRepresented(id) {
        return this.represented[id];
      }

      getAllRepresentedWithType(type) {
        const arr_represented = this.getArrRepresented().filter(represented => {
          const rep_official = represented.r_official();
          const isRequestedType = (rep_official.type == type);
          return isRequestedType;
        });
        return arr_represented;
      }

      getArr_represented() {
        return Object.values(this.represented);
      }

      getArr_icObj(repName = "official") {
        return this.getArr_represented().map(represented => {
          const rep = represented.getRepresentation(repName);
          return rep;
        });
      }

      getArr_icObj__containingPoint(repName = "official", truePoint) {
        return this.getArr_icObj(repName).filter((rep_x__icObj) => {
          return Geometry.isPointContainedInRect(truePoint, rep_x__icObj.getTrueRect2());
        });
      }

      getArr_icObj__intersecting(repName = "official", icObj) {
        return this.getArr_icObj(repName).filter((rep_x__icObj) => {
          //SHU TODO: rect intersection
          // return Geometry.rect;
          return (rep_x__icObj.id != icObj.id);
        });
      }

      getArrIcPoint_near(pos, repName = "official") {
        const arr_icObj = this.getArr_icObj(repName);
        const arr_icPoint = arr_icObj.filter(icObj => icObj.type == "point");
        const arr_icPoint__near = arr_icPoint.filter(icPoint => {
          const radius = 10;
          const isNear = Geometry.distance(icPoint.position, pos) < radius;
          return isNear;
        });
        return arr_icPoint__near;
      }


        //around neveremptiness

      isEmptyScreenPov() {
        const repName = "free";

        const pov__screen = this.getCurrentPov();
        const trueRect__screenPov = pov__screen.getTrueRect2();
        const arr_icObj__intersecting = this.getArr_icObj__intersectingTrueRect(repName, trueRect__screenPov);

        const isEmpty = (arr_icObj__intersecting.length == 0);
        return isEmpty;
      }

      isEmptyScreenPov__noticeablyWise() {
        const repName = "free";

        const pov__screen = this.getCurrentPov();
        const trueRect__screenPov = pov__screen.getTrueRect2();
        const arr_icObj__intersecting__noticeable = this.getArr_icObj__intersectingTrueRect__noticeable(repName, trueRect__screenPov);

        const isEmpty = (arr_icObj__intersecting__noticeable.length == 0);
        return isEmpty;
      }

      getArr_icObj__intersectingTrueRect(repName = "official", trueRect) {
        
        const func__isIntersecting = function(rep_x__icObj) {
          const trueRect__icObj = rep_x__icObj.getTrueRect2();

          const isIntersecting = Geometry.intersectRect(Geometry.createLRRect(trueRect__icObj), Geometry.createLRRect(trueRect));
          // logger.log("logNeveremptiness", {
          //   "trueRect__icObj": trueRect__icObj,
          //   "trueRect":        trueRect,
          // });

          // logger.log("logNeveremptiness", "isIntersecting:", isIntersecting);
          return isIntersecting;
        };

        return this.getArr_icObj(repName).filter(func__isIntersecting);
      }

      getArr_icObj__intersectingTrueRect__noticeable(repName = "official", trueRect) {

        const func__isIntersecting = function(rep_x__icObj) {
          const trueRect__icObj = rep_x__icObj.getTrueRect2();
          const isIntersecting = Geometry.intersectRect(Geometry.createLRRect(trueRect__icObj), Geometry.createLRRect(trueRect));
          return isIntersecting;
        };

        const trueSize__pixel = this.getTrueSize__forScreenPixel();
        const func__isNoticeable = function(rep_x__icObj) {

          // const isMoreThanAPixelWide = rep_x__icObj.getTrueRect2().width  > trueSize__pixel.width;
          // const isMoreThanAPixelTall = rep_x__icObj.getTrueRect2().height > trueSize__pixel.height;

          const isMoreThanAPixelWide = rep_x__icObj.getTrueRect2().width  > (trueSize__pixel.width  / 2);
          const isMoreThanAPixelTall = rep_x__icObj.getTrueRect2().height > (trueSize__pixel.height / 2);

          // const isMoreThanAPixelWide = rep_x__icObj.getTrueRect2().width  > (trueSize__pixel.width  / 2.01);
          // const isMoreThanAPixelTall = rep_x__icObj.getTrueRect2().height > (trueSize__pixel.height / 2.01);

          // const isMoreThanAPixelWide = rep_x__icObj.getTrueRect2().width  > (trueSize__pixel.width  / 10.0);
          // const isMoreThanAPixelTall = rep_x__icObj.getTrueRect2().height > (trueSize__pixel.height / 10.0);

          const isNoticeable = isMoreThanAPixelWide || isMoreThanAPixelTall;
          return isNoticeable;
        };
        
        // return this.getArr_icObj(repName).filter(func__isNoticeable).filter(func__isIntersecting);
        return this.getArr_icObj(repName).filter(func__isIntersecting).filter(func__isNoticeable);
      }

      getScreenSize__forScreenPixel() {
        const nb_pixels__width  = screen.width; 
        const nb_pixels__height = screen.height;

        const size__canvas = this.getCanvasSize();

        const size__pixel = {
          width:  size__canvas.width  / nb_pixels__width,
          height: size__canvas.height / nb_pixels__height,
        };

        return size__pixel;
      }
      
      getTrueSize__forScreenPixel() {
        const size__pixel = this.getScreenSize__forScreenPixel();

        const trueSize__pixel = {
          width:  size__pixel.width  * 1.0 / infiniteCanvas.scale.X,
          height: size__pixel.height * 1.0 / infiniteCanvas.scale.Y,
        };

        return trueSize__pixel;
      }

        //around nevercompleteness

      isCompleteScreenPov() {
        //maybe one day
        throw new Error("Not implemented yet");
      }

      isCompleteScreenPov__noticeablyWise() {
        var outBool; 

        const repName = "free";

        const icObj__completenessObject = this.getIcObj__completenessObject();
        logger.log("logCompleteness", "icObj__completenessObject:", icObj__completenessObject);


        if(icObj__completenessObject != null) {

          //check if there is no noticeable object other than the completeness
          
          const pov__screen         = this.getCurrentPov();
          const trueRect__screenPov = pov__screen.getTrueRect2();
          const arr_icObj__intersecting__noticeable = this.getArr_icObj__intersectingTrueRect__noticeable(repName, trueRect__screenPov);
  
          const arr_icObj__intersecting__noticeable__withoutCompletenessObj = arr_icObj__intersecting__noticeable.filter((icObj) => {
            return icObj != icObj__completenessObject;
          });
          logger.log("logCompleteness", "arr_icObj__intersecting__noticeable__withoutCompletenessObj:", arr_icObj__intersecting__noticeable__withoutCompletenessObj);

          const isEmpty = (arr_icObj__intersecting__noticeable__withoutCompletenessObj.length == 0);

          outBool = isEmpty;
        } else {
          outBool = false;
        }

        return outBool;
      }

      getTrueSize__forObjectPixel(icObj) {
        const trueRect__icObj = icObj.getTrueRect2();

        const trueSize__pixel = {
          width:  trueRect__icObj.width  / icObj.size.width,
          height: trueRect__icObj.height / icObj.size.height,
        };

        return trueSize__pixel;
      }

      isCompletenessObject(icObj) {
        const infiniteCanvas = this;

        //condition1: screenPov is intersecting icObj
        const pov__screen         = this.getCurrentPov();
        const trueRect__screenPov = pov__screen.getTrueRect2();

        const trueRect__icObj     = icObj.getTrueRect2();
        
        // const isIntersectingWithScreenPov = Geometry.intersectRect(Geometry.createLRRect(trueRect__icObj), Geometry.createLRRect(trueRect__screenPov));
        const isIntersectingWithScreenPov = true;

        //condition2: icObj is not overlooked
        const isOverlooked = false;

        //condition3: screenPov is unnoticeable wrt icObj
        const isScreenPovNoticeableWrtObj = func__isScreenPovNoticeableWrtObj(icObj);

        function func__isScreenPovNoticeableWrtObj(icObj) {

          const trueSize__pixel__icObjWise = infiniteCanvas.getTrueSize__forObjectPixel(icObj);

          const pov__screen = infiniteCanvas.getCurrentPov();

          const trueRect__screenPov = pov__screen.getTrueRect2();
          const trueSize__screenPov = {
            width:  trueRect__screenPov.width,
            height: trueRect__screenPov.height,
          };

          // logger.log("logCompleteness", "isScreenPovNoticeable", {
          //   "trueSize__screenPov": trueSize__screenPov, 
          //   "trueSize__pixel__icObjWise": trueSize__pixel__icObjWise,
          // });

          const isMoreThanAPixelWide = trueSize__screenPov.width  > trueSize__pixel__icObjWise.width;
          const isMoreThanAPixelTall = trueSize__screenPov.height > trueSize__pixel__icObjWise.height;

          // const isMoreThanAPixelWide = trueSize__screenPov.width  > (trueSize__pixel__icObjWise.width  / 2);
          // const isMoreThanAPixelTall = trueSize__screenPov.height > (trueSize__pixel__icObjWise.height / 2);

          // const isMoreThanAPixelWide = trueSize__screenPov.width  > (trueSize__pixel__icObjWise.width  / 2.01);
          // const isMoreThanAPixelTall = trueSize__screenPov.height > (trueSize__pixel__icObjWise.height / 2.01);

          // const isMoreThanAPixelWide = trueSize__screenPov.width  > (trueSize__pixel__icObjWise.width  / 5.0);
          // const isMoreThanAPixelTall = trueSize__screenPov.height > (trueSize__pixel__icObjWise.height / 5.0);

          // const isMoreThanAPixelWide = trueSize__screenPov.width  > (trueSize__pixel__icObjWise.width  / 10.0);
          // const isMoreThanAPixelTall = trueSize__screenPov.height > (trueSize__pixel__icObjWise.height / 10.0);

          const isNoticeable = isMoreThanAPixelWide || isMoreThanAPixelTall;
          return isNoticeable;
        };

        const isCompletenessObject = isIntersectingWithScreenPov && !isOverlooked && !isScreenPovNoticeableWrtObj;

        return isCompletenessObject;
      }

      getIcObj__completenessObject() { //may return null
        var outIcObj;
        
        const pov__screen         = this.getCurrentPov();
        const trueRect__screenPov = pov__screen.getTrueRect2(); 
        
        //get candidate objects
        // const repName = "free";
        // const arr_icObj__intersectingScreenPov__noticeable = this.getArr_icObj__intersectingTrueRect__noticeable(repName, trueRect__screenPov);
        // outIcObj = arr_icObj__intersectingScreenPov__noticeable.find((icObj) => {
        //   return this.isCompletenessObject(icObj);
        // });

        const icObj__eminentObject = this.getIcObj__eminentObject();
        if(icObj__eminentObject != null) {
          outIcObj = [icObj__eminentObject].find((icObj) => {
              return this.isCompletenessObject(icObj);
          });
        }

        return outIcObj;
      }

        //around eminence

      getIcObj__eminentObject() {

        const pov__screen         = this.getCurrentPov();
        const trueRect__screenPov = pov__screen.getTrueRect2(); 
        
        //get candidate objects
        const repName = "free";
        const arr_icObj__intersectingScreenPov__noticeable = this.getArr_icObj__intersectingTrueRect__noticeable(repName, trueRect__screenPov);

        //get objects that have a container/content relationship with screenPov
        function func__is1Inside2(objOrPov1, objOrPov2) {
          const trueRect__objOrPov1 = objOrPov1.getTrueRect2();
          const trueRect__objOrPov2 = objOrPov2.getTrueRect2();
          return Geometry.isRectFullyContainedInRect(trueRect__objOrPov1, trueRect__objOrPov2);
        }
        const arr__with_inout_relationship = arr_icObj__intersectingScreenPov__noticeable.filter((icObj) => {
          // const isIcObjInScreenPov = func__is1Inside2(icObj, pov__screen);
          // logger.log("logEminent", "isIcObjInScreenPov:", isIcObjInScreenPov);

          // const isScreenPovInIcObj = func__is1Inside2(pov__screen, icObj);
          // logger.log("logEminent", "isScreenPovInIcObj:", isScreenPovInIcObj);

          // return isIcObjInScreenPov || isScreenPovInIcObj;
          return func__is1Inside2(icObj, pov__screen) || func__is1Inside2(pov__screen, icObj);
        });

        //sort by trueArea
        const arr__sorted_by_trueArea__descending = arr__with_inout_relationship.toSorted((icObj1, icObj2) => {
          const trueRect__obj1 = icObj1.getTrueRect2();
          const trueRect__obj2 = icObj2.getTrueRect2();

          const trueArea__icObj1 = trueRect__obj1.width * trueRect__obj1.height; 
          const trueArea__icObj2 = trueRect__obj2.width * trueRect__obj2.height;

          return trueArea__icObj2 - trueArea__icObj1;  //descending order
        });

        //pick first
        const icObj__eminentObject = arr__sorted_by_trueArea__descending.find(e => true);

        return icObj__eminentObject;
      }






      getRootCompositeForContentOrPart(icObj__part) {  //recursively seek parent composite
        if(icObj__part.compositeId != -1) {
          const icObj__composite = this.getParentCompositeForContentOrPart(icObj__part);
          return this.getRootCompositeForContentOrPart(icObj__composite);
        } else {
          return icObj__part;
        }
      }

      getParentCompositeForContentOrPart(icObj__part, representation = "official") {
        const icObj__composite = this.getRepresented(icObj__part.compositeId).getRepresentation(representation);
        return icObj__composite;
      }

      getClosestCompositeForContentOrPart(icObj__part, representation = "official") { //can return icObj__part itself
        var outIcObj;
        if(icObj__part.type == "composite") {
          outIcObj = icObj__part;
        } else {
          outIcObj = this.getParentCompositeForContentOrPart(icObj__part, representation);
        }
        return outIcObj;
      }

      getEntity(icObj, representation = "official") {
        logger.log("logEntity", "getEntity", icObj);
        var outIcObj;
        if(icObj.isEntity) {
          return icObj;
        } else {
          const icObj__composite = this.getParentCompositeForContentOrPart(icObj);
          return this.getEntity(icObj__composite, representation);
        }
        return outIcObj;
      }

      getId__max() {
        return this.getArr_icObj().map((icObj) => icObj.id).reduce((acc, x) => {
          return math.max(acc, x);
        }, -1);
      }

      getId__fresh() {
        return this.getId__max() + 1;
      }


      getCandidateSupportForIcObj(icObj) {
        var outIcObj;

        const fObj = fabricIntegration.getFObjForIcObj(icObj);
        const arr_icObj__other = this.getArr_icObj("free").filter(icObj_el => (icObj_el != icObj));
        outIcObj = arr_icObj__other.reduce((acc, x) => {
          const fObj__x = fabricIntegration.getFObjForIcObj(x);
          // const isIntersecting = infiniteCanvas.checkIntersecting([x, icObj]);
          const isIntersecting = fObj.intersectsWithObject(fObj__x);
          // logger.log("logAdh", "getCandidateSupportForIcObj", "isIntersecting:", isIntersecting);
          if(isIntersecting) {
            if(acc == null) {
                acc = x;
            } else if( (x.zIndex < icObj.zIndex) && (x.zIndex > acc.zIndex) )  {
              acc = x;
            } else {
              //ignore
            }
          }
          return acc;
        }, null);

        return outIcObj;            
      }

      getCandidateSupportUnderPoint(truePoint, icObj_to_adhere) {
        var outIcObj;

        const arr_icObj = this.getArr_icObj__containingPoint("free", truePoint).sort((icObj1, icObj2) => (icObj1.zIndex < icObj2.zIndex));
        outIcObj = arr_icObj.find((icObj) => (icObj.zIndex < icObj_to_adhere.zIndex));

        return outIcObj;            
      }

      getApplyCandidateForIcObj(icObj) {
        var outIcObj;

        const fObj = fabricIntegration.getFObjForIcObj(icObj);
        const arr_icObj__other = this.getArr_icObj("free").filter(icObj_el => (icObj_el != icObj));
        // const arr_appOp        = arr_icObj__other.filter(icObj_el => icObj_el.type == "applySlot");
        outIcObj = arr_icObj__other.reduce((acc, x) => {
          const fObj__x = fabricIntegration.getFObjForIcObj(x);
          // const isIntersecting = infiniteCanvas.checkIntersecting([x, icObj]);
          const isIntersecting = fObj.intersectsWithObject(fObj__x);
          // logger.log("logAdh", "getCandidateSupportForIcObj", "isIntersecting:", isIntersecting);
          if(isIntersecting) {
            if(acc == null) {
                acc = x;
            } 
            // else if( (x.zIndex < icObj.zIndex) && (x.zIndex > acc.zIndex) )  {
            //   acc = x;
            // } else {
            //   //ignore
            // }
          }
          return acc;
        }, null);

        if(outIcObj != null && outIcObj.isCompositeContentOrPart()) {
          const closestParent = infiniteCanvas.getParentCompositeForContentOrPart(outIcObj, "free");
          if(closestParent != null) {
            outIcObj = closestParent;
          }
        }

        return outIcObj;            
      }


      getArr_icObj__underCursor(repName = "official") {
        const true_cursor = infiniteCanvas.getTrueCursor();
        const arr_icObj = infiniteCanvas.getArr_icObj__containingPoint(repName, true_cursor);
        return arr_icObj;
      }

      getIcObj__underCursor(repName = "official") {
        const icObj = infiniteCanvas.getArr_icObj__underCursor(repName).find(e => true);
        return icObj;
      }



      createIcRect_withLTWH(left, top, width, height) {

        const type      = "rect";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;
      }

      createIcRect_withLTRB(left, top, right, bottom) {
        const width  = right - left;
        const height = bottom - top;
        const icRect = this.createRect_withLTWH(left, top, width, height);

        return icRect;
      }

      createIcRect(trueRect) {

        const type      = "rect";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;
      }

      createIcRect__backingPov(pov) {

        // const trueRect   = pov.getTrueRect2();
        const screenRect = pov.getScreenRect();

        // const icRect  = this.createIcRect(trueRect);
        const icRect  = this.createIcRect(screenRect); 

        icRect.zIndex    = -300;
        icRect.homeScale = Object.assign({}, pov.scale);

        return icRect;
      }

      createIcPOVRect(trueRect, orientation = 0) {

        const type      = "povRect";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);
        // const homeScale = Object.assign({}, {X: 1.0, Y: 1.0});

        const icObj = this.createIcObject(type, position, size, homeScale);

        const fColor__stroke = new fabric.Color("black");
        fColor__stroke.setAlpha(0.777);
        const color__stroke = fColor__stroke.toRgba();

        const icPOVRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,

          isSharpRect: true,

          fill:   "transparent",

          stroke_width: 3,
          stroke: color__stroke,
        };

        const icPOVRect = Object.assign(icObj, icPOVRect_spec);

        return icPOVRect;
      }

      createIcPOVRectStar(trueRect, orientation = 0) {

        const infiniteCanvas = this;

        const scale = this.scale; 

        const width__scaled  = trueRect.width  * 1.0 / scale.X; 
        const height__scaled = trueRect.height * 1.0 / scale.Y;

        //center composite
        const trueRect__center = trueRect;
        const trueRect__up     = Geometry.translatedXYRect(trueRect, {dx: 0, dy: -height__scaled * 1.1});
        const trueRect__down   = Geometry.translatedXYRect(trueRect, {dx: 0, dy: +height__scaled * 1.1});
        const trueRect__left   = Geometry.translatedXYRect(trueRect, {dx: -width__scaled * 1.1, dy: 0});
        const trueRect__right  = Geometry.translatedXYRect(trueRect, {dx: +width__scaled * 1.1, dy: 0});

        const icPOVRect__center = infiniteCanvas.createIcPOVRect(trueRect__center, orientation);
        const icPOVRect__up     = infiniteCanvas.createIcPOVRect(trueRect__up,     orientation);
        const icPOVRect__down   = infiniteCanvas.createIcPOVRect(trueRect__down,   orientation);
        const icPOVRect__left   = infiniteCanvas.createIcPOVRect(trueRect__left,   orientation);
        const icPOVRect__right  = infiniteCanvas.createIcPOVRect(trueRect__right,  orientation);

        const width__button  = trueRect__center.width  * 0.075;
        const height__button = trueRect__center.height * 0.075;
        const width__button__scaled  = width__button  * 1.0 / scale.X; 
        const height__button__scaled = height__button * 1.0 / scale.Y;

        const trueRect__button__down  = {
          x: trueRect__center.x + width__scaled  * 0.85 - width__button__scaled,
          y: trueRect__center.y + height__scaled * 0.95 - height__button__scaled,
          width: width__button,
          height: height__button,
        };
        const trueRect__button__up    = Geometry.translatedXYRect(trueRect__button__down, {dx:                    0, dy: -height__button__scaled * 1.5});
        const trueRect__button__left  = Geometry.translatedXYRect(trueRect__button__down, {dx: -width__button__scaled * 1.5, dy:                     0});
        const trueRect__button__right = Geometry.translatedXYRect(trueRect__button__down, {dx: +width__button__scaled * 1.5, dy:                     0});

        const fColor__fill = new fabric.Color("turquoise");
        fColor__fill.setAlpha(0.666);
        const color__fill = fColor__fill.toRgba();
        const config__gotopov_button = {
          fill: color__fill,
          duration__anim: 50,
        };
        const icButton_gotopov__up    = infiniteCanvas.createIcButton__gotopov(trueRect__button__up,    icPOVRect__up,    config__gotopov_button);
        const icButton_gotopov__down  = infiniteCanvas.createIcButton__gotopov(trueRect__button__down,  icPOVRect__down,  config__gotopov_button);
        const icButton_gotopov__left  = infiniteCanvas.createIcButton__gotopov(trueRect__button__left,  icPOVRect__left,  config__gotopov_button);
        const icButton_gotopov__right = infiniteCanvas.createIcButton__gotopov(trueRect__button__right, icPOVRect__right, config__gotopov_button);

        const parts__center = {
          povRect__center:  icPOVRect__center,

          button_gotopov__up:     icButton_gotopov__up,
          button_gotopov__down:   icButton_gotopov__down,
          button_gotopov__left:   icButton_gotopov__left,
          button_gotopov__right:  icButton_gotopov__right,
        };

        const compositeConfig__center = Compositer.defaultCompositeConfig(parts__center, false);

        const trueRect_composite__center = {
          x: trueRect__center.x + trueRect__center.width  * 0.075,
          y: trueRect__center.y + trueRect__center.height * 0.075,
          width:  trueRect__center.width  * 0.05,
          height: trueRect__center.height * 0.05,
        };

        const icComposite__center = this.createIcComposite(trueRect_composite__center, parts__center, compositeConfig__center);
        icComposite__center.cType = "povRect_star__center";

        
        //main composite
        const parts = {
          composite__center:  icComposite__center,
          
          povRect__up:        icPOVRect__up,
          povRect__down:      icPOVRect__down,
          povRect__left:      icPOVRect__left,
          povRect__right:     icPOVRect__right,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, true);

        const trueRect_composite = {
          x: trueRect__center.x - trueRect__center.width  * 0.075,
          y: trueRect__center.y - trueRect__center.height * 0.075,
          width:  trueRect__center.width  * 0.05,
          height: trueRect__center.height * 0.05,
        };

        const icComposite = this.createIcComposite(trueRect_composite, parts, compositeConfig);
        icComposite.cType = "povRect_star";

        return icComposite;
      }


      createIcPrintPOVRect(trueRect, orientation = 0) {

        const type      = "printPovRect";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);
        // const homeScale = Object.assign({}, {X: 1.0, Y: 1.0});

        const icObj = this.createIcObject(type, position, size, homeScale);

        const fColor__stroke = new fabric.Color("grey");
        fColor__stroke.setAlpha(0.777);
        const color__stroke = fColor__stroke.toRgba();

        const icPOVRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,

          isSharpRect: true,

          fill:   "transparent",

          stroke_width: 3,
          stroke: color__stroke,
        };

        const icPOVRect = Object.assign(icObj, icPOVRect_spec);

        return icPOVRect;
      }

      createIcPortal(trueRect__rect1, trueRect__rect2_in = null) {

        var trueRect__rect2;
        if(trueRect__rect2_in != null) {
          trueRect__rect2 = trueRect__rect2_in;
        } else {
          trueRect__rect2 = {
            x:        trueRect__rect1.x + 1.10 * trueRect__rect1.width,
            y:        trueRect__rect1.y + 0.10 * trueRect__rect1.height,
            width:    trueRect__rect1.width,
            height:   trueRect__rect1.height,
          };
        }

        const icRect1 = infiniteCanvas.createIcRect(trueRect__rect1);
        icRect1.fill    = "blue";
        icRect1.opacity = 0.2;
        icRect1.isSharpRect = true;

        const icRect2 = infiniteCanvas.createIcRect(trueRect__rect2);
        icRect2.fill    = "orange";
        icRect2.isSharpRect = true;

        // icRect2.opacity = 0.3;
        icRect2.opacity = 1.0;


        //main composite
        const parts = {
          "rect__in":  icRect1,
          "rect__out": icRect2,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const trueRect_composite = {
          x: trueRect__rect1.x - trueRect__rect1.width  * 0.075,
          y: trueRect__rect1.y - trueRect__rect1.height * 0.075,
          width:  trueRect__rect1.width  * 0.05,
          height: trueRect__rect1.height * 0.05,
        };
        logger.log("logPortal", "trueRect_composite:", trueRect_composite);

        const icComposite = this.createIcComposite(trueRect_composite, parts, compositeConfig);
        icComposite.cType = "portal";
        // icRect2.isSharpRect = true;


        const icPortal_spec = {
          portalConfig: {

          },
        };

        const icPortal = Object.assign(icComposite, icPortal_spec);

        const engine = new PortalEngine();
        const eType  = "portal";
        const icEngined = infiniteCanvas.installEngineOnIcObj(icPortal, eType, engine);

        return icEngined;
      }


      createIcInnerCamPortal(trueRect__rect1, trueRect__rect2_in = null) {

        var trueRect__rect2;
        if(trueRect__rect2_in != null) {
          trueRect__rect2 = trueRect__rect2_in;
        } else {
          trueRect__rect2 = {
            x:        trueRect__rect1.x + 1.10 * trueRect__rect1.width,
            y:        trueRect__rect1.y + 0.10 * trueRect__rect1.height,
            width:    trueRect__rect1.width,
            height:   trueRect__rect1.height,
          };
        }

        //icEye
        const trueRect_icEye = trueRect__rect1;

        const icEye  = infiniteCanvas.createIcEye(trueRect_icEye);
        logger.log("logPortal", "createIcInnerCamPortal", "icEye:", icEye);
        icEye.zIndex = 100;

        //debug
        infiniteCanvas.addIcObject(icEye);

        //icDisplay
        const trueRect_icDisplay = trueRect__rect2;

        const icDisplay  = infiniteCanvas.createIcDisplay(trueRect_icDisplay);
        logger.log("logPortal", "createIcInnerCamPortal", "icDisplay:", icDisplay);

        infiniteCanvas.onceOnAddRepresentedForIcObject(icDisplay, (icDisplay) => {

            const rep_free__icDisplay = infiniteCanvas.getRepresented(icDisplay.id).r_free();
            const rep_free__icEye     = infiniteCanvas.getRepresented(icEye.id).r_free();

            const rx_signal__in = rep_free__icEye.rx_signal__out;
            
            logger.log("LogDisplay", "setting new rx_signal__in");
            // rep_free__icDisplay.rx_signal__in = rx_signal__in;   //SHU: does not work

            //SHU: workaround:
            //unsubscribe to old signal (if any)                    
            rep_free__icDisplay.rxsub?.unsubscribe();

            rep_free__icDisplay.rxsub = rx_signal__in.subscribe({
              next: (img) => {
                rep_free__icDisplay.img = img;
              },
            });

        });


        //main composite
        const parts = {
          "rect__in":  icDisplay,
          "rect__out": icEye,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const trueRect_composite = {
          x: trueRect__rect1.x - trueRect__rect1.width  * 0.075,
          y: trueRect__rect1.y - trueRect__rect1.height * 0.075,
          width:  trueRect__rect1.width  * 0.05,
          height: trueRect__rect1.height * 0.05,
        };

        const icComposite = this.createIcComposite(trueRect_composite, parts, compositeConfig);
        icComposite.cType = "innerCamPortal";
        // icRect2.isSharpRect = true;


        const icPortal_spec = {
          portalConfig: {

          },
        };

        const icPortal = Object.assign(icComposite, icPortal_spec);

        const engine = new PortalEngine();
        const eType  = "portal";
        const icEngined = infiniteCanvas.installEngineOnIcObj(icPortal, eType, engine);

        return icEngined;
      }



      createIcPoint(point) {
        logger.log("createIcPoint", point);

        const type = "point";
        const position = Geometry.createPoint(point.x, point.y);
        const size = Geometry.createSize(10, 10);
        // const size      = Geometry.createSize(1, 1);

        // const homeScale = null;   // exact geometry objects don't have a homeScale
        const homeScale = { X: 1, Y: 1 };   // exact geometry objects don't have a homeScale


        const icObj = this.createIcObject(type, position, size, homeScale);

        const icPoint_spec = {
          isPoint: true,        //points have a particular relationship with position, size and scale
          isUsingCenterPosition: true,

          "color": "blue",
          "name": "A",

          "fillColor": "black",

          "fill": "orange",

          "pointType": "undefined",
        };

        const icPoint = Object.assign(icObj, icPoint_spec);

        return icPoint;

      }

      createIcSpotPoint(pointCenter, size_in) {
        logger.log("createIcSpotPoint", pointCenter, size_in);

        const type = "spotPoint";
        const position = Object.assign({}, pointCenter);
        const size = Object.assign({}, size_in);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSpot_spec = {
          isUsingCenterPosition: true,

          "color": "blue",
          "name": "S",

          "fillColor": "black",
          "fill": "lime",

          "viewType": "undefined",
        };

        const icSpot = Object.assign(icObj, icSpot_spec);

        return icSpot;
      }

      createIcHUDPoint(point) {
        logger.log("createIcHUDPoint", point);

        const type = "HUD_point";
        const position = Geometry.createPoint(point.x, point.y);
        const size = Geometry.createSize(0, 0);
        // const size      = Geometry.createSize(1, 1);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icPoint_spec = {
          isPoint: true,     //points have a particular relationship with position, size and scale
          isUsingCenterPosition: true,

          "color": "blue",
          "name": "A",

          "fillColor": "black",

          "fill": "orange",

          "pointType": "undefined",
        };

        const icPoint = Object.assign(icObj, icPoint_spec);

        return icPoint;

      }


      createIcCurve3(point1, point2, point3) {
        logger.log("logCurve3", "createIcCurve3", point1, point2, point3);

        const type = "curve3";

        const arr_point = [point1, point2, point3];
        const trueRect__enveloppe = Geometry.getEnveloppeRect(arr_point);

        const position = {x: trueRect__enveloppe.x, y: trueRect__enveloppe.y};
        const size     = {width: trueRect__enveloppe.width, height: trueRect__enveloppe.height};

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icCurve3_spec = {
          "arr_point": arr_point,
          
          "color":     "purple",
          "fillColor": "black",

          "pointType": "undefined",
        };

        const icCurve3 = Object.assign(icObj, icCurve3_spec);

        return icCurve3;
      }

      createIcCompositeCurve3(point1, point2, point3) {
        logger.log("logCurve3", "createIcCompositeCurve3", point1, point2, point3);

        const pointCenter = Geometry.getCenterPoint(Geometry.createLTRect(trueRect));
        const strokeWidth = trueRect.width / 20;
        const radius = trueRect.width / 2 - strokeWidth / 2;

        const cfg_circle__bg = {
          strokeWidth: strokeWidth,
          stroke: "grey",
          fillColor: "",
        };
        const circle__bg = infiniteCanvas.createIcCircle(pointCenter, radius, cfg_circle__bg);
        const cfg_arc = {
          strokeWidth: strokeWidth,
          stroke: "gold",
          fillColor: "",
        };
        const arc = infiniteCanvas.createIcArcOfCircle(pointCenter, radius, 0, progress * 360, cfg_arc);

        var arr_point__crown = [
          Geometry.createPoint(0, 100),
          Geometry.createPoint(100, 150),
          Geometry.createPoint(250, 0),
          Geometry.createPoint(400, 150),
          Geometry.createPoint(500, 100),
          Geometry.createPoint(400, 400),
          Geometry.createPoint(100, 400),
        ];
        arr_point__crown = Geometry.getCenterScaledPolygon(arr_point__crown, 0.10);
        const point__src = Geometry.getCenterPoint(Geometry.createLTRect(Geometry.getEnveloppeRect(arr_point__crown)));
        const point__dst = Geometry.pointOnCircle__angleInDegrees(pointCenter, radius, 0);
        arr_point__crown = Geometry.getTranslatedPolygon(arr_point__crown, point__src, point__dst);

        const cfg__crown = {
          stroke: "grey",
          strokeWidth: 5,

          fillColor: "gold",
        };
        const crownSymbol = infiniteCanvas.createIcPolygon(arr_point__crown, cfg__crown);
        const facade = infiniteCanvas.createIcRect(Geometry.getCenterScaledRect(trueRect, 0.5));

        const parts = {
          "circle_bg": circle__bg,
          "arc": arc,
          "crownSymbol": crownSymbol,

          //"facade":      facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "progress_marker";

        //debug
        // const icObj = icComposite;
        // setTimeout(() => {
        //   const represented = infiniteCanvas.getRepresented(icObj.id);
        //   const rep_free    = represented.r_free();
        //
        //   // const progress = 0.9;
        //   // rep_free.progress = progress;
        //
        //   const arcStart = 40;
        //   const arcEnd   = 160;
        //   rep_free.parts.arc.arcStart = arcStart;
        //   rep_free.parts.arc.arcEnd   = arcEnd;
        //
        // }, 2000);

        return icComposite;
      }

      createIcZCurve3(point1, point2, point3) {
        
      }


      createIcCircle(pointCenter, radius, cfg_in = {}) {

        const type = "circle";
        // const position  = Geometry.createPoint(left, top);

        const diameter = 2 * radius;
        const size = Geometry.createSize(diameter, diameter);
        // const size    = Geometry.createSize(radius, radius);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, pointCenter, size, homeScale);


        const cfg_default = {
          isUsingCenterPosition: true,
          strokeWidth: 2,
          stroke: "red",
          fillColor: "blue",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icCircle_spec = {
          isUsingCenterPosition: cfg.isUsingCenterPosition,
          radius: radius,

          strokeWidth: cfg.strokeWidth,
          stroke: cfg.stroke,
          fill: cfg.fillColor,

          //add properties which specify circle can't be resizedX or resizedY
        };

        const icCircle = Object.assign(icObj, icCircle_spec);

        return icCircle;
      }

      createIcEllipse(trueRect, cfg_in = {}) {

        const type = "ellipse";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const cfg_default = {
          stroke: "magenta",
          fill:   "cyan",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icEllipse_spec = {
          "stroke": cfg.stroke,
          "fill": cfg.fill,
        };

        const icEllipse = Object.assign(icObj, icEllipse_spec);

        return icEllipse;
      }

      createIcArcOfSquare(pointCenter, radius, angleInDegrees__start, angleInDegrees__end, cfg_in = {}) {  //arc = object + clipping path

        const type = "arc_of_square";
        //const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(2 * radius, 2 * radius);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, pointCenter, size, homeScale);

        const cfg_default = {
          stroke: "black",
          fillColor: "blanchedalmond",

          arcStart: angleInDegrees__start,
          arcEnd: angleInDegrees__end,
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icArcOfSquare_spec = {
          isUsingCenterPosition: true,

          squareCenter: pointCenter,
          radius: radius,

          "stroke": cfg.stroke,
          //"strokeWidth" : 0,

          "fill": cfg.fillColor,

          "arcStart": cfg.arcStart,
          "arcEnd": cfg.arcEnd,
        };

        const icArcOfSquare = Object.assign(icObj, icArcOfSquare_spec);

        return icArcOfSquare;
      }

      createIcArcOfCircle(pointCenter, radius, angleInDegrees__start, angleInDegrees__end, cfg_in = {}) {  //arc = object + clipping path

        const type = "arc_of_circle";
        //const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(radius, radius);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, pointCenter, size, homeScale);

        const cfg_default = {
          stroke: "orange",
          fillColor: "",

          arcStart: angleInDegrees__start,
          arcEnd: angleInDegrees__end,
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icCircle_spec = {
          isUsingCenterPosition: true,

          circleCenter: pointCenter,
          radius: radius,

          strokeWidth: cfg.strokeWidth,
          stroke: cfg.stroke,
          fill: cfg.fillColor,

          arcStart: cfg.arcStart,
          arcEnd: cfg.arcEnd,

          //add properties which specify circle can't be resizedX or resizedY
        };

        const icCircle = Object.assign(icObj, icCircle_spec);

        return icCircle;
      }

      createIcArcOfEllipse(trueRect, cfg_in = {}) {

        const type = "arc_of_ellipse";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const cfg_default = {
          stroke: "magenta",
          fillColor: "cyan",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icEllipse_spec = {
          "stroke": cfg.stroke,
          "fill": cfg.fillColor,
        };

        const icEllipse = Object.assign(icObj, icEllipse_spec);

        return icEllipse;
      }

      createIcSegmentedArcOfCircle(pointCenter, radius, cfg_in = {}) {  //arc = object + clipping path

        const type = "segmented_arc_of_circle";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const cfg_default = {
          stroke: "magenta",
          fillColor: "cyan",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icEllipse_spec = {
          "stroke": cfg.stroke,
          "fill": cfg.fillColor,
        };

        const icEllipse = Object.assign(icObj, icEllipse_spec);

        return icEllipse;
      }

      createIcSegmentedArcOfEllipse(trueRect, cfg_in = {}) {

        const type = "segmented_arc_of_ellipse";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const cfg_default = {
          stroke: "magenta",
          fillColor: "cyan",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icEllipse_spec = {
          "stroke": cfg.stroke,
          "fill": cfg.fillColor,
        };

        const icEllipse = Object.assign(icObj, icEllipse_spec);

        return icEllipse;
      }


      createIcPolygon(arr_point, cfg_in = null) {

        const type = "polygon";
        const rect__enveloppe = Geometry.getEnveloppeRect(arr_point);

        const position  = Geometry.createPoint(rect__enveloppe.x, rect__enveloppe.y);
        const size      = Geometry.createSize(rect__enveloppe.width, rect__enveloppe.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const cfg_default = {
          stroke:    "red",
          fillColor: "blue",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icPolygon_spec = {
          arr_point: arr_point,

          "stroke": cfg.stroke,
          "fill":   cfg.fillColor,
        };

        const icPolygon = Object.assign(icObj, icPolygon_spec);

        return icPolygon;
      }

      createIcHexagon(pointTL, length, cfg_in = null) {
        const arr_point = [
          Geometry.createPoint(pointTL.x + length * 0.5, pointTL.y + 0),
          Geometry.createPoint(pointTL.x + length * 1.5, pointTL.y + 0),
          Geometry.createPoint(pointTL.x + length * 2.0, pointTL.y + length * math.sqrt(3) / 2.0),
          Geometry.createPoint(pointTL.x + length * 1.5, pointTL.y + length * math.sqrt(3)),
          Geometry.createPoint(pointTL.x + length * 0.5, pointTL.y + length * math.sqrt(3)),
          Geometry.createPoint(pointTL.x + length * 0.0, pointTL.y + length * math.sqrt(3) / 2.0),
        ];

        const cfg_default = {
          stroke: "red",
          fillColor: "blue",
        };
        const cfg = cfg_in ? Object.assign(cfg_default, cfg_in) : cfg_default;

        const icPolygon = this.createIcPolygon(arr_point, cfg);

        return icPolygon;
      }

      createIcProgressMarker(trueRect, progress, cfg) { //bind progress outer object via cfg
        const infiniteCanvas = this;

        const pointCenter = Geometry.getCenterPoint(Geometry.createLTRect(trueRect));
        const strokeWidth = trueRect.width / 20;
        const radius = trueRect.width / 2 - strokeWidth / 2;

        const cfg_circle__bg = {
          strokeWidth: strokeWidth,
          stroke: "grey",
          fillColor: "",
        };
        const circle__bg = infiniteCanvas.createIcCircle(pointCenter, radius, cfg_circle__bg);
        const cfg_arc = {
          strokeWidth: strokeWidth,
          stroke: "gold",
          fillColor: "",
        };
        const arc = infiniteCanvas.createIcArcOfCircle(pointCenter, radius, 0, progress * 360, cfg_arc);

        var arr_point__crown = [
          Geometry.createPoint(0, 100),
          Geometry.createPoint(100, 150),
          Geometry.createPoint(250, 0),
          Geometry.createPoint(400, 150),
          Geometry.createPoint(500, 100),
          Geometry.createPoint(400, 400),
          Geometry.createPoint(100, 400),
        ];
        arr_point__crown = Geometry.getCenterScaledPolygon(arr_point__crown, 0.10);
        const point__src = Geometry.getCenterPoint(Geometry.createLTRect(Geometry.getEnveloppeRect(arr_point__crown)));
        const point__dst = Geometry.pointOnCircle__angleInDegrees(pointCenter, radius, 0);
        arr_point__crown = Geometry.getTranslatedPolygon(arr_point__crown, point__src, point__dst);

        const cfg__crown = {
          stroke: "grey",
          strokeWidth: 5,

          fillColor: "gold",
        };
        const crownSymbol = infiniteCanvas.createIcPolygon(arr_point__crown, cfg__crown);
        const facade = infiniteCanvas.createIcRect(Geometry.getCenterScaledRect(trueRect, 0.5));

        const parts = {
          "circle_bg": circle__bg,
          "arc": arc,
          "crownSymbol": crownSymbol,

          //"facade":      facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "progress_marker";

        //debug
        // const icObj = icComposite;
        // setTimeout(() => {
        //   const represented = infiniteCanvas.getRepresented(icObj.id);
        //   const rep_free    = represented.r_free();
        //
        //   // const progress = 0.9;
        //   // rep_free.progress = progress;
        //
        //   const arcStart = 40;
        //   const arcEnd   = 160;
        //   rep_free.parts.arc.arcStart = arcStart;
        //   rep_free.parts.arc.arcEnd   = arcEnd;
        //
        // }, 2000);

        return icComposite;
      }

      createIcProductOfPrimesDisk(pointCenter, number) {
        const infiniteCanvas = this;

        const mathNode__number = new math.ConstantNode(number);
        // const mathNode__prpr   = Rewriter.decomposition_product_primes(mathNode__number);
        const arr_values = MathUtils.primeFactorization(number);
        logger.log("arr_values", arr_values);
        const nb_factors = arr_values.length;

        const radius_full = 100;
        const strokeWidth = radius_full / 4;
        const radius = radius_full - strokeWidth / 2.0;

        const width = 2 * radius_full;
        const height = 2 * radius_full;
        const trueRect = Geometry.createCenteredXYRect(pointCenter, width, height);

        // const cfg_circle__bg = {
        //   strokeWidth: strokeWidth,
        //   stroke: "grey",
        //   fillColor: "",
        // };
        // const circle__bg  = infiniteCanvas.createIcCircle(pointCenter, radius, cfg_circle__bg);

        function colorForPrime(number) {
          const dict_color = {
            2: "orange",
            3: "green",
            5: "blue",
            7: "violet",
          };
          const color_default = "red";
          if (!math.isPrime(number)) {
            throw new Error("number must be a prime number");
          }
          const color = dict_color[number] ? dict_color[number] : color_default;
          return color;
        }

        function angleStartForSector(index_sector, nb_sectors) {
          return 360 * index_sector / nb_sectors;
        }

        function angleEndForSector(index_sector, nb_sectors) {
          return 360 * (index_sector + 1) / nb_sectors; //- 0.05;
        }

        function arcForPrimeNumber(number, index_sector, nb_sectors) {

          const color = colorForPrime(number);

          const cfg_arc = {
            strokeWidth: strokeWidth,
            stroke: color,
            fillColor: "",
          };
          const angleStart = angleStartForSector(index_sector, nb_sectors);
          const angleEnd = angleEndForSector(index_sector, nb_sectors);
          const arc = infiniteCanvas.createIcArcOfCircle(pointCenter, radius, angleStart, angleEnd, cfg_arc);
          return arc;
        }

        const arr_arc = arr_values.map((number, index) => {
          const arc = arcForPrimeNumber(number, index, nb_factors);
          return arc;
        });
        const arr_entries = arr_arc.map((arc, index) => {
          const name = "sector_" + index;
          return [name, arc];
        });
        const dict_sector = Object.fromEntries(arr_entries);

        var parts = {};
        parts = Object.assign(parts, dict_sector);

        // const facade      = infiniteCanvas.createIcMathNode(x,y,mathNode);
        // parts.facade = facade;

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "product_of_primes";

        return icComposite;
      }

      createIcGrid(trueRect, nb_horiz = 15, nb_vert = 15) {
        // const nb_total = 15;

        // const nb_horiz = nb_total;
        const index_axis__horiz = (nb_horiz - 1)/2;

        // const nb_vert  = nb_total;
        const index_axis__vert  = (nb_vert - 1)/2;

        // const trueRect__grid__container = {
        //   x:      100,
        //   y:      100,
        //   width:  500,
        //   height: 500,
        // };
        const trueRect__grid__container = trueRect;

        function createGridSegment__horiz(rect__grid, index, nb_total) {
          const segment_L = Geometry.segment_L(rect__grid);
          const segment_R = Geometry.segment_R(rect__grid);
          return Geometry.createWebSegment__nth(segment_L, segment_R, index, nb_total);
        }

        function createGridSegment__vert(rect__grid, index, nb_total) {
          const segment_T = Geometry.segment_T(rect__grid);
          const segment_B = Geometry.segment_B(rect__grid);
          return Geometry.createWebSegment__nth(segment_T, segment_B, index, nb_total);
        }

        const arr_segmentWrapper__horiz = [...Array(nb_horiz).keys()].map((index) => {
          const segment_horiz      = createGridSegment__horiz(trueRect__grid__container, index, nb_horiz);
          return {
            segment: segment_horiz,
            index: index,
            isAxis: (index == index_axis__horiz),
          };
        });
        const arr_segmentWrapper__vert = [...Array(nb_vert).keys()].map((index) => {
          const segment_vert      = createGridSegment__vert(trueRect__grid__container, index, nb_vert);
          return {
            segment: segment_vert,
            index: index,
            isAxis: (index == index_axis__vert),
          };
        });

        const arr_icSegment = [...arr_segmentWrapper__horiz, ...arr_segmentWrapper__vert].map((segmentWrapper) => {
          const segment = segmentWrapper.segment;
          const icSegment = infiniteCanvas.createIcSegment(segment.point1, segment.point2);
          // const icCompositeSegment = infiniteCanvas.createIcCompositeSegment(segment.point1, segment.point2);
          if(segmentWrapper.isAxis) {
            icSegment.strokeWidth = 3;
          } else {
            icSegment.strokeWidth = 1;
          }
          return icSegment;
        });




        const trueRect__composite = {
          x:      trueRect__grid__container.x - 50,
          y:      trueRect__grid__container.y - 50,
          width:  50,
          height: 50,
        };
        const icRect = infiniteCanvas.createIcRect(trueRect__composite);
        icRect.zIndex = -100;
        icRect.fill   = ColorUtils.randomColor();


        const content = icRect;

        const parts           = Utils.dictFromArr(arr_icSegment);
        const contentAndParts = Object.assign({"content": content}, parts);
        
        const compositeConfig = Compositer.defaultCompositeConfig(contentAndParts, false);
        // compositeConfig__knob[icMathNode__knob.id].isMobile = true;
        
        const icComposite = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig, content);
        icComposite.cType = "grid";

        return icComposite;
      }


      createIcText(left, top, text) {

        const type = "text";
        const position = Geometry.createPoint(left, top);
        const size = Geometry.createSize(0, 0);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        // const text     = "icText";
        const fontSize = 100;

        const icText_spec = {
          text: text,
          textColor: "black",
          fontSize: fontSize,
        };

        const icText = Object.assign(icObj, icText_spec);

        icText.addInteraction_edit();

        //SHU123
        // //add collection
        // function collectionCreation_textChangeListener(icObj) {
        //
        // }
        // icText.onEditExit(collectionCreation_textChangeListener);
        // rep_free.onEditExit(collectionCreation_textChangeListener);

        return icText;
      }

      createIcImage(left, top, img_in) {
        const type = "image";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        var img;
        if (img_in != null) {
          img = img_in;
        } else {
          const width__default  = 100;
          const height__default = 100;
          img = new Image(width__default, height__default);

          logger.log("log1", "img", img);
        }

        const icImage_spec = {
          img: img,
          force_width: false,
          force_height: false,
        };

        const icImage = Object.assign(icObj, icImage_spec);

        return icImage;
      }

      createIcPatternRectImage(trueRect, img_in) {
        const type     = "patternRectImage";

        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size     = Geometry.createSize(trueRect.width, trueRect.height);
        // const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        var img;
        if (img_in != null) {
          img = img_in;
        } else {
          const width__default  = 100;
          const height__default = 100;
          img = new Image(width__default, height__default);

          logger.log("log1", "img", img);
        }

        const icPatternRectImage_spec = {
          img: img,
          force_width:  false,
          force_height: false,
        };

        const icPatternRectImage = Object.assign(icObj, icPatternRectImage_spec);

        return icPatternRectImage;
      }

      createIcVideo(left, top, video_in) {
        const type = "video";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        var video;
        if (video_in != null) {
          video = video_in;
        } else {
          const width__default = 100;
          const height__default = 100;
          video = document.createElement('video');

          logger.log("log1", "video", video);
        }

        const icVideo_spec = {
          video: video,
          img: null,
          force_width: false,
          force_height: false,
        };

        const icVideo = Object.assign(icObj, icVideo_spec);

        ImageUtils.imageFromVideo_p(video).then((img) => {
          Object.assign(icObj, { img: img });
        });

        

        //TBD: play on click/shift-click
        // const video = icVideo.video;
        video.play();

        const engine = new VideoEngine();
        const eType  = "video";
        const icEngined = infiniteCanvas.installEngineOnIcObj(icVideo, eType, engine);

        return icEngined;
      }

      getFrameFromVideo_p(video) {

        const html_elt = video;

        const canvasElt_p = html2canvas(html_elt, {
          // onclone: function (clone__htmlElt) {
          // clone__htmlElt.style.visibility = "visible";
          // clone__htmlElt.style.display = "block";
          // },
        });

        const fObj_hmtlElt_image_p = canvasElt_p.then((canvasElt) => {

          function getNumericalValueForPxString(pxString) {
            return parseInt(pxString.replace("px", ""));
          }

          const width__canvasElt  = getNumericalValueForPxString(canvasElt.style.width);
          const height__canvasElt = getNumericalValueForPxString(canvasElt.style.height);

          const img = new fabric.Image(canvasElt);

          const group = fObj;
          img.set({
            // left: 0,
            // top: 0,
            //SHU: that smell of Scotch Tape
            left: -group.width / 2,
            top: -group.height / 2,

            //debug
            // stroke: "yellow",
            // strokeWidth: 2,
          });

          return img;

          return canvasElt;
        });

      }


      createIcAudio(trueRect, audio_in) {
        const type = "audio";

        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        audio_in.style.width  = "" + trueRect.width  + "px";
        audio_in.style.height = "" + trueRect.height + "px";

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        var audio;
        if (audio_in != null) {
          audio = audio_in;
        } else {
          audio = document.createElement('audio');
          logger.log("log1", "audio", audio);
        }

        const icAudio_spec = {
          el__audio: audio,
        };

        const icAudio = Object.assign(icObj, icAudio_spec);

        const engine    = new AudioEngine();
        const eType     = "audio";
        const icEngined = infiniteCanvas.installEngineOnIcObj(icAudio, eType, engine);

        //debug
        audio.play();

        return icEngined;
      }


      createIcFreeDrawing_from_freeDrawingFObj(fObj) {
        console.log("createIcFreeDrawing_from_freeDrawingFObj", fObj);
        console.log("createIcFreeDrawing_from_freeDrawingFObj", fObj.constructor.name);


        const type = "freeDrawing";


        const trueRect = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size     = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        const exoObject = Object.assign({}, fObj);
        exoObject.icObj = null; // remove circular dependency

        const isCosmetic = fObj.isCosmetic;

        const icFreeDrawing_spec = {
          // path: fObj.path,

          exoObject: exoObject,

          isCosmetic: isCosmetic,

          opacity: fObj.opacity,

        };

        const icFreeDrawing = Object.assign(icObj, icFreeDrawing_spec);
        icFreeDrawing.isTouchable = true;

        return icFreeDrawing;
      }

      createIcFloodFill_from_floodFillFObj(fObj) {
        console.log("createIcFloodFill_from_floodFillFObj", fObj);
        console.log("createIcFloodFill_from_floodFillFObj", fObj.constructor.name);

        const type = "floodFill";

        const trueRect = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size     = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        const exoObject = Object.assign({}, fObj);
        exoObject.icObj = null; // remove circular dependency

        // const isCosmetic = fObj.isCosmetic;

        const icFloodFill_spec = {
          exoObject: exoObject,

          // isCosmetic: isCosmetic,
          // opacity: fObj.opacity,
        };

        const icFloodFill = Object.assign(icObj, icFloodFill_spec);
        // icFloodFill.isTouchable = true;

        return icFloodFill;
      }

      createIcSvg(left, top, svgEl) {
        const type = "svg";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSvg_spec = {
          svg: svgEl,
        };

        var icSvg = Object.assign(icObj, icSvg_spec);

        const color_property = {
          get color() {
            return icSvg.svg.style.color;
          },
          set color(value) {
            icSvg.svg.style.color = value;
          },
        };

        icSvg = Object.assign(icSvg, color_property);

        return icSvg;
      }

      createIcTex(left, top, tex) {
        const type = "tex";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(500, 500);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icTex_spec = {
          tex: tex,
        };

        const icTex = Object.assign(icObj, icTex_spec);

        //debug
        // const infiniteCanvas = this;
        // setTimeout(() => {
        //   const tex = '\\frac{50}{50x^2-50}';
        //
        //   const represented = infiniteCanvas.getRepresented(icObj.id);
        //   // const rep_official = represented.r_official();
        //   // rep_official.tex = tex;
        //   const rep_free = represented.r_free();
        //   rep_free.tex = tex;
        //
        // }, 5000);

        return icTex;
      }

      createIcBigTex(left, top, tex) {
        const type = "bigTex";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(500, 500);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icTex_spec = {
          tex: tex,
        };

        const icTex = Object.assign(icObj, icTex_spec);

        return icTex;
      }

      createIcMathNode(left, top, mathNode) {
        console.log("createIcMathNode", left, top, mathNode);


        const type = "mathNode";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icMathNode_spec = {
          mathNode: mathNode,

          //appearance
          // strokeWidth: 0.0777,
          // stroke: "hotpink",
        };

        const icMathNode = Object.assign(icObj, icMathNode_spec);
        icMathNode.isTouchable = true;


        //edition
        const infiniteCanvas = this;

        icMathNode.edit = {};
        icMathNode.edit.start = function () {
          console.log("icMathNode.edit.start");

          globalsSingleton.isEditing = true;

          //mathQuill
          {
            //create mathField
            const mathField = createMathField();

            //add mathField root HTML element to canvasContainer
            const elt = mathField.el();
            console.log("elt", elt);

            if (elt.style == null) { elt.style = {}; }
            elt.style.position = "absolute";

            const canvasContainer = infiniteCanvas.canvas.parentElement;
            canvasContainer.appendChild(elt);    //SHU: move this to fabricIntegration

            mathField.reflow();


            // //update position
            // function updatePosition() {
            //   const represented = infiniteCanvas.getRepresented(icMathNode.id);
            //   // console.log("represented", represented);
            //   const rep_free = represented.r_free();
            //
            //   const position_screen = rep_free.getScreenPositionWithoutOffset();
            //   console.log("position_screen", position_screen);
            //
            //   const style = {
            //     left: position_screen.x + 'px',
            //     top:  position_screen.y + 'px',
            //   };
            //
            //   const elt = mathField.el();
            //   // elt.style = Object.assign(elt.style, style);
            //   elt.style.left = style.left;
            //   elt.style.top  = style.top;
            //
            //   mathField.reflow();
            // }
            //
            // updatePosition();


            //update rect
            function updateRect() {
              const represented = infiniteCanvas.getRepresented(icMathNode.id);
              const rep_free = represented.r_free();

              const screenRect = rep_free.getScreenRect();
              console.log("screenRect", screenRect);

              const style = {
                left: screenRect.left + 'px',
                top: screenRect.top + 'px',
                width: screenRect.width + 'px',
                height: screenRect.height + 'px',
              };

              const elt = mathField.el();
              // elt.style = Object.assign(elt.style, style);
              elt.style.left = style.left;
              elt.style.top = style.top;
              elt.style.width = style.width;
              elt.style.height = style.height;

              mathField.reflow();
            }

            updateRect();


            //update tex
            function updateTex() {
              const represented = infiniteCanvas.getRepresented(icMathNode.id);
              const rep_free = represented.r_free();

              const tex = rep_free.mathNode.toTex();
              mathField.latex(tex);
            }

            updateTex();

            //bind position
            {

            }



            //track end of mathField edition
            // mathField.upOutOf({
            //   const represented = infiniteCanvas.getRepresented(icMathNode.id);
            //   const rep_free    = represented.r_free();
            //
            //   rep_free.edit.stop(mathField);
            // })
            // mathField.el().onfocusout(() => {
            //   stopEditing(mathField);
            // });
            const eventListener = () => {
              stopEditing(mathField);
            };
            mathField.el().addEventListener("focusout", eventListener);

            function stopEditing(mathField) {
              const represented = infiniteCanvas.getRepresented(icMathNode.id);
              const rep_free = represented.r_free();

              rep_free.edit.stop(mathField);

              globalsSingleton.isEditing = false;
            }


            //focus mathField
            mathField.focus();

          }


        };

        icMathNode.edit.stop = function (mathField) {
          console.log("icMathNode.edit.stop", mathField);

          //mathQuill
          {

            //transfer tex
            {
              const tex = mathField.latex();
              console.log("tex", tex);

              const represented = infiniteCanvas.getRepresented(icMathNode.id);
              const rep_free = represented.r_free();

              //this is where fun starts
              function mathFieldTex_to_mathNode(tex) {
                var outMathNode;

                // outMathNode = math.parse(tex);
                const mathExpression = MathExpression.fromLatex(tex);
                const text = mathExpression.toString();
                console.log("text", text);
                outMathNode = math.parse(text);

                //don't parse "=" into ":="

                //upgrade to gmOperator when writing "x50"

                return outMathNode;
              }

              const mathNode__new = mathFieldTex_to_mathNode(tex);
              mathNode__new.autoSimplify = true;

              rep_free.mathNode = mathNode__new;
            }

            //remove all listeners
            // mathField.el().removeEventListener("focusout", eventListener);
            $(mathField.el()).off();

            //remove mathField elt from canvasContainer
            mathField.el().remove();

            //destroy mathField
            mathField.revert();
          }


        };



        return icMathNode;
      }

      createIcRichMathNode(left, top, richMathNode) {
        console.log("createIcRichMathNode", left, top, richMathNode);

        const type = "richMathNode";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRichMathNode_spec = {
          richMathNode: richMathNode,
        };

        const icRichMathNode = Object.assign(icObj, icRichMathNode_spec);


        return icRichMathNode;
      }


      // createIcAsText_mathNode(left, top, text, ) {
      //
      //   const type      = "as_text__mathNode";
      //   const position  = Geometry.createPoint(left, top);
      //   const size      = Geometry.createSize(0, 0);
      //   const homeScale = Object.assign({}, this.scale);
      //
      //   const icObj = this.createIcObject(type, position, size, homeScale);
      //
      //
      //   // const text     = "icText";
      //   const fontSize = 100;
      //
      //   const icText_spec = {
      //     text:      text,
      //     textColor: "black",
      //     fontSize:  fontSize,
      //   };
      //
      //   const icText = Object.assign(icObj, icText_spec);
      //
      //   return icText;
      // }
      //
      // createIcAsY(left, top, type_y, type_x, func_YtoX) {
      //
      // }
      //
      // createIcEditingAsY(left, top, type_y, type_x, func_YtoX) {
      //
      // }


      createIcMNReictangle(left, top, mathNode, length_unit = 30) {
        console.log("createIcMNReictangle", left, top, mathNode);

        const type = "mnrei_rectangle";
        const position = Geometry.createPoint(left, top);

        const value = mathNode.evaluate({});

        const width = length_unit * value;
        // const height = length_unit * 1;
        const height = 30;

        const size = Geometry.createSize(width, height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);
        // icMNReictangle.fill = "orange";

        const icMNReictangle_spec = {
          mathNode: mathNode,
          length_unit: length_unit,
        };

        const icMNReictangle = Object.assign(icObj, icMNReictangle_spec);

        const infiniteCanvas = this;
        infiniteCanvas.onceOnAddRepresentedForIcObject(icMNReictangle, (icMNReictangle) => {

          const rep_free = infiniteCanvas.getRepresented(icMNReictangle.id).r_free();

          rep_free.onInnerUpdate((rep_free, propName, oldValue, newValue) => {

            if (propName == "mathNode") {
              logger.log("icMNReictangle.onInnerUpdate, mathNode", propName, newValue);

              const mathNode = newValue;

              const value = mathNode.evaluate({});
              logger.log("value", value);

              const length_unit = rep_free.length_unit;

              const width = length_unit * value;
              // const height = length_unit * 1;
              const height = 30;

              const size = Geometry.createSize(width, height);

              rep_free.size = size;
            }

          });

        });

        return icMNReictangle;
      }


      createIcHtmlElt(left, top, html_elt) {
        console.log("createIcHtmlElt", left, top, html_elt);
        const infiniteCanvas = this;

        const type = "htmlElt";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icHtmlElt_spec = {
          htmlElt: html_elt,
        };

        const icHtmlElt = Object.assign(icObj, icHtmlElt_spec);



        const htmlEltObserver = createHtmlEltObserver(html_elt);
        htmlEltObserver.rx_observable__mutation.subscribe({
          next: (html_elt_mutated) => {

            const represented = infiniteCanvas.getRepresented(icHtmlElt.id);
            const rep_free = represented.getRepresentation("free");

            rep_free.htmlElt = html_elt_mutated;

          },
        });

        html_elt.innerHTML = "1";
        // html_elt.text = "1";


        //debug
        setTimeout(() => {
          html_elt.innerHTML += "[]";
          // html_elt.text += "[]";
        }, 5000);

        // setInterval(() => {
        //   html_elt.innerHTML += "[]";
        //   // html_elt.text += "[]";
        // }, 2000);


        return icHtmlElt;
      }

      createIcHTMLObject(left, top, el_html) {
        logger.log("logHTML", "createIcHTMLObject", left, top, el_html);
        const infiniteCanvas = this;

        const type     = "htmlObject";
        const position = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icHtmlObject_spec = {
          el_html: el_html,
        };

        const icHtmlObject = Object.assign(icObj, icHtmlObject_spec);



        // const htmlEltObserver = createHtmlEltObserver(html_elt);
        // htmlEltObserver.rx_observable__mutation.subscribe({
        //   next: (html_elt_mutated) => {

        //     const represented = infiniteCanvas.getRepresented(icHtmlElt.id);
        //     const rep_free = represented.getRepresentation("free");

        //     rep_free.htmlElt = html_elt_mutated;

        //   },
        // });

        return icHtmlObject;
      }

      createIcPDF(left, top, dict_pdf) {
        logger.log("logPDF", "createIcPDF", left, top, dict_pdf);
        const infiniteCanvas = this;

        const type      = "pdf";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(100, 100);
        const homeScale = Object.assign({}, this.scale);

        const padding = {
          X: 0,
          Y: 0,
        };
        const arr_icHtmlObject__page = dict_pdf.arr_dict_page.reduce((acc, dict_page) => {

          const el_canvas = dict_page.el_canvas;

          const icHtmlObject__page = infiniteCanvas.createIcHTMLObject(acc.x, acc.y, el_canvas);
          
          acc.x = acc.x + (padding.X + el_canvas.width) / infiniteCanvas.scale.X;
          // acc.y = acc.y + (padding.Y + el_canvas.height) / infiniteCanvas.scale.Y;

          acc.arr_icHtmlObject.push(icHtmlObject__page);

          return acc;
        }, {
          x:left,
          y:top,
          arr_icHtmlObject: [],
        }).arr_icHtmlObject;
        
        const arr_entries = arr_icHtmlObject__page.map((icHtmlObject__page, index) => {
          const name = "page_" + index;
          return [name, icHtmlObject__page];
        });

        var parts = {};
        parts = Object.assign(parts, Object.fromEntries(arr_entries));

        // const facade      = infiniteCanvas.createIcMathNode(x,y,mathNode);
        // parts.facade = facade;

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const trueRect__composite = {
          x:      left - 50,
          y:      top,
          width:  50,
          height: 50,
        };
        const icComposite = this.createIcComposite(trueRect__composite, parts, compositeConfig);
        icComposite.cType = "pdf";

        return icComposite;
      }

      createIcPDF_a(left, top, dict_pdf_a) {
        logger.log("logPDF", "createIcPDF_a", left, top, dict_pdf_a);
        const infiniteCanvas = this;

        const type      = "pdf";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(100, 100);
        const homeScale = Object.assign({}, this.scale);

        var parts = {};
        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const trueRect__composite = {
          x:      left - 50,
          y:      top,
          width:  50,
          height: 50,
        };
        const icComposite = this.createIcComposite(trueRect__composite, parts, compositeConfig);
        icComposite.cType = "pdf";


        const pdf = dict_pdf_a.pdf;
        //spec
        const icPDF_spec = {
          pdf: pdf,
        };
        
        const icPDF = Object.assign(icComposite, icPDF_spec);

        infiniteCanvas.onceOnAddRepresentedForIcObject(icPDF, (icPDF) => {
          const icComposite = icPDF;
          const pdf         = icPDF.pdf;

          const rep_free__icComposite = infiniteCanvas.getRepresented(icComposite.id).r_free();

          const padding = {
            X: 10,
            Y: 0,
          };

          const width__el  = 500;
          const height__el = 1000;

          // dict_pdf_a.arr_dict_page_p.filter((x,i) => (i < 10)).reduce((acc, dict_page_p, index) => {

          //   const x = (padding.X + 500);
          //   const y = 0;

          //   acc = acc.then((_)=> {

          //     return new Promise(resolve => setTimeout(resolve, 100)).then((_) => {

          //       return dict_page_p.then((dict_page) => {
          //         const el_canvas = dict_page.el_canvas;
          //         logger.log("logPDF", "el_canvas", el_canvas);

          //         const x = index * (padding.X + width__el);
          //         const y = 0;

          //         const icHtmlObject__page = infiniteCanvas.createIcHTMLObject(x, y, el_canvas);

          //         infiniteCanvas.onceOnAddRepresentedForIcObject(icHtmlObject__page, (icHtmlObject__page) => {
          //           const rep_free__icHtmlObject__page = infiniteCanvas.getRepresented(icHtmlObject__page.id).r_free();
          //           rep_free__icComposite.dict_engine["composite"].engine.awoken.addPart(rep_free__icHtmlObject__page);
          //         });

          //         infiniteCanvas.addIcObject(icHtmlObject__page);
                  
          //         return "" + index;
          //       });

          //     });

          //   });

          //   return acc;

          // }, Promise.resolve(-1));


          // const queue = new FunctionCallsQueue(true);
          // queue.add(() => {});

          // const arr_func_load = dict_pdf_a.arr_dict_page_p.map((dict_page_p, index) => {

          //   const x = (padding.X + 500);
          //   const y = 0;

          //   const func_load = async function() {

          //     setTimeout(() => {}, 500);

          //     await dict_page_p.then((dict_page) => {
          //       const el_canvas = dict_page.el_canvas;
          //       logger.log("logPDF", "el_canvas", el_canvas);

          //       const x = index * (padding.X + width__el);
          //       const y = 0;

          //       const icHtmlObject__page = infiniteCanvas.createIcHTMLObject(x, y, el_canvas);

          //       infiniteCanvas.onceOnAddRepresentedForIcObject(icHtmlObject__page, (icHtmlObject__page) => {
          //         const rep_free__icHtmlObject__page = infiniteCanvas.getRepresented(icHtmlObject__page.id).r_free();
          //         rep_free__icComposite.dict_engine["composite"].engine.awoken.addPart(rep_free__icHtmlObject__page);
          //       });

          //       infiniteCanvas.addIcObject(icHtmlObject__page);
          //     });

          //   };

          //   return func_load;

          // });

          // arr_func_load.filter((x,i) => (i < 10)).forEach((func_load, index) => {
          //   queue.add(func_load);
          // })

          // queue.next();


          const queue = [...Array(pdf.numPages).keys()].reduce((acc, index) => {
          // const queue = [...Array(pdf.numPages).keys()].filter((x,i) => ((0 + infiniteCanvas.debug__offset__pdf_load < i) && (i < 100 + infiniteCanvas.debug__offset__pdf_load))).reduce((acc, index) => {

            acc = acc.add((_)=> {

              function getPage_p(index) {
                logger.log("logPDF", "getPage_p:", index);

                // return new Promise((resolve) => setTimeout(resolve("lol"), 300)).then((_) => {  //timeout

                return pdf.getPage(index + 1).then(function (page) {
                  logger.log("logPDF", "pdf.getPage(" + (index + 1) + "):", page);

                  // var scale    = 4.0;
                  // var scale    = 1.0;
                  // var scale    = 2.0;
                  var scale    = 1.5;

                  // var viewport = page.getViewport({scale: scale});
                  var viewport = page.getViewport({scale: scale});
                  // logger.log("logPDF", "viewport:", viewport);

                  //
                  // Prepare canvas using PDF page dimensions
                  //
                  var el_canvas    = document.createElement("canvas");
                  el_canvas.height = viewport.height;
                  el_canvas.width  = viewport.width;

                  //
                  // Render PDF page into canvas context
                  //
                  // 
                  var context   = el_canvas.getContext('2d');

                  let renderTask = page.render({
                    canvasContext: context, 
                    viewport: viewport,
                  });

                  // Wait for rendering to finish
                  return renderTask.promise.then(function() {
                      //debug
                      // const dataURL = el_canvas.toDataURL();
                      // FileIntegration.save_image(dataURL);

                      // return el_canvas;

                      const dict_page = {
                        page: page,
                        el_canvas: el_canvas,
                      };

                      return dict_page;
                  });
                
                });

                // }); //timeout
              }

              return getPage_p(index).then((dict_page) => {
                const el_canvas = dict_page.el_canvas;
                logger.log("logPDF", "el_canvas", el_canvas);

                const x = index * (padding.X + width__el + 2000);
                const y = 0;

                const icHtmlObject__page = infiniteCanvas.createIcHTMLObject(x, y, el_canvas);

                infiniteCanvas.onceOnAddRepresentedForIcObject(icHtmlObject__page, (icHtmlObject__page) => {
                  const rep_free__icHtmlObject__page = infiniteCanvas.getRepresented(icHtmlObject__page.id).r_free();
                  rep_free__icComposite.dict_engine["composite"].engine.awoken.addPart(rep_free__icHtmlObject__page);

                  rep_free__icComposite.compositeConfig[rep_free__icHtmlObject__page.id].isMobile = true;
                  rep_free__icHtmlObject__page.position = {
                    x: x,
                    y: y,
                  };
                  rep_free__icComposite.compositeConfig[rep_free__icHtmlObject__page.id].isMobile = false;
                });

                infiniteCanvas.addIcObject(icHtmlObject__page);
                
                return "done";
              });

            });

            return acc;

          }, new FunctionCallsQueue(false));

          queue.next();
          infiniteCanvas.debug__offset__pdf_load = infiniteCanvas.debug__offset__pdf_load + 100;

        });

        return icPDF;
      }


      createIcGroupWithChildIcObjects(arr_icObjs) {
        console.log("createIcGroupWithChildIcObjects", arr_icObjs);

        const type = "group";

        const trueRect = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icGroup_spec = {
          children: children,
        };

        const icGroup = Object.assign(icObj, icGroup_spec);

        return icGroup;
      }

      createIcGroup_from_groupFObj(fObj) {
        console.log("createIcGroup_from_groupFObj", fObj);

        const type = "group";

        const trueRect = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const fChildren = fObj.getObjects();
        const icChildren = fChildren.map(fObj => {
          const icObj = fObj.icObj;

          //?add position wrt group
          return icObj;
        });

        const icGroup_spec = {
          children: icChildren,
        };

        const icGroup = Object.assign(icObj, icGroup_spec);

        return icGroup;
      }

      createIcActiveSelection_from_activeSelectionFObj(fObj) {
        console.log("createIcActiveSelection_from_activeSelectionFObj", fObj);

        const type = "activeSelection";

        const trueRect = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        //to clone or not to clone...
        const icObj = this.createIcObject(type, position, size, homeScale);


        const arr_fChild = fObj.getObjects();
        const arr_icChild = arr_fChild.map(fObj_child => {
          logger.log("logCopy", "fObj_child", fObj_child);

          const icObj_child = fObj_child.icObj;
          logger.log("logCopy", "icObj_child", icObj_child);   //????
          icObj_child.icObj__activeSelection = icObj;

          fObj.activeSelection = fObj;

          //add position wrt group

          return icObj_child;
        });

        const icActiveSelection_spec = {
          children: arr_icChild,
        };

        const icActiveSelection = Object.assign(icObj, icActiveSelection_spec);

        return icActiveSelection;

      }


      createIcLink(icObj1, icObj2) {
        console.log("createIcLink", fObj);

        const infiniteCanvas = this;

        const type = "link";

        const trueRect = {

        };
        const position = Geometry.getPointTL(trueRect);
        const size = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const arr_part = {
          [icObj1.id]: icObj1,
          [icObj2.id]: icObj2,
        };

        const icLink_spec = {
          parts: arr_part,
        };

        const icLink = Object.assign(icObj, icLink_spec);

        return icLink;
      }




      createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive) {

        const type = "toggleRect";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icToggleRect_spec = {
          activeCfg: activeCfg,
          inactiveCfg: inactiveCfg,

          isActive: isActive,
        };

        const icToggleRect = Object.assign(icObj, icToggleRect_spec);

        return icToggleRect;

      }



      createIcSnapSlot(trueRect, snapSlotConfig_in = null) {
        console.log("createIcSnapSlot");

        const infiniteCanvas = this;

        const type = "snapSlot";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        var snapSlotConfig = snapSlotConfig_in;
        if (snapSlotConfig == null) {
          // console.log("snapEngine == null");
          snapSlotConfig = Snap.defaultSnapSlotConfig();
        }

        const icSnapSlot_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 3,

          snapSlotConfig: snapSlotConfig,
        };

        const icSnapSlot = Object.assign(icObj, icSnapSlot_spec);



        const engine = new SnapSlotEngine();
        const eType = "snapSlot";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icSnapSlot, eType, engine);


        return icEngined;
      }





      createIcLine_start() {
        // console.log("createIcLine_start");

        //check
        {
          const creationManager__line = this.creationManagers["line"];
          if (creationManager__line != null) {
            throw new Error("createIcLine_start, creationManager__line != null");
          }
        }

        // this.creationManagers["line"] = new LineCreationManager();
        this.creationManagers["line"] = {};
        const creationManager__line = this.creationManagers["line"];

        const true_cursor = this.getTrueCursor();

        creationManager__line.point_start = Object.assign({}, true_cursor);
      }

      createIcLine_end() {
        // console.log("createIcLine_end");

        //check
        {
          const creationManager__line = this.creationManagers["line"];
          if (creationManager__line == null) {
            throw new Error("createIcLine_end, creationManager__line == null");
          }
        }

        const creationManager__line = this.creationManagers["line"];

        const true_cursor = this.getTrueCursor();

        creationManager__line.point_end = Object.assign({}, true_cursor);

        // this.createIcLine(creationManager__line.point_start, creationManager__line.point_end);

        // const icSegment = this.createIcSegment(creationManager__line.point_start, creationManager__line.point_end);
        // this.addNewIcObject(icSegment);

        const icCompositeSegment = this.createIcCompositeSegment(creationManager__line.point_start, creationManager__line.point_end);
        this.addNewIcObject(icCompositeSegment);

        delete this.creationManagers["line"];
      }

      createIcLine(startPoint, endPoint) {

        const type = "line";
        const position = Geometry.createPoint(left, top);
        const size = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;

      }

      createIcSegment(point_start, point_end) {
        // console.log("createIcSegment", point_start, point_end);

        const type = "segment";
        const position = null;
        const size = null;
        const homeScale = { X: 1, Y: 1 };

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSegment_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
          point_start: point_start,
          point_end:   point_end,

          stroke: "#000000",    //default
        };

        const icSegment = Object.assign(icObj, icSegment_spec);

        return icSegment;
      }

      createIcCompositeSegment(point_start, point_end) {
        // console.log("createIcSegment", point_start, point_end);
        const infiniteCanvas = this;

        const type = "compositeSegment";
        const position = point_start;
        const size = { width: 10, height: 10 };
        const homeScale = { X: 1, Y: 1 };

        const icObj = this.createIcObject(type, position, size, homeScale);


        var icPoint__start = infiniteCanvas.getArrIcPoint_near(point_start).find(e => true);
        if (icPoint__start == null) {
          const icPoint__start__new = infiniteCanvas.createIcPoint(point_start);
          icPoint__start__new.pointType = "circle";
          icPoint__start__new.fill = "orange";

          icPoint__start = icPoint__start__new;
        }

        var icPoint__end = infiniteCanvas.getArrIcPoint_near(point_end).find(e => true);;
        if (icPoint__end == null) {
          const icPoint__end__new = infiniteCanvas.createIcPoint(point_end);
          icPoint__end__new.pointType = "circle";
          icPoint__end__new.fill = "blue";

          icPoint__end = icPoint__end__new;
        }

        const icSegment = infiniteCanvas.createIcSegment(point_start, point_end);
        icSegment.lock();

        const icCompositeSegment_spec = {
          isSnappable: false,

          stroke: "red",
          strokeWidth: 4,

          parts: {
            sstroke: icSegment,
            point_start: icPoint__start,
            point_end: icPoint__end,
          },
        };

        const icCompositeSegment = Object.assign(icObj, icCompositeSegment_spec);

        //endPoints' handles

        class CompositeSegmentEngine {
          constructor() {

            this.initialized = false;

            this.initialize = function (scopeObj) {

              //"wake up":
              //bind all funcs
              // function isFunction(functionToCheck) {
              //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
              // }
              const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

              this.awoken = {
                'i_am': "awoken",
              };
              console.log("this.virgin", this.virgin);
              Object.entries(this.virgin)
                .filter(([propName, prop]) => isFunction(prop))
                .forEach(([propName, prop], i) => {
                  this.awoken[propName] = prop.bind(this.awoken);
                });

              // this.scopeObj  = scopeObj;
              //engineCarrier,
              //infiniteCanvas,
              this.awoken.scopeObj = scopeObj;

              this.initialized = true;
            };


            this.createSStrokeListener = function () {

              const sstroke__listener = (representation, propName, oldValue, newValue) => {
                // logger.log("sstroke__listener");
                const updatesDict = {
                  [propName]: {
                    old: oldValue,
                    new: newValue,
                  },
                };
                this.manageSStrokeUpdate(representation, updatesDict);
              };

              return sstroke__listener;
            };


            // this.counter__pointListeners = 0;
            this.createPointListener = function () {

              // const index__pointListener = this.counter__pointListeners;

              const point__listener = (representation, propName, oldValue, newValue) => {
                // logger.log("pointListener", index__pointListener);
                const updatesDict = {
                  [propName]: {
                    old: oldValue,
                    new: newValue,
                  },
                };
                this.managePointUpdate(representation, updatesDict);
              };

              // this.counter__pointListeners += 1;

              return point__listener;
            };



            this.createListeners = function () {
              var outListenersDict = {};

              const infiniteCanvas = this.scopeObj.infiniteCanvas;
              const handle = this.scopeObj.engineCarrier;

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free = handle__represented.r_free();

              //sstroke
              {
                const sstroke__listener = this.createSStrokeListener();
                const id__sstroke = handle__rep_free.parts.sstroke.id;
                outListenersDict[id__sstroke] = sstroke__listener;
              }

              //points
              //point_start
              {
                const point__listener = this.createPointListener();
                const id__point_start = handle__rep_free.parts.point_start.id;
                outListenersDict[id__point_start] = point__listener;
              }

              //point_end
              {
                const point__listener = this.createPointListener();
                const id__point_end = handle__rep_free.parts.point_end.id;
                outListenersDict[id__point_end] = point__listener;
              }

              return outListenersDict;
            };




            // this.getArr_everyone = function () {

            //   const infiniteCanvas = this.scopeObj.infiniteCanvas;
            //   const handle = this.scopeObj.engineCarrier;


            //   //get free_rep
            //   const handle__represented = infiniteCanvas.getRepresented(handle.id);
            //   const handle__rep_free = handle__represented.r_free();

            //   const parts = handle__rep_free.parts;

            //   return [handle__rep_free] + Object.values(parts);
            // };

            // this.getArr_everyoneBut = function (rep) {
            //   const arr_everyoneElse = this.getArr_everyone().filter(rep => rep.id != solo_rep.id);
            //   return arr_everyoneElse;
            // };

            // this.onEveryoneBut = function (solo_rep) {
            //   const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            //   arr_everyoneElse.forEach((rep, i) => {
            //     const listener = this.listeners[rep.id];
            //     rep.onInnerUpdate(listener);
            //   });
            // };

            // this.offEveryoneBut = function (rep) {
            //   const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            //   arr_everyoneElse.forEach((rep, i) => {
            //     const listener = this.listeners[rep.id];
            //     rep.offInnerUpdate(listener);
            //   });
            // };


            //sstroke update
            this.manageSStrokeUpdate = function (icObj_compositePart, outerUpdatesDict) {

            };

            //point update
            this.managePointUpdate = function (icObj_point, outerUpdatesDict) {

              //SHU FLUID
              logger.log("managePointUpdate", icObj_point, outerUpdatesDict);

              const infiniteCanvas = this.scopeObj.infiniteCanvas;
              const handle = this.scopeObj.engineCarrier;

              const id__point = icObj_point.id;
              console.log("id__point", id__point);

              // const compositeConfig = handle.compositeConfig;
              // console.log("compositeConfig", compositeConfig);
              // const isMobile = compositeConfig[id__point].isMobile;

              // if (isMobile) {

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free = handle__represented.r_free();

              // const part__represented   = infiniteCanvas.getRepresented(icObj_compositePart.id);

              // rep_free__composite.composite.managePartUpdate(rep_free__compositePart, outerUpdatesDict);
              if (outerUpdatesDict.position != null) {

                // var offset = {dx: 0, dy: 0};
                // if (outerUpdatesDict.position != null) {
                //   offset = {
                //     dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                //     dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
                //   };
                // }

                const rep_free__sstroke = handle__rep_free.parts.sstroke;
                {

                  // const engine_compositeSegment = this.scopeObj.engineCarrier.dict_engine["compositeSegment"].engine.awoken;
                  // const listener__sStroke       = engine_compositeSegment.listeners[icSStroke.id];
                  // console.log("°°°listener", listener);

                  const listener__sStroke = this.listeners[rep_free__sstroke.id];

                  //listen:off
                  // rep_free__sstroke.offInnerUpdate(listener__sStroke);   //SHU: innerUpdate must be kept on for live update of sstroke

                  //mutate
                  logger.log("mutating sstroke:", rep_free__sstroke.id);
                  {
                    if (icObj_point == handle__rep_free.parts.point_start) {

                      // const point_start_new = {
                      //   x: rep_free.point_start.x + offset.dx,
                      //   y: rep_free.point_start.y + offset.dy,
                      // };
                      const point_start_new = Object.assign({}, icObj_point.position);
                      rep_free__sstroke.point_start = point_start_new;

                    } else if (icObj_point == handle__rep_free.parts.point_end) {

                      // const point_end_new = {
                      //   x: rep_free.point_end.x + offset.dx,
                      //   y: rep_free.point_end.y + offset.dy,
                      // };
                      const point_end_new = Object.assign({}, icObj_point.position);
                      rep_free__sstroke.point_end = point_end_new;

                    } else {
                      throw new Error("moved point is not handled:", icObj_point);

                    }

                  }

                  //listen:on
                  // rep_free__sstroke.onInnerUpdate(listener__sStroke);   //SHU: innerUpdate must be kept on for live update of sstroke
                }

              }

              // }

            };


            this.start = function () {
              console.log("CompositeEngine::start, this", this);
              console.log("CompositeEngine::start", "this.scopeObj", this.scopeObj);

              this.listeners = this.createListeners();

              const infiniteCanvas = this.scopeObj.infiniteCanvas;
              const handle = this.scopeObj.engineCarrier;

              console.log("CompositeEngine.start", handle.id);

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free = handle__represented.r_free();

              //listen to handle
              // const handle__listener = this.listeners[handle.id];
              // handle__rep_free.onInnerUpdate(handle__listener);

              //listen to points
              // const parts = handle__rep_free.parts;
              // const arr_parts_all = Object.values(parts);

              const arr_point = [handle__rep_free.parts.point_start, handle__rep_free.parts.point_end];
              arr_point.forEach((point__rep_free, i) => {
                logger.log("point__rep_free", point__rep_free);

                //set compositeId if not done yet         //SHU: horror
                // part__rep_free.compositeId = handle__rep_free.id;

                //'activate' listeners
                logger.log("this.listeners", this.listeners);
                const point__listener = this.listeners[point__rep_free.id];
                logger.log("point__listener", point__listener);
                // if(typeof part__rep_free.onInnerUpdate === "function") { //SHU HORROR
                point__rep_free.onInnerUpdate(point__listener);
                // }
              });

            };

            this.stop = function () {

              const infiniteCanvas = this.scopeObj.infiniteCanvas;
              const handle = this.scopeObj.engineCarrier;

              console.log("compositeEngine.stop", handle);

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free = handle__represented.r_free();

              // const handle__listener = this.listeners[handle.id];
              // handle__rep_free.offInnerUpdate(handle__listener);

              // const parts = handle__rep_free.parts;
              // const arr_parts_all = Object.values(parts);
              // arr_parts_all.forEach((part__rep_free, i) => {

              //   // const part__listener = this.listeners[part__rep_free.id];
              //   // part__rep_free.offInnerUpdate(part__listener);

              //   this.removePart(part__rep_free);
              // });

            };



            this.virgin = Object.assign({}, this);  //virgin == not bound


          }

        }

        const engine_compositeSegment = new CompositeSegmentEngine();
        infiniteCanvas.installEngineOnIcObj(icCompositeSegment, "compositeSegment", engine_compositeSegment);

        return icCompositeSegment;
      }


      createIcDividedSegment() {

      }


      createIcRegularPolygon(point_A, point_B) {
        // console.log("createIcSegment", point_start, point_end);
        const infiniteCanvas = this;

        const type = "regularPolygon";
        const position = point_start;
        const size = { width: 10, height: 10 };
        const homeScale = { X: 1, Y: 1 };

        const icObj = this.createIcObject(type, position, size, homeScale);


        var icPoint__start = infiniteCanvas.getArrIcPoint_near(point_start).find(e => true);
        if (icPoint__start == null) {
          const icPoint__start__new = infiniteCanvas.createIcPoint(point_start);
          icPoint__start__new.pointType = "circle";
          icPoint__start__new.fill = "orange";

          icPoint__start = icPoint__start__new;
        }

        var icPoint__end = infiniteCanvas.getArrIcPoint_near(point_end).find(e => true);;
        if (icPoint__end == null) {
          const icPoint__end__new = infiniteCanvas.createIcPoint(point_end);
          icPoint__end__new.pointType = "circle";
          icPoint__end__new.fill = "blue";

          icPoint__end = icPoint__end__new;
        }

        const icSegment = infiniteCanvas.createIcSegment(point_start, point_end);
        icSegment.lock();

        const icCompositeSegment_spec = {
          isSnappable: false,

          stroke: "red",
          strokeWidth: 4,

          parts: {
            sstroke: icSegment,
            point_start: icPoint__start,
            point_end: icPoint__end,
          },
        };

        const icCompositeSegment = Object.assign(icObj, icCompositeSegment_spec);

        //endPoints' handles

        class CompositeSegmentEngine {
          constructor() {

            this.initialized = false;

            this.initialize = function (scopeObj) {

              //"wake up":
              //bind all funcs
              // function isFunction(functionToCheck) {
              //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
              // }
              const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

              this.awoken = {
                'i_am': "awoken",
              };
              console.log("this.virgin", this.virgin);
              Object.entries(this.virgin)
                .filter(([propName, prop]) => isFunction(prop))
                .forEach(([propName, prop], i) => {
                  this.awoken[propName] = prop.bind(this.awoken);
                });

              // this.scopeObj  = scopeObj;
              //engineCarrier,
              //infiniteCanvas,
              this.awoken.scopeObj = scopeObj;

              this.initialized = true;
            };


            this.createSStrokeListener = function () {

              const sstroke__listener = (representation, propName, oldValue, newValue) => {
                // logger.log("sstroke__listener");
                const updatesDict = {
                  [propName]: {
                    old: oldValue,
                    new: newValue,
                  },
                };
                this.manageSStrokeUpdate(representation, updatesDict);
              };

              return sstroke__listener;
            };


            // this.counter__pointListeners = 0;
            this.createPointListener = function () {

              // const index__pointListener = this.counter__pointListeners;

              const point__listener = (representation, propName, oldValue, newValue) => {
                // logger.log("pointListener", index__pointListener);
                const updatesDict = {
                  [propName]: {
                    old: oldValue,
                    new: newValue,
                  },
                };
                this.managePointUpdate(representation, updatesDict);
              };

              // this.counter__pointListeners += 1;

              return point__listener;
            };



            this.createListeners = function () {
              var outListenersDict = {};

              const infiniteCanvas = this.scopeObj.infiniteCanvas;
              const handle = this.scopeObj.engineCarrier;

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free = handle__represented.r_free();

              //sstroke
              {
                const sstroke__listener = this.createSStrokeListener();
                const id__sstroke = handle__rep_free.parts.sstroke.id;
                outListenersDict[id__sstroke] = sstroke__listener;
              }

              //points
              //point_start
              {
                const point__listener = this.createPointListener();
                const id__point_start = handle__rep_free.parts.point_start.id;
                outListenersDict[id__point_start] = point__listener;
              }

              //point_end
              {
                const point__listener = this.createPointListener();
                const id__point_end = handle__rep_free.parts.point_end.id;
                outListenersDict[id__point_end] = point__listener;
              }

              return outListenersDict;
            };




            // this.getArr_everyone = function () {

            //   const infiniteCanvas = this.scopeObj.infiniteCanvas;
            //   const handle = this.scopeObj.engineCarrier;


            //   //get free_rep
            //   const handle__represented = infiniteCanvas.getRepresented(handle.id);
            //   const handle__rep_free = handle__represented.r_free();

            //   const parts = handle__rep_free.parts;

            //   return [handle__rep_free] + Object.values(parts);
            // };

            // this.getArr_everyoneBut = function (rep) {
            //   const arr_everyoneElse = this.getArr_everyone().filter(rep => rep.id != solo_rep.id);
            //   return arr_everyoneElse;
            // };

            // this.onEveryoneBut = function (solo_rep) {
            //   const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            //   arr_everyoneElse.forEach((rep, i) => {
            //     const listener = this.listeners[rep.id];
            //     rep.onInnerUpdate(listener);
            //   });
            // };

            // this.offEveryoneBut = function (rep) {
            //   const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            //   arr_everyoneElse.forEach((rep, i) => {
            //     const listener = this.listeners[rep.id];
            //     rep.offInnerUpdate(listener);
            //   });
            // };


            //sstroke update
            this.manageSStrokeUpdate = function (icObj_compositePart, outerUpdatesDict) {

            };

            //point update
            this.managePointUpdate = function (icObj_point, outerUpdatesDict) {

              //SHU FLUID
              logger.log("managePointUpdate", icObj_point, outerUpdatesDict);

              const infiniteCanvas = this.scopeObj.infiniteCanvas;
              const handle = this.scopeObj.engineCarrier;

              const id__point = icObj_point.id;
              console.log("id__point", id__point);

              // const compositeConfig = handle.compositeConfig;
              // console.log("compositeConfig", compositeConfig);
              // const isMobile = compositeConfig[id__point].isMobile;

              // if (isMobile) {

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free = handle__represented.r_free();

              // const part__represented   = infiniteCanvas.getRepresented(icObj_compositePart.id);

              // rep_free__composite.composite.managePartUpdate(rep_free__compositePart, outerUpdatesDict);
              if (outerUpdatesDict.position != null) {

                // var offset = {dx: 0, dy: 0};
                // if (outerUpdatesDict.position != null) {
                //   offset = {
                //     dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                //     dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
                //   };
                // }

                const rep_free__sstroke = handle__rep_free.parts.sstroke;
                {

                  // const engine_compositeSegment = this.scopeObj.engineCarrier.dict_engine["compositeSegment"].engine.awoken;
                  // const listener__sStroke       = engine_compositeSegment.listeners[icSStroke.id];
                  // console.log("°°°listener", listener);

                  const listener__sStroke = this.listeners[rep_free__sstroke.id];

                  //listen:off
                  // rep_free__sstroke.offInnerUpdate(listener__sStroke);   //SHU: innerUpdate must be kept on for live update of sstroke

                  //mutate
                  logger.log("mutating sstroke:", rep_free__sstroke.id);
                  {
                    if (icObj_point == handle__rep_free.parts.point_start) {

                      // const point_start_new = {
                      //   x: rep_free.point_start.x + offset.dx,
                      //   y: rep_free.point_start.y + offset.dy,
                      // };
                      const point_start_new = Object.assign({}, icObj_point.position);
                      rep_free__sstroke.point_start = point_start_new;

                    } else if (icObj_point == handle__rep_free.parts.point_end) {

                      // const point_end_new = {
                      //   x: rep_free.point_end.x + offset.dx,
                      //   y: rep_free.point_end.y + offset.dy,
                      // };
                      const point_end_new = Object.assign({}, icObj_point.position);
                      rep_free__sstroke.point_end = point_end_new;

                    } else {
                      throw new Error("moved point is not handled:", icObj_point);

                    }

                  }

                  //listen:on
                  // rep_free__sstroke.onInnerUpdate(listener__sStroke);   //SHU: innerUpdate must be kept on for live update of sstroke
                }

              }

              // }

            };


            this.start = function () {
              console.log("CompositeEngine::start, this", this);
              console.log("CompositeEngine::start", "this.scopeObj", this.scopeObj);

              this.listeners = this.createListeners();

              const infiniteCanvas = this.scopeObj.infiniteCanvas;
              const handle = this.scopeObj.engineCarrier;

              console.log("CompositeEngine.start", handle.id);

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free = handle__represented.r_free();

              //listen to handle
              // const handle__listener = this.listeners[handle.id];
              // handle__rep_free.onInnerUpdate(handle__listener);

              //listen to points
              // const parts = handle__rep_free.parts;
              // const arr_parts_all = Object.values(parts);

              const arr_point = [handle__rep_free.parts.point_start, handle__rep_free.parts.point_end];
              arr_point.forEach((point__rep_free, i) => {
                logger.log("point__rep_free", point__rep_free);

                //set compositeId if not done yet         //SHU: horror
                // part__rep_free.compositeId = handle__rep_free.id;

                //'activate' listeners
                logger.log("this.listeners", this.listeners);
                const point__listener = this.listeners[point__rep_free.id];
                logger.log("point__listener", point__listener);
                // if(typeof part__rep_free.onInnerUpdate === "function") { //SHU HORROR
                point__rep_free.onInnerUpdate(point__listener);
                // }
              });

            };

            this.stop = function () {

              const infiniteCanvas = this.scopeObj.infiniteCanvas;
              const handle = this.scopeObj.engineCarrier;

              console.log("compositeEngine.stop", handle);

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free = handle__represented.r_free();

              // const handle__listener = this.listeners[handle.id];
              // handle__rep_free.offInnerUpdate(handle__listener);

              // const parts = handle__rep_free.parts;
              // const arr_parts_all = Object.values(parts);
              // arr_parts_all.forEach((part__rep_free, i) => {

              //   // const part__listener = this.listeners[part__rep_free.id];
              //   // part__rep_free.offInnerUpdate(part__listener);

              //   this.removePart(part__rep_free);
              // });

            };



            this.virgin = Object.assign({}, this);  //virgin == not bound


          }

        }

        const engine_compositeSegment = new CompositeSegmentEngine();
        infiniteCanvas.installEngineOnIcObj(icCompositeSegment, "compositeSegment", engine_compositeSegment);

        return icCompositeSegment;
      }


      createIcVibratingSegment(point__attach, length__base, cfg_in) {
        // console.log("createIcSegment", point_start, point_end);

        // const type      = "vibratingSegment";
        const type = "segment";

        const position = null;
        const size = null;
        const homeScale = { X: 1, Y: 1 };

        const icObj = this.createIcObject(type, position, size, homeScale);

        const point_start = point__attach;
        const point_end = {
          x: point_start.x + length__base,
          y: point_start.y,
        };

        const icSegment_spec = {
          point_start: point_start,
          point_end: point_end,
        };
        const icSegment = Object.assign(icObj, icSegment_spec);


        //lengthVibration

        class LengthVibrationEngine {
          constructor() {

            this.initialized = false;

            this.initialize = function (scopeObj) {

              //"wake up":
              //bind all funcs
              // function isFunction(functionToCheck) {
              //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
              // }
              const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

              this.awoken = {
                'i_am': "awoken",
              };
              console.log("this.virgin", this.virgin);
              Object.entries(this.virgin)
                .filter(([propName, prop]) => isFunction(prop))
                .forEach(([propName, prop], i) => {
                  this.awoken[propName] = prop.bind(this.awoken);
                });

              // this.scopeObj  = scopeObj;
              //engineCarrier,
              //infiniteCanvas,
              this.awoken.scopeObj = scopeObj;

              this.initialized = true;
            }

            // this.r_official_update_handler2 = function(rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions
            //
            //   // logger.log("r_official_update_handler2", rep_official_incoming);
            //
            //   // console.log("engine::r_official_update_handler2, this", this);
            //   // console.log("this.scopeObj", this.scopeObj);
            //
            // };

            this.start = function () {
              console.log("engine::start, this", this);
              logger.log("lengthVibrationEngine::start", "this.scopeObj", this.scopeObj);
              const infiniteCanvas = this.scopeObj.infiniteCanvas;
              const icObj = this.scopeObj.engineCarrier;

              {
                function startRefreshLoop() {
                  logger.log("log1", "startRefreshLoop");

                  /// get context from canvas (canvas not shown in example)
                  var ctx = canvas.getContext('2d');

                  var counter = 1;                  /// this is used to reduce FPS

                  //easing
                  const x = icObj.point_end.x;

                  var counter__easing = 0;
                  const nb_steps__easing = 5;
                  var x__prev = x;
                  var x__target = null;

                  /// register refresh loop
                  function refreshLoop() {

                    const represented = infiniteCanvas.getRepresented(icObj.id);
                    const rep_free = represented.r_free();

                    /// reduce frame-rate
                    const nb_skipped_frames__lengthVibration = 4;

                    if (counter % (nb_skipped_frames__lengthVibration + 1) == 0) {
                      setNewFrame();
                      counter = 1;
                    } else {
                      counter = counter + 1;
                    }

                    if (icObj.isShouldRequestAnimationFrame) {
                      requestAnimationFrame(refreshLoop);
                    }


                    function setNewFrame() {
                      const vibration = icObj.vibration;
                      const amp__normalized = vibration.next();

                      if (counter__easing == 0) {
                        if (x__target != null) {
                          x__prev = x__target;
                        }
                        x__target = length__base + length__base * amp__normalized * 0.2;
                        logger.log("x__target", x__target);
                      }

                      const progress = 1.0 * counter__easing / nb_steps__easing;
                      logger.log("progress", progress);
                      const x__next = math.floor(progress * x__target + (1 - progress) * x__prev);
                      logger.log("x__next", x__next);

                      counter__easing += 1;
                      counter__easing = counter__easing % nb_steps__easing;
                      logger.log("counter__easing", counter__easing);

                      rep_free.point_end = {
                        x: x__next,
                        y: icObj.point_end.y,
                      };

                    }

                  }

                  icObj.isShouldRequestAnimationFrame = true;
                  icObj.requestAnimationFrame = requestAnimationFrame(refreshLoop);

                }

                startRefreshLoop();

              }

            };

            this.stop = function () {
              // delete this.scopeObj;
            };


            this.virgin = Object.assign({}, this);  //virgin == not bound

          }
        }

        const seed = math.randomInt(1, 1000000000) * 3000;
        const symbol__inner = MathUtils.randomSymbolNode__kanji(seed);
        const vibration = new Vibration(seed);

        const icVibratingSegment_spec = {
          seed: seed,
          symbol__inner: symbol__inner,
          vibration: vibration,
        };
        Object.assign(icSegment, icVibratingSegment_spec);

        const engine_lengthVibration = new LengthVibrationEngine();
        infiniteCanvas.installEngineOnIcObj(icSegment, "lengthVibration", engine_lengthVibration);


        //colorVibration

        class ColorVibrationEngine {
          constructor() {

            this.initialized = false;

            this.initialize = function (scopeObj) {

              //"wake up":
              //bind all funcs
              // function isFunction(functionToCheck) {
              //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
              // }
              const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

              this.awoken = {
                'i_am': "awoken",
              };
              console.log("this.virgin", this.virgin);
              Object.entries(this.virgin)
                .filter(([propName, prop]) => isFunction(prop))
                .forEach(([propName, prop], i) => {
                  this.awoken[propName] = prop.bind(this.awoken);
                });

              // this.scopeObj  = scopeObj;
              //engineCarrier,
              //infiniteCanvas,
              this.awoken.scopeObj = scopeObj;

              this.initialized = true;
            }

            // this.r_official_update_handler2 = function(rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions
            //
            //   // logger.log("r_official_update_handler2", rep_official_incoming);
            //
            //   // console.log("engine::r_official_update_handler2, this", this);
            //   // console.log("this.scopeObj", this.scopeObj);
            //
            // };

            this.start = function () {
              console.log("engine::start, this", this);
              logger.log("lengthVibrationEngine::start", "this.scopeObj", this.scopeObj);
              const infiniteCanvas = this.scopeObj.infiniteCanvas;
              const icObj = this.scopeObj.engineCarrier;

              {
                function startRefreshLoop() {
                  logger.log("log1", "startRefreshLoop");

                  /// get context from canvas (canvas not shown in example)
                  var ctx = canvas.getContext('2d');

                  var counter = 1;                  /// this is used to reduce FPS

                  /// register refresh loop
                  function refreshLoop() {

                    const represented = infiniteCanvas.getRepresented(icObj.id);
                    const rep_free = represented.r_free();

                    /// reduce frame-rate
                    const nb_skipped_frames__lengthVibration = 6;
                    if (counter % (nb_skipped_frames__lengthVibration + 1) == 0) {
                      setNewFrame();
                      counter = 1;
                    } else {
                      counter = counter + 1;
                    }

                    if (icObj.isShouldRequestAnimationFrame) {
                      requestAnimationFrame(refreshLoop);
                    }


                    function setNewFrame() {

                      const vibration = icObj.vibration;

                      const arr_comp255__base1 = [50, 100, 150];
                      const arr_comp255__base2 = [240, 50, 0];
                      const arr_comp255__all = Utils.zip(arr_comp255__base1, arr_comp255__base2);

                      const amp__normalized = vibration.next();

                      const arr_comp255 = arr_comp255__all.map(([comp255__base1, comp255__base2]) => {
                        const comp255 = math.floor(comp255__base1 * amp__normalized + comp255__base2 * (1 - amp__normalized));
                        return comp255;
                      });

                      const arr_compHex = arr_comp255.map(comp255 => math.hex(comp255).slice(2));

                      const string__colorHex__next = arr_compHex.reduce((acc, compHex) => acc.concat(compHex), "#");
                      logger.log("string__colorHex__next", string__colorHex__next);
                      rep_free.stroke = string__colorHex__next;
                    }

                  }

                  icObj.isShouldRequestAnimationFrame = true;
                  icObj.requestAnimationFrame = requestAnimationFrame(refreshLoop);

                }

                startRefreshLoop();

              }

            };

            this.stop = function () {
              // delete this.scopeObj;
            };


            this.virgin = Object.assign({}, this);  //virgin == not bound

          }
        }

        const icVibratingSegment__color_spec = {
          stroke: "#000000",
        };
        Object.assign(icSegment, icVibratingSegment__color_spec);

        const engine_colorVibration = new ColorVibrationEngine();
        infiniteCanvas.installEngineOnIcObj(icSegment, "colorVibration", engine_colorVibration);

        if (cfg_in.symbol != null) {
          const symbol = cfg_in.symbol;
          const engine_symbolBinding = new SymbolBindingEngine(symbol);
          infiniteCanvas.installEngineOnIcObj(icSegment, "symbolBinding", engine_symbolBinding);
        }

        return icSegment;
      }



      createIcSpotLine_start() {
        // console.log("createIcLine_start");

        //check
        {
          const creationManager__line = this.creationManagers["line"];
          if (creationManager__line != null) {
            throw new Error("createIcLine_start, creationManager__line != null");
          }
        }

        // this.creationManagers["line"] = new LineCreationManager();
        this.creationManagers["line"] = {};
        const creationManager__line = this.creationManagers["line"];

        const true_cursor = this.getTrueCursor();

        creationManager__line.point_start = Object.assign({}, true_cursor);
      }

      createIcSpotLine_end() {
        // console.log("createIcLine_end");

        //check
        {
          const creationManager__line = this.creationManagers["line"];
          if (creationManager__line == null) {
            throw new Error("createIcLine_end, creationManager__line == null");
          }
        }

        const creationManager__line = this.creationManagers["line"];

        const true_cursor = this.getTrueCursor();

        creationManager__line.point_end = Object.assign({}, true_cursor);

        // this.createIcLine(creationManager__line.point_start, creationManager__line.point_end);
        const icSegment = this.createIcSegment(creationManager__line.point_start, creationManager__line.point_end);
        this.addNewIcObject(icSegment);

        delete this.creationManagers["line"];
      }

      createIcSpotLine(startPoint, endPoint) {

        const type = "spotLine";
        const position = Geometry.createPoint(left, top);
        const size = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;

      }

      createIcSpotSegment(point_start, point_end) {
        // console.log("createIcSegment", point_start, point_end);

        const type = "spotSegment";
        const position = null;
        const size = null;
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSegment_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
          point_start: point_start,
          point_end: point_end,
        };

        const icSegment = Object.assign(icObj, icSegment_spec);

        return icSegment;
      }




      createIcSlider(trueRect, sliderConfig) {
        // console.log("createIcSlider", trueRect, sliderConfig);

        const infiniteCanvas = this;

        const type = "slider";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);





        const ratio__wh_end = 1. / 80;
        const ratio__wh_marker = 1. / 120;


        const pointL = Geometry.createPoint(-800, -200);
        const width = 2000;
        const pointR = Geometry.createPoint(pointL.x + width, pointL.y);

        const icSegment__segment = infiniteCanvas.createIcSegment(pointL, pointR);
        // infiniteCanvas.addIcObject(icObj_Segment__segment);


        //mark ends

        const height__end = ratio__wh_end * width;

        const point_endL_T = Geometry.createPoint(pointL.x, pointL.y - height__end);
        const point_endL_B = Geometry.createPoint(pointL.x, pointL.y + height__end);

        const icSegment__endL = infiniteCanvas.createIcSegment(point_endL_T, point_endL_B);
        // infiniteCanvas.addIcObject(icObj_Segment__endL);


        const point_endR_T = Geometry.createPoint(pointR.x, pointR.y - height__end);
        const point_endR_B = Geometry.createPoint(pointR.x, pointR.y + height__end);

        const icSegment__endR = infiniteCanvas.createIcSegment(point_endR_T, point_endR_B);
        // infiniteCanvas.addIcObject(icObj_Segment__endR);






        //valueify segment
        const ratio__wh_spot = 1. / 100;

        const size__spot = {
          width: ratio__wh_spot * width,
          height: ratio__wh_spot * width,
        };


        function createLabeledPoint(point, value) {

          const icPoint = infiniteCanvas.createIcPoint(point);
          icPoint.pointType = "circle";
          // icPoint.fill      = "lime";


          const mathNode = new math.ConstantNode(value);
          const icMathNode = infiniteCanvas.createIcMathNode(icPoint.position.x, icPoint.position.y, mathNode);


          const mixedScaleEngine = new MixedScaleEngine();
          infiniteCanvas.installEngineOnIcObj(icMathNode, "mixedScale", mixedScaleEngine);
          icMathNode.scale__mixed = {
            X: 0.5,
            Y: 0.5,
          };
          const parts = {
            "point": icPoint,
            "mathNode": icMathNode,
          };
          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
          // compositeConfig__knob[icMathNode.id].isMobile = true;
          const trueRect__composite = {
            x: icPoint.position.x,
            y: icPoint.position.y,
            // width:  icPoint.size.width,
            // height: icPoint.size.height,
            width: 0,
            height: 0,
          };
          // logger.log("trueRect__composite", trueRect__composite);
          const icLabeledPoint = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig);
          icLabeledPoint.cType = "labeledPoint";

          return icLabeledPoint;
        }

        const icLabeledPoint__L = createLabeledPoint(pointL, sliderConfig.value__L);
        icLabeledPoint__L.parts.point.fill = "orange";
        const icLabeledPoint__R = createLabeledPoint(pointR, sliderConfig.value__R);
        icLabeledPoint__R.parts.point.fill = "orange";

        const icLabeledPoint__knob = createLabeledPoint(pointL, sliderConfig.value);
        icLabeledPoint__knob.parts.point.fill = "lime";



        function mark_divide(point1, point2, nb_sectors, ratio_wh_marker) {

        }

        function createMarkerWithValue(icSegment, value_min, value_max, value) {
          const progress = (value - value_min) / (value_max - value_min);
          const icSegment__marker = createMarkerWithProgress(icSegment, progress);
          return icSegment__marker;
        }

        function createMarkerWithProgress(icSegment, progress) {

          const pointL = icSegment.point_start;
          const pointR = icSegment.point_end;

          const vSegment = Geometry.vector_2d(icSegment.point_start, icSegment.point_end);
          const width = Geometry.norm_2d(vSegment);

          const height__marker = ratio__wh_marker * width;

          const x__progress = pointL.x + progress * (pointR.x - pointL.x);
          const y__progress = pointL.y + progress * (pointR.y - pointL.y);

          const point__marker_T = Geometry.createPoint(x__progress, y__progress - height__marker);
          const point__marker_B = Geometry.createPoint(x__progress, y__progress + height__marker);

          const icSegment__marker = infiniteCanvas.createIcSegment(point__marker_T, point__marker_B);
          return icSegment__marker;
        }


        const icSegment__marker_0 = createMarkerWithValue(icSegment__segment, sliderConfig.value__L, sliderConfig.value__R, 0);
        const icSegment__marker_1 = createMarkerWithValue(icSegment__segment, sliderConfig.value__L, sliderConfig.value__R, 1);


        const parts = {
          "segment": icSegment__segment,
          "endL": icSegment__endL,
          "endR": icSegment__endR,

          "marker_0": icSegment__marker_0,
          "marker_1": icSegment__marker_1,

          // "pointL":   icPoint__L,
          // "pointR":   icPoint__R,
          // "knob":     icPoint__knob,
          "labeledPoint_L": icLabeledPoint__L,
          "labeledPoint_R": icLabeledPoint__R,
          "labeledPoint_knob": icLabeledPoint__knob,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        // compositeConfig[icPoint.id].isMobile = true;

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "slider";




        const icSlider_spec = {
          value__L: sliderConfig.value__L,
          value__R: sliderConfig.value__R,

          // value: sliderConfig.value,
          mathNode: new math.ConstantNode(sliderConfig.value),
        };

        const icSlider = Object.assign(icComposite, icSlider_spec);



        const sliderEngine = new SliderEngine();
        infiniteCanvas.installEngineOnIcObj(icSlider, "slider", sliderEngine);


        // //debug
        // infiniteCanvas.onceOnAddRepresentedForIcObject(icSlider, (icSlider) => {
        //   const rep_free = infiniteCanvas.getRepresented(icSlider.id).r_free();

        //   setTimeout(() => {
        //     rep_free.mathNode = new math.ConstantNode(50);
        //   }, 3000);

        // })



        return icSlider;
      }







      createIcHUDLine_start() {
        // console.log("createIcHUDLine_start");

        //check
        {
          const creationManager__line = this.creationManagers["HUD_line"];
          if (creationManager__line != null) {
            throw new Error("createIcHUDLine_start, creationManager__line != null");
          }
        }

        // this.creationManagers["HUD_line"] = new LineCreationManager();
        this.creationManagers["HUD_line"] = {};
        const creationManager__line = this.creationManagers["HUD_line"];

        const true_cursor = this.getTrueCursor();

        creationManager__line.point_start = Object.assign({}, true_cursor);
      }

      createIcHUDLine_end() {
        // console.log("createIcLine_end");

        //check
        {
          const creationManager__line = this.creationManagers["HUD_line"];
          if (creationManager__line == null) {
            throw new Error("createIcHUDLine_end, creationManager__line == null");
          }
        }

        const creationManager__line = this.creationManagers["HUD_line"];

        const true_cursor = this.getTrueCursor();

        creationManager__line.point_end = Object.assign({}, true_cursor);

        // this.createIcLine(creationManager__line.point_start, creationManager__line.point_end);
        const icSegment = this.createIcHUDSegment(creationManager__line.point_start, creationManager__line.point_end);
        this.addNewIcObject(icSegment);

        delete this.creationManagers["HUD_line"];
      }

      createIcHUDLine(startPoint, endPoint) {

        const type = "HUD_line";
        const position = Geometry.createPoint(left, top);
        const size = Geometry.createSize(width, height);
        const homeScale = { X: 1, Y: 1 };

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;

      }

      createIcHUDSegment(point_start, point_end) {
        // console.log("createIcHUDSegment", point_start, point_end);

        const type = "HUD_segment";
        const position = null;
        const size = null;
        const homeScale = { X: 1, Y: 1 };

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSegment_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
          point_start: point_start,
          point_end: point_end,
        };

        const icSegment = Object.assign(icObj, icSegment_spec);

        return icSegment;
      }






      // createIcSConveyor(path, replayObj) {
      createIcUniformSConveyor(path, cfg_in = null) {
        logger.log("createIcUniformSConveyor", path, cfg_in);

        const point__start = PathUtils.startingPointFromPath(path);

        const trueRect = {
          x: point__start.x,
          y: point__start.y,
          width: 100,
          height: 100,
        };

        const text_in = "pathmade:conveyor";

        // const transformationFunc = this.transformationFuncForReplayObj(replayObj);
        const transformationFunc = async function (icObj, icTouchSlot) {

          //prevent original from touches while shadePossessor is running     //SHU: il faudra trouver un moyen de faire autrement car c'est moche
          // icObj.isTouchable = false;

          const transformationFunc_p = infiniteCanvas.transformationFunc_pForReplayObj(replayObj);
          const transformationOutput = await transformationFunc_p(icObj)
            .then(transformationOutput => {

              //restore isTouchable                 //SHU: il faudra trouver un moyen de faire autrement car c'est moche
              // if(icObj.type != "geminiShade") {
              //   icObj.isTouchable = true;
              // }

              return transformationOutput;
            });

          return transformationOutput;
        };

        const operatorConfig = new OperatorConfig(text_in, transformationFunc);

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_operator";

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;


        const icPathmadeOperator_spec = {
          path: path,
        };

        const icPathmadeOperator = Object.assign(icComposite, icPathmadeOperator_spec);

        return icPathmadeOperator;
      }



      // createIcZSegment(icCircle1, icCircle2) {
      createIcZSegment(p__start,r__start, p__end,r__end) {
        const infiniteCanvas = this;

        // const color__fill = "";
        const color__fill = "rgba(0, 0, 0, 0.7)";

        const icCircle__start = infiniteCanvas.createIcCircle(p__start, r__start);
        icCircle__start.stroke  = "blue";
        icCircle__start.fill    = color__fill;


        const icCircle__end   = infiniteCanvas.createIcCircle(p__end, r__end);
        icCircle__end.stroke  = "red";
        icCircle__end.fill    = color__fill;

        const enveloppeRect__circleCircle  = Geometry.getEnveloppeRect__circleCircle(p__start,r__start, p__end,r__end);
        
        const arr__arr_point = Geometry.getArr_extangent_point__circleCircle(p__start,r__start, p__end,r__end);
        // logger.log("logZSegment", "arr__arr_point", arr__arr_point);
        const arr_point = [arr__arr_point[0][0], arr__arr_point[0][1], arr__arr_point[1][1], arr__arr_point[1][0]];

        const icPolygon = infiniteCanvas.createIcPolygon(arr_point);
        icPolygon.stroke = "rgba(150, 50,150,0.5)";
        icPolygon.fill   = color__fill;
        icPolygon.homeScale = {
          X: 1.0,
          Y: 1.0,
        };
        icPolygon.canBeSelected = false;
        

        const parts = {
      	  "zPoint_start": icCircle__start,
	        "zPoint_end":   icCircle__end,
          "zsstroke":     icPolygon,
        };

        // const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        
        const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
        // compositeConfig[icPolygon.id].isMobile = false;

        const trueRect__composite = {
          // x:      p__start.x - r__start,
          // y:      p__start.y - r__start,
          x:      enveloppeRect__circleCircle.x - r__start / 2.0,
          y:      enveloppeRect__circleCircle.y - r__start / 2.0,
          width:  r__start / 4.0,
          height: r__start / 4.0,
        };
        const icComposite = this.createIcComposite(trueRect__composite, parts, compositeConfig);
        icComposite.cType = "zSegment";

        //deactivate composite listeners
        infiniteCanvas.onceOnAddRepresentedForIcObject((icComposite), (icComposite) => {
          const rep_free__icComposite = infiniteCanvas.getRepresented(icComposite.id).r_free();
          const listeners__in_composite = rep_free__icComposite.dict_engine["composite"].engine.awoken.listeners;
          Object.values(rep_free__icComposite.parts).forEach((rep_free__part) => {
            const listener = listeners__in_composite[rep_free__part.id];
            rep_free__part.offInnerUpdate(listener);
          });
        });



        const icZSegment = icComposite;

        const engine_zSegment = new ZSegmentEngine();
        infiniteCanvas.installEngineOnIcObj(icZSegment, "zSegment", engine_zSegment);

        return icZSegment;
      }





      createIcSSPathmadeOperator_start(type__pathmadeOp) {
        // console.log("createIcSSPathmadeOperator_start");

        const infiniteCanvas = this;

        //check
        {
          const creationManager__ssPathmadeOperator = infiniteCanvas.creationManagers["ssPathmadeOperator"];
          if (creationManager__ssPathmadeOperator != null) {
            throw new Error("createIcSSPathmadeOperator_start, creationManager__ssPathmadeOperator != null");
          }
        }

        infiniteCanvas.creationManagers["ssPathmadeOperator"] = {
          type: type__pathmadeOp,
        };
        const creationManager__ssPathmadeOperator = infiniteCanvas.creationManagers["ssPathmadeOperator"];


      }

      createIcSSPathmadeOperator_end_p(size__start) {
        // console.log("createIcSSPathmadeOperator_end");

        const infiniteCanvas = this;

        //check
        {
          const creationManager__ssPathmadeOperator = infiniteCanvas.creationManagers["ssPathmadeOperator"];
          if (creationManager__ssPathmadeOperator == null) {
            const err = new Error("createIcSSPathmadeOperator_end, creationManager__ssPathmadeOperator == null");
            out_p = Promise.reject(err);
          }
        }

        const creationManager__ssPathmadeOperator = infiniteCanvas.creationManagers["ssPathmadeOperator"];

        

        const type__pathmadeOp = creationManager__ssPathmadeOperator.type;
        const arr_point        = creationManager__ssPathmadeOperator.arr_point;

        const dict_icObj = creationManager__ssPathmadeOperator.dict_icObj;

        const icSSPathmadeOperator = infiniteCanvas.createIcSSPathmadeOperator(type__pathmadeOp, arr_point, dict_icObj);

        delete this.creationManagers["ssPathmadeOperator"];

        return Promise.resolve(icSSPathmadeOperator);
      }




      // createEventstore_p() {
      //   //logger.log("createEventstore_p");
      //
      //   const eventstore = new Eventstore();
      //   return eventstore.initialize();
      // }
      createEventstore() {
        // logger.log("createEventstore");

        const eventstore = new Eventstore();
        eventstore.initialize();

        return eventstore;
      }

      getArrEvent_p(eventstore__) {
        var out_p;

        const replayStream_p = eventstore__.getReplay({
          // fromPosition: 7,
          // toPosition: 23
        });

        out_p = replayStream_p.then(readEventStream_p);

        return out_p;
      }

      getReplayObj_p(eventstore__) {
        var out_p;

        out_p = this.getArrEvent_p(eventstore__)
          .then(arr_event__replay => {

            const replayObj = {
              arr_event: arr_event__replay,
            };

            return replayObj;
          });

        return out_p;
      }

      performReplay(arr_event__replay) {

        const event__first = arr_event__replay[0];
        const time__first = event__first.data.time;
        const arr_replayEvent = arr_event__replay.map(event => {
          const event__clone = Object.assign({}, event);

          const time__event = event__clone.data.time
          event__clone.timeout = time__event - time__first;

          return event__clone;
        });

        arr_replayEvent.forEach((replayEvent, i) => {
          setTimeout(() => {
            infiniteCanvas.manageMoveEvent(replayEvent);
          }, replayEvent.timeout);
        });

      }


      createIcReplay_start() {
        // console.log("createIcReplay_start");

        const infiniteCanvas = this;

        //check
        {
          const creationManager__replay = infiniteCanvas.creationManagers["replay"];
          if (creationManager__replay != null) {
            throw new Error("createIcReplay_start, creationManager__replay != null");
          }
        }

        // infiniteCanvas.creationManagers["replay"] = new icReplayCreationManager();
        infiniteCanvas.creationManagers["replay"] = {};
        const creationManager__replay = infiniteCanvas.creationManagers["replay"];


        //create dedicated eventstore
        // infiniteCanvas.createEventstore_p()
        // .then((eventstore__replay) => {
        //   logger.log("eventstore__replay", eventstore__replay);
        //   creationManager__replay.eventstore = eventstore__replay;
        // });
        const eventstore__replay = infiniteCanvas.createEventstore();
        logger.log("eventstore__replay", eventstore__replay);
        creationManager__replay.eventstore = eventstore__replay;

        //start recording
        creationManager__replay.sub = infiniteCanvas.rx_icEvent_observable.subscribe({
          next: (icEvent) => {
            infiniteCanvas.recordIcEvent_p(eventstore__replay, icEvent);

            //debug
            infiniteCanvas.recordIcEvent_p(eventstore__global, icEvent);
          },
        });

      }

      createIcReplay_end() {
        // console.log("createIcReplay_end");

        const infiniteCanvas = this;

        //check
        {
          const creationManager__replay = this.creationManagers["replay"];
          if (creationManager__replay == null) {
            throw new Error("createIcReplay_end, creationManager__replay == null");
          }
        }

        const creationManager__replay = this.creationManagers["replay"];

        //stop recording
        creationManager__replay.sub.unsubscribe();



        const true_cursor = this.getTrueCursor();
        // creationManager__replay.point_end = Object.assign({}, true_cursor);
        const trueRect = {
          x: true_cursor.x,
          y: true_cursor.y,
          width: 100,
          height: 100,
        };

        const eventstore__replay = creationManager__replay.eventstore;
        const replayObj_p = this.getReplayObj_p(eventstore__replay);

        replayObj_p.then(replayObj => {

          const icReplay = infiniteCanvas.createIcReplay(trueRect, replayObj);
          infiniteCanvas.addIcObject(icReplay);

          delete infiniteCanvas.creationManagers["replay"];
        });

      }

      createIcReplay(trueRect, replayObj) {
        logger.log("createIcReplay", trueRect, replayObj);

        const type = "replay";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);
        icObj.fill = "red";

        const icReplay_spec = {
          replayObj: replayObj,
        };

        const icReplay = Object.assign(icObj, icReplay_spec);

        return icReplay;
      }





      createIcPathmadeOperator_start(type__pathmadeOp) {
        // console.log("createIcPathmadeOperator_start");

        const infiniteCanvas = this;

        //check
        {
          const creationManager__pathmadeOperator = infiniteCanvas.creationManagers["pathmadeOperator"];
          if (creationManager__pathmadeOperator != null) {
            throw new Error("createIcPathmadeOperator_start, creationManager__pathmadeOperator != null");
          }
        }

        infiniteCanvas.creationManagers["pathmadeOperator"] = {
          type: type__pathmadeOp,
        };
        const creationManager__pathmadeOperator = infiniteCanvas.creationManagers["pathmadeOperator"];

        //create dedicated eventstore
        const eventstore__pathmadeOperator = infiniteCanvas.createEventstore();
        logger.log("eventstore__pathmadeOperator", eventstore__pathmadeOperator);
        creationManager__pathmadeOperator.eventstore = eventstore__pathmadeOperator;

        //start recording
        creationManager__pathmadeOperator.sub = infiniteCanvas.rx_icEvent_observable.subscribe({
          next: (icEvent) => {
            infiniteCanvas.recordIcEvent_p(eventstore__pathmadeOperator, icEvent);
          },
        });

      }

      createIcPathmadeOperator_end_p(size__start) {
        // console.log("createIcPathmadeOperator_end_p");
        var out_p;

        const infiniteCanvas = this;

        //check
        {
          const creationManager__pathmadeOperator = infiniteCanvas.creationManagers["pathmadeOperator"];
          if (creationManager__pathmadeOperator == null) {
            const err = new Error("createIcPathmadeOperator_end_p, creationManager__pathmadeOperator == null");
            out_p = Promise.reject(err);
          }
        }

        const creationManager__pathmadeOperator = infiniteCanvas.creationManagers["pathmadeOperator"];

        //stop recording
        creationManager__pathmadeOperator.sub.unsubscribe();


        const type__pathmadeOp = creationManager__pathmadeOperator.type;
        const path = creationManager__pathmadeOperator.path;
        const replayObj = creationManager__pathmadeOperator.replayObj;

        const eventstore__pathmadeOperator = creationManager__pathmadeOperator.eventstore;
        const replayObj_p = infiniteCanvas.getReplayObj_p(eventstore__pathmadeOperator);

        const dict_icObj = creationManager__pathmadeOperator.dict_icObj;

        out_p = replayObj_p
          .then(replayObj => {

            const icPathmadeOperator = infiniteCanvas.createIcPathmadeOperator(type__pathmadeOp, path, replayObj, dict_icObj);

            delete this.creationManagers["pathmadeOperator"];

            return icPathmadeOperator;
          });

        return out_p;
      }

      // createIcPathmadeOperator_from_operatorPathDrawingFObj(fObj) {
      //   console.log("createIcPathmadeOperator_from_operatorPathDrawingFObj", fObj);
      //   console.log("createIcPathmadeOperator_from_operatorPathDrawingFObj", fObj.constructor.name);
      //
      //   const type      = "pathmadeOperator";
      //
      //   const trueRect  = this.toTrueRect(fObj);
      //   const position = Geometry.getPointTL(trueRect);
      //   const size     = Geometry.createSize(trueRect.width, trueRect.height);
      //
      //   const homeScale = Object.assign({}, this.scale);
      //
      //   const icObj = this.createIcObject(type, position, size, homeScale);
      //
      //
      //   const exoObject = Object.assign({}, fObj);
      //   exoObject.icObj = null; // remove circular dependency
      //
      //   const icPathmadeOperator_spec = {
      //     path: fObj.path,
      //     // exoObject: exoObject,
      //   };
      //
      //   const icPathmadeOperator = Object.assign(icObj, icPathmadeOperator_spec);
      //
      //   return icPathmadeOperator;
      // }


      transformationFuncForReplayObj(replayObj) {
        var outFunc;

        outFunc = function (icObj) {
          var transformationOutput;

          //debug
          // if(icObj.text != null) {
          //   icObj.text += "lol";
          // }


          const arr_event__replay = replayObj.arr_event;
          if (arr_event__replay.length > 0) {

            const event__first = arr_event__replay[0];
            const time__first = event__first.data.time;
            const arr_replayEvent = arr_event__replay.map(event => {
              const event__clone = Object.assign({}, event);

              const time__event = event__clone.data.time
              event__clone.timeout = time__event - time__first;

              return event__clone;
            });


            arr_replayEvent.forEach((replayEvent, i) => {
              setTimeout(() => {

                const rep_free = icObj;

                const moveEvent = replayEvent;

                //"apply" event
                const position__new = moveEvent.data.position;
                rep_free.position = position__new;

              }, replayEvent.timeout);
            });

          }




          transformationOutput = new TransformationOutput("mutated", icObj, icObj);

          return transformationOutput;
        };

        return outFunc;
      }

      // doEvent_p(icEvent) {
      //
      // }

      transformationFunc_pForReplayObj(replayObj) {
        var outFunc;

        outFunc = function (icObj) {
          var out_p;

          //follow a new path
          icObj.counter__path += 1;
          const index__path = icObj.counter__path;

          const arr_event__replay = replayObj.arr_event;
          if (arr_event__replay.length > 0) {

            const event__first = arr_event__replay[0];
            const time__first = event__first.data.time;
            const arr_replayEvent = arr_event__replay.map(event => {
              const event__clone = Object.assign({}, event);

              const time__event = event__clone.data.time
              event__clone.timeout = time__event - time__first;

              return event__clone;
            });

            function createPromiseForReplayEvent(replayEvent) {
              return new Promise((resolve, reject) => {

                setTimeout(() => {

                  if (icObj.counter__path == index__path) {

                    const rep_free = icObj;

                    const moveEvent = replayEvent;

                    //"apply" event
                    const position__new = moveEvent.data.position;
                    rep_free.position = position__new;

                      //debug
                    // if("homeScale" in moveEvent.data) {
                    //   const homeScale__new = moveEvent.data.homeScale;
                    //   rep_free.homeScale = homeScale__new;
                    // }

                    resolve(rep_free);

                  } else {
                    // const err = new Error("icObj.id__replayObj != replayObj.id");
                    // reject(err);
                    resolve(icObj);
                  }

                }, replayEvent.timeout);
              });
            }

            const arr_promise = arr_replayEvent.map(createPromiseForReplayEvent);

            var transformationOutput = new TransformationOutput("mutated", icObj, icObj);

            out_p = bluebird.reduce(arr_promise, (acc, x) => {
              // logger.log("x", x);
              return acc;
            }, transformationOutput);

            //debug
            // out_p = out_p.then(transformationOutput => {
            //   logger.log("transformationOutput", transformationOutput);
            //   return transformationOutput;
            // });

          } else {
            out_p = Promise.reject(new Error("arr_event__replay.length == 0"));
          }

          return out_p;
        };

        return outFunc;
      }

      transformationFunc_pForSSConveyorWithArrPoint(arr_point) {
        var outFunc;

        // outFunc = function (icObj) {

        //   icObj.position = arr_point.slice(-1)[0];

        //   var transformationOutput = new TransformationOutput("mutated", icObj, icObj);

        //   return transformationOutput;
        // };

        function func_length(point_A, point_B) {
          return Geometry.norm_2d(Geometry.vector_2d(point_A, point_B));
        }

        const point__start  = arr_point[0];
        const point__end    = arr_point.slice(-1)[0];

        const arr_dict_segment__raw = Utils.zip(arr_point.slice(0,-1), arr_point.slice(1)).map(([point_A, point_B]) => {
          const length__AB = func_length(point_A, point_B);
          const miniDict__segment = {
            length: length__AB,
            point_A: point_A,
            point_B: point_B,
          }; 
          return miniDict__segment;
        });

        const length__total = arr_dict_segment__raw.reduce((acc, dict__segment) => {
          return acc + dict__segment.length;
        }, 0);

        const arr_dict_segment__refined = arr_dict_segment__raw.reduce((acc, dict__segment) => {
          
          dict__segment.absc_A = acc.absc__current;
          dict__segment.absc_B = dict__segment.absc_A + dict__segment.length;
          
          dict__segment.progress_A = 1.0 * dict__segment.absc_A / length__total;
          dict__segment.progress_B = 1.0 * dict__segment.absc_B / length__total;
          
          acc.arr_segment.push(dict__segment);
          acc.absc__current = dict__segment.absc_B;

          return acc;
        }, {
          arr_segment: [],
          absc__current: 0,
        }).arr_segment;
        logger.log("logSSPathmade", "arr_dict_segment__refined:", arr_dict_segment__refined);

        const duration__total = 2000;
        const nb_step         = 100;
        const duration__step  = 1.0 * duration__total / nb_step;

        const progress__step  = 1.0 / (nb_step-1);

        const arr_progress = [...Array(nb_step).keys()].map((index) => {
          const progress = index * progress__step;
          return progress;
        });

        function pointForProgress(progress, arr_dict_segment) {
          var outPoint;

          if(progress == 1.0) {
            outPoint = arr_dict_segment.slice(-1)[0].point_B;
          } else {
            const dict__segment = arr_dict_segment.find((dict__segment) => (dict__segment.progress_A <= progress) && (progress < dict__segment.progress_B) );
            logger.log("logSSPathmade", "dict__segment:", dict__segment);
            
            const progress__inner = (progress - dict__segment.progress_A) / (dict__segment.progress_B - dict__segment.progress_A);
            const point__progress__inner = {
              x: dict__segment.point_A.x + progress__inner * (dict__segment.point_B.x - dict__segment.point_A.x),  
              y: dict__segment.point_A.y + progress__inner * (dict__segment.point_B.y - dict__segment.point_A.y),
            };
            outPoint = point__progress__inner;
          }

          return outPoint;
        }

        //create artifical array of points with constant progress step
        const arr_point__step = arr_progress.map((progress) => {
          const point__progress = pointForProgress(progress, arr_dict_segment__refined);
          return point__progress;
        });

        function createMoveEventForPoint(point) {
          var outMoveEvent;

          outMoveEvent = {};

          outMoveEvent.data    = {};
          outMoveEvent.data.offset = {
            dx: point.x - point__start.x,
            dy: point.y - point__start.y,
          };

          return outMoveEvent;
        }

        const arr_moveEvent = arr_point__step.reduce((acc, point) => {

          const moveEvent = createMoveEventForPoint(point);
          
          // moveEvent.data.time = acc.time;
          moveEvent.timeout = acc.time;

          acc.arr_event.push(moveEvent);

          acc.time += duration__step;

          return acc;
        }, {
          arr_event: [],
          time: 0,
        }).arr_event;

        outFunc = function (icObj) {
          var out_p;

          //follow a new path
          icObj.counter__path += 1;
          const index__path = icObj.counter__path;

          const arr_event__move = arr_moveEvent;

          //get initial position
          // const position__start = Object.assign({}, icObj.position);
          // const position__start = {
          //   x: icObj.position.x /*- icObj.size.width  / 2.0*/,
          //   y: icObj.position.y - icObj.size.height / 2.0,
          // };
          // const position__start = {
          //   x: icObj.position.x,
          //   y: icObj.position.y,
          // };
          // const position__start = Object.assign({}, point__start);
          const position__start = {
            x: point__start.x - icObj.size.width  / 2.0,
            y: point__start.y - icObj.size.height / 2.0,
          };

          if (arr_event__move.length > 0) {
            function createPromiseForMoveEvent(moveEvent) {
              return new Promise((resolve, reject) => {

                setTimeout(() => {

                  if (icObj.counter__path == index__path) {

                    const rep_free = icObj;

                    //"apply" event
                    const position__new = {
                      // x: rep_free.position.x + moveEvent.data.offset.dx,
                      // y: rep_free.position.y + moveEvent.data.offset.dy,
                      x: position__start.x + moveEvent.data.offset.dx,
                      y: position__start.y + moveEvent.data.offset.dy,
                    };
                    rep_free.position = position__new;

                    resolve(rep_free);

                  } else {
                    // const err = new Error("icObj.id__replayObj != replayObj.id");
                    // reject(err);
                    resolve(icObj);
                  }

                }, moveEvent.timeout);
              });
            }

            const arr_promise = arr_event__move.map(createPromiseForMoveEvent);

            const isUsingCenterPosition__previous = icObj.isUsingCenterPosition;

            const arr_promise__refined = [
              new Promise((resolve, reject) => {
                //ensure center position is used
                icObj.isUsingCenterPosition = true;
                resolve(icObj);
              }),
              ...arr_promise,
              new Promise((resolve, reject) => {
                //restore position origin
                icObj.isUsingCenterPosition = isUsingCenterPosition__previous;
                resolve(icObj);
              }),
            ];

            var transformationOutput = new TransformationOutput("mutated", icObj, icObj);

            out_p = bluebird.reduce(arr_promise__refined, (acc, x) => {
              // logger.log("x", x);
              return acc;
            }, transformationOutput);

            //debug
            // out_p = out_p.then(transformationOutput => {
            //   logger.log("transformationOutput", transformationOutput);
            //   return transformationOutput;
            // });

          } else {
            out_p = Promise.reject(new Error("arr_event__replay.length == 0"));
          }

          return out_p;
        };

        return outFunc;
      }


      createIcDummy(trueRect) {
        logger.log("createIcDummy");

        const icObj = this.createIcRect(trueRect);

        const fColor__fill = new fabric.Color("black");
        fColor__fill.setAlpha(0.444);
        icObj.fill = fColor__fill.toRgba();

        icObj.strokeWidth = 2;
        const fColor__stroke = new fabric.Color("red");
        fColor__stroke.setAlpha(0.444);
        icObj.stroke = fColor__stroke.toRgba();

        const icDummy_spec = {
          isDummy: true,
        };

        const icDummy = Object.assign(icObj, icDummy_spec);

        return icDummy;
      }

      createIcDummy_from_fObj(fObj) {
        logger.log("createIcDummy_from_fObj", fObj);

        const type = "rect";

        return this.createIcObj_from_fObj(type, fObj);
      }

      createIcObj_from_fObj(type, fObj) {
        logger.log("createIcDummy_from_fObj", type, fObj);

        const trueRect = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size     = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        const exoObject = Object.assign({}, fObj);
        exoObject.icObj = null; // remove circular dependency

        // const isCosmetic = fObj.isCosmetic;

        const icObjFromFObj_spec = {
          fObj: fObj,
        };

        const icObjFromFObj = Object.assign(icObj, icObjFromFObj_spec);
        icObjFromFObj.isTouchable = true;

        return icObjFromFObj;
      }




      // createIcPathmadeOperator(path, replayObj) {
      //   logger.log("createIcPathmadeOperator", path, replayObj);
      //
      //   //debug
      //   const point__start = PathUtils.startingPointFromPath(path);
      //
      //   const trueRect = {
      //     x:      point__start.x,
      //     y:      point__start.y,
      //     width:  100,
      //     height: 100,
      //   };
      //
      //   const type      = "pathmadeOperator";
      //   const position  = Geometry.createPoint(trueRect.x, trueRect.y);
      //   const size      = Geometry.createSize(trueRect.width, trueRect.height);
      //   const homeScale = Object.assign({}, this.scale);
      //
      //   const icObj = this.createIcObject(type, position, size, homeScale);
      //   icObj.fill = "blanchedalmond";
      //
      //   const icPathmadeOperator_spec = {
      //     path: path,
      //     replayObj: replayObj,
      //   };
      //
      //   const icPathmadeOperator = Object.assign(icObj, icPathmadeOperator_spec);
      //
      //   return icPathmadeOperator;
      // }

      createIcPathmadeOperator(type__pathmadeOp, path, replayObj, dict_icObj) {
        var outIcObj;

        switch (type__pathmadeOp) {
          case "conveyor":
            outIcObj = infiniteCanvas.createIcPathmadeOperator__conveyor(path, replayObj, dict_icObj);
            break;
          case "shadePossessor":
            outIcObj = infiniteCanvas.createIcPathmadeOperator__shadePossessor(path, replayObj, dict_icObj);
            break;
          case "vesseler":
            outIcObj = infiniteCanvas.createIcPathmadeOperator__vesseler(path, replayObj, dict_icObj);
            break;
          default:
            throw new Error("Unsupported type: " + type__pathmadeOp);
            break;
        }

        return outIcObj;
      }

      createIcPathmadeOperator__conveyor(path, replayObj, dict_icObj) {
        logger.log("createIcPathmadeOperator__conveyor", path, replayObj, dict_icObj);

        const point__start = PathUtils.startingPointFromPath(path);

        // const icObj_start = dict_icObj.icObj_start;
        // icObj_start.isTouchable = false;
        const icObj_path  = dict_icObj.icObj_path;
        // icObj_path.isTouchable = false;
        const rep_free__icObj_path  = this.getRepresented(icObj_path.id).r_free();
        rep_free__icObj_path.isTouchable = false;

        // const size__slot__start = icObj_start.size;
        const size__slot__start = {
          width:    70,
          height:   70,
        };


        const trueRect__start = {
          x: point__start.x - (size__slot__start.width  / 2.0),
          y: point__start.y - (size__slot__start.height / 2.0),
          width:  size__slot__start.width,
          height: size__slot__start.height,
        };

        const text_in = "pathmade:conveyor";

        // const transformationFunc = this.transformationFuncForReplayObj(replayObj);
        const transformationFunc = async function (icObj, icTouchSlot) {

          //prevent original from touches while shadePossessor is running     //SHU: il faudra trouver un moyen de faire autrement car c'est moche
          // icObj.isTouchable = false;

          const transformationFunc_p = infiniteCanvas.transformationFunc_pForReplayObj(replayObj);
          const transformationOutput = await transformationFunc_p(icObj)
            .then(transformationOutput => {

              //restore isTouchable                 //SHU: il faudra trouver un moyen de faire autrement car c'est moche
              // if(icObj.type != "geminiShade") {
              //   icObj.isTouchable = true;
              // }

              return transformationOutput;
            });

          return transformationOutput;
        };

        const operatorConfig = new OperatorConfig(text_in, transformationFunc);

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect__start, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const text = operatorConfig.name;
        // const facade = infiniteCanvas.createIcText(trueRect__start.x, trueRect__start.y, text);
        const facade = infiniteCanvas.createIcRect(trueRect__start);
        facade.fill = "blue";
        // facade.isMobile    = false;
        facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade":    facade,
          
          // "start":     icObj_start,
          "path":      icObj_path,

          //TODO:
          // "course": icObj_course,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect__start, parts, compositeConfig);
        icComposite.cType = "gm_operator";
        icComposite.isTouchable = false;

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;


        const icPathmadeOperator_spec = {
          path: path,
        };

        const icPathmadeOperator = Object.assign(icComposite, icPathmadeOperator_spec);

        return icPathmadeOperator;
      }


      createIcPathmadeOperator__shadePossessor(path, replayObj) {
        logger.log("createIcPathmadeOperator__shadePossessor", path, replayObj);

        const point__start = PathUtils.startingPointFromPath(path);

        const trueRect = {
          x: point__start.x,
          y: point__start.y,
          width: 100,
          height: 100,
        };

        const text_in = "pathmade:shadePossessor";

        // const transformationFunc = this.transformationFuncForReplayObj(replayObj);
        const transformationFunc__decorated = async function (icObj, icTouchSlot) {

          //create geminiShade
          const icGeminiShade = infiniteCanvas.createIcGeminiShade(icObj);
          // icGeminiShade.position = {
          //   x: icGeminiShade.position.x + 100,
          //   y: icGeminiShade.position.y + 100,
          // };

          //prevent geminiShade from being touched by shadePossessor when starting
          {
            icGeminiShade.touchStateDict[icTouchSlot.id] = TouchState.Touched;
            // icGeminiShade.isTouchable = false;


            // logger.log("*icTouchSlot", icTouchSlot);
            // const canTouchFunc_geometryWise = function(above, below, context) {
            //   const canTouchFunc = Touch.canTouch;
            //   const canTouchFunc = Touch2Singleton.sharedInstance().canTouch;
            //
            //   return canTouchFunc(above, below);
            // };
            //
            // const canTouchFunc_idWise = function(above, below, context) {
            //   logger.log("canTouchFunc_idWise, above.id", above.id);
            //   logger.log("canTouchFunc_idWise, icGeminiShade.id", icGeminiShade.id);
            //
            //   return (above.id != icGeminiShade.id);
            // };
            //
            // const canTouchFuncs = {
            //   "geometry": canTouchFunc_geometryWise,
            //   "id":       canTouchFunc_idWise,
            // };
            //
            // const canTouchFunc_allWise = (above, below, context) => {
            //   return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            //     const canTouch_xWise = canTouchFunc_xWise(above,below, context);
            //     console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            //     return acc && canTouch_xWise;
            //   }, true);
            // };
            //
            // const canTouchFunc = canTouchFunc_allWise;
            // icTouchSlot.touchSlotConfig.canTouchFunc = canTouchFunc;
          }

          //prevent original from touches while shadePossessor is running     //SHU: il faudra trouver un moyen de faire autrement car c'est moche
          icObj.isTouchable = false;

          const transformationOutput = await infiniteCanvas.addIcObject_p(icGeminiShade)
            .then(rep_free__geminiShade => {
              var out_p;

              //operate on shade

              const transformationFunc_p = infiniteCanvas.transformationFunc_pForReplayObj(replayObj);

              out_p = transformationFunc_p(rep_free__geminiShade)
                .then(transformationOutput => {
                  // logger.log("transformationOutput", transformationOutput);

                  const obj = {
                    rep_free__geminiShade: rep_free__geminiShade,
                    transformationOutput: transformationOutput,
                  };

                  return obj;
                });

              return out_p;
            })
            .then(obj => {

              const rep_free__geminiShade = obj.rep_free__geminiShade;
              // const transformationOutput  = obj.transformationOutput;
              const transformationOutput = new TransformationOutput("mutated", icObj, icObj);

              //destroy shade
              rep_free__geminiShade.im_dying_now = true;

              //restore isTouchable                 //SHU: il faudra trouver un moyen de faire autrement car c'est moche
              // if(icObj.type != "geminiShade") {
              //   icObj.isTouchable = true;
              // }

              return transformationOutput;
            });

          return transformationOutput;
        };

        const operatorConfig = new OperatorConfig(text_in, transformationFunc__decorated);

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_operator";

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;


        // return icComposite;

        const icPathmadeOperator_spec = {
          path: path,
        };

        const icPathmadeOperator = Object.assign(icComposite, icPathmadeOperator_spec);

        return icPathmadeOperator;
      }

      createIcPathmadeOperator__vesseler(path, replayObj) {
        logger.log("createIcPathmadeOperator__vesseler", path, replayObj);

        const point__start = PathUtils.startingPointFromPath(path);

        const trueRect = {
          x: point__start.x,
          y: point__start.y,
          width: 100,
          height: 100,
        };

        const text_in = "pathmade:vesseler";

        // const transformationFunc = this.transformationFuncForReplayObj(replayObj);
        const transformationFunc__decorated = async function (icObj, icTouchSlot) {

          //create vessel
          const trueRect__icObj = {
            x: icObj.position.x,
            y: icObj.position.y,
            width: icObj.size.width,
            height: icObj.size.height,
          };
          const icVessel = infiniteCanvas.createIcVessel(trueRect__icObj);

          //prevent vessel from being touched by parent vesseler when starting
          {
            icVessel.touchStateDict[icTouchSlot.id] = TouchState.Touched;
          }

          const transformationOutput = await infiniteCanvas.addIcObject_p(icVessel)
            .then(rep_free__vessel => {
              var out_p;

              // shutemp {
              //
              //remove icObj from previous vessel (if any)
              const previousVessel = infiniteCanvas.getVessel(icObj);
              if (previousVessel != null) {
                // previousVessel.engine.awoken.removePart(icObj);
                previousVessel.im_dying_now = true;                   //SHU: this is ugly, and fortunately, only temporary
              }
              //
              // shutemp }


              //add icObj to vessel
              rep_free__vessel.dict_engine["composite"].engine.awoken.addPart(icObj, false);

              //operate on vessel
              const transformationFunc_p = infiniteCanvas.transformationFunc_pForReplayObj(replayObj);

              out_p = transformationFunc_p(rep_free__vessel)
                .then(transformationOutput => {
                  // logger.log("transformationOutput", transformationOutput);

                  const obj = {
                    rep_free__vessel: rep_free__vessel,
                    transformationOutput: transformationOutput,
                  };

                  return obj;
                });

              return out_p;
            })
            .then(obj => {

              const rep_free__vessel = obj.rep_free__vessel;
              // const transformationOutput  = obj.transformationOutput;
              const transformationOutput = new TransformationOutput("mutated", icObj, icObj);

              //remove icObj from vessel
              rep_free__vessel.dict_engine["composite"].engine.awoken.removePart(icObj);

              //destroy vessel
              rep_free__vessel.im_dying_now = true;

              return transformationOutput;
            });

          return transformationOutput;
        };

        const operatorConfig = new OperatorConfig(text_in, transformationFunc__decorated);

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_operator";

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;


        // return icComposite;

        const icPathmadeOperator_spec = {
          path: path,
        };

        const icPathmadeOperator = Object.assign(icComposite, icPathmadeOperator_spec);

        return icPathmadeOperator;
      }


      createIcSSPathmadeOperator(type__pathmadeOp, arr_point, dict_icObj) {
        var outIcObj;

        switch (type__pathmadeOp) {
          case "conveyor":
            outIcObj = infiniteCanvas.createIcSSPathmadeOperator__conveyor(arr_point, dict_icObj);
            break;
          // case "shadePossessor":
          //   outIcObj = infiniteCanvas.createIcSSPathmadeOperator__shadePossessor(arr_point, dict_icObj);
          //   break;
          // case "vesseler":
          //   outIcObj = infiniteCanvas.createIcSSPathmadeOperator__vesseler(arr_point, dict_icObj);
          //   break;
          default:
            throw new Error("Unsupported type: " + type__pathmadeOp);
            break;
        }

        return outIcObj;
      }

      createIcSSPathmadeOperator__conveyor(arr_point, dict_icObj) {
        logger.log("logSSPathmade", "createIcSSPathmadeOperator__conveyor", dict_icObj);

        const point__start = arr_point[0];

        // const icObj_start = dict_icObj.icObj_start;
        // icObj_start.isTouchable = false;
        const icObj_path  = dict_icObj.icObj_path;
        // icObj_path.isTouchable = false;
        const rep_free__icObj_path  = this.getRepresented(icObj_path.id).r_free();
        rep_free__icObj_path.isTouchable = false;

        // const size__slot__start = icObj_start.size;
        const size__slot__start = {
          width:    70,
          height:   70,
        };


        const trueRect__start = {
          x: point__start.x - (size__slot__start.width  / 2.0),
          y: point__start.y - (size__slot__start.height / 2.0),
          width:  size__slot__start.width,
          height: size__slot__start.height,
        };

        const text_in = "ssPathmade:conveyor";

        // const transformationFunc = infiniteCanvas.transformationFunc_pForSSConveyorWithArrPoint(arr_point);

        const transformationFunc = async function (icObj, icTouchSlot) {
          const transformationFunc_p = infiniteCanvas.transformationFunc_pForSSConveyorWithArrPoint(arr_point);
          const transformationOutput = await transformationFunc_p(icObj)
            .then(transformationOutput => {
              return transformationOutput;
            });
          return transformationOutput;
        };

        const operatorConfig = new OperatorConfig(text_in, transformationFunc);

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect__start, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const text = operatorConfig.name;
        // const facade = infiniteCanvas.createIcText(trueRect__start.x, trueRect__start.y, text);
        const facade = infiniteCanvas.createIcRect(trueRect__start);
        facade.fill = "blue";
        // facade.isMobile    = false;
        facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade":    facade,
          
          // "start":     icObj_start,
          "path":      icObj_path,

          //TODO:
          // "course": icObj_course,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect__start, parts, compositeConfig);
        icComposite.cType = "gm_operator";
        icComposite.isTouchable = false;

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;


        const icSSPathmadeOperator_spec = {
          // path: path,
          "arr_point": arr_point,
        };

        const icSSPathmadeOperator = Object.assign(icComposite, icSSPathmadeOperator_spec);

        return icSSPathmadeOperator;
      }

      createIcSSPathmadeOperator__shadePossessor(arr_point, dict_icObj) {
        throw new Error("Unimplemented function");
      }

      createIcSSPathmadeOperator__vesseler(arr_point, dict_icObj) {
        throw new Error("Unimplemented function");
      }





      createIcVessel(trueRect) {
        logger.log("createIcVessel");

        const parts = [];
        const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.c_type = "vessel";

        const fColor = new fabric.Color("violet");
        fColor.setAlpha(0.666);
        const rgbaColorString = fColor.toRgba();

        const icVessel_spec = {
          fill: rgbaColorString,

          isTouchable: false,
        }

        const icVessel = Object.assign(icComposite, icVessel_spec);

        return icVessel;
      }

      createIcFuturing(trueRect) {
        logger.log("createIcFuturing");

        const infiniteCanvas = this;

        const type = "futuring";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icFuturing_spec = {

        };

        const icFuturing = Object.assign(icObj, icFuturing_spec);


        const engine = new FuturingEngine();
        const eType = "futuring";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icFuturing, eType, engine);
      }




      createIcMultiPathmadeOperator_start(type__pathmadeOp) {
        // console.log("createIcMultiPathmadeOperator_start");

        const infiniteCanvas = this;

        //check
        {
          const creationManager__multiPathmadeOperator = infiniteCanvas.creationManagers["multiPathmadeOperator"];
          if (creationManager__multiPathmadeOperator != null) {
            throw new Error("createIcMultiPathmadeOperator_start, creationManager__multiPathmadeOperator != null");
          }
        }

        infiniteCanvas.creationManagers["multiPathmadeOperator"] = {
          type: type__pathmadeOp,
        };
        const creationManager__multiPathmadeOperator = infiniteCanvas.creationManagers["multiPathmadeOperator"];

        //create array for parts
        creationManager__multiPathmadeOperator.arr_pathmadeOp = [];

        //start amassing
        creationManager__multiPathmadeOperator.sub = infiniteCanvas.rx_icPathmadeOperator_observable.subscribe({
          next: (icPathmadeOperator) => {
            creationManager__multiPathmadeOperator.arr_pathmadeOp.push(icPathmadeOperator);
          },
        });

      }

      createIcMultiPathmadeOperator_end() {
        console.log("createIcMultiPathmadeOperator_end");

        const infiniteCanvas = this;

        //check
        {
          const creationManager__multiPathmadeOperator = infiniteCanvas.creationManagers["multiPathmadeOperator"];
          if (creationManager__multiPathmadeOperator == null) {
            throw new Error("createIcMultiPathmadeOperator_end, creationManager__multiPathmadeOperator == null");
          }
        }

        const creationManager__multiPathmadeOperator = infiniteCanvas.creationManagers["multiPathmadeOperator"];

        //stop amassing
        creationManager__multiPathmadeOperator.sub.unsubscribe();


        const type__pathmadeOp = creationManager__multiPathmadeOperator.type;
        const arr_pathmadeOp = creationManager__multiPathmadeOperator.arr_pathmadeOp;


        //create from parts
        const icMultiPathmadeOperator = infiniteCanvas.createIcMultiPathmadeOperator(arr_pathmadeOp);

        return icMultiPathmadeOperator;
      }


      createIcMultiPathmadeOperator(arr_pathmadeOp) {
        logger.log("createIcMultiPathmadeOperator", arr_pathmadeOp);

        const pathmadeOp__first = arr_pathmadeOp.find(e => true);
        const path__first = pathmadeOp__first.path;

        const point__start = PathUtils.startingPointFromPath(path__first);

        const trueRect = {
          x: point__start.x,
          y: point__start.y,
          width: 100,
          height: 100,
        };

        const text_in = "multipathmade";


        const canTouchFunc_geometryWise = function (above, below, context) {
          // const canTouchFunc = Touch.canTouch;

          const touch2Singleton = Touch2Singleton.sharedInstance();
          const canTouchFunc = touch2Singleton.canTouch.bind(touch2Singleton);

          return canTouchFunc(above, below);
        };

        const canTouchFunc_valueWise = function (icObj) {
          var outBool;

          if (icObj.type == "composite") {
            const nb_parts = Object.values(icObj.parts).length;
            logger.log("nb_parts", nb_parts);
            const nb_op = arr_pathmadeOp.length;
            logger.log("nb_op", nb_op);

            outBool = (nb_parts == nb_op);
          } else {
            outBool = false;
          }

          logger.log("canTouchFunc_valueWise", icObj, outBool);

          return outBool;
        };

        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value": canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above, below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;


        const transformationFunc = async function (icObj, icTouchSlot) {

          //debug
          // icObj.fill = ColorUtils.randomColor();
          const transformationOutput = new TransformationOutput("mutated", icObj, icObj);

          //dispatch
          const arr_part = Object.values(icObj.parts);
          const arr_transformationFunc = arr_pathmadeOp.map(icObj => icObj.parts.touchSlot.touchSlotConfig.transformationFunc);

          const arr_zipped = Utils.zip(arr_part, arr_transformationFunc);
          const arr_transformationOutput = arr_zipped.map(([part, transformationFunc], i) => {
            const transformationOutput = transformationFunc(part);
          });

          return transformationOutput;
        };


        const operatorConfig = new OperatorConfig(text_in, transformationFunc);

        const touchSlotConfig = {
          canTouchFunc: canTouchFunc,
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "multipathmade";

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;


        const icMultiPathmadeOperator_spec = {
          arr_pathmadeOp: arr_pathmadeOp,
        };

        const icMultiPathmadeOperator = Object.assign(icComposite, icMultiPathmadeOperator_spec);

        return icMultiPathmadeOperator;
      }



      createIcLayout(truePoint, storeConfig) {    //SHU: todo
        logger.log("createIcLayout", truePoint, storeConfig);

        // const parts           = [];
        // const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
        // const icComposite     = this.createIcComposite(trueRect, parts, compositeConfig);
        // icComposite.c_type = "store";
        //
        // const fColor = new fabric.Color("9A7B5F");
        // fColor.setAlpha(1.0);
        // const rgbaColorString = fColor.toRgba();
        //
        // const icStore_spec = {
        //   fill: rgbaColorString,
        //
        //   isTouchable: true,
        // }
        //
        // const icVessel = Object.assign(icComposite, icVessel_spec);
        //
        // return icVessel;
      }


      createIcStore(trueRect, storeConfig_in) {
        logger.log("createIcStore", trueRect, storeConfig);

        var storeConfig = storeConfig_in;
        if (storeConfig == null) {
          storeConfig = {
            type: "copy",
          };
        }

        const transformationFunc = async function (icObj, icTouchSlot) {

          //debug
          icObj.fill = ColorUtils.randomColor();
          const transformationOutput = new TransformationOutput("mutated", icObj, icObj);


          const rep_free__icStore = infiniteCanvas.getRepresented(icTouchSlot.compositeId).r_free();
          const rep_free__depot = rep_free__icStore.parts.depot;

          const icObj__clone = icObj.deepClone();
          const id__clone = infiniteCanvas.generateIcObjectId();
          icObj__clone.id = id__clone;
          icObj__clone.isTouchable = false;

          infiniteCanvas.addIcObject(icObj__clone);
          const rep_free__clone = infiniteCanvas.getRepresented(icObj__clone.id).r_free();

          rep_free__clone.homeScale = Object.assign({}, icObj.homeScale);

          const nb__in_depot = Object.values(rep_free__depot.parts).length;
          const spacing__x = 200;
          rep_free__clone.isMobile = true;
          rep_free__clone.position = {
            x: rep_free__depot.position.x + nb__in_depot * spacing__x,
            y: rep_free__depot.position.y,
          };

          rep_free__depot.dict_engine["composite"].engine.awoken.addPart(rep_free__clone, false);

          return transformationOutput;
        };

        const text_in = "store";
        const operatorConfig = new OperatorConfig(text_in, transformationFunc);

        const touchSlotConfig = {
          // canTouchFunc:       canTouchFunc,
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;


        var depot;
        {
          const parts = [];
          const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
          const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
          icComposite.c_type = "depot";

          depot = icComposite;
        }


        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.backgroundColor = "#9A7B5F";        //SHU: is store really an operator ?
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "depot": depot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.c_type = "store";

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;

        const icStore_spec = {

        };

        const icStore = Object.assign(icComposite, icStore_spec);

        infiniteCanvas.onceOnAddRepresentedForIcObject(icStore, (icStore) => {

          const rep_free__icStore = infiniteCanvas.getRepresented(icStore.id).r_free();
          const rep_free__depot = rep_free__icStore.parts.depot;

          //shift down depot
          rep_free__depot.isMobile = true;
          rep_free__depot.position = Object.assign({}, rep_free__depot.position, { y: rep_free__depot.position.y + 180 });
          rep_free__depot.isMobile = false;

        });

        return icStore;
      }


      createIcCounter(trueRect, counterConfig_in) {
        logger.log("createIcCounter", trueRect, counterConfig_in);

        var counterConfig = counterConfig_in;
        if (counterConfig == null) {
          counterConfig = this.createCounterConfig(1);
        }

        const canTouchFunc_geometryWise = (above, below, context) => {
          // const canTouchFunc = Touch.canTouch;

          const touch2Singleton = Touch2Singleton.sharedInstance();
          const canTouchFunc = touch2Singleton.canTouch.bind(touch2Singleton);

          return canTouchFunc(above, below);
        };

        const canTouchFunc_valueWise = function (icObj, icTouchSlot) {
          const canCount = counterConfig.canCountFunc(icObj);
          return canCount;
        };

        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value": canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above, below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;

        const transformationFunc = async function (icObj, icTouchSlot) {

          //debug
          // icObj.fill = ColorUtils.randomColor();
          const transformationOutput = new TransformationOutput("mutated", icObj, icObj);


          const rep_free__icCounter = infiniteCanvas.getRepresented(icTouchSlot.compositeId).r_free();

          const rep_free__reictangle = rep_free__icCounter.parts.reictangle;
          const rep_free__label = rep_free__icCounter.parts.label;


          //increment counter inner variable
          //counter inner variable is reictangle mathNode
          const mathNode__counter__old = rep_free__reictangle.mathNode;
          const value__counter__old = mathNode__counter__old.value;
          const value__counter__new = value__counter__old + 1;


          //update parts
          const mathNode__counter__new = new math.ConstantNode(value__counter__new);
          rep_free__reictangle.mathNode = mathNode__counter__new;

          rep_free__label.text = "" + value__counter__new;

          return transformationOutput;
        };

        const text_in = "count_";
        const operatorConfig = new OperatorConfig(text_in, transformationFunc);

        const touchSlotConfig = {
          canTouchFunc: canTouchFunc,
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        // touchSlot.fill     = "";
        // touchSlot.isMobile = false;





        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.backgroundColor = "#9A7B5F";        //SHU: is store really an operator ?
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const icObj__specimen = counterConfig.icObj__specimen;
        icObj__specimen.position = {
          x: facade.position.x + 280,
          y: facade.position.y + 32,
        };


        const mathNode = new math.ConstantNode(0);
        const icMNReictangle = this.createIcMNReictangle(trueRect.x + 100, trueRect.y - 50, mathNode);
        icMNReictangle.isTouchable = false;
        icMNReictangle.fill = "#A6C39E";
        icMNReictangle.orientation = -90;


        const string__counter = "" + mathNode.value;
        const label = infiniteCanvas.createIcText(trueRect.x + 100, trueRect.y + 200, string__counter);
        label.backgroundColor = "#A6C39E";

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
          "specimen": icObj__specimen,

          "reictangle": icMNReictangle,
          "label": label,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.c_type = "counter";

        const operation = new Operation(operatorConfig.transformationFunc);
        icComposite.operation = operation;

        const icCounter_spec = {

        };

        const icCounter = Object.assign(icComposite, icCounter_spec);

        //arrange parts once added
        // infiniteCanvas.onceOnAddRepresentedForIcObject(icCounter, (icCounter) => {
        //
        //   const rep_free__icCounter = infiniteCanvas.getRepresented(icCounter.id).r_free();
        //
        //   const rep_free__touchSlot   = rep_free__icCounter.parts.touchSlot;
        //   const rep_free__facade      = rep_free__icCounter.parts.facade;
        //
        //   const rep_free__specimen    = rep_free__icCounter.parts.specimen;
        //   const rep_free__reictangle  = rep_free__icCounter.parts.reictangle;
        //   const rep_free__label       = rep_free__icCounter.parts.label;
        //
        //   rep_free__touchSlot.isMobile = true;
        //   rep_free__touchSlot.position = Object.assign({}, rep_free__icCounter.position);
        //   rep_free__touchSlot.isMobile = false;
        //
        //   rep_free__facade.isMobile = true;
        //   rep_free__facade.position = Object.assign({}, rep_free__icCounter.position);
        //   rep_free__facade.isMobile = false;
        //
        //   // rep_free__specimen.isMobile = true;
        //   // rep_free__specimen.position = Object.assign({}, rep_free__icCounter.position);
        //   // rep_free__specimen.isMobile = false;
        //
        //
        //   rep_free__reictangle.isMobile = true;
        //   rep_free__reictangle.position = {
        //     x: rep_free__specimen.position.x,
        //     y: rep_free__specimen.position.y - 100,
        //   };
        //   rep_free__reictangle.isMobile = false;
        //
        //   rep_free__label.isMobile = true;
        //   rep_free__label.position = {
        //     x: rep_free__specimen.position.x - 100,
        //     y: rep_free__specimen.position.y + 100,
        //   };
        //   rep_free__label.isMobile = false;
        //
        // });

        return icCounter;
      }




      // createIcSparkle(trueRect, img, sparkleConfig) {
      createIcSparkle(truePoint, img, sparkleConfig) {
        // console.log("createIcSparkle", truePoint, sparkleConfig);

        const type = "sparkle";

        // const position = Geometry.getPointTL(trueRect);
        // const size     = Geometry.createSize(trueRect.width, trueRect.height);
        // const center = Geometry.getCenterPoint(trueRect);
        const position = {
          x: truePoint.x,
          y: truePoint.y,
        };
        const size = Geometry.createSize(img.width, img.height);

        const homeScale = {
          // X: this.scale.X * 10,
          // Y: this.scale.Y * 10,
          X: this.scale.X,
          Y: this.scale.Y,
        };

        const icObj = this.createIcObject(type, position, size, homeScale);



        const icSparkle_spec = {
          isUsingCenterPosition: true,
          // center: center,

          homeScale_max: 10000,
          homeScale_min: 0,

          img: img,

          isSnappable: false,
        };

        const icSparkle = Object.assign(icObj, icSparkle_spec);

        return icSparkle;
      }

      debug_sparkleAnims(isAnimPaused) {
        console.log("debug_sparkleAnims(", isAnimPaused, ")");

        const arr_sparkles = Object.values(this.represented)
          .map(represented => {
            // return represented.r_official();
            return represented.r_free();
          })
          .filter(rep => {
            const isSparkle = (rep.type == "sparkle");
            return isSparkle;
          });

        arr_sparkles.forEach((rep, i) => {
          rep.isAnimPaused = isAnimPaused;

          const animation = rep.animation;
          const progress = animation.progress / 100.0;
          console.log("debug_sparkleAnims: progress", progress);

          if (isAnimPaused) {
            animation.pause();
          } else {
            animation.play();
          }
        });
      }




      createIcTouchSlot(trueRect, touchSlotConfig) {
        console.log("createIcTouchSlot", trueRect, touchSlotConfig);

        const infiniteCanvas = this;

        const type      = "touchSlot";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        if(!("isEnabled" in touchSlotConfig)) {
          touchSlotConfig["isEnabled"] = true;
        }

        const transformationFunc = touchSlotConfig.transformationFunc;
        const transformationFunc__decorated = function (icObj_in) {
          var transformationOutput;

          //debug
          // const rep_free = infiniteCanvas.getRepresented(icObj_in.id).r_free();
          // infiniteCanvas.animate_bounce(rep_free);

          transformationOutput = new TransformationOutput("mutated", icObj_in, icObj_in);

          transformationOutput = transformationFunc(icObj_in);
          // logger.log("transformationOutput", transformationOutput);

          //touch animation
          // setTimeout(() => {
            const icObj__result = transformationOutput.value; 
            const rep_free = infiniteCanvas.getRepresented(icObj__result.id).r_free();
            infiniteCanvas.animate_bounce(rep_free);
          // }, 1); 

          return transformationOutput;
        };
        const touchSlotConfig__decorated  = Object.assign({},touchSlotConfig,{transformationFunc: transformationFunc__decorated});

        const icTouchSlot_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 3,

          touchSlotConfig: touchSlotConfig__decorated,
        };

        const icTouchSlot = Object.assign(icObj, icTouchSlot_spec);


        const engine = new TouchSlotEngine();
        const eType  = "touchSlot";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icTouchSlot, eType, engine);

        //debug: hot-mutating touchSlotConfig
        // setTimeout(() => {
        //
        //   const represented = infiniteCanvas.getRepresented(icEngined.id);
        //   const rep_free    = represented.r_free();
        //
        //   rep_free.touchSlotConfig = {
        //     transformationFunc: (icObj) => {
        //       icObj.fill = "orange";
        //     },
        //   };
        //
        // }, 10000);

        return icEngined;
      }


      createIcDropTouchSlot(trueRect, touchSlotConfig_in = null, engine_in = null) {
        console.log("createIcTouchSlot", trueRect, touchSlotConfig);

        const infiniteCanvas = this;

        const type = "dropTouchSlot";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        var touchSlotConfig;
        if (touchSlotConfig_in != null) {
          touchSlotConfig = touchSlotConfig_in;
        } else {
          const icObjToIcObjFunc = (new GMOperatorTextChangeEngine()).transformationFuncForText("+ 1");
          const transformationFunc = (icObj) => {
            const icObj__sadness = icObjToIcObjFunc(icObj);
            const transformationOutput = new TransformationOutput("sadness", icObj__sadness, icObj);
            return transformationOutput;
          };

          touchSlotConfig = {
            transformationFunc__touch:   transformationFunc,
            transformationFunc__untouch: transformationFunc,
            filterFunc__touch__isObjectIgnored:   (icObj) => false,
            filterFunc__untouch__isObjectIgnored: (icObj) => false,
          };
        }

        const icDropTouchSlot_spec = {
          isSnappable: false,

          fill: "#226699",

          stroke: "purple",
          strokeWidth: 3,

          touchSlotConfig: touchSlotConfig,
        };

        const icDropTouchSlot = Object.assign(icObj, icDropTouchSlot_spec);


        var engine;
        if (engine_in != null) {
          engine = engine_in;
        } else {
          engine = new DropTouchSlotEngine();
        }
        const eType = "dropTouchSlot";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icDropTouchSlot, eType, engine);

        return icEngined;
      }


      createIcPokeSlot(trueRect, pokeSlotConfig) {
        console.log("createIcPokeSlot", trueRect, pokeSlotConfig);

        const infiniteCanvas = this;

        const type      = "pokeSlot";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        if(!("isEnabled" in pokeSlotConfig)) {
          pokeSlotConfig["isEnabled"] = true;
        }

        const icPokeSlot_spec = {
          // isSnappable: false,
          isTouchable: false,

          stroke: "yellow",
          strokeWidth: 2,

          fill: "rgba(33,66,200,0.5)",

          pokeSlotConfig: pokeSlotConfig,
        };

        const icPokeSlot = Object.assign(icObj, icPokeSlot_spec);

        // return icPokeSlot;

        const engine = new PokeSlotEngine();
        const eType  = "pokeSlot";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icPokeSlot, eType, engine);

        //debug: hot-mutating touchSlotConfig
        // setTimeout(() => {
        //
        //   const represented = infiniteCanvas.getRepresented(icEngined.id);
        //   const rep_free    = represented.r_free();
        //
        //   rep_free.touchSlotConfig = {
        //     transformationFunc: (icObj) => {
        //       icObj.fill = "orange";
        //     },
        //   };
        //
        // }, 10000);

        return icEngined;
      }


      createIcApplySlot(trueRect, applySlotConfig) {
        console.log("createIcApplySlot", trueRect, applySlotConfig);

        const infiniteCanvas = this;

        const type      = "applySlot";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        if(!("isEnabled" in applySlotConfig)) {
          applySlotConfig["isEnabled"] = true;
        }

        const icApplySlot_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 3,

          applySlotConfig: applySlotConfig,
        };

        const icApplySlot = Object.assign(icObj, icApplySlot_spec);


        const engine = new ApplySlotEngine();
        const eType  = "applySlot";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icApplySlot, eType, engine);

        return icEngined;
      }

      createIcDiveSlot(trueRect, diveSlotConfig) {
        console.log("createIcDiveSlot", trueRect, diveSlotConfig);

        const infiniteCanvas = this;

        const type      = "diveSlot";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        if(!("isEnabled" in diveSlotConfig)) {
          diveSlotConfig["isEnabled"] = true;
        }

        const icDiveSlot_spec = {
          stroke: "yellow",
          strokeWidth: 4,

          diveSlotConfig: diveSlotConfig,
        };

        const icDiveSlot = Object.assign(icObj, icDiveSlot_spec);


        const engine = new DiveSlotEngine();
        const eType  = "diveSlot";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icDiveSlot, eType, engine);

        return icEngined;
      }



      createIcCollection(trueRect, collectionConfig) {
        console.log("createIcCollection", trueRect, collectionConfig);

        const infiniteCanvas = this;

        function createPartsDict(collectionConfig) {

          function trueRectForPartIndex(index) {
            const outTrueRect = {
              x: trueRect.x + 200 + index * 100 / infiniteCanvas.scale.X,
              y: trueRect.y,
              width: trueRect.width,
              height: trueRect.height,
            };

            return outTrueRect;
          }

          const nb_elements = collectionConfig.max - collectionConfig.min + 1;
          const arr_numbers = Array.from({ length: nb_elements }, (_, i) => i + collectionConfig.min)

          const arr_entries = arr_numbers.map((number, index) => {
            const trueRect__icObj = trueRectForPartIndex(index);
            const mathNode = new math.ConstantNode(number);
            const icObj = infiniteCanvas.createIcMathNode(trueRect__icObj.x, trueRect__icObj.y, mathNode);

            const name__element = "part_" + index;
            return [name__element, icObj];
          });

          const partsDict = Object.fromEntries(arr_entries);

          return partsDict;
        }

        const parts = createPartsDict(collectionConfig);

        const compositeConfig = Object.entries(parts).reduce((acc, [partName, part], index) => {
          // const isMobile = (index != 0);
          const isMobile = true;

          // acc[partName] = {
          acc[part.id] = {
            isMobile: isMobile,
          };
          return acc;
        }, {});

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);

        icComposite.isCollection = true;
        icComposite.isTouchable = true;

        return icComposite;
      }


      // createIcComposite(parts, engine) {
      createIcComposite_debug(trueRect) {
        console.log("createIcComposite_debug", trueRect);


        function createPartsDict() {
          // const part1_trueRect = trueRect;
          const part1_trueRect = {
            x: trueRect.x + 400,
            y: trueRect.y + 50,
            width: trueRect.width,
            height: trueRect.height,
          };
          const part1_icObj = infiniteCanvas.createIcRect(part1_trueRect);
          part1_icObj.fill = "cyan";

          // const part2_trueRect = {
          //   x:      trueRect.x + 400,
          //   y:      trueRect.y + 50,
          //   width:  trueRect.width,
          //   height: trueRect.height,
          // };
          const part2_trueRect = part1_trueRect;
          const part2_icObj = infiniteCanvas.createIcRect(part2_trueRect);
          part2_icObj.fill = "orange";

          const part3_trueRect = part1_trueRect;
          const part3_icObj = infiniteCanvas.createIcRect(part2_trueRect);
          part3_icObj.fill = "magenta";

          const partsDict = {
            "part1": part1_icObj,
            "part2": part2_icObj,
            "part3": part3_icObj,
          };

          return partsDict;
        }

        const parts = createPartsDict();

        const compositeConfig = Object.entries(parts).reduce((acc, [partName, part], index) => {
          const isMobile = (index != 0);
          // acc[partName] = {
          acc[part.id] = {
            isMobile: isMobile,
          };
          return acc;
        }, {});

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);

        return icComposite;
      }


      createIcComposite(trueRect, parts, compositeConfig, content = null) {
        console.log("createIcComposite", trueRect);

        const infiniteCanvas = this;

        const type = "composite";

        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);
        const icObj     = this.createIcObject(type, position, size, homeScale);


        const icComposite_spec = {
          isSnappable: false,

          // stroke: "red",
          // strokeWidth: 4,

          fill: "pink",

          parts: parts,
          compositeConfig: compositeConfig,
        };
        if(content != null) {
          icComposite_spec.content = content;
        }

        const icComposite = Object.assign(icObj, icComposite_spec);

        const engine = new CompositeEngine();
        const eType  = "composite";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icComposite, eType, engine);


        return icEngined;
      }

      createIcArray(trueRect, arr_icObj_in) {

        const parts = Utils.dictFromArr(arr_icObj_in);
        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        // compositeConfig__knob[icMathNode__knob.id].isMobile = true;
        const trueRect__composite = {
          x:      -100,
          y:      -100,
          width:    30,
          height:   30,
        };
        const icComposite = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig);
        icComposite.cType = "array";

        const icArray_spec = {
          arr_icObj: arr_icObj_in,
        };

        var icArray = Object.assign(icComposite, icArray_spec);
        icArray.fill = "grey";
        icArray.opacity = 0.555;


        const arrayEngine = new ArrayEngine();
        const icEngined = infiniteCanvas.installEngineOnIcObj(icArray, "array", arrayEngine);

        //so: icArray has 2 engines: CompositeEngine and ArrayEngine

        return icEngined;
      }

      createIcBloom(trueRect, core, facets, compositeConfig) {
        console.log("createIcBloom", trueRect, core, facets, compositeConfig);

        const infiniteCanvas = this;

        const parts = [core, ...facets];
        const icComposite = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "bloom";

        const icBloom_spec = {
          core: core,
          facets: facets,
        };

        const icBloom = Object.assign(icComposite, icBloom_spec);

        return icBloom;
      }

      createIcCore(icObj) {
        console.log("createIcCore", icObj);

        const infiniteCanvas = this;


        const trueRect__touchSlot = {
          x: icObj.position.x + 100,
          y: icObj.position.x + 100,
          width: 100,
          height: 100,
        };
        const touchSlotConfig = {
          transformationFunc: function (icObj) {

            //will be set later in CoreEngine

            return new TransformationOutput("mutated", icObj, icObj);
          },
        };
        const icTouchSlot = infiniteCanvas.createIcTouchSlot(trueRect__touchSlot, touchSlotConfig);
        icTouchSlot.fill = "pink";
        icTouchSlot.opacity = 0.4;

        const trueRect__ghost = {
          x: icObj.position.x + 200,
          y: icObj.position.x - 200,
          width: 100,
          height: 100,
        };
        const icGhost = infiniteCanvas.createIcGhost(trueRect__ghost);
        icGhost.fill = "black";
        icGhost.opacity = 0.2;


        const parts = {
          specimen: icObj,
          touchSlot: icTouchSlot,
          ghost: icGhost,
        };
        const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
        const trueRect__core = {
          x: icObj.position.x + 100,
          y: icObj.position.x - 100,
          width: 100,
          height: 100,
        };
        const icComposite = infiniteCanvas.createIcComposite(trueRect__core, parts, compositeConfig);
        icComposite.cType = "core";


        const icCore_spec = {

        };

        var icCore = Object.assign(icComposite, icCore_spec);
        icCore.fill = "lime";
        icCore.opacity = 0.4;


        const coreEngine = new CoreEngine();
        const icEngined = infiniteCanvas.installEngineOnIcObj(icCore, "core", coreEngine);

        //so: core has 2 engines: CompositeEngine and CoreEngine

        return icEngined;
      }

      createIcGhost(trueRect) {
        console.log("createIcGhost", trueRect);

        const infiniteCanvas = this;

        const parts = {};
        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        const icComposite = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "ghost";

        const icGhost_spec = {

        };

        const icGhost = Object.assign(icComposite, icGhost_spec);

        return icGhost;
      }



      createIcTag(left, top, text) {

        const type = "tag";
        const position = Geometry.createPoint(left, top);
        const size = Geometry.createSize(0, 0);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        // const text     = "icText";
        const fontSize = 100;

        const icTag_spec = {
          text: text,
          textColor: "black",
          fontSize: fontSize,
        };

        const icTag = Object.assign(icObj, icTag_spec);

        return icTag;
      }

      createIcLabelValue(trueRect, text, value) {
        console.log("createIcLabelValue", trueRect, text, value);

        const infiniteCanvas = this;

        const icObj__label = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        icObj__label.fill = "";

        const icObj__value = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "" + value);
        icObj__value.fill = "";

        const parts = {
          "label": icObj__label,
          "value": icObj__value,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "labelValue";
        icComposite.fill = "";



        //put value on right side of label
        // infiniteCanvas.onceOnAddRepresentedForIcObject(icComposite, (icComposite) => {
        // logger.log("infiniteCanvas.onceOnAddRepresentedForIcObject", icComposite);
        setTimeout(() => {

          const labelValue__represented = infiniteCanvas.getRepresented(icComposite.id);
          const labelValue__rep_free = labelValue__represented.r_free();


          const label__rep_free = labelValue__rep_free.parts["label"];
          const value__rep_free = labelValue__rep_free.parts["value"];
          // logger.log("label__rep_free", label__rep_free);
          // logger.log("value__rep_free", value__rep_free);


          labelValue__rep_free.compositeConfig[value__rep_free.id].isMobile = true;

          const spacing = 50;
          value__rep_free.position = {
            x: label__rep_free.position.x + label__rep_free.size.width + spacing,
            y: value__rep_free.position.y,
          };

          labelValue__rep_free.compositeConfig[value__rep_free.id].isMobile = false;


          // });
        }, 10);   //SHU TODO: remove this ugliness


        return icComposite;
      }


      createIcP2P(trueRect) {
        // const type      = "p2p";
        // const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        // const size      = Geometry.createSize(trueRect.width, trueRect.height);
        // const homeScale = Object.assign({}, this.scale);

        var peer;

        // const id__user = Session.uuid;
        const userid__p2p = MathUtils.randomCartArrFromArr(["a","b","c","d","e"], 3, 3).join("");
        logger.log("logP2P", "userid__p2p", userid__p2p);
        
        const icText__p2pId = infiniteCanvas.createIcText(trueRect.x, trueRect.y - 400, userid__p2p);
        icText__p2pId.fill  = "lime";

        const config__button__connectToServer = {
          buttonFunc: (scopeObj) => {
            const id__icText__p2pId = scopeObj.engineCarrier.buttonConfig.id__icText__p2pId;
            const rep_free__icText__p2pId = scopeObj.infiniteCanvas.getRepresented(id__icText__p2pId).getRepresentation("free");
            const userid__p2p = rep_free__icText__p2pId.text;

            // const peer = new Peer(userid__p2p, {
            peer = new Peer(userid__p2p, {
              host: "localhost",
              port: 9000,
              path: "/myapp",
            });
            peer.on('connection', function(conn) {
              conn.on('data', function(data){
                // Will print 'hi!'
                logger.log("p2p", "received:", data);
              });
            });

          },
          id__icText__p2pId: icText__p2pId.id,
        };
        const icButton__connectToServer = infiniteCanvas.createIcButton({
          x:      trueRect.x,
          y:      trueRect.y - 200,
          width:  110,
          height: 100,
        }, config__button__connectToServer);





        const icText__ip = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "");
        icText__ip.fill  = "";
        icText__ip.canBeEdited = false;

        const icText__userName = infiniteCanvas.createIcText(trueRect.x, trueRect.y + 200, "debug__userName");
        icText__userName.fill  = "";

        const icText__groupName = infiniteCanvas.createIcText(trueRect.x, trueRect.y + 400, "debug__groupName");
        icText__groupName.fill  = "";





        const icText__connectToPeer = infiniteCanvas.createIcText(trueRect.x, trueRect.y + 700, "aaa");
        icText__connectToPeer.fill  = "orange";

        const config__button__connectToPeer = {
          buttonFunc: (scopeObj) => {
            const id__icText__connectToPeer = scopeObj.engineCarrier.buttonConfig.id__icText__connectToPeer;
            const rep_free__icText__connectToPeer = scopeObj.infiniteCanvas.getRepresented(id__icText__connectToPeer).getRepresentation("free");
            const userid__target = rep_free__icText__connectToPeer.text;

            var conn = peer.connect(userid__target);
            // on open will be launch when you successfully connect to PeerServer
            conn.on('open', function(){
              // here you have conn.id
              conn.send('hi!');
            });

          },
          id__icText__connectToPeer: icText__connectToPeer.id,
        };
        const icButton__connectToPeer = infiniteCanvas.createIcButton({
          x:      trueRect.x,
          y:      trueRect.y + 900,
          width:  200,
          height: 100,
        }, config__button__connectToPeer);





        const icText__debug = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "text__debug");
        icText__userName.stroke = "purple";


        const parts = {
          "text__p2pId": icText__p2pId,
          "connectToServer__button" : icButton__connectToServer,

          "ip":        icText__ip,
          "userName":  icText__userName,
          "groupName": icText__groupName,

          "connectToPeer__text":   icText__connectToPeer,
          "connectToPeer__button": icButton__connectToPeer,
          
          "debug__text": icText__debug,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "p2p";
        icComposite.fill  = "";


        


        const icP2P_spec = {
          // peer: peer,
        };

        const icP2P = Object.assign(icComposite, icP2P_spec);

        

        return icP2P;
      }


      createIcCanvas(trueRect) {
        const infiniteCanvas = this;

        const type      = "icCanvas";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        const canvas__iC  = document.createElement('canvas');
        canvas__iC.width  = trueRect.width;
        canvas__iC.height = trueRect.height;
        document.body.appendChild(canvas__iC);

        const dict__iC = create_iC(canvas__iC);

        dict__iC.fabricIntegration.fabricCanvas.backgroundColor = "rgba(150,100,50,0.7)";

        const icCanvas__spec = {
          dict__iC: dict__iC,
        };

        const icCanvas = Object.assign(icObj, icCanvas__spec);

        //debug
        this.onceOnAddRepresentedForIcObject(icCanvas, (icCanvas) => {
          const rep_free__icCanvas__child = infiniteCanvas.getRepresented(icCanvas.id).r_free();

          {
            const infiniteCanvas__child = dict__iC.infiniteCanvas;
            setTimeout(() => {

              const trueRect = {
                x: 160,
                y: 10,
                width: 150,
                height: 80,
              };
              const icRect = infiniteCanvas__child.createIcRect(trueRect);
              icRect.fill = "orange";
              infiniteCanvas__child.addIcObject(icRect);

              //trigger img refresh
              rep_free__icCanvas__child.position = Object.assign({}, rep_free__icCanvas__child.position);

            }, 3000);
          }
        });

        return icCanvas;
      }





      createIcButton(trueRect, buttonConfig_in) {
        logger.log("createIcButton", trueRect, buttonConfig_in);

        const infiniteCanvas = this;

        const type      = "button";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        var buttonConfig = buttonConfig_in;
        if (buttonConfig == null) {
          buttonConfig = {
            buttonFunc: (scopeObj) => {
              console.log("buttonFunc", scopeObj);
              const button = scopeObj.engineCarrier;
              button.fill = ColorUtils.randomColor();
            },
          };
        }

        const icButton_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 1,
          fill: buttonConfig.fill ? buttonConfig.fill : "lightgray",

          buttonConfig: buttonConfig,
        };

        const icButton = Object.assign(icObj, icButton_spec);


        const engine = new ButtonEngine();
        engine.buttonConfig = buttonConfig;
        const eType  = "button";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icButton, eType, engine);

        return icEngined;
      }

      createIcButton__gotopov(trueRect, icPOVRect, config_in = null) {

        var config = config_in;
        if(config == null) {

          const fColor__fill = new fabric.Color("orange");
          fColor__fill.setAlpha(0.777);
          const color__fill = fColor__fill.toRgba();

          config = {
            fill: color__fill,
            duration__anim: 5000,
            // duration__anim: 20000,
          };
        }

        //create gotopov button
        const config__button = {
          buttonFunc: (scopeObj) => {
            const cfg_anim__easy = {
              duration: scopeObj.engineCarrier.buttonConfig.duration__anim,
            };

            const id__povRect = scopeObj.engineCarrier.buttonConfig.id__povRect;
            logger.log("logPov", "id__povRect", id__povRect);

            const represented__povRect = scopeObj.infiniteCanvas.getRepresented(id__povRect);
            const rep_free__povRect    = represented__povRect.getRepresentation("free");

            // const trueRect2_pov  = icPOVRect.getTrueRect2();
            const trueRect2_pov  = rep_free__povRect.getTrueRect2();

            scopeObj.infiniteCanvas.move_to_rect__animation(trueRect2_pov, cfg_anim__easy);
          },
          id__povRect: icPOVRect.id,
          fill: config.fill,
          duration__anim: config.duration__anim,
        };
        const icButton = infiniteCanvas.createIcButton(trueRect, config__button);
        return icButton;
      }



      createIcClickWell(trueRect, value_in = -48) {
        console.log("createIcClickWell", trueRect);

        const infiniteCanvas = this;

        // const type      = "clickWell";
        const type = "button";

        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const buttonFunc = (scopeObj) => {
          console.log("buttonFunc", scopeObj);
          const button = scopeObj.engineCarrier;
          button.fill = ColorUtils.randomColor();

          //create/add new spawn
          const infiniteCanvas = scopeObj.infiniteCanvas;

          const trueRect = {
            x: button.position.x,
            y: button.position.y,
            width: button.size.width,
            height: button.size.height,
          };

          // const spawn = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "spawn");
          // const spawn = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "12");

          const mathNode = new math.ConstantNode(value_in);
          mathNode.autoSimplify = true;
          const spawn = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);


          infiniteCanvas.addIcObject(spawn);


          //set spawn as active object
          const spawn__represented = infiniteCanvas.getRepresented(spawn.id);
          const spawn__rep_free = spawn__represented.r_free();

          infiniteCanvas.setActiveObject(spawn__rep_free);
        };

        const buttonConfig = {
          buttonFunc: buttonFunc,
        };


        const icButton_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 1,
          fill: "lightgray",

          buttonConfig: buttonConfig,
        };

        const icButton = Object.assign(icObj, icButton_spec);


        const engine = new ButtonEngine();
        const eType = "button";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icButton, eType, engine);

        return icEngined;
      }

      setActiveObject(icObj) {
        icObj.im_active_now = true;
      }

      createIcPlatform(trueRect, parts__terrace = {}) {
        logger.log("createIcPlatform", trueRect);

        const infiniteCanvas = this;

          //terrace
        // const parts__terrace = {};
        const compositeConfig__terrace = Compositer.defaultCompositeConfig(parts__terrace, false);
        const icComposite__terrace = infiniteCanvas.createIcComposite(trueRect, parts__terrace, compositeConfig__terrace);
        icComposite__terrace.cType = "terrace";

        icComposite__terrace.fill = "lime";
        icComposite__terrace.opacity = 0.7;

          //dropTouchSlot
        const dropTouchSlotEngine = new DropTouchSlotEngine();
        //dropTouchSlotEngine will be invested by PlatformEngine

        const icDropTouchSlot = infiniteCanvas.createIcDropTouchSlot(trueRect, null, dropTouchSlotEngine);
          //have terraced objects be touched
        Object.values(icComposite__terrace.parts).forEach((icObj__terraced) => {
          icObj__terraced.touchStateDict[icDropTouchSlot.id] = TouchState.Touched;
        });

          //platform
        const parts = {
          dropTouchSlot: icDropTouchSlot,         //landing
          terrace:       icComposite__terrace,    //sitting
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false, false); //unmovable, unalterable parts

        const trueRect__platform = {
          x:      trueRect.x,
          y:      trueRect.y,
          width:  trueRect.width  / 5,
          height: trueRect.height / 5,
        };

        const icComposite = this.createIcComposite(trueRect__platform, parts, compositeConfig);
        icComposite.cType = "platform";
        // icComposite.isTouchable = false;

        const icPlatform_spec = {
          arr_terraced: Object.values(icComposite__terrace.parts),
        };

        const icPlatform = Object.assign(icComposite, icPlatform_spec);

        //SHU: TODO: PlatformEngine
        const engine = new PlatformEngine();
        const eType  = "platform";
        
        const icEngined = infiniteCanvas.installEngineOnIcObj(icPlatform, eType, engine);

        const icPlatform_ = icEngined;

        logger.log("logPlatform", "createIcPlatform", {
          id__platform: icPlatform.id,
          id__terrace:  icComposite__terrace.id,
          // id__dropTouchSlot: icDropTouchSlot.id,
        });

        return icPlatform_;
      }

      createIcBiPlatform(trueRect__biPlatform, parts__terrace1 = {}, parts__terrace2 = {}) {

        const icRect__backade = infiniteCanvas.createIcRect(trueRect__biPlatform);
        icRect__backade.fill = "grey";
        icRect__backade.isTouchable = false;

        //create platform1
        const rectRel__platform1 = {
          l: 0,
          t: 0,
          r: 0.4,
          b: 0.66,
        };
        const trueRect__platform1 = Geometry.rectForRectRel(rectRel__platform1, trueRect__biPlatform);
          //set position of parts to be terraced
        Object.values(parts__terrace1).forEach((icObj) => {
          logger.log("logBiPlatform", "createIcBiPlatform", "parts__terrace1", "icObj:", icObj);

          const position_dst = {
            x: trueRect__platform1.x + 1,
            y: trueRect__platform1.y + 1,
          };

          const homeScale_dst = {
            X: 2.0,
            Y: 2.0,
          };

          if(icObj.type == "composite") {
            CompositeUtils.shiftToPositionAndScale2(icObj, position_dst, homeScale_dst);
          } else {
            icObj.position  = Object.assign({}, position_dst);
            icObj.homeScale = Object.assign({}, homeScale_dst);
          }

        });

        const icPlatform1 = infiniteCanvas.createIcPlatform(trueRect__platform1, parts__terrace1);
          

        //create platform2
        const rectRel__platform2 = {
          l: 0.6,
          t: 0,
          r: 1,
          b: 0.66,
        };
        const trueRect__platform2 = Geometry.rectForRectRel(rectRel__platform2, trueRect__biPlatform);
          //set position of parts to be terraced
        Object.values(parts__terrace2).forEach((icObj) => {
          logger.log("logBiPlatform", "createIcBiPlatform", "parts__terrace2", "icObj:", icObj);

          const position_dst = {
            x: trueRect__platform2.x + 1,
            y: trueRect__platform2.y + 1,
          };

          const homeScale_dst = {
            X: 2.0,
            Y: 2.0,
          };

          if(icObj.type == "composite") {
            CompositeUtils.shiftToPositionAndScale2(icObj, position_dst, homeScale_dst);
          } else {
            icObj.position  = Object.assign({}, position_dst);
            icObj.homeScale = Object.assign({}, homeScale_dst);
          }

        });
        const icPlatform2 = infiniteCanvas.createIcPlatform(trueRect__platform2, parts__terrace2);

        //create content
        const rectRel__content = {
          l: 0.4,
          t: 0.66,
          r: 0.6,
          b: 1,
        };
        const trueRect__content = Geometry.rectForRectRel(rectRel__content, trueRect__biPlatform);
        const icRect__content = infiniteCanvas.createIcRect(trueRect__content);
        icRect__content.fill = "magenta";



          //create biPlatform
        const parts = {
          backade:      icRect__backade,    
          platform1:    icPlatform1,        
          platform2:    icPlatform2,
          content:      icRect__content,    
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false, false); //unmovable, unalterable parts

        // const trueRect__platform = {
        //   x:      trueRect.x,
        //   y:      trueRect.y,
        //   width:  trueRect.width  / 5,
        //   height: trueRect.height / 5,
        // };

        const icComposite = infiniteCanvas.createIcComposite(trueRect__biPlatform, parts, compositeConfig);
        icComposite.cType = "biPlatform";
        // icComposite.isTouchable = false;
        icComposite.zIndex = -1;
        // icComposite.isTouchable = false;

        const icBiPlatform_spec = {
          // arr_terraced: [],
        };

        const icBiPlatform = Object.assign(icComposite, icBiPlatform_spec);

        // //SHU: TODO: BiPlatformEngine
        // const engine = new BiPlatformEngine();
        // const eType  = "biPlatform";
        
        // const icEngined = infiniteCanvas.installEngineOnIcObj(icBiPlatform, eType, engine);

        // const icBiPlatform_ = icEngined;

        return icBiPlatform;
      }


      createIcConductiveOperator(trueRect, mathOperatorSymbol_in = "+", cfg_in = null) {
        console.log("createIcConductiveOperator", trueRect);

        var cfg = cfg_in;
        if (cfg == null) {
          cfg = {
            isRetaining: false,
          };
        }

        const trueRect__platform = Object.assign({}, trueRect, { width: 300, height: 300 });
        const icPlatform = infiniteCanvas.createIcPlatform(trueRect__platform);
        infiniteCanvas.addIcObject(icPlatform);                         //SHU: workaround.  One day, find out how to create fresh composite containing fresh composite

        const touchSlotConfig = {
          transformationFunc: function (icObj) {
            // logger.log("transformationFunc, default", icObj);
            return new TransformationOutput("mutated", icObj, icObj);
            // return icObj;
          },
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;



        const text = mathOperatorSymbol_in;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "platform": icPlatform,
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "conductive_operator";
        // icComposite.isTouchable = false;


        const icConductiveOperator = icComposite;

        //rework
        infiniteCanvas.onceOnAddRepresentedForIcObject(icConductiveOperator, (icConductiveOperator) => {

          const rep_free__conductiveOperator = infiniteCanvas.getRepresented(icConductiveOperator.id).r_free();

          // const rep_free__platform = rep_free__conductiveOperator.parts.platform;
          // logger.log("rep_free__platform", rep_free__platform);

          const rep_free__touchSlot = rep_free__conductiveOperator.parts.touchSlot;

          const mathOperatorSymbol = mathOperatorSymbol_in;

          switch (mathOperatorSymbol) {
            case "+":
            case "-":
            case "x":
            case "/":
              {
                const gmOperatorTextChangeEngine = new GMOperatorTextChangeEngine();
                const mathOperatorFuncName = Operator.funcNameForSymbolString(mathOperatorSymbol);

                const transformationFunc = (icObj) => {
                  var transformationOutput;

                  logger.log("transformationFunc__touch", icObj);

                  const rep_free__platform = rep_free__conductiveOperator.parts.platform;
                  logger.log("rep_free__platform", rep_free__platform);

                  // const icObj__sadness = icObjToIcObjFunc(icObj);

                  const conducted_operands = rep_free__platform.parts.terrace.parts;
                  const arr_conducted_operands = Object.values(conducted_operands);

                  if (arr_conducted_operands.length > 0) {

                    if (icObj.type == "mathNode") {

                      //check if transformation is allowed
                      function isTransformationAllowed_atomic(mathNode_a, mathNode_b) {
                        var outBool;

                        //fractions mode
                        if (MathUtils.isFraction(mathNode_a) && MathUtils.isFraction(mathNode_b)) {

                          const mathNode__denominator_a = mathNode_a.args[1];
                          const mathNode__denominator_b = mathNode_b.args[1];

                          const isSameDenominator = (mathNode__denominator_a.value == mathNode__denominator_b.value);   //SHU: this should be improved (symbols, parentheses...)

                          outBool = isSameDenominator;

                        } else {
                          outBool = true;
                        }

                        return outBool;
                      }

                      const arr_conducted_mathNodes = arr_conducted_operands.filter(icObj => icObj.type == "mathNode").map(icObj => icObj.mathNode);
                      logger.log("arr_conducted_mathNodes", arr_conducted_mathNodes);

                      const mathNode__initial = icObj.mathNode.cloneDeep();
                      mathNode__initial.autoSimplify = icObj.mathNode.autoSimplify;

                      const isTransformationAllowed = Utils.early_break_reduce(arr_conducted_mathNodes, (acc, x, i, arr) => {
                        return acc && isTransformationAllowed_atomic(mathNode__initial, x);
                      }, true, (acc, x, i, arr) => {
                        return (acc == false);
                      });

                      if (isTransformationAllowed) {

                        // const mathNode__new = arr_conducted_mathNodes.reduce((acc, mathNode_conducted) => {
                        const mathNode__new = arr_conducted_operands.reduce((acc, icObj_conducted) => {

                          const mathNode__acc = acc;
                          const mathNode_conducted = icObj_conducted.mathNode;

                          if (!cfg.isRetaining) {
                            rep_free__platform.parts.terrace.dict_engine["composite"].engine.awoken.removePart(icObj_conducted);
                            icObj_conducted.im_dying_now = true;
                          }

                          const transformationFunc = gmOperatorTextChangeEngine.createTransformationFunc(mathOperatorSymbol, mathOperatorFuncName, mathNode_conducted);

                          const transformationFunc__decorated = function (mathNode) {
                            var outMathNode;

                            outMathNode = transformationFunc(mathNode);

                            return outMathNode;
                          };

                          //SHU: addition de fractions:
                          // const transformationFunc__decorated = function(mathNode) {
                          //   var outMathNode;
                          //
                          //   // outMathNode = transformationFunc(mathNode);
                          //   // outMathNode = Simplifier.simplify_fraction(outMathNode);
                          //
                          //   logger.log("mathNode__acc", mathNode__acc);
                          //
                          //   const mathNode_numerator__acc       = mathNode__acc.args[0];
                          //   const mathNode_numerator__conducted = mathNode_conducted.args[0];
                          //
                          //   const value__numerator      = mathNode_numerator__acc.value + mathNode_numerator__conducted.value;
                          //   const mathNode__numerator   = new math.ConstantNode(value__numerator);
                          //   const mathNode__denominator = mathNode__acc.args[1];
                          //
                          //   outMathNode = new math.OperatorNode("/", "divide", [mathNode__numerator, mathNode__denominator]);
                          //
                          //   return outMathNode;
                          // };

                          acc = transformationFunc__decorated(acc);

                          return acc;
                        }, mathNode__initial);
                        logger.log("mathNode__new", mathNode__new);

                        const icObj__new = icObj.clone();
                        icObj__new.mathNode = mathNode__new;

                        transformationOutput = new TransformationOutput("mutated", icObj__new, icObj);

                      } else {
                        transformationOutput = new TransformationOutput("old", icObj, icObj);
                      }

                    } else {
                      transformationOutput = new TransformationOutput("old", icObj, icObj);
                    }

                  } else {
                    icObj.fill = ColorUtils.randomColor();
                    // icObj.mathNode = new math.ConstantNode(42);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc;
              }
              break;

            case "randInBag":
              {
                const transformationFunc = (icObj) => {
                  var transformationOutput;

                  logger.log("transformationFunc__touch", icObj);

                  const rep_free__platform = rep_free__conductiveOperator.parts.platform;
                  logger.log("rep_free__platform", rep_free__platform);

                  // const icObj__sadness = icObjToIcObjFunc(icObj);

                  const conducted_operands = rep_free__platform.parts.terrace.parts;
                  const arr_conducted_operands = Object.values(conducted_operands);

                  switch (arr_conducted_operands.length) {
                    case 0:
                      {
                        icObj.fill = ColorUtils.randomColor();
                        // icObj.mathNode = new math.ConstantNode(42);
                        transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                      }
                      break;

                    case 1:
                      {
                        const isBag = (arr_conducted_operands[0].type == "composite");
                        if (isBag) {

                          const icObj__bag = arr_conducted_operands[0];

                          const arr_part = Object.values(icObj__bag.parts)
                            .filter(icObj__part => !icObj__part.isCosmetic);

                          const part__random = Utils.randomElementInArray(arr_part);

                          var icObj__new;
                          if (cfg.isConsume) {
                            //remove part
                            const rep_free__parent = infiniteCanvas.getRepresented(part__random.compositeId).r_free();
                            rep_free__parent.dict_engine["composite"].engine.awoken.removePart(part__random);

                            icObj__new = part__random;

                            //destroy bag if emptied
                            {
                              const arr_remaining = Object.values(rep_free__parent.parts)
                                .filter(icObj__part => !icObj__part.isCosmetic);

                              if (arr_remaining.length == 0) {

                                // //remove bag from platform's terrace
                                // const rep_free__terrace = infiniteCanvas.getRepresented(rep_free__parent.compositeId).r_free();
                                // rep_free__terrace.engine.awoken.removePart(rep_free__parent);

                                // rep_free__parent.shouldAlsoRemoveChildren = true;

                                rep_free__parent.im_dying_now = true;
                              }
                            }


                          } else {
                            const icObj__clone = infiniteCanvas.createReplicant(part__random);
                            icObj__new = icObj__clone;
                          }

                          // icObj__new.position = Object.assign({}, icObj.position);

                          transformationOutput = new TransformationOutput("new", icObj__new, icObj);

                        } else {
                          const part__random = arr_conducted_operands[0];

                          const icObj__clone = infiniteCanvas.createReplicant(part__random);
                          icObj__new = icObj__clone;

                          transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                        }
                      }
                      break;

                    default:  //manage objects put directly on platform     //SHU: TODO: flatten atoms and composites
                      {
                        const arr_part = arr_conducted_operands;

                        //debug
                        {
                          const arr_values = arr_part.map(x => {
                            var outValue;

                            const mathNode = x.mathNode;
                            logger.log("mathNode", mathNode);
                            if (mathNode != null) {
                              outValue = mathNode.value;
                            }

                            return outValue;
                          });
                          logger.log("arr_values", arr_values);
                        }

                        const part__random = Utils.randomElementInArray(arr_part);

                        var icObj__new;
                        if (cfg.isConsume) {
                          //remove part
                          const rep_free__parent = infiniteCanvas.getRepresented(part__random.compositeId).r_free();
                          rep_free__parent.dict_engine["composite"].engine.awoken.removePart(part__random);

                          icObj__new = part__random;
                        } else {
                          const icObj__clone = infiniteCanvas.createReplicant(part__random);
                          icObj__new = icObj__clone;
                        }

                        // icObj__new.position = Object.assign({}, icObj.position);

                        transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                      }
                      break;
                  }

                  return transformationOutput;
                };

                rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc;
              }
              break;
            default:
              throw new Error("Unsupported mathOperatorSymbol: " + mathOperatorSymbol);
              break;
          }




        });

        return icConductiveOperator;
      }


      createIcFractionOneOperator(trueRect, operatorNodeFactoryFuncWrapper_in = null, isSimplifying = true) {

        var operatorNodeFactoryFuncWrapper;
        if (operatorNodeFactoryFuncWrapper_in != null) {
          operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_in;
        } else {
          const op = Operator.fromOpString_binary("x");
          const node_b = new math.ConstantNode(2);
          operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);
        }

        const touchSlotConfig = {
          transformationFunc: function (icObj) {
            var transformationOutput;

            if (icObj.type == "mathNode") {

              var mathNode__input = icObj.mathNode;

              // const isFraction = MathUtils.isFraction(mathNode__input);
              const isFraction = mathNode__input.type == "OperatorNode" && mathNode__input.fn == "divide";
              if (!isFraction) {
                mathNode__input = new math.OperatorNode("/", "divide", [mathNode__input, new math.ConstantNode(1)]);
              }

              const mathNode__input__numerator = mathNode__input.args[0];
              const mathNode__input__denominator = mathNode__input.args[1];

              const operatorNodeFunc = operatorNodeFactoryFuncWrapper.func;

              // var mathNode__output__numerator   = new math.OperatorNode("x", "multiply", [mathNode__input__numerator,   mathNode__factor]);
              var mathNode__output__numerator = operatorNodeFunc(mathNode__input__numerator);
              if (isSimplifying) {
                mathNode__output__numerator = Simplifier.simplify_fraction(mathNode__output__numerator);
              }

              // var mathNode__output__denominator = new math.OperatorNode("x", "multiply", [mathNode__input__denominator, mathNode__factor]);
              var mathNode__output__denominator = operatorNodeFunc(mathNode__input__denominator);
              if (isSimplifying) {
                mathNode__output__denominator = Simplifier.simplify_fraction(mathNode__output__denominator);
              }

              var mathNode__output = new math.OperatorNode("/", "divide", [mathNode__output__numerator, mathNode__output__denominator]);
              if (isSimplifying) {
                if (mathNode__output__denominator.value == 1) {
                  mathNode__output = mathNode__output__numerator;
                }
              }

              const icObj__new = icObj.clone();
              icObj__new.mathNode = mathNode__output;

              transformationOutput = new TransformationOutput("mutated", icObj__new, icObj);

            } else {
              transformationOutput = new TransformationOutput("old", icObj, icObj);
            }

            return transformationOutput;
          },
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;


        // const value = mathNode__factor.value;
        const operation = operatorNodeFactoryFuncWrapper.semantics.name;

        // const text         = "x" + "(" + value + "/" + value + ")";
        // const facade       = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        // const tex = '\\times \\frac{' + value +  '}{' + value + '}';
        const tex = '\\frac{\\ ' + operation + '}{\\ ' + operation + '}';

        const facade = infiniteCanvas.createIcTex(trueRect.x, trueRect.y, tex);
        facade.size = {
          width: 100,
          height: 100,
        };

        facade.backgroundColor = "orange";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };
        // touchSlot.zIndex = facade.zIndex - 1;

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "fractionOne_operator";
        // icComposite.isTouchable = false;

        const icFractionOneOperator = icComposite;

        return icFractionOneOperator;
      }




      createIcConductiveCompositingOperator(trueRect) {
        logger.log("createIcConductiveCompositingOperator", trueRect);

        const icPlatform = infiniteCanvas.createIcPlatform(trueRect);
        infiniteCanvas.addIcObject(icPlatform);                         //SHU: workaround.  One day, find out how to create fresh composite containing fresh composite

        const touchSlotConfig = {
          transformationFunc: function (icObj) {
            // logger.log("transformationFunc, default", icObj);
            return new TransformationOutput("mutated", icObj, icObj);
            // return icObj;
          },
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const parts = {
          "platform": icPlatform,
          "touchSlot": touchSlot,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "conductive_compositing_operator";
        // icComposite.isTouchable = false;


        const icConductiveCompositingOperator = icComposite;

        //rework
        infiniteCanvas.onceOnAddRepresentedForIcObject(icConductiveCompositingOperator, (icConductiveCompositingOperator) => {

          const rep_free__conductiveCompositingOperator = infiniteCanvas.getRepresented(icConductiveCompositingOperator.id).r_free();

          const rep_free__touchSlot = rep_free__conductiveCompositingOperator.parts.touchSlot;

          const transformationFunc = (icObj) => {
            var transformationOutput;

            logger.log("transformationFunc__touch", icObj);

            const rep_free__platform = rep_free__conductiveCompositingOperator.parts.platform;
            logger.log("rep_free__platform", rep_free__platform);

            const dict__conducted_operators = rep_free__platform.parts.terrace.parts;
            const arr__conducted_operators = Object.values(dict__conducted_operators);

            transformationOutput = new TransformationOutput("old", icObj, icObj);

            if (arr__conducted_operators.length > 0) {

              const arr__operations = arr__conducted_operators.map(icObj__operator => {
                logger.log("icObj__operator", icObj__operator);
                const operation = icObj__operator.operation;
                return operation;
              });

              transformationOutput = arr__operations.reduce((acc, operation) => {
                var transformationOutput__step;

                logger.log("operation", operation);
                const transformationOutput__previousStep = acc;
                const input = transformationOutput__previousStep.value;

                transformationOutput__step = operation.transformationFunc(input);

                return transformationOutput__step;
              }, transformationOutput);

              logger.log("transformationOutput", transformationOutput);
            }

            return transformationOutput;
          };

          rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc;

        });

        return icConductiveCompositingOperator;
      }





      createIcGMClickWell(trueRect, value_in = -48) {
        console.log("createIcClickWell", trueRect);

        const infiniteCanvas = this;

        // const type      = "clickWell";
        const type = "button";

        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const buttonFunc = (scopeObj) => {
          console.log("buttonFunc", scopeObj);
          const button = scopeObj.engineCarrier;
          button.fill = ColorUtils.randomColor();

          //create/add new spawn
          const infiniteCanvas = scopeObj.infiniteCanvas;

          const spawn = infiniteCanvas.createIcGreenMouse(trueRect, value_in);

          infiniteCanvas.addIcObject(spawn);
        };

        const buttonConfig = {
          buttonFunc: buttonFunc,
        };


        const icButton_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 1,
          fill: "lightgray",

          buttonConfig: buttonConfig,
        };

        const icButton = Object.assign(icObj, icButton_spec);


        const engine = new ButtonEngine();
        const eType = "button";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icButton, eType, engine);

        return icEngined;
      }


      createIcGreenMouse(trueRect, value_in = 1) {
        console.log("createIcGreenMouse", trueRect);

        const infiniteCanvas = this;

        // const type      = "greenMouse";


        const mathNode = new math.ConstantNode(value_in);
        mathNode.autoSimplify = true;
        const spawn = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);



        infiniteCanvas.onceOnAddRepresentedForIcObject(spawn, (spawn) => {

          //set spawn as active object
          const spawn__represented = infiniteCanvas.getRepresented(spawn.id);
          const spawn__rep_free = spawn__represented.r_free();

          //greenMouseify
          infiniteCanvas.greenMouseify(spawn__rep_free);
          spawn__rep_free.onHold(() => {
            spawn__rep_free.curse_greenMouse_start();
          })

        });


        return spawn;
      }


      createIcBornAgainGreenMouse(trueRect, mathNode_in = new math.ConstantNode(1)) {
        console.log("createIcBornAgainGreenMouse", trueRect);

        const infiniteCanvas = this;

        // const type      = "bornAgainGreenMouse";


        const mathNode = mathNode_in;
        // mathNode.autoSimplify = true;

        const spawn = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        spawn.isTouchable = true;


        infiniteCanvas.onceOnAddRepresentedForIcObject(spawn, (spawn) => {

          //set spawn as active object
          const spawn__represented = infiniteCanvas.getRepresented(spawn.id);
          const spawn__rep_free = spawn__represented.r_free();

          //greenMouseify
          infiniteCanvas.greenMouseify(spawn__rep_free);
          spawn__rep_free.onHold(() => {
            spawn__rep_free.curse_greenMouse_start();
          });

          //bornAgainify
          infiniteCanvas.bornAgainify(spawn__rep_free);
          //spawn__rep_free.onHold(() => {
          spawn__rep_free.curse_bornAgain_start();
          //});

        });



        return spawn;
      }


      createIcGreenMouseBox(trueRect, mathNode_in = new math.ConstantNode(1)) {
        console.log("createIcBornAgainGreenMouseBox", trueRect);

        const infiniteCanvas = this;

        // const type      = "bornAgainGreenMouse";


        const mathNode = mathNode_in;
        // mathNode.autoSimplify = true;


        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        facade.isTouchable = false;
        const contactArea = infiniteCanvas.createIcRect(trueRect);
        contactArea.fill = "lightblue";

        const parts = {
          contactArea: contactArea,
          facade:      facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_box";

        const greenMouseBox = icComposite;
        greenMouseBox.isTouchable = true;
        // greenMouseBox.canBeHeld   = true;


        infiniteCanvas.onceOnAddRepresentedForIcObject(greenMouseBox, (greenMouseBox) => {

          //set spawn as active object
          const greenMouseBox__represented = infiniteCanvas.getRepresented(greenMouseBox.id);
          const greenMouseBox__rep_free = greenMouseBox__represented.r_free();

          //greenMouseify
          const facade__rep_free = greenMouseBox__rep_free.parts.facade;

          greenMouseBox__rep_free.die = () => {
            greenMouseBox__rep_free.im_dying_now = true;
          };

          infiniteCanvas.greenMouseify(facade__rep_free);
          //rewrite greenMouse.die
          facade__rep_free.die = () => {
            // logger.log("greenMouse, die (override)");
            greenMouseBox__rep_free.die();
          };

          facade__rep_free.onHold(() => {
            // logger.log("greenMouseBox__rep_free", "curse_greenMouse_start");
            facade__rep_free.curse_greenMouse_start();
          });

        });

        return greenMouseBox;
      }

      createIcBornAgainGreenMouseBox(trueRect, mathNode_in = new math.ConstantNode(1)) {
        console.log("createIcBornAgainGreenMouseBox", trueRect);

        const infiniteCanvas = this;

        // const type      = "bornAgainGreenMouse";


        const mathNode = mathNode_in;
        // mathNode.autoSimplify = true;


        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        const contactArea = infiniteCanvas.createIcRect(trueRect);
        contactArea.fill = "lightblue";

        const parts = {
          contactArea: contactArea,
          facade: facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_box";

        const greenMouseBox = icComposite;
        greenMouseBox.isTouchable = true;


        infiniteCanvas.onceOnAddRepresentedForIcObject(greenMouseBox, (greenMouseBox) => {

          //set spawn as active object
          const greenMouseBox__represented = infiniteCanvas.getRepresented(greenMouseBox.id);
          const greenMouseBox__rep_free = greenMouseBox__represented.r_free();

          //greenMouseify
          infiniteCanvas.greenMouseify(greenMouseBox__rep_free);
          greenMouseBox__rep_free.onHold(() => {
            greenMouseBox__rep_free.curse_greenMouse_start();
          });

          //bornAgainify
          infiniteCanvas.bornAgainify(greenMouseBox__rep_free);
          //spawn__rep_free.onHold(() => {
          greenMouseBox__rep_free.curse_bornAgain_start();
          //});

        });



        return greenMouseBox;
      }



      createIcExoSkeleton(/*icObj__heart,*/ exoSkeletonConfig) {
        console.log("createIcExoSkeleton", /*icObj__heart,*/ exoSkeletonConfig);

        const infiniteCanvas = this;

        function easyTrueRectWithTrueRect(trueRect, position_easy) {
          var outTrueRect;

          const trueRect_clone = Object.assign({}, trueRect);
          switch (position_easy) {
            case "left":
              outTrueRect = trueRect_clone;
              outTrueRect.x = outTrueRect.x - outTrueRect.width;
              break;
            case "right":
              outTrueRect = trueRect_clone;
              outTrueRect.x = outTrueRect.x + outTrueRect.width;
              break;
            case "top":
              outTrueRect = trueRect_clone;
              outTrueRect.y = outTrueRect.y - outTrueRect.height;
              break;
            case "bottom":
              outTrueRect = trueRect_clone;
              outTrueRect.y = outTrueRect.y + outTrueRect.height;
              break;
            case "center":
              outTrueRect = trueRect_clone;
              break;
            default:
              throw new Error("Unsupported position_easy: " + position_easy);
              break;
          }

          return outTrueRect;
        }

        const trueRect__heart = {
          x: icObj__heart.position.x,
          y: icObj__heart.position.y,
          width: icObj__heart.size.width,
          height: icObj__heart.size.height,
        };


        const icObj__display = icObj__heart.deepClone();
        icObj__display.stroke = "red";
        icObj__display.strokeWidth = 5;



        const icObj__grab = infiniteCanvas.createIcRect(trueRect__heart);
        icObj__grab.fill = "green";
        const trueRect__grab = easyTrueRectWithTrueRect(trueRect__heart, exoSkeletonConfig.grab.position_easy);
        icObj__grab.position = {
          x: trueRect__grab.x,
          y: trueRect__grab.y,
        };

        const icObj__contact = infiniteCanvas.createIcRect(trueRect__heart);
        icObj__contact.fill = "lightblue";
        const trueRect__contact = easyTrueRectWithTrueRect(trueRect__heart, exoSkeletonConfig.contact.position_easy);
        icObj__contact.position = {
          x: trueRect__contact.x,
          y: trueRect__contact.y,
        };

        const parts = {
          heart: icObj__heart,

          display: icObj__display,
          grab: icObj__grab,
          contact: icObj__contact,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect__heart, parts, compositeConfig);
        icComposite.cType = "exoSkeleton";

        return icComposite;
      }








      createIcWell(trueRect) {
        console.log("createIcWell", trueRect);

        const startingValue = 1;

        const canSnapFunc = (above, below) => {
          var outBool;

          const canSnapFunc_geometryWise = (above, below) => {
            // return Snap.canSnap(above, below);
            return Snap.canSnap_noSize(above, below);
          };

          // const canSnapFunc_valueWise    = (above, below) => (above.value == targetValue);
          // const canSnapFunc_valueWise    = (above, below) => {
          //   const value = parseInt(above.text,10);
          //   const isValueValid = (value == targetValue);
          //   return isValueValid;
          // };

          const canSnapFuncs = {
            "geometry": canSnapFunc_geometryWise,
            // "value":    canSnapFunc_valueWise,
          };

          const canSnapFunc_allWise = (above, below) => Object.entries(canSnapFuncs).reduce((acc, [canSnapFunc_xWiseName, canSnapFunc_xWise]) => {
            const canSnap_xWise = canSnapFunc_xWise(above, below);
            console.log("canSnap_xWise", canSnapFunc_xWiseName, canSnap_xWise);
            return acc && canSnap_xWise;
          }, true);

          const canSnap_allWise = canSnapFunc_allWise(above, below);
          console.log("canSnap_allWise", canSnap_allWise);

          outBool = canSnap_allWise;

          return outBool;
        };
        const canUnsnapFunc = (above, below) => {
          return Snap.canUnsnap(above, below);
        };
        // const snapMutationFunc  = (above, below) => {   //SHU TODO: toSnapState mutations: toPresnapped, toSnapped, toUnsnapped
        //   //how rep_snapped  will differ from rep_official
        //   //how snappedState will differ from rep_official
        // };
        const snapSlotConfig = {
          canSnapFunc: canSnapFunc,
          canUnsnapFunc: canUnsnapFunc,
        };

        const snapSlot = infiniteCanvas.createIcSnapSlot(trueRect, snapSlotConfig);
        snapSlot.fill = "lightblue";
        snapSlot.isMobile = false;

        const text = startingValue.toString(10);
        const stem = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        stem.textColor = "blue";
        stem.backgroundColor = "";
        stem.isMobile = true;
        stem.isTouchable = true;

        const parts = {
          // "snapSlot": snapSlot,
          "stem": stem,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "well";

        // icComposite.isTouchable = false;


        // snapEngine.will['unsnap'].on((snapSlot, icObj) => {
        //   console.log("well, snapEngine.will['unsnap']", snapSlot, icObj);
        //
        //   const cloned = icObj.deepClone();
        //   cloned.snapState = SnapState.Unsnapped;
        //   cloned.position = Object.assign({}, snapSlot.position);
        //   infiniteCanvas.addIcObject(cloned);
        //
        //   // snapEngine.clonedObj = cloned;
        // });


        // infiniteCanvas.onceOnAddRepresentedForIcObject(stem, (stem) => {
        //
        //   //get free rep
        //   const represented = infiniteCanvas.getRepresented(stem.id);
        //   console.log("represented", represented);
        //   const rep_free = represented.r_free();
        //
        //   infiniteCanvas.greenMouseify(rep_free);
        //
        //   rep_free.curse_greenMouse_start();
        // });


        return icComposite;
      }






      greenMouseify(rep) {
        console.log("greenMouseify", rep);

        rep.die = () => {
          // logger.log("greenMouse, die");
          rep.im_dying_now = true;
        };

        rep.curse_greenMouse_do = (icObj) => {
          console.log("curse_greenMouse_do");
          rep.curse_greenMouse_end();
          rep.die();
        };

        rep.curse_greenMouse_start = () => {
          rep.onRelease(rep.curse_greenMouse_do);
        };

        rep.curse_greenMouse_end = () => {
          rep.offRelease(rep.curse_greenMouse_do);
        };

        // rep.curse_greenMouse_start = () => {
        //   if(rep.cType == "gm_box") {
        //     rep.parts.facade.onRelease(rep.curse_greenMouse_do);
        //   } else {
        //     rep.onRelease(rep.curse_greenMouse_do);
        //   }
        // };
        //
        // rep.curse_greenMouse_end = () => {
        //   if(rep.cType == "gm_box") {
        //     rep.parts.facade.offRelease(rep.curse_greenMouse_do);
        //   } else {
        //     rep.offRelease(rep.curse_greenMouse_do);
        //   }
        // };

      }


      bornAgainify(rep) {
        console.log("bornAgainify", rep);

        const infiniteCanvas = this;

        if (rep.die == null) {
          throw new Error("Can't resurrect what doesn't die");
        }
        Hooker.installHooks(rep, "die");

        if (rep.number_replica == null) {
          rep.number_replica = 0;
        }

        const stem = rep.clone();
        // stem.mathNode = rep.mathNode.cloneDeep();

        rep.prepareForResurrection = () => {

        };

        rep.resurrect = () => {
          console.log("resurrect");

          //born again
          const resurrected = stem.clone();
          // logger.log("resurrected", resurrected);
          resurrected.mathNode = stem.mathNode;

          const id_resurrected = this.generateIcObjectId();
          resurrected.id = id_resurrected;

          resurrected.number_replica = stem.number_replica + 1;

          infiniteCanvas.addIcObject(resurrected);


          //cursed again
          //SHU TODO: better management of curses
          const spawn__represented = infiniteCanvas.getRepresented(resurrected.id);
          const spawn__rep_free = spawn__represented.r_free();

          //greenMouseify
          infiniteCanvas.greenMouseify(spawn__rep_free);
          spawn__rep_free.onHold(() => {
            spawn__rep_free.curse_greenMouse_start();
          })

          //bornAgainify
          infiniteCanvas.bornAgainify(spawn__rep_free);
          spawn__rep_free.curse_bornAgain_start();

        };

        rep.curse_bornAgain_start = () => {
          rep.will["die"].on(rep.prepareForResurrection);
          rep.did["die"].on(rep.resurrect);
        };

        rep.curse_bornAgain_end = () => {
          rep.did["die"].off(rep.resurrect);
        };



        //not that easy to die
        // Object.defineProperty(rep, 'im_dying_now', {
        //   get() { return false; },
        //   set(newValue) { rep.lolilol = newValue; },
        //   enumerable: true,
        //   configurable: true
        // });

      }

      // createCurseTrigger_countdown() {
      //
      //   const curseTrigger = new CurseTrigger_countdown();
      //
      //   return curseTrigger;
      // }

      createCurse_metamorphosis(curseTrigger) {
        logger.log("createCurse_metamorphosis", curseTrigger);


        // const facade_represented = infiniteCanvas.getRepresented(facade.id);
        // const facade_rep_free    = facade_represented.r_free();
        //
        // const mathNode = new math.ConstantNode(stepIndex);
        // facade_rep_free.mathNode = mathNode;

        const curseFunc = (rep_free) => {
          // logger.log("curseFunc, rep_free:", rep_free);
          const mathNode = random_constantNode();
          rep_free.mathNode = mathNode;
        };

        const curse_metamorphosis = this.createCurse(curseTrigger);
        // logger.log("curse_metamorphosis.curseTrigger", curse_metamorphosis.curseTrigger);

        curse_metamorphosis.curseFunc = curseFunc;
        curse_metamorphosis.rx_countDownCounter = curseTrigger.engine.rx_countDownCounter;

        return curse_metamorphosis;
      }

      createCurse(curseTrigger) {
        // logger.log("createCurse", curseTrigger);

        const curse = new Curse(curseTrigger);

        return curse;
      }

      accurse__metamorphosis(rep_free) {
        const infiniteCanvas = this;

        const curseTrigger_countdown = new CurseTrigger_countdown();
        const curse_metamorphosis = this.createCurse_metamorphosis(curseTrigger_countdown);

        curse_metamorphosis.reset = function () {
          const curseTrigger_countdown = new CurseTrigger_countdown();
          curseTrigger_countdown.curse = curse_metamorphosis;

          curse_metamorphosis.curseTrigger = curseTrigger_countdown;
          curse_metamorphosis.rx_countDownCounter = curseTrigger_countdown.engine.rx_countDownCounter;


          // infiniteCanvas.accurse__metamorphosis(rep_free);   //SHU: does not work
        };

        rep_free.curse_metamorphosis = curse_metamorphosis;
      }




      createIcGMWell(trueRect, icObj__wrapped) {
        logger.log("logVarSlot", "createIcGMWell", trueRect, icObj__wrapped);
        const infiniteCanvas = this;

        const icObj__wrapped__clone = icObj__wrapped.deepClone();

        const facade      = icObj__wrapped__clone;
        
        const wellArea    = infiniteCanvas.createIcRect(trueRect);
        wellArea.fill     = "lightblue";

        const parts = {
          facade:   facade,
          wellArea: wellArea,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gmWell";

        const gmWell       = icComposite;
        gmWell.isTouchable = false;


        infiniteCanvas.onceOnAddRepresentedForIcObject(gmWell, (gmWell) => {

          //set spawn as active object
          const represented__gmWell = infiniteCanvas.getRepresented(gmWell.id);
          const rep_free__gmWell    = represented__gmWell.r_free();

          // //greenMouseify
          // infiniteCanvas.greenMouseify(rep_free__gmWell);
          // rep_free__gmWell.onHold(() => {
          //   rep_free__gmWell.curse_greenMouse_start();
          // });

          // //bornAgainify
          // infiniteCanvas.bornAgainify(rep_free__gmWell);
          // //spawn__rep_free.onHold(() => {
          //   rep_free__gmWell.curse_bornAgain_start();
          // //});

          
          // //"exo curse"
          // Hooker.installHooks(rep_free__ball, "die");
          // rep_free__gmWell.did["die"].on(() => {
          //   // logger.log("did die");
  
          //   rep_free__gmWell.parts.facade.im_dying_now      = true;
          //   rep_free__gmWell.parts.contactArea.im_dying_now = true;
  
          //   //step.addNewBall();
          // });

          const rep_free__facade = rep_free__gmWell.parts.facade;

          function wellify(rep_free__facade) {
            const fObj__facade = fabricIntegration.getFObjForIcObj(rep_free__facade);
            fObj__facade.on('mousedown', function(options) {
              logger.log("logVarSlot", "fObj__facade.on('mousedown')", options);

              // rep_free__facade.release();

              // const icObj__wrapped__clone2 = rep_free__facade.deepClone();
              // const id__clone2          = infiniteCanvas.generateIcObjectId();
              // icObj__wrapped__clone2.id = id__clone2; 
              // logger.log("logVarSlot", "icObj__wrapped__clone2.id", icObj__wrapped__clone2.id);

              // icObj__wrapped__clone2.zIndex   = infiniteCanvas.getFreshIcZIndex__max();

              // infiniteCanvas.onceOnAddRepresentedForIcObject(icObj__wrapped__clone2, (icObj__wrapped__clone2) => {

              //   const rep_free__icObj__wrapped__clone2 = infiniteCanvas.getRepresented(icObj__wrapped__clone2.id).r_free();

              //   //put object under mouse
              //   setTimeout(() => {
              //     const fObj__clone2 = fabricIntegration.getFObjForIcObj(rep_free__icObj__wrapped__clone2);
              //     // fabricIntegration.putFObjUnderMouseCursor(fObj__clone2);
              //     fabricIntegration.fabricCanvas.discardActiveObject();
              //     fabricIntegration.simulateMouseUpDownToHoldFObj(fObj__clone2, function(){});
              //   }, 50);

              // });

              try {

                //remove part: old facade
                rep_free__gmWell.dict_engine["composite"].engine.awoken.removePart(rep_free__facade);

                //clone old facade
                const icObj__wrapped__clone2 = rep_free__facade.deepClone();
                icObj__wrapped__clone2.id = infiniteCanvas.generateIcObjectId();    //SHU: it would be nice if we could preserve original id
                icObj__wrapped__clone2.text      = "lol";
                icObj__wrapped__clone2.textColor = ColorUtils.randomColor();
                icObj__wrapped__clone2.isHeld = false;
                logger.log("logVarSlot", "icObj__wrapped__clone2", icObj__wrapped__clone2);


                // logger.log("logVarSlot", "old facade id", rep_free__facade.id);

                //give new id to old facade
                rep_free__facade.id     = infiniteCanvas.generateIcObjectId();
                // //bring old facade to front
                // rep_free__facade.zIndex = infiniteCanvas.getFreshIcZIndex__max();

                infiniteCanvas.onceOnAddRepresentedForIcObject(icObj__wrapped__clone2, (icObj__wrapped__clone2) => {

                  const rep_free__icObj__wrapped__clone2 = infiniteCanvas.getRepresented(icObj__wrapped__clone2.id).r_free();
                  logger.log("logVarSlot", "new facade id", rep_free__icObj__wrapped__clone2.id);

                  logger.log("logVarSlot", "old facade id", rep_free__facade.id);

                  //add part:    new facade
                  rep_free__gmWell.dict_engine["composite"].engine.awoken.addNamedPart("facade", rep_free__icObj__wrapped__clone2);

                  setTimeout(() => {
                    wellify(rep_free__icObj__wrapped__clone2);
                  }, 100);

                });        

                infiniteCanvas.addIcObject(icObj__wrapped__clone2);

              } catch(e) {
                logger.log("logError", e);
              }


            });
          }

          setTimeout(() => {
            wellify(rep_free__facade);
          }, 100);


        });


        return gmWell;
      }

      // mutateGMWell__addReactivePart(icGreenMouseWell) {
      //
      // }


      createIcGMSafetyZone(trueRect) {
        logger.log("createIcGMSafetyZone", trueRect);

        const icPlatform = infiniteCanvas.createIcPlatform(trueRect);

        //rework
        infiniteCanvas.onceOnAddRepresentedForIcObject(icPlatform, (icPlatform) => {

          const rep_free__platform = infiniteCanvas.getRepresented(icPlatform.id).r_free();

          const transformationFunc__touch = (icObj) => {
            var transformationOutput;

            logger.log("log4", "icGMSafetyZone, transformationFunc__touch", icObj);
            const isGreenMouse = icObj.isGM;

            if (isGreenMouse) {
              logger.log("log4", "isGreenMouse");
              icObj.isSafe = true;
              logger.log("log4", "set .isSafe: true");

              transformationOutput = new TransformationOutput("mutated", icObj, icObj);
            } else {
              transformationOutput = new TransformationOutput("old", icObj, icObj);
            }

            return transformationOutput;
            // return icObj;
          };
          rep_free__platform.parts.dropTouchSlot.touchSlotConfig.transformationFunc__touch = transformationFunc__touch;

          const transformationFunc__untouch = (icObj) => {
            var transformationOutput;
            logger.log("log4", "icGMSafetyZone, transformationFunc__untouch", icObj);
            const isGreenMouse = icObj.isGM;

            if (isGreenMouse) {
              logger.log("log4", "isGreenMouse");
              icObj.isSafe = false;
              logger.log("log4", "set .isSafe: false");

              transformationOutput = new TransformationOutput("mutated", icObj, icObj);
            } else {
              transformationOutput = new TransformationOutput("old", icObj, icObj);
            }

            return transformationOutput;
            // return icObj;
          };
          rep_free__platform.parts.dropTouchSlot.touchSlotConfig.transformationFunc__untouch = transformationFunc__untouch;

        });

        const icGMSafetyZone = icPlatform;

        icGMSafetyZone.parts.terrace.fill = "#FF8822";
        icGMSafetyZone.parts.terrace.opacity = 0.4;
        icGMSafetyZone.parts.dropTouchSlot.fill = "#FFFFFF";

        return icGMSafetyZone;
      }

      createIcTouchHook(trueRect) {

        const touchSlotConfig = {
          transformationFunc: (icObj) => {

          },
          isEnabled: true,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";

        return touchSlot;
      }


      createIcGMOperator(trueRect, cfg) {
        logger.log("logGMOp", "createIcGMOperator", trueRect, cfg);
        const operatorNodeFactoryFuncWrapper = cfg.operatorNodeFactoryFuncWrapper;
        const isEnabled = cfg.isEnabled;
        
        const touchSlotConfig = {
          transformationFunc: operatorNodeFactoryFuncWrapper.func,
          isEnabled: isEnabled,
        };

        const transformationFunc = touchSlotConfig.transformationFunc;
        const transformationFunc__decorated = function (icObj_in) {
          var transformationOutput;

          transformationOutput = transformationFunc(icObj_in);
          logger.log("transformationOutput", transformationOutput);

          //touch animation
          // setTimeout(() => {
            const icObj__result = transformationOutput.value;

            const icObj__facade    = icObj__result.parts.facade;
            const rep_free__facade = infiniteCanvas.getRepresented(icObj__facade.id).r_free();

            infiniteCanvas.animate_bounce(rep_free__facade);
          // }, 1); 

          return transformationOutput;
        };
        const touchSlotConfig__decorated  = Object.assign({},touchSlotConfig,{transformationFunc: transformationFunc__decorated});

        // const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig__decorated);

        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const mathNode__facade = operatorNodeFactoryFuncWrapper.semantics.node__operatorNode.cloneDeep();
        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode__facade);
        facade.backgroundColor = "blanchedalmond";
        if(!isEnabled) {
          facade.opacity = 0.4;
        }
        // facade.isMobile    = false;
        facade.isTouchable = false;
        //SHULOLILOL
        facade.zIndex = 100;

        facade.opacity = "0.8";

        const parts = {
          "touchSlot": touchSlot,
          "facade":    facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.isEntity = true;
        icComposite.cType    = "gm_operator";

        const operation       = new Operation(touchSlotConfig.transformationFunc);
        // const operation       = new Operation(touchSlotConfig__decorated.transformationFunc);
        icComposite.operation = operation;

        // icComposite.isTouchable = false;

        return icComposite;
      }

      createIcGMOperator_withType(trueRect, gmOperatorType, cfg = {}) {
        console.log("logGMOp", "createIcGMOperator_withType", trueRect, gmOperatorType);

        const infiniteCanvas = this;

        const operatorConfig = infiniteCanvas.createConfig__icGMOperator_withType(gmOperatorType, cfg);

        const icGMOperator = infiniteCanvas.createIcGMOperator_withConfig(trueRect, operatorConfig, cfg);

        return icGMOperator;
      }

      createIcGMOperator_withConfig(trueRect, operatorConfig, cfg = {}) {
        logger.log("logGMOp", "createIcGMOperator_withConfig", trueRect, operatorConfig);

        const infiniteCanvas = this;

        const touchSlotConfig = {
          transformationFunc:   operatorConfig.transformationFunc,
          isCollectionOperator: cfg.isCollectionOperator,
        };


        const transformationFunc = touchSlotConfig.transformationFunc;
        const transformationFunc__decorated = function (icObj_in) {
          var transformationOutput;

          transformationOutput = transformationFunc(icObj_in);
          logger.log("transformationOutput", transformationOutput);

          //touch animation
          // setTimeout(() => {
            const icObj__result = transformationOutput.value;

            if(icObj__result.type == "composite") {
              const icObj__facade    = icObj__result.parts.facade;
              const rep_free__facade = infiniteCanvas.getRepresented(icObj__facade.id).r_free();
  
              infiniteCanvas.animate_bounce(rep_free__facade);
            } else {
              infiniteCanvas.animate_bounce(icObj__result);
            }

          // }, 1); 

          return transformationOutput;
        };
        const touchSlotConfig__decorated  = Object.assign({},touchSlotConfig,{transformationFunc: transformationFunc__decorated});


        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig__decorated);
        touchSlot.fill  = "";
        // touchSlot.isMobile = false;


        var facade;

        const text          = operatorConfig.name;
        const node__display = operatorConfig.node__display;
        if(text != null) {
          facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        } else if(node__display != null) {
          facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, node__display);
        } else {
          facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "facade__default");
        }
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        facade.isTouchable = false;

        facade.opacity = "0.8";

        const parts = {
          "touchSlot": touchSlot,
          "facade":    facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.isEntity = true;
        icComposite.cType = "gm_operator";
        // icComposite.isTouchable = false;
        icComposite.fill = "transparent";

        facade.zIndex = icComposite.zIndex + 1;


        // infiniteCanvas.onceOnAddRepresentedForIcObject(touchSlot, (touchSlot) => {

        //   const rep_free = infiniteCanvas.getRepresented(touchSlot.id).r_free();
        //   logger.log("logIsDidApply", "rep_free", rep_free);

        //   //.isDidApply
        //   const touchSlotEngine = rep_free.dict_engine["touchSlot"].engine.awoken;
        //   logger.log("logIsDidApply", "touchSlotEngine", touchSlotEngine);

        //   Hooker.installHooks(touchSlotEngine, "touch");
        //   touchSlotEngine.did["touch"].on(() => {
        //     logger.log("logIsDidApply", "did touch");

        //     // rep_free__ball.parts.facade.im_dying_now      = true;
        //     // rep_free__ball.parts.contactArea.im_dying_now = true;

        //     // step.addNewBall();
        //   });

        // });

        //.isDidApply mechanism
        infiniteCanvas.onceOnAddRepresentedForIcObject(icComposite, (icComposite) => {

          const rep_free__op        = infiniteCanvas.getRepresented(icComposite.id).r_free();
          const rep_free__touchSlot = rep_free__op.parts.touchSlot;

          const touchSlotEngine = rep_free__touchSlot.dict_engine["touchSlot"].engine.awoken;
          // logger.log("logIsDidApply", "touchSlotEngine", touchSlotEngine);

          Hooker.installHooks(touchSlotEngine, "touch");
          touchSlotEngine.did["touch"].on(() => {
            // logger.log("logIsDidApply", "did touch");

            //create isDidApply spike
            rep_free__op.isDidApply = true;
            setTimeout(() => {
              rep_free__op.isDidApply = false;
            }, 0);

          });

        });

        return icComposite;
      }

      easy__createIcGMOperator_fromString(str__op__easy) {

      }

      createIcGMApplicableOperator(trueRect, cfg) {
        logger.log("createIcGMApplicableOperator", trueRect, cfg);
        const operatorNodeFactoryFuncWrapper = cfg.operatorNodeFactoryFuncWrapper;
        const isEnabled = cfg.isEnabled;
        
        const applySlotConfig = {
          transformationFunc: operatorNodeFactoryFuncWrapper.func,
          isEnabled: isEnabled,
        };

        const applySlot = infiniteCanvas.createIcApplySlot(trueRect, applySlotConfig);
        applySlot.fill = "blue";
        // touchSlot.isMobile = false;

        const mathNode__facade = operatorNodeFactoryFuncWrapper.semantics.node__operatorNode.cloneDeep();
        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode__facade);
        facade.backgroundColor = "blanchedalmond";
        if(!isEnabled) {
          facade.opacity = 0.4;
        }
        // facade.isMobile    = false;
        facade.isTouchable = false;
        //SHULOLILOL
        facade.zIndex = 100;

        facade.opacity = "0.8";

        const parts = {
          "applySlot": applySlot,
          "facade":    facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_applicable_operator";

        const operation       = new Operation(applySlotConfig.transformationFunc);
        icComposite.operation = operation;

        // icComposite.isTouchable = false;

        return icComposite;
      }


      createIcGMApplicableOperator_withType(trueRect, gmOperatorType, cfg = {}) {
        console.log("createIcGMApplicableOperator_withType", trueRect, gmOperatorType);

        const infiniteCanvas = this;

        const operatorConfig = infiniteCanvas.createConfig__icGMOperator_withType(gmOperatorType, cfg);

        const slotConfig = {
          transformationFunc:   operatorConfig.transformationFunc,
          isCollectionOperator: cfg.isCollectionOperator,
        };

        const applySlot = infiniteCanvas.createIcApplySlot(trueRect, slotConfig);
        applySlot.fill  = "blue";
        // touchSlot.isMobile = false;


        var facade;

        const text          = operatorConfig.name;
        const node__display = operatorConfig.node__display;
        if(text != null) {
          facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        } else if(node__display != null) {
          facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, node__display);
        } else {
          facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "facade__default");
        }
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        facade.isTouchable = false;

        facade.opacity = "0.8";


        const parts = {
          "applySlot": applySlot,
          "facade":    facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_applicable_operator";
        // icComposite.isTouchable = false;
        icComposite.fill = "transparent";

        facade.zIndex = icComposite.zIndex + 1;

        return icComposite;
      }


      createIcDiveOperator(trueRect, cfg) {
        logger.log("logGolf", "createIcDiveOperator", trueRect, cfg);
        const operatorNodeFactoryFuncWrapper = cfg.operatorNodeFactoryFuncWrapper;
        const isEnabled = cfg.isEnabled;

        const diveSlotConfig = {
          transformationFunc: operatorNodeFactoryFuncWrapper.func,
          isEnabled: isEnabled,

          // //debug
          // transformationFunc: (icObj) => {
          //   logger.log("diveOp", "transformationFunc");

          //   icObj.stroke = ColorUtils.randomColor();
          //   icObj.mathNode = new math.ConstantNode(101);

          //   const transformationOutput = new TransformationOutput("mutated", icObj, icObj);
          //   return transformationOutput;
          // },
        };

        const diveSlot = infiniteCanvas.createIcDiveSlot(trueRect, diveSlotConfig);
        diveSlot.fill = "lime";
        diveSlot.opacity = 0.5;
        // diveSlot.isMobile = false;

        const mathNode__facade = operatorNodeFactoryFuncWrapper.semantics.node__operatorNode.cloneDeep();
        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode__facade);
        facade.backgroundColor = "blanchedalmond";
        if(!isEnabled) {
          facade.opacity = 0.4;
        }
        // facade.isMobile    = false;
        facade.isTouchable = false;
        //SHULOLILOL
        facade.zIndex = 100;

        facade.opacity = "0.8";

        const parts = {
          "diveSlot": diveSlot,
          "facade":   facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const trueRect__composite = {
          x:      trueRect.x,
          y:      trueRect.y,
          width:  trueRect.width  / 10.0,
          height: trueRect.height / 10.0,
        };
        const icComposite = this.createIcComposite(trueRect__composite, parts, compositeConfig);
        icComposite.cType = "dive_operator";

        const operation       = new Operation(diveSlotConfig.transformationFunc);
        icComposite.operation = operation;

        // icComposite.isTouchable = false;

        return icComposite;        
      }

      createIcDiveOperator_withType(trueRect, gmOperatorType, cfg = {}) {
        console.log("createIcDiveOperator_withType", trueRect, gmOperatorType);

        const infiniteCanvas = this;

        const operatorConfig = infiniteCanvas.createConfig__icGMOperator_withType(gmOperatorType, cfg);

        const diveSlotConfig = {
          transformationFunc:   operatorConfig.transformationFunc,
          isCollectionOperator: cfg.isCollectionOperator,
        };

        const diveSlot = infiniteCanvas.createIcDiveSlot(trueRect, diveSlotConfig);
        diveSlot.fill = "lime";
        diveSlot.opacity = 0.5;
        // diveSlot.isMobile = false;


        var facade;

        const text          = operatorConfig.name;
        const node__display = operatorConfig.node__display;
        if(text != null) {
          facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        } else if(node__display != null) {
          facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, node__display);
        } else {
          facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "facade__default");
        }
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        facade.isTouchable = false;

        facade.opacity = "0.8";

        const parts = {
          "diveSlot":  diveSlot,
          "facade":    facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "dive_operator";
        // icComposite.isTouchable = false;
        icComposite.fill = "transparent";

        facade.zIndex = icComposite.zIndex + 1;

        return icComposite;
      }



      createIcBombOperator() {

      }

      createIcMineOperator() {

      }


      createConfig__icGMOperator_withType(gmOperatorType, cfg = {}) {
        const infiniteCanvas = this;

        function operatorConfigForType(gmOperatorType) {

          var operatorConfig = {
            name: null,
            transformationFunc: null,
          };

          switch (gmOperatorType) {

            case "custom":
              {
                operatorConfig = cfg;
              }
              break;

            case "debug":
            case "debug:random_color":
              {
                operatorConfig.name = "debug:random_color";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  function randomColor() {
                    var r = 255 * Math.random() | 0,
                      g = 255 * Math.random() | 0,
                      b = 255 * Math.random() | 0;
                    return 'rgb(' + r + ',' + g + ',' + b + ')';
                  }

                  const color = randomColor();

                  if("stroke" in cfg) {
                    if("exoObject" in icObj) {
                      const exoObject__new = Object.assign({}, icObj.exoObject); 
                      exoObject__new.stroke = color;
                      icObj.exoObject = exoObject__new;
                    } else {
                      icObj.stroke = color;
                    }
                  }
                  if("fill" in cfg) {
                    icObj.fill = color;
                  }

                  transformationOutput = new TransformationOutput("mutated", icObj, icObj);


                  // const icObj__new = icObj.deepClone();
                  // if("stroke" in cfg) {
                  //   if("exoObject" in icObj) {
                  //     icObj__new.exoObject.stroke = color;
                  //   } else {
                  //     icObj__new.stroke = color;
                  //   }
                  // }
                  // if("fill" in cfg) {
                  //   icObj__new.fill = color;
                  // }
                  // transformationOutput = new TransformationOutput("new", icObj__new, icObj);

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "from_string":
              {
                // throw new Error("do not use " + "gmOperatorType::'from_string'" + " until fixed");

                // const str__operator = cfg.str__operator;
                // operatorConfig.name = str__operator;
                // const transformationFunc = (new GMOperatorTextChangeEngine()).transformationFuncForText(str__operator);
                // operatorConfig.transformationFunc = transformationFunc; 

                const str__operator      = cfg.str__operator;
                operatorConfig.name = "from_string:(" + str__operator + ")";

                const mathNode__operator = infiniteCanvas.numberTyping_parseTex_toOperatorNode(str__operator);
                logger.log("logIcGMOperator", "from_string", "mathNode__operator:", mathNode__operator);

                const operatorConfig__from_operatorNode = infiniteCanvas.createConfig__icGMOperator_withType("from_operatorNode", {
                  mathNode__operator: mathNode__operator,
                });

                operatorConfig.transformationFunc = operatorConfig__from_operatorNode.transformationFunc;
                
              }
              break;
            
            case "from_operatorNode":
              {
                const mathNode__operator = cfg.mathNode__operator;
                // operatorConfig.name      = "lol";
                operatorConfig.node__display = mathNode__operator;

                const arr_zerone__node_empty = mathNode__operator.args.map((arg) => {
                  logger.log("logNT", "arg:", arg);
                  const zeroneNodeEmpty = arg.isNodeEmpty ? 1 : 0;
                  return zeroneNodeEmpty;
                });
                logger.log("logNT", "arr_zerone__node_empty:", arr_zerone__node_empty);

                const arity = arr_zerone__node_empty.reduce((acc,x) => acc + x,0);
                logger.log("logNT", "arity:", arity);
                if(arity > 1) {

                  // const funcWrapper = operatorNodeFactoryFuncWrapper_from_operatorNode(mathNode__operator);
                  // const transformationFunc__mathNode = funcWrapper.func;
  
                  function transformationFunc__icObj(icObj) {
                    var transformationOutput;
        
                    const arr_arg__sleeping      = infiniteCanvas.getArr_icObj("free").filter((icObj) => icObj.isSleeping);
        
                    if(arr_arg__sleeping.length == 0) {
                    // if(arr_arg__sleeping.length < 2) {
        
                      icObj.isSleeping = true;
        
                    } else {
        
                      const arr_mathNode__sleeping = arr_arg__sleeping.map((icMathNode) => icMathNode.mathNode);
        
                      function createMathNode__result_func(arr_mathNode) {

                        // const arr_mathNode__reversed = arr_mathNode.reverse();
                        const arr_mathNode__reversed = arr_mathNode;
          
                        //shu: c'est un peu risqué
                        const mathNode__new = mathNode__operator.transform(function (node, path, parent) {
                          if (node.isSymbolNode && node.isNodeEmpty) {
                            const node_bx = arr_mathNode__reversed.pop();
                            return node_bx;
                          }
                          else {
                            return node;
                          }
                        });
          
                        return mathNode__new;
                      }            
          
                      icObj.mathNode = createMathNode__result_func([icObj.mathNode, ...arr_mathNode__sleeping]);

                      icObj.mathNode = Simplifier.simplify_litexp_2(icObj.mathNode);
                      icObj.mathNode.autoSimplify = true;
        
                      //consume all sleeping args 
                      arr_arg__sleeping.forEach((icObj__sleeping) => {
                        icObj__sleeping.im_dying_now = true;
                      });
        
                    }
        
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
        
                    return transformationOutput;
                  }
                  operatorConfig.transformationFunc = transformationFunc__icObj;

                } else {

                  const funcWrapper = operatorNodeFactoryFuncWrapper_from_operatorNode(mathNode__operator);
                  const transformationFunc__mathNode = funcWrapper.func;
  
                  const transformationFunc__icObj = (icObj) => {
                    logger.log("logOp", "transformationFunc__icObj", icObj);
                    var transformationOutput;
  
                    // const mathNode__in  = icObj.mathNode;
                    // const mathNode__new = transformationFunc__mathNode(mathNode__in);
  
                    // const icObj__new    = icObj.deepClone();
                    // icObj__new.mathNode = mathNode__new;
  
                    // transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                    icObj.mathNode = transformationFunc__mathNode(icObj.mathNode);
                    const autoSimplify = icObj.mathNode.autoSimplify;
                    if(autoSimplify) {
                      icObj.mathNode = math.simplify(icObj.mathNode);
                      icObj.mathNode.autoSimplify = autoSimplify;
                    }
  
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
  
                    return transformationOutput;
                  };
                  operatorConfig.transformationFunc = transformationFunc__icObj;

                }

              }
              break;

            case "from_anonFunctionObjectNode":
              {
                const mathNode__anonFunction = cfg.mathNode__anonFunction;

                const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
                const mathNode__expr  = mathNode__anonFunction.properties["expr"];
                const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);
                operatorConfig.node__display = node__display;

                function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                  var outMathNode;
        
                  switch(objectNode__anonFunction.properties.type.name) {
                    case "anonFunction":
                      {
                        const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                        const mathNode__expr          = objectNode__anonFunction.properties["expr"];

                        // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                        // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);

                        var nb__var_in = arrayNode__operand.items.length;

                        const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                          const name = x.name;
                          // acc[name]  = arrayNode__operand.items[index];
                          acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                          return acc;
                        }, {});
                        logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);


                        //substitute as many bound vars as possible
                        outMathNode = mathNode__expr.transform(function (node, path, parent) {
                          var outNode2; 
              
                          var node__subst;
                          if (node.isSymbolNode && (node.name in dict__betaRed)) {
                            node__subst = dict__betaRed[node.name];
                            if(node__subst != null) {
                              outNode2 = node__subst.cloneDeep();
                            } else {
                              outNode2 = node;
                            }
                          }
                          else {
                            outNode2 = node;
                          }
                          logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
              
                          return outNode2;
                        });
                      }
                      break;
                    default:
                      {
                        throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                        outMathNode = arrayNode__operand;
                      }
                      break;
                  }
        
                  return outMathNode;
                }
  
  
                const transformationFunc__icObj = (icObj) => {
                  logger.log("logOp", "transformationFunc__icObj", icObj);
                  var transformationOutput;

                  const mathNode__in = icObj.mathNode;
                  var arrayNode__in;
                  if(mathNode__in instanceof math.ArrayNode) {
                    arrayNode__in = mathNode__in;
                  } else {
                    arrayNode__in = new math.ArrayNode([mathNode__in]);
                  }
                  const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                  logger.log("logAnon", "mathNode__new:", mathNode__new);
                  logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());


                  icObj.mathNode = mathNode__new;
                  
                  try {
                    const value = mathNode__new.evaluate();
                    const mathNode__new__evaluated = new math.ConstantNode(value);

                    icObj.mathNode = mathNode__new__evaluated;
                  } catch(e) {
                    logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                  }

                  const autoSimplify = icObj.mathNode.autoSimplify;
                  if(autoSimplify) {
                    icObj.mathNode = math.simplify(icObj.mathNode);
                    icObj.mathNode.autoSimplify = autoSimplify;
                  }

                  transformationOutput = new TransformationOutput("mutated", icObj, icObj);

                  return transformationOutput;
                };
                  
                operatorConfig.transformationFunc = transformationFunc__icObj;
              }
              break;

            case "from_anon5050FunctionObjectNode":
              {
                const mathNode__anon5050Function = cfg.mathNode__anon5050Function;
                // logger.log("logAnon5050", "mathNode__anon5050Function:", mathNode__anon5050Function);

                const arr_str__symbol     = mathNode__anon5050Function.properties["mathNode__arr_bound_var"].items.map(x => x.name);
                const mathNode__arr_expr  = mathNode__anon5050Function.properties["mathNode__arr_expr"];
                const node__display = new My5050FunctionAssignmentNode("f", arr_str__symbol, mathNode__arr_expr);
                operatorConfig.node__display = node__display;

                operatorConfig.transformationFunc = function(icObj) {
                  // const mathNode__anonFunction__actual = mathNode__anon5050Function.evaluate();  //SHU: DOES NOT WORK
                  const mathNode__anonFunction__actual = MyAnon5050FunctionObjectNode.evaluateInstance(mathNode__anon5050Function);

                  const operatorConfig__anonFunction__actual = infiniteCanvas.createConfig__icGMOperator_withType("from_anonFunctionObjectNode", {mathNode__anonFunction: mathNode__anonFunction__actual});
                  const transformationFunc__actual           = operatorConfig__anonFunction__actual.transformationFunc;

                  return transformationFunc__actual(icObj);
                };
              }
              break;


            case "apl::iota":
              {
                operatorConfig.node__display = new math.SymbolNode("⍳");
                const transformationFunc__mathNode = (node_a) => {
                  var outNode;

                  if(node_a instanceof math.ConstantNode) {
                    const value = node_a.value.valueOf();
                    if(value > 0) {
                      logger.log("logAPL", "value", value);
                      const arr_mathNode = [...Array(value).keys()].map((i) => {
                        var outNode;
                        
                        const mathNode__i = new math.ConstantNode(i+1);
                        mathNode__i.autoSimplify = true;
                        
                        outNode = mathNode__i;
                        return outNode;
                      });
                      logger.log("logAPL", "arr_mathNode", arr_mathNode);
                      outNode = new MyAPLArrayNode(arr_mathNode);
                    } else {
                      outNode = node_a;  
                    }
                  } else {
                    outNode = node_a;
                  }

                  return outNode;
                };
                
                const transformationFunc__icObj = (icObj) => {
                  var transformationOutput;

                  if(icObj.type == "mathNode") {
                    const mathNode__old = icObj.mathNode;
                    const mathNode__new = transformationFunc__mathNode(mathNode__old); 
                    icObj.mathNode = mathNode__new;
                  }
                  
                  transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  
                  return transformationOutput;
                };
                operatorConfig.transformationFunc = transformationFunc__icObj;

              }
              break;

            case "apl::rho":
              {
                operatorConfig.node__display = new math.SymbolNode("⍴");
                const transformationFunc__mathNode = (node_a) => {
                  var outNode;

                  if(node_a instanceof math.ArrayNode) {
                    outNode = MathUtils.shape__arrayNode(node_a);
                  } else {
                    outNode = new math.ConstantNode(1);
                    outNode.autoSimplify = true;
                  }

                  return outNode;
                };
                
                const transformationFunc__icObj = (icObj) => {
                  var transformationOutput;

                  if(icObj.type == "mathNode") {
                    const mathNode__old = icObj.mathNode;
                    const mathNode__new = transformationFunc__mathNode(mathNode__old); 
                    icObj.mathNode = mathNode__new;
                  }
                  
                  transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  
                  return transformationOutput;
                };
                operatorConfig.transformationFunc = transformationFunc__icObj;

              }
              break;

            case "complex::modulus":
              {
                operatorConfig.node__display = new math.SymbolNode("| |");
                const transformationFunc__mathNode = (node_a) => {
                  var outNode;
                  
                  try {
                    const value_a = node_a.evaluate();

                    var mathNode__inside;
                    if(value_a instanceof math.Complex) {
                      // const value_norm = math.norm(value_a);
                      const value__re = math.re(value_a); 
                      const value__im = math.im(value_a);

                      var mathNode__re = new math.ConstantNode(value__re);
                      if(value__re < 0) {
                        mathNode__re = new math.ParenthesisNode(mathNode__re);
                      }

                      var mathNode__im = new math.ConstantNode(value__im);
                      if(value__im < 0) {
                        mathNode__im = new math.ParenthesisNode(mathNode__im);
                      }

                      mathNode__inside = new math.OperatorNode("+", "add", [
                        new math.OperatorNode("^", "pow", [
                          mathNode__re,
                          new math.ConstantNode(2),
                        ]),
                        new math.OperatorNode("^", "pow", [
                          mathNode__im,
                          new math.ConstantNode(2),
                        ]),
                      ]);

                      if(cfg.simplify) {
                        mathNode__inside = Simplifier.simplify_litexp_2(mathNode__inside);
                      }

                      outNode = new math.FunctionNode(new math.SymbolNode('sqrt'), [
                        mathNode__inside,
                      ]);

                    } else {
                      var mathNode__refined;
                      if(cfg.simplify) {
                        mathNode__refined = Simplifier.simplify_litexp_2(node_a);
                      } else {
                        mathNode__refined = node_a;
                      }
                      if(value_a < 0) {
                        // outNode = new math.OperatorNode("-", "unaryMinus", [mathNode__refined]);
                        outNode = new math.ConstantNode(-value_a);
                      } else {
                        outNode = mathNode__refined;
                      }
                      
                    }
                    
                    outNode.autoSimplify = true;

                  } catch(e) {
                    logger.log("logError", e);
                    outNode = node_a;
                  }

                  return outNode;
                };
                
                const transformationFunc__icObj = (icObj) => {
                  var transformationOutput;

                  if(icObj.type == "mathNode") {
                    const mathNode__old = icObj.mathNode;
                    const mathNode__new = transformationFunc__mathNode(mathNode__old); 
                    icObj.mathNode = mathNode__new;
                  }
                  
                  transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  
                  return transformationOutput;
                };
                operatorConfig.transformationFunc           = transformationFunc__icObj;
                operatorConfig.transformationFunc__mathNode = transformationFunc__mathNode;

              }
              break;

            case "complex::argument":
              {
                operatorConfig.node__display = new math.SymbolNode("arg");
                const transformationFunc__mathNode = (node_a) => {
                  var outNode;
                  
                  try {
                    // const value_a = node_a.evaluate();
                    // logger.log("logComplex", "complex::argument", "value_a:", value_a);
                    // const value_arg = math.arg(value_a);
                    // const str__algebrite_in  = "arg(" + value_a + ")";

                    const str__node_a = node_a.toString();
                    const str__algebrite_in  = "arg(" + str__node_a + ")";

                    logger.log("logComplex", "complex::argument", "str__algebrite_in:", str__algebrite_in);
                    const str__algebrite_out = Algebrite.run(str__algebrite_in);
                    logger.log("logComplex", "complex::argument", "str__algebrite_out:", str__algebrite_out);

                    outNode = math.parse(str__algebrite_out);
                    logger.log("logComplex", "argument:", outNode);
                    outNode.autoSimplify = true;
                  } catch(e) {
                    logger.log("logError", e);
                    outNode = node_a;
                  }

                  return outNode;
                };
                
                const transformationFunc__icObj = (icObj) => {
                  var transformationOutput;

                  if(icObj.type == "mathNode") {
                    const mathNode__old = icObj.mathNode;
                    const mathNode__new = transformationFunc__mathNode(mathNode__old); 
                    icObj.mathNode = mathNode__new;
                  }
                  
                  transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  
                  return transformationOutput;
                };
                operatorConfig.transformationFunc           = transformationFunc__icObj;
                operatorConfig.transformationFunc__mathNode = transformationFunc__mathNode;

              }
              break;

            case "complex::conjugate":
              {
                operatorConfig.node__display = new math.SymbolNode("conj");
                const transformationFunc__mathNode = (node_a) => {
                  var outNode;
                  
                  try {
                    // const value_a = node_a.evaluate();
                    // // const value_conj = math.conj(value_a);
                    // const str__algebrite_in  = "conj(" + value_a + ")";

                    const str__node_a = node_a.toString();
                    const str__algebrite_in  = "conj(" + str__node_a + ")";

                    const str__algebrite_out = Algebrite.run(str__algebrite_in);
                    outNode = math.parse(str__algebrite_out);
                    logger.log("logComplex", "conjugate:", outNode);
                    outNode.autoSimplify = true;
                  } catch(e) {
                    logger.log("logError", e);
                    outNode = node_a;
                  }

                  return outNode;
                };
                
                const transformationFunc__icObj = (icObj) => {
                  var transformationOutput;

                  if(icObj.type == "mathNode") {
                    const mathNode__old = icObj.mathNode;
                    const mathNode__new = transformationFunc__mathNode(mathNode__old); 
                    icObj.mathNode = mathNode__new;
                  }
                  
                  transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  
                  return transformationOutput;
                };
                operatorConfig.transformationFunc           = transformationFunc__icObj;
                operatorConfig.transformationFunc__mathNode = transformationFunc__mathNode;

              }
              break;


            case "simplify":
              {
                operatorConfig.name = "s";
                const transformationFunc = (node_a) => {
                  var outNode;

                  function standardOperation(node_in) {
                    var outNode;

                    const node_unsimplified = node_in;

                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;

                    outNode.autoSimplify = node_in.autoSimplify;

                    return outNode;
                  }

                  if (node_a.isEquation) {
                    console.log("node_a", node_a);
                    const node_left = standardOperation(node_a.params[0]);
                    const node_right = standardOperation(node_a.params[1]);
                    const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    node_equation.isEquation = true;

                    outNode = node_equation;
                  } else {
                    outNode = standardOperation(node_a);
                  }

                  return outNode;
                };
                operatorConfig.transformationFunc = transformationFunc;
              }
              break;
            case "simplify__full":
              {
                operatorConfig.name = "sfull";
                const transformationFunc = (node_a) => {
                  var outNode;

                  function standardOperation(node_in) {
                    var outNode;

                    const node_unsimplified = node_in;

                    const node_simplified = Simplifier.simplify_full(node_unsimplified);
                    outNode = node_simplified;

                    outNode.autoSimplify = node_in.autoSimplify;

                    return outNode;
                  }

                  if (node_a.isEquation) {
                    console.log("node_a", node_a);
                    const node_left = standardOperation(node_a.params[0]);
                    const node_right = standardOperation(node_a.params[1]);
                    const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    node_equation.isEquation = true;

                    outNode = node_equation;
                  } else {
                    outNode = standardOperation(node_a);
                  }

                  return outNode;
                };
                operatorConfig.transformationFunc = transformationFunc;
              }
              break;


            case "simplify__step_by_step":
              {
                operatorConfig.name = "st";
                const transformationFunc = (node_a) => {
                  var outNode;

                  function standardOperation(node_in) {
                    var outNode;

                    if (node_in.type == "OperatorNode") {

                      const depth = getDepth(node_in);

                      if (depth > 2) {
                        console.log("___st A");

                        //'innermost first' simplify

                        const arr_deep_first__treeObj = getArr_deep_first__treeObj(node_in);
                        console.log("arr_deep_first__treeObj", arr_deep_first__treeObj);

                        const arr_deep_first__treeObj__operatorNode = arr_deep_first__treeObj.filter(treeObj => (treeObj.node.type == "OperatorNode"));

                        const treeObj_operatorNode__first_unsimplified = arr_deep_first__treeObj__operatorNode.find(treeObj => !treeObj.node.isSimplified);

                        const node_unsimplified = treeObj_operatorNode__first_unsimplified.node;
                        console.log("node_unsimplified", node_unsimplified);
                        const path__node_unsimplified = treeObj_operatorNode__first_unsimplified.path;

                        const node_simplified = math.simplify(node_unsimplified);
                        node_simplified.isSimplified = true;
                        console.log("node_simplified", node_simplified);

                        const node_mutated = operatorNodeBySettingNodeAtPath(node_in, node_simplified, path__node_unsimplified);

                        outNode = node_mutated;

                      } else {
                        console.log("___st B");

                        //simple simplify

                        const node_unsimplified = node_in;

                        const node_simplified = math.simplify(node_unsimplified);
                        node_simplified.isSimplified = true;

                        outNode = node_simplified;

                      }

                    } else {
                      console.log("___st C");

                      //simple simplify

                      const node_unsimplified = node_in;

                      const node_simplified = math.simplify(node_unsimplified);
                      node_simplified.isSimplified = true;

                      outNode = node_simplified;

                    }

                    outNode.autoSimplify = node_in.autoSimplify;

                    return outNode;
                  }

                  if (node_a.isEquation) {
                    console.log("node_a", node_a);
                    const node_left = standardOperation(node_a.params[0]);
                    const node_right = standardOperation(node_a.params[1]);
                    const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    node_equation.isEquation = true;

                    outNode = node_equation;
                  } else {
                    outNode = standardOperation(node_a);
                  }

                  return outNode;
                };
                operatorConfig.transformationFunc = transformationFunc;
              }
              break;


            case "simplify__top_layer":
              {
                operatorConfig.name = "stl";
                const transformationFunc = (node_a) => {
                  var outNode;

                  // function standardOperation(node_in) {
                  //   var outNode;
                  //
                  //   if(node_in.type == "OperatorNode") {
                  //
                  //     const depth = getDepth(node_in);
                  //
                  //     if(depth > 2) {
                  //       console.log("___st A");
                  //
                  //       //'outermost first' simplify
                  //
                  //       function isTerminalType(mathNode) {
                  //         const type = mathNode.type;
                  //         return ( (type == "ConstantNode") || (type == "SymbolNode") );
                  //       }
                  //
                  //       const operator__layerN          = node_in;
                  //       const arr_child__layerN         = operator__layerN.args;
                  //       const terminal__layerN          = arr_child__layerN.filter(child => isTerminalType(child)).find(e => true);
                  //
                  //       const operator__layerN_minus_1      = arr_child__layerN.filter(child => (child.type == "OperatorNode") ).find(e => true);
                  //       const arr_child__layerN_minus_1     = operator__layerN_minus_1.args;
                  //       // const terminal__layerN_minus_1      = arr_child__layerN_minus_1.filter(child => isTerminalType(child)).find(e => true);
                  //       const arr_terminal__layerN_minus_1  = arr_child__layerN_minus_1.filter(child => isTerminalType(child));
                  //
                  //       function isSameTerminal(termNode1, termNode2) {
                  //         var outBool;
                  //
                  //         function isSameTerminalType(termNode1, termNode2) {
                  //           return (termNode1.type == termNode2.type);
                  //         }
                  //
                  //         const isSameTerminalType_ = isSameTerminalType(termNode1, termNode2);
                  //         console.log("isSameTerminalType_", isSameTerminalType_);
                  //
                  //         if(!isSameTerminalType_) {
                  //           return false;                 //j'aime pas trop ça mais bon...
                  //         }
                  //
                  //         function isSameTerminalContent(termNode1, termNode2) {
                  //           console.log("isSameTerminal", termNode1, termNode2);
                  //           var outBool;
                  //
                  //           switch(termNode1.type) {
                  //             case "SymbolNode":
                  //               outBool = (termNode1.name == termNode2.name);
                  //             break;
                  //             case "ConstantNode":
                  //               outBool = (termNode1.value == termNode2.value);
                  //             break;
                  //             default:
                  //               throw new Error("unsupported type", termNode1.type);
                  //               break;
                  //           }
                  //
                  //           return outBool;
                  //         }
                  //
                  //         outBool = isSameTerminalContent(termNode1, termNode2);
                  //
                  //         return outBool;
                  //       }
                  //
                  //       const sameTerminal = arr_terminal__layerN_minus_1.find(term__layerN_minus_1 => isSameTerminal(terminal__layerN, term__layerN_minus_1));
                  //       if(!sameTerminal) {
                  //         return node_in;
                  //       }
                  //
                  //       function isInverseOperators(opNode1, opNode2) {
                  //         console.log("isInverseOperators", opNode1, opNode2);
                  //         var outBool;
                  //
                  //         const set_opFunc = new Set([opNode1.fn, opNode2.fn]);
                  //         console.log("set_opFunc", set_opFunc);
                  //
                  //         /*Set utils*/
                  //         function eqSet(as, bs) {
                  //             return as.size === bs.size && all(isIn(bs), as);
                  //         }
                  //
                  //         function all(pred, as) {
                  //             for (var a of as) if (!pred(a)) return false;
                  //             return true;
                  //         }
                  //
                  //         function isIn(as) {
                  //             return function (a) {
                  //                 return as.has(a);
                  //             };
                  //         }
                  //         /**/
                  //
                  //
                  //
                  //         const arr_set_inverse = [
                  //           new Set(["multiply", "divide"]),
                  //           new Set(["add", "subtract"]),
                  //         ];
                  //
                  //         outBool = arr_set_inverse.reduce((acc, x) => {
                  //           if(eqSet(set_opFunc, x)) {
                  //             acc = true;
                  //           }
                  //           return acc;
                  //         }, false);
                  //
                  //         return outBool;
                  //       }
                  //
                  //       const isInverseOperators_ = isInverseOperators(operator__layerN_minus_1, operator__layerN);
                  //       console.log("isInverseOperators_", isInverseOperators_);
                  //       if(!isInverseOperators_) {
                  //         return node_in;
                  //       }
                  //
                  //       const node__layerN_minus_2      = arr_child__layerN_minus_1.filter(child => child != sameTerminal).find(e => true);
                  //
                  //       //remove parentheses if any
                  //       // if(node__layerN_minus_2.type == "ParenthesisNode") {
                  //       //   const contentNode = node__layerN_minus_2.content;
                  //       //   outNode = contentNode;
                  //       // } else {
                  //       //   outNode = node__layerN_minus_2;
                  //       // }
                  //
                  //       outNode = node__layerN_minus_2;
                  //
                  //     } else {
                  //       console.log("___st B");
                  //
                  //       //simple simplify
                  //
                  //       const node_unsimplified = node_in;
                  //
                  //       const node_simplified = math.simplify(node_unsimplified);
                  //       node_simplified.isSimplified = true;
                  //
                  //       outNode = node_simplified;
                  //
                  //     }
                  //
                  //   } else {
                  //     console.log("___st C");
                  //     console.log("node_in", node_in);
                  //
                  //     //simple simplify
                  //
                  //     const node_unsimplified = node_in;
                  //
                  //     const node_simplified = math.simplify(node_unsimplified);   //SHU: boom
                  //     node_simplified.isSimplified = true;
                  //
                  //     outNode = node_simplified;
                  //
                  //   }
                  //
                  //   outNode.autoSimplify = node_in.autoSimplify;
                  //
                  //   return outNode;
                  // }

                  const operation = Simplifier.simplify_top_layer;

                  if (node_a.isEquation) {
                    console.log("node_a", node_a);
                    const node_left = operation(node_a.params[0]);
                    const node_right = operation(node_a.params[1]);
                    const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    node_equation.isEquation = true;

                    outNode = node_equation;
                  } else {
                    outNode = operation(node_a);
                  }

                  return outNode;
                };

                const icObjTransformationFunc = (icObj) => {
                  var outIcObj;

                  outIcObj = icObj.clone();

                  // logger.log("icObj.mathNode", icObj.mathNode);
                  outIcObj.mathNode = transformationFunc(icObj.mathNode);

                  return outIcObj;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "simplify__remove_parentheses":
              {
                operatorConfig.name = "srp";
                const transformationFunc = (node_a) => {
                  var outNode;

                  function standardOperation(node_in) {
                    var outNode;

                    if (node_in.type == "ParenthesisNode") {
                      const contentNode = node_in.content;
                      outNode = contentNode;
                    } else {
                      outNode = node_in;
                    }

                    outNode.autoSimplify = node_in.autoSimplify;

                    return outNode;
                  }

                  if (node_a.isEquation) {
                    console.log("node_a", node_a);
                    const node_left = standardOperation(node_a.params[0]);
                    const node_right = standardOperation(node_a.params[1]);
                    const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    node_equation.isEquation = true;

                    outNode = node_equation;
                  } else {
                    outNode = standardOperation(node_a);
                  }

                  return outNode;
                };
                operatorConfig.transformationFunc = transformationFunc;
              }
              break;

            case "simplify:force":
              {
                operatorConfig.name = "simplify";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;

                    const mathNode__in = icObj.mathNode;

                    const mathNode__clone = mathNode__in.cloneDeep();
                    // logger.log("mathNode__clone", mathNode__clone);

                    const value__out = mathNode__clone.evaluate({});
                    // logger.log("value__out", value__out);
                    const mathNode__out = math.parse(value__out);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode__out);
                    icObj__new.isTouchable = true;

                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("old", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "format:toFixed":
              {
                operatorConfig.name = "format:toFixed";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;

                    const mathNode__in = icObj.mathNode;

                    const mathNode__clone = mathNode__in.cloneDeep();
                    // logger.log("mathNode__clone", mathNode__clone);

                    const str__formatted = math.format(mathNode__clone.evaluate({}), { notation: "fixed" });
                    logger.log("str__formatted", str__formatted);
                    const mathNode__out = math.parse(str__formatted);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode__out);
                    icObj__new.isTouchable = true;

                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("old", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;


            case "split__top_layer":
              {
                operatorConfig.name = "sptl";
                const transformationFunc = (node_a) => {
                  var outArr;

                  const operation = Splitter.split_top_layer;

                  if (node_a.isEquation) {
                    // console.log("node_a", node_a);
                    // const node_left     = operation(node_a.params[0]);
                    // const node_right    = operation(node_a.params[1]);
                    // const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    // node_equation.isEquation = true;
                    //
                    // outNode = node_equation;
                    throw new Error("unsupported (yet): split equation");
                  } else {
                    outArr = operation(node_a);
                  }

                  return outArr;
                };

                const icObjTransformationFunc = (icObj) => {

                  logger.log("icObj.mathNode", icObj.mathNode);
                  const arr_mathNodes = transformationFunc(icObj.mathNode);
                  logger.log("arr_mathNodes", arr_mathNodes);

                  const trueRect = {
                    x: icObj.position.x,
                    y: icObj.position.y,
                    width: icObj.size.width,
                    height: icObj.size.height,
                  };

                  const arr_icMathNode = arr_mathNodes.map((mathNode, index) => {
                    const trueRect_part = {
                      x: trueRect.x + index * 100,
                      y: trueRect.y + index * 100,
                      width: trueRect.width,
                      height: trueRect.height,
                    };
                    const icMathNode = infiniteCanvas.createIcMathNode(trueRect_part.x, trueRect_part.y, mathNode);
                    return icMathNode;
                  })

                  const parts = arr_icMathNode;
                  const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
                  const icComposite = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);

                  const icObj__new = icComposite;

                  //debug
                  // const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "new_object");
                  // // const icObj__new = icText;
                  // const parts           = [icText];
                  // const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
                  // const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
                  // const icObj__new = icComposite;


                  // outIcObj = icComposite;
                  // return outIcObj;
                  const transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;


            case "split__full":
              {
                operatorConfig.name = "spf";
                const transformationFunc = (node_a) => {
                  var outArr;

                  const operation = Splitter.split_full;

                  if (node_a.isEquation) {
                    // console.log("node_a", node_a);
                    // const node_left     = operation(node_a.params[0]);
                    // const node_right    = operation(node_a.params[1]);
                    // const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                    // node_equation.isEquation = true;
                    //
                    // outNode = node_equation;
                    throw new Error("unsupported (yet): split equation");
                  } else {
                    outArr = operation(node_a);
                  }

                  return outArr;
                };

                const icObjTransformationFunc = (icObj) => {
                  var outIcObj;

                  logger.log("icObj.mathNode", icObj.mathNode);
                  const arr_mathNodes = transformationFunc(icObj.mathNode);
                  logger.log("arr_mathNodes", arr_mathNodes);

                  const trueRect = {
                    x: icObj.position.x,
                    y: icObj.position.y,
                    width: icObj.size.width,
                    height: icObj.size.height,
                  };

                  const arr_icMathNode = arr_mathNodes.map((mathNode, index) => {
                    const trueRect_part = {
                      x: trueRect.x + index * 100,
                      y: trueRect.y + index * 100,
                      width: trueRect.width,
                      height: trueRect.height,
                    };
                    const icMathNode = infiniteCanvas.createIcMathNode(trueRect_part.x, trueRect_part.y, mathNode);
                    return icMathNode;
                  })

                  const parts = arr_icMathNode;
                  const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
                  const icComposite = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);

                  const icObj__new = icComposite;

                  //debug
                  // const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "new_object");
                  // // const icObj__new = icText;
                  // const parts           = [icText];
                  // const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
                  // const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
                  // const icObj__new = icComposite;


                  // outIcObj = icComposite;
                  // return outIcObj;
                  const transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;


            // case "join__top_layer":
            // {
            //   operatorConfig.name = "sptl";
            //   const transformationFunc = (node_a) => {
            //     var outArr;
            //
            //     const operation = .split_top_layer;
            //
            //     if(node_a.isEquation) {
            //       // console.log("node_a", node_a);
            //       // const node_left     = operation(node_a.params[0]);
            //       // const node_right    = operation(node_a.params[1]);
            //       // const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
            //       // node_equation.isEquation = true;
            //       //
            //       // outNode = node_equation;
            //       throw new Error("unsupported (yet): split equation");
            //     } else {
            //       outArr = operation(node_a);
            //     }
            //
            //     return outArr;
            //   };
            //
            //   const icObjTransformationFunc = (icObj) => {
            //     var outIcObj;
            //
            //     logger.log("icObj.mathNode", icObj.mathNode);
            //     const arr_mathNodes = transformationFunc(icObj.mathNode);
            //     logger.log("arr_mathNodes", arr_mathNodes);
            //
            //     const trueRect = {
            //       x:      icObj.position.x,
            //       y:      icObj.position.y,
            //       width:  icObj.size.width,
            //       height: icObj.size.height,
            //     };
            //
            //     const arr_icMathNode = arr_mathNodes.map((mathNode, index) => {
            //       const trueRect_part = {
            //         x:      trueRect.x + index * 100,
            //         y:      trueRect.y + index * 100,
            //         width:  trueRect.width,
            //         height: trueRect.height,
            //       };
            //       const icMathNode = infiniteCanvas.createIcMathNode(trueRect_part.x, trueRect_part.y, mathNode);
            //       return icMathNode;
            //     })
            //
            //     const parts           = arr_icMathNode;
            //     const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
            //     const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
            //
            //     const icObj__new = icComposite;
            //
            //     //debug
            //     // const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "new_object");
            //     // // const icObj__new = icText;
            //     // const parts           = [icText];
            //     // const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
            //     // const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
            //     // const icObj__new = icComposite;
            //
            //
            //     // outIcObj = icComposite;
            //     // return outIcObj;
            //     const transformationOutput = new TransformationOutput("new", icObj__new, icObj);
            //     return transformationOutput;
            //   };
            //
            //   operatorConfig.transformationFunc = icObjTransformationFunc;
            // }
            // break;



            case "morpher__math_to_text":
              {
                operatorConfig.name = "morph: math→text";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const str = icObj.mathNode.toString();
                    const icObj__new = infiniteCanvas.createIcText(x, y, str);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "morpher__text_to_math":
              {
                operatorConfig.name = "morph: text→math";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "text") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;

                    const mathNode = math.parse(icObj.text);
                    mathNode.autoSimplify = true;

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "decomposition__product_primes":
              {
                operatorConfig.name = "decomp:prpr";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const mathNode = icObj.mathNode;
                    const mathNode_new = Rewriter.decomposition_product_primes(mathNode);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode_new);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "mark__slash_simplifiable":
              {
                operatorConfig.name = "mark:slash";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const mathNode = icObj.mathNode;

                    //SHU741852
                    const analysisOutput = Analyzer.analyze_simplifiable(mathNode);

                    const mathNode__initial = new math.OperatorNode("x", "multiply", []);
                    const mathNode_new = analysisOutput.arr_simplifiable_pair.reduce((acc, x) => {

                      acc.args.push(x);

                    }, mathNode__initial);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode_new);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);

                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;


            case "simplify__fraction":
              {
                operatorConfig.name = "sf";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const mathNode = icObj.mathNode;
                    const mathNode_new = Simplifier.simplify_fraction(mathNode);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode_new);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;


            case "inverse":
              {
                operatorConfig.name = "inverse";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const mathNode = icObj.mathNode;
                    const mathNode_new = Inverser.inverse(mathNode);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode_new);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "singleOperatorize":
              {
                operatorConfig.name = "s:singleOperatorize";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const mathNode = icObj.mathNode;
                    const mathNode_new = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode_new);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "simplify__topPriorityShell":
              {
                operatorConfig.name = "s:tpsh";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const mathNode = icObj.mathNode;
                    const mathNode_new = Simplifier.simplify_top_priorityShell(mathNode);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode_new);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            //math operators

            case "math::plus":
              {
                operatorConfig.name = "+";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "mathNode") {
                    const x = icObj.position.x;
                    const y = icObj.position.y;
                    const mathNode = icObj.mathNode;
                    const mathNode_new = Simplifier.simplify_top_priorityShell(mathNode);

                    const icObj__new = infiniteCanvas.createIcMathNode(x, y, mathNode_new);
                    transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;


            //object transformations

            case "o:clone":
              {
                const nb_clones = cfg.nb_clones;
                // const nb_clones = 2;

                const string__easy = "clone" + "(" + cfg.nb_clones + ")";
                operatorConfig.name = string__easy;

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  logger.log("o:clone");

                  const arr_clone = [...Array(nb_clones).keys()].map((index) => {
                    const icObj_clone = icObj.deepClone();
                    const id__clone = infiniteCanvas.generateIcObjectId();
                    icObj_clone.id = id__clone;

                    icObj_clone.fill = "yellow";
                    const width__icObj = icObj.size.width;
                    const width__spacing = 50;
                    const offset__x = index * (width__icObj + width__spacing);
                    icObj_clone.position.x = icObj.position.x + offset__x;

                    return icObj_clone;
                  });

                  const arr_icObj = [icObj, ...arr_clone];
                  // const arr_icObj = [icObj];
                  // const arr_icObj = arr_clone;
                  logger.log("arr_icObj", arr_icObj);

                  transformationOutput = new TransformationOutput("new", arr_icObj, icObj);

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "o:scale":
              {
                const string__mode_and_operation = cfg.mode + " " + cfg.operation;
                // operatorConfig.name = gmOperatorType + "(" + string__mode_and_operation + ")";
                operatorConfig.name = string__mode_and_operation;

                const string__mode = cfg.mode;
                const string__operation = cfg.operation;

                function createStandardTransformationFunc(string__mode, string__operation) {

                  var outFunc;

                  //create a mathNode operator
                  const arr_components = string__operation.split(" ");
                  const string__opSymbol = arr_components[0];
                  const string__operand = arr_components[1];

                  const value__operand = Number(string__operand);
                  logger.log("value__operand", value__operand);

                  const op = Operator.fromOpString_binary(string__opSymbol);
                  const node_b = new math.ConstantNode(value__operand);
                  // const node_b = math.parse(string__operand);
                  const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

                  outFunc = function (icObj) {
                    var outIcObj;

                    var mathNode__in;
                    switch (string__mode) {
                      case "horiz":
                        mathNode__in = new math.ConstantNode(icObj.scale.X);
                        break;
                      case "vert":
                        mathNode__in = new math.ConstantNode(icObj.scale.Y);
                        break;
                    }

                    const mathNode__out = operatorNodeFuncWrapper.func(mathNode__in);
                    logger.log("mathNode__out", mathNode__out);

                    const value__out = mathNode__out.evaluate({});
                    logger.log("value__out", value__out);



                    const icObj_clone = icObj.deepClone();
                    const id__clone = infiniteCanvas.generateIcObjectId();
                    icObj_clone.id = id__clone;

                    switch (string__mode) {
                      case "horiz":
                        icObj_clone.scale.X = value__out;
                        break;
                      case "vert":
                        icObj_clone.scale.Y = value__out;
                        break;
                    }

                    outIcObj = icObj_clone;    //shu: return functional(my life)

                    return outIcObj;
                  };

                  return outFunc;
                }

                function icObjTransformationFunc(icObj) {
                  var transformationOutput;

                  logger.log("o:scale", "icObjTransformationFunc", "icObj.type", icObj.type);
                  switch (icObj.type) {
                    case "composite":
                      {
                        const arr_entry__part_mutated = Object.entries(icObj.parts).map(([partName, icObj__part]) => {
                          const transformationOutput__part = icObjTransformationFunc(icObj__part);
                          const icObj__part__transformed = transformationOutput__part.value;
                          return [partName, icObj__part__transformed];
                        });

                        const parts__mutated = Object.fromEntries(arr_entry__part_mutated);
                        logger.log("parts__mutated", parts__mutated);


                        // const icObj__new = icObj.deepClone();
                        // icObj__new.parts = parts__mutated;

                        const compositeConfig = Compositer.defaultCompositeConfig(parts__mutated, true);
                        const icComposite__new = infiniteCanvas.createIcComposite(trueRect, parts__mutated, compositeConfig);
                        const icObj__new = icComposite__new;

                        transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                      }
                      break;
                    default:
                      {
                        const opString = gmOperatorType;
                        const stdTransformationFunc = createStandardTransformationFunc(string__mode, string__operation);

                        const icObj__new = stdTransformationFunc(icObj);
                        logger.log("icObj__new", icObj__new);

                        transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                      }
                      // {
                      //   logger.log("icObj.type:", icObj.type);
                      //   transformationOutput = new TransformationOutput("old", icObj, icObj);
                      // }
                      break;

                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "o:ucscale":
              {

              }
              break;

            case "o:ucconvert":
              {

              }
              break;




            //image transformations
            case "i:scale":   //== pxscale (mutate image bitmap)
              {

              }
              break;


            //text transformations
            case "t:append":
              {
                const string__ingredient = cfg.text;

                const string__mode_and_operation = cfg.mode + " " + cfg.operation;
                // operatorConfig.name = gmOperatorType + "(" + string__mode_and_operation + ")";
                operatorConfig.name = "append(" + "\"" + string__ingredient + "\"" + ")";

                function createMutationFunc(string__ingredient) {
                  var outFunc;

                  outFunc = function (icObj) {
                    var outIcObj;

                    outIcObj = icObj;
                    outIcObj.text = outIcObj.text + string__ingredient;

                    return outIcObj;
                  };

                  return outFunc;
                }

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  if (icObj.type == "text") {

                    const mutationFunc = createMutationFunc(string__ingredient);

                    const icObj__mutated = mutationFunc(icObj);
                    logger.log("icObj__mutated", icObj__mutated);

                    transformationOutput = new TransformationOutput("mutated", icObj__mutated, icObj);

                  } else {
                    logger.log("icObj.type:", icObj.type);
                    transformationOutput = new TransformationOutput("old", icObj, icObj);
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;




            //text transformations
            case "comp":
              {
                const string__name = cfg.name;
                operatorConfig.name = string__name;

                const dict_op_part = cfg.parts; //this dict contains Operation instances

                switch (cfg.mode) {
                  case "sequential":
                    {
                      const icObjTransformationFunc = (icObj) => {
                        var transformationOutput;

                        const transformationOutput__identity = new TransformationOutput("old", icObj, icObj);

                        transformationOutput = Object.entries(dict_op_part).reduce((acc, [name__op_part, op_part]) => {
                          var out;

                          const input = acc.value;

                          const transformationOutput__step = op_part.transformationFunc(input);

                          return transformationOutput__step;
                        }, transformationOutput__identity);

                        return transformationOutput;
                      };
                    }
                    break;
                  case "parallel":                  //SHU: for parallel operations, we need to promisify all this
                    throw new Error("parallel operations not supported yet");
                    break;
                }

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;



            //composite-munching
            case "c:objectAtIndex":
              {
                const index = cfg.index;

                operatorConfig.name = gmOperatorType + "(" + index + ")";

                function icObjTransformationFunc(icObj) {
                  logger.log("c:objectAtIndex", icObj);
                  var transformationOutput;

                  switch (icObj.type) {
                    case "composite":
                      {
                        const arr_part = Object.values(icObj.parts);
                        const icObj__new = arr_part[index];

                        transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                      }
                      break;
                    default:
                      //do nothing
                      transformationOutput = new TransformationOutput("old", icObj, icObj);
                      break;
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            // case "c:map:1":
            // {
            //   operatorConfig.name = "c:map:" + "" + 1 + "";
            //
            //   function icObjTransformationFunc(icObj) {
            //     logger.log("c:map:1", icObj);
            //     var transformationOutput;
            //
            //     switch(icObj.type) {
            //       case "composite":
            //         {
            //           const arr_part      = Object.values(icObj.parts);
            //           const arr_part__new = arr_part.map(icObj__part => {
            //             var outIcObj;
            //
            //             switch(icObj__part.type) {
            //               case "mathNode":
            //               {
            //                 const mathNode__new   = new math.ConstantNode(1);
            //                 const icMathNode__new = infiniteCanvas.createIcMathNode(icObj__part.position.x, icObj__part.position.y, mathNode__new);
            //                 outIcObj = icMathNode__new;
            //               }
            //               break;
            //               default:
            //                 //do nothing
            //                 outIcObj = icObj;
            //               break;
            //             }
            //
            //             return outIcObj;
            //           });
            //
            //
            //           //create new collection
            //           const arr_entries = arr_part__new.map((icObj__part__new, index) => {
            //             const name__element = "part_" + index;
            //             return [name__element, icObj__part__new];
            //           });
            //
            //           const parts = Object.fromEntries(arr_entries);
            //
            //           const compositeConfig = Object.entries(parts).reduce((acc, [partName, part], index) => {
            //             // const isMobile = (index != 0);
            //             const isMobile = true;
            //
            //             // acc[partName] = {
            //             acc[part.id] = {
            //               isMobile: isMobile,
            //             };
            //             return acc;
            //           }, {});
            //
            //           const icObj__new = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
            //
            //           icComposite.isCollection = true;
            //           icComposite.isTouchable  = true;
            //
            //           transformationOutput = new TransformationOutput("new", icObj__new, icObj);
            //         }
            //         break;
            //       default:
            //         //do nothing
            //         transformationOutput = new TransformationOutput("old", icObj, icObj);
            //         break;
            //     }
            //
            //     return transformationOutput;
            //   };
            //
            //   operatorConfig.transformationFunc = icObjTransformationFunc;
            // }
            // break;

            case "c:map:":
              {
                const operatorString = cfg.operatorString;
                operatorConfig.name = "c:map:" + operatorString;

                function icObjTransformationFunc(icObj) {
                  logger.log(operatorConfig.name, icObj);
                  var transformationOutput;

                  switch (icObj.type) {
                    case "composite":
                      {
                        const arr_part = Object.values(icObj.parts);
                        const arr_part__new = arr_part.map(icObj__part => {
                          var outIcObj;

                          switch (icObj__part.type) {
                            case "mathNode":
                              {
                                const transformationFunc__inner = (new GMOperatorTextChangeEngine()).transformationFuncForText(operatorString);
                                logger.log("transformationFunc__inner", transformationFunc__inner);
                                logger.log("icObj__part", icObj__part);

                                // const operatorConfig__inner     = operatorConfigForType("inverse");
                                // const transformationFunc__inner = operatorConfig__inner.transformationFunc;
                                // const operation__inner = new Operation(transformationFunc__inner);

                                const transformationOutput__inner = transformationFunc__inner(icObj__part);
                                logger.log("transformationOutput__inner", transformationOutput__inner);

                                const icObj__part__new = transformationOutput__inner.value;
                                outIcObj = icObj__part__new;
                              }
                              break;
                            default:
                              //do nothing
                              outIcObj = icObj__part;
                              break;
                          }

                          return outIcObj;
                        });


                        //create new collection
                        const arr_entries = arr_part__new.map((icObj__part__new, index) => {
                          const name__element = "part_" + index;
                          return [name__element, icObj__part__new];
                        });

                        const parts = Object.fromEntries(arr_entries);

                        const compositeConfig = Object.entries(parts).reduce((acc, [partName, part], index) => {
                          // const isMobile = (index != 0);
                          const isMobile = true;

                          // acc[partName] = {
                          acc[part.id] = {
                            isMobile: isMobile,
                          };
                          return acc;
                        }, {});

                        const icObj__new = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);

                        icComposite.isCollection = true;
                        icComposite.isTouchable = true;

                        transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                      }
                      break;
                    default:
                      //do nothing
                      transformationOutput = new TransformationOutput("old", icObj, icObj);
                      break;
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;


            //composite creation
            case "vessel":
              {
                const rgbaString__vessel = cfg.rgbaString;

                operatorConfig.name = "vessel";

                const icObjTransformationFunc = async function (icObj) {
                  var transformationOutput;

                  logger.log("[vessel]");
                  //create vessel
                  const trueRect__icObj = {
                    x: icObj.position.x,
                    y: icObj.position.y,
                    width: icObj.size.width,
                    height: icObj.size.height,
                  };
                  const icVessel = infiniteCanvas.createIcVessel(trueRect__icObj);
                  if (rgbaString__vessel != null) {
                    icVessel.fill = rgbaString__vessel;
                  }

                  transformationOutput = await infiniteCanvas.addIcObject_p(icVessel)
                    .then(rep_free__vessel => {

                      //add icObj to vessel
                      rep_free__vessel.dict_engine["composite"].engine.awoken.addPart(icObj, false);

                      return rep_free__vessel;
                    })
                    .then(rep_free__vessel => {
                      const transformationOutput = new TransformationOutput("new", rep_free__vessel, icObj);
                      return transformationOutput;
                    });

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "unvessel":
              {
                operatorConfig.name = "unvessel";

                const icObjTransformationFunc = (icObj) => {
                  var transformationOutput;

                  logger.log("[unvessel]");

                  // const rep_free__vessel = infiniteCanvas.get;

                  //remove parts from vessel
                  // rep_free__vessel.engine.awoken.removePart(icObj);

                  transformationOutput = new TransformationOutput("new", arr_icObj, icObj);

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;



            //randomness

            case "random":
              {
                operatorConfig.name = gmOperatorType;

                function icObjTransformationFunc(icObj) {
                  logger.log("random", icObj);
                  var transformationOutput;

                  const mathNode = new math.ConstantNode(0);
                  const value__random = Math.random();
                  mathNode.value = value__random;

                  const trueRect__icObj = {
                    x: icObj.position.x,
                    y: icObj.position.y,
                    width: icObj.size.width,
                    height: icObj.size.height,
                  };
                  const icMathNode = infiniteCanvas.createIcMathNode(trueRect__icObj.x, trueRect__icObj.y, mathNode);

                  transformationOutput = new TransformationOutput("new", icMathNode, icObj);

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "rand_int":
              {
                const int__min = cfg.min;
                const int__max = cfg.max;

                operatorConfig.name = gmOperatorType + "(" + int__min + "," + int__max + ")";

                function icObjTransformationFunc(icObj) {
                  logger.log("rand_int", icObj);
                  var transformationOutput;

                  const mathNode = new math.ConstantNode(0);
                  const value__random = Math.floor(Math.random() * (int__max - int__min)) + int__min;
                  mathNode.value = value__random;

                  const trueRect__icObj = {
                    x: icObj.position.x,
                    y: icObj.position.y,
                    width: icObj.size.width,
                    height: icObj.size.height,
                  };
                  const icMathNode = infiniteCanvas.createIcMathNode(trueRect__icObj.x, trueRect__icObj.y, mathNode);

                  transformationOutput = new TransformationOutput("new", icMathNode, icObj);

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "rand_inArr":
              {
                const arr_value = cfg.arr_value;

                operatorConfig.name = gmOperatorType + "([" + arr_value.join(",") + "])";

                function icObjTransformationFunc(icObj) {
                  logger.log("rand_inArr", icObj);
                  var transformationOutput;

                  const mathNode = new math.ConstantNode(0);
                  const value__random = Utils.randomElementInArray(arr_value);
                  mathNode.value = value__random;

                  const trueRect__icObj = {
                    x: icObj.position.x,
                    y: icObj.position.y,
                    width: icObj.size.width,
                    height: icObj.size.height,
                  };
                  const icMathNode = infiniteCanvas.createIcMathNode(trueRect__icObj.x, trueRect__icObj.y, mathNode);

                  transformationOutput = new TransformationOutput("new", icMathNode, icObj);

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;

            case "rand_inBag":
              {
                operatorConfig.name = gmOperatorType;

                function icObjTransformationFunc(icObj) {
                  logger.log("rand_inBag", icObj);
                  var transformationOutput;

                  switch (icObj.type) {
                    case "composite":
                      {
                        const arr_part = Object.values(icObj.parts);
                        const icObj__picked = Utils.randomElementInArray(arr_part);

                        const icObj__new = icObj__picked.deepClone();

                        transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                      }
                      break;
                    default:
                      //do nothing
                      transformationOutput = new TransformationOutput("old", icObj, icObj);
                      break;
                  }

                  return transformationOutput;
                };

                operatorConfig.transformationFunc = icObjTransformationFunc;
              }
              break;



              case "spawner":
                {
                  const nb_spawn = 1;
  
                  const string__easy  = "spawn" + "(" + cfg.str__spawned + ")";
                  operatorConfig.name = string__easy;

                  operatorConfig.icObj_sample = cfg.icObj_sample;

                  function create_clone(icObj_sample) {
                    const icObj_clone = icObj_sample.deepClone();
                    const id__clone   = infiniteCanvas.generateIcObjectId();
                    icObj_clone.id    = id__clone;

                    // icObj_clone.fill = "yellow";
                    icObj_clone.fill = ColorUtils.randomColor();

                    // const width__icObj = icObj_sample.size.width;
                    // const width__spacing = icObj_sample.size.width / 2;
                    // const offset__x = index * (width__icObj + width__spacing);
                    // icObj_clone.position.x = icObj.position.x + offset__x;

                    return icObj_clone;
                  }
                  operatorConfig.create_clone = create_clone;
  
                  const icObjTransformationFunc = (icObj) => {
                    var transformationOutput;
  
                    logger.log("spawner");

                    const icObj_sample = operatorConfig.icObj_sample;
                    //create clone
                    const icObj_clone  = operatorConfig.create_clone(icObj_sample);
                    //set clone position
                    icObj_clone.position = Object.assign({}, infiniteCanvas.getTrueCursor()); //SHU: operator.position would be better
                    //set clone homeScale
                    icObj_clone.homeScale = Object.assign({}, infiniteCanvas.scale);          //SHU: operator.homeScale would be better
                    
                    //add clone to iC
                    // infiniteCanvas.addIcObject(icObj_clone);
                    infiniteCanvas.addNewIcObject(icObj_clone);


  
                    //incoming icObj is left unchanged
                    transformationOutput = new TransformationOutput("old", icObj, icObj);
  
                    return transformationOutput;
                  };
  
                  operatorConfig.transformationFunc = icObjTransformationFunc;
                }
                break;



          }

          return operatorConfig;
        }


        const operatorConfig = operatorConfigForType(gmOperatorType);

        return operatorConfig;
      }








      createIcGMOperator_editable(trueRect, text_in) {
        console.log("createIcGMOperator", trueRect, text_in);

        const transformationFunc = (new GMOperatorTextChangeEngine()).transformationFuncForText(text_in);

        const operatorConfig = {
          name: text_in,
          transformationFunc: transformationFunc,
        };

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";

        const text = operatorConfig.name;
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isTouchable     = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_operator";

        // icComposite.isTouchable = false;


        const engineCarrier = icComposite;
        const engine = new GMOperatorTextChangeEngine();
        const eType = "gmOperator_editable";

        const icEngined = infiniteCanvas.installEngineOnIcObj(engineCarrier, eType, engine);


        return icEngined;
      }




      createIcGMTargetSlot(trueRect) {
        console.log("createIcGMTargetSlot", trueRect);

        const targetValue = -48;

        const text = targetValue.toString(10);
        const backade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        backade.backgroundColor = "grey";
        backade.isMobile = false;
        // backade.isTouchable = false;

        const canSnapFunc = (above, below) => {
          var outBool;

          const canSnapFunc_geometryWise = (above, below) => {
            // return Snap.canSnap(above, below);
            return Snap.canSnap_noSize(above, below);
          };

          // const canSnapFunc_valueWise    = (above, below) => (above.value == targetValue);
          const canSnapFunc_valueWise = (above, below) => {
            const value = parseInt(above.text, 10);
            const isValueValid = (value == targetValue);
            return isValueValid;
          };

          const canSnapFuncs = {
            "geometry": canSnapFunc_geometryWise,
            "value": canSnapFunc_valueWise,
          };

          const canSnapFunc_allWise = (above, below) => Object.entries(canSnapFuncs).reduce((acc, [canSnapFunc_xWiseName, canSnapFunc_xWise]) => {
            const canSnap_xWise = canSnapFunc_xWise(above, below);
            console.log("canSnap_xWise", canSnapFunc_xWiseName, canSnap_xWise);
            return acc && canSnap_xWise;
          }, true);

          const canSnap_allWise = canSnapFunc_allWise(above, below);
          console.log("canSnap_allWise", canSnap_allWise);

          outBool = canSnap_allWise;

          return outBool;
        };
        const canUnsnapFunc = (above, below) => {
          return Snap.canUnsnap(above, below);
        };
        // const snapMutationFunc  = (above, below) => {   //SHU TODO: toSnapState mutations: toPresnapped, toSnapped, toUnsnapped
        //   //how rep_snapped  will differ from rep_official
        //   //how snappedState will differ from rep_official
        // };
        const snapSlotConfig = {
          canSnapFunc: canSnapFunc,
          canUnsnapFunc: canUnsnapFunc,
        };

        const snapSlot = infiniteCanvas.createIcSnapSlot(trueRect, snapSlotConfig);
        snapSlot.fill = "";
        snapSlot.isMobile = false;


        const parts = {
          "backade": backade,
          "snapSlot": snapSlot,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_targetSlot";

        // icComposite.isTouchable = false;


        return icComposite;
      }


      createIcGMTargetTouchSlot(trueRect, cfg_in) {
        console.log("createIcGMTargetTouchSlot", trueRect);

        var cfg = cfg_in;
        if (cfg == null) {
          cfg = {
            targetValue: - 48,
            isEnabled:   true,
          };
        }


        const canTouchFunc_geometryWise = (above, below, context) => {
          // const canTouchFunc = Touch.canTouch;

          const touch2Singleton = Touch2Singleton.sharedInstance();
          const canTouchFunc = touch2Singleton.canTouch.bind(touch2Singleton);

          return canTouchFunc(above, below);
        };

        // const canTouchFunc_valueWise = (above, below) => {
        //   const value = parseInt(above.text,10);
        //   const isValueValid = (value == targetValue);
        //   return isValueValid;
        // };

        const canTouchFunc_valueWise = (above, below, context) => {
          logger.log("canTouchFunc_valueWise", above, below, context);
          var outBool;

          // const touchSlot = below;
          const facade = context.facade;

          var mathNode__above;
          // const mathNode__above = above.mathNode;
          // const mathNode__above = above.parts.facade.mathNode;
          if (above.mathNode != null) {
            mathNode__above = above.mathNode;
          } else if (above.parts.facade.mathNode != null) {
            mathNode__above = above.parts.facade.mathNode;
          } else {
            throw new Error("unsupported situation: canTouchFunc_valueWise");
          }
          logger.log("mathNode__above", mathNode__above);
          // logger.log("mathNode__above.value", mathNode__above.value);

          const mathNode__below = facade.mathNode;
          logger.log("mathNode__below", mathNode__below);
          // logger.log("mathNode__below.value", mathNode__below.value);


          function isSameValue(mathNode_1, mathNode_2) {
            var outBool;

            function isContainingSymbolNode(mathNode) {
              var outBool;

              switch (mathNode.type) {
                case "OperatorNode":
                  {
                    const operatorNode = mathNode;
                    const arr_child = operatorNode.args;
                    outBool = Utils.early_break_reduce(arr_child, (acc, x, i, arr) => {
                      // logger.log("early_break_reduce", x.x);

                      const isChildContainingSymbolNode = isContainingSymbolNode(x);

                      return acc || isChildContainingSymbolNode;
                    }, true, (acc, x, i, arr) => {
                      return (acc == true);
                    });
                  }
                  break;
                case "RelationalNode":
                  {
                    const operatorNode = mathNode;
                    const arr_child = operatorNode.params;
                    outBool = Utils.early_break_reduce(arr_child, (acc, x, i, arr) => {
                      // logger.log("early_break_reduce", x.x);

                      const isChildContainingSymbolNode = isContainingSymbolNode(x);

                      return acc || isChildContainingSymbolNode;
                    }, true, (acc, x, i, arr) => {
                      return (acc == true);
                    });
                  }
                  break;
                case "ParenthesisNode":
                  const parenthesisNode = mathNode;
                  outBool = isContainingSymbolNode(parenthesisNode.content);
                  break;
                case "SymbolNode":
                  outBool = true;
                  break;
                default:
                  outBool = false;
                  break;
              }

              return outBool;
            }

            const isSymbolNode_in_either = isContainingSymbolNode(mathNode_1) || isContainingSymbolNode(mathNode_2);
            if (isSymbolNode_in_either) {

              function evaluateMathNode(mathNode, dict_subst) {
                return mathNode.evaluate(dict_subst);
              }

              function evaluation_grid(mathNode_1, mathNode_2) {
                var outBool;

                const arr_dict_subst = [
                  {
                    x: 0,
                  },
                  {
                    x: 1,
                  },
                  {
                    x: -1,
                  },
                ];

                //early break reduce
                outBool = Utils.early_break_reduce(arr_dict_subst, (acc, x, i, arr) => {
                  // logger.log("early_break_reduce", x.x);

                  const ev_1 = evaluateMathNode(mathNode_1, x);
                  const ev_2 = evaluateMathNode(mathNode_2, x);

                  const isEqual_ev = (ev_1 == ev_2);

                  return acc && isEqual_ev;
                }, true, (acc, x, i, arr) => {
                  return (acc == false);
                });

                return outBool;
              }

              outBool = evaluation_grid(mathNode_1, mathNode_2);
              if (outBool) {
                return outBool;
              }



              var expr__mathNode_1 = mathNode_1.toString();
              expr__mathNode_1 = expr__mathNode_1.replaceAll("×", "*");
              var expr__mathNode_2 = mathNode_2.toString();
              expr__mathNode_2 = expr__mathNode_2.replaceAll("×", "*");

              const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
              const algebrite_result = Algebrite.run(expr__equality);

              outBool = (algebrite_result == true);

            } else {

              const relationalNode = new math.RelationalNode(['equal'], [mathNode__above, mathNode__below]);
              // logger.log("relationalNode", relationalNode);

              outBool = relationalNode.evaluate();
            }

            return outBool;
          }


          const isSameValue_ = isSameValue(mathNode__above, mathNode__below);
          console.log("isSameValue_", isSameValue_);


          outBool = isSameValue_;

          return outBool;
        };


        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value":    canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above, below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;

        const transformationFunc = (icObj) => {
          var outIcObj;

          console.log("yey");

          outIcObj = icObj.clone();

          outIcObj.fill = "yellow";
          outIcObj.color = "white";

          // outIcObj.im_dying_now = true;


          // icObj.text = "touched";
          // icObj.text += " : yey!";

          // icObj.mathNode = icObj.mathNode;            //SHU: oh my god.  "Ok."
          // icObj.mathNode = new math.ConstantNode("Super!");


          return outIcObj;
        };

        const touchSlotConfig = {
          canTouchFunc: canTouchFunc,
          transformationFunc: transformationFunc,
          context: {},
          isEnabled: (cfg.isEnabled != null) ? cfg.isEnabled : true,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";


        // const text             = targetValue.toString(10);
        // const facade           = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        // facade.backgroundColor = "orange";
        // facade.isTouchable     = false;


        const targetValue = cfg.targetValue;

        var mathNode;
        if (targetValue instanceof math.Node) {
          mathNode = targetValue;
        } else {
          mathNode = new math.ConstantNode(targetValue);
        }
        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        // facade.backgroundColor = "orange";
        // facade.isTouchable     = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade":    facade,
        };


        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_targetTouchSlot";

        // icComposite.isTouchable = false;


        //enrich touchSlotConfig.context
        infiniteCanvas.onceOnAddRepresentedForIcObject(facade, (facade) => {
          const facade__represented = infiniteCanvas.getRepresented(facade.id);
          // const facade__rep_free     = facade__represented.r_free();
          const facade__rep_official = facade__represented.r_official();

          touchSlotConfig.context.facade = facade__rep_official;
        });


        /*
        // const touchSlotEngine = touchSlot.engine;
        // console.log("touchSlot", touchSlot);
        // Hooker.installHooks(touchSlotEngine, "touch");
        // touchSlotEngine.did["touch"].on((...args) => {
        //   console.log("did touch", ...args);
        //
        //   infiniteCanvas.addNewCircle();
        // });
        infiniteCanvas.onceOnAddRepresentedForIcObject(touchSlot, (touchSlot) => {
          const touchSlot__represented  = infiniteCanvas.getRepresented(touchSlot.id);
          const touchSlot__rep_free     = touchSlot__represented.r_free();

          const touchSlotEngine = touchSlot__rep_free.engine;
          // Hooker.installHooks(touchSlotEngine, "touch");
          // touchSlotEngine.did["touch"].on((...args) => {

          Hooker.installHooks(touchSlotEngine.awoken, "touch");
          touchSlotEngine.awoken.did["touch"].on((...args) => {
            console.log("did touch", ...args);

            infiniteCanvas.addNewCircle();

            const context = touchSlot__rep_free.touchSlotConfig.context;
            const facade__rep_official  = context.facade;                 //SHU: this is context so it is official rep

            const facade__represented = facade__rep_official.represented;
            const facade__rep_free    = facade__represented.r_free();

            // facade__rep_free.text = "Super!";
            // facade__rep_free.mathNode = new math.ConstantNode("Super!");
            facade__rep_free.mathNode = new math.ConstantNode(10000000);

            facade__rep_free.fill     = "darkblue";
            facade__rep_free.stroke   = "yellow";

            //debug
            facade__rep_free.position = {
              x: facade__rep_free.position.x + 100,
              y: facade__rep_free.position.y - 50,
            };

          });
        });
        */

        return icComposite;
      }

      createIcGMEqTargetTouchSlot(trueRect, mathNode__core, mathNode__facade, cfg_in) {
        console.log("createIcGMTargetTouchSlot", trueRect);

        var cfg = cfg_in;
        if (cfg == null) {
          cfg = {
            isEnabled:   true,
          };
        }

        const canTouchFunc_geometryWise = (above, below, context) => {
          // const canTouchFunc = Touch.canTouch;

          const touch2Singleton = Touch2Singleton.sharedInstance();
          const canTouchFunc    = touch2Singleton.canTouch.bind(touch2Singleton);

          return canTouchFunc(above, below);
        };

        const canTouchFunc_valueWise = (above, below, context) => {
          logger.log("canTouchFunc_valueWise", above, below, context);
          var outBool;


          var mathNode__above;
          // const mathNode__above = above.mathNode;
          // const mathNode__above = above.parts.facade.mathNode;
          if (above.mathNode != null) {
            mathNode__above = above.mathNode;
          } else if (above.parts.facade.mathNode != null) {
            mathNode__above = above.parts.facade.mathNode;
          } else {
            throw new Error("unsupported situation: canTouchFunc_valueWise");
          }
          logger.log("mathNode__above", mathNode__above);
          // logger.log("mathNode__above.value", mathNode__above.value);



          // const touchSlot = below;
          // const facade    = context.facade;
          const core = context.core;
          // logger.log("core", core);

          const mathNode__below = core.mathNode;
          logger.log("mathNode__below", mathNode__below);
          // logger.log("mathNode__below.value", mathNode__below.value);


          function isSameValue(mathNode_1, mathNode_2) {
            var outBool;

            function isContainingSymbolNode(mathNode) {
              var outBool;

              switch (mathNode.type) {
                case "OperatorNode":
                  {
                    const operatorNode = mathNode;
                    const arr_child = operatorNode.args;
                    outBool = Utils.early_break_reduce(arr_child, (acc, x, i, arr) => {
                      // logger.log("early_break_reduce", x.x);

                      const isChildContainingSymbolNode = isContainingSymbolNode(x);

                      return acc || isChildContainingSymbolNode;
                    }, true, (acc, x, i, arr) => {
                      return (acc == true);
                    });
                  }
                  break;
                case "RelationalNode":
                  {
                    const operatorNode = mathNode;
                    const arr_child = operatorNode.params;
                    outBool = Utils.early_break_reduce(arr_child, (acc, x, i, arr) => {
                      // logger.log("early_break_reduce", x.x);

                      const isChildContainingSymbolNode = isContainingSymbolNode(x);

                      return acc || isChildContainingSymbolNode;
                    }, true, (acc, x, i, arr) => {
                      return (acc == true);
                    });
                  }
                  break;
                case "ParenthesisNode":
                  const parenthesisNode = mathNode;
                  outBool = isContainingSymbolNode(parenthesisNode.content);
                  break;
                case "SymbolNode":
                  outBool = true;
                  break;
                default:
                  outBool = false;
                  break;
              }

              return outBool;
            }

            const isSymbolNode_in_either = isContainingSymbolNode(mathNode_1) || isContainingSymbolNode(mathNode_2);
            if (isSymbolNode_in_either) {

              function evaluateMathNode(mathNode, dict_subst) {
                return mathNode.evaluate(dict_subst);
              }

              function evaluation_grid(mathNode_1, mathNode_2) {
                var outBool;

                const arr_dict_subst = [
                  {
                    x: 0,
                  },
                  {
                    x: 1,
                  },
                  {
                    x: -1,
                  },
                ];

                //early break reduce
                outBool = Utils.early_break_reduce(arr_dict_subst, (acc, x, i, arr) => {
                  // logger.log("early_break_reduce", x.x);

                  const ev_1 = evaluateMathNode(mathNode_1, x);
                  const ev_2 = evaluateMathNode(mathNode_2, x);

                  const isEqual_ev = (ev_1 == ev_2);

                  return acc && isEqual_ev;
                }, true, (acc, x, i, arr) => {
                  return (acc == false);
                });

                return outBool;
              }

              outBool = evaluation_grid(mathNode_1, mathNode_2);
              if (outBool) {
                return outBool;
              }



              var expr__mathNode_1 = mathNode_1.toString();
              expr__mathNode_1 = expr__mathNode_1.replaceAll("×", "*");
              var expr__mathNode_2 = mathNode_2.toString();
              expr__mathNode_2 = expr__mathNode_2.replaceAll("×", "*");

              const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
              const algebrite_result = Algebrite.run(expr__equality);

              outBool = (algebrite_result == true);

            } else {

              const relationalNode = new math.RelationalNode(['equal'], [mathNode__above, mathNode__below]);
              // logger.log("relationalNode", relationalNode);

              outBool = relationalNode.evaluate();
            }

            return outBool;
          }


          const isSameValue_ = isSameValue(mathNode__above, mathNode__below);
          console.log("isSameValue_", isSameValue_);


          outBool = isSameValue_;

          return outBool;
        };


        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value": canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above, below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;

        const transformationFunc = (icObj) => {
          var outIcObj;

          console.log("yey");

          outIcObj = icObj.clone();

          outIcObj.fill = "yellow";
          outIcObj.color = "white";

          // outIcObj.im_dying_now = true;


          // icObj.text = "touched";
          // icObj.text += " : yey!";

          // icObj.mathNode = icObj.mathNode;            //SHU: oh my god.  "Ok."
          // icObj.mathNode = new math.ConstantNode("Super!");


          return outIcObj;
        };

        const touchSlotConfig = {
          canTouchFunc: canTouchFunc,
          transformationFunc: transformationFunc,
          context: {},
          isEnabled: (cfg.isEnabled != null) ? cfg.isEnabled : true,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";



        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode__facade);
        facade.backgroundColor = "orange";
        // facade.isTouchable     = false;

        const core = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode__core);
        core.opacity = 0;
        core.backgroundColor = "orange";
        core.isTouchable = false;

        const parts = {
          "core": core,
          "touchSlot": touchSlot,
          "facade": facade,
        };


        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_eq_targetTouchSlot";

        // icComposite.isTouchable = false;


        //enrich touchSlotConfig.context
        infiniteCanvas.onceOnAddRepresentedForIcObject(facade, (facade) => {
          const facade__represented = infiniteCanvas.getRepresented(facade.id);
          // const facade__rep_free     = facade__represented.r_free();
          const facade__rep_official = facade__represented.r_official();

          touchSlotConfig.context.facade = facade__rep_official;
        });

        return icComposite;
      }


      createIcGMBoxTargetTouchSlot(trueRect, targetMathNode) {
        console.log("createIcGMBoxTargetTouchSlot", trueRect, targetMathNode);


        const canTouchFunc_geometryWise = (above, below, context) => {
          // logger.log("canTouchFunc_geometryWise", above);

          // if(above.parts != null && above.parts.contactArea != null) {
          const contactArea = above.parts.contactArea;
          // const canTouchFunc = Touch.canTouch;

          const touch2Singleton = Touch2Singleton.sharedInstance();
          const canTouchFunc = touch2Singleton.canTouch.bind(touch2Singleton);

          return canTouchFunc(above, below);
        };

        const canTouchFunc_valueWise = (above, below, context) => {
          // logger.log("canTouchFunc_valueWise", above, below, context);
          var outBool;

          // const touchSlot = below;
          const facade = context.facade;

          const mathNode__above = above.parts.facade.mathNode;
          console.log("mathNode__above", mathNode__above);
          const mathNode__below = facade.mathNode;
          console.log("mathNode__below", mathNode__below);

          function isSameValue(mathNode_1, mathNode_2) {
            var outBool;

            function isContainingSymbolNode(mathNode) {
              var outBool;

              const arr_symbolNode = mathNode.filter(function (node) { return node.isSymbolNode; });

              outBool = (arr_symbolNode.length > 0);

              return outBool;
            }

            const isSymbolNode_in_either = isContainingSymbolNode(mathNode_1) || isContainingSymbolNode(mathNode_2);
            if (isSymbolNode_in_either) {

              function evaluateMathNode(mathNode, dict_subst) {
                return mathNode.evaluate(dict_subst);
              }

              function evaluation_grid(mathNode_1, mathNode_2) {
                var outBool;

                const arr_dict_subst = [
                  {
                    x: 0,
                  },
                  {
                    x: 1,
                  },
                  {
                    x: -1,
                  },
                ];

                //early break reduce
                outBool = Utils.early_break_reduce(arr_test, (acc, x, i, arr) => {
                  // logger.log("early_break_reduce", x.x);

                  const ev_1 = evaluateMathNode(mathNode_1, x);
                  const ev_2 = evaluateMathNode(mathNode_2, x);

                  const isEqual_ev = (ev_1 == ev_2);

                  return acc && isEqual_ev;
                }, true, (acc, x, i, arr) => {
                  return (acc == false);
                });

                return outBool;
              }

              outBool = evaluation_grid(mathNode_1, mathNode_2);
              if (outBool) {
                return outBool;
              }



              var expr__mathNode_1 = mathNode_1.toString();
              expr__mathNode_1 = expr__mathNode_1.replaceAll("×", "*");
              var expr__mathNode_2 = mathNode_2.toString();
              expr__mathNode_2 = expr__mathNode_2.replaceAll("×", "*");

              const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
              const algebrite_result = Algebrite.run(expr__equality);

              outBool = (algebrite_result == true);

            } else {

              const relationalNode = new math.RelationalNode(['equal'], [mathNode__above, mathNode__below]);
              // logger.log("relationalNode", relationalNode);

              outBool = relationalNode.evaluate();
            }

            return outBool;
          }


          const isSameValue_ = isSameValue(mathNode__above, mathNode__below);
          console.log("isSameValue_", isSameValue_);


          outBool = isSameValue_;

          return outBool;
        };


        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value": canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above, below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;

        const transformationFunc = (icObj) => {
          var outIcObj;

          logger.log("icGMBox original transformation func");

          return outIcObj;
        };

        const touchSlotConfig = {
          canTouchFunc: canTouchFunc,
          transformationFunc: transformationFunc,
          context: {},
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";



        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, targetMathNode);
        // facade.backgroundColor = "orange";
        // facade.isTouchable     = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,
        };


        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_boxTargetTouchSlot";

        // icComposite.isTouchable = false;


        //enrich touchSlotConfig.context
        infiniteCanvas.onceOnAddRepresentedForIcObject(facade, (facade) => {
          const facade__represented = infiniteCanvas.getRepresented(facade.id);
          // const facade__rep_free     = facade__represented.r_free();
          const facade__rep_official = facade__represented.r_official();

          touchSlotConfig.context.facade = facade__rep_official;
        });

        return icComposite;
      }


      createIcGMBlob(trueRect, targetMathNode) {
        console.log("createIcGMBlob", trueRect, targetMathNode);

        const canTouchFunc_geometryWise = (above, below, context) => {
          const contactArea = above.parts.contactArea;
          // const canTouchFunc = Touch.canTouch;

          const touch2Singleton = Touch2Singleton.sharedInstance();
          const canTouchFunc = touch2Singleton.canTouch.bind(touch2Singleton);

          return canTouchFunc(above, below);
        };

        const canTouchFunc_valueWise = (above, below, context) => {
          // logger.log("canTouchFunc_valueWise", above, below, context);
          var outBool;

          // const touchSlot = below;
          const facade = context.facade;

          const mathNode__above = above.parts.facade.mathNode;
          console.log("mathNode__above", mathNode__above);
          const mathNode__below = facade.mathNode;
          console.log("mathNode__below", mathNode__below);

          function isSameValue(mathNode_1, mathNode_2) {
            var outBool;

            function isContainingSymbolNode(mathNode) {
              var outBool;

              const arr_symbolNode = mathNode.filter(function (node) { return node.isSymbolNode; });

              outBool = (arr_symbolNode.length > 0);

              return outBool;
            }

            const isSymbolNode_in_either = isContainingSymbolNode(mathNode_1) || isContainingSymbolNode(mathNode_2);
            if (isSymbolNode_in_either) {

              function evaluateMathNode(mathNode, dict_subst) {
                // logger.log("evaluateMathNode, mathNode", mathNode);
                // logger.log("evaluateMathNode, dict_subst", dict_subst);
                return mathNode.evaluate(dict_subst);
              }

              function evaluation_grid(mathNode_1, mathNode_2) {
                var outBool;

                const arr_dict_subst = [
                  {
                    x: 0,
                  },
                  {
                    x: 1,
                  },
                  {
                    x: -1,
                  },
                ];

                //early break reduce
                outBool = Utils.early_break_reduce(arr_dict_subst, (acc, x, i, arr) => {
                  // logger.log("early_break_reduce", x.x);

                  const ev_1 = evaluateMathNode(mathNode_1, x);
                  const ev_2 = evaluateMathNode(mathNode_2, x);

                  const isEqual_ev = (ev_1 == ev_2);

                  return acc && isEqual_ev;
                }, true, (acc, x, i, arr) => {
                  return (acc == false);
                });

                return outBool;
              }

              outBool = evaluation_grid(mathNode_1, mathNode_2);
              if (outBool) {
                return outBool;
              }


              var expr__mathNode_1 = mathNode_1.toString();
              expr__mathNode_1 = expr__mathNode_1.replaceAll("×", "*");
              var expr__mathNode_2 = mathNode_2.toString();
              expr__mathNode_2 = expr__mathNode_2.replaceAll("×", "*");

              const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
              const algebrite_result = Algebrite.run(expr__equality);

              outBool = (algebrite_result == true);

            } else {

              const relationalNode = new math.RelationalNode(['equal'], [mathNode__above, mathNode__below]);
              // logger.log("relationalNode", relationalNode);

              outBool = relationalNode.evaluate();
            }

            return outBool;
          }


          const isSameValue_ = isSameValue(mathNode__above, mathNode__below);
          console.log("isSameValue_", isSameValue_);


          outBool = isSameValue_;

          return outBool;
        };


        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value": canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above, below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;

        const transformationFunc = (icObj) => {
          var outIcObj;

          // logger.log("icGMBox original transformation func");

          return outIcObj;
        };

        const touchSlotConfig = {
          canTouchFunc: canTouchFunc,
          transformationFunc: transformationFunc,
          context: {},
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";



        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, targetMathNode);
        // facade.backgroundColor = "orange";
        // facade.isTouchable     = false;

        const curseFacade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "0");

        const parts = {
          "touchSlot": touchSlot,
          "facade": facade,

          "curseFacade": curseFacade,
        };


        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_blobTarget";

        // icComposite.isTouchable = false;


        //enrich touchSlotConfig.context
        infiniteCanvas.onceOnAddRepresentedForIcObject(facade, (facade) => {
          const facade__represented = infiniteCanvas.getRepresented(facade.id);
          // const facade__rep_free     = facade__represented.r_free();
          const facade__rep_official = facade__represented.r_official();

          touchSlotConfig.context.facade = facade__rep_official;
        });



        //curse: metamorphosis
        infiniteCanvas.onceOnAddRepresentedForIcObject(icComposite, (icComposite) => {

          const composite_represented = infiniteCanvas.getRepresented(icComposite.id);
          const composite_rep_free = composite_represented.r_free();

          const facade_rep_free = composite_rep_free.parts.facade;
          const curseFacade_rep_free = composite_rep_free.parts.curseFacade;


          // const countDownTrigger = infiniteCanvas.createCurseTrigger_countdown();
          infiniteCanvas.accurse__metamorphosis(facade_rep_free);

          const curseFunc = () => {
            // logger.log("curseFunc, rep_free:", facade_rep_free);
            const mathNode = random_constantNode();
            facade_rep_free.mathNode = mathNode;
            facade_rep_free.curse_metamorphosis.reset();
          };
          facade_rep_free.curse_metamorphosis.curseFunc = curseFunc;



          facade_rep_free.curse_metamorphosis.start();





          const curseTrigger = facade_rep_free.curse_metamorphosis.curseTrigger;
          // logger.log("curseTrigger", curseTrigger);

          // Hooker.installHooks(curseTrigger, "impulse");
          // curseTrigger.did["impulse"].on(() => {
          // logger.log("did impulse");
          // const countDownEngine = curseTrigger.engine;
          // const counter         = countDownEngine.getCounter();
          // curseFacade_rep_free.text = "" + counter;
          // });


          // facade_rep_free.curse_metamorphosis.start();

          facade_rep_free.curse_metamorphosis.rx_countDownCounter.subscribe({
            next: (value) => {
              // logger.log("rx_countDownCounter, next", value);
              // logger.log("curseFacade_rep_free", curseFacade_rep_free);

              curseFacade_rep_free.text = "" + value;
              // facade_rep_free.mathNode = new math.ConstantNode(value);
            },
          });


        });


        return icComposite;


        // keyboard_Rx.rx_keyUp.subscribe({
        //   next: (e) => {
        //     logger.log("e",e);
        //
        //     switch(e.code) {
        //       case "Numpad1":
        //         facade_rep_free.curse_metamorphosis.curseTrigger.impulse();
        //         break;
        //     }
        //
        //   },
        // });


      }



      createIcGMChallenge(trueRect, challengeIndex) {
        console.log("createIcGMChallenge", trueRect);

        const challengeName = "gmChallenge " + "#" + challengeIndex;
        const nameLabel = infiniteCanvas.createIcText(trueRect.x, trueRect.y, challengeName);
        backade.backgroundColor = "brown";
        backade.fill = "white";
        backade.isMobile = false;
        // backade.isTouchable = false;

        const gmChallengeConfig = GMChallengeMama.configForIndex(challengeIndex);

        const well = infiniteCanvas.createIcText(trueRect.x, trueRect.y, challengeName);

        const op1 = infiniteCanvas.createIcText(trueRect.x, trueRect.y, challengeName);

        const parts = {
          "nameLabel": nameLabel,

          "well": well,

          "op1": op1,
          "op2": op2,
          "op3": op3,
          "op4": op4,

          "targetSlot": targetSlot,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_challenge";

        // icComposite.isTouchable = false;


        return icComposite;

      }








      createIcObserver(trueRect, observerConfig_in = null) {
        console.log("createIcObserver");

        const infiniteCanvas = this;

        const type = "observer";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const arr_mathNode = infiniteCanvas.getAllRepresentedWithType("mathNode");
        console.log("arr_mathNode", arr_mathNode);
        // const mathNode_id  = arr_mathNode.find(e => true).id;
        const mathNode_id = arr_mathNode.find(e => true).r_official().id;
        console.log("mathNode_id", mathNode_id);
        const observed = {};
        if (mathNode_id != null) {
          observed[mathNode_id] = true;
        }

        var observerConfig = observerConfig_in;
        if (observerConfig == null) {
          observerConfig = {
            observerEngine: ObserverEngine.defaultInstance(infiniteCanvas, icObj),
            observed: observed,
          };
        }

        //debug
        // observerConfig.observerEngine.did['observe'].on((icObj_incoming) => {
        //   console.log("observerEngine.did['observe']", icObj_incoming);
        // });

        const icObserver_spec = {
          isSnappable: false,

          stroke: "#123123",
          strokeWidth: 5,

          fill: "#789456",

          observerConfig: observerConfig,
        };

        const icObserver = Object.assign(icObj, icObserver_spec);

        //add reactive part
        this.mutateObserver__addReactivePart(icObserver, observerConfig);

        return icObserver;
      }

      mutateObserver__addReactivePart(icObserver, observerConfig) {

        const infiniteCanvas = this;

        const observerEngine = observerConfig.observerEngine;

        observerEngine.start();
        infiniteCanvas.onIcObjUpdate(observerEngine.r_official_update_handler2);
      }

      createIcTrigger(trueRect, triggerConfig = null) {
        console.log("createIcTrigger");

        const infiniteCanvas = this;

        const type = "trigger";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icTrigger_spec = {
          isSnappable: false,

          stroke: "#123123",
          strokeWidth: 5,

          fill: "#888555",

          triggerConfig: triggerConfig,
        };

        const icTrigger = Object.assign(icObj, icTrigger_spec);

        //add reactive part
        this.mutateTrigger__addReactivePart(icTrigger, triggerConfig);

        return icTrigger;
      }

      mutateTrigger__addReactivePart(icTrigger, triggerConfig) {

      }

      createIcEventEmitter(trueRect) {

      }

      createIcEventReceiver(trueRect) {

      }

      createIcEye(trueRect) {
        logger.log("createIcEye", trueRect);
        const infiniteCanvas = this;

        const type = "eye";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icEye_spec = {
          rx: 0,
          ry: 0,
          strokeWidth: 3,
          stroke: "lime",

          rx_signal__out: new ReplaySubject(1),
        };

        const icEye = Object.assign(icObj, icEye_spec);

        const engine    = new EyeEngine();
        const eType     = "eye";
        const icEngined = infiniteCanvas.installEngineOnIcObj(icEye, eType, engine);

        return icEngined;
      }

      createIcDisplay(trueRect) {
        logger.log("createIcDisplay", trueRect);
        const infiniteCanvas = this;

        const type      = "display";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icDisplay_spec = {
          // rx: 0,
          // ry: 0,
          strokeWidth: 2,
          stroke: "olive",

          rx_signal__in: null,
        };

        const icDisplay = Object.assign(icObj, icDisplay_spec);

        const engine    = new DisplayEngine();
        const eType     = "display";
        const icEngined = infiniteCanvas.installEngineOnIcObj(icDisplay, eType, engine);

        return icEngined;
      }


      createIcInnerCam(trueRect) {

          //icEye
          const trueRect_icEye = trueRect;

          const icEye  = infiniteCanvas.createIcEye(trueRect_icEye);
          icEye.zIndex = 100;

          //icDisplay
          const trueRect_icDisplay = {
            x:      trueRect_icEye.x + trueRect_icEye.width * 1.1,
            y:      trueRect_icEye.x +                    0 * 1.1,
            width:  trueRect_icEye.width,
            height: trueRect_icEye.height,
          };

          const icDisplay  = infiniteCanvas.createIcDisplay(trueRect_icDisplay);

          infiniteCanvas.onceOnAddRepresentedForIcObject(icDisplay, (icDisplay) => {

              const rep_free__icDisplay = infiniteCanvas.getRepresented(icDisplay.id).r_free();
              const rep_free__icEye     = infiniteCanvas.getRepresented(icEye.id).r_free();

              const rx_signal__in = rep_free__icEye.rx_signal__out;
              
              logger.log("LogDisplay", "setting new rx_signal__in");
              // rep_free__icDisplay.rx_signal__in = rx_signal__in;   //SHU: does not work

              //SHU: workaround:
              //unsubscribe to old signal (if any)                    
              rep_free__icDisplay.rxsub?.unsubscribe();

              rep_free__icDisplay.rxsub = rx_signal__in.subscribe({
                next: (img) => {
                  rep_free__icDisplay.img = img;
                },
              });

          });

        const parts = {
          "eye":     icEye,
          "display": icDisplay,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
        // compositeConfig[icDisplay.id].isMobile = true;

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "innerCam";

        return icComposite;
      }


      createIcRxSubject(trueRect) {
        console.log("createIcRxSubject", trueRect);

        const infiniteCanvas = this;

        const type = "rxSubject";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRxSubject_spec = {

        };

        const icRxSubject = Object.assign(icObj, icRxSubject_spec);


        const engine = new RxSubjectEngine();
        const eType = "rxSubject";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icRxSubject, eType, engine);

        return icEngined;
      }

      createIcRxSubscription(trueRect) {
        console.log("createIcRxSubscription", trueRect);

        const infiniteCanvas = this;

        const type = "rxSubscription";
        const position = Geometry.createPoint(trueRect.x, trueRect.y);
        const size = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRxSubscription_spec = {

        };

        const icRxSubscription = Object.assign(icObj, icRxSubscription_spec);


        const engine = new RxSubscriptionEngine();
        const eType = "rxSubscription";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icRxSubscription, eType, engine);

        return icEngined;
      }





      createIcFacet_mathNode(trueRect) {
        console.log("createIcFacet_mathNode", trueRect);
        const infiniteCanvas = this;

        const mathNode = new math.ConstantNode("");
        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        facade.backgroundColor = "grey";
        facade.isMobile = true;
        // facade.isTouchable = false;

        const observer = infiniteCanvas.createIcObserver(trueRect, null);

        observer.observerConfig.observerEngine.did['observe'].on((icObj_incoming) => {
          const mathNode_incoming = icObj_incoming.mathNode;
          console.log("mathNode_incoming", mathNode_incoming);

          const mathNode_cloned = mathNode_incoming.clone();
          const mathNode_simplified = math.simplify(mathNode_cloned);

          // facade.mathNode = mathNode_simplified;
          const facade_represented = infiniteCanvas.getRepresented(facade.id);
          const facade_rep_free = facade_represented.r_free();

          facade_rep_free.mathNode = mathNode_simplified;
        });

        const parts = {
          "observer": observer,
          "facade": facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "facet_mathNode";

        // icComposite.isTouchable = false;


        return icComposite;
      }




      //icEngined

      installEngineOnIcObj(icObj, eType, engine) {
        console.log("promotedToIcEngined", icObj, eType, engine);

        const dict_engine__icObj = icObj.dict_engine;

        var index_start;
        if (dict_engine__icObj == null) {
          index_start = 0;
        } else {
          index_start = Object.values(dict_engine__icObj).reduce((acc, x) => {
            // logger.log("index_start", "x", x);
            const index_start__existingEngine = x.index_start;
            acc = Math.max(index_start__existingEngine, acc);
            return acc;
          }, 0) + 1;
        }

        const icEngined_spec = {
          dict_engine: {
            [eType]: {
              engine: engine,
              index_start: index_start,
            },
          },
        };

        var icEngined;
        if (icObj.dict_engine == null) {
          icEngined = Object.assign(icObj, icEngined_spec);
        } else {
          // Object.assign(icObj.dict_engine, icEngined_spec.dictEngine);
          icObj.dict_engine[eType] = {
            engine: engine,
            index_start: index_start,
          };
          icEngined = icObj;
        }

        Enginiter.installEngine(icEngined, engine);

        return icEngined;
      }

      uninstallEngineOnIcObj(icEngined, eType) {
        console.log("uninstallEngineOnIcObj", icEngined);

        const engine = icEngined.dict_engine[eType];

        Enginiter.uninstallEngine(icEngined, engine);

        const icObj = icEngined;

        delete icObj.dict_engine[eType];
        if (Object.values(icObj.dict_engine).length == 0) {
          delete icObj.dict_engine;
        }

        return icObj;
      }

      createIcEngined_debug(trueRect) {
        console.log("createIcEngined_debug", trueRect);

        const engineCarrier = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "icEngined_debug");
        engineCarrier.backgroundColor = "gold";

        const eType1 = "debug__growText";
        const engine1 = new DebugEngine_growText();
        const icEngined1 = infiniteCanvas.installEngineOnIcObj(engineCarrier, eType1, engine1);
        logger.log("icEngined1", icEngined1);

        const eType2 = "debug__changeColor";
        const engine2 = new DebugEngine_changeColor();
        const icEngined2 = infiniteCanvas.installEngineOnIcObj(icEngined1, eType2, engine2);
        logger.log("icEngined2", icEngined2);

        return icEngined2;
      }





      createIcCountdown(trueRect, countDownConfig_in = null) {
        console.log("createIcCountdown", trueRect);
        const infiniteCanvas = this;

        const mathNode = new math.ConstantNode("");
        const facade = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        facade.backgroundColor = "grey";
        facade.isMobile = true;
        facade.isTouchable = true;  //:)

        class CountDownEngine {
          constructor(facade, countDownConfig_in = null) {

            var countDownConfig = countDownConfig_in;
            if (countDownConfig == null) {
              countDownConfig = CountDownConfig.defaultConfig();
            }

            this.counter_start = countDownConfig.value_start;
            this.counter_end = countDownConfig.value_end;

            this.stepFunc = countDownConfig.stepFunc;
            this.stepDuration = countDownConfig.stepDuration;

            const nb_steps = math.abs(this.counter_end - this.counter_start);
            this.nb_steps = nb_steps;

            this.arr_steps = [...new Array(nb_steps).keys()];
            this.step_current = 0;

            this.counter = this.counter_start;

            this.progress = 0;

            this.isPaused = true;

            const duration = this.nb_steps * this.stepDuration;

            this.animatedObj = {
              progress: 0
            };

            const countDownEngine = this;
            const animatedObj = this.animatedObj;
            const animation = anime({
              // targets: countDownEngine,
              targets: animatedObj,

              /*animated props*/
              progress: 1,
              /*--------------*/

              direction: 'normal',
              easing: 'linear',
              duration: duration,

              autoplay: false,

              update: (anim) => {
                // const progress = anim.progress / 100;
                const progress = animatedObj.progress;
                countDownEngine.progress = progress;
                countDownEngine.update(progress);
              },
            });

            this.animation = animation;




            this.start = function () {
              const countDownEngine = this;

              countDownEngine.stepFunc(0);
              countDownEngine.play();
            };
            // }.bind(this);

            this.stop = function () {
              const countDownEngine = this;

              countDownEngine.reset();
            };
            // }.bind(this);

            this.play = function () {
              const countDownEngine = this;

              const date_play = new Date();
              countDownEngine.date_play = date_play;

              countDownEngine.isPaused = false;
              countDownEngine.animation.play();
            };
            // }.bind(this);

            this.pause = function () {
              const countDownEngine = this;

              const date_pause = new Date();
              countDownEngine.date_pause = date_pause;

              countDownEngine.animation.pause();
              countDownEngine.isPaused = true;
            };
            // }.bind(this);

            this.reset = function () {
              const countDownEngine = this;

              countDownEngine.animation.reset();
            };
            // }.bind(this);

            this.update = function (progress) {
              console.log("update", progress);
              const countDownEngine = this;

              const cursor = progress * countDownEngine.nb_steps;
              const step_cursor = math.floor(cursor);

              const isStepChanged = (step_cursor - countDownEngine.step_current) >= 1;
              if (isStepChanged) {
                countDownEngine.step_current = step_cursor;
                countDownEngine.stepFunc(step_cursor);
              }
            };
            // }.bind(this);

          }

          /*
          start() {
            this.stepFunc(0);
            this.play();
          }

          stop() {
            this.reset();
          }

          play() {
            const countDownEngine = this;

            const date_play           = new Date();
            countDownEngine.date_play = date_play;

            countDownEngine.isPaused = false;
            countDownEngine.animation.play();
          }

          pause() {
            const countDownEngine = this;

            const date_pause           = new Date();
            countDownEngine.date_pause = date_pause;

            countDownEngine.animation.pause();
            countDownEngine.isPaused = true;
          }

          reset() {
            countDownEngine.animation.reset();
          }

          update(progress) {
            console.log("update", progress);
            const cursor      = progress * this.nb_steps;
            const step_cursor = math.floor(cursor);

            const isStepChanged = (step_cursor - this.step_current) >= 1;
            if(isStepChanged) {
              this.step_current = step_cursor;
              this.stepFunc(step_cursor);
            }
          }
          */

        }

        class CountDownConfig {

          constructor(value_start, value_end, stepFunc, stepDuration) {
            this.value_start = value_start;
            this.value_end = value_end;

            this.stepFunc = stepFunc;
            this.stepDuration = stepDuration;
          }

          static defaultConfig() {
            var outConfig;

            const value_start = 10;
            const value_end = 0;

            const stepFunc = (stepIndex) => {
              console.log("stepFunc", stepIndex);
            };

            const stepDuration = 1000;

            outConfig = new CountDownConfig(value_start, value_end, stepFunc, stepDuration);

            return outConfig;
          }

        }

        const countDownConfig = CountDownConfig.defaultConfig();
        countDownConfig.stepFunc = (stepIndex) => {
          console.log("stepFunc", stepIndex);

          const facade_represented = infiniteCanvas.getRepresented(facade.id);
          const facade_rep_free = facade_represented.r_free();

          const mathNode = new math.ConstantNode(stepIndex);
          facade_rep_free.mathNode = mathNode;
        };

        const engine = new CountDownEngine(facade, countDownConfig);
        console.log("fresh engine", engine);
        const eType = "countdown";

        const icEngined = infiniteCanvas.installEngineOnIcObj(facade, eType, engine);

        return icEngined;
      }



      createIcInteractor(trueRect, interactorConfig_in = null) {
        console.log("createIcCountdown", trueRect);
        const infiniteCanvas = this;

        // const mathNode = new math.ConstantNode("");
        // const facade   = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        const facade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "interactor");
        facade.backgroundColor = "gold";
        facade.isMobile = true;
        facade.isTouchable = true;  //:)

        class InteractorEngine {
          constructor() {

            this.initialized = false;

            this.initialize = function (scopeObj) {
              this.initialized = true;
              this.scopeObj = scopeObj;
            }

            this.start = function () {
              console.log("this.scopeObj.facade", this.scopeObj.facade);
            };

            this.stop = function () {

            };

            this.interact = function () {
              console.log("interact");

              this.scopeObj.facade.text += "+";
            };

          }
        }

        const engine = new InteractorEngine();
        console.log("fresh engine", engine);
        const eType = "interactor";

        const icEngined = infiniteCanvas.installEngineOnIcObj(facade, eType, engine);

        return icEngined;
      }


      createIcGeminiShade(icObj) {
        console.log("createIcGeminiShade", icObj);
        const infiniteCanvas = this;

        const icObj__clone = icObj.deepClone();
        const id__clone = infiniteCanvas.generateIcObjectId();
        icObj__clone.id = id__clone;

        const icGeminiShade_spec = {
          id__target: icObj.id,

          opacity: 0.666,
          fill: "grey",
        };

        const icGeminiShade = Object.assign(icObj__clone, icGeminiShade_spec);

        const engine = new GeminiShadeEngine();
        const eType = "geminiShade";

        const icEngined = infiniteCanvas.installEngineOnIcObj(icGeminiShade, eType, engine);

        return icEngined;
      }



      createIcCustomizableOperator(trueRect) {

        //--create interior--

        const trueRect__interior = Geometry.rectWithHomothety(trueRect, {x: trueRect.x, y: trueRect.y}, 0.1);

        const trueRect__i__rect = Geometry.rectWithHomothety(trueRect, Geometry.getCenterPoint(Geometry.createLTRect(trueRect)), 0.3);
        const icRect = this.createIcRect(trueRect__i__rect);

        const parts__interior = {
          "rect":  icRect,
        };

        const compositeConfig__interior = Compositer.defaultCompositeConfig(parts__interior, false);

        const icComposite__interior = this.createIcComposite(trueRect, parts__interior, compositeConfig__interior);


        //--create surface--

        const trueRect__surface = trueRect;

        const transformationFunc = (icObject_in) => {
            var outMutationObject = {};

            function randomColor() {
              var r = 255 * Math.random() | 0,
                g = 255 * Math.random() | 0,
                b = 255 * Math.random() | 0;
              return 'rgb(' + r + ',' + g + ',' + b + ')';
            }

            const color = randomColor();
            outMutationObject.fill = color;

            return outMutationObject;
          };

        const touchSlotConfig = {
          transformationFunc: transformationFunc,
        };

        const touchSlot = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill = "";
        // touchSlot.isMobile = false;

        const facade = infiniteCanvas.createIcText(trueRect__surface.x, trueRect__surface.y, "customizable");
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;
        //SHULOLILOL
        facade.zIndex = 100;

        const parts__surface = {
          "touchSlot": touchSlot,
          "facade":    facade,
        };

        const compositeConfig__surface = Compositer.defaultCompositeConfig(parts__surface, false);

        const icComposite__surface = this.createIcComposite(trueRect__surface, parts__surface, compositeConfig__surface);
        icComposite__surface.cType = "customizable_operator.Surface";

        const operation       = new Operation(transformationFunc);
        icComposite__surface.operation = operation;
        // icComposite__surface.isTouchable = false;




        //--create main composite--

        const parts__main = {
          "surface":  icComposite__surface,
          "interior": icComposite__interior,
        };

        const compositeConfig__main = Compositer.defaultCompositeConfig(parts__main, false);

        const icComposite__main = this.createIcComposite(trueRect, parts__main, compositeConfig__main);


        return icComposite__main;
      }













      //add
      addIcObject(icObj) {
        // logger.log("logCP", "addIcObject", icObj);

        if (this.getRepresented(icObj.id) != null) {
          //ignore
        } else {

          if (icObj.type == "composite"
            || icObj.type == "compositeSegment") {
            if(icObj.content != null) {
              this.addIcObject(icObj.content);
            }            
            Object.values(icObj.parts).forEach((part, i) => {
              this.addIcObject(part);
            });
          }

          const represented = this.createRepresentedIcObject(icObj);
          this.addRepresented(represented);
        }

      }

      addIcObject_p(icObj) {
        var out_p;

        out_p = new Promise((resolve, reject) => {

          infiniteCanvas.onceOnAddRepresentedForIcObject(icObj, async (icObj) => {

            const represented = infiniteCanvas.getRepresented(icObj.id);
            const rep_free = represented.r_free();

            resolve(rep_free);
          });
          infiniteCanvas.addIcObject(icObj);

        });

        return out_p;
      }

      didAddIcObject(icObj) {

      }

      addRepresented(represented) {
        logger.log("addRepresented", represented);

        const id_icObj = represented.r_official().id;
        const represented_check = this.getRepresented(id_icObj);
        if (represented_check != null) {
          //ignore
          console.log("represented already added => ignore");
          return;
        }

        this.tetherIcObject(represented);   //== track icObj updates

        this.introduceToExistingObjects(represented);

        //store
        const rep_official = represented.r_official();
        this.represented[rep_official.id] = represented;

        //add free representation
        const rep_free = represented.r_free();
        this.addRepresentation(represented, rep_free);

        // if (rep_official.type == "composite") {
        //   Object.values(represented.parts).forEach((part__represented, i) => {
        //     logger.log("adding part: ", part__represented);
        //     this.addRepresented(part__represented);
        //   });
        // }

        this.didAddRepresented(represented);
      }

      didAddRepresented(represented) {
        this.setChanged(true);

        this.didAddRepresentedListeners.forEach((listener, i) => {
          listener(represented);
        });
      }

      onAddRepresented(listener) {
        this.didAddRepresentedListeners.push(listener);
      }

      offAddRepresented(listener) {
        this.didAddRepresentedListeners = Utils.arrayByRemovingElement(this.didAddRepresentedListeners, listener);
      }

      onceOnAddRepresentedForIcObject(icObject, func) {

        var autoUnsub = (represented) => {

          //compare icObject with represented
          const r_official = represented.r_official();
          if (r_official.id == icObject.id) {
            this.offAddRepresented(autoUnsub);
            func(icObject);
          }

        }

        this.onAddRepresented(autoUnsub);
      }

      removeRepresented(represented, shouldAlsoRemoveChildren = false) {
        logger.log("log1", "removeRepresented", represented);

        // if(represented == null) {
        //   throw new Error("represented == null");
        // }

        const id_icObj = represented.r_official().id;
        const represented_check = this.getRepresented(id_icObj);
        if (represented_check == null) {
          //ignore
          console.log("represented already removed => ignore");
          return;
        }

        //remove from parent (if any)
        const rep_free = represented.r_free();
        if (rep_free.compositeId != -1) {
          const rep_free__parent = infiniteCanvas.getRepresented(rep_free.compositeId).r_free();
          rep_free__parent.dict_engine["composite"].engine.awoken.removePart(rep_free);
        }

        if (shouldAlsoRemoveChildren) {
          if (represented.r_official().type == "composite") {
            Object.values(represented.parts).forEach((part__represented, i) => {
              this.removeRepresented(part__represented, shouldAlsoRemoveChildren);
            });
          }
        }

        const isEngined = (represented.r_official().dict_engine != null);
        if (isEngined) {
          Object.keys(represented.r_free().dict_engine).forEach(eType => {
            represented.r_free().dict_engine[eType].engine.awoken.stop();
          });
        }

        if (represented.r_official().type == "video") {
          const video = represented.r_free().video;
          logger.log("log1", "removeRepresented", "video", video);
          video.pause();

          //stop stream if any
          if (video.srcObject instanceof MediaStream) {
            const stream = video.srcObject;
            stream.getTracks().forEach(function (track) {
              track.stop();
            });
          }

          video.remove();
        }



        this.untetherIcObject(represented);   //== stop tracking icObj updates

        this.extroduceFromExistingObjects(represented);

        //unstore
        //representations
        Object.values(represented.reps).forEach((rep, i) => {
          this.removeRepresentation(represented, rep);
        });


        //represented
        const rep_official = represented.r_official();
        const id_represented = rep_official.id;
        // this.represented[id_represented] = null;
        delete this.represented[id_represented];


        //deconstruct
        represented.deconstruct();

        this.didRemoveRepresented(represented);
      }

      didRemoveRepresented(represented) {
        // logger.log("didRemoveRepresented", represented);

        this.setChanged(true);

        this.didRemoveRepresentedListeners.forEach((listener, i) => {
          listener(represented);
        });
      }

      onRemoveRepresented(listener) {
        this.didRemoveRepresentedListeners.push(listener);
      }

      offRemoveRepresented(listener) {
        this.didRemoveRepresentedListeners = Utils.arrayByRemovingElement(this.didRemoveRepresentedListeners, listener);
      }










      addRepresentation(represented, representation) {

        if (this.representations[representation.id_rep] == null) {
          this.representations[representation.id_rep] = representation;
        } else {
          throw new Error("oh, no, id collision for id: " + representation.id_rep);
        }

        this.didAddRepresentation(represented, representation);
      }

      didAddRepresentation(represented, representation) {
        this.setChanged(true);

        this.didAddRepresentationListeners.forEach((listener, i) => {
          listener(represented, representation);
        });

        this.redrawCanvas(RedrawOccasion.objectAdded);
      }

      removeRepresentation(represented, representation) {

        // if(this.representations[representation.id_rep] != null) {
        delete this.representations[representation.id_rep];
        // }

        this.didRemoveRepresentation(represented, representation);
      }

      didRemoveRepresentation(represented, representation) {
        this.setChanged(true);

        // this.didAddObjectListeners.forEach((listener, i) => {
        //   listener(icObj);
        // });

        this.redrawCanvas(RedrawOccasion.objectRemoved);
      }

      addPureIcObject(icObj) {

        this.pure_icObjects["any"].push(icObj);


        if (this.pure_icObjects[icObj.type] == null) {
          this.pure_icObjects[icObj.type] = [];
        }
        this.pure_icObjects[icObj.type].push(icObj);

        this.didAddPureObject(icObj);
      }

      didAddPureObject(icObj) {
        this.didAddPureObjectListeners.forEach((listener, i) => {
          listener(icObj);
        });

        this.redrawCanvas(RedrawOccasion.pureObjectAdded);
      }


      removeIcObject(icObj) {
        console.log("removeIcObject", icObj);

        //SHU TODO: removeIcObject


        this.didRemoveObject_p(icObj);
      }

      didRemoveObject_p(icObj) {
        this.setChanged(true);

        // this.didAddObjectListeners.forEach((listener, i) => {
        //   listener(icObj);
        // });
        //
        // this.redrawCanvas(RedrawOccasion.objectRemoved);
      }

      // manageIcObjUpdate(icObj, requestCanvasRedraw = false) {
      //   console.log("manageIcObjUpdate");
      //
      //   if(icObj.toBeDeleted) {
      //     console.log("this", this);
      //     this.removeIcObject(icObj);
      //   }
      //
      //   this.icObjDidUpdate(icObj);
      //
      //   this.setChanged(true);
      // }



      createIcEvent__icObjUpdate(icObj, outerUpdatesDict) {
        logger.log("createIcEvent", icObj, outerUpdatesDict);
        var outIcEvent;

        const infiniteCanvas = this;

        if (outerUpdatesDict.position && outerUpdatesDict.homeScale) {

          var time = performance.now();
          logger.log("time", time);

          // var timestamp = Date.now();
          // logger.log("timestamp", timestamp);

          const icObj__id = icObj.id;
          const position__new  = Object.assign({}, outerUpdatesDict.position.new);
          const homeScale__new = Object.assign({}, outerUpdatesDict.homeScale.new);


          const revision = infiniteCanvas.generateIcEventIndex();

          const icEvent__move = {
            // type: "move",
            data: {
              id: icObj__id,
              position:  position__new,
              homeScale: homeScale__new,
              time: time,
            },

            //SHU: wolken-related
            context: {
              name: 'ux',
            },
            aggregate: {
              name: 'icObject',
              id: uuid__unknown,
            },
            name: 'icObjZMoved',

            metadata: {
              correlationId: uuid__unknown,
              causationId: uuid__unknown,

              revision: revision,
              timestamp: time,
            },

          };

          outIcEvent = icEvent__move;
        }

        else if (outerUpdatesDict.position) {

          var time = performance.now();
          logger.log("time", time);

          // var timestamp = Date.now();
          // logger.log("timestamp", timestamp);

          const icObj__id = icObj.id;
          const position__new  = Object.assign({}, outerUpdatesDict.position.new);

          const revision = infiniteCanvas.generateIcEventIndex();

          const icEvent__move = {
            // type: "move",
            data: {
              id: icObj__id,
              position:  position__new,
              time: time,
            },

            //SHU: wolken-related
            context: {
              name: 'ux',
            },
            aggregate: {
              name: 'icObject',
              id: uuid__unknown,
            },
            name: 'icObjMoved',

            metadata: {
              correlationId: uuid__unknown,
              causationId: uuid__unknown,

              revision: revision,
              timestamp: time,
            },

          };

          outIcEvent = icEvent__move;
        } 

        //for hexmap
        else if (outerUpdatesDict.isHeld) {

          var time = performance.now();
          logger.log("time", time);

          const icObj__id = icObj.id;
          const isHeld__new = Object.assign({}, outerUpdatesDict.isHeld.new);

          const revision = infiniteCanvas.generateIcEventIndex();

          const icEvent__hold = {
            // type: "hold",
            data: {
              id: icObj__id,
              isHeld: isHeld__new,
              time: time,
            },

            //SHU: wolken-related
            context: {
              name: 'ux',
            },
            aggregate: {
              name: 'icObject',
              id: uuid__unknown,
            },
            name: 'icObjHeld',

            metadata: {
              correlationId: uuid__unknown,
              causationId: uuid__unknown,

              revision: revision,
              timestamp: time,
            },

          };

          outIcEvent = icEvent__hold;
        }

        return outIcEvent;
      }

      recordIcEvent_p(eventstore__, icEvent) {
        var out_p;

        const state = {
          desc: "lolilol",
        };

        async function saveEvent(icEvent) {

          const event = new Event(icEvent);
          // const event = new Event({
          //   context:   icEvent.context,
          //   aggregate: icEvent.aggregate,
          //   name:      icEvent.name,
          //   data:      icEvent.data,
          //   // custom:    icEvent.custom,
          //   metadata:  icEvent.metadata,
          // });
          event.metadata.revision = icEvent.metadata.revision;

          const arr_event__saved = await eventstore__.saveEvents({
            uncommittedEvents: [
              { event: event, state: state },
            ],
          });

          const id__aggregate = uuid__unknown;
          const revision = icEvent.metadata.revision;

          await eventstore__.markEventsAsPublished({
            aggregateId: id__aggregate,
            fromRevision: revision,
            toRevision: revision,
          });

          // const event__last = await eventstore__.getLastEvent(id__aggregate);
          // return event__last;

          return event;
        }

        out_p = saveEvent(icEvent);
        // .then(event__last => {
        //   logger.log("event__last", event__last);
        // });

        return out_p;
      }


      icObjDidUpdate(icObj, outerUpdatesDict) {
        // logger.log("icObjDidUpdate", icObj, outerUpdatesDict);

        //SHU FLUID
        //create event
        const icEvent__icObjUpdate = this.createIcEvent__icObjUpdate(icObj, outerUpdatesDict);
        // const icEvent__icObjUpdate = null;   //debug
        if (icEvent__icObjUpdate != null) {
          //"publish" event
          //so that it's somehow saved somewhere
          this.rx_icEvent_subject.next(icEvent__icObjUpdate);
        }


        //original iC update forwarding
        this.icObjListeners.forEach((listener, i) => {
          // logger.log("icObjDidUpdate", "listener()", listener);
          listener(icObj, outerUpdatesDict);
        });

        //specific icObj update forwarding
        this.icObjListeners__dict[icObj.id]?.forEach((listener, i) => {
          // logger.log("icObjDidUpdate", "listener()", listener);
          listener(icObj, outerUpdatesDict);
        });
      }

      //"onAnyIcObjUpdate"    //TODO: rename
      onIcObjUpdate(listener) {
        this.icObjListeners.push(listener);
      }

      offIcObjUpdate(listener) {
        this.icObjListeners = Utils.arrayByRemovingElement(this.icObjListeners, listener);
      }
      
      //"onIcObjUpdate"    //TODO: rename
      onSpecificIcObjUpdate(icObj, listener) {
        if(this.icObjListeners__dict[icObj.id] == null) {
          this.icObjListeners__dict[icObj.id] = [];  
        }
        this.icObjListeners__dict[icObj.id].push(listener);
      }

      offSpecificIcObjUpdate(icObj, listener) {
        this.icObjListeners__dict[icObj.id] = Utils.arrayByRemovingElement(this.icObjListeners__dict[icObj.id], listener);
      }


      addDehydratedIcObject(icObj) {
        const rehydrated = this.rehydrated(icObj);

        this.addIcObject(rehydrated);
      }

      rehydrated(icObj) {
        var rehydrated;

        // rehydrated = icObj.clone();
        rehydrated = icObj.deepClone();


        // switch(icObj.type) {
        //   case "snapSlot":
        //     const icSnapSlot = rehydrated;
        //     //add reactive part
        //     this.mutateSnapSlot__addReactivePart(icSnapSlot);
        //     rehydrated = icSnapSlot;
        //     break;
        //   default:
        //   break;
        // }

        return rehydrated;
      }


      addIcObjectAtPositionAndScale(icObj, position_new, homeScale_new) {
        
        if(icObj.type == "composite") {
          CompositeUtils.shiftToPositionAndScale(icObj, position_new, homeScale_new); //SHU: this could be improved by using "appearance scale" i.e object.size.width wrt screenPov.size.width 
        } else {
          icObj.position  = position_new;
          icObj.homeScale = homeScale_new;
        }

        infiniteCanvas.addIcObject(icObj);
      }

      addPastedIcObject(icObj) {
        const infiniteCanvas = this;

        const true_cursor = this.getTrueCursor();

        const position__cursor = {
          x: true_cursor.x,
          y: true_cursor.y,
        };

        const scale__iC = {
          X: infiniteCanvas.scale.X,
          Y: infiniteCanvas.scale.Y,
        };

        this.addIcObjectAtPositionAndScale(icObj, position__cursor, scale__iC);
      }

      addPastedIcObjects(arr_icObj) {
        const infiniteCanvas = this;

        const true_cursor = this.getTrueCursor();

        const position__cursor = {
          x: true_cursor.x,
          y: true_cursor.y,
        };

        const scale__iC = {
          X: infiniteCanvas.scale.X,
          Y: infiniteCanvas.scale.Y,
        };

        //SHU TODO: keep relative offsets while changing position and scale

        //paste layout: row
        const ratio_padding__h = 0.1;
        const ratio_padding__v = 0;
        var position__prev = position__cursor;
        arr_icObj.forEach((icObj) => {
          const position_new  = position__prev;
          const homeScale_new = scale__iC;
          this.addIcObjectAtPositionAndScale(icObj, position_new, homeScale_new);

          const trueWidth__total = icObj.getTrueWidth__total(); //SHU TODO: take orientation into account...
          // logger.log("logCP", "addPastedIcObjects", "width__total:", width__total);

          const true_offset = {
            dx: trueWidth__total * (1 + ratio_padding__h),
            dy:                0 * (1 + ratio_padding__v),
          }; 
          position__prev = {
            x: position_new.x + true_offset.dx,
            y: position_new.y + true_offset.dy,               
          };

        });

      }

      manageAdhesion(icObj, icObj__support) {
        logger.log("logFD", "manageAdhesion", icObj, icObj__support);
        const infiniteCanvas = this;

        //we suppose that icObj has already been added to iC

        if(icObj__support.type == "composite") {
          //add as part
          const icObj__rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();
          icObj__support.dict_engine["composite"].engine.awoken.addPart(icObj__rep_free, false);
        } else if(infiniteCanvas.isCompositeContent(icObj__support)) {
          //add as part in parent
          const id__parent = icObj__support.compositeId; 
          const parent__rep_free = infiniteCanvas.getRepresented(id__parent).r_free();

          const icObj__rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();
          parent__rep_free.dict_engine["composite"].engine.awoken.addPart(icObj__rep_free, false);
        } else if(infiniteCanvas.isCompositePart(icObj__support)) {

          //promote icObj__support to composite

            //remove original version from parent
          const id__parent = icObj__support.compositeId; 
          const parent__rep_free = infiniteCanvas.getRepresented(id__parent).r_free();
          parent__rep_free.dict_engine["composite"].engine.awoken.removePart(icObj__support);

            //create composite form
          const trueRect__support__as_composite = {
            x:      icObj__support.position.x -  0 / (icObj__support.homeScale.X * icObj__support.scale.X),
            y:      icObj__support.position.y - 50 / (icObj__support.homeScale.Y * icObj__support.scale.Y),
            width:  30 / (icObj__support.homeScale.X * icObj__support.scale.X),
            height: 30 / (icObj__support.homeScale.Y * icObj__support.scale.Y),
          };
          const content         = icObj__support;
          const parts           = Utils.dictFromArr([icObj]);
          const contentAndParts = Object.assign({"content": content}, parts); 
          const compositeConfig = Compositer.defaultCompositeConfig(contentAndParts, false);
          const icObj__support__as_composite = infiniteCanvas.createIcComposite(trueRect__support__as_composite, parts, compositeConfig, content);
          icObj__support__as_composite.cType = "support";
          
          //SHU: illusion
          icObj__support__as_composite.fill = "transparent";
          
            //add composite form
          infiniteCanvas.onceOnAddRepresentedForIcObject(icObj__support__as_composite, (icObj__support__as_composite) => {

            const icObj__support__as_composite__rep_free = infiniteCanvas.getRepresented(icObj__support__as_composite.id).r_free();

            //add composite version to parent
            parent__rep_free.dict_engine["composite"].engine.awoken.addPart(icObj__support__as_composite__rep_free, false);
          });
          infiniteCanvas.addIcObject(icObj__support__as_composite);

        } else {

          //promote icObj__support to composite

            //create composite form
            const trueRect__support__as_composite = {
            x:      icObj__support.position.x -  0 / (icObj__support.homeScale.X * icObj__support.scale.X),
            y:      icObj__support.position.y - 50 / (icObj__support.homeScale.Y * icObj__support.scale.Y),
            width:  30 / (icObj__support.homeScale.X * icObj__support.scale.X),
            height: 30 / (icObj__support.homeScale.Y * icObj__support.scale.Y),
          };
          const content         = icObj__support;
          const parts           = Utils.dictFromArr([icObj]);
          const contentAndParts = Object.assign({"content": content}, parts); 
          const compositeConfig = Compositer.defaultCompositeConfig(contentAndParts, false);
          const icObj__support__as_composite = infiniteCanvas.createIcComposite(trueRect__support__as_composite, parts, compositeConfig, content);
          icObj__support__as_composite.cType = "support";

          //SHU: illusion
          icObj__support__as_composite.fill = "transparent";

          infiniteCanvas.addIcObject(icObj__support__as_composite);
        }
          

      }


      manageClippingAdhesion(icObj, icObj__support) {
        logger.log("logFD", "manageAdhesion", icObj, icObj__support);
        const infiniteCanvas = this;

        //we suppose that icObj has already been added to iC

        if(icObj__support.type == "composite") {
          // //add as part
          // const icObj__rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();
          // icObj__support.dict_engine["composite"].engine.awoken.addPart(icObj__rep_free, false);
        } else if(infiniteCanvas.isCompositeContent(icObj__support)) {
          // //add as part in parent
          // const id__parent = icObj__support.compositeId; 
          // const parent__rep_free = infiniteCanvas.getRepresented(id__parent).r_free();

          // const icObj__rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();
          // parent__rep_free.dict_engine["composite"].engine.awoken.addPart(icObj__rep_free, false);
        } else if(infiniteCanvas.isCompositePart(icObj__support)) {

          // //promote icObj__support to composite

          //   //remove original version from parent
          // const id__parent = icObj__support.compositeId; 
          // const parent__rep_free = infiniteCanvas.getRepresented(id__parent).r_free();
          // parent__rep_free.dict_engine["composite"].engine.awoken.removePart(icObj__support);

          //   //create composite form
          // const trueRect__support__as_composite = {
          //   x:      icObj__support.position.x -  0 / (icObj__support.homeScale.X * icObj__support.scale.X),
          //   y:      icObj__support.position.y - 50 / (icObj__support.homeScale.Y * icObj__support.scale.Y),
          //   width:  30 / (icObj__support.homeScale.X * icObj__support.scale.X),
          //   height: 30 / (icObj__support.homeScale.Y * icObj__support.scale.Y),
          // };
          // const content         = icObj__support;
          // const parts           = Utils.dictFromArr([icObj]);
          // const contentAndParts = Object.assign({"content": content}, parts); 
          // const compositeConfig = Compositer.defaultCompositeConfig(contentAndParts, false);
          // const icObj__support__as_composite = infiniteCanvas.createIcComposite(trueRect__support__as_composite, parts, compositeConfig, content);
          // icObj__support__as_composite.cType = "support";
          
          // //SHU: illusion
          // icObj__support__as_composite.fill = "transparent";
          
          //   //add composite form
          // infiniteCanvas.onceOnAddRepresentedForIcObject(icObj__support__as_composite, (icObj__support__as_composite) => {

          //   const icObj__support__as_composite__rep_free = infiniteCanvas.getRepresented(icObj__support__as_composite.id).r_free();

          //   //add composite version to parent
          //   parent__rep_free.dict_engine["composite"].engine.awoken.addPart(icObj__support__as_composite__rep_free, false);
          // });
          // infiniteCanvas.addIcObject(icObj__support__as_composite);

        } else {

          // //promote icObj__support to composite

          //   //create composite form
          //   const trueRect__support__as_composite = {
          //   x:      icObj__support.position.x -  0 / (icObj__support.homeScale.X * icObj__support.scale.X),
          //   y:      icObj__support.position.y - 50 / (icObj__support.homeScale.Y * icObj__support.scale.Y),
          //   width:  30 / (icObj__support.homeScale.X * icObj__support.scale.X),
          //   height: 30 / (icObj__support.homeScale.Y * icObj__support.scale.Y),
          // };
          // const content         = ;
          // const parts           = Utils.dictFromArr([icObj]);
          // const contentAndParts = Object.assign({"content": content}, parts); 
          // const compositeConfig = Compositer.defaultCompositeConfig(contentAndParts, false);
          // const icObj__support__as_composite = infiniteCanvas.createIcComposite(trueRect__support__as_composite, parts, compositeConfig, content);
          // icObj__support__as_composite.cType = "support";

          // //SHU: illusion
          // icObj__support__as_composite.fill = "transparent";

          // infiniteCanvas.addIcObject(icObj__support__as_composite);

          const fObj__clipPath = fabricIntegration.getFObjForIcObj(icObj);
          fObj__clipPath.visible = false;

          if(icObj__support.clipPath == null) {
            const fObj__support = fabricIntegration.getFObjForIcObj(icObj__support);
            
            fObj__support.clipPath = fObj__clipPath;
          } else {
            //SHU: TODO: icObj__support already has clipPath...
          }

          fabricIntegration.fabricCanvas.renderAll();
          
        }
          

      }



      managePunchHoleErase(icObj, icObj__support) {
        logger.log("logFD", "managePunchHoleErase", icObj, icObj__support);
        const infiniteCanvas = this;

        const icObj__rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();

        // if(icObj__support.type == "composite") {
        //   //add as part
        //   const icObj__rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();
        //   // icObj__support.parts...
        // } else if(infiniteCanvas.isCompositeContent(icObj__support)) {
        //   //add as part in parent
        //   const id__parent = icObj__support.compositeId; 
        //   const parent__rep_free = infiniteCanvas.getRepresented(id__parent).r_free();

        //   const icObj__rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();
        //   parent__rep_free.dict_engine["composite"].engine.awoken.addPart(icObj__rep_free, false);
        // } else if(infiniteCanvas.isCompositePart(icObj__support)) {

        //   //promote icObj__support to composite

        //     //remove original version from parent
        //   const id__parent = icObj__support.compositeId; 
        //   const parent__rep_free = infiniteCanvas.getRepresented(id__parent).r_free();
        //   parent__rep_free.dict_engine["composite"].engine.awoken.removePart(icObj__support);

        //     //create composite form
        //   const trueRect__support__as_composite = {
        //     x:      icObj__support.position.x -  0 / (icObj__support.homeScale.X * icObj__support.scale.X),
        //     y:      icObj__support.position.y - 50 / (icObj__support.homeScale.Y * icObj__support.scale.Y),
        //     width:  30 / (icObj__support.homeScale.X * icObj__support.scale.X),
        //     height: 30 / (icObj__support.homeScale.Y * icObj__support.scale.Y),
        //   };
        //   const content         = icObj__support;
        //   const parts           = Utils.dictFromArr([icObj]);
        //   const contentAndParts = Object.assign({"content": content}, parts); 
        //   const compositeConfig = Compositer.defaultCompositeConfig(contentAndParts, false);
        //   const icObj__support__as_composite = infiniteCanvas.createIcComposite(trueRect__support__as_composite, parts, compositeConfig, content);
        //   icObj__support__as_composite.cType = "support";
          
        //   //SHU: illusion
        //   icObj__support__as_composite.fill = "transparent";
          
        //     //add composite form
        //   infiniteCanvas.onceOnAddRepresentedForIcObject(icObj__support__as_composite, (icObj__support__as_composite) => {

        //     const icObj__support__as_composite__rep_free = infiniteCanvas.getRepresented(icObj__support__as_composite.id).r_free();

        //     //add composite version to parent
        //     parent__rep_free.dict_engine["composite"].engine.awoken.addPart(icObj__support__as_composite__rep_free, false);
        //   });
        //   infiniteCanvas.addIcObject(icObj__support__as_composite);

        // } else {

        //   //promote icObj__support to composite

        //     //create composite form
        //     const trueRect__support__as_composite = {
        //     x:      icObj__support.position.x -  0 / (icObj__support.homeScale.X * icObj__support.scale.X),
        //     y:      icObj__support.position.y - 50 / (icObj__support.homeScale.Y * icObj__support.scale.Y),
        //     width:  30 / (icObj__support.homeScale.X * icObj__support.scale.X),
        //     height: 30 / (icObj__support.homeScale.Y * icObj__support.scale.Y),
        //   };
        //   const content         = icObj__support;
        //   const parts           = Utils.dictFromArr([icObj]);
        //   const contentAndParts = Object.assign({"content": content}, parts); 
        //   const compositeConfig = Compositer.defaultCompositeConfig(contentAndParts, false);
        //   const icObj__support__as_composite = infiniteCanvas.createIcComposite(trueRect__support__as_composite, parts, compositeConfig, content);
        //   icObj__support__as_composite.cType = "support";

        //   //SHU: illusion
        //   icObj__support__as_composite.fill = "transparent";

        //   infiniteCanvas.addIcObject(icObj__support__as_composite);
        // }
          
        // icObj__support.erasable = true; 
        // fObj.set('erasable', true);

        

      }


      manageApply(rep_free__over, rep_free__under) {
        logger.log("logApply", "manageApply", rep_free__over, rep_free__under);
        const infiniteCanvas = this;

        const rootObject = rep_free__over.getRootObject(infiniteCanvas);

        //find all valid targets for !apply!
        var arr_valid;
        if(rootObject.cType == "gm_applicable_operator") {
          arr_valid = [rootObject];
        } else if(rootObject.type == "composite") {
          const arr__contained = CompositeUtils.getAllContained(rootObject);
          logger.log("logApply", "manageApply", "arr__contained:", arr__contained);
          arr_valid = arr__contained.filter((icObj) => (icObj.cType == "gm_applicable_operator"));
        } else {
          arr_valid = [];
        }

        arr_valid.forEach((icObj__over) => {
          infiniteCanvas.manageApply__onOperator(icObj__over, rep_free__under);
        });
        
      }

      manageApply__onOperator(rep_free__over, rep_free__under) {

        function createStringForSwitch(str__mainType__over, str__mainType__under) {
          var outString = "";

          if(str__mainType__under == "gm_operator") {
            outString = "_ over gm_operator";
          } else if(str__mainType__over == "gm_operator") {
            outString = "gm_operator over _";
          }
          
          else if(str__mainType__under == "gm_applicable_operator") {
            outString = "_ over gm_applicable_operator";
          } else if(str__mainType__over == "gm_applicable_operator") {
            outString = "gm_applicable_operator over _";
          }
 
          else if(str__mainType__under == "array") {
            outString = "_ over array";
          } else if(str__mainType__over == "array") {
            outString = "array over _";
          }

          else {
            outString = "default";
          }
          return outString;
        }

        const str__mainType__over  = infiniteCanvas.getStrMainType(rep_free__over);
        const str__mainType__under = infiniteCanvas.getStrMainType(rep_free__under);
        const str__switch = createStringForSwitch(str__mainType__over, str__mainType__under);

        switch (str__switch) {
          // switch ([rep_free__over.type, rep_free__under.type]) {
            case "_ over gm_operator":
              {
                const icOperator = rep_free__under;
                const transformationFunc__icObj = icOperator.parts.touchSlot.touchSlotConfig.transformationFunc;
  
                transformationFunc__icObj(rep_free__over);
              }
              break;
            case "_ over gm_applicable_operator":
              {
                const icApplicableOperator = rep_free__under;
                const transformationFunc__icObj = icApplicableOperator.parts.applySlot.applySlotConfig.transformationFunc;
  
                transformationFunc__icObj(rep_free__over);
              }
              break;
  
            case "gm_operator over _":
              {
                logger.log("logApply", "manageApply", "gm_operator over _");
  
                const icOperator = rep_free__over;
                const transformationFunc__icObj = icOperator.parts.touchSlot.touchSlotConfig.transformationFunc;
  
                transformationFunc__icObj(rep_free__under);
              }
              break;
            case "gm_applicable_operator over _":
              {
                const icApplicableOperator = rep_free__over;
                const transformationFunc__icObj = icApplicableOperator.parts.applySlot.applySlotConfig.transformationFunc;
  
                transformationFunc__icObj(rep_free__under);
              }
              break;
            default:
              break;
          }

      }

      manageEnroll(miniDict_operation) {
        logger.log("logArray", "manageEnroll", miniDict_operation);

        const infiniteCanvas = this;

        switch(miniDict_operation.subType) {
          case "extend":
            {
              const rep_free__array = miniDict_operation.icArray;
              const rep_free__other = miniDict_operation.icArray__other;
              rep_free__array.dict_engine["array"].engine.awoken.extend(rep_free__other);
            }
            break;
          case "add":
            {
              const rep_free__array = miniDict_operation.icArray;
              const rep_free__other = miniDict_operation.icObj__other;
              rep_free__array.dict_engine["array"].engine.awoken.append(rep_free__other);
            }
            break;
          case "createArray":
            {
              const arr_icObj = miniDict_operation.arr_icObj;

              const true_cursor = this.getTrueCursor();
              const trueRect__icArray = {
                x: true_cursor.x,
                y: true_cursor.y,
                width:  30,
                height: 30,
              };
              const icArray = infiniteCanvas.createIcArray(trueRect__icArray, arr_icObj);

              // infiniteCanvas.onceOnAddRepresentedForIcObject(icArray, (icArray) => {
              //   const rep_free = infiniteCanvas.getRepresented(icArray.id).r_free();
              //   // infiniteCanvas.changeToSelected(rep_free);  
              // });

              infiniteCanvas.addIcObject(icArray);
            }
            break; 
        }

        //select iCArray
      }

      manageDeroll(miniDict_operation) {
        logger.log("logArray", "manageDeroll", miniDict_operation);

        // switch(miniDict_operation.subType) {
        //   case "popFirst":
        //     {
              const rep_free__array = miniDict_operation.icArray;
              rep_free__array.dict_engine["array"].engine.awoken.popFirst();

              //selected: first of rest
              const arr_icObj__rest = rep_free__array.arr_icObj;
              if(arr_icObj__rest.length > 0) {
                const icObj__first_of_rest = arr_icObj__rest[0];
                const rep_free__first_of_rest = infiniteCanvas.getRepresented(icObj__first_of_rest.id).r_free();
                // infiniteCanvas.changeToSelected(rep_free__first_of_rest);
              }
        //     }
        //     break;
        //   case "popLast":
        //     {
        //       const rep_free__array = miniDict_operation.icArray;
        //       const rep_free__other = miniDict_operation.icObj__other;
        //       rep_free__array.dict_engine["array"].engine.awoken.append(rep_free__other);
        //     }
        //     break;
        //   case "popRandom":
        //     {

        //     }
        //     break; 
        // }
      }



      //convenience

      getStrMainType(icObj) {
        var outString;

        if(icObj == null) {
          outString = "null";
        } else {

          // outString = ("t__" + icObj.type);
          outString = icObj.type;

          if(icObj.cType != null) {
            // outString = ("ct__" + icObj.cType);
            outString = icObj.cType;
          }

          if(icObj.cType != null && Utils.isString(icObj.cType) && (icObj.cType.length == 0)) {
            throw new Error("icObj has .cType: \"\"");
          }

        }

        return outString;
      }


      manageApplyCommand__setActiveColor__onUnderlying() {
        logger.log("logColor", "manageApplyCommand__setActiveColor__onUnderlying");
        const infiniteCanvas = this;

        const rep_free__underlying = infiniteCanvas.getIcObj__underCursor("free");
        logger.log("logColor", "manageApplyCommand__setActiveColor__onUnderlying", "rep_free__underlying:", rep_free__underlying);


        if(rep_free__underlying != null) {
          const rgbaColorString = inputProperties.getActiveRgbaColorString();
          infiniteCanvas.updateMainColorOfObject(rep_free__underlying, rgbaColorString);
        } else {
          //create underlying object: screenPov's povBackingRect
          const pov__screen = infiniteCanvas.getCurrentPov();

          const icObj__screenPovBackingRect = infiniteCanvas.createIcRect__backingPov(pov__screen);

          infiniteCanvas.onceOnAddRepresentedForIcObject(icObj__screenPovBackingRect, (icObj__screenPovBackingRect) => {

            const rep_free__screenPovBackingRect = infiniteCanvas.getRepresented(icObj__screenPovBackingRect.id).r_free();

            const rgbaColorString = inputProperties.getActiveRgbaColorString();
            infiniteCanvas.updateMainColorOfObject(rep_free__screenPovBackingRect, rgbaColorString);
          });

          infiniteCanvas.addIcObject(icObj__screenPovBackingRect);
          
        }

      }

      



      addNewIcObject(icObj) {
        // logger.log("addNewIcObject", icObj);

        icObj.orientation = this.orientation;

        const inputProperties = this.inputProperties;

        const activeColor = inputProperties.getActiveColor();
        
        const str__mainType = this.getStrMainType(icObj);
        logger.log("addNewIcObject", "str__mainType:", str__mainType);
        switch (str__mainType) {
          case "rect":
          case "point":
          case "sparkle":
          case "spot":
            icObj.fill = activeColor;
            break;
          case "text":
            icObj.textColor = activeColor;
            break;
          case "circle":
          case "ellipse":
          case "segment":
            icObj.stroke = activeColor;
            break;

          case "svg":
            icObj.stroke = activeColor;
            icObj.strokeWidth = 5;

            icObj.fill = "yellow";
            break;

          case "observer":
          case "trigger":
          case "eventEmitter":
          case "eventReceiver":
            break;

          case "eye":
            break;

          case "gm_operator":
          case "snapSlot":
            break;
          case "freeDrawing":
          case "floodFill":
            break;

          case "povRect":
            break;


          //composite
          case "freeDrawingObj":
          case "support":
            break;


          default:
            icObj.fill = activeColor;
            break;
        }

        icObj.opacity = inputProperties.getActiveOpacity();

        icObj.zIndex = this.getFreshIcZIndex__max();

        if(this.lock_homeScale_isActive) {
          icObj.homeScale = Object.assign({}, inputProperties.homeScale);
        }

        this.addIcObject(icObj);
      }

      addNewRect() {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const icRect = this.createIcRect_withLTWH(left, top, width, height);
        this.addNewIcObject(icRect);
      }

      addNewText(text = "icText") {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icText = this.createIcText(left, top, text);

        // //debug
        // const width  = 100;   //"information" size
        // const height = 100;
        // icText.width  = width;
        // icText.height = height;

        this.addNewIcObject(icText);
      }

      addNewHTMLObject(htmlObject = "<html><body>lol</body></html>") {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icHTMLObject = this.createIcHTMLObject(left, top, htmlObject);

        // //debug
        // const width  = 100;   //"information" size
        // const height = 100;
        // icText.width  = width;
        // icText.height = height;

        this.addNewIcObject(icHTMLObject);
      }

      addNewPDF(dict_pdf) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icPDF = this.createIcPDF(left, top, dict_pdf);

        this.addNewIcObject(icPDF);
      }

      addNewPDF_a(dict_pdf_a) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icPDF_a = this.createIcPDF_a(left, top, dict_pdf_a);

        this.addNewIcObject(icPDF_a);
      }

      addNewTag(text = "icTag") {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icTag = this.createIcTag(left, top, text);

        this.addNewIcObject(icTag);
      }


      addNewImage(img) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icImage = this.createIcImage(left, top, img);
        this.addNewIcObject(icImage);
      }

      addNewVideo(video) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icVideo = this.createIcVideo(left, top, video);
        this.addNewIcObject(icVideo);
      }

      addNewAudio(audio) {

        const true_cursor = this.getTrueCursor();

        const trueRect = {
          x: true_cursor.x,
          y: true_cursor.y,
          width:  300,
          height: 300,
        };

        const icAudio = this.createIcAudio(trueRect, audio);
        this.addNewIcObject(icAudio);
      }

      addNewCircle() {
        const true_cursor = this.getTrueCursor();
        const radius = 100;

        const icCircle = this.createIcCircle(true_cursor, radius, { isUsingCenterPosition: true, });
        this.addNewIcObject(icCircle);
      }

      addNewPoint() {
        const true_cursor = this.getTrueCursor();

        const icPoint = this.createIcPoint(true_cursor);
        this.addNewIcObject(icPoint);


        /*
        //debug
        const point_from = this.cursor;
        const center     = this.getScreenCenterPoint();

        [10,20,30,70,80,90,  270,300, -85].forEach((angleInDegrees, i) => {

          const screenPoint = Geometry.pointWithRotation(point_from, center, angleInDegrees);
          // console.log("screenPoint", screenPoint);

          this.addPoint(this.toTruePoint(screenPoint));
        });
        */

        // function debugRotation(point_from, center) {
        //
        //   [10,20,30,70,80,90].forEach((angleInDegrees, i) => {
        //
        //     const screenPoint = Geometry.pointWithRotation(point_from, center, angleInDegrees);
        //     this.addPoint(screenPoint);
        //   });
        //
        // }
        //
        // debugRotation(this.cursor, screenCenterPoint);


      }

      addNewSpotPoint() {
        const true_cursor = this.getTrueCursor();

        const size = {
          width: 30,
          height: 30,
        };

        const icSpotPoint = this.createIcSpotPoint(true_cursor, size);
        this.addNewIcObject(icSpotPoint);

      }

      addNewToggleRect() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const activeCfg = {
          fill: "green",
          opacity: 1.0,
        };
        const inactiveCfg = {
          fill: "red",
          opacity: 0.3,
        };

        const isActive = false;

        const icToggleRect = this.createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive);
        this.addNewIcObject(icToggleRect);
      }

      // addPurePoint(point) {
      //   const icPoint = this.createIcPoint(point);
      //   this.addPureIcObject(icPoint);
      // }
      //
      // addPureCircle(center, radius) {
      //
      //   const icCircle = this.createIcCircle(center, radius);
      //   this.addPureIcObject(icCircle);
      //
      // }

      addNewSvg(svgEl) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icSvg = this.createIcSvg(left, top, svgEl);
        this.addNewIcObject(icSvg);
      }

      addNewTex(tex) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icTex = this.createIcTex(left, top, tex);
        this.addNewIcObject(icTex);
      }

      addNewMathNode(mathNode) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icMathNode = this.createIcMathNode(left, top, mathNode);
        this.addNewIcObject(icMathNode);
      }

      addNewMNReictangle(mathNode) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icMNReictangle = this.createIcMNReictangle(left, top, mathNode);
        icMNReictangle.isTouchable = true;
        this.addNewIcObject(icMNReictangle);
      }

      addNewHtmlElt(html_elt) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const icHtmlElt = this.createIcHtmlElt(left, top, html_elt);
        this.addNewIcObject(icHtmlElt);
      }


      addNewSnapSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icSnapSlot = this.createIcSnapSlot(trueRect);
        this.addNewIcObject(icSnapSlot);
      }

      addNewSparkle(img) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        // const width  = 100;   //"information" size
        // const height = 100;

        // const trueRect = Geometry.createRect(left, top, width, height);

        const sparkleConfig = {

        };

        // const icSparkle = this.createIcSparkle(trueRect, img, sparkleConfig);
        const icSparkle = this.createIcSparkle(true_cursor, img, sparkleConfig);
        this.addNewIcObject(icSparkle);
      }


      addNewTouchSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };


        const toucher = Toucher.debugInstance();

        const touchSlotConfig = {
          transformationFunc: toucher.transformationFunc,
        };

        const icTouchSlot = this.createIcTouchSlot(trueRect, touchSlotConfig);
        this.addNewIcObject(icTouchSlot);
      }

      getNextTouchSlotRank() {
        var outNumber;
        const arr_touchSlot = Object.values(this.represented)
          .map(represented => represented.r_official())
          .filter(rep => (rep.type == "touchSlot"));
        outNumber = arr_touchSlot.length;
        return outNumber;
      }




      addNewComposite() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icComposite = this.createIcComposite_debug(trueRect);
        this.addNewIcObject(icComposite);
      }

      addNewP2P() {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icP2P = this.createIcP2P(trueRect);
        this.addNewIcObject(icP2P);
      }


      addNewIcCanvas() {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 320;   //"information" size
        const height = 180;

        const trueRect = {
          x:      left,
          y:      top,
          width:  width,
          height: height,
        };

        const icCanvas = this.createIcCanvas(trueRect);
        this.addNewIcObject(icCanvas);
      }




      addNewGreenMouseBox(mathNode) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icComposite = this.createIcGreenMouseBox(trueRect, mathNode);
        this.addNewIcObject(icComposite);
      }

      // composed(trueRect, arr_icObj) {
      //   var outIcObj;
      //
      //   const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
      //   const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
      //
      //   return outIcObj;
      // }


      addNewCollection(collectionStr) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const collectionConfig = this.parseCollectionStr(collectionStr);

        const icCollection = this.createIcCollection(trueRect, collectionConfig);
        this.addNewIcObject(icCollection);
      }

      parseCollectionStr(collectionStr) {
        var outConfig;

        var arr_elements = collectionStr.split("..");
        var min = parseInt(arr_elements[0]);
        var max = parseInt(arr_elements[1]);
        var step = 1;

        outConfig = {
          min: min,
          max: max,
          step: step,
        };

        return outConfig;
      }


      compose(arr_icObj) {
        logger.log("logComposite", "compose", arr_icObj);
        const infiniteCanvas = this;

        function debugTrueRect(infiniteCanvas) {
          const true_cursor = infiniteCanvas.getTrueCursor();

          const left = true_cursor.x;
          const top = true_cursor.y;

          const width = 100;   //"information" size
          const height = 100;

          const trueRect = {
            x: left,
            y: top,
            width: width,
            height: height,
          };

          return trueRect;
        }

        const trueRect = debugTrueRect(infiniteCanvas);
        console.log("trueRect", trueRect);

        const parts = arr_icObj; //SHU: arr is an obj with propNames = indexes
        // const parts = {
        //   "1": arr_icObj[0],
        //   "2": arr_icObj[1],
        // };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
        const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
        logger.log("logComposite", "compose", "icComposite:", icComposite);
        // icComposite.cType = cType;

        icComposite.isTouchable = true;

        icComposite.stroke      = "cyan";
        icComposite.strokeWidth = 5;




        //get tag object (if any)
        const tag = arr_icObj.find(icObj => icObj.type == "tag");

        var cType;
        if (tag != null) {
          cType = tag.text;
        } else {
          cType = "anonymous";
        }
        icComposite.cType = cType;


        if (tag != null) {
          //stick tag next to handle

          // tag.isMobile = false;
          // compositeConfig.parts[tag].isMobile = false;

          tag.position = {
            x: icComposite.position.x + icComposite.size.width,
            y: icComposite.position.y,
          };
        }



        this.addNewIcObject(icComposite);
        // this.addIcObject(icComposite);

      }

      decompose(icComposite) {
        console.log("decompose", icComposite);

        const arr_parts = Object.values(icComposite.parts);

        // arr_parts.forEach((part, i) => {
        //   part.compositeId     = -1;
        //   // part.isMobile        = false;
        // });

        // icComposite.engine.stop();
        icComposite.dict_engine["composite"].engine.awoken.stop();

        const represented = this.getRepresented(icComposite.id);
        const rep_free = represented.r_free();
        rep_free.im_dying_now = true;

        // this.removeRepresented(represented);
      }

      killComposite(icComposite) {
        console.log("killComposite", icComposite);

        const arr_parts = Object.values(icComposite.parts);



        // icComposite.engine.stop();
        icComposite.dict_engine["composite"].engine.awoken.stop();

        const represented = this.getRepresented(icComposite.id);
        const rep_free = represented.r_free();
        rep_free.im_dying_now = true;

        // this.removeRepresented(represented);



        arr_parts.forEach((icObj, i) => {
          if (icObj.type == "composite") {
            this.killComposite(icObj);
          } else {
            icObj.im_dying_now = true;
          }
        });


      }

      isCompositeContent(icObj) {
        var outBool;

        if(icObj.isCompositeContentOrPart()) {
          const id_parent = icObj.compositeId;
          const parent__rep_official = this.getRepresented(id_parent).r_official();
          if(parent__rep_official.content != null) {
            outBool = (parent__rep_official.content.id == icObj.id);
          } else {
            outBool = false;
          }
        } else {
          outBool = false;
        }

        return outBool;
      }

      isCompositePart(icObj) {
        var outBool;

        if(icObj.isCompositeContentOrPart()) {
          const id_parent = icObj.compositeId;
          const parent__rep_official = this.getRepresented(id_parent).r_official();
          outBool = (Object.values(parent__rep_official.parts).find(icObj__part => icObj__part.id == icObj.id) != null);
        } else {
          outBool = false;
        }

        return outBool;
      }




      link(icObj__1, icObj__2) {
        logger.log("infiniteCanvas::unlink", icObj__1, icObj__2);

        const infiniteCanvas = this;

        const icObj__link = infiniteCanvas.createIcLink();


      }

      unlink(icObj__link) {
        logger.log("infiniteCanvas::unlink", icObj__link);


      }


      spreadApart__centered(arr_icObj) {
        logger.log("spreadApart", arr_icObj);
        const infiniteCanvas = this;

        var isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);
        logger.log("spreadApart", "isIntersecting", isIntersecting);

        while (isIntersecting) {

          //spread push
          infiniteCanvas.spread_push(arr_icObj);

          isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);

        }

      }

      spreadApart__2by2(arr_icObj) {
        logger.log("spreadApart__2by2", arr_icObj);
        const infiniteCanvas = this;

        var isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);
        logger.log("spreadApart__2by2", "start: isIntersecting (all)", isIntersecting);

        while (isIntersecting) {

          //get all pairs
          const arr_pair = MathUtils.arrOfPairs(arr_icObj);
          logger.log("arr_pair", arr_pair);

          arr_pair.forEach(([icObj_1, icObj_2], i) => {
            logger.log("[icObj_1, icObj_2]", [icObj_1, icObj_2]);

            //spread pair if needed
            const isIntersecting__pairWise = infiniteCanvas.checkIntersecting([icObj_1, icObj_2]);
            if (isIntersecting__pairWise) {
              infiniteCanvas.spread_push__binary([icObj_1, icObj_2]);
            }
          });

          isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);
          logger.log("spreadApart__2by2", "while: isIntersecting (all)", isIntersecting);
        }

      }

      // spreadApart__recursive(arr_icObj) {
      //   logger.log("spreadApart", arr_icObj);
      //   const infiniteCanvas = this;
      //
      //   var isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);
      //   logger.log("spreadApart", "isIntersecting", isIntersecting);
      //
      //   while(isIntersecting) {
      //
      //     //spread push
      //     if(arr_icObj.length > 2) {
      //       const arr_tail = arr_icObj.slice(1);
      //       infiniteCanvas.spreadApart__recursive(arr_tail);
      //       isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);
      //     } else if(arr_icObj.length == 2) {
      //       infiniteCanvas.spread_push__binary(arr_icObj);
      //       isIntersecting = infiniteCanvas.checkIntersecting(arr_icObj);
      //     } else {
      //       isIntersecting = false;
      //     }
      //
      //   }
      //
      // }

      getTrueRect_hack(icObj) {
        const infiniteCanvas = this;

        const fObj = fabricIntegration.getFObjForIcObj(icObj);    //SHU: horror
        const screenRect = {
          left: fObj.left,
          top: fObj.top,
          width: fObj.width,
          height: fObj.height,
        };
        const trueRect = infiniteCanvas.toTrueRect(screenRect);
        return trueRect;
      }

      checkIntersecting(arr_icObj) {
        logger.log("checkIntersecting", arr_icObj);
        var outBool;

        const infiniteCanvas = this;

        const arr_pair = MathUtils.arrOfPairs(arr_icObj);

        outBool = Utils.early_break_reduce(arr_pair, (acc, [icObj_1, icObj_2], index, arr) => {

          // const rect__1 = infiniteCanvas.getTrueRect_hack(icObj_1);
          // const rect__2 = infiniteCanvas.getTrueRect_hack(icObj_2);
          // const isIntersecting__pair = Geometry.intersectRect(rect__1, rect__2);
          // logger.log("isIntersecting__pair", icObj_1.id, icObj_2.id, isIntersecting__pair);

          //SHU66667777

          const fObj__1 = fabricIntegration.getFObjForIcObj(icObj_1);   //SHU: global variable warning
          const fObj__2 = fabricIntegration.getFObjForIcObj(icObj_2);
          const isIntersecting__pair = fObj__1.intersectsWithObject(fObj__2);

          return acc || isIntersecting__pair;
        }, false, (acc, x, i, arr) => {
          return (acc == true);
        });

        return outBool;
      }

      getIntersection__compositeWise(arr_icObj) {

      }


      getBarycenter(arr_icObj) {
        var outPoint;

        outPoint = arr_icObj.reduce((acc, icObj) => {
          const pointCenter = {
            x: icObj.position.x + icObj.size.width / 2.0,
            y: icObj.position.y + icObj.size.height / 2.0,
          };
          return {
            x: acc.x + pointCenter.x,
            y: acc.y + pointCenter.y,
          };
        }, {
          x: 0,
          y: 0,
        });

        outPoint.x = math.floor(outPoint.x / arr_icObj.length);
        outPoint.y = math.floor(outPoint.y / arr_icObj.length);

        return outPoint;
      }

      spread_push(arr_icObj) {
        // logger.log("spread_push", arr_icObj);

        const infiniteCanvas = this;

        if (arr_icObj.length == 2) {
          infiniteCanvas.spread_push__binary(arr_icObj);
        } else {
          const point__barycenter = infiniteCanvas.getBarycenter(arr_icObj);
          arr_icObj.forEach((icObj, i) => {
            const factor__push = 1.1;
            infiniteCanvas.centered_push(point__barycenter, icObj, factor__push);
          });
        }

      }

      spread_push__binary(arr_icObj) {
        // logger.log("spread_push__binary", arr_icObj);

        const icObj_1 = arr_icObj[0];
        const icObj_2 = arr_icObj[1];

        // const rect__1 = icObj_1.getRect();
        // const rect__2 = icObj_2.getRect();
        const rect__1 = infiniteCanvas.getTrueRect_hack(icObj_1);
        const rect__2 = infiniteCanvas.getTrueRect_hack(icObj_2);

        // logger.log("rect__1", rect__1);

        const pointCenter1 = Geometry.getCenterPoint(rect__1);
        const pointCenter2 = Geometry.getCenterPoint(rect__2);
        // logger.log("pointCenter1", pointCenter1);

        var v__c1c2 = Geometry.vector_2d(pointCenter1, pointCenter2);
        // logger.log("v__c1c2", v__c1c2);


        const norm__c1c2 = Geometry.norm_2d(v__c1c2);
        // logger.log("norm__c1c2", norm__c1c2);

        const radius_1 = Geometry.getRectRadius(rect__1);
        const radius_2 = Geometry.getRectRadius(rect__2);
        // const radius_avg = (radius_1 + radius_2) / 2.0;
        const radius_max = Math.max(radius_1, radius_2);
        // logger.log("radius_1", radius_1);
        // logger.log("radius_2", radius_2);
        // logger.log("radius_max", radius_max);

        const factor__same = 0.03;
        const isSameCenter = (norm__c1c2 / radius_max) < factor__same;
        // logger.log("isSameCenter", isSameCenter);

        if (isSameCenter) {
          infiniteCanvas.spread_push__disambiguation(icObj_1, icObj_2);
        } else {
          const point__barycenter = infiniteCanvas.getBarycenter(arr_icObj);

          arr_icObj.forEach((icObj, i) => {
            const factor__push = 1.1;
            infiniteCanvas.centered_push(point__barycenter, icObj, factor__push);
          });
        }
      }

      spread_push__disambiguation(icObj_1, icObj_2) {
        // logger.log("spread_push__disambiguation", icObj_1, icObj_2);

        const infiniteCanvas = this;

        const point__barycenter = infiniteCanvas.getBarycenter([icObj_1, icObj_2]);

        const angleInDegrees__random = math.randomInt(0, 360);

        // const rect__1    = icObj_1.getRect();
        // const rect__2    = icObj_2.getRect();
        const rect__1 = infiniteCanvas.getTrueRect_hack(icObj_1);
        const rect__2 = infiniteCanvas.getTrueRect_hack(icObj_2);

        const radius_1 = Geometry.getRectRadius(rect__1);
        const radius_2 = Geometry.getRectRadius(rect__2);
        const radius_max = Math.max(radius_1, radius_2);

        const factor__push = 1.1;
        const radius__disambiguation = radius_max * factor__push;
        const pointOnCircle1 = Geometry.pointOnCircle__angleInDegrees(point__barycenter, radius__disambiguation, angleInDegrees__random);
        const v_trans1 = {
          x: pointOnCircle1.x - point__barycenter.x,
          y: pointOnCircle1.y - point__barycenter.y,
        };
        const v_trans2 = {
          x: -v_trans1.x,
          y: -v_trans1.y,
        };

        //push on opposite directions
        icObj_1.position = {
          x: icObj_1.position.x + v_trans1.x,
          y: icObj_1.position.y + v_trans1.y,
        };
        icObj_2.position = {
          x: icObj_2.position.x + v_trans2.x,
          y: icObj_2.position.y + v_trans2.y,
        };

      }

      centered_push(pointCenter, icObj, factor) {

        const infiniteCanvas = this;

        const pointTL__src = icObj.position;
        const point_center__src = {
          x: pointTL__src.x + icObj.size.width / 2.0,
          y: pointTL__src.y + icObj.size.height / 2.0,
        };
        const point_center__dst = Geometry.pointWithHomothety(point_center__src, pointCenter, factor);
        // logger.log("point_center__dst", point_center__dst);

        const pointTL__dst = {
          x: point_center__dst.x - icObj.size.width / 2.0,
          y: point_center__dst.y - icObj.size.height / 2.0,
        };

        //set new pos
        icObj.position = pointTL__dst;
      }







      getVessel(icObj) {
        var outIcObj;

        const id__parent = icObj.compositeId;
        if (id__parent != -1) {
          const rep_free__parent = this.getRepresented(id__parent).r_free();
          if (rep_free__parent.c_type == "vessel") {
            outIcObj = rep_free__parent;
          }
        }

        return outIcObj;
      }


      getSupervessel() {
        const supervessel__represented = Object.values(this.represented).find(represented => represented.r_official().isSupervessel);
        const supervessel__rep_free = supervessel__represented.r_free();
        return supervessel__rep_free;
      }


      operateOnSupervessel__moveStep(step_x, step_y) {
        logger.log("operateOnSupervessel__moveStep", step_x, step_y);

        const icSupervessel = this.getSupervessel();

        moveStep(icSupervessel, step_x, step_y);

        function moveStep(icObj, step_x, step_y) {

          const default_moveStep_length = 100;

          icObj.position = {
            x: icObj.position.x + step_x * default_moveStep_length,
            y: icObj.position.y + step_y * default_moveStep_length,
          };
        }

      }

      operateOnSupervessel__grab() {

        const infiniteCanvas = this;
        const icSupervessel = this.getSupervessel();
        logger.log("operateOnSupervessel__grab", icSupervessel);

        if (Object.values(icSupervessel.parts).length == 0) {
          attemptGrabbing(icSupervessel);
        } else {
          attemptUngrabbing(icSupervessel);
        }

        function attemptGrabbing(icSupervessel) {

          const arr_icObj__other = getArr_everyoneBut(icSupervessel);
          const arr_icObj__intersecting = getArr_intersecting(icSupervessel, arr_icObj__other);

          icSupervessel.dict_engine["composite"].engine.awoken.addParts(arr_icObj__intersecting);
        }

        function attemptUngrabbing(icSupervessel) {
          const isUngrabbingAllowed = true;

          if (isUngrabbingAllowed) {
            icSupervessel.dict_engine["composite"].engine.awoken.removeAllParts();
          }

        }

        function getArr_intersecting(icObj_solo, arr_icObj__other) {
          return arr_icObj__other.filter(icObj => {
            return Touch2Singleton.sharedInstance().isIntersecting(icObj, icObj_solo);
          });
        }

        function getArr_everyoneBut(icObj_solo) {
          const arr_all = infiniteCanvas.getArr_icObj("free");
          const arr_everyoneElse = arr_all.filter(icObj => icObj.id != icObj_solo.id);
          return arr_everyoneElse;
        }

      }



      getIcActiveSelection() {
        // return this.getAllRepresentedWithType("activeSelection").find(e => true).rep_free();
        return this.activeSelection;
      }

      operateOnActiveSelection__moveStep(step_x, step_y) {
        logger.log("operateOnActiveSelection__moveStep", step_x, step_y);

        //getIcActiveSelection
        const icActiveSelection = this.getIcActiveSelection();
        logger.log("icActiveSelection", icActiveSelection);

        moveStep(icActiveSelection, step_x, step_y);
        icActiveSelection.children.forEach(icObj => {
          moveStep(icObj, step_x, step_y);
        });


        function moveStep(icObj, step_x, step_y) {

          const default_moveStep_length = 100;

          icObj.position = {
            x: icObj.position.x + step_x * default_moveStep_length,
            y: icObj.position.y + step_y * default_moveStep_length,
          };
        }

      }




      operateOnActiveObject(opName) {
        return;
      }

      operateOnActiveObject__split() {

        const infiniteCanvas = this;

        //get supervessel
        const rep_free__supervessel = infiniteCanvas.getSupervessel();
        logger.log("rep_free__supervessel", rep_free__supervessel);

        //get cargo
        const arr_cargo = Object.values(rep_free__supervessel.parts);
        if (arr_cargo.length == 0) {
          //ignore            //SHU: ou alors faire surgir des paires du vide canvassien
          return;
        }
        const rep_free__cargo_1 = arr_cargo.find(e => true);

        //split
        function processSplitOutput(arr_components) {
          var outBool;

          if (arr_components.length > 0) {
            //remove original part
            rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(rep_free__cargo_1);

            //add parts: components
            arr_components.forEach((component, i) => {
              //add to infiniteCanvas
              infiniteCanvas.addIcObject(component);

              //get rep_free
              const rep_free__component = infiniteCanvas.getRepresented(component.id).r_free();

              //add to supervessel
              rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__component, false);
            });

            outBool = true;
          } else {
            outBool = false;
          }

          return outBool;
        }

        //if split was successful: perform replacement in supervessel
        // const arr_components = infiniteCanvas.splitObject(rep_free__cargo_1);
        // processSplitOutput(arr_components);

        infiniteCanvas.splitObject_p(rep_free__cargo_1)
          .then((arr_components) => {
            processSplitOutput(arr_components);
          });

      }

      splitObject(icObj) {
        var outArr;

        const infiniteCanvas = this;

        outArr = [];

        switch (icObj.type) {
          case "mathNode":
            {
              const mathNode = icObj.mathNode;

              const arr_components = Splitter.split_full(mathNode);

              outArr = arr_components.map((mathNode__component, i) => {
                const position = {
                  x: icObj.position.x + 50 * i,
                  y: icObj.position.y + 50 * i,
                };
                const icMathNode = infiniteCanvas.createIcMathNode(position.x, position.y, mathNode__component);
                return icMathNode;
              });

            }
            break;

          case "text":
            {
              const text = icObj.text;
              const arr_components = Splitter.split_string(text);

              outArr = arr_components.map((str__component, i) => {
                const position = {
                  x: icObj.position.x + 50 * i,
                  y: icObj.position.y + 50 * i,
                };
                const icText = infiniteCanvas.createIcText(position.x, position.y, str__component);
                return icText;
              });
            }
            break;

          case "image":
            {
              // const img = icObj.img;
              // // const fObj = icObj;
              //
              // const arr_img = infiniteCanvas.splitImage(img);
              //
              // outArr = arr_img.map((img__component, i) => {
              //   const position = {
              //     x: icObj.position.x + 50 * i,
              //     y: icObj.position.y + 50 * i,
              //   };
              //   const icImage = infiniteCanvas.createIcImage(position.x, position.y, img__component);
              //   return icImage;
              // });
            }
            break;

          case "bag":
            break;


          default:
            break;
        }

        return outArr;
      }

      splitObject_p(icObj) {
        var out_p;

        const infiniteCanvas = this;

        switch (icObj.type) {
          case "mathNode":
            {
              const mathNode = icObj.mathNode;

              const arr_components = Splitter.split_full(mathNode);

              const arr_icObj = arr_components.map((mathNode__component, i) => {
                const position = {
                  x: icObj.position.x + 50 * i,
                  y: icObj.position.y + 50 * i,
                };
                const icMathNode = infiniteCanvas.createIcMathNode(position.x, position.y, mathNode__component);
                return icMathNode;
              });

              out_p = Promise.resolve(arr_icObj);

            }
            break;

          case "text":
            // {
            //   const text = icObj.text;
            //   const arr_components = Splitter.split_string(text);
            //
            //   const arr_icObj = arr_components.map((str__component, i) => {
            //     const position = {
            //       x: icObj.position.x + 50 * i,
            //       y: icObj.position.y + 50 * i,
            //     };
            //     const icText = infiniteCanvas.createIcText(position.x, position.y, str__component);
            //     return icText;
            //   });
            //
            //   out_p = Promise.resolve(arr_icObj);
            // }

            //rainbow split
            {
              const text = icObj.text;
              const arr_components = Splitter.split_string(text);

              const length = arr_components.length;
              const arr_color = ColorUtils.rainbow__random_arr_of_length(length, 1);
              logger.log("log1", "arr_color", arr_color);

              const arr_zipped = Utils.zip(arr_components, arr_color);

              const arr_icObj = arr_zipped.map(([str__component, color], i) => {
                const position = {
                  x: icObj.position.x + 50 * i,
                  y: icObj.position.y + 50 * i,
                };
                const icText = infiniteCanvas.createIcText(position.x, position.y, str__component);

                icText.textColor = color;

                return icText;
              });

              out_p = Promise.resolve(arr_icObj);
            }
            break;

          case "image":
            {
              const img = icObj.img;
              // const fObj = icObj;

              // out_p = infiniteCanvas.splitImage_p(img)
              out_p = infiniteCanvas.splitImage2_p(img)
                .then((arr_img) => {

                  const arr_icObj = arr_img.map((img__component, i) => {
                    const position = {
                      x: icObj.position.x + 50 * i,
                      y: icObj.position.y + 50 * i,
                    };
                    const icImage = infiniteCanvas.createIcImage(position.x, position.y, img__component);
                    return icImage;
                  });

                  return arr_icObj;
                })
                .catch((e) => {
                  logger.log(e);
                });
            }
            break;

          // case "bag":
          //   break;
          default:
            out_p = Promise.reject(new Error("splitObject_p, unsupported icObj.type: " + icObj.type));
            break;
        }

        return out_p;
      }

      splitImage_p(img) {
        var out_p;

        // logger.log("splitImage_p, img", img);
        // logger.log("img.src", img.src);

        // img.setAttribute("crossOrigin", "Anonymous");
        // img.crossOrigin = 'Anonymous';

        function createDataURL__img_p(img) {
          var out_p;

          const isSimpleURL = img.src.startsWith("file://")
            || img.src.startsWith("http://")
            || img.src.startsWith("https://");

          if (isSimpleURL) {
            out_p = FileIntegration.dataUrlForImgViaCanvas_p(img);
          } else {
            out_p = Promise.resolve(img.src);
          }

          return out_p;
        }

        function createFObj_p(dataURL__img) {
          var out_p;

          logger.log("dataURL__img", dataURL__img);

          out_p = new Promise((resolve, reject) => {
            fabric.Image.fromURL(dataURL__img, function (fObj, isError) {
              if (isError) {
                const error = new Error("fabric.Image.fromURL, error");
                reject(error);
              }
              resolve(fObj);
            }, { crossOrigin: 'Anonymous' });
          });

          return out_p;
        }

        function splitFObj_p(fObj, width, height) {
          var out_p;

          const fObjOrfCanvas = fObj;

          const height__half = height / 2.0;

          const rect__top = {
            left: 0,
            top: 0,
            width: width,
            height: height__half,
          };
          const dataURL__top = FileIntegration.dataURLForRect(fObjOrfCanvas, rect__top);
          // logger.log("dataURL__top", dataURL__top);
          const img__top_p = FileIntegration.imageFromImgSrc_p(dataURL__top);

          const rect__bottom = {
            left: 0,
            top: height__half,
            width: width,
            height: height__half,
          };
          const dataURL__bottom = FileIntegration.dataURLForRect(fObjOrfCanvas, rect__bottom);
          // logger.log("dataURL__bottom", dataURL__bottom);
          const img__bottom_p = FileIntegration.imageFromImgSrc_p(dataURL__bottom);

          const arr_p = [img__top_p, img__bottom_p];
          out_p = Promise.all(arr_p)
            .then((arr_img) => {

              //clean canvas
              // fabricCanvas__tool.remove(fObj);
              // fabricCanvas__tool.renderAll();

              return arr_img;

              // const arr_img__custom = arr_img.map(img => {
              //   img.setAttribute("crossorigin", "anonymous");
              //   return img;
              // });
              // return arr_img__custom;
            });

          return out_p;
        }




        const width = img.width;
        const height = img.height;

        const fObj_p = createDataURL__img_p(img)
          .then((dataURL__img) => {
            return createFObj_p(dataURL__img);
          });
        // const fCanvas_p = fObj_p.then((fObj) => {
        //   //prepare canvas
        //   fabricCanvas__tool.add(fObj);
        //   fabricCanvas__tool.renderAll();
        //
        //   return fabricCanvas__tool;
        // });

        out_p = fObj_p.then((fObj) => {
          logger.log("fObj", fObj);
          return splitFObj_p(fObj, width, height);
        });

        return out_p;
      }

      splitImage2_p(img) {
        var out_p;

        // logger.log("splitImage_p, img", img);
        // logger.log("img.src", img.src);

        // img.setAttribute("crossOrigin", "Anonymous");
        // img.crossOrigin = 'Anonymous';

        function createDataURL__img_p(img) {
          var out_p;

          const isSimpleURL = img.src.startsWith("file://")
            || img.src.startsWith("http://")
            || img.src.startsWith("https://");

          if (isSimpleURL) {
            out_p = FileIntegration.dataUrlForImgViaCanvas_p(img);
          } else {
            out_p = Promise.resolve(img.src);
          }

          return out_p;
        }

        function createFObj_p(dataURL__img) {
          var out_p;

          logger.log("dataURL__img", dataURL__img);

          out_p = new Promise((resolve, reject) => {
            fabric.Image.fromURL(dataURL__img, function (fObj, isError) {
              if (isError) {
                const error = new Error("fabric.Image.fromURL, error");
                reject(error);
              }
              resolve(fObj);
            }, { crossOrigin: 'Anonymous' });
          });

          return out_p;
        }

        function dataURLForClipPath(fObjOrfCanvas, clipPath) {
          var outDataURL;

          fObjOrfCanvas.clipPath = clipPath;

          //get pixelwise bounding rect     //SHU: TODO

          // const printOptions = Object.assign({}, rect__print);
          const printOptions = {};
          outDataURL = fObjOrfCanvas.toDataURL(printOptions);

          return outDataURL;
        }

        function splitFObj_p(fObj, width, height) {
          var out_p;

          const fObjOrfCanvas = fObj;

          const pointA = Geometry.createPoint(0, 0.2 * height);
          const pointB = Geometry.createPoint(width - 1, 0.7 * height);
          const lineAB = Geometry.createLine(pointA, pointB);

          const pointTL = Geometry.createPoint(0, 0);
          const pointTR = Geometry.createPoint(width, 0);
          const pointBL = Geometry.createPoint(0, height);
          const pointBR = Geometry.createPoint(width, height);

          const polygon__top = new fabric.Polygon([
            pointTL,
            pointTR,
            pointB,
            pointA,
          ]);
          polygon__top.absolutePositioned = true;

          const dataURL__top = dataURLForClipPath(fObjOrfCanvas, polygon__top);
          // logger.log("dataURL__top", dataURL__top);
          const img__top_p = FileIntegration.imageFromImgSrc_p(dataURL__top);

          const polygon__bottom = new fabric.Polygon([
            pointA,
            pointB,
            pointBR,
            pointBL,
          ]);
          polygon__bottom.absolutePositioned = true;

          const dataURL__bottom = dataURLForClipPath(fObjOrfCanvas, polygon__bottom);
          // logger.log("dataURL__top", dataURL__top);
          const img__bottom_p = FileIntegration.imageFromImgSrc_p(dataURL__bottom);

          const arr_p = [img__top_p, img__bottom_p];
          out_p = Promise.all(arr_p)
            .then((arr_img) => {

              //clean canvas
              // fabricCanvas__tool.remove(fObj);
              // fabricCanvas__tool.renderAll();

              return arr_img;

              // const arr_img__custom = arr_img.map(img => {
              //   img.setAttribute("crossorigin", "anonymous");
              //   return img;
              // });
              // return arr_img__custom;
            });

          return out_p;
        }




        const width = img.width;
        const height = img.height;

        const fObj_p = createDataURL__img_p(img)
          .then((dataURL__img) => {
            return createFObj_p(dataURL__img);
          });
        // const fCanvas_p = fObj_p.then((fObj) => {
        //   //prepare canvas
        //   fabricCanvas__tool.add(fObj);
        //   fabricCanvas__tool.renderAll();
        //
        //   return fabricCanvas__tool;
        // });

        out_p = fObj_p.then((fObj) => {
          logger.log("fObj", fObj);
          return splitFObj_p(fObj, width, height);
        });

        return out_p;
      }


      operateOnActiveObject__export_asImg() {

        const infiniteCanvas = this;

        //get supervessel
        const rep_free__supervessel = infiniteCanvas.getSupervessel();
        logger.log("rep_free__supervessel", rep_free__supervessel);

        //get cargo
        const arr_cargo = Object.values(rep_free__supervessel.parts);
        if (arr_cargo.length == 0) {
          //ignore            //SHU: ou alors faire surgir des paires du vide canvassien
          return;
        }
        const rep_free__cargo_1 = arr_cargo.find(e => true);

        //export
        this.exportObj_asImg(rep_free__cargo_1);
      }

      exportObj_asImg(icObj) {
        logger.log("exportObj_asImg", icObj);
        const fObj = fabricIntegration.getFObjForIcObj(icObj);    //SHU: magic rabbit: "fabricIntegration"...
        logger.log("fObj", fObj);

        const rect = {
          left: 0,
          top:  0,
          width:  fObj.width,
          height: fObj.height,
        };
        const dataURL = FileIntegration.dataURLForRect(fObj, rect);
        logger.log("dataURL", dataURL);

        // const img = FileIntegration.imageFromImgSrc_p(dataURL);

        FileIntegration.save_image(dataURL);
      }

      dataUrl_for_canvasRectContainingObj(icObj, filename = null) {
        logger.log("dataUrl_for_canvasRectContainingObj", icObj);
        const fObj = fabricIntegration.getFObjForIcObj(icObj);    //SHU: magic rabbit: "fabricIntegration"...
        logger.log("fObj", fObj);

        const fCanvas = fabricIntegration.fabricCanvas;

        const rect = {
          left:   fObj.left,
          top:    fObj.top,
          width:  fObj.width,
          height: fObj.height,
        };
        const dataURL = FileIntegration.dataURLForRect(fCanvas, rect);

        return dataURL;
      }

      exportCanvasRectContainingObj_asImg(icObj, filename = null) {
        //SHU: workflow with iC.scale change is a bit ugly but it works well

        const infiniteCanvas = this;

        //store iC.scale
        const scale_tmp = Object.assign({}, infiniteCanvas.scale);

        //set iC.scale = obj.scale 
        const scale_obj = {
          X: icObj.homeScale.X * icObj.scale.X,
          Y: icObj.homeScale.Y * icObj.scale.Y,
        };
        infiniteCanvas.updateScaleAndDOffset(scale_obj, {dx: 0, dy: 0});
        infiniteCanvas.redrawCanvas(RedrawOccasion.scaleChanged);

        {
          const dataURL = infiniteCanvas.dataUrl_for_canvasRectContainingObj(icObj, filename);
          // logger.log("dataURL", dataURL);

          FileIntegration.save_image(dataURL, filename);
        }

        //restore iC.scale
        infiniteCanvas.updateScaleAndDOffset(scale_tmp, {dx: 0, dy: 0});
        infiniteCanvas.redrawCanvas(RedrawOccasion.scaleChanged);

      }



      operateOnActiveObject__join() {

        const infiniteCanvas = this;

        //get supervessel
        const rep_free__supervessel = infiniteCanvas.getSupervessel();
        logger.log("rep_free__supervessel", rep_free__supervessel);

        //get cargo
        const arr_cargo = Object.values(rep_free__supervessel.parts);
        if (arr_cargo.length == 0) {
          //ignore            //SHU: ou alors faire surgir des paires du vide canvassien
          return;
        }

        //join
        const icObj__joined = infiniteCanvas.joinObjects(arr_cargo);

        //if join was successful: perform replacement in supervessel
        if (icObj__joined != null) {
          //remove original parts
          arr_cargo.forEach((rep_free__cargo, i) => {
            rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(rep_free__cargo);
          });

          //add part: joined
          {
            //add to infiniteCanvas
            infiniteCanvas.addIcObject(icObj__joined);

            //get rep_free
            const rep_free__joined = infiniteCanvas.getRepresented(icObj__joined.id).r_free();

            //add to supervessel
            rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__joined, false);
          }


        }

      }

      joinObjects(arr_icObj) {
        var outIcObj;

        const infiniteCanvas = this;

        const typeDescription = infiniteCanvas.createTypeDescription(arr_icObj);

        if (typeDescription.type == "single") {
          const icObjType = typeDescription.arr_type.find(e => true);
          switch (icObjType) {
            case "mathNode":
              {
                const arr_mathNode = arr_icObj.map(icObj => icObj.mathNode);
                const mathNode__joined = Joiner.random_join(arr_mathNode);

                const icObj = arr_icObj.find(e => true);
                const position = {
                  x: icObj.position.x,
                  y: icObj.position.y,
                };

                const icMathNode = infiniteCanvas.createIcMathNode(position.x, position.y, mathNode__joined);
                outIcObj = icMathNode;
              }
              break;
            case "text":
              {

              }
              break;
            default:
              break;
          }
        } else {

        }

        return outIcObj;
      }

      operateOnActiveObject__coreify() {

        const infiniteCanvas = this;

        //get supervessel
        const rep_free__supervessel = infiniteCanvas.getSupervessel();
        logger.log("rep_free__supervessel", rep_free__supervessel);

        //get cargo
        const arr_cargo = Object.values(rep_free__supervessel.parts);
        if (arr_cargo.length == 0) {
          //ignore            //SHU: ou alors faire surgir des paires du vide canvassien
          return;
        }
        const rep_free__cargo_1 = arr_cargo.find(e => true);


        const specimen = rep_free__cargo_1;

        //create core
        const icCore = infiniteCanvas.createIcCore(specimen);

        //add core
        infiniteCanvas.addIcObject(icCore);



        //find alike
        // const arr_alike = this.getAlikeForIcObject(specimen);

        //set alike
        // icCore.addArrAlike(arr_alike);
      }

      getAlikeForIcObject(icObj) {
        var outArr;

        const arr_sameType = this.getAllRepresentedWithType(icObj.type).map(represented => represented.r_free());

        const identifyingContent__icObj = this.getIdentifyingContentForIcObject(icObj);
        const arr_sameIdentifyingContent = arr_sameType.filter(icObj_candidate => {
          const identifyingContent__candidate = this.getIdentifyingContentForIcObject(icObj_candidate);
          const isSameIdentifyingContent = (identifyingContent__candidate == identifyingContent__icObj);
          return isSameIdentifyingContent;
        });

        outArr = arr_sameIdentifyingContent;

        return outArr;
      }

      getIdentifyingContentForIcObject(icObj) {
        var outObj;

        switch (icObj.type) {
          case "mathNode":
            {
              const mathNode = icObj.mathNode;
              if (mathNode instanceof math.ConstantNode) {
                outObj = icObj.mathNode.value;
              } else if (mathNode instanceof math.SymbolNode) {
                outObj = icObj.mathNode.name;
              } else {
                outObj = icObj.mathNode.toString();
              }
            }
            break;
          case "text":
            {
              outObj = icObj.text;
            }
            break;
          case "image":
            {
              outObj = icObj.img.src;
            }
            break;
          default:
            {
              throw new Error("object has no known identifying content");
            }
            break;
        }

        return outObj;
      }




      scaledObject(icObj, mode, factor) {
        var outIcObj;



        return outIcObj;
      }

      unitCloneScaledObject(icObj, mode, factor) {
        var outIcObj;




        return outIcObj;
      }




      createTypeDescription(arr_icObj) {
        var outTypeDesc = {};

        const arr_type__all = arr_icObj.map(icObj => icObj.type);

        const set_type = new Set(arr_type__all);
        const arr_type__distinct = [...set_type];
        outTypeDesc.arr_type = arr_type__distinct;

        if (arr_type__distinct.length == 1) {
          outTypeDesc.type = "single";
        } else {
          outTypeDesc.type = "multi";
        }

        return outTypeDesc;
      }



      operateOnObject__poopSameScaleClone(icObj) {
        logger.log("logOperate", "operateOnObject__poopSameScaleClone", "icObj:", icObj);

        const icObj__clone = icObj.deepClone();
        logger.log("logOperate", "operateOnObject__poopSameScaleClone", "icObj__clone:", icObj__clone);

        //shift id(s)
        if(icObj__clone.type == "composite") { 
          CompositeUtils.shiftToNextAvailableId(icObj__clone, icObj, infiniteCanvas);
        } else {
          icObj__clone.id = infiniteCanvas.generateIcObjectId(); 
        }

        icObj__clone.position = Object.assign({}, icObj.position);
        icObj__clone.position.x = icObj__clone.position.x;
        icObj__clone.position.y = icObj__clone.position.y;

        infiniteCanvas.onceOnAddRepresentedForIcObject(icObj__clone, (icObj__clone) => {
          const rep_free__clone = infiniteCanvas.getRepresented(icObj__clone.id).r_free();
          rep_free__clone.homeScale = Object.assign({}, icObj.homeScale);

          logger.log("rep_free__clone.id", rep_free__clone.id);
        });



        infiniteCanvas.addIcObject(icObj__clone);
      }


      getActiveObject() {
        const infiniteCanvas = this;

        //get supervessel
        const rep_free__supervessel = infiniteCanvas.getSupervessel();
        logger.log("rep_free__supervessel", rep_free__supervessel);

        //get cargo
        const arr_cargo = Object.values(rep_free__supervessel.parts);
        if (arr_cargo.length == 0) {
          //ignore            //SHU: ou alors faire surgir des paires du vide canvassien
          return;
        }

        const icObj = arr_cargo.find(e => true);

        return icObj;
      }

      operateOnActiveObject__executeScript() {
        const infiniteCanvas = this;

        const icObj = infiniteCanvas.getActiveObject();

        const isIcText = icObj.type == "text";
        if (isIcText) {
          const icText = icObj;

          const transformationOutput = infiniteCanvas.executeScript_fromIcText(icText);
          logger.log("transformationOutput", transformationOutput);

          if (transformationOutput.type == "new") {

            const icObj__new = transformationOutput.value;
            icObj__new.fill = "yellow";

            //remove original parts
            arr_cargo.forEach((rep_free__cargo, i) => {
              rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(rep_free__cargo);
            });

            //add part: joined
            {
              //add to infiniteCanvas
              infiniteCanvas.addIcObject(icObj__new);

              //get rep_free
              const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();

              //add to supervessel
              rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new, false);
            }
          }

        }

      }

      executeScript_fromIcText(icText) {
        var transformationOutput;

        const text = icText.text;

        {
          //script context
          const infiniteCanvas = this;
          const trueRect = {
            x: icText.position.x,
            y: icText.position.y,
            width: icText.size.width,
            height: icText.size.height,
          };

          var scriptOutput;
          // const scriptOutput = eval(text);
          eval(text);
          logger.log("scriptOutput", scriptOutput);

          if (scriptOutput instanceof IcObject) {

            transformationOutput = new TransformationOutput("new", scriptOutput, icText);

          } else {
            transformationOutput = new TransformationOutput("old", icText, icText);
          }
        }

        return transformationOutput;
      }


      operateOnActiveObject__toggleProperty(propName) {

        const infiniteCanvas = this;

        const icObj__cargo = infiniteCanvas.getActiveObject();
        infiniteCanvas.toggleIcObjProperty(icObj__cargo, propName);
      }

      // operateOnActiveObject__setBehavior(behaviorName, isOn) {
      //
      //   const infiniteCanvas = this;
      //
      //   const icObj = infiniteCanvas.getActiveObject();
      //
      //   const value = icObj[propName];
      //   if(value != null) {
      //     if(typeof value == "boolean") {
      //       icObj[behaviorName] = !value;
      //     } else {
      //       throw new Error("icObj[propName] is not boolean");
      //     }
      //   } else {
      //     throw new Error("icObj[propName] == null");
      //   }
      //
      // }


      createReplicant(icObj) {
        const icObj_clone = icObj.deepClone();
        const id__clone = infiniteCanvas.generateIcObjectId();
        icObj_clone.id = id__clone;

        return icObj_clone;
      }


      operateOnActiveObject__poopSameHomeScaleClone() {
        const infiniteCanvas = this;

        const icObj__mould = infiniteCanvas.getActiveObject();
        infiniteCanvas.operateOnObject__poopSameScaleClone(icObj__mould);
      }

      operateOnActiveObject__poopGeminiShade() {
        const infiniteCanvas = this;

        const icObj__mould = infiniteCanvas.getActiveObject();

        const icObj__geminiShade = infiniteCanvas.createIcGeminiShade(icObj__mould);

        icObj__geminiShade.position = Object.assign({}, icObj__mould.position);
        icObj__geminiShade.position.x = icObj__geminiShade.position.x * 1.10;
        icObj__geminiShade.position.y = icObj__geminiShade.position.y * 1.10;

        infiniteCanvas.addIcObject(icObj__geminiShade);
      }




      getSelectedIcObj() {
        const fabricCanvas    = fabricIntegration.fabricCanvas;   //SHU: global variable warning
        const fObj__selected  = fabricCanvas.getActiveObject();
        const icObj__selected = fObj__selected?.icObj;
        return icObj__selected;
      }

      getSelectedEntity() {
        const icObj__selected    = this.getSelectedIcObj();
        const icEntity__selected = this.getEntity(icObj__selected); 
        return icEntity__selected;
      }

      operateOnSelected__poopSameHomeScaleClone() {
        const infiniteCanvas = this;

        // const icObj__selected = infiniteCanvas.getSelectedIcObj();
        const icEntity__selected = infiniteCanvas.getSelectedEntity();
        infiniteCanvas.operateOnObject__poopSameScaleClone(icEntity__selected);
      }


      operateOnSelected__adhere() {
        const infiniteCanvas = this;

        //get selected icObj
        const icObj__selected = infiniteCanvas.getSelectedIcObj();

        //get underlying support (with zIndex just below)
        const icObj__support = infiniteCanvas.getCandidateSupportForIcObj(icObj__selected);
        
        if(icObj__support != null) {
          infiniteCanvas.manageAdhesion(icObj__selected, icObj__support);
        }
      }


      operateOnSelected__unadhere() {   //SHU: TODO
        // const infiniteCanvas = this;

        // //get selected icObj
        // const fabricCanvas    = fabricIntegration.fabricCanvas;
        // const fObj__selected  = this.fabricCanvas.getActiveObject();
        // const icObj__selected = fObj__selected.icObj;

        // //get underlying support (with zIndex just below)

        
        
        // infiniteCanvas.addIcObject(icObj__geminiShade);
      }

      operateOnSelected__clippingAdhere() {
        const infiniteCanvas = this;

        //get selected icObj
        const icObj__selected = infiniteCanvas.getSelectedIcObj();

        //get underlying support (with zIndex just below)
        const icObj__support = infiniteCanvas.getCandidateSupportForIcObj(icObj__selected);
        
        if(icObj__support != null) {
          infiniteCanvas.manageClippingAdhesion(icObj__selected, icObj__support);
        }
      }


      operateOnSelected__punchHoleErase() {
        logger.log("logOOS", "operateOnSelected__punchHoleErase");
        const infiniteCanvas = this;

        //get selected icObj
        const icObj__selected = infiniteCanvas.getSelectedIcObj();

        //get underlying support (with zIndex just below)
        const icObj__support  = infiniteCanvas.getCandidateSupportForIcObj(icObj__selected);
        
        if(icObj__support != null) {
          infiniteCanvas.managePunchHoleErase(icObj__selected, icObj__support);
        }
      }


      operateOnSelected__toggleProperty(propName) {
        const infiniteCanvas = this;
        const icObj__selected = infiniteCanvas.getSelectedIcObj();

        infiniteCanvas.toggleIcObjProperty(icObj__selected, propName);
      }

      toggleIcObjProperty(icObj, propPath) {
        const value = Utils.getPropForPropPath(icObj, propPath);
        if (value != null) {
          if (typeof value == "boolean") {
            Utils.setPropAtPropPath(icObj, propPath, !value);
          } else {
            throw new Error("icObj[propPath] is not boolean");
          }
        } else {
          throw new Error("icObj[propPath] == null");
        }
      }



      operateOnSelected__warp() {
        logger.log("logOOS", "operateOnSelected__warp");
        const infiniteCanvas = this;

        //get selected icObj
        const icObj__selected = infiniteCanvas.getSelectedIcObj();

        function trueWarpCoords(icObj) {
          var outPos = {
            x: 0,
            y: 0,
          };

          if(icObj.type == "mathNode") {

            const mathNode = icObj.mathNode;
            logger.log("logOOS", "mathNode", mathNode);

            if(mathNode instanceof math.ObjectNode) {
              outPos = {
                x: mathNode.properties["x"].value,
                y: mathNode.properties["y"].value,
              };
            } else {

              if(mathNode.value instanceof math.Complex) {
                outPos = {
                  x: mathNode.value.re,
                  y: mathNode.value.im,
                };
              } else {
                outPos = {
                  x: mathNode.value,
                  y: 0,
                };
              }

            }
  
          }

          return outPos;
        }

        function createTeachingCoords(truePos) {
          var outPos;

          const factor = 50;

          outPos = {
            x: truePos.x * (+1) * factor,
            y: truePos.y * (-1) * factor,
          };

          return outPos;
        }

        //SHU: it would be nice if obj.position and screenPov could change "simultaneously"

        const coords__trueWarp = trueWarpCoords(icObj__selected);
        const coords__teaching = createTeachingCoords(coords__trueWarp);
        logger.log("logWARP", "coords__teaching", coords__teaching);
        icObj__selected.position = coords__teaching;

          //change screenPov if necessary
        if(icObj__selected.isHeld) {
          const trueRect__screen__100 = infiniteCanvas.getShownRect();
          logger.log("logWARP", "trueRect__screen__100", trueRect__screen__100);
          trueRect__screen__100.left = trueRect__screen__100.x; 
          trueRect__screen__100.top  = trueRect__screen__100.y;
          const trueRect__screen__90  = Geometry.getCenterScaledRect(trueRect__screen__100, 0.9);
          const isNewPositionInsideScreenPov90 = Geometry.isPointContainedInRect(coords__teaching, trueRect__screen__90);
          logger.log("logWARP", "isNewPositionInsideScreenPov90", isNewPositionInsideScreenPov90);
          if(!isNewPositionInsideScreenPov90) {
            const cfg_anim__easy = {
              duration: 10,
            };
            const trueRect__screen__100__new = {
              x: trueRect__screen__100.x + coords__teaching.x - Geometry.getCenterPoint(Geometry.createLTRect(trueRect__screen__100)).x,
              y: trueRect__screen__100.y + coords__teaching.y - Geometry.getCenterPoint(Geometry.createLTRect(trueRect__screen__100)).y,
              width:  trueRect__screen__100.width,
              height: trueRect__screen__100.height,
            };
            infiniteCanvas.move_to_rect__animation(trueRect__screen__100__new, cfg_anim__easy);
          }
        }

      }

      operateOnSelected__apply() {    //this is the !apply_X! switch (!apply_enroll!, !apply!, ...)
        const infiniteCanvas = this;

        //get selected icObj
        const icObj__selected = infiniteCanvas.getSelectedIcObj();

        

        const icObj__over   = icObj__selected;

        //get underlying icObj
        const icObj__under  = infiniteCanvas.getApplyCandidateForIcObj(icObj__selected);

        //arr: [obj, parent, root]
        function createArr_obj_parent_root(icObj) {
          var parent;
          try {
            parent = infiniteCanvas.getParentCompositeForContentOrPart(icObj);
          } catch(e) {
            parent = null;
          }

          return [icObj, parent];

          // var root;
          // try {
          //   root = infiniteCanvas.getRootCompositeForContentOrPart(icObj);
          // } catch(e) {
          //   root = null;
          // }

          // return [icObj, parent, root];
        }

        const arr__over  = createArr_obj_parent_root(icObj__over);
        const arr__under = createArr_obj_parent_root(icObj__under);


        function findTypeInArray(arr, str_type) {
          return arr.find((elt) => infiniteCanvas.getStrMainType(elt) == str_type);
        }

        const icArray__over  = findTypeInArray(arr__over,  "array");
        const icArray__under = findTypeInArray(arr__under, "array");

        const gmOp__over  = findTypeInArray(arr__over,  "gm_operator");
        const gmOp__under = findTypeInArray(arr__under, "gm_operator");

        const gmApplicOp__over  = findTypeInArray(arr__over,  "gm_applicable_operator");
        const gmApplicOp__under = findTypeInArray(arr__under, "gm_applicable_operator");

        var miniDict_operation = {
          type: "unknown",
        };

        if(icArray__over != null && icObj__under == null) {
          miniDict_operation = {
            type: "deroll",
            subType: "popFirst",
            icArray: icArray__over,
          };
        } 
        else 
        if(icArray__over != null && icArray__under != null) {
          miniDict_operation = {
            type: "enroll",
            subType: "extend",
            icArray:        icArray__over,
            icArray__other: icArray__under,
          };
        } else if(icArray__over != null && icArray__under == null) {
          miniDict_operation = {
            type: "enroll",
            subType: "add",
            icArray:      icArray__over,
            icObj__other: icObj__under,
          };
        } else if(icArray__over == null && icArray__under != null) {
          miniDict_operation = {
            type: "enroll",
            subType: "add",
            icArray:      icArray__under,
            icObj__other: icObj__over,
          };
        } 
        else 
        if(icArray__over == null && icArray__under == null) {
          miniDict_operation = {
            type: "enroll",
            subType: "createArray",
            arr_icObj: [icObj__over, icObj__under],
          };
        }

        // function createStringForSwitch(str__arr_mainType__over, str__arr_mainType__under) {
        //   var outString = "";

        //   if(str__mainType__under == "gm_operator") {
        //     outString = "_ over gm_operator";
        //   } else if(str__mainType__over == "gm_operator") {
        //     outString = "gm_operator over _";
        //   }
          
        //   else if(str__mainType__under == "gm_applicable_operator") {
        //     outString = "_ over gm_applicable_operator";
        //   } else if(str__mainType__over == "gm_applicable_operator") {
        //     outString = "gm_applicable_operator over _";
        //   }
 
        //   else if(str__mainType__under == "array") {
        //     outString = "_ over array";
        //   } else if(str__mainType__over == "array") {
        //     outString = "array over _";
        //   }

        //   else {
        //     outString = "default";
        //   }
        //   return outString;
        // }



        // if(miniDict_operation.type == "enroll") {
        //   infiniteCanvas.manageEnroll(miniDict_operation);
        // } else if(miniDict_operation.type == "deroll") {
        //   infiniteCanvas.manageDeroll(miniDict_operation);
        // } else {
          infiniteCanvas.manageApply(icObj__selected, icObj__under);
        // }


      }

      operateOnSelected__crown() {
        const infiniteCanvas = this;

        //get selected icObj
        const icObj__selected = infiniteCanvas.getSelectedIcObj();

        //crown object i.e. store id
        infiniteCanvas.id__crown = icObj__selected.id;
      }



      addNewLabelValue(text, value) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icLabelValue = this.createIcLabelValue(trueRect, text, value);
        this.addNewIcObject(icLabelValue);
      }


      addNewButton() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icButton = this.createIcButton(trueRect);
        this.addNewIcObject(icButton);
      }

      addNewClickWell(value) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icClickWell = this.createIcClickWell(trueRect, value);
        this.addNewIcObject(icClickWell);
      }

      addNewBornAgainGreenMouse(value) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icBornAgainGreenMouse = this.createIcBornAgainGreenMouse(trueRect, value);
        this.addNewIcObject(icBornAgainGreenMouse);
      }


      addNewGMSafetyZone() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 150;   //"information" size
        const height = 150;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMSafetyZone = this.createIcGMSafetyZone(trueRect);
        this.addNewIcObject(icGMSafetyZone);
      }

      // addNewGMOperator() {
      //   const true_cursor = this.getTrueCursor();

      //   const left = true_cursor.x;
      //   const top = true_cursor.y;

      //   const width = 100;   //"information" size
      //   const height = 100;

      //   const trueRect = {
      //     x: left,
      //     y: top,
      //     width: width,
      //     height: height,
      //   };

      //   const icGMOperator = this.createIcGMOperator(trueRect);
      //   this.addNewIcObject(icGMOperator);
      // }

      addNewGMOperator_editable(text) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMOperator = this.createIcGMOperator_editable(trueRect, text);
        this.addNewIcObject(icGMOperator);
      }


      addNewGMOperator_withType(type, cfg = {}) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMOperator = this.createIcGMOperator_withType(trueRect, type, cfg);
        this.addNewIcObject(icGMOperator);
      }


      addNewGMTargetSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMTargetSlot = this.createIcGMTargetSlot(trueRect);
        this.addNewIcObject(icGMTargetSlot);
      }

      addNewGMTargetTouchSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMTargetTouchSlot = this.createIcGMTargetTouchSlot(trueRect);
        this.addNewIcObject(icGMTargetTouchSlot);
      }


      addNewWell() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icWell = this.createIcWell(trueRect);
        this.addNewIcObject(icWell);
      }

      addNewGreenMouseWell() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGreenMouseWell = this.createIcGreenMouseWell(trueRect);
        this.addNewIcObject(icGreenMouseWell);
      }

      addNewGMChallenge(challengeIndex) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMChallenge = this.createIcGMChallenge(trueRect, challengeIndex);
        this.addNewIcObject(icGMChallenge);
      }


      addNewRxSubject(value) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icRxSubject = this.createIcRxSubject(trueRect, value);
        this.addNewIcObject(icRxSubject);
      }

      addNewRxSubscription() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icRxSubscription = this.createIcRxSubscription(trueRect);
        this.addNewIcObject(icRxSubscription);
      }





      addNewObserver() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icObserver = this.createIcObserver(trueRect);
        this.addNewIcObject(icObserver);
      }

      addNewTrigger() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icTrigger = this.createIcTrigger(trueRect);
        this.addNewIcObject(icTrigger);
      }

      addNewEventEmitter() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icEventEmitter = this.createIcEventEmitter(trueRect);
        this.addNewIcObject(icEventEmitter);
      }

      addNewEventReceiver() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icEventReceiver = this.createIcEventReceiver(trueRect);
        this.addNewIcObject(icEventReceiver);
      }

      addNewEye() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icEye = this.createIcEye(trueRect);
        this.addNewIcObject(icEye);
      }


      addNewFacet_mathNode() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icFacet_mathNode = this.createIcFacet_mathNode(trueRect);
        this.addNewIcObject(icFacet_mathNode);
      }

      addNewIcEngined_debug() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icEngined_debug = this.createIcEngined_debug(trueRect);
        this.addNewIcObject(icEngined_debug);
      }

      addNewCountdown() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icCountdown = this.createIcCountdown(trueRect);
        this.addNewIcObject(icCountdown);
      }


      addNewStore() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icStore = this.createIcStore(trueRect);
        this.addNewIcObject(icStore);
      }

      addNewCounter() {
        const infiniteCanvas = this;

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const index__counter = this.index__counter;
        const counterConfig = this.createCounterConfig(index__counter);
        this.index__counter += 1;

        const icCounter = this.createIcCounter(trueRect, counterConfig);
        this.addNewIcObject(icCounter);
      }

      createCounterConfig(index__counter) {
        var outCounterConfig;

        const mathNode = new math.ConstantNode(index__counter);
        const left = 0;
        const top = 0;
        const icMathNode = infiniteCanvas.createIcMathNode(0, 0, mathNode);

        const icObj__specimen = icMathNode;
        outCounterConfig = {
          icObj__specimen: icObj__specimen,

          canCountFunc: (icObj) => {
            var outBool;

            const isValidType = (icObj.type == icObj__specimen.type);
            if (!isValidType) {
              outBool = false;
            } else {
              const isValidValue = (icObj.mathNode.value == icObj__specimen.mathNode.value);
              outBool = isValidValue;
            }

            return outBool;
          }
        };

        return outCounterConfig;
      }


      addNewConductiveOperator_withType(type, cfg = {}) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const conductiveOperator = infiniteCanvas.createIcConductiveOperator(trueRect, type, cfg);
        infiniteCanvas.addIcObject(conductiveOperator);
      }


      addNewCustomizableOperator() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const customizableOperator = infiniteCanvas.createIcCustomizableOperator(trueRect);
        infiniteCanvas.addIcObject(customizableOperator);
      }

      addNewITOperator_withType(type, cfg = {}) {

      }


      spawnImageCart() {

        FileIntegration.importImage_folder_p()
          .then(arr_img => {

            const arr_values = [...Array(10).keys()].map(i => i * 0.5);
            const arr_values__shuffled = Utils.shuffle([...arr_values]);

            const dict_cart = MathUtils.randomCartDictFromArr(arr_img, 10, 3, 6);
            logger.log("log1", "dict_cart", dict_cart);
            Object.entries(dict_cart).forEach(([k, miniDict], i) => {
              logger.log("log1", "k", k);
              const img = miniDict.obj;
              const nb = miniDict.nb;

              [...Array(nb).keys()].forEach((item, i) => {
                infiniteCanvas.manageImport__image(img);
              });

              const value = arr_values__shuffled[i];
              const mathNode__value = new math.ConstantNode(value);
              infiniteCanvas.addNewMathNode(mathNode__value);
            });

            // const isShuffled = true;
            // const arr_cart  = MathUtils.randomCartArrFromArr(arr_img, 10, 3, 6, isShuffled);
            // logger.log("log1", "arr_cart", arr_cart);
            // arr_cart.forEach(img => {
            //   infiniteCanvas.manageImport__image(img);
            // });

          });





      }





      configureInitialIcObjects() {

        // this.addAxes();

      }

      addAxes() {

        const icRectX = this.createIcRect_withLTWH(0, 0, 1000, 10);
        icRectX.fill = "red";
        this.addIcObject(icRectX);

        const icRectY = this.createIcRect_withLTWH(0, 0, 10, 1000);
        icRectY.fill = "blue";
        this.addIcObject(icRectY);

      }





      setupRedrawConditions() {
        // if the window changes size, redraw the canvas
        window.addEventListener("resize", (event) => {
          this.redrawCanvas(RedrawOccasion.windowResize);
        });
      }



      redrawCanvas(redrawOccasion) {

        debug.setScale(this.scale);
        debug.setOffset(this.offset);

        // console.log("this.icObjects", this.icObjects);
        // debug.setNbObjects(Object.values(this.icObjects.any).length);

        /*
        console.log("**reps[[[[[");
        Object.values(this.representations).forEach((rep, i) => {
          console.log("**rep", rep.type, rep.id_rep);
        });
        console.log("**reps]]]]]");
        */

        const nbDisplayedRepresentations = Object.values(this.representations).length;
        debug.setNbObjects(nbDisplayedRepresentations);

        this.redrawCanvasListeners.forEach((listener, i) => {
          listener(redrawOccasion);
        });
      }

      // redrawCanvasObject(icObj) {
      //   const fObj = fabricIntegration.getFObjForIcObj(icObj);
      //   fObj.dirty = true;
      //   fabricIntegration.fabricCanvas.renderAll();
      // }


      animate_bounce(rep_free) {

        const infiniteCanvas = this;

        const scale__start = Object.assign({}, rep_free.scale);
        // logger.log("animate_bounce", "scale__start", scale__start);

        const animation = anime({
          targets: rep_free.scale,

          /*animated props*/
          X: scale__start.X * 1.36,
          Y: scale__start.Y * 1.36,
          /*--------------*/

          //direction: 'normal',
          direction: 'alternate',
          easing: 'easeInOutSine',
          duration: 100,

          autoplay: true,

          update: (anim) => {
            logger.log("animate_bounce", "update", rep_free.id);

            // infiniteCanvas.redrawCanvasObject(rep_free);
            infiniteCanvas.redrawCanvas(RedrawOccasion.animation_bounce);
            // infiniteCanvas.redrawCanvas(RedrawOccasion.forceRedraw); //does not work

          },

        });

      }




      // convert coordinates
      toScreenX(xTrue) {
        return (xTrue + this.offset.dx) * this.scale.X;
      }
      toScreenY(yTrue) {
        return (yTrue + this.offset.dy) * this.scale.Y;
      }
      toScreenPoint(truePoint) {
        return Geometry.createPoint(this.toScreenX(truePoint.x), this.toScreenY(truePoint.y));
      }
      toScreenRect(trueRect) {
        const truePointTL = Geometry.createPoint(trueRect.left, trueRect.top);
        const truePointBR = Geometry.createPoint(trueRect.left + trueRect.width, trueRect.top + trueRect.height);

        const screen_pointTL = this.toScreenPoint(truePointTL);
        const screen_pointBR = this.toScreenPoint(truePointBR);

        const screen_w = screen_pointBR.x - screen_pointTL.x;
        const screen_h = screen_pointBR.y - screen_pointTL.y;

        const screenRect = Geometry.createRect(screen_pointTL.x, screen_pointTL.y, screen_w, screen_h);

        return screenRect;
      }
      toScreenSize(trueSize) {
        const screen_w = trueSize.width / this.scale.X;
        const screen_h = trueSize.height / this.scale.Y;
        return Geometry.createSize(screen_w, screen_h);
      }
      // toScreenLength(trueLength) {
      //   return trueLength * this.scale;
      // }




      getOrientationBaseVectors() {
        return this.getRotationBaseVectors(this.orientation);
      }

      getStdBaseVectors() {
        return this.getRotationBaseVectors(-this.orientation);
      }

      getRotationBaseVectors(angle) {

        const cosTheta = Math.cos(angle * (Math.PI / 180));
        const sinTheta = Math.sin(angle * (Math.PI / 180));

        const orientation_vector_u = {
          x: cosTheta,
          y: sinTheta,
        };

        const orientation_vector_v = {
          x: -sinTheta,
          y: cosTheta,
        };

        const baseVectors = {
          u: orientation_vector_u,
          v: orientation_vector_v,
        };

        return baseVectors;

      }


      // toTrueX(xScreen) {
      //     return (xScreen / this.scale.X) - this.offset.dx;
      // }
      // toTrueY(yScreen) {
      //     return (yScreen / this.scale.Y) - this.offset.dy;
      // }
      toTrueX(screenPoint) {
        // console.log("toTrueX", "screenPoint", screenPoint);
        //
        // console.log("screenPoint.x", screenPoint.x);
        // console.log("this.scale.X", this.scale.X);
        // console.log("this.offset.dx", this.offset.dx);
        // console.log("this.offset", this.offset);


        const v = this.toNoOrPoint(screenPoint);

        const stdBaseVectors = this.getStdBaseVectors();
        // console.log("stdBaseVectors", stdBaseVectors);

        const trueX = Geometry.dotProduct_2d(v, stdBaseVectors.u);

        return trueX;
      }
      toTrueY(screenPoint) {
        const v = this.toNoOrPoint(screenPoint);

        const stdBaseVectors = this.getStdBaseVectors();

        return Geometry.dotProduct_2d(v, stdBaseVectors.v);
      }

      trueWidth() {
        // return canvas.clientWidth / scale;
        return this.canvas.width / this.scale.X;
      }
      trueHeight() {
        // return canvas.clientHeight / scale;
        return this.canvas.height / this.scale.Y;
      }

      toTruePoint(point) {
        const trueX = this.toTrueX(point);
        // console.log("trueX", trueX);

        const trueY = this.toTrueY(point);
        const truePoint = Geometry.createPoint(trueX, trueY);
        // console.log("truePoint", truePoint);
        return truePoint;
      }

      toTrueRect(ltRect) {
        const pointTL = Geometry.createPoint(ltRect.left, ltRect.top);
        const pointBR = Geometry.createPoint(ltRect.left + ltRect.width, ltRect.left + ltRect.height);

        const true_pointTL = this.toTruePoint(pointTL);
        const true_pointBR = this.toTruePoint(pointBR);

        const true_w = true_pointBR.x - true_pointTL.x;
        const true_h = true_pointBR.y - true_pointTL.y;

        const trueRect = Geometry.createRect(true_pointTL.x, true_pointTL.y, true_w, true_h);

        return trueRect;
      }

      getTrueCursor() {
        return this.toTruePoint(this.cursor);
      }

      truePointFromNoOrPoint(noOrPoint) {

        const stdBaseVectors = this.getStdBaseVectors();
        // console.log("stdBaseVectors", stdBaseVectors);

        const trueX = Geometry.dotProduct_2d(noOrPoint, stdBaseVectors.u);
        const trueY = Geometry.dotProduct_2d(noOrPoint, stdBaseVectors.v);

        const truePoint = Geometry.createPoint(trueX, trueY);

        return truePoint;
      }



      //noOr == no orientation == almost true point (wrong axes orientation)
      toNoOrX(screenX) {
        const noOrX = (screenX / this.scale.X) - this.offset.dx;
        return noOrX;
      }

      toNoOrY(screenY) {
        const noOrY = (screenY / this.scale.Y) - this.offset.dy;
        return noOrY;
      }

      toNoOrPoint(screenPoint) {
        return Geometry.createPoint(this.toNoOrX(screenPoint.x), this.toNoOrY(screenPoint.y));
      }

      toNoOrRect(screenRect) {
        const noOrTL = this.toNoOrPoint(Geometry.getPointTL(screenRect));
        const noOrBR = this.toNoOrPoint(Geometry.getPointBR(screenRect));
        const w = noOrBR.x - noOrTL.x;
        const h = noOrBR.y - noOrTL.y;
        return Geometry.createRect(noOrTL.x, noOrTL.y, w, h);
      }

      //   //reverse funcs:
      // toOrX(trueX, scale) {
      //   const orX = (trueX + this.offset.dx) * scale.X;
      //   return orX;
      // }

      // toOrY(trueY, scale) {
      //   const orY = (trueY + this.offset.dy) * scale.Y;
      //   return orY;
      // }

      // toOrPoint(truePoint, scale) {
      //   return Geometry.createPoint(this.toOrX(truePoint.x, scale), this.toOrY(truePoint.y, scale));
      // }

      // toOrRect(trueRect, scale) {
      //   const orTL = this.toOrPoint(Geometry.getPointTL(Geometry.createLTRect(trueRect)), scale);
      //   const orBR = this.toOrPoint(Geometry.getPointBR(Geometry.createLTRect(trueRect)), scale);
      //   const w = orBR.x - orTL.x;
      //   const h = orBR.y - orTL.y;
      //   return Geometry.createRect(orTL.x, orTL.y, w, h);
      // }      



      getCanvasBoundingRect() {
        // return canvas.getBoundingClientRect();
        return this.canvas.getBoundingClientRect();
      }

      getCanvasBoundingTrueRect() {
        const canvasBoundingRect = this.getCanvasBoundingRect();
        logger.log("logPOV", "canvasBoundingRect:", canvasBoundingRect);

        const trueRect = this.toTrueRect(canvasBoundingRect);

        return trueRect;
      }


      getScreenRect() {
        return this.getCanvasBoundingRect();
      }

      getScreenCenterPoint() {
        return Geometry.getCenterPoint(this.getCanvasBoundingRect());
      }

      getTrueCenterPoint() {
        const centerPoint_screen = this.getScreenCenterPoint();
        // console.log("centerPoint_screen", centerPoint_screen);
        const centerPoint_true = this.toTruePoint(centerPoint_screen);
        return centerPoint_true;
      }

      getNoOrCenterPoint() {
        const centerPoint_screen = this.getScreenCenterPoint();
        // console.log("centerPoint_screen", centerPoint_screen);
        const centerPoint_noOr = this.toNoOrPoint(centerPoint_screen);
        return centerPoint_noOr;
      }


      getShownRect() {
        const screenRect = this.getScreenRect();
        const noOrRect   = this.toNoOrRect(screenRect);
        const shownRect  = Geometry.createXYRect(noOrRect);
        return shownRect;
      }

      getScreenRectForTrueRectAtScale(trueRect, scale) {
        const orRect = this.toOrRect(trueRect, scale);
        const screenRect  = Geometry.createXYRect(orRect);
        return screenRect;
      }


      createPOVWithRect(trueRect) {
        const center = {
          x: trueRect.x + (trueRect.width  / 2.0),
          y: trueRect.y + (trueRect.height / 2.0),
        };
        const size = {
          width:  trueRect.width,
          height: trueRect.height,
        };
        logger.log("logPOV", "size:", size);

        const scale = infiniteCanvas.getNaturalScaleForSize(size);

        return new POV(scale, center, size);
      }


      getCanvasSize() {
        const size__canvas = {
          width:  this.canvas.width  / window.devicePixelRatio,
          height: this.canvas.height / window.devicePixelRatio,
        };
        return size__canvas;
      }

      getNaturalScaleForSize(size_in) {

        //get canvas size
        const size__canvas = this.getCanvasSize();
        // logger.log("logPOV", "size__canvas:", size__canvas);

        //get fitting dimension
        const scale__X = size__canvas.width  / size_in.width;
        const scale__Y = size__canvas.height / size_in.height;

        const scale__min = math.min(scale__X, scale__Y);
        const scale = {
          X: scale__min,
          Y: scale__min,
        };
        // logger.log("logPOV", "scale__min:", scale__min);

        const scale__max = math.max(scale__X, scale__Y);
        // const scale = {
        //   X: scale__max,
        //   Y: scale__max,
        // };
        // logger.log("logPOV", "scale__max:", scale__max);


        return scale;
      }



      //"entry points"

      manageCursorMove_line() {

        /*
        //create line
        const line = {
            x0: prevScaledX,
            y0: prevScaledY,
            x1: scaledX,
            y1: scaledY
        };

        //console.log("line", line);

        // add the line to our drawing history
        drawings.push(line);

        // draw a line
        drawLine(prevCursorX, prevCursorY, cursorX, cursorY);
        */

      }

      manageCursorMove_offset(factor = 1) {
        const infiniteCanvas = this;

        const func_update = function() {

          const noOr_cursor         = infiniteCanvas.toNoOrPoint(infiniteCanvas.cursor);
          const noOr_previousCursor = infiniteCanvas.toNoOrPoint(infiniteCanvas.previousCursor);

          // move the screen
          const dOffsetX = (noOr_cursor.x - noOr_previousCursor.x) * infiniteCanvas.inputProperties.moveProperties.moveMultiplier;
          const dOffsetY = (noOr_cursor.y - noOr_previousCursor.y) * infiniteCanvas.inputProperties.moveProperties.moveMultiplier;

          const dOffset = {
            dx: dOffsetX * factor,
            dy: dOffsetY * factor,
          };

          infiniteCanvas.updateDOffset(dOffset);
          infiniteCanvas.redrawCanvas(RedrawOccasion.offsetChanged);

        };

        const isFreeDrawingPan       = fabricIntegration.fabricCanvas.isDrawingMode && mouseIntegration.leftMouseDown && !infiniteCanvas.isFreeDrawingPan;
        const isFreeDrawingPan__line = isFreeDrawingPan && keyboardIntegration.keyDownToggles.shiftLeft.isActive;
        if(isFreeDrawingPan__line) {
          infiniteCanvas.enterPan__freeDrawing__line(func_update);
        } else if(isFreeDrawingPan) {
          infiniteCanvas.enterPan__freeDrawing(func_update);
        } else if((infiniteCanvas.getArr_rep_free__isHeld().length !=0) && mouseIntegration.leftMouseDown && !infiniteCanvas.isObjectHoldingPan) {
          infiniteCanvas.enterPan__objectHolding(func_update);
        } 
        else {
          func_update();
        }

      }

      enterPan__freeDrawing(func_update) {
        this.isFreeDrawingPan      = true;
        fabricIntegration.simulateMouseUp__with_freeDrawingBrush(() => {
          fabricIntegration.leaveFreeDrawing__atomic();
          func_update();
          fabricIntegration.fabricCanvas.isDrawingMode = false;
        });
      }

      leavePan__freeDrawing() {
        fabricIntegration.fabricCanvas.isDrawingMode = true;
        fabricIntegration.enterFreeDrawing__atomic({isCosmetic:false});
        fabricIntegration.simulateMouseDown__with_freeDrawingBrush(() => {});
        this.isFreeDrawingPan      = false;
        this.hasBeenFreeDrawingPan = true;
      }

      enterPan__freeDrawing__line(func_update) {
        //SHU TODO
        // this.isFreeDrawingPan      = true;
        // fabricIntegration.simulateMouseUp__with_freeDrawingBrush(() => {
        //   fabricIntegration.leaveFreeDrawing__atomic();
        //   func_update();
        //   fabricIntegration.fabricCanvas.isDrawingMode = false;
        // });
      }

      leavePan__freeDrawing__line() {
        //SHU TODO
        // fabricIntegration.fabricCanvas.isDrawingMode = true;
        // fabricIntegration.enterFreeDrawing__atomic({isCosmetic:false});
        // fabricIntegration.simulateMouseDown__with_freeDrawingBrush(() => {});
        // this.isFreeDrawingPan      = false;
        // this.hasBeenFreeDrawingPan = true;
      }



      enterPan__objectHolding(func_update) {
        this.isObjectHoldingPan      = true;
        func_update();
      }

      leavePan__objectHolding() {
        this.isObjectHoldingPan      = false;
        this.hasBeenObjectHoldingPan = true;
      }




      manageCursorMove_rotate(factor) {
        const infiniteCanvas = this;

        // console.log("this.cursor",         this.cursor);
        // console.log("this.previousCursor", this.previousCursor);

        // const screenRect   = this.getScreenRect();
        // console.log("screenRect", screenRect);
        const screenCenterPoint = this.getScreenCenterPoint();
        // console.log("screenCenterPoint", screenCenterPoint);


        // get rotation angle
        const v1 = {
          x: this.cursor.x - screenCenterPoint.x,
          y: this.cursor.y - screenCenterPoint.y,
        };
        const v2 = {
          x: this.previousCursor.x - screenCenterPoint.x,
          y: this.previousCursor.y - screenCenterPoint.y,
        };

        const norm_v1 = Geometry.norm_2d(v1);
        const norm_v2 = Geometry.norm_2d(v2);

        //angle = arccos[(xa * xb + ya * yb) / (√(xa2 + ya2) * √(xb2 + yb2))]
        const angle_abs = Math.acos(Geometry.dotProduct_2d(v1, v2) / (norm_v1 * norm_v2));
        console.log("mcr", "angle_abs", angle_abs);

        if (isNaN(angle_abs)) {
          //ignore
          console.log("ignore", "isNaN(angle_abs) == true");
          // console.log("norm_v1", norm_v1);
          // console.log("norm_v2", norm_v2);
          return;
        }

        // * this.inputProperties.moveProperties.moveMultiplier

        //get the right sign
        const v1_3d = Geometry.vector_3d(v1);
        const v2_3d = Geometry.vector_3d(v2);
        const vn = {
          x: 0,
          y: 0,
          z: 1,
        };

        const cross = Geometry.crossProduct_3d(v1_3d, v2_3d);
        // console.log("cross", cross);
        const sign = Geometry.dotProduct_3d(vn, cross) < 0 ? +1 : -1;

        const angleInRadians = sign * angle_abs * factor;

        const angleInDegrees = angleInRadians * 180 / Math.PI;
        console.log("mcr", "angleInDegrees", angleInDegrees);

        const rotationCenter = this.getNoOrCenterPoint();
        // console.log("rotationCenter", rotationCenter);

        const func_update = function() {
          infiniteCanvas.updateWithDRotation(angleInDegrees, rotationCenter);
          infiniteCanvas.redrawCanvas(RedrawOccasion.orientationChanged);
        };

        if(fabricIntegration.fabricCanvas.isDrawingMode && mouseIntegration.leftMouseDown) {

          fabricIntegration.simulateMouseUpDown__with_freeDrawingBrush(() => {
            fabricIntegration.leaveFreeDrawing__atomic();
            func_update();
            fabricIntegration.enterFreeDrawing__atomic({isCosmetic: false});
          });

        } else {
          func_update();
        }


      }

      manageCenterRotation(angleInDegrees) {
        const rotationCenter = this.getNoOrCenterPoint();
        // console.log("rotationCenter", rotationCenter);

        this.updateWithDRotation(angleInDegrees, rotationCenter);
        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }

      logCursor() {

        console.log("this.cursor", this.cursor);
        const true_cursor = this.toTruePoint(this.cursor);
        console.log("true_cursor", true_cursor);


        const screenCenterPoint = this.getScreenCenterPoint();
        console.log("screenCenterPoint", screenCenterPoint);

      }




      //   // zoom the page based on where the cursor is
      //   var distX = event.pageX / canvas.clientWidth;
      //   var distY = event.pageY / canvas.clientHeight;
      //
      //   // calculate how much we need to zoom
      //   const unitsZoomedX = trueWidth() * scaleAmount;
      //   const unitsZoomedY = trueHeight() * scaleAmount;
      //
      //   const unitsAddLeft = unitsZoomedX * distX;
      //   const unitsAddTop = unitsZoomedY * distY;
      //
      //   offsetX -= unitsAddLeft;
      //   offsetY -= unitsAddTop;

      manageUpdate__scale_withScaleAmount(scaleAmount) {
        logger.log("log1", "manageUpdate__scale_withScaleAmount", scaleAmount);

        const infiniteCanvas = this;

        const factor = (1 + scaleAmount); 

        const scale_new = {
          X: this.scale.X * factor,
          Y: this.scale.Y * factor,
        };
        // logger.log("log1", "scale_new", scale_new);

        // zoom the page based on where the cursor is
        const cursor            = this.cursor;        //the only point that does not move on screen 
        const pos__cursor__ic   = infiniteCanvas.toNoOrPoint(cursor);
        logger.log("log1", "pos__cursor__ic", pos__cursor__ic);

        // const screenCenterPoint = this.getScreenCenterPoint();
        const screenRect       = this.getScreenRect();
        logger.log("log1", "screenRect", screenRect);
        const trueRect__screen = this.toNoOrRect(screenRect);
        logger.log("log1", "trueRect__screen", trueRect__screen);

        // const trueRect__screen__after_homot = Geometry.rectWithHomothety(trueRect__screen, pos__cursor__ic, factor);
        const pointTL__screen = {
          x: trueRect__screen.left,
          y: trueRect__screen.top,
        };
        const pointTL__screen__after_homot = Geometry.pointWithHomothety(pointTL__screen, pos__cursor__ic, factor);

          //wrong
        // const dOffset = {
        //   dx: pointTL__screen__after_homot.x - pointTL__screen.x,
        //   dy: pointTL__screen__after_homot.y - pointTL__screen.y,
        // };
          //correct
        const dOffset = {
          dx: (pointTL__screen__after_homot.x - pointTL__screen.x) / factor,
          dy: (pointTL__screen__after_homot.y - pointTL__screen.y) / factor,
        };
        logger.log("log1", "dOffset", dOffset);


        logger.log("logFreeDrawing", "manageScaleUpdateWithScaleAmount", "fabricCanvas.isDrawingMode:", fabricIntegration.fabricCanvas.isDrawingMode);


        if(fabricIntegration.fabricCanvas.isDrawingMode && mouseIntegration.leftMouseDown) {
        //   //--- Simulate a natural mouse-click sequence.

          const func_inBetween__updateScaleAndDOffset = function() {
            //update scale
            infiniteCanvas.updateScaleAndDOffset(scale_new, dOffset);

            // if(inputProperties.isHomeScaleLocked) {
            //   const width__current = fabricIntegration.freeDrawingBrush.width; 
            //   fabricIntegration.configureFreeDrawingBrush({
            //     width: math.min(1, width__current * factor),
            //   });
            // }

            infiniteCanvas.redrawCanvas(RedrawOccasion.scaleChanged);
          };
        
          fabricIntegration.simulateMouseUpDown__with_freeDrawingBrush(() => {

            // //get cursor: zSegment start 
            // const true_cursorA = infiniteCanvas.getTrueCursor();
            // logger.log("logZSegmentFreeDrawing", "true_cursorA:", true_cursorA);
            
            fabricIntegration.leaveFreeDrawing__atomic();
            func_inBetween__updateScaleAndDOffset();

            // //get cursor: zSegment end
            // const true_cursorB = infiniteCanvas.getTrueCursor();
            // logger.log("logZSegmentFreeDrawing", "true_cursorB:", true_cursorB);

            // //create/add zSegment
            // try {

            //   const r__start = fabricIntegration.freeDrawingBrush.width;
            //   const r__end   = r_start * factor;

            //   const zSegment = infiniteCanvas.createIcZSegment(true_cursorA, r__start, true_cursorB, r__end);
            //   zSegment.parts.zPoint_start.fill  = "yellow";
            //   zSegment.parts.zPoint_end         = "yellow";
            //   zSegment.parts.zsstroke           = "yellow";

            //   infiniteCanvas.addIcObject(zSegment);

            // } catch(e) {
            //   logger.log("logZSegmentFreeDrawing", "catch(e):", e);
            // }
            
            
            fabricIntegration.enterFreeDrawing__atomic({isCosmetic: false});
          });

        } 
        // else if(fabricIntegration.fabricCanvas.isDrawingMode) {
        //   fabricIntegration.leaveFreeDrawing__atomic();
        // } 
        else {

          this.updateScaleAndDOffset(scale_new, dOffset);
          this.redrawCanvas(RedrawOccasion.scaleChanged);

        }

      }


      manageUpdate__color(rgbaColorString) {
        // logger.log("logFD", "manageUpdate__color", "rgbaColorString:", rgbaColorString);

        const func_update = function() {
          fabricIntegration.configureFreeDrawingBrush({color: rgbaColorString});
        };

        if(fabricIntegration.fabricCanvas.isDrawingMode && mouseIntegration.leftMouseDown) {
          //--- Simulate a natural mouse-click sequence.
          fabricIntegration.simulateMouseUpDown__with_freeDrawingBrush(() => {
            fabricIntegration.leaveFreeDrawing__atomic();
            func_update();
            fabricIntegration.enterFreeDrawing__atomic({isCosmetic: false});
          });
          
        } else if(fabricIntegration.fabricCanvas.isDrawingMode) {
          
          func_update();
        
        } else if(infiniteCanvas.isZSegmentDrawingMode_zPointMoving) {
          
          const rep_free__zSegment = infiniteCanvas.getRepresented(infiniteCanvas.id__zSegment).r_free();
          Object.values(rep_free__zSegment.parts).forEach((rep_free__part) => {
            rep_free__part.stroke = rgbaColorString;
            rep_free__part.fill   = rgbaColorString;
          });

        } else if(keyboardIntegration.keyDownToggles.b.isActive) {
          logger.log("logColorScroll", "change bg color");
          
          fabricIntegration.fabricCanvas.backgroundColor = rgbaColorString;
          fabricIntegration.fabricCanvas.requestRenderAll();

        } else {
          //get selected objects
          const arr_rep_free_selected = this.getArr_selected_rep_free();

          //update main color of object
          arr_rep_free_selected.forEach((rep_free, i) => {
            this.updateMainColorOfObject(rep_free, rgbaColorString);
          });

          //update brush color 
          fabricIntegration.configureFreeDrawingBrush({color: rgbaColorString});
        }

      }

      updateMainColorOfObject(rep_free, rgbaColorString) {

        switch(rep_free.type) {
          case "rect":
            rep_free.fill = rgbaColorString;
            break;
          case "text":
            rep_free.textColor = rgbaColorString;
            break;
          case "mathNode":
            rep_free.stroke = rgbaColorString;
            break;
          case "freeDrawing":
            rep_free.stroke = rgbaColorString;
            break;
          default:
            rep_free.fill = rgbaColorString;
            break;
        }

      }

      manageUpdate__opacity(opacity) {

        if(fabricIntegration.fabricCanvas.isDrawingMode && mouseIntegration.leftMouseDown) {
        //   //--- Simulate a natural mouse-click sequence.

          const func_inBetween = function() {
            fabricIntegration.configureFreeDrawingBrush({opacity: opacity});
          };
        
          fabricIntegration.simulateMouseUpDown__with_freeDrawingBrush(() => {
            fabricIntegration.leaveFreeDrawing__atomic();
            func_inBetween();
            fabricIntegration.enterFreeDrawing__atomic({isCosmetic: false});
          });

        } else {
          //get selected objects
          const arr_rep_free_selected = this.getArr_selected_rep_free();

          //version 1: update object's main color
            // const rgbaColorString = inputProperties.getActiveRgbaColorString();

            // //update main color of object
            // arr_rep_free_selected.forEach((rep_free, i) => {
            //   switch(rep_free.type) {
            //     case "rect":
            //       rep_free.fill = rgbaColorString;
            //       break;
            //     case "text":
            //       rep_free.textColor = rgbaColorString;
            //       break;
            //     default:
            //       rep_free.fill = rgbaColorString;
            //       break;
            //   }
            // });

          //version 2: update object's opacity
          arr_rep_free_selected.forEach((rep_free, i) => {
            rep_free.opacity = opacity;
          });

        }

      }

      manageUpdate__lightness(lightness) {

        if(fabricIntegration.fabricCanvas.isDrawingMode && mouseIntegration.leftMouseDown) {
        //   //--- Simulate a natural mouse-click sequence.

          const func_inBetween = function() {
            fabricIntegration.configureFreeDrawingBrush({lightness: lightness});
          };

          fabricIntegration.simulateMouseUpDown__with_freeDrawingBrush(() => {
            fabricIntegration.leaveFreeDrawing__atomic();
            func_inBetween();
            fabricIntegration.enterFreeDrawing__atomic({isCosmetic: false});
          });

        } else {
          //get selected objects
          const arr_rep_free_selected = this.getArr_selected_rep_free();

          //version 1: update object's main color
            // const rgbaColorString = inputProperties.getActiveRgbaColorString();

            // //update main color of object
            // arr_rep_free_selected.forEach((rep_free, i) => {
            //   switch(rep_free.type) {
            //     case "rect":
            //       rep_free.fill = rgbaColorString;
            //       break;
            //     case "text":
            //       rep_free.textColor = rgbaColorString;
            //       break;
            //     default:
            //       rep_free.fill = rgbaColorString;
            //       break;
            //   }
            // });

          //version 2: update object's lightness
          arr_rep_free_selected.forEach((rep_free, i) => {
            rep_free.lightness = lightness;
          });

        }

      }

      manageUpdate__brushWidth(brushWidth) {

        if(fabricIntegration.fabricCanvas.isDrawingMode && mouseIntegration.leftMouseDown) {
        //   //--- Simulate a natural mouse-click sequence.

          const func_inBetween = function() {
            fabricIntegration.configureFreeDrawingBrush({width: brushWidth});
          };
      
          fabricIntegration.simulateMouseUpDown__with_freeDrawingBrush(() => {
            fabricIntegration.leaveFreeDrawing__atomic();
            func_inBetween();
            fabricIntegration.enterFreeDrawing__atomic({isCosmetic: false});
          });

        } else {
          fabricIntegration.configureFreeDrawingBrush({width: brushWidth});
        }

      }

      manageUpdate__comb__addStroke() {
        // const fabricCanvas = fabricIntegration.fabricCanvas;
        // const brush        = fabricCanvas.freeDrawingBrush; 

        // const isSingleBrush = !("arr_brush" in brush);

        // if(isSingleBrush) {

        // } else {

        // }

        // const brush__src               = combBrush.arr_brush[0];
        // // const brush__src__decorated = combBrush.arr_brush[0];
        // // const brush__src            = DecorationUtils.getInnermost(brush__src__decorated);
        // logger.log("logComb", "brush__src:", brush__src);
        // const dict_prop = Utils.getPropDict__shallow(brush__src, [
        //   "color",
        //   "width",
        //   "zIndex__ic",
        // ]);
        // logger.log("logComb", "dict_prop:", dict_prop);
        // var brush__child__new = new fabric.PencilBrush(fabricCanvas);
        // Object.assign(brush__child__new, dict_prop);
        // brushUpgrade__preview(brush__child__new);
        // brushUpgrade__pathWithBrushProperty(brush__child__new);

        // combBrush.addBrush(brush__child__new);

        // fabricIntegration.setBrush__hotSwap(combBrush);
      }


      manageUpdate__freeDrawing__orthScroll(shiftAmount) {
        logger.log("logComb", "manageUpdate__freeDrawing__orthScroll", "shiftAmount:", shiftAmount);
        const infiniteCanvas = this;

        const spacing__min = 1e-8;

        if(infiniteCanvas.isCombSetup) {
          if(infiniteCanvas.step__combSetup == 1) {
            const isSingleBrush = !("arr_brush" in fabricIntegration.fabricCanvas.freeDrawingBrush);
            // const isSingleBrush = (fabricIntegration.fabricCanvas.freeDrawingBrush.arr_brush?.length == 1);

            if(isSingleBrush) {
              if(shiftAmount > 0) {
                infiniteCanvas.combSetup__autoComb(2);
                // infiniteCanvas.combSetup__autoComb(5);
              } else {
                infiniteCanvas.combSetup__autoComb(3);
              }
            }
            infiniteCanvas.combSetup__moveToStep(2);
          }

          const factor = this.isReverseCombSpacing ? -1 : + 1;

          const spacing__old = fabricIntegration.fabricCanvas.freeDrawingBrush.spacing;
          const spacing__new = Math.max(spacing__min, spacing__old + shiftAmount * 50 * factor);

          infiniteCanvas.combSetup__spacing(spacing__new);
        } else {

          const factor = this.isReverseCombSpacing ? -1 : + 1;

          const spacing__old = fabricIntegration.fabricCanvas.freeDrawingBrush.spacing;
          const spacing__new = Math.max(spacing__min, spacing__old + shiftAmount * 50 * factor);

          fabricIntegration.fabricCanvas.freeDrawingBrush.setSpacing(spacing__new);
        }

      }


      manageUpdate__selectedObj__value(cfg) {

        //get selected objects
        const arr_rep_free_selected = this.getArr_selected_rep_free();

        arr_rep_free_selected.forEach((rep_free, i) => {
          
          if("mathNode" in rep_free /*&& rep_free.mathNode instanceof math.ConstantNode*/) {
            const mathNode__prev = rep_free.mathNode;
            // const value__prev = mathNode__prev.evaluate({});
            const value__prev = mathNode__prev.value;
            var value__new;
            switch(cfg.type) {
              case "inc":
                {
                  value__new = value__prev + cfg.screment;
                }
                break;
              case "pow10":
                {
                  value__new = value__prev * math.pow(10, cfg.screment);
                }
                break;
              default:
                {
                  throw new Error("Unsupported cfg.type: " + cfg.type);
                }
                break;
            } 
            // const mathNode__new  = new mathNode__prev.constructor(value__new);
            const mathNode__new = new math.ConstantNode(value__new);
            
            rep_free.mathNode = mathNode__new;
          } else  if("text" in rep_free) {
            const text__prev = rep_free.text;

            var text__new;
            switch(cfg.type) {
              case "inc":
                {
                  const str__butlast = text__prev.slice(0, -1);
           
                  const str__last__old      = text__prev.slice(-1);
                  const charCode__last__old = str__last__old.charCodeAt(0);
                  const charCode__last__new = charCode__last__old + cfg.screment;
                  const str__last__new      = String.fromCharCode(charCode__last__new);

                  text__new = str__butlast + str__last__new;
                }
                break;
              case "pow10":
                {
                  if(cfg.screment > 0) {
                    const str__last__old      = text__prev.slice(-1);
                    text__new = text__prev + str__last__old;
                  } else {
                    const str__butlast = text__prev.slice(0, -1);
                    text__new = str__butlast;
                  }
                  
                }
                break;
              default:
                {
                  throw new Error("Unsupported cfg.type: " + cfg.type);
                }
                break;
            } 
            rep_free.text = text__new;

          }
          
        });

      }


      manageUpdate__selectedObj__homeScale__withScaleAmount(scaleAmount) {

        //get selected objects
        const arr_rep_free_selected = this.getArr_selected_rep_free();

        arr_rep_free_selected.forEach((rep_free, i) => {
          
          const homeScale__old = Object.assign({}, rep_free.homeScale);
          const homeScale__new = {
            X: homeScale__old.X * (1 + scaleAmount),
            Y: homeScale__old.Y * (1 + scaleAmount),
          };
          rep_free.homeScale = homeScale__new;
          
        });

      }



      getArr_selected_rep_free() {
        const arr_rep_free = Object.values(this.represented).map(represented => represented.r_free());
        const arr_rep_free_selected = arr_rep_free
          .filter(rep_free => {
            return rep_free.isSelected;
          });
        return arr_rep_free_selected;
      }

      getArr_rep_free__isHeld() {
        const arr_rep_free = Object.values(this.represented).map(represented => represented.r_free());
        const arr_rep_free_filtered = arr_rep_free
          .filter(rep_free => {
            return rep_free.isHeld;
          });
        return arr_rep_free_filtered;
      }



      // zIndex

      enterZIndexEditing() {
        this.isZIndexEditing = true;
      }

      leaveZIndexEditing() {
        this.isZIndexEditing = false;
      }

      manageUpdate__zIndex_withScrement(screment) {
        console.log("manageUpdate__zIndex_withScrement", screment);

        const infiniteCanvas = this;
        const isABScroll = keyboardIntegration.keyDownToggles.digit3.isActive;

        function getBrushZIndex_new(screment, isABScroll) {
          var outZIndex;
          if(isABScroll) {
            if(screment > 0) {
              outZIndex = infiniteCanvas.getFreshIcZIndex__max();
            } else {
              outZIndex = infiniteCanvas.getFreshIcZIndex__min();
            }
          } else {
            outZIndex = inputProperties.resulting_brushZIndex_forScrement(screment);
          }
          return outZIndex;
        }

        if(fabricIntegration.fabricCanvas.isDrawingMode && mouseIntegration.leftMouseDown) {
        //   //--- Simulate a natural mouse-click sequence.

          const func_inBetween = function() {

            const brushZIndex_new = getBrushZIndex_new(screment, isABScroll);

            //set zIndex of next freeDrawing object
            inputProperties.setBrushZIndex(brushZIndex_new);

            fabricIntegration.configureFreeDrawingBrush({zIndex__ic: brushZIndex_new});
          };
        
          fabricIntegration.simulateMouseUpDown__with_freeDrawingBrush(() => {
            fabricIntegration.leaveFreeDrawing__atomic();
            func_inBetween();
            fabricIntegration.enterFreeDrawing__atomic({isCosmetic: false});
          });

        } else if(fabricIntegration.fabricCanvas.isDrawingMode) {
          
          const brushZIndex_new = getBrushZIndex_new(screment, isABScroll);

          //set zIndex of next freeDrawing object
          logger.log("logZIndexScroll", "brushZIndex_new:", brushZIndex_new);
          inputProperties.setBrushZIndex(brushZIndex_new);

          //refresh brush
          fabricIntegration.configureFreeDrawingBrush({zIndex__ic: brushZIndex_new});

        } else {

          //get selected objects
          const arr_rep_free_selected = this.getArr_selected_rep_free();

          //update zIndex
          arr_rep_free_selected.forEach((rep_free, i) => {
            rep_free.zIndex += screment;
          });

          // if(icObj_active.type == "composite") {
          //
          // } else {
          //   icObj_active.zIndex += screment;
          // }

        }

      }

      getArrIcZIndex() {
        const arr_represented = Object.values(this.represented);
        // const arr_rep_official = arr_represented.map(represented => represented.r_official());
        const arr_rep_free = arr_represented.map(represented => represented.r_free());

        const arr_zIndex = arr_rep_free.map(rep_free => rep_free.zIndex);
        return arr_zIndex;
      }

      getFreshIcZIndex__max() {
        var outIndex;

        const arr_zIndex = this.getArrIcZIndex();
        if (arr_zIndex.length == 0) {
          outIndex = 0;
        } else {
          const zIndex_max = math.max(arr_zIndex);

          outIndex = zIndex_max + 1;
        }

        return outIndex;
      }

      getFreshIcZIndex__min() {
        var outIndex;

        const arr_zIndex = this.getArrIcZIndex();
        if (arr_zIndex.length == 0) {
          outIndex = 0;
        } else {
          const zIndex_min = math.min(arr_zIndex);

          outIndex = zIndex_min - 1;
        }

        return outIndex;
      }

      manageZIndexEditing_bringToFront() {
        const infiniteCanvas = this;

        if(fabricIntegration.fabricCanvas.isDrawingMode && mouseIntegration.leftMouseDown) {
        //   //--- Simulate a natural mouse-click sequence.

          const func_inBetween = function() {

            const icZIndex__max = infiniteCanvas.getFreshIcZIndex__max();
            inputProperties.setBrushZIndex(icZIndex__max);

            fabricIntegration.configureFreeDrawingBrush({zIndex__ic: icZIndex__max});
          };
        
          fabricIntegration.simulateMouseUpDown__with_freeDrawingBrush(() => {
            fabricIntegration.leaveFreeDrawing__atomic();
            func_inBetween();
            fabricIntegration.enterFreeDrawing__atomic({isCosmetic: false});
          });

        } else if(fabricIntegration.fabricCanvas.isDrawingMode) {
          
          const icZIndex__max = this.getFreshIcZIndex__max();
          inputProperties.setBrushZIndex(icZIndex__max);

          fabricIntegration.configureFreeDrawingBrush({zIndex__ic: icZIndex__max});

        } else {

          //get selected objects
          const arr_rep_free_selected = this.getArr_selected_rep_free();

          //update zIndex
          arr_rep_free_selected.forEach((rep_free, i) => {
            rep_free.zIndex = this.getFreshIcZIndex__max();
          });

        }



      }

      manageZIndexEditing_sendToBack() {
        const infiniteCanvas = this;

        if(fabricIntegration.fabricCanvas.isDrawingMode && mouseIntegration.leftMouseDown) {
        //   //--- Simulate a natural mouse-click sequence.
          const func_inBetween = function() {

            const icZIndex__min = infiniteCanvas.getFreshIcZIndex__min();
            inputProperties.setBrushZIndex(icZIndex__min);

            fabricIntegration.configureFreeDrawingBrush({zIndex__ic: icZIndex__min});
          };
        
          fabricIntegration.simulateMouseUpDown__with_freeDrawingBrush(() => {
            fabricIntegration.leaveFreeDrawing__atomic();
            func_inBetween();
            fabricIntegration.enterFreeDrawing__atomic({isCosmetic: false});
          });

        } else if(fabricIntegration.fabricCanvas.isDrawingMode) {
          
          const icZIndex__min = this.getFreshIcZIndex__min();
          inputProperties.setBrushZIndex(icZIndex__min);

          fabricIntegration.configureFreeDrawingBrush({zIndex__ic: icZIndex__min});

        } else {

          //get selected objects
          const arr_rep_free_selected = this.getArr_selected_rep_free();

          //update zIndex
          arr_rep_free_selected.forEach((rep_free, i) => {
            rep_free.zIndex = this.getFreshIcZIndex__min();
          });

        }
        
      }


      //zSegment

      enterZSegmentDrawing(cfg) {
        logger.log("logZSegment", "enterZSegmentDrawing", cfg);
        this.isZSegmentDrawingMode = true;
        
        const fabricCanvas = fabricIntegration.fabricCanvas;

        //change cursor appearance
        {
          const cursor__crosshair_custom = 'url("./img/ic/cursor__zSegment_64__better.png") 32 32, auto';

          fabricCanvas.defaultCursor = cursor__crosshair_custom;
          fabricCanvas.hoverCursor   = cursor__crosshair_custom;
          fabricCanvas.moveCursor    = cursor__crosshair_custom;
        }
          
        


      }

      manageZSegmentCreation() {
        const infiniteCanvas = this;

        //spawn zSegment
        const p1 = infiniteCanvas.getTrueCursor();
        const r1 = 30;
        const p2 = p1;
        const r2 = r1;

        const icZSegment = infiniteCanvas.createIcZSegment(p1, r1, p2, r2);
        infiniteCanvas.addIcObject(icZSegment);

        //hold zPoint__end
        fabricIntegration.fabricCanvas.selection = false;
        infiniteCanvas.isDeepAltering = true;

        const rep_free__zPoint__end = infiniteCanvas.getRepresented(icZSegment.parts.zPoint_end.id).r_free();
        infiniteCanvas.setActiveObject(rep_free__zPoint__end);

          //make zPoint__end follow mouse cursor
          infiniteCanvas.isZSegmentDrawingMode_zPointMoving = true;
          infiniteCanvas.id__zSegment                       = icZSegment.id;
          infiniteCanvas.id__zPointMoving                   = rep_free__zPoint__end.id;

      }

      leaveZSegmentDrawing() {
        logger.log("logZSegment", "leaveZSegmentDrawing");

        const fabricCanvas = fabricIntegration.fabricCanvas;

        //reset cursor appearance
        {
          fabricCanvas.defaultCursor = "auto";
          fabricCanvas.hoverCursor   = "auto";
          fabricCanvas.moveCursor    = "auto";
        }

        this.id__zPointMoving                   = -1;
        this.isZSegmentDrawingMode_zPointMoving = false;
        this.isZSegmentDrawingMode              = false;

      }



      //comb

      enterCombSetup() {
        logger.log("logComb", "enterCombSetup");
        this.isCombSetup = true;
        this.combSetup__moveToStep(1);
      }

      combSetup__moveToStep(index) {
        if(this.isCombSetup) {
          this.step__combSetup = index;
        } else {
          throw new Error("can't moveTostep while isCombSetup == false");
        }
      }

      combSetup__createCombBrush__debug(nb_brush) {

        const fabricCanvas = fabricIntegration.fabricCanvas;

        function createChildBrush(index) {
          // const brush__pencil__1 = new fabric.ZPencilBrush(fabricCanvas);
          const brush__pencil__1 = fabric.ZPencilBrush.createInstance(fabricCanvas);
          brush__pencil__1.color = ColorUtils.randomColor();
          brush__pencil__1.width = 20;
          brush__pencil__1.zIndex__ic = 10;
          brush__pencil__1.zIndex = 10;
          brushUpgrade__preview(brush__pencil__1);
          brushUpgrade__pathWithBrushProperty(brush__pencil__1);
          brush__pencil__1.debug__name = brush__pencil__1.color;

          return brush__pencil__1;
        }

        const arr_brush__raw = [...Array(nb_brush).keys()].map((i) => {
          return createChildBrush(i);
        });
        
        // const combBrush = fabric.CombPencilBrush.createInstance(fabricCanvas, arr_brush__raw);
        // combBrush.debug__name = "comb";

        const combBrush = fabric.ZCombPencilBrush.createInstance(fabricCanvas, arr_brush__raw);
        combBrush.debug__name = "zComb";

        // const combBrush = fabric.SideCombPencilBrush.createInstance(fabricCanvas, arr_brush__raw);
        // combBrush.debug__name = "sideComb";

        return combBrush;
      }

      combSetup__setCombBrush(combBrush) {

        //store singleBrush
        const fabricCanvas = fabricIntegration.fabricCanvas;
        const brush        = fabricCanvas.freeDrawingBrush;
        
        const isSingleBrush = !("arr_brush" in brush);
        if(isSingleBrush) {
          inputProperties.brush__single = brush;
        } else {
          // throw new Error("brush should be single at this step", brush);
        }

        //swap to comb brush
        fabricIntegration.setBrush__hotSwap(combBrush);
      }

      //step 1
      combSetup__addBrush() {
        const fabricCanvas = fabricIntegration.fabricCanvas;
        const brush        = fabricCanvas.freeDrawingBrush; 

        const isSingleBrush = !("arr_brush" in brush);

        var combBrush;
        if(isSingleBrush) {

          // combBrush = this.combSetup__createCombBrush__debug(1);
          // combBrush = new fabric.CombPencilBrush(fabricCanvas, [brush]);
          
          // combBrush = fabric.CombPencilBrush.createInstance(fabricCanvas, [brush]);
          // combBrush = fabric.ZCombPencilBrush.createInstance(fabricCanvas, [brush]);

          combBrush = fabric.SideCombPencilBrush.createInstance(fabricCanvas, [brush]);

          this.combSetup__setCombBrush(combBrush);
        } else {
          combBrush = brush;
        }

        
        
        // {
        //   // const brush__src = combBrush.arr_brush[0].brush_raw;
        //   const brush__src = combBrush.arr_brush[0];
        //   logger.log("logComb", "brush__src", brush__src);

        //   const brush__clone = brush__src.deepClone();
        //   logger.log("logComb", "brush__clone", brush__clone);
        
        //   //debug
        //   // brushUpgrade__preview(brush__clone);

        //   combBrush.addBrush(brush__clone);
        // }

        // {
        //   const brush__child__new = new fabric.PencilBrush(fabricCanvas);
        //   brush__child__new.color = ColorUtils.randomColor();
        //   brush__child__new.width = 20;
        //   brush__child__new.zIndex__ic = 20;
        //   brushUpgrade__preview(brush__child__new);
        //   brushUpgrade__pathWithBrushProperty(brush__child__new);

        //   combBrush.addBrush(brush__child__new);
        // }

        {
          const brush__src               = combBrush.arr_brush[0];
          // const brush__src__decorated = combBrush.arr_brush[0];
          // const brush__src            = DecorationUtils.getInnermost(brush__src__decorated);
          logger.log("logComb", "brush__src:", brush__src);
          const dict_prop = Utils.getPropDict__shallow(brush__src, [
            "color",
            "width",
            "zIndex__ic",
            "zIndex",
          ]);
          logger.log("logComb", "dict_prop:", dict_prop);
          var brush__child__new = new fabric.PencilBrush(fabricCanvas);
          Object.assign(brush__child__new, dict_prop);
          brushUpgrade__preview(brush__child__new);
          brushUpgrade__pathWithBrushProperty(brush__child__new);

          combBrush.addBrush(brush__child__new);
        }

      }

      combSetup__removeBrush() {

      }

      combSetup__autoComb(n) {
        const fabricCanvas = fabricIntegration.fabricCanvas;

        const combBrush = this.combSetup__createCombBrush__debug(n);
        // const combBrush = new fabric.CombPencilBrush(fabricCanvas, []);

        this.isReverseCombSpacing = (n == 3);

        logger.log("logComb", "autoComb2", "combBrush.arr_brush.length:", combBrush.arr_brush.length);
        // logger.log("logComb", "autoComb2", "fabric.CombPencilBrush.arr_brush?.length:", fabric.CombPencilBrush.arr_brush?.length);
        this.combSetup__setCombBrush(combBrush);
      }

      //step 2
      combSetup__spacing(spacing) {
        const brush       = fabricIntegration.fabricCanvas.freeDrawingBrush;
        const isCombBrush = ("arr_brush" in brush);  
        if(isCombBrush) {
          brush.setSpacing(spacing);
        }
      }

      leaveCombSetup() {
        logger.log("logComb", "leaveCombSetup");
        infiniteCanvas.isCombSetup     = false;
        infiniteCanvas.step__combSetup = 0;
      }



      //transportation

      manageTransportation(screment) {

        //get transportation pod
        const icObj_tpod = this.getTransportationPod();
        logger.log("logTransport", "icObj_tpod:", icObj_tpod);

        //get next pod
        const icObj_tpod__next = this.getTransportationPod_next(icObj_tpod, screment);
        logger.log("logTransport", "icObj_tpod__next:", icObj_tpod__next);

        //transport to next pod
        this.transportFromPodToPod(icObj_tpod, icObj_tpod__next);
      }

      getTransportationPod() {
        //get object under cursor
        const icObj__under_cursor = infiniteCanvas.getIcObj__underCursor("free");

        return icObj__under_cursor;
      }

      getTransportationPod_next(icObj_tpod, screment, func_filter_in = null) {
        
        var func_filter;
        if(func_filter_in == null) {
          const func_filter__same_type = (icObj) => {
            return icObj.type == icObj_tpod.type;
          };
          func_filter = func_filter__same_type;
        } else {
          func_filter = func_filter_in;
        }
        
        //get other objects
        const arr_icObj = infiniteCanvas.getArr_icObj("free").filter(func_filter);

        const icObj_tpod__next = arr_icObj.find((icObj) => (icObj != icObj_tpod));

        return icObj_tpod__next;
      }

      transportFromPodToPod(icObj_tpod1, icObj_tpod2) {

        //get screenPov
        const pov1 = infiniteCanvas.getCurrentPov();

        //get pov2
        const pov2 = infiniteCanvas.getPov2WrtIcObj2_sameWayAsPov1WrtIcObj1(icObj_tpod2, pov1, icObj_tpod1);

        //set pov
        this.set_pov(pov2);
      }






      //number typing

      enterNumberTyping() {
        logger.log("logNT", "enterNumberTyping");

        globalsSingleton.isEditing = true;
        this.isNumberTyping        = true;

        //mathQuill
        {
          //create mathField
          const mathField = createMathField();

          //add mathField root HTML element to canvasContainer
          const elt = mathField.el();
          console.log("elt", elt);

          if (elt.style == null) { elt.style = {}; }
          elt.style.position = "absolute";

          const canvasContainer = infiniteCanvas.canvas.parentElement;
          canvasContainer.appendChild(elt);    //SHU: move this to fabricIntegration

          // mathField.latex("");
          mathField.reflow();
          
          mathField.focus();

          //clear
          // setTimeout(() => {
          //   mathField.latex("");
          //   mathField.reflow();
          // }, 0);
          

          logger.log("logMQ", "mathField", mathField);

          this.mathField_numberTyping = mathField;
        }

      }

      numberTyping_getInputTex() {
        
        const mathField = this.mathField_numberTyping;

        const tex = mathField.latex();
        logger.log("logNT", "tex:", tex);
        return tex;
      }

      leaveNumberTyping() {
        logger.log("logNT", "leaveNumberTyping");
        const infiniteCanvas = this;

        //mathQuill
        {

          //transfer tex
          {
            const tex = infiniteCanvas.numberTyping_getInputTex();

            const dict_parsed = infiniteCanvas.numberTyping_parseTex(tex);

            infiniteCanvas.numberTyping_manageDictParsed(dict_parsed);
          }

          const mathField = infiniteCanvas.mathField_numberTyping;

          //remove all listeners
          // mathField.el().removeEventListener("focusout", eventListener);
          $(mathField.el()).off();

          //remove mathField elt from canvasContainer
          mathField.el().remove();

          //destroy mathField
          mathField.revert();

        }

        this.mathNode_numberTyping  = null;
        this.mathField_numberTyping = null;

        this.isNumberTyping         = false;
        globalsSingleton.isEditing  = false;
      }

      numberTyping_parseTex(tex) {
        const dict_parsed = this.numberTyping_parseTex_to_dict(tex);

        return dict_parsed;
      }

      numberTyping_parseTex_toMathNode(tex) {
        var outMathNode;

        function parseCoords(tex) {
          var outMathNode;

          const regex__coords = /(.*);(.*)/;
          const isCoords = regex__coords.test(tex);
          logger.log("logNT, parseCoords", "isCoords", isCoords);
          if(isCoords) {
            const arr_match = tex.match(regex__coords);
            const str__x = arr_match[1];
            const str__y = arr_match[2];
            const mathNode__x = math.parse(str__x);
            const mathNode__y = math.parse(str__y);
            outMathNode = new math.ObjectNode({x: mathNode__x, y: mathNode__y});
          }

          return outMathNode;
        }

        function parseRational(tex) {
          logger.log("logNT", "parseRational", tex);
          var outMathNode;
          try {
            const regex__rational__explicit = /(^[+-]?[0-9]+\.[0-9]*\'[0-9]+\'$)/;
            const isRational__explicit = regex__rational__explicit.test(tex);
            
            if(isRational__explicit) {
              outMathNode = Parser.parse__rational__explicit(tex);
            } else {
              const regex__rational__implicit = /(^[+-]?[0-9]+\.[0-9]+\.\.\.$)/;
              const isRational__implicit = regex__rational__implicit.test(tex);

              if(isRational__implicit) {
                outMathNode = Parser.parse__rational__implicit(tex);
              } else {
                outMathNode = null;
              }
            }
          
          } catch(e) {
            throw e;
          }
          return outMathNode;
        }

        function parseFraction(tex) {
          var outMathNode;
          try {
            // const value__fraction = new Fraction(tex);
            const value__fraction = math.fraction(tex);
            logger.log("logNT", "value__fraction:", value__fraction);

            outMathNode = new math.ConstantNode(value__fraction);

            logger.log("logNT", "outMathNode:", outMathNode);
          } catch(e) {

          }
          return outMathNode;
        }

        function parseComplex(tex) {
          var outMathNode;
          try {
            const value__complex = math.complex(tex);
            logger.log("logNT", "value__complex:", value__complex);

            outMathNode = new math.ConstantNode(value__complex);
            logger.log("logNT", "outMathNode:", outMathNode);
          } catch(e) {

          }
          return outMathNode;
        }

        function parseExpression(tex) {
          var outMathNode;
          try {
            const mathExpression = MathExpression.fromLatex(tex);
              const text = mathExpression.toString();
              logger.log("logNT", "text:", text);
              outMathNode = math.parse(text);
          } catch(e) {

          }
          return outMathNode;
        }

        outMathNode = null;

        //debug
        // outMathNode = outMathNode ? outMathNode : FuncUtils.tryCatch_wrapper( () => new HorizSquaresBarIntegerConstantNode(math.parse(tex).value) );

        outMathNode = outMathNode ? outMathNode : parseCoords(tex);
        outMathNode = outMathNode ? outMathNode : parseRational(tex);
        outMathNode = outMathNode ? outMathNode : parseFraction(tex);
        outMathNode = outMathNode ? outMathNode : parseComplex(tex);
        outMathNode = outMathNode ? outMathNode : parseExpression(tex);

        return outMathNode;
      }

      numberTyping_parseTex_toOperatorNode(tex) {
        logger.log("logNT", "numberTyping_parseTex_toOperatorNode", tex);
        var outMathNode;

        const infiniteCanvas = this;

        // function parseToOperatorNode(tex) {
        //   var outNode;

        //   const [str__comp1, ...arr__comp__rest] = tex.split("\\ ");
        //   logger.log("logNumberTyping", "str__comp1:", str__comp1);
        //   logger.log("logNumberTyping", "arr__comp__rest:", arr__comp__rest);
          
        //   const str__mathOperatorSymbol = str__comp1;
        //   const mathOperatorFuncName = Operator.funcNameForSymbolString(str__mathOperatorSymbol);
        //   if(mathOperatorFuncName != null) {
        //     const node_a = MathSingleton.node__empty;

        //     const str__b = arr__comp__rest[0];
        //     const node_b = math.parse(str__b);

        //     const node__operator = new math.OperatorNode(str__mathOperatorSymbol, mathOperatorFuncName, [node_a, node_b]);
        //     outNode = node__operator;
        //   } else {
        //     throw new Error("couldn't find a funcName match for str__mathOperatorSymbol: " + str__mathOperatorSymbol);
        //   } 
          
        //   return outNode;
        // }

        const nb_explArgSlot = StringUtils.count(tex, "..");
        logger.log("logNT", "nb_explArgSlot:", nb_explArgSlot);

        if(nb_explArgSlot != 0) {
          outMathNode = FuncUtils.tryCatch_wrapper(() => infiniteCanvas.numberTyping_parseTex_toOperatorNode__explicit(tex),   null);
        } else {
          outMathNode = FuncUtils.tryCatch_wrapper(() => infiniteCanvas.numberTyping_parseTex_toOperatorNode__implicit(tex),   null);
          outMathNode = outMathNode ? outMathNode : FuncUtils.tryCatch_wrapper(() => infiniteCanvas.numberTyping_parseTex_toOperatorNode__function(tex),   null);
          outMathNode = outMathNode ? outMathNode : FuncUtils.tryCatch_wrapper(() => infiniteCanvas.numberTyping_parseTex_toOperatorNode__assignment(tex),   null);
        }

        logger.log("logNT", "outMathNode:", outMathNode);

        return outMathNode;
      }

      numberTyping_parseTex_toOperatorNode__explicit(tex) {
        var outMathNode;

        function parseToOperatorNode__unary_pre__explicit(tex) {
          var outNode;

          //count how many ".." are found
          // const nb_explArgSlot = StringUtils.count(tex, "..");
          if(nb_explArgSlot != 1) {
            throw new Error("parseToOperatorNode__unary_pre__explicit: wrong number of explArgSlots (\"..\") in input tex: " + tex);
          }

          //add symbol at start of tex and check if parsed as operatorNode
          const str__symbol_pre      = "Ä";
          const tex__with_symbol_pre = tex.replace("..", str__symbol_pre);

          logger.log("logNT", "tex__with_symbol_pre:", tex__with_symbol_pre);

          const mathNode__parsed = math.parse(tex__with_symbol_pre);
          logger.log("logNT", "mathNode__parsed:", mathNode__parsed);


          const regex__frac = /\\frac{(.*)}{(.*)}/;
          const tex__with_symbol_pre__frac = tex__with_symbol_pre.replace(regex__frac, "math.fraction($1,$2)");
          // const tex__with_symbol_pre__frac = tex__with_symbol_pre.replace(regex__frac, "($1) / ($2)");
          const mathNode__parsed__frac = math.parse(tex__with_symbol_pre__frac);
          logger.log("logNT", "mathNode__parsed__frac:", mathNode__parsed__frac);


          if(mathNode__parsed instanceof math.OperatorNode) {
            logger.log("logNT", "mathNode__parsed:", mathNode__parsed);

            //replace mathNode__symbol__pre with node__empty
            outNode = Rewriter.substitute(mathNode__parsed, (mathNode) => {
              const isFound = ((mathNode instanceof math.SymbolNode) && (mathNode.name == str__symbol_pre));
              return isFound;
            }, (_) => {
              return MathSingleton.node__empty;
            });

          } else if(mathNode__parsed__frac instanceof math.FunctionNode) {

            //replace mathNode__symbol__pre with node__empty
            outNode = Rewriter.substitute(mathNode__parsed__frac, (mathNode) => {
              const isFound = ((mathNode instanceof math.SymbolNode) && (mathNode.name == str__symbol_pre));
              return isFound;
            }, (_) => {
              return MathSingleton.node__empty;
            });
            
          } else {
            throw new Error("couldn't find a funcName match for str__mathOperatorSymbol: " + str__mathOperatorSymbol);
          } 


          
          return outNode;
        }

        function parseToOperatorNode__unary_pre__explicit__frac(tex) {
          var outNode;

          //count how many ".." are found
          const nb_explArgSlot = StringUtils.count(tex, "..");
          if(nb_explArgSlot != 1) {
            throw new Error("parseToOperatorNode__unary_pre__explicit__frac: wrong number of explArgSlots (\"..\") in input tex: " + tex);
          }

          //add symbol at start of tex and check if parsed as operatorNode
          const str__symbol_pre      = "Ä";
          const tex__with_symbol_pre = tex.replace("..", str__symbol_pre);

          const regex__frac = /\\frac{(.*)}{(.*)}/;
          const tex__with_symbol_pre__frac = tex__with_symbol_pre.replace(regex__frac, "math.fraction($1,$2)");
          // const tex__with_symbol_pre__frac = tex__with_symbol_pre.replace(regex__frac, "($1) / ($2)");
          const mathNode__parsed__frac = math.parse(tex__with_symbol_pre__frac);
          logger.log("logNT", "mathNode__parsed__frac:", mathNode__parsed__frac);


          // if(mathNode__parsed instanceof math.OperatorNode) {
          //   logger.log("logNT", "mathNode__parsed:", mathNode__parsed);

          //   //replace mathNode__symbol__pre with node__empty
          //   outNode = Rewriter.substitute(mathNode__parsed, (mathNode) => {
          //     const isFound = ((mathNode instanceof math.SymbolNode) && (mathNode.name == str__symbol_pre));
          //     return isFound;
          //   }, (_) => {
          //     return MathSingleton.node__empty;
          //   });

          // } 
          // else
          if(mathNode__parsed__frac instanceof math.FunctionNode) {

            //replace mathNode__symbol__pre with node__empty
            outNode = Rewriter.substitute(mathNode__parsed__frac, (mathNode) => {
              const isFound = ((mathNode instanceof math.SymbolNode) && (mathNode.name == str__symbol_pre));
              return isFound;
            }, (_) => {
              return MathSingleton.node__empty;
            });

            //rewrite as OperatorNode
            // outNode = new math.OperatorNode("f/", "fracop", outNode.args); 
            outNode = new math.OperatorNode("/", "divide", outNode.args);
            
          } else {
            throw new Error("couldn't find a funcName match for str__mathOperatorSymbol: " + str__mathOperatorSymbol);
          } 
          
          return outNode;
        }

        function parseToOperatorNode__unary_post__explicit(tex) {
          var outNode;

          //count how many ".." are found
          const nb_explArgSlot = StringUtils.count(tex, "..");
          if(nb_explArgSlot != 1) {
            throw new Error("parseToOperatorNode__unary_post__explicit: wrong number of explArgSlots (\"..\") in input tex: " + tex);
          }

          //add symbol at end of tex and check if parsed as operatorNode
          const str__symbol_post      = "Ö";
          const tex__with_symbol_post = tex.replace("..", str__symbol_post);

          logger.log("logNT", "tex__with_symbol_post:", tex__with_symbol_post);


          const mathNode__parsed = math.parse(tex__with_symbol_post);
          if(mathNode__parsed instanceof math.OperatorNode) {
            logger.log("logNT", "mathNode__parsed:", mathNode__parsed);

            //replace mathNode__symbol__pre with node__empty
            outNode = Rewriter.substitute(mathNode__parsed, (mathNode) => {
              const isFound = ((mathNode instanceof math.SymbolNode) && (mathNode.name == str__symbol_post));
              return isFound;
            }, (_) => {
              return MathSingleton.node__empty;
            });

          } else {
            throw new Error("couldn't find a funcName match for str__mathOperatorSymbol: " + str__mathOperatorSymbol);
          } 
          
          return outNode;
        }

        function parseToOperatorNode__binary__explicit(tex) {
          var outNode;

          //count how many ".." are found
          const nb_explArgSlot = StringUtils.count(tex, "..");
          if(nb_explArgSlot != 2) {
            throw new Error("parseToOperatorNode__binary__explicit: wrong number of explArgSlots (\"..\") in input tex: " + tex);
          }

          //add symbol at start, and symbol at end of tex and check if parsed as operatorNode
          const str__symbol_pre      = "Ä";
          const str__symbol_post     = "Ö";
          var tex__with_symbols = tex;
          tex__with_symbols = tex__with_symbols.replace("..", str__symbol_pre);
          tex__with_symbols = tex__with_symbols.replace("..", str__symbol_post);

          const tex__with_symbols_pre_post = tex__with_symbols;

          logger.log("logNT", "tex__with_symbols_pre_post:", tex__with_symbols_pre_post);

          const mathNode__parsed = math.parse(tex__with_symbols_pre_post);
          if(mathNode__parsed instanceof math.OperatorNode) {
            logger.log("logNT", "mathNode__parsed:", mathNode__parsed);

            outNode = mathNode__parsed;
            //SHU: this is real strange: (but I don't care, I need to move on)

              //replace mathNode__symbol__pre  with node__empty
            // outNode = Rewriter.substitute(outNode, (mathNode) => {
            //   const isFound = ((mathNode instanceof math.SymbolNode) && (mathNode.name == str__symbol_pre));
            //   return isFound;
            // }, (_) => {
            //   return MathSingleton.node__empty;
            //   // return MathSingleton.node__empty.cloneDeep();
            // });
              //replace mathNode__symbol__post with node__empty
            // outNode = Rewriter.substitute(outNode, (mathNode) => {
            //   const isFound = ((mathNode instanceof math.SymbolNode) && (mathNode.name == str__symbol_post));
            //   return isFound;
            // }, (_) => {
            //   return MathSingleton.node__empty;
            //   // return MathSingleton.node__empty.cloneDeep();
            // });

            outNode = Rewriter.substitute(outNode, (mathNode) => {
              const isFound__pre  = ((mathNode instanceof math.SymbolNode) && (mathNode.name == str__symbol_pre));
              const isFound__post = ((mathNode instanceof math.SymbolNode) && (mathNode.name == str__symbol_post));

              const isFound = isFound__pre || isFound__post;

              return isFound;
            }, (_) => {
              return MathSingleton.node__empty;
              // return MathSingleton.node__empty.cloneDeep();
            });

          } else {
            throw new Error("couldn't find a funcName match for str__mathOperatorSymbol: " + str__mathOperatorSymbol);
          } 
          
          return outNode;
        }

        outMathNode = outMathNode ? outMathNode : FuncUtils.tryCatch_wrapper(() => parseToOperatorNode__unary_pre__explicit(tex), null);
        outMathNode = outMathNode ? outMathNode : FuncUtils.tryCatch_wrapper(() => parseToOperatorNode__unary_pre__explicit__frac(tex), null);

        outMathNode = outMathNode ? outMathNode : FuncUtils.tryCatch_wrapper(() => parseToOperatorNode__unary_pre__explicit(tex), null);
        outMathNode = outMathNode ? outMathNode : FuncUtils.tryCatch_wrapper(() => parseToOperatorNode__binary__explicit(tex),    null);

        return outMathNode;
      }

      numberTyping_parseTex_toOperatorNode__implicit(tex) {
        logger.log("numberTyping_parseTex_toOperatorNode__implicit", tex);
        var outMathNode;

        function parseToOperatorNode__unary_pre__implicit(tex) {
          var outNode;

          //add symbol at start of tex and check if parsed as operatorNode
          const str__symbol_pre      = "Ä";
          const tex__with_symbol_pre = str__symbol_pre + " " + tex;

          logger.log("logNT", "tex__with_symbol_pre:", tex__with_symbol_pre);


          const mathNode__parsed = math.parse(tex__with_symbol_pre);
          if(mathNode__parsed instanceof math.OperatorNode) {
            logger.log("logNT", "mathNode__parsed:", mathNode__parsed);

            //replace mathNode__symbol__pre with node__empty
            outNode = Rewriter.substitute(mathNode__parsed, (mathNode) => {
              const isFound = ((mathNode instanceof math.SymbolNode) && (mathNode.name == str__symbol_pre));
              return isFound;
            }, (_) => {
              return MathSingleton.node__empty;
            });

          } else {
            throw new Error("couldn't find a funcName match for str__mathOperatorSymbol: " + str__mathOperatorSymbol);
          } 
          
          return outNode;
        }

        function parseToOperatorNode__unary_post__implicit(tex) {
          var outNode;

          //add symbol at end of tex and check if parsed as operatorNode
          const str__symbol_post      = "Ö";
          const tex__with_symbol_post = tex + " " + str__symbol_post;

          logger.log("logNT", "tex__with_symbol_post:", tex__with_symbol_post);


          const mathNode__parsed = math.parse(tex__with_symbol_post);
          if(mathNode__parsed instanceof math.OperatorNode) {
            logger.log("logNT", "mathNode__parsed:", mathNode__parsed);

            //replace mathNode__symbol__pre with node__empty
            outNode = Rewriter.substitute(mathNode__parsed, (mathNode) => {
              const isFound = ((mathNode instanceof math.SymbolNode) && (mathNode.name == str__symbol_post));
              return isFound;
            }, (_) => {
              return MathSingleton.node__empty;
            });

          } else {
            throw new Error("couldn't find a funcName match for str__mathOperatorSymbol: " + str__mathOperatorSymbol);
          } 
          
          return outNode;
        }

        function parseToOperatorNode__binary__implicit(tex) {
          var outNode;

          //add symbol at start, and symbol at end of tex and check if parsed as operatorNode
          const str__symbol_pre      = "Ä";
          const str__symbol_post     = "Ö";
          const tex__with_symbols_pre_post = str__symbol_pre + " " + tex + " " + str__symbol_post;

          logger.log("logNT", "tex__with_symbols_pre_post:", tex__with_symbols_pre_post);

          const mathNode__parsed = math.parse(tex__with_symbols_pre_post);
          if(mathNode__parsed instanceof math.OperatorNode) {
            logger.log("logNT", "mathNode__parsed:", mathNode__parsed);

            //replace mathNode__symbol__pre  with node__empty
            //replace mathNode__symbol__post with node__empty
            outNode = mathNode__parsed;
            outNode = Rewriter.substitute(outNode, (mathNode) => {
              const isFound = ((mathNode instanceof math.SymbolNode) && (mathNode.name == str__symbol_pre));
              return isFound;
            }, (_) => {
              return MathSingleton.node__empty;
            });
            outNode = Rewriter.substitute(outNode, (mathNode) => {
              const isFound = ((mathNode instanceof math.SymbolNode) && (mathNode.name == str__symbol_post));
              return isFound;
            }, (_) => {
              return MathSingleton.node__empty;
            });

          } else {
            throw new Error("couldn't find a funcName match for str__mathOperatorSymbol: " + str__mathOperatorSymbol);
          } 
          
          return outNode;
        }

        outMathNode = outMathNode ? outMathNode : FuncUtils.tryCatch_wrapper(() => parseToOperatorNode__unary_pre__implicit(tex),   null);
        outMathNode = outMathNode ? outMathNode : FuncUtils.tryCatch_wrapper(() => parseToOperatorNode__unary_post__implicit(tex),  null);
        outMathNode = outMathNode ? outMathNode : FuncUtils.tryCatch_wrapper(() => parseToOperatorNode__binary__implicit(tex),      null);

        return outMathNode;
      }

      numberTyping_parseTex_toOperatorNode__function(tex) {
        var outMathNode;

        function parseAnon5050Function(tex) {
          var outMathNode;

          // const regex__function_5050 = /(.*)⊢\?→([^:]*)(:[^:]*)?(:[^:]*)?(:[^:]*)?(:[^:]*)?(:[^:]*)?(:[^:]*)?(:[^:]*)?(:[^:]*)?(:[^:]*)?/;
          const nb_output = 10;
          const str__re__function_5050 = "(.*)⊢\\?→([^:]*)".concat("(:[^:]*)?".repeat(nb_output - 1));
          const regex__function_5050 = new RegExp(str__re__function_5050);
          const is5050Function = regex__function_5050.test(tex);
          logger.log("logNT, parseAnon5050Function", "is5050Function:", is5050Function);
          if(is5050Function) {
            const arr_match = tex.match(regex__function_5050);
            logger.log("logNT, parseAnon5050Function", "arr_match:", arr_match);

            const str__args = arr_match[1];
                            
            const arr_bound_var           = str__args.split(",").map(str__var => new math.SymbolNode(str__var));
            // const mathNode__arr_bound_var = new math.ArrayNode(arr_bound_var);


            const str__expr0 = arr_match[2];
            const offset = 2;
            function func__removeStartingColon(str_in) {
              // return str_in.match(/:([^:]*)/)[1];
              return str_in.slice(1);
            }
            const arr_str__expr1plus = arr_match.slice(1+offset,nb_output+offset).filter((x) => x != null).map(func__removeStartingColon);
            logger.log("logNT, parseAnon5050Function", "arr_str__expr1plus:", arr_str__expr1plus);

            const arr_str__expr = [str__expr0, ...arr_str__expr1plus];
            logger.log("logNT, parseAnon5050Function", "arr_str__expr:", arr_str__expr);

            const arr_str__expr__refined = arr_str__expr.map((str__elt) => Algebrite.run(str__elt));
            logger.log("logNT, parseAnonymousFunction", "arr_str__expr__refined:", arr_str__expr__refined);

            const arr_mathNode__expr = arr_str__expr__refined.map((str__elt) => math.parse(str__elt));
            logger.log("logNT, parseAnonymousFunction", "arr_mathNode__expr:", arr_mathNode__expr);

            const mathNode__anon5050Function = MyAnon5050FunctionObjectNode.createInstance(arr_bound_var, arr_mathNode__expr);

            outMathNode = mathNode__anon5050Function;
          }

          return outMathNode;

        }

        function parseAnonymousFunction(tex) {
          var outMathNode;

          const regex__function = /(.*)↦(.*)/;
          const isFunction = regex__function.test(tex);
          logger.log("logNT, parseAnonymousFunction", "isFunction", isFunction);
          if(isFunction) {
            const arr_match = tex.match(regex__function);
            const str__args = arr_match[1];
            const str__expr = arr_match[2];
            
            const arr_bound_var           = str__args.split(",").map(str__var => new math.SymbolNode(str__var));
            // const mathNode__arr_bound_var = new math.ArrayNode(arr_bound_var);
            
            // const mathNode__expr = math.parse(str__expr);
            const str__expr__refined = Algebrite.run(str__expr);
            logger.log("logNT, parseAnonymousFunction", "str__expr__refined", str__expr__refined);
            const mathNode__expr = math.parse(str__expr__refined);


            const mathNode__anonFunction = MyAnonFunctionObjectNode.createInstance(arr_bound_var, mathNode__expr);

            outMathNode = mathNode__anonFunction;

            /*
              //META SHU: abandonné pour l'instant ?

              //SHU la même notation que dans still_shute:
              //[[6]] * [+ 5]          = [[11]]
              //[[4]] * [anonFunction] = [[anonFunction(4)]]
              // const mathNode__operator = new math.OperatorNode("*", "myApply", [MathSingleton.node__empty, mathNode__anonFunction]); 
              // outMathNode = mathNode__operator;
            */
          }

          return outMathNode;
        }

        outMathNode = outMathNode ? outMathNode : FuncUtils.tryCatch_wrapper(() => parseAnon5050Function(tex), null);
        outMathNode = outMathNode ? outMathNode : FuncUtils.tryCatch_wrapper(() => parseAnonymousFunction(tex),    null);

        return outMathNode;
      }

      numberTyping_parseTex_toOperatorNode__assignment(tex) {
        var outMathNode;

        function parseAssignmentExpression(tex) {
          var outMathNode;

          const regex__assign = /(.*)←(.*)/;
          const isFunction = regex__function.test(tex);
          logger.log("logNT, parseAnonymousFunction", "isFunction", isFunction);
          if(isFunction) {
            const arr_match = tex.match(regex__function);
            const str__args = arr_match[1];
            const str__expr = arr_match[2];
            
            const arr_bound_var           = str__args.split(",").map(str__var => new math.SymbolNode(str__var));
            const mathNode__arr_bound_var = new math.ArrayNode(arr_bound_var);
            
            // const mathNode__expr = math.parse(str__expr);
            const str__expr__refined = Algebrite.run(str__expr);
            logger.log("logNT, parseAnonymousFunction", "str__expr__refined", str__expr__refined);
            const mathNode__expr = math.parse(str__expr__refined);


            const mathNode__anonFunction = new math.ObjectNode({
              type: new math.SymbolNode("anonFunction"),

              mathNode__arr_bound_var: mathNode__arr_bound_var,
              expr:          mathNode__expr,
            });

            outMathNode = mathNode__anonFunction;

            /*
              //META SHU: abandonné pour l'instant ?

              //SHU la même notation que dans still_shute:
              //[[6]] * [+ 5]          = [[11]]
              //[[4]] * [anonFunction] = [[anonFunction(4)]]
              // const mathNode__operator = new math.OperatorNode("*", "myApply", [MathSingleton.node__empty, mathNode__anonFunction]); 
              // outMathNode = mathNode__operator;
            */
          }

          return outMathNode;
        }

        outMathNode = outMathNode ? outMathNode : FuncUtils.tryCatch_wrapper(() => parseAssignmentExpression(tex), null);

        return outMathNode;
      }


        //debug/horror
      numberTyping_parseTex_toOperatorNode__zZz(tex_in) {

        var tex = tex_in;

        if(tex == "\\times") {
          tex = "*";
        } 
        else if(tex == "\\frac{ }{ }") {
          tex = "/";
        }
      
        // if(tex == "+" 
        // || tex == "-"
        // || tex == "×"
        // || tex == "/") {
          const tex__forced = ".. " + tex + "..";
          const mathNode__op = infiniteCanvas.numberTyping_parseTex_toOperatorNode(tex__forced);
          return mathNode__op;
        // }

      }

      numberTyping_parseTex_to_dict(tex) {
        var outDict;

        outDict = {};

        //debug/horror
        if(tex == "+" 
        || tex == "-"
        || tex == "\\times"
        || tex == "\\frac{ }{ }") {
          const mathNode__op = infiniteCanvas.numberTyping_parseTex_toOperatorNode__zZz(tex);

          outDict.type     = "operatorNode";
          // outDict.subType  = "zZz";
          outDict.mathNode = mathNode__op;

          return outDict;
        }

        function refinedTex0(tex) {
          var outTex;

          // const isPlusOperator = /^\+\\/.test(tex);
          // logger.log("logNT", "isPlusOperator:", isPlusOperator);

          outTex = tex;

          outTex = outTex.replaceAll("\\left",  "");
          outTex = outTex.replaceAll("\\right", "");

          // outTex = outTex.replaceAll(":", "/");

          outTex = outTex.replace(/^\+\\/, "[＋]"); //"[" + U+FF0B + "]"
          outTex = outTex.replace(/^\-\\/, "[－]"); //"[" + U+FF0D + "]"

          outTex = outTex.replaceAll("\\ ", " ");

          // outTex = outTex.replaceAll("\\times", "\\cdot");
          outTex = outTex.replaceAll("\\times", "*");

          return outTex;
        }

        function refinedTex1(tex) {
          var outTex;

          // const isPlusOperator = /^\+\\/.test(tex);
          // logger.log("logNT", "isPlusOperator:", isPlusOperator);

          outTex = tex;

          outTex = outTex.replaceAll("\\left",  "");
          outTex = outTex.replaceAll("\\right", "");

          outTex = outTex.replaceAll(":", "/");

          outTex = outTex.replace(/^\+\\/, "[＋]"); //"[" + U+FF0B + "]"
          outTex = outTex.replace(/^\-\\/, "[－]"); //"[" + U+FF0D + "]"

          outTex = outTex.replaceAll("\\ ", " ");

          // outTex = outTex.replaceAll("\\times", "\\cdot");
          outTex = outTex.replaceAll("\\times", "*");

          return outTex;
        }

        function refinedTex2(tex) {
          var outTex;

          outTex = tex;
          outTex = outTex.replaceAll("[＋]", "+");  //"[" + U+FF0B + "]"
          outTex = outTex.replaceAll("[－]", "-");  //"[" + U+FF0D + "]"

          return outTex;
        }

        const tex__refined0 = refinedTex0(tex);
        logger.log("logNT", "tex__refined0:", tex__refined0);

        const tex__refined1 = refinedTex1(tex);
        logger.log("logNT", "tex__refined1:", tex__refined1);

        const tex__refined2 = refinedTex2(tex__refined1);
        logger.log("logNT", "tex__refined2:", tex__refined2);


        const mathNode__new      = infiniteCanvas.numberTyping_parseTex_toMathNode(tex__refined1);
        // mathNode__new.autoSimplify = true;

        if(mathNode__new != null) {
          outDict.type     = "mathNode";
          outDict.mathNode = mathNode__new;
        } else {
          outDict.type     = "operatorNode";

          const mathNode__op = infiniteCanvas.numberTyping_parseTex_toOperatorNode(tex__refined2);
          // logger.log("logNT", "mathNode__op:", mathNode__op);

          outDict.mathNode   = mathNode__op;
        }

        return outDict;
      }

      numberTyping_manageDictParsed(dict_parsed) {

        switch(dict_parsed.type) {
          case "operatorNode":
            {
              const mathNode__operator = dict_parsed.mathNode;

              //create/add icMathNode
              const position__icMathNode = this.getTrueCursor();
              const trueRect__operator = {
                x:      position__icMathNode.x,
                y:      position__icMathNode.y,
                width:  120,
                height: 120,
              };

              // const icMathNode = this.createIcMathNode(position__icMathNode.x, position__icMathNode.y, mathNode__operator);
              // this.addNewIcObject(icMathNode);

              const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect__operator, "from_operatorNode", {mathNode__operator: mathNode__operator});
              infiniteCanvas.addNewIcObject(gmOperator);
            }
            break;
          case "mathNode":
            {
              const mathNode__new = dict_parsed.mathNode;

              if(fabricIntegration.fabricCanvas.isDrawingMode) {
                //create/add divided segment
                // const position__icMathNode = this.getTrueCursor();
                // const mathNode   = this.mathNode_numberTyping.cloneDeep();
                // const dividedSegment = this.createIcMathNode(position__icMathNode.x, position__icMathNode.y, mathNode);
                // this.addNewIcObject(icMathNode);
    
              } else {
    
                //create/add icMathNode
                const position__icMathNode = this.getTrueCursor();
                const mathNode   = mathNode__new.cloneDeep();
                mathNode.autoSimplify = true;
                const icMathNode = this.createIcMathNode(position__icMathNode.x, position__icMathNode.y, mathNode);
                icMathNode.isTouchable = true;
                this.addNewIcObject(icMathNode);
              }
            }
            break;
          default:
            {

            }
            break;
        }

      }

      numberTyping_manageDictParsed__operatorNode(dict_parsed) {

        try {
          mathNode__anon5050Function = parseAnon5050Function(tex__refined0);
          logger.log("logNT", "anon5050Function, mathNode__anon5050Function:", mathNode__anon5050Function);
          // logger.log("logNT", "anon5050Function, mathNode__anon5050Function.toTex():",    mathNode__anon5050Function.toTex());
          // logger.log("logNT", "anon5050Function, mathNode__anon5050Function.toString():", mathNode__anon5050Function.toString());
        } catch(e) {
          logger.log("logNT", "couldn't parse anon5050FuncString: ", tex__refined0, "error: ", e);
        }

        if(mathNode__anon5050Function != null) {
          //create/add icMathNode
          const position__icMathNode = this.getTrueCursor();
          const trueRect__operator = {
            x:      position__icMathNode.x,
            y:      position__icMathNode.y,
            width:  120,
            height: 120,
          };

          const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect__operator, "from_anon5050FunctionObjectNode", {mathNode__anon5050Function: mathNode__anon5050Function});
          infiniteCanvas.addNewIcObject(gmOperator);

        } else {

          //is input an anonymous function definition ?
          var mathNode__anonFunction;

          try {
            mathNode__anonFunction = parseAnonymousFunction(tex__refined1);
            logger.log("logNT", "anonymousFunction, mathNode__anonFunction:", mathNode__anonFunction);
            // logger.log("logNT", "anonymousFunction, mathNode__anonFunction.toTex():", mathNode__anonFunction.toTex());
            // logger.log("logNT", "anonymousFunction, mathNode__anonFunction.toString():", mathNode__anonFunction.toString());
          } catch(e) {
            logger.log("logNT", "couldn't parse anonFuncString: ", tex, "error: ", e);
          }

          if(mathNode__anonFunction != null) {
            //create/add icMathNode
            const position__icMathNode = this.getTrueCursor();
            const trueRect__operator = {
              x:      position__icMathNode.x,
              y:      position__icMathNode.y,
              width:  120,
              height: 120,
            };

            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect__operator, "from_anonFunctionObjectNode", {mathNode__anonFunction: mathNode__anonFunction});
            infiniteCanvas.addNewIcObject(gmOperator);
          } else {

            var mathNode__operator;



            try {
              mathNode__operator = parseToOperatorNode__unary_pre__implicit(tex__refined2);
            } catch(e) {
              logger.log("logNT", "couldn't parse opString: ", tex, "error: ", e);

              try {
                mathNode__operator = parseToOperatorNode__unary_post__implicit(tex__refined2);
              } catch(e) {
                logger.log("logNT", "couldn't parse opString: ", tex, "error: ", e);

                try {
                  mathNode__operator = parseToOperatorNode__binary__implicit(tex__refined2);
                } catch(e) {
                  logger.log("logNT", "couldn't parse opString: ", tex, "error: ", e);
                }

              }

            }

            if(mathNode__operator != null) { 



            } else {
              
              //is input an assignment expression
              const miniDict__assignment = parseAssignmentExpression(tex__refined1);
              if(miniDict__assignment != null) {
                const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect__operator, "assign", {rhs: rhs});
                infiniteCanvas.addNewIcObject(gmOperator);
              }

            }

          }
        }

      }




      //microphone recording

      enterMicrophoneRecording() {
        logger.log("logNT", "enterMicrophoneRecording");
        const infiniteCanvas = this;

        // globalsSingleton.isEditing = true;
        infiniteCanvas.isMicrophoneRecording = true;

        //wad
        {
          //create wad
          const voice   = new Wad({source: 'mic'})
          const polywad = new Wad.Poly({
              recorder: {
                  options: { mimeType : 'audio/webm' },
                  onstop: function(event) {
                    let blob = new Blob(this.recorder.chunks, { 'type' : 'audio/webm;codecs=opus' });
                    // window.open(URL.createObjectURL(blob));
                    infiniteCanvas.func__handleRecordedBlob(blob);
                  },
              }
          })
          polywad.add(voice)
          voice.play()
          polywad.recorder.start()

          infiniteCanvas.polywad_microphoneRecording = polywad;
        }

      }

      leaveMicrophoneRecording() {
        logger.log("logNT", "leaveNumberTyping");
        const infiniteCanvas = this;

        infiniteCanvas.func__handleRecordedBlob = function(blob) {
          const audio = document.createElement("audio");
          audio.src   = blob;
          infiniteCanvas.addNewAudio(audio);   
        };
        const polywad = infiniteCanvas.polywad_microphoneRecording;
        
        polywad.recorder.stop();

        infiniteCanvas.isMicrophoneRecording = false;
        // globalsSingleton.isEditing  = false;
      }


      //io pasting (==pasting stuff from inside (== from aui) or from outside (== from browser's clipboard))

      enterIOPasting() {
        logger.log("logCP", "enterIOPasting");
        this.isIOPasting           = true;

        // globalsSingleton.isEditing = true;
        // this.isNumberTyping        = true;

        //add airlock


      }

      leaveIOPasting() {
        logger.log("logCP", "leaveIOPasting");
        const infiniteCanvas = this;


          navigator.clipboard.read()
          .then((arr_clipboardItem) => {
            var out_p;

            logger.log("logCP", "leaveIOPasting", "navigator.clipboard.read()", "arr_clipboardItem:", arr_clipboardItem);

            const clipboardItem = arr_clipboardItem.find(e => true);
            logger.log("logCP", "leaveIOPasting", "navigator.clipboard.read()", "clipboardItem:", clipboardItem);

            // const type__clipboardItem = clipboardItem.types.find(e => true);
            const type__clipboardItem = 'image/png';
            logger.log("logCP", "leaveIOPasting", "navigator.clipboard.read()", "type__clipboardItem:", type__clipboardItem);

            out_p = clipboardItem.getType(type__clipboardItem);

            out_p = out_p.then((blob) => {
              logger.log("logCP", "leaveIOPasting", "navigator.clipboard.read()", "blob:", blob);
            });
            // out_p = clipboardIntegration.outerToInner_p(clipboardEvent);

            //inner to ic
            // const infiniteCanvas = this.infiniteCanvas;

            out_p = out_p.then(content => {
              var outIcObj;

              logger.log("content", content);

              const true_cursor = infiniteCanvas.getTrueCursor();
              const trueRect = {
                x: true_cursor.x,
                y: true_cursor.y,
                width: 100,
                height: 100,
              };

              if (typeof content == "string") {
                const text = content;
                outIcObj = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
              } else if (content instanceof Image) {
                const img = content;
                outIcObj = infiniteCanvas.createIcImage(trueRect.x, trueRect.y, img);
              } else {
                outIcObj = infiniteCanvas.createIcRect(trueRect);
              }

              return outIcObj;
            });

            return out_p;
          }).then((icObj) => {
            infiniteCanvas.addPastedIcObject(icObj);
          });
        


        //add object to iC (== allow it to interact with other objects)

        //remove airlock

        this.isIOPasting         = false;
      }





      //batch pasting

      enterBatchPasting() {
        logger.log("logCP", "enterBatchPasting");
        this.isBatchPasting        = true;

        globalsSingleton.isEditing = true;
        this.isNumberTyping        = true;

        //mathQuill
        {
          //create mathField
          const mathField = createMathField();

          //add mathField root HTML element to canvasContainer
          const elt = mathField.el();
          console.log("elt", elt);

          if (elt.style == null) { elt.style = {}; }
          elt.style.position = "absolute";

          const canvasContainer = infiniteCanvas.canvas.parentElement;
          canvasContainer.appendChild(elt);    //SHU: move this to fabricIntegration

          // mathField.latex("");
          mathField.reflow();
          
          mathField.focus();

          //clear
          // setTimeout(() => {
          //   mathField.latex("");
          //   mathField.reflow();
          // }, 0);
          

          logger.log("logMQ", "mathField", mathField);

          this.mathField_numberTyping = mathField;
        }

      }

      leaveBatchPasting() {
        logger.log("logCP", "leaveBatchPasting");
        const infiniteCanvas = this;

        const mathField = this.mathField_numberTyping;

        //mathQuill
        {

          //transfer tex
          {
            const tex = mathField.latex();
            console.log("tex", tex);

            //this is where fun starts
            function mathFieldTex_to_mathNode(tex) {
              var outMathNode;

              try {

                // outMathNode = math.parse(tex);

                const mathExpression = MathExpression.fromLatex(tex);
                const text = mathExpression.toString();
                console.log("text", text);
                outMathNode = math.parse(text);

                //don't parse "=" into ":="

                //upgrade to gmOperator when writing "x50"
              } catch {
                outMathNode = null;
              }

              return outMathNode;
            }

            const mathNode__new = mathFieldTex_to_mathNode(tex);
            // mathNode__new.autoSimplify = true;

            //store generated mathNode
            this.mathNode_numberTyping = mathNode__new;
          }

          //remove all listeners
          // mathField.el().removeEventListener("focusout", eventListener);
          $(mathField.el()).off();

          //remove mathField elt from canvasContainer
          mathField.el().remove();

          //destroy mathField
          mathField.revert();
        }

        if(this.mathNode_numberTyping != null) {

          if(fabricIntegration.fabricCanvas.isDrawingMode) {
            // //create/add divided segment
            // const position__icMathNode = this.getTrueCursor();
            // const mathNode   = this.mathNode_numberTyping.cloneDeep();
            // const dividedSegment = this.createIcMathNode(position__icMathNode.x, position__icMathNode.y, mathNode);
            // this.addNewIcObject(icMathNode);

          } else {
            //create/add clones
            const position__icMathNode = this.getTrueCursor();
            
            const mathNode             = this.mathNode_numberTyping.cloneDeep();
            const value                = mathNode.evaluate({});

            const rx_get_arr_bclone = clipboardIntegration.rx_innerCopy.pipe(
              Rx_operators.take(1), 
              Rx_operators.map((innerCopyEvent) => {
                // logger.log("logCP", "rx_get_arr_bclone", "innerCopyEvent:", innerCopyEvent);

                const icObj__cloned = innerCopyEvent.clipboardObject.content;

                const nb_reclones = value - 1;
                const arr_icObj__bclone = [...Array(nb_reclones).keys()].reduce((acc, index) => {
                  // logger.log("logCP", "rx_get_arr_bclone", "reduce", acc, index);

                  //get last created clone
                  const icObj__bClone = acc[index];
                  
                  //reclone, shift it, and copy it {
                  const icObj__recloned = icObj__bClone.deepClone();
                  icObj__recloned.position.x += 10;
                  icObj__recloned.position.y += 10;

                  //shift id(s) 
                  if(icObj__bClone.type == "composite") {
                    CompositeUtils.shiftToNextAvailableId(icObj__recloned, icObj__bClone, infiniteCanvas);
                  } else {
                    icObj__recloned.id = infiniteCanvas.generateIcObjectId();
                  }

                  //if last to be created, copy to clipboard
                  if(index == (nb_reclones - 1)) {
                    clipboardIntegration.manageInnerCopy("fabric.general", icObj__recloned);
                  }

                  acc = [...acc, icObj__recloned];
                  return acc;
                }, [icObj__cloned]);

                return arr_icObj__bclone;
              })
            );


            function spawn_bclones() {
              rx_get_arr_bclone.subscribe({
                next: (arr_icObj__bclone) => {
                  logger.log("logCP", "spawn_bclones", "arr_icObj__bclone:", arr_icObj__bclone);
                  infiniteCanvas.addPastedIcObjects(arr_icObj__bclone);
                },
              });
            }

            spawn_bclones();

          }

        }


        this.mathNode_numberTyping  = null;
        this.mathField_numberTyping = null;

        this.isNumberTyping         = false;
        globalsSingleton.isEditing  = false;

        this.isBatchPasting         = false;
      }





      //events

      manageMoveEvent(moveEvent) {
        logger.log("manageMoveEvent", moveEvent);

        //get icObj
        const id__icObj = moveEvent.data.id;
        const rep_free = this.getRepresented(id__icObj).r_free();

        //"apply" event
        const position__new = moveEvent.data.position;
        rep_free.position = position__new;
      }

      manageMoveEvent_debug() {
        const id__icObj = 1;
        const moveEvent__random = this.createRandomMoveEvent(id__icObj);
        this.manageMoveEvent(moveEvent__random);
      }

      createRandomMoveEvent(id__icObj) {

        const x = Math.random() * 500;
        const y = Math.random() * 500;

        var time = performance.now();
        logger.log("time", time);

        const moveEvent = {
          type: "move",
          time: time,
          data: {
            id: id__icObj,
            position: {
              x: x,
              y: y,
            },
          },
        };

        return moveEvent;
      }


      manageReplay() {

      }

      manageReplay_debug() {

        const infiniteCanvas = this;

        const replayStream_p = eventstore__global.getReplay({
          // fromPosition: 7,
          // toPosition: 23
        });

        replayStream_p.then(readEventStream_p)
          .then(arr_event__replay => {
            // logger.log("arr_event__replay", arr_event__replay);

            const event__first = arr_event__replay[0];
            const time__first = event__first.data.time;
            const arr_replayEvent = arr_event__replay.map(event => {
              const event__clone = Object.assign({}, event);

              const time__event = event__clone.data.time
              event__clone.timeout = time__event - time__first;

              return event__clone;
            });

            arr_replayEvent.forEach((replayEvent, i) => {
              setTimeout(() => {
                infiniteCanvas.manageMoveEvent(replayEvent);
              }, replayEvent.timeout);
            });

          });

      }

      manageReplay_debug__machineGun() {

        const infiniteCanvas = this;

        const replayStream_p = eventstore__global.getReplay({
          // fromPosition: 7,
          // toPosition: 23
        });

        replayStream_p.then(readEventStream_p)
          .then(arr_event__replay => {
            // logger.log("arr_event__replay", arr_event__replay);

            const event__first = arr_event__replay[0];
            const time__first = event__first.data.time;

            const event__last = arr_event__replay[arr_event__replay.length - 1];
            const time__last = event__last.data.time;

            const duration__src = time__last - time__first;

            // const nb__iter         = 1000;
            const nb__iter = 50;

            const duration__all = 10000;
            const duration__dst = duration__all / nb__iter;

            const factor__scaletime = duration__dst / duration__src;

            [...Array(nb__iter).keys()].forEach((index__iter, i) => {

              const arr_replayEvent = arr_event__replay.map(event => {
                const event__clone = Object.assign({}, event);

                const time__event = event__clone.data.time
                event__clone.timeout = index__iter * duration__dst + (time__event - time__first) * factor__scaletime;

                return event__clone;
              });

              arr_replayEvent.forEach((replayEvent, i) => {
                setTimeout(() => {
                  infiniteCanvas.manageMoveEvent(replayEvent);
                }, replayEvent.timeout);
              });

            });


          });

      }


      //recording

      manageEnterOrLeaveRecording() {
        logger.log("manageEnterOrLeaveRecording");

        if (!this.isRecording) {
          this.manageEnterRecording();
        } else {
          this.manageLeaveRecording();
        }
      }

      manageEnterRecording() {
        this.createIcReplay_start();
        this.isRecording = true;
      }

      manageLeaveRecording() {
        this.isRecording = false;
        this.createIcReplay_end();
      }









      //save/load

      createInfinishute_p() {

        const counter = this.counter;
        const offset = this.offset;
        const scale = this.scale;
        const orientation = this.orientation;

        // const arr_icObjects_serial_p = this.icObjects.any.map(icObj => icObj.toSerial_p());
        // console.log("this.icObjects['any'].length", this.icObjects['any'].length);
        // console.log("this.icObjects.any.length",    this.icObjects.any.length);

        const arr_official_serial_p = Object.values(this.represented)
          .filter(represented => {    //don't serialize supervessel
            const isSupervessel = represented.r_official().isSupervessel;
            return !isSupervessel;
          })
          .map(represented => represented.officialSerial_p());
        const all_official_serial_p = Promise.all(arr_official_serial_p);

        // const arr_rep_serial_p = Object.values(this.representations).map(rep => rep.toSerial_p());
        // const all_rep_serial_p = Promise.all(arr_rep_serial_p);

        const infinishute_p = all_official_serial_p.then((arr_official_serial) => {
          const infinishute = {};

          infinishute.offset = offset;
          infinishute.scale = scale;
          infinishute.orientation = orientation;

          infinishute.counter = counter;

          infinishute.official = arr_official_serial.reduce((acc, official) => {
            console.log("official",)
            acc[official.id] = official;
            return acc;
          }, {});

          // infinishute.representations = arr_rep_serial.reduce((acc, rep) => {
          //   acc[rep.id_rep] = rep;
          //   return acc;
          // }, {});

          return infinishute;
        });

        return infinishute_p;
      }

      manageSaveInfinishute_p() {

        const infiniteCanvas = this;
        const infinishute_p = this.createInfinishute_p();

        return infinishute_p

          //debug
          .then(infinishute => {
            console.log("infinishute", infinishute);
            return infinishute;
          })

          .then(infinishute => {
            return FileIntegration.saveInfinishute_p(infinishute);
          })
          .then(success => {
            console.log("saveInfinishute_p", "success", success);
            infiniteCanvas.setChanged(!success);
          });
      }

      manageSaveInfinishute_p_2(infinishute_p) {

        return infinishute_p
          .then(infinishute => {
            return FileIntegration.saveInfinishute_p(infinishute);
          })
          .then(success => {
            console.log("saveInfinishute_p", "success", success);
            infiniteCanvas.setChanged(!success);
          });

      }


      manageLoadInfinishute(json) {
        console.log("manageLoadInfinishute", json);

        this.offset = json.offset;
        this.scale = json.scale;
        this.orientation = json.orientation;

        // this.counter = json.counter;
        this.counter = Math.max(this.counter, json.counter);

        const infiniteCanvas = this;

        const arr_official = Object.values(json.official);

        const arr_icObj_p = arr_official.map((json_icObject, i) => {
          const icObj_p = IcObject.fromJson_p(json_icObject);
          return icObj_p;
        });

        Promise.all(arr_icObj_p)
          .then(arr_icObj => {
            console.log("manageLoadInfinishute", "arr_icObj", arr_icObj);

            arr_icObj.forEach((icObj, i) => {
              logger.log("log1", "manageLoadInfinishute", "icObj", icObj);

              infiniteCanvas.addDehydratedIcObject(icObj);
              // infiniteCanvas.addRepresented(icObj);
            });

            // //sort by zIndex
            // const arr__sorted = [...arr_icObj].toSorted((icObj1, icObj2) => {
            //   return icObj1.zIndex > icObj2.zIndex;
            // });
            //
            // const zip = (a, b) => a.map((k, i) => [k, b[i]]);
            // const arr_zIndex = [...arr__sorted.keys()].map((index) => {
            //   return index + 100;                                           //because supervessel has zIndex == 0
            // });
            //
            // const arr__rezindexed = zip(arr__sorted, arr_zIndex).map(([icObj, zIndex__new]) => {
            //   icObj.zIndex = zIndex__new;
            //   return icObj;
            // });
            //
            // arr__rezindexed.forEach((icObj, i) => {
            //   logger.log("log1", "manageLoadInfinishute", "icObj", icObj);
            //
            //   infiniteCanvas.addDehydratedIcObject(icObj);
            //   // infiniteCanvas.addRepresented(icObj);

          });

      }


      //core mutators

      updateCursor(cursor) {
        // console.log("updateCursor", cursor);
        this.previousCursor = Object.assign({}, this.cursor);
        this.cursor = Object.assign({}, cursor);
      }


      updateOffset(offset_new) {
        console.log("updateOffset", offset_new);

        this.previousOffset = Object.assign({}, this.offset);

        this.offset = Object.assign({}, offset_new);

        this.dOffset.dx = this.offset.dx - this.previousOffset.dx;
        this.dOffset.dy = this.offset.dy - this.previousOffset.dy;

        // this.redrawCanvas(RedrawOccasion.offsetChanged);

        // this.didUpdateListenersDict["offsetChanged"].forEach((listener, i) => {
        //   listener(this);
        // });

      }

      updateScale(scale_new) {
        this.scale = Object.assign({}, scale_new);
        // this.update("scale", Object.assign({}, scale_new));

        this.didUpdateListenersDict["scaleChanged"].forEach((listener, i) => {
          listener(this);
        });
      }


      updateDOffset(dOffset_new) {

        if(this.isPovBeing_setPovd__portal_crossing) {
          logger.log("logPOV", "updateDOffset", "ignored");
          return;
        }

        const offset_new = {
          dx: this.offset.dx + dOffset_new.dx,
          dy: this.offset.dy + dOffset_new.dy,
        };
        this.updateOffset(offset_new);
      }

      updateScaleAndDOffset(scale_new, dOffset) {
        // logger.log("updateScaleAndDOffset", scale_new, dOffset);

        if(this.isPovBeing_setPovd__portal_crossing) {
          logger.log("logPOV", "updateScaleAndDOffset", "ignored");
          return;
        }

        this.updateScale(scale_new);
        this.updateDOffset(dOffset);
      }

      updateScaleAndOffset(scale_new, offset) {
        // logger.log("updateScaleAndOffset", scale_new, offset);

        if(this.isPovBeing_setPovd__portal_crossing) {
          logger.log("logPOV", "updateScaleAndOffset", "ignored");
          return;
        }

        this.updateScale(scale_new);
        this.updateOffset(offset);
      }

      updateOrientation(orientation_new) {
        console.log("updateOrientation", orientation_new);
        var orientation_bounded = Geometry.boundedAngleInDegrees(orientation_new);
        console.log("orientation_bounded", orientation_bounded);
        this.orientation = orientation_bounded;
      }

      updateWithDRotation(angleInDegrees, noOrCenterPoint) {
        console.log("updateWithDRotation", angleInDegrees, noOrCenterPoint);

        console.log("angleInDegrees", angleInDegrees);

        const radius = Geometry.norm_2d(noOrCenterPoint);

        // this.addPurePoint(centerPoint);
        // this.addPureCircle(centerPoint, radius);

        // this.addPoint(noOrCenterPoint);
        // this.addCircle(noOrCenterPoint, radius);

        const orientation_new = this.orientation - angleInDegrees;
        this.updateOrientation(orientation_new);


        const v = {
          x: noOrCenterPoint.x,
          y: noOrCenterPoint.y,
        };
        // console.log("v.x", v.x);
        // console.log("v.y", v.y);

        const angleInRadians = angleInDegrees / 180 * Math.PI;

        const ddx = Math.cos(angleInRadians) * v.x - Math.sin(angleInRadians) * v.y;
        const ddy = Math.sin(angleInRadians) * v.x + Math.cos(angleInRadians) * v.y;
        // console.log("ddx", ddx);
        // console.log("ddy", ddy);

        const dx = v.x - ddx
        const dy = v.y - ddy;
        // console.log("dx", dx);
        // console.log("dy", dy);


        const doffset_new = {
          dx: dx,
          dy: dy,
        };
        // console.log("doffset_new", doffset_new);

        this.updateDOffset(doffset_new);


      }


      updateWithDOrientation(dOrientation) {
        const orientation_new = this.orientation + dOrientation;
        this.updateOrientation(orientation_new);

        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }


      move_to_initial_position() {
        console.log("move_to_initial_position");
        this.updateScaleAndOffset(this.coords_initial.scale, this.coords_initial.offset);
      }

      move_to_position(position) {
        console.log("move_to_position", position);

        const offset = {
          dx: -position.x,        //SHU: this is a bit ???
          dy: -position.y,
        };
        this.updateScaleAndOffset(this.scale, offset);
        this.redrawCanvas(RedrawOccasion.offsetChanged);
      }



      /* POVs */

      // getCurrentPov() {
      //   const center   = this.getTrueCenterPoint();
      //   const trueRect = this.getCanvasBoundingTrueRect();
      //   const size = {
      //     width:  trueRect.width,
      //     height: trueRect.height,
      //   };
      //   return new POV(this.scale, center, size);
      // }

      getCurrentPov() {
        const center   = this.getTrueCenterPoint();
        // const trueRect = this.getCanvasBoundingTrueRect();
        const trueRect = this.getShownRect();
        const size = {
          width:  trueRect.width,
          height: trueRect.height,
        };
        return new POV(this.scale, center, size);
      }

      set_pov(pov, cb = null) {
        logger.log("logPOV", "set_pov", pov, cb);
        const offset__new = {
          dx: pov.size.width  / 2.0 - pov.center.x,
          dy: pov.size.height / 2.0 - pov.center.y,
        };
        this.updateScaleAndOffset(pov.scale, offset__new);
        // this.redrawCanvas(RedrawOccasion.povChanged);
        this.redrawCanvas(RedrawOccasion.scaleChanged);

        if(cb != null) {
          cb();
        }
      }

      move_to_pov__animation(pov_to, cfg_anim__easy) {
        const infiniteCanvas = this;

        const pov_from = Object.assign({}, this.getCurrentPov());

        const animatedObj = {
          t: 0,
        };
        const cfg_anim = Object.assign({
          // targets: countDownEngine,
          targets: animatedObj,

          /*animated props*/
          t: 1,
          /*--------------*/

          direction: 'normal',

          // easing:    'easeInOutExpo',  //SHU: this one is good too
          easing:    'easeOutExpo',

          duration: cfg_anim__easy.duration,

          autoplay: false,

          update: (anim) => {
            logger.log("logPov", "anim:", anim);
            const t = animatedObj.t;
            const pov__progress = infiniteCanvas.getPovForProgress(pov_from, pov_to, t);
            // logger.log("logPov", "pov__progress", pov__progress);
            infiniteCanvas.set_pov(pov__progress);
          },
        }, cfg_anim__easy);

        const animation = anime(cfg_anim);
        animation.play();

      }

      getPovForProgress(pov_from, pov_to, progress) {
        const arr_propPaths = [
          "scale.X",
          "scale.Y",
          "center.x",
          "center.y",
          "size.width",
          "size.height",
        ];
        
        const pov_progress = arr_propPaths.reduce((acc, propPath) => {
          const prop_from = Utils.getPropForPropPath(pov_from, propPath);
          const prop_to   = Utils.getPropForPropPath(pov_to,   propPath);

          //linear progress
          var prop_progress;
          if(propPath.includes("scale")) {
            prop_progress = 1/(1/prop_from + (1/prop_to - 1/prop_from) * progress);
          } else {
            prop_progress = prop_from + (prop_to - prop_from) * progress;
          }

          Utils.setPropAtPropPath(acc, propPath, prop_progress);

          return acc;
        }, {});

        return pov_progress;
      }

      getPovForIcObj(icObj) {
        const trueRect      = Geometry.createLTRect(icObj.getTrueRect2());
        const center__icObj = Geometry.getCenterPoint(trueRect);

        const screenCenter = infiniteCanvas.getScreenCenterPoint();
        const trueOffset   = {
          dx: screenCenter.x / icObj.homeScale.X, 
          dy: screenCenter.y / icObj.homeScale.Y,
        };

        const center__true = {
          x: center__icObj.x - trueOffset.dx,
          y: center__icObj.y - trueOffset.dy,
        };

        const size = {
          width:  trueRect.width,
          height: trueRect.height,
        };
        return new POV(icObj.homeScale, center__true, size);
      }

      move_to_pov__autoPov(icObj) {
        const pov = this.getPovForIcObj(icObj);
        this.set_pov(pov);
      }

      getPovForIcObj__TL(icObj) {
        const trueRect = Geometry.createLTRect(icObj.getTrueRect2());

        const pointTL = Geometry.getPointTL(trueRect);

        const size = {
          width:  trueRect.width,
          height: trueRect.height,
        };
        return new POV(icObj.homeScale, pointTL, size);
      }

      move_to_pov__autoPov__TL(icObj) {
        const pov = this.getPovForIcObj__TL(icObj);
        this.set_pov(pov);
      }


      getPov2WrtIcObj2_sameWayAsPov1WrtIcObj1(icObj2, pov1, icObj1) {

        //compute relative rect for pov1 in icObj__portal_in
        const trueRect2__pov1   = pov1.getTrueRect2();
        logger.log("logPOV", "getPov2", "trueRect2__pov1:", trueRect2__pov1);

        const trueRect2__icObj1 = icObj1.getTrueRect2();
        logger.log("logPOV", "getPov2", "trueRect2__icObj1:", trueRect2__icObj1);
        const trueRect2__icObj2 = icObj2.getTrueRect2();
        logger.log("logPOV", "getPov2", "trueRect2__icObj2:", trueRect2__icObj2);


        //get same w/h ratio rect: rect D
        // const trueRect__icObj1 = icObj1.getTrueRect();
        // const trueRect__icObj2 = icObj2.getTrueRect();

        // var factor__scale;
        // const ratio_w = trueRect__icObj1.width  / trueRect__icObj2.width;
        // logger.log("logPOV", "getPov2", "ratio_w:", ratio_w);
        // const ratio_h = trueRect__icObj1.height / trueRect__icObj2.height;
        // logger.log("logPOV", "getPov2", "ratio_h:", ratio_h);

        // if(ratio_w < ratio_h) {
        //   factor__scale = ratio_w;
        // } else {
        //   factor__scale = ratio_h;
        // }
        // logger.log("logPOV", "getPov2", "factor__scale:", factor__scale);

        
        const trueRect2__D = {
          x:      trueRect2__icObj2.x,
          y:      trueRect2__icObj2.y,
          width:  trueRect2__icObj2.width   /* * factor__scale*/,
          height: trueRect2__icObj2.height  /* * factor__scale*/,
        };
        logger.log("logPOV", "getPov2", "trueRect2__D:", trueRect2__D);


        const trueRect2__C = Geometry.getRectC_from_rectsAB_and_rectD(trueRect2__pov1, trueRect2__icObj1, trueRect2__D);
        logger.log("logPOV", "getPov2", "trueRect2__C:", trueRect2__C);

        //descale
        const trueRect2__pov2 = {
          x:      trueRect2__C.x     /*- trueRect2__C.x / factor__scale*/,
          y:      trueRect2__C.y     /*- trueRect2__C.y / factor__scale*/,
          width:  trueRect2__C.width,
          height: trueRect2__C.height,
        };

        const pov2   = infiniteCanvas.createPOVWithRect(trueRect2__pov2);
        logger.log("logPOV", "pov2:", pov2);

        return pov2;
      }




      show_rect(rect) {
        //get pov to show and contain rect
        const pov = this.centeredPovForRect(rect);

        this.set_pov(pov);
      }

      move_to_rect__animation(rect__dst, cfg_anim__easy) {
        logger.log("move_to_rect__animation", rect__dst, cfg_anim__easy);

        const pov__dst = infiniteCanvas.centeredPovForRect(rect__dst);
        infiniteCanvas.move_to_pov__animation(pov__dst, cfg_anim__easy);
      }

      povForRect(rect_target) {
        throw new Error("lol");
      }

      centeredPovForRect(rect__dst) {
        // logger.log("centeredPovForRect", rect__dst);
        const infiniteCanvas = this;

        const rect__src = infiniteCanvas.getShownRect();
        // logger.log("rect__src", rect__src);
        // logger.log("rect__dst", rect__dst);

        const pointCenter__src = Geometry.getCenterPoint(Geometry.createLTRect(rect__src));
        // logger.log("pointCenter__src", pointCenter__src);

        const pointCenter__dst = Geometry.getCenterPoint(Geometry.createLTRect(rect__dst));
        // logger.log("pointCenter__dst", pointCenter__dst);

        const length_max__src = Math.max(rect__src.width, rect__src.height);
        const length_max__dst = Math.max(rect__dst.width, rect__dst.height);
        
        var scaleFactor_to_contain_dstRect;
        if(rect__dst.width >= rect__dst.height) {
          scaleFactor_to_contain_dstRect = 1.0 / (rect__dst.width / rect__src.width);
        } else {
          scaleFactor_to_contain_dstRect = 1.0 / (rect__dst.height / rect__src.height);
        }

        const scale__dst = {
          X: infiniteCanvas.scale.X * scaleFactor_to_contain_dstRect,
          Y: infiniteCanvas.scale.Y * scaleFactor_to_contain_dstRect,
        };
        // logger.log("scale__dst", scale__dst);

        const size__dst = {
          width:  rect__src.width  / scaleFactor_to_contain_dstRect, 
          height: rect__src.height / scaleFactor_to_contain_dstRect,
        };

        const pov = new POV(scale__dst, pointCenter__dst, size__dst);

        return pov;
      }

      topLeftPovForRect(rect__dst) {
        // logger.log("centeredPovForRect", rect__dst);
        const infiniteCanvas = this;

        const rect__src = infiniteCanvas.getShownRect();

        const pointCenter__src = Geometry.getCenterPoint(Geometry.createLTRect(rect__src));
        // logger.log("pointCenter__src", pointCenter__src);

        const pointCenter__dst = Geometry.getCenterPoint(Geometry.createLTRect(rect__dst));
        // logger.log("pointCenter__dst", pointCenter__dst);

        const length_max__src = Math.max(rect__src.width, rect__src.height);
        const length_max__dst = Math.max(rect__dst.width, rect__dst.height);
        
        var scaleFactor_to_contain_dstRect;
        if(rect__dst.width >= rect__dst.height) {
          scaleFactor_to_contain_dstRect = 1.0 / (rect__dst.width / rect__src.width);
        } else {
          scaleFactor_to_contain_dstRect = 1.0 / (rect__dst.height / rect__src.height);
        }

        const scale__dst = {
          X: infiniteCanvas.scale.X * scaleFactor_to_contain_dstRect,
          Y: infiniteCanvas.scale.Y * scaleFactor_to_contain_dstRect,
        };

        const size__dst = {
          width:  rect__dst.width, 
          height: rect__dst.height,
        };

        const pov = new POV(scale__dst, pointCenter__dst, size__dst);

        return pov;
      }






      storePOVRectAtIndex(icPOVRect, index) {
        this.dict_pov[index] = icPOVRect;
      }

      getStoredPOVRect(index) {
        const icPOVRect = this.dict_pov[index];
        return icPOVRect;
      }








      manageImport__image(img) {
        this.addNewImage(img);
      }

      manageImport__video(video) {
        this.addNewVideo(video);
      }

      manageImport__audio(audio) {
        this.addNewAudio(audio);
      }

      manageImport__text(text) {
        this.addNewText(text);
      }

      manageImport__htmlObject(htmlObject) {
        this.addNewHTMLObject(htmlObject);
      }

      manageImport__pdf(dict_pdf) {
        this.addNewPDF(dict_pdf);
      }


      //top down request
      requestViewUpdateForIcObj(icObj) {
        console.log("requestViewUpdateForIcObj", icObj);
        this.requestSyncWithIcObjListeners.forEach((listener, i) => {
          listener(icObj);
        });
      }



      //ALL

      vitrify() {
        Object.values(this.represented)
          .forEach((represented, i) => {
            const r_free = represented.r_free();
            r_free.lock();
          });

      }

      vivify() {
        Object.values(this.represented)
          .forEach((represented, i) => {
            const r_free = represented.r_free();
            r_free.unlock();
          });

      }


    }




    class IcObject {

      constructor(id, type, position, size, homeScale) {
        this.id        = id;
        this.type      = type;

        this.position  = position;
        this.size      = size;       //"information" size    //gives an idea of the sharpness/heavyness of the object

        this.homeScale = homeScale;

        this.orientation = 0;
        this.scale = {
          X: 1.0,
          Y: 1.0,
        };
        this.flip = {
          X: false,
          Y: false,
        };

        this.zIndex = 0;


        this.fill = "";
        this.stroke = "";
        // this.colors = {};
        this.opacity = 1.0;

        this.strokeWidth = 3;

        this.backgroundColor = "";

        // this.hotState = {
        //   toBeDeleted: false,
        //
        //   perceptionScale: {
        //     X:1,
        //    Y:1,
        //   },
        // };

        this.canBeMoved = true;
        this.canBeRotated = true;
        this.canBeResized = true;
        this.canBeSelected = true;

        this.canBeHeld = true;

        // this.isSnapped     = false;
        this.isSnappable = true;
        this.snapState = SnapState.Unsnapped;
        this.snappedTo = -1;

        // this.isTouchable    = true;
        this.isTouchable = false;
        // this.touchState    = TouchState.Untouched;
        this.touchStateDict = {};


        // this.cType = "";
        this.cType = null;
        this.isMobile = false;
        this.compositeId = -1;

        this.isHeld = false;
        // this.addInteraction_hold();

        this.isUsingCenterPosition = false;

        this.isSelected = false;

        // this.exoObject     = null;

        this.didUpdateListeners = [];



        //ugliness from outer space
        this.counter__path = 0;
      }

      static fromJson_p(json_icObject) {
        logger.log("log2", "fromJson_p", json_icObject);

        const id        = json_icObject.id;
        const type      = json_icObject.type;

        const position  = json_icObject.position;
        const size      = json_icObject.size;

        const homeScale = json_icObject.homeScale;


        const icObj = new IcObject(id, type, position, size, homeScale);


        const scale = json_icObject.scale;
        icObj.scale = scale;

        const orientation = json_icObject.orientation;
        icObj.orientation = orientation;

        const flip = json_icObject.flip;
        icObj.flip = flip;

        const zIndex = json_icObject.zIndex;
        icObj.zIndex = zIndex;


        const fill = json_icObject.fill;
        icObj.fill = fill;
        const stroke = json_icObject.stroke;
        icObj.stroke = stroke;

        const backgroundColor = json_icObject.backgroundColor;
        icObj.backgroundColor = backgroundColor;

        const opacity = json_icObject.opacity;
        icObj.opacity = opacity;


        const isSnappable = json_icObject.isSnappable;
        icObj.isSnappable = isSnappable;
        const snapState = json_icObject.snapState;
        icObj.snapState = snapState;
        const snappedTo = json_icObject.snappedTo;
        icObj.snappedTo = snappedTo;


        const isTouchable = json_icObject.isTouchable;
        icObj.isTouchable = isTouchable;
        // const touchState = json_icObject.touchState;
        // icObj.touchState = touchState;
        const touchStateDict = json_icObject.touchStateDict;
        icObj.touchStateDict = touchStateDict;

        const isLocked = json_icObject.isLocked;
        icObj.isLocked = isLocked;

        const cType = json_icObject.cType;
        icObj.cType = cType;
        const isMobile = json_icObject.isMobile;
        icObj.isMobile = isMobile;
        const compositeId = json_icObject.compositeId;
        icObj.compositeId = compositeId;

        const isUsingCenterPosition = json_icObject.isUsingCenterPosition;
        icObj.isUsingCenterPosition = isUsingCenterPosition;

        // if(json_icObject.engine_serial != null) {
        //   const eType           = json_icObject.eType;
        //   icObj.eType           = eType;
        //   const engine_serial   = json_icObject.engine_serial;

        //   // const engine          = deserialize(engine_serial);
        //   // console.log("rehydrated engine", engine);
        //   // // engine.initialize()
        //   // icObj.engine          = engine;

        //   const virgin          = deserialize(engine_serial);

        //   icObj.engine            = {};
        //   icObj.engine.initialize = virgin.initialize.bind(icObj.engine);
        //   icObj.engine.virgin     = virgin;

        //   console.log("rehydrated engine", icObj.engine);


        //   const getScopeObj = deserialize(json_icObject.getScopeObj);
        //   icObj.getScopeObj = getScopeObj;
        // }
        if(json_icObject.dict_engine != null) {

          const dict_engine = Object.entries(json_icObject.dict_engine).reduce((acc, [eType, engineMiniDict_serial] ) => {
            const index_start   = engineMiniDict_serial.index_start;
            const engine_serial = engineMiniDict_serial.engine;

            const virgin      = deserialize(engine_serial);

            const engine      = {};
            engine.initialize = virgin.initialize.bind(engine);
            engine.virgin     = virgin;

            const engineMiniDict = {
              index_start: index_start,
              engine: engine,
            };
            acc[eType] = engineMiniDict;
            return acc;
          }, {});
          icObj.dict_engine = dict_engine;

          const getScopeObj = deserialize(json_icObject.getScopeObj);
          icObj.getScopeObj = getScopeObj;
        }



        var icObj_p = Promise.resolve(icObj);

        switch (icObj.type) {
          case "text":
          case "tag":
            const text = json_icObject.text;
            icObj.text = text;
            const textColor = json_icObject.textColor;
            icObj.textColor = textColor;
            const fontSize = json_icObject.fontSize;
            icObj.fontSize = fontSize;

            break;
          case "image":
            const img_serial = json_icObject.img;
            const img_p = FileIntegration.imageFromImgSrc_p(img_serial);

            const arr_p = [icObj_p, img_p];

            icObj_p = Promise.all(arr_p)
              .then(([icObj, img]) => {

                icObj.img = img;

                return icObj;
              });
            break;
          case "circle":
            const radius = json_icObject.radius;

            icObj.radius = radius;
            break;
          case "spotSegment":
            const point_start = json_icObject.point_start;
            const point_end = json_icObject.point_end;

            icObj.point_start = point_start;
            icObj.point_end = point_end;

            break;

          case "group":
            {
              const children = json_icObject.children;

              const arr_p = children.map(json_child => {
                const icObj = IcObject.fromJson_p(json_child);
                return icObj;
              });

              icObj_p = Promise.all(arr_p)
                .then((arr_icObj) => {
                  icObj.children = arr_icObj;

                  return icObj;
                });
            }
            break;

          case "freeDrawing":
          case "floodFill":
            const exoObject = json_icObject.exoObject;
            icObj.exoObject = exoObject;
            break;

          case "sparkle":
            {
              const img_serial = json_icObject.img;
              const img_p = FileIntegration.imageFromImgSrc_p(img_serial);

              const arr_p = [icObj_p, img_p];

              icObj_p = Promise.all(arr_p)
                .then(([icObj, img]) => {

                  icObj.img = img;

                  return icObj;
                });
            }
            break;

          case "touchSlot":
            {
              const touchSlotConfig_serial = json_icObject.touchSlotConfig_serial;
              const touchSlotConfig = deserialize(touchSlotConfig_serial);

              icObj_p = icObj_p
                .then(icObj => {

                  icObj.touchSlotConfig = touchSlotConfig;

                  return icObj;
                })

            }
            break;

          case "snapSlot":
            {
              const snapSlotConfig_serial = json_icObject.snapSlotConfig_serial;
              const snapSlotConfig = deserialize(snapSlotConfig_serial);

              icObj_p = icObj_p
                .then(icObj => {

                  icObj.snapSlotConfig = snapSlotConfig;

                  return icObj;
                })

            }
            break;

          case "composite":
            {
              const json_content   = json_icObject.content;
              const dict_json_part = json_icObject.parts;

              // const arr_p = parts.map(json_part => {
              //   const icObj = IcObject.fromJson_p(json_part);
              //   return icObj;
              // });
              // icObj_p = Promise.all(arr_p)
              // .then((arr_icObj) => {
              //   icObj.parts = arr_icObj;
              //
              //   // if(icObj.engine == null) {
              //   //   icObj.engine = Compositer.defaultCompositeEngine(icObj, icObj.parts);
              //   // }
              //
              //   return icObj;
              // });

              const arr_part_serial_miniDict_p = Object.entries(dict_json_part).reduce((acc, [partName, json_part]) => {
                const part_miniDict_p = IcObject.fromJson_p(json_part)
                  .then(icObj => {

                    const part_miniDict = {
                      [partName]: icObj,
                    };

                    return part_miniDict;
                  });

                acc.push(part_miniDict_p);
                return acc;
              }, []);

              icObj_p = Promise.all(arr_part_serial_miniDict_p)
                .then((arr_part_miniDict) => {
                  icObj.parts = {};
                  Object.assign(icObj.parts, ...arr_part_miniDict);

                  return icObj;
                });

              if(json_content != null) {

                const content_p = IcObject.fromJson_p(json_content);
                icObj_p = Promise.all([icObj_p, content_p])
                  .then(([icObj, content]) => {
                    icObj.content = content;
                    return icObj;
                  });

              }


              const compositeConfig_serial = json_icObject.compositeConfig_serial;
              const compositeConfig        = deserialize(compositeConfig_serial);

              icObj_p = icObj_p
                .then(icObj => {
                  icObj.compositeConfig = compositeConfig;
                  return icObj;
                });
            }
            break;

          case "mathNode":
            const mathNode = math.parse(json_icObject.mathNodeString);
            icObj.mathNode = mathNode;
            break;

          case "button":
          {
            const buttonConfig_serial = json_icObject.buttonConfig_serial;
            const buttonConfig        = deserialize(buttonConfig_serial);

            icObj_p = icObj_p
              .then(icObj => {

                icObj.buttonConfig = buttonConfig;

                return icObj;
              })

          }
          break;


          // case "engined":
          //
          //   break;

          default:
            break;
        }


        return icObj_p;
      }

      getTrueRect() {
        return {
          x:      this.position.x, 
          y:      this.position.y, 
          width:  this.size.width, 
          height: this.size.height,
        };
      }

      getTrueRect2() {
        return {
          x:      this.position.x, 
          y:      this.position.y, 
          width:  this.size.width  / this.homeScale.X, 
          height: this.size.height / this.homeScale.Y,
        };
      }

      // getAbsoluteTrueRect2() {
      //   var outRect;

      //   const trueRect2 = this.getTrueRect2();
      //   logger.log("logComposite", "getAbsoluteTrueRect2:", "trueRect2:", trueRect2);

      //   if(this.isCompositeContentOrPart()) {

      //     const rep_free__parent = infiniteCanvas.getRepresented(this.compositeId).r_free();
      //     logger.log("logComposite", "getAbsoluteTrueRect2:", "rep_free__parent:", rep_free__parent);

      //     const trueRect__parent = rep_free__parent.getAbsoluteTrueRect2();
      //     logger.log("logComposite", "getAbsoluteTrueRect2:", "trueRect__parent:", trueRect__parent);

      //     outRect = {
      //       x:      trueRect__parent.x + trueRect2.x, 
      //       y:      trueRect__parent.y + trueRect2.y,
      //       width:  trueRect2.width, 
      //       height: trueRect2.height,
      //     };

      //   } else {
      //     outRect = trueRect2;
      //   }
      //   logger.log("logComposite", "getAbsoluteTrueRect2:", "outRect:", outRect);

      //   return outRect;
      // }

      getTrueWidth__total() {
        var outWidth;

        if(this.type == "composite") {
          // const icObj__part__sample = Object.values(this.parts).find(e => true).position.x;

          const miniDict = Object.entries(this.parts).reduce((acc, [partName, icObj__part]) => {
            const trueRect__part = icObj__part.getTrueRect();
            acc.x__max = math.max(acc.x__max, trueRect__part.x + icObj__part.getTrueWidth__total() );
            acc.x__min = math.min(acc.x__min, trueRect__part.x);
            return acc;
          }, {
            x__max: -math.Infinity,
            x__min: +math.Infinity,
          });
          outWidth = miniDict.x__max - miniDict.x__min;
        } else {
          outWidth = this.size.width / this.homeScale.X / this.scale.X;
        }

        return outWidth;
      }

      setCenter(pointCenter) {
        if (this.isUsingCenterPosition) {
          this.position = Object.assign({}, pointCenter);
        } else {
          this.position = {
            x: pointCenter.x - this.size.width / 2,
            y: pointCenter.x - this.size.height / 2,
          };
        }
      }

      toSerial_p() {
        var out_p;

        const icObj = this;

        const icObj_serial = Object.assign({}, icObj);

        if(icObj.dict_engine != null) {
          //don't serialize engine directly
          delete icObj_serial.dict_engine;

          icObj_serial.getScopeObj = serialize(icObj.getScopeObj);  //SHU: maybe this function is a bit useless

          const dict_virgin = Object.entries(icObj.dict_engine).reduce((acc, [eType, engineMiniDict]) => {

              const index_start = engineMiniDict.index_start;
              const engine      = engineMiniDict.engine;

              //serialize the virgin version of engine (== a version which is context-free and not bound)
              const virgin = engine.virgin;

              const engine_cloned = Object.assign({}, virgin);
              console.log("engine_cloned", engine_cloned);

              const engine_serial = serialize(engine_cloned);
              const engineMiniDict_serial= {
                index_start: index_start,
                engine:      engine_serial,
              };
              acc[eType] = engineMiniDict_serial;

            return acc;
          }, {});
          icObj_serial.dict_engine = dict_virgin;
        }

        var icObj_serial_p = Promise.resolve(icObj_serial);

        switch (icObj.type) {
          // case "text":
          //   const text     = icObj.text;
          //   const fontSize = icObj.fontSize;
          //
          //   icObj_serial.text     = text;
          //   icObj_serial.fontSize = fontSize;
          //
          //   break;
          case "image":
            {
              const img = icObj.img;
              const img_serial_p = FileIntegration.dataUrlForImgViaCanvas_p(img);

              const arr_p = [icObj_serial_p, img_serial_p];

              icObj_serial_p = Promise.all(arr_p)
                .then(([icObj_serial, img_serial]) => {

                  icObj_serial.img = img_serial;
                  return icObj_serial;
                });
            }
            break;

          // case "circle":
          //   const radius     = icObj.radius;
          //   icObj_serial.radius = radius;
          //
          //   break;

          // case "group":
          //   const children = icObj.children;
          //   icObj_serial.children = children;
          //
          //   break;

          case "freeDrawing":
            {
              const exoObject = icObj.exoObject;
              logger.log("exoObject", exoObject);

              const exoObject__clone = Object.assign({}, exoObject);
              logger.log("exoObject__clone", exoObject__clone);
              //remove cyclical refs
              exoObject__clone.canvas           = null;
              exoObject__clone._cacheCanvas     = null;
              exoObject__clone._cacheContext    = null;
              exoObject__clone._cacheProperties = null;

              exoObject__clone.__brush          = null;   //SHU TODO: store __id__brush

              const exoObject_serial = exoObject__clone;
              // const exoObject_serial = JSON.stringify(exoObject__clone);

              icObj_serial.exoObject = exoObject_serial;
            }
            break;

          case "floodFill":
            {
              const exoObject = icObj.exoObject;
              logger.log("exoObject", exoObject);

              const exoObject__clone = Object.assign({}, exoObject);
              logger.log("exoObject__clone", exoObject__clone);
              //remove cyclical refs
              exoObject__clone.canvas           = null;
              exoObject__clone._cacheCanvas     = null;
              exoObject__clone._cacheContext    = null;
              exoObject__clone._cacheProperties = null;

              // exoObject__clone.__brush          = null;   //SHU TODO: store __id__brush

              const exoObject_serial = exoObject__clone;
              // const exoObject_serial = JSON.stringify(exoObject__clone);

              icObj_serial.exoObject = exoObject_serial;
            }
            break;

          case "sparkle":
            {
              const img = icObj.img;
              const img_serial_p = FileIntegration.dataUrlForImgViaCanvas_p(img);

              const arr_p = [icObj_serial_p, img_serial_p];

              icObj_serial_p = Promise.all(arr_p)
                .then(([icObj_serial, img_serial]) => {

                  icObj_serial.img = img_serial;
                  return icObj_serial;
                });
            }
            break;

          case "touchSlot":
            {
              const touchSlotConfig = icObj.touchSlotConfig;
              const touchSlotConfig_serial = serialize(touchSlotConfig);

              icObj_serial_p = icObj_serial_p
                .then((icObj_serial) => {

                  icObj_serial.touchSlotConfig_serial = touchSlotConfig_serial;
                  return icObj_serial;
                });
            }
            break;

          case "snapSlot":
            {
              const snapSlotConfig = icObj.snapSlotConfig;
              const snapSlotConfig_serial = serialize(snapSlotConfig);

              icObj_serial_p = icObj_serial_p
                .then((icObj_serial) => {

                  icObj_serial.snapSlotConfig_serial = snapSlotConfig_serial;
                  return icObj_serial;
                });
            }
            break;



          case "composite":
            {
              const parts = icObj.parts;
              const arr_part_serial_miniDict_p = Object.entries(icObj.parts).reduce((acc, [partName, part]) => {
                const part_serial_miniDict_p = part.toSerial_p()
                  .then(part_serial => {

                    const part_serial_miniDict = {
                      [partName]: part_serial,
                    };

                    return part_serial_miniDict;
                  });

                acc.push(part_serial_miniDict_p);
                return acc;
              }, []);

              if(icObj.content != null) {
                const content = icObj.content;
                const content_serial_p = content.toSerial_p();

                icObj_serial_p = Promise.all([icObj_serial_p, content_serial_p])
                  .then(([icObj_serial, content_serial]) => {
                    icObj_serial.content = content_serial;
                    return icObj_serial;
                  });
              }

              icObj_serial_p = Promise.all([icObj_serial_p, ...arr_part_serial_miniDict_p])
                .then(([icObj_serial, ...arr_part_serial_miniDict]) => {    //SHU: wow, pas mal le spread operator
                  // icObj_serial.parts = arr_part_serial_miniDict.reduce((acc, x) => {
                  //   Object.assign(acc, x);
                  //   return acc;
                  // }, {});
                  icObj_serial.parts = {};
                  Object.assign(icObj_serial.parts, ...arr_part_serial_miniDict);
                  return icObj_serial;
                });

              const compositeConfig = icObj.compositeConfig;
              const compositeConfig_serial = serialize(compositeConfig);

              icObj_serial_p = icObj_serial_p
                .then((icObj_serial) => {

                  icObj_serial.compositeConfig_serial = compositeConfig_serial;
                  return icObj_serial;
                });
            }
            break;

          case "mathNode":
            {
              const mathNode = icObj.mathNode;
              const mathNodeString = mathNode.toString();
              const mathNode_serial_p = Promise.resolve(mathNodeString);

              const arr_p = [icObj_serial_p, mathNode_serial_p];

              icObj_serial_p = Promise.all(arr_p)
                .then(([icObj_serial, mathNode_serial]) => {

                  icObj_serial.mathNodeString = mathNode_serial;
                  return icObj_serial;
                });
            }
            break;

          case "button":
          {
            const buttonConfig        = icObj.buttonConfig;
            const buttonConfig_serial = serialize(buttonConfig);

            icObj_serial_p = icObj_serial_p
              .then((icObj_serial) => {

                icObj_serial.buttonConfig_serial = buttonConfig_serial;
                return icObj_serial;
              });
          }
          break;

          default:
            break;
        }

        out_p = icObj_serial_p;

        return out_p;
      }


      addInteraction_hold() {
        console.log("IcObject::addInteraction_hold", "this.id", this.id, this.id_rep);
        const icObj = this;

        icObj.holdListeners = [];
        function nowHeld() {
          this.isHeld = true;
          this.holdListeners.forEach((listener, i) => {
            listener(this);
          });
        }
        icObj.registerFunc("nowHeld", nowHeld);
        function onHold(listener) {
          this.holdListeners.push(listener);
        }
        icObj.registerFunc("onHold", onHold);

        function offHold (listener) {
          this.holdListeners = Utils.arrayByRemovingElement(this.holdListeners, listener);
        }
        icObj.registerFunc("offHold", offHold);


        icObj.releaseListeners = [];
        function nowReleased() {
          logger.log("nowReleased");
          this.isHeld = false;
          this.releaseListeners.forEach((listener, i) => {
            listener(this);
          });
        }
        icObj.registerFunc("nowReleased", nowReleased);
        
        function onRelease(listener) {
          this.releaseListeners.push(listener);
        }
        icObj.registerFunc("onRelease", onRelease);

        function offRelease(listener) {
          this.releaseListeners = Utils.arrayByRemovingElement(this.releaseListeners, listener);
        }
        icObj.registerFunc("offRelease", offRelease);

      }

      addInteraction_edit() {
        const icObj = this;

        icObj.editEnterListeners = [];
        function nowEditEnter() {
          this.isEditing = true;
          globalsSingleton.isEditing = true;
          this.editEnterListeners.forEach((listener, i) => {
            listener(this);
          });
        }
        icObj.registerFunc("nowEditEnter", nowEditEnter);

        function onEditEnter(listener) {
          this.editEnterListeners.push(listener);
        }
        icObj.registerFunc("onEditEnter", onEditEnter);

        function offEditEnter(listener) {
          this.editEnterListeners = Utils.arrayByRemovingElement(this.editEnterListeners, listener);
        }
        icObj.registerFunc("offEditEnter", offEditEnter);


        icObj.editExitListeners = [];
        function nowEditExit() {
          this.isEditing = false;
          globalsSingleton.isEditing = false;
          this.editExitListeners.forEach((listener, i) => {
            listener(this);
          });
        }
        icObj.registerFunc("nowEditExit", nowEditExit);

        function onEditExit(listener) {
          this.editExitListeners.push(listener);
        }
        icObj.registerFunc("onEditExit", onEditExit);

        function offEditExit(listener) {
          this.editExitListeners = Utils.arrayByRemovingElement(this.editExitListeners, listener);
        }
        icObj.registerFunc("offEditExit", offEditExit);

      }

      addInteraction_click() {
        console.log("IcObject::addInteraction_click", "this.id", this.id, this.id_rep);
        const icObj = this;

        icObj.clickListeners = [];
        function nowClicked() {
          this.clickListeners.forEach((listener, i) => {
            listener(this);
          });
        }
        icObj.registerFunc("nowClicked", nowClicked);

        function onClick(listener) {
          this.clickListeners.push(listener);
        }
        icObj.registerFunc("onClick", onClick);

        function offClick(listener) {
          this.clickListeners = Utils.arrayByRemovingElement(this.clickListeners, listener);
        }
        icObj.registerFunc("offClick", offClick);

      }

      removeInteraction_click() {
        console.log("IcObject::removeInteraction_click", "this.id", this.id, this.id_rep);
        const icObj = this;

        delete icObj.nowClicked;
        delete icObj.onClick;
        delete icObj.offClick;
        delete icObj.clickListeners;
      }


      lock() {
        this.canBeMoved    = false;
        this.canBeSelected = false;
        this.canBeResized  = false;
        this.canBeRotated  = false;
        this.canBeHeld     = false;

        this.isLocked      = true;
      }

      unlock() {
        this.canBeMoved    = true;
        this.canBeSelected = true;
        this.canBeResized  = true;
        this.canBeRotated  = true;
        this.canBeHeld     = true;

        this.isLocked      = false;
      }




      getScreenPositionWithoutOffset() {
        const screenX = this.position.x * this.homeScale.X;
        const screenY = this.position.y * this.homeScale.Y;
        return Geometry.createPoint(screenX, screenY);
      }

      getScreenPointBRWithoutOffset() {       //SHU TODO: take orientation into account
        const screenX = (this.position.x + this.size.width) * this.homeScale.X;
        const screenY = (this.position.y + this.size.height) * this.homeScale.Y;
        return Geometry.createPoint(screenX, screenY);
      }

      getScreenRect(/*isPixelRatioFixEnabled = true*/) {
        const screenPointTL = this.getScreenPositionWithoutOffset();
        const screenPointBR = this.getScreenPointBRWithoutOffset();

        const left   = screenPointTL.x;
        const top    = screenPointTL.y;
        const width  = screenPointBR.x - screenPointTL.x;
        const height = screenPointBR.y - screenPointTL.y;
        const rect__screen__raw = Geometry.createRect(left, top, width, height);

        return rect__screen__raw;

        // var factor;
        // if(isPixelRatioFixEnabled) {
        //   factor = window.devicePixelRatio;
        // } else {
        //   factor = 1.0;
        // }
  
        // const rect__screen__fixed = {
        //   left:   rect__screen__raw.left   * factor,
        //   top:    rect__screen__raw.top    * factor,
        //   width:  rect__screen__raw.width  * factor,
        //   height: rect__screen__raw.height * factor,
        // };

        // return rect__screen__fixed;
      }




      getHomeScreenSize() {
        return this.size;
      }

      

      // getTrueSize() {
      //   // const homeScreenSize = this.getHomeScreenSize();
      //   const trueSize = {
      //     width:    this.size.width / this.homeScale.X * this.scale.X,
      //     height:   this.size.width / this.homeScale.Y * this.scale.Y,
      //   }
      //   return trueSize;
      // }

      getRect() {
        const rect = Geometry.createRect(this.position.x, this.position.y, this.size.width, this.size.height);
        return rect;
      }

      getRect2() {
        const trueSize = this.getTrueSize();
        const rect2 = Geometry.createRect(this.position.x, this.position.y, trueSize.width, trueSize.height);
        return rect2;
      }



      update(icObj_new, requestCanvasRedraw) {
        logger.log("icObj.update", "icObj_new", icObj_new);

        const icObj = this;

        if (icObj_new.type != icObj.type) {
          // console.log("invalid type for icObj_new", "icObj", icObj, "icObj_new", icObj_new);
          throw new Error("invalid type for icObj_new" + "icObj" + icObj + "icObj_new" + icObj_new);
        }

        this.position = Object.assign({}, icObj_new.position);
        this.size = Object.assign({}, icObj_new.size);

        this.homeScale = Object.assign({}, icObj_new.homeScale);

        this.scale = Object.assign({}, icObj_new.scale);
        this.orientation = icObj_new.orientation;
        this.flip = Object.assign({}, icObj_new.flip);

        // this.fill        = icObj_new.fill;
        // this.stroke      = icObj_new.stroke;


        // this.perceptionScale = Object.assign({}, icObj_new.perceptionScale);

        if (this.type == "text") {
          this.text = icObj_new.text;
          this.fontSize = icObj_new.fontSize;
        }

        if (this.type == "toggleRect") {
          this.isActive = icObj_new.isActive;
        }

        this.didUpdate(requestCanvasRedraw);
      }


      didUpdate(requestCanvasRedraw) {
        const icObj = this;
        this.didUpdateListeners.forEach((listener, i) => {      //SHU: todo: "everything is promised"
          listener(icObj, requestCanvasRedraw);
        });
      }

      delete_p() {
        return new Promise((resolve, reject) => {

          this.toBeDeleted = true;

          this.didUpdate(false);

          resolve(this);
        });
      }

      clone() {
        const id   = this.id;
        const type = this.type;

        const position = this.position;
        const size = this.size;

        const homeScale = this.homeScale;

        const icObj_clone = new IcObject(id, type, position, size, homeScale);

        Object.assign(icObj_clone, this);
        console.log("icObj_clone", icObj_clone);

        return icObj_clone;
      }

      deepClone() { 
        logger.log("logCP", "deepClone", "this:", this);

        const icObj = this;

        // const id   = this.id;
        const id   = infiniteCanvas.getId__fresh();

        const type = this.type;

        const position = {
          x: this.position.x,
          y: this.position.y,
        };
        const size = {
          width:  this.size.width,
          height: this.size.height,
        };

        const homeScale = {
          X: this.homeScale.X,
          Y: this.homeScale.Y,
        };

        const icObj__deepClone = new IcObject(id, type, position, size, homeScale);
        // logger.log("logCP", "deepClone", "icObj__deepClone:", icObj__deepClone);
        
        const arr_method = Utils.getMethods(icObj__deepClone);
        // logger.log("logCP", "deepClone", "arr_method:", arr_method);

        const arr_alreadySet = [
          ...arr_method,
          "id",
          "type",
          "position",
          "size",
          "homeScale",
        ];

        const arr_ignored = [
          // "snappedTo",
          "icObj__activeSelection",
        ];

        // logger.log("logCP", "deepClone", "Object.keys(this):", Object.keys(this));

        Object.entries(this)
          .filter(([key, value]) => {
            const isPropertyAlreadyCopied = (arr_alreadySet.includes(key));
            return !isPropertyAlreadyCopied;
          })
          .filter(([key, value]) => {
            const isPropertyIgnored = (arr_ignored.includes(key));
            return !isPropertyIgnored;
          })
          .forEach(([key, value], i) => {
            // logger.log("logCP", "deepClone", "(k,v):", key, value);

            switch (key) {
              case "scale":
                {
                  const scale = value;
                  const scale__deepClone = Object.assign({}, scale);
                  icObj__deepClone[key] = scale__deepClone;
                }
                break;
              case "img":
                {
                  const img = value;
                  const img__deepClone = img.cloneNode(true);
                  icObj__deepClone[key] = img__deepClone;
                }
                break;
              case "mathNode":
                {
                  const mathNode = value;
                  const mathNode__deepClone = mathNode.cloneDeep();
                  if (mathNode.autoSimplify != null) {
                    mathNode__deepClone.autoSimplify = mathNode.autoSimplify;
                  }
                  icObj__deepClone[key] = mathNode__deepClone;
                }
                break;
              case "exoObject":
                {
                  const exoObject = value;

                  if(exoObject.path != null ) {
                    //clone only essential props of freeDrawing exoObject
                    icObj__deepClone[key] = {
                      path:             this.deepClone__propertyObject(exoObject, "path", exoObject.path),
                      
                      stroke:           exoObject.stroke,
                      strokeDashArray:  exoObject.strokeDashArray,
                      strokeLineCap:    exoObject.strokeLineCap,
                      strokeLineJoin:   exoObject.strokeLineJoin,
                      strokeMiterLimit: exoObject.strokeMiterLimit,
                      strokeWidth:      exoObject.strokeWidth,

                      fill:             exoObject.fill,
                      //debug
                      // fill:             "black",
                    };
                  }

                }
                break;
              case "dict_engine":
                {
                  icObj__deepClone[key] = [...Object.entries(icObj[key])].reduce((acc, [eType, engineMiniDict]) => {
                    //logger.log("logCP", "deepClone", "dict_engine[" + eType + "]", engineMiniDict);

                    acc[eType] = {
                      index_start:  engineMiniDict.index_start,
                      engine: this.deepClone__engine(engineMiniDict.engine),
                    };
                    return acc;
                  }, {});
                }
                break;
              case "content":
                {
                  const content = icObj[key];
                  icObj__deepClone[key] = content.deepClone();
                }
                break;
              case "parts":
                {
                  logger.log("logCP", "deepClone", "parts:");

                  icObj__deepClone[key] = [...Object.entries(icObj[key])].reduce((acc, [partName, icObj__part]) => {
                    acc[partName] = icObj__part.deepClone();
                    return acc;
                  }, {});
                }
                break;
              default:
                {
                  // logger.log("logCP", "deepClone", "default:", key);
                  const prop__cloned    = this.deepClone__propertyObject(icObj, key, icObj[key]);
                  icObj__deepClone[key] = prop__cloned;
                  //check if we can bind
                  if(icObj__deepClone[key] instanceof Function) {
                    const propName__virgin = key + "__" + "virgin";
                    if(propName__virgin in icObj) {
                      icObj__deepClone[key] = icObj__deepClone[key].bind(icObj__deepClone);
                    }
                  }
                  // logger.log("logCP", "deepClone", "default:", "icObj__deepClone[key]:", icObj__deepClone[key]);
                }
                break;
            }

          });

        return icObj__deepClone;
      }

      deepClone__engine(engine) {
        // logger.log("logCP", "deepClone__engine", engine);

        const virgin_src = engine.virgin;
        const virgin     = Object.assign({}, virgin_src);
        // const virgin = this.deepClone__propertyObject(virgin_src); //not working

        const engine_cloned      = {};
        engine_cloned.initialize = virgin.initialize.bind(engine_cloned);
        engine_cloned.virgin     = virgin;

        return engine_cloned;
      }

      deepClone__func(func) {
        // logger.log("logCP", "deepClone__func", func);
        // return deserialize(serialize(func)); 
        return func;  //SHU: for operator cloning
      }

      deepClone__propertyObject(motherObject, propName, prop) {
        // logger.log("logCP", "deepClone__propertyObject", motherObject, propName, prop);

        if(prop instanceof Function) {
          const propName__virgin = propName + "__" + "virgin";
          if(propName__virgin in motherObject) {
            const func__virgin = motherObject[propName__virgin];
            return this.deepClone__func(func__virgin);
          } else {
            return this.deepClone__func(prop);
          }
        } else if(prop instanceof Array) {
          return prop.map((elt, index) => {
            return this.deepClone__propertyObject(prop, index, elt);
          });
        } else if(prop instanceof Object) {
          return [...Object.entries(prop)].reduce((acc, [k,v]) => {
            acc[k] = this.deepClone__propertyObject(prop, k, v);
            //check if we can bind
            if(acc[k] instanceof Function) {
              const propName__virgin = k + "__" + "virgin";
              if(propName__virgin in prop) {
                acc[k] = acc[k].bind(acc);
              }
            }
            return acc;
          }, {});
        } else {
          return prop;
        }
      }


      registerFunc(key, func) {
        //store virgin
        const key__virgin = key + "__" + "virgin";
        this[key__virgin] = func;
        
        //set func and bind
        this[key] = func.bind(this);
      }






      isCompositeContentOrPart() {
        return this.compositeId != -1;
      }

      getRootObject(infiniteCanvas) {
        // logger.log("getRootObject", "this.compositeId:", this.compositeId);
        if(this.isCompositeContentOrPart()) {
          const icObj__parentComposite = infiniteCanvas.getRepresented(this.compositeId).r_free();
          return icObj__parentComposite.getRootObject(infiniteCanvas);
        } else { 
          return this;
        }
      }

      isRootObject(infiniteCanvas) {
        return (this.getRootObject(infiniteCanvas) == this);
      }



    }


  </script>


  <script>
    class Ic_HUD {
      constructor(eltsDict) {
        this.eltsDict = eltsDict;
      }

      setIsRecording(isRecording) {
        this.eltsDict["red_dot"].style.visibility = isRecording ? "visible" : "hidden";
      }

      setActiveColor(rgbaString) {
        if (this.idTimeout__activeColor != null) {
          clearTimeout(this.idTimeout__activeColor);
        }
        this.eltsDict["color_triangle"].style.visibility = "visible";

        this.eltsDict["color_triangle"].style.borderTopColor = rgbaString;

        this.idTimeout__activeColor = setTimeout(() => {
          this.eltsDict["color_triangle"].style.visibility = "hidden";
          this.idTimeout__activeColor = null;
        }, 444);

      }

    }
  </script>

  <div id="ic_HUD_container" style="position:absolute; left:0; top: 0; font-size: 60px; pointer-events: none;">
    <div>
      <!-- color triangle -->
      <style>
        #triangle-topleft {
          width: 0;
          height: 0;
          border-top: 100px solid red;
          border-right: 100px solid transparent;
        }
      </style>
      <div id="triangle-topleft"></div>

      <!-- red dot when recording  -->
      <div
        style="display: block; position:absolute; left: 60px; top: 60px; background-color: red; width: 70px; height: 70px; opacity: 0.7; border-radius: 35px;"
        id="ic_HUD_red_dot"></div>
    </div>

    <script>
      const icHUD_eltsDict = {
        color_triangle: document.getElementById("triangle-topleft"),
        red_dot: document.getElementById("ic_HUD_red_dot"),
      };
      const ic_HUD = new Ic_HUD(icHUD_eltsDict);
      //debug
      // ic_HUD.setActiveColor("rgba(200,100,50,0.6)");

    </script>



    <script>
      /*
      class IcComposite {
  
        constructor(handle, otherPartsDict) {
          this.parts  = Object.assign(otherPartsDict, {
            "handle": handle,
          };
        }
  
        getHandle() {
          return this.parts["handle"];
        }
  
        getPart(icObjId) {
          const part = Object.values(this.parts).find(part => (part.icObject.id == icObjId));
          return part;
        }
  
        getIcObject(icObjId) {
          const part = this.getPart(icObjId);
          return part ? part.icObject : null;
        }
  
        managePartUpdate(part, updateDict) {
  
          const icObj_compositePart = part.icObject;
  
          const arr_compositePartIcObj = Object.values(this.parts).map(compositePart => compositePart.icObject);
          const arr_compositePartIcObj__other = arr_compositePartIcObj.filter(icObj => icObj.id != icObj_compositePart.id);
  
          arr_compositePartIcObj__other.forEach((icObj, i) => {
  
            //test
            // icObj.position = Object.assign({}, icObj_compositePart.position);
  
            //get free rep
            // const represented = infiniteCanvas.getRepresented(icObj.id);
            // const rep_free    = represented.r_free();
  
            const rep_free = icObj;
  
            if(outerUpdatesDict.position != null) {
  
              const position_offset = {
                dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
              };
              // console.log("position_offset", position_offset);
  
              const obj = {
                position: {
                  x: rep_free.position.x + position_offset.dx,
                  y: rep_free.position.y + position_offset.dy,
                },
              };
  
              rep_free.syncWith(obj);
  
              //debug
              // rep_free.position = {
              //   x: icObj_compositePart.position.x + 100,
              //   y: icObj_compositePart.position.y + 100,
              // };
  
            }
  
          });
  
        }
  
        outerUpdatePart(part, updateDict) {
  
        }
  
      }
  
      class IcCompositePart {
  
        constructor(icObject, isMobile = false) {
          this.icObject = icObject;
  
          this.isMobile = isMobile;
        }
  
      }
      */







      /* POVs */

      // class POV {
      //
      //   constructor(scale, offset) {
      //     this.scale = scale;
      //     this.offset = offset;
      //   }
      //
      //   static createPOVWithValues(scale_X, scale_Y, offset_dx, offset_dy) {
      //     const scale = {
      //       X: scale_X,
      //       Y: scale_Y,
      //     };
      //     const offset = {
      //       dx: offset_dx,
      //       dy: offset_dy,
      //     };
      //     return new POV(scale, offset);
      //   }
      //
      //   static debugInstance() {
      //     const scale = {
      //       X: 2.0,
      //       Y: 1.5,
      //     };
      //     const offset = {
      //       dx: +100,
      //       dy: +100,
      //     };
      //     return new POV(scale, offset);
      //   }
      //
      //
      // }

      class POV {   

        constructor(scale, center, size) {    //SHU: horror is my co-pilot
          this.scale  = scale;
          this.center = center;

          this.size   = size;
        }

        getTrueRect2() {
          const trueRect2 = {
            x:      this.center.x - (this.size.width  / 2.0),
            y:      this.center.y - (this.size.height / 2.0),
            width:  this.size.width,
            height: this.size.height,
          };
          return trueRect2;
        }

        getScreenRect() {
          const trueRect2 = this.getTrueRect2();
          const size__screen = {
            width: trueRect2.width   * this.scale.X,
            height: trueRect2.height * this.scale.Y,
          };
          const screenRect = Object.assign({}, {
            x: trueRect2.x,
            y: trueRect2.y,
          }, size__screen);
          return screenRect;
        }

        static createPOVWithValues(scale_X, scale_Y, center_x, center_y, size_width, size_height) {
          const scale = {
            X: scale_X,
            Y: scale_Y,
          };
          const center = {
            x: center_x,
            y: center_y,
          };
          const size = {
            width:  size_width,
            height: size_height,
          };
          return new POV(scale, center, size);
        }

        static debugInstance() {
          const scale = {
            X: 2.0,
            Y: 1.5,
          };
          const center = {
            x: +100,
            y: +100,
          };
          const size = {
            width:  100,
            height: 100, 
          };
          return new POV(scale, center, size);
        }


      }


      // class POVRect {
      //   constructor(trueRect, scale, orientation = 0) {
      //     this.trueRect = trueRect;
      //     this.scale = scale;
      //     this.orientation = orientation;
      //   }
      // }







      /*****
        REPRESENTATIONS / BACKING OBJECT
      *//////

      var ID = () => {
        let arr = new Uint32Array(8);
        window.crypto.getRandomValues(arr);
        let str = '';
        for (let i = 0; i < arr.length; i++) {
          str += (i < 2 || i > 5 ? '' : '-') + arr[i].toString(16).slice(-4);
        }
        return str;
      };

      class BackingSchema {

        constructor(propsDict) {
          const arr_entries = Object.entries(propsDict).map(([propName, prop]) => {
            var propType;
            if (prop != null) {
              propType = prop.constructor;
            } else {
              propType = Object;
            }
            return [propName, propType];
          });
          const propConstructorsDict = Object.fromEntries(arr_entries);

          Object.assign(this, propConstructorsDict);
        }

        static fromObject(obj) {
          return new BackingSchema(obj);
        }
      }

      class BackingObject {

        constructor(repClass, backingSchema, obj = null) {
          this.id = ID();

          /**/
          //pour la forme
          this.repClass = repClass;
          this.backingSchema = backingSchema;
          /**/

          // this.counter = 0;
          this.representations = {};

          // this.inner = new repClass();                                                     //}
          //this.inner = {};                                                                  //} SHU: ça se discute
          this.innerRep = createRepresentation(obj, "id_inner_rep" + "__" + this.id, []);     //}
          this.addRepresentation(this.innerRep);
        }

        static fromBackingSchemaAndObject(backingSchema, obj) {
          const repClass = obj.constructor;

          const backingObject = new BackingObject(repClass, backingSchema, obj);
          return backingObject;
        }

        static fromObject(obj) {
          const repClass = obj.constructor;
          const backingSchema = BackingSchema.fromObject(obj);

          const backingObject = new BackingObject(repClass, backingSchema, obj);
          return backingObject;
        }

        generateNewRepId() {
          // const id = this.counter;
          // this.counter += 1;
          // return id;

          const id_rep = ID();
          return id_rep;
        }

        getNewRepresentation(repType = "std") {
          var outRep;

          const backingObj = this;

          const id_rep = backingObj.generateNewRepId();

          const target = backingObj.innerRep;
          console.log("target", target);

          const arr_backingObj = [backingObj];

          switch (repType) {
            case "std":
              outRep = createRepresentation(target, id_rep, arr_backingObj);
              break;
            // case "ghost":
            //   outRep = createRepresentation__ghost(target, id_rep, arr_backingObj);
            //   break;
            default:
              throw new Error("Unsupported repType: " + repType);
              break;
          }

          backingObj.addRepresentation(outRep);

          return outRep;
        }

        // updateWithRepresentation(rep__update) {
        //
        //   const arr_affected = Object.values(this.representations).filter(rep => rep.id != rep__update.id);
        //
        //   arr_affected.forEach((rep, i) => {
        //     rep.syncWith(rep__update);
        //   });
        //
        // }

        updateWithPropFromRepresentation(propName, setValue, rep__update) {
          // console.log("updateWithPropFromRepresentation", propName, setValue, rep__update);
          // console.log("rep__update.id_rep", rep__update.id_rep);

          const arr_affected = Object.values(this.representations).filter(rep => rep.id_rep != rep__update.id_rep);
          // console.log("arr_affected", arr_affected.map(rep => rep.id_rep));

          arr_affected.forEach((rep, i) => {
            rep.updateFromOuter(propName, setValue, rep__update);
          });

        }

        addRepresentation(representation) {
          this.representations[representation.id_rep] = representation;
          // this.innerRep.follow(representation);  //SHU: innerRep now useless ?
        }

        removeRepresentation(rep) {
          //rep should no longer get any update from any other rep
          rep.unfollowAll();

          //all following reps must unfollow
          const arr_followers = Object.values(rep.followers);
          arr_followers.forEach((rep_follower) => {
            rep_follower.unfollow(rep);
          });

          //remove reference in dict
          delete this.representations[rep.id_rep];
        }

      }

      //original representation
      // function createRepresentation(target, id_rep, arr_backingObj) {
      //     // console.log("createRepresentation", "target", target);
      //     // console.log("createRepresentation", JSON.stringify(target));
      //
      //     // const targetClass = target.constructor;
      //
      //     const broadcaster = {}; //--> push to backingObject(s)
      //     broadcaster.id_rep = id_rep;
      //     broadcaster.arr_backingObj = arr_backingObj;
      //     broadcaster.addBackingObject = function(backingObj) {
      //       broadcaster.arr_backingObj.push(backingObj);
      //       backingObj.addRepresentation(broadcaster.representation);
      //     };
      //
      //     broadcaster.createSisterRepresentation = function(backingObj = null) {
      //       var targetBackingObj = backingObj;
      //       if(targetBackingObj == null) {
      //         const backingObj_first = broadcaster.arr_backingObj.find(e => true);
      //         targetBackingObj = backingObj_first;
      //       }
      //       return targetBackingObj.getNewRepresentation();
      //     };
      //
      //     const receiver  = {}; //<-- receive updates from backingObject(s)
      //     receiver.id_rep = id_rep;
      //
      //
      //     const inner = target.clone();
      //     // console.log("inner", inner);
      //
      //     const representation = new Proxy({}, {
      //         get: function (obj, propName) {
      //           // console.log("representation.get", propName);
      //           var outProp;
      //
      //           if(propName in broadcaster) {
      //             outProp = broadcaster[propName];//.bind(broadcaster);
      //           } else if(propName in receiver) {
      //             outProp = receiver[propName];//.bind(receiver);
      //           }
      //
      //           else if(propName in inner) {
      //             outProp = inner[propName];//.bind(inner);
      //           }
      //
      //           // else {
      //           //   console.log("representation", obj);
      //           //   throw new Error("unknown propName" + "(" + propName + ")" + " for representation: " + obj);
      //           // }
      //
      //           return outProp;
      //         },
      //         set: function (obj, propName, setValue) {
      //           // console.log("representation.set", propName, setValue);
      //
      //           updateInternals(propName,setValue);
      //           broadcaster.arr_backingObj.forEach((backingObj, i) => {
      //             console.log("representation", broadcaster.representation, "has updated");
      //             // console.log("broadcasting to", backingObj);
      //             backingObj.updateWithPropFromRepresentation(propName, setValue, broadcaster.representation);
      //           });
      //
      //           return true;
      //         },
      //     });
      //
      //     function updateInternals(propName, value) {
      //       // console.log("updateInternals", propName, value);
      //
      //       inner[propName] = value;
      //     }
      //
      //
      //
      //
      //
      //
      //     receiver.updateFromOuter = (propName,value) => {
      //       // console.log("updateFromOuter", propName, value);
      //
      //       updateInternals(propName,value);
      //
      //       // receiver.didUpdateProp(prop,value);
      //
      //       //timeout to avoid calling didUpdate for every updated prop
      //       if(receiver.didUpdateTimeout == null) {
      //         const timeout_delayInMs = 17;
      //         receiver.didUpdateTimeout = setTimeout(() => {
      //           // console.log("didUpdateTimeout", "triggering");
      //           receiver.didUpdate();
      //           receiver.didUpdateTimeout = null;
      //         }, timeout_delayInMs);
      //       }
      //     };
      //
      //     // receiver.didUpdatePropListeners = [];
      //     // receiver.didUpdateProp = (prop,value) => {
      //     //   receiver.didUpdatePropListeners.forEach((listener, i) => {
      //     //     listener(prop,value);
      //     //   });
      //     // }
      //
      //     receiver.didUpdateTimeout   = null;
      //     receiver.didUpdateListeners = [];
      //     receiver.didUpdate = () => {
      //       // console.log("receiver", "didUpdate");
      //       receiver.didUpdateListeners.forEach((listener, i) => {
      //         listener(receiver.representation);
      //       });
      //     };
      //
      //     receiver.addOnOuterUpdate = (listener) => {
      //       receiver.didUpdateListeners.push(listener);
      //     };
      //
      //
      //
      //
      //     const glassFacade = new Proxy(inner, {
      //       get: function (obj, propName) {
      //         // console.log("glassFacade.get", propName);
      //         var outProp;
      //
      //         if (propName === 'toJSON') {
      // 		      return function() { return obj; }
      //         }
      //
      //         if(propName in inner)	{	//Be careful! The in operator matches all object keys, including those in the object's prototype chain.
      //           outProp = inner[propName];
      //         } else {
      //           outProp = representation[propName];
      //         }
      //
      //         return outProp;
      //       },
      //       set: function (obj, propName, setValue) {
      //           //console.log("glassFacade.set", propName /*,setValue*/ );
      //           representation[propName] = setValue;
      //           return true;
      //       },
      //     });
      //
      //     broadcaster.representation = glassFacade;
      //     receiver.representation    = glassFacade;
      //
      //
      //     return glassFacade;
      //   }
      //

      class RepresentationFactory {
        static initial(obj) {
          return BackingObject.fromObject(obj).getNewRepresentation();
        }
      }

      class RepresentedFactory {
        static initial(obj) {
          const backingObj = BackingObject.fromObject(obj);
          const rep_official = backingObj.getNewRepresentation();
          const represented = new Represented(backingObj, rep_official);
          rep_official.represented = represented;
          return represented;
        }
      }

      class Represented {

        constructor(backingObj, rep_official) {
          this.backingObj = backingObj;

          this.reps = {};
          this.reps["official"] = rep_official;
        }

        r_official() {
          return this.reps["official"];
        }

        createNewRepresentation(repName, repType = "std") {
          logger.log("createNewRepresentation", repName, repType);
          const rep_new = this.backingObj.getNewRepresentation(repType);
          rep_new.represented = this;

          this.reps[repName] = rep_new;

          return rep_new;
        }

        getRepresentation(repName) {
          return this.reps[repName];
        }

        // removeRepresentation(repName) {
        //   if(repName == "official") {
        //     throw new Error("Represented::removeRepresentation, can't remove official rep");
        //   }
        //   const rep = this.reps[repName];
        //   this.backingObj.removeRepresentation(rep);
        //   delete this.reps[repName];
        // }

        removeRepresentation(rep) {
          if (rep == this.r_official()) {
            throw new Error("Represented::removeRepresentation, can't remove official rep");
          }
          this.backingObj.removeRepresentation(rep);

          const repName = this.getRepNameForRep(rep);
          delete this.reps[repName];
        }

        deconstruct() {
          //warning: this is only to be used when destroying represented
          // this.backingObj = null;
          this.reps = {};
        }

        getRepNameForRep(rep_unknown) {
          var outString;

          const entry_found = Object.entries(this.reps).find(([repName, rep]) => rep == rep_unknown);
          if (entry_found != null) {
            outString = entry_found[0];
          } else {
            console.log("rep not found in represented");
            outString = null;
          }

          return outString;
        }



        //convenience
        r_free() {
          return this.reps["free"];
        }

        r_snapped() {
          return this.reps["snapped"];
        }






        officialSerial_p() {
          const rep = this.r_official();
          const serial_p = rep.toSerial_p();
          return serial_p;
        }





      }

      // class RepresentationNetwork {
      //
      //
      // }
      //
      // class RepresentationNetworkNode {
      //
      //
      // }


      //representation "plus"
      function createRepresentation(target, id_rep, arr_backingObj/*, dict_ignoredPropName = {}*/) {
        logger.log("createRepresentation", "target", target);
        // console.log("createRepresentation", JSON.stringify(target));

        // const targetClass = target.constructor;

        const broadcaster = {}; //--> push to backingObject(s)
        broadcaster.id_rep = id_rep;
        broadcaster.arr_backingObj = arr_backingObj;
        broadcaster.addBackingObject = function (backingObj) {
          broadcaster.arr_backingObj.push(backingObj);
          backingObj.addRepresentation(broadcaster.representation);
        };

        // broadcaster.createSisterRepresentation = function(backingObj = null) {  //~ "gemini rep"
        //   var targetBackingObj = backingObj;
        //   if(targetBackingObj == null) {
        //     const backingObj_first = broadcaster.arr_backingObj.find(e => true);
        //     targetBackingObj = backingObj_first;
        //   }
        //
        //   const rep_elder  = broadcaster.representation;
        //   const rep_sister = targetBackingObj.getNewRepresentation();
        //
        //   rep_sister.follow(rep_elder);
        //   rep_elder.follow(rep_sister);
        //
        //   return rep_sister;
        // };
        //
        // broadcaster.removeSisterRepresentation = (rep) => {
        //   //SHU: TODO
        // };

        broadcaster.followers = {};
        broadcaster.addFollower = function (rep) {
          broadcaster.followers[rep.id_rep] = rep;
        }

        broadcaster.removeFollower = function (rep) {
          delete broadcaster.followers[rep.id_rep];
        }


        broadcaster.didUpdateFromInner = (representation, propName, oldValue, newValue) => {
          // logger.log("broadcaster.didUpdateFromInner", representation, propName, oldValue, newValue);
          broadcaster.didUpdateFromInnerListeners.forEach((listener, i) => {
            listener(representation, propName, oldValue, newValue);
          });
        };

        // var innerUpdates = {};
        broadcaster.didUpdateFromInnerListeners = [];
        broadcaster.onInnerUpdate = (listener) => {
          broadcaster.didUpdateFromInnerListeners.push(listener);
        };
        broadcaster.offInnerUpdate = (listener) => {
          // logger.log("broadcaster.didUpdateFromInnerListeners, before", broadcaster.didUpdateFromInnerListeners);
          broadcaster.didUpdateFromInnerListeners = Utils.arrayByRemovingElement(broadcaster.didUpdateFromInnerListeners, listener);
          // logger.log("broadcaster.didUpdateFromInnerListeners,  after", broadcaster.didUpdateFromInnerListeners);
        };

        broadcaster.offAllInnerUpdates = () => {
          receiver.didUpdateFromInnerListeners = [];
        };


        const receiver = {}; //<-- receive updates from backingObject(s)
        receiver.id_rep = id_rep;

        const inner = target.clone();
        // console.log("inner", inner);

        const representation = new Proxy({}, {
          get: function (obj, propName) {
            // console.log("representation.get", propName);
            var outProp;

            if (propName in broadcaster) {
              outProp = broadcaster[propName];//.bind(broadcaster);
            } else if (propName in receiver) {
              outProp = receiver[propName];//.bind(receiver);
            }

            else if (propName in inner) {
              outProp = inner[propName];//.bind(inner);
            }

            // else {
            //   console.log("representation", obj);
            //   throw new Error("unknown propName" + "(" + propName + ")" + " for representation: " + obj);
            // }

            return outProp;
          },
          set: function (obj, propName, setValue) {
            if (propName == "touchStateDict") {
              logger.trace("representation.set", propName, setValue);
            }

            if (propName in broadcaster) {
              broadcaster[propName] = setValue;
            } else if (propName in receiver) {
              receiver[propName] = setValue;
            }

            else {
              //setting something in inner

              // const isIgnoredPropName = (dict_ignoredPropName[propName] != null);
              // if(!isIgnoredPropName) {

              const oldValue = inner[propName];
              const newValue = setValue;

              updateInternals(propName, setValue);
              broadcaster.arr_backingObj.forEach((backingObj, i) => {
                // console.log("representation has updated", broadcaster.representation);
                // console.log("broadcasting to", backingObj);
                backingObj.updateWithPropFromRepresentation(propName, setValue, broadcaster.representation);
              });

              broadcaster.didUpdateFromInner(broadcaster.representation, propName, oldValue, newValue);

              // }

            }

            return true;
          },
        });

        function updateInternals(propName, value) {
          // console.log("updateInternals", propName, value);

          inner[propName] = value;
        }

        //follow system

        receiver.followed = {};

        receiver.follow = function (rep) {
          const follower = receiver.representation;
          const followed = rep;

          if (followed == follower) {
            //can't follow self
            //ignore
            return;
          }

          followed.followers[follower.id_rep] = follower;
          follower.followed[followed.id_rep] = followed;
        }

        receiver.unfollow = function (rep) {
          const follower = receiver.representation;
          const followed = rep;

          if (followed.followers[follower.id_rep] != null) {
            delete followed.followers[follower.id_rep];
          }
          if (follower.followed[followed.id_rep] != null) {
            delete follower.followed[followed.id_rep];
          }
        }

        receiver.followAll = function () {
          const arr_repDicts = arr_backingObj.map((backingObj) => backingObj.representations);
          const arr_allreps = arr_repDicts.reduce((acc, repDict) => {
            const arr = acc;
            arr.push(...Object.values(repDict));
            return arr;
          }, []);
          arr_allreps.forEach((rep, i) => {
            receiver.follow(rep);
          });
        }

        receiver.unfollowAll = function () {
          const followed = Object.assign({}, receiver.followed);
          Object.values(followed).forEach((rep, i) => {
            receiver.unfollow(rep);
          });
        }

        // receiver.inner = inner;
        receiver.syncWith = function (rep, set_propName__ignored = null) {
          // Object.entries(rep.inner).forEach(([propName,value], i) => {
          //   updateInternals(propName, value);
          // });

          const arr_propName = Object.keys(inner);

          var arr_propName__filtered;
          if (set_propName__ignored == null) {
            arr_propName__filtered = arr_propName;
          } else {
            arr_propName__filtered = arr_propName.filter(propName => !set_propName__ignored.has(propName));
          }

          arr_propName__filtered.forEach((propName, i) => {
            const value = rep[propName];
            console.log("+++syncWith", propName, value);
            updateInternals(propName, value);
          });

        };

        receiver.syncWithObj = function (obj, set_propName__ignored = null) {

          const arr_propName = Object.keys(obj);

          var arr_propName__filtered;
          if (set_propName__ignored == null) {
            arr_propName__filtered = arr_propName;
          } else {
            arr_propName__filtered = arr_propName.filter(propName => !set_propName__ignored.has(propName));
          }

          arr_propName__filtered.forEach((propName, i) => {
            const value = obj[propName];
            console.log("+++syncWithObj", propName, value);
            updateInternals(propName, value);
          });

        };


        var outerUpdates = {};
        receiver.updateFromOuter = (propName, value, rep) => {
          // console.log("updateFromOuter", propName, value);

          // const isIgnoredPropName = (dict_ignoredPropName[propName] != null);
          // if(isIgnoredPropName) {
          //   return;
          // }

          const isRepFollowed = (receiver.followed[rep.id_rep] == rep);
          if (!isRepFollowed) {
            // console.log("rep not followed", "ignore");
            return;
          }

          // outerUpdates[propName] = value;
          if (outerUpdates[propName] == null) {
            outerUpdates[propName] = {
              old: inner[propName],     //SHU: beware with this

              //debug
              // old: value,
            };
          }
          outerUpdates[propName]["new"] = value;


          updateInternals(propName, value);

          // receiver.didUpdateProp(prop,value);

          function reportOuterUpdates() {
            // console.log("didUpdateTimeout", "triggering");
            receiver.didUpdateFromOuter(outerUpdates);
            receiver.didUpdateFromOuterTimeout = null;
            outerUpdates = {};
          }

          //timeout to avoid calling didUpdate for every updated prop (==throttle)
          if (receiver.didUpdateFromOuterTimeout == null) {

            // const timeout_delayInMs = 17;
            const timeout_delayInMs = 0;
            // const timeout_delayInMs = 500;

            receiver.didUpdateFromOuterTimeout = setTimeout(() => {
              reportOuterUpdates();
            }, timeout_delayInMs);

          }

          // requestAnimationFrame(reportOuterUpdates);

        };


        // receiver.remoteInnerUpdate = (propName, value, rep) => {
        //
        // };


        // receiver.didUpdatePropListeners = [];
        // receiver.didUpdateProp = (prop,value) => {
        //   receiver.didUpdatePropListeners.forEach((listener, i) => {
        //     listener(prop,value);
        //   });
        // }

        receiver.didUpdateFromOuterTimeout = null;
        receiver.didUpdateFromOuterListeners = [];
        receiver.didUpdateFromOuter = (updateDict) => {
          // console.log("receiver", "didUpdate");
          receiver.didUpdateFromOuterListeners.forEach((listener, i) => {
            listener(receiver.representation, updateDict);
          });
        };

        receiver.onOuterUpdate = (listener) => {
          receiver.didUpdateFromOuterListeners.push(listener);
        };

        receiver.offOuterUpdate = (listener) => {
          receiver.didUpdateFromOuterListeners = Utils.arrayByRemovingElement(receiver.didUpdateFromOuterListeners, listener);
        };

        receiver.offAllOuterUpdates = () => {
          receiver.didUpdateFromOuterListeners = [];
        };

        receiver.represented = null;


        receiver.toSerial_p = () => {
          // console.log("inner", inner);
          return inner.toSerial_p();
        }


        const glassFacade = new Proxy(inner, {
          get: function (obj, propName) {
            // console.log("glassFacade.get", propName);
            var outProp;

            if (propName === 'toJSON') {
              return function () { return obj; }
            }

            if (propName in inner) {	//Be careful! The in operator matches all object keys, including those in the object's prototype chain.
              outProp = inner[propName];
            } else {
              outProp = representation[propName];
            }

            return outProp;
          },
          set: function (obj, propName, setValue) {
            //console.log("glassFacade.set", propName /*,setValue*/ );
            representation[propName] = setValue;
            return true;
          },
        });

        broadcaster.representation = glassFacade;
        receiver.representation = glassFacade;


        return glassFacade;
      }


      // function createRepresentation__ghost(target, id_rep, arr_backingObj) {
      //   //feel/channel everything but moves
      //   const dict_ignoredPropName = {
      //     position: true,
      //   };
      //   const rep = createRepresentation(target, id_rep, arr_backingObj, dict_ignoredPropName);
      //
      //   return rep;
      // }



      /*//////
      *********/

      class Enginiter {

        static installEngine(engineCarrier, engine) {

          //install func for engine to work properly
          engineCarrier.getScopeObj = function (engineCarrier) {
            const scopeObj = {
              engineCarrier: engineCarrier,
            };
            return scopeObj;
          };

          //install engine
          // engineCarrier.engine = engine;
        }

      }

      class Engine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }

          this.start = function () {   //SHU: attention, il y a peut-être une drôlerie de closure ici
            logger.log("this.scopeObj.engineCarrier", this.scopeObj.engineCarrier);
            const engineCarrier = this.scopeObj.engineCarrier;
            //do something with engineCarrier
          };

          this.stop = function () {
            // delete this.scopeObj;
          };

          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }

      class DebugEngine_growText {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }

          this.start = function () {   //SHU: attention, il y a peut-être une drôlerie de closure ici
            // logger.log("engine.start()");
            // logger.log("this.scopeObj.engineCarrier", this.scopeObj.engineCarrier);

            const engineCarrier = this.scopeObj.engineCarrier;

            engineCarrier.text += "[]";

            const interval__growth = setInterval(() => {
              // logger.log("debugEngine_growText", "interval");

              engineCarrier.text += "[]";              //linear      growth
              // engineCarrier.text += engineCarrier.text;   //exponential growth

              if (engineCarrier.text.length > 10000) {
                // engineCarrier.engine.stop();
                this.stop();
              }

            }, 1000);


            if (this.scopeObj.running == null) {
              this.scopeObj.running = {};
            }
            this.scopeObj.running["interval"] = {
              interval__growth: interval__growth,
            };
          };

          this.stop = function () {
            // logger.log("engine.stop()");

            if (this.scopeObj.running != null) {
              if (this.scopeObj.running["interval"] != null) {
                const arr_interval = Object.values(this.scopeObj.running["interval"]);

                arr_interval.forEach((interval, i) => {
                  clearInterval(interval);
                });

              }
            }
          };

          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }

      class DebugEngine_changeColor {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }

          this.start = function () {   //SHU: attention, il y a peut-être une drôlerie de closure ici
            // logger.log("engine.start()");
            // logger.log("this.scopeObj.engineCarrier", this.scopeObj.engineCarrier);

            const engineCarrier = this.scopeObj.engineCarrier;

            engineCarrier.backgroundColor = ColorUtils.randomColor();

            const interval__growth = setInterval(() => {
              // logger.log("debugEngine_changeColor", "interval");

              engineCarrier.backgroundColor = ColorUtils.randomColor();

            }, 777);


            if (this.scopeObj.running == null) {
              this.scopeObj.running = {};
            }
            this.scopeObj.running["interval"] = {
              interval__growth: interval__growth,
            };
          };

          this.stop = function () {
            logger.log("engine.stop()");

            if (this.scopeObj.running != null) {
              if (this.scopeObj.running["interval"] != null) {
                const arr_interval = Object.values(this.scopeObj.running["interval"]);

                arr_interval.forEach((interval, i) => {
                  clearInterval(interval);
                });

              }
            }
          };

          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }



      class Toucher {

        constructor() {
          this.transformationFunc = null;
        }

        static debugInstance() {
          const toucher = new Toucher();

          const transformationFunc = (icObject_in) => {
            var outMutationObject = {};

            function randomColor() {
              var r = 255 * Math.random() | 0,
                g = 255 * Math.random() | 0,
                b = 255 * Math.random() | 0;
              return 'rgb(' + r + ',' + g + ',' + b + ')';
            }

            const color = randomColor();
            outMutationObject.fill   = color;
            outMutationObject.stroke = color;

            return outMutationObject;
          };

          toucher.transformationFunc = transformationFunc;

          return toucher;
        }

      }


      class TouchSlotEngine {
        // constructor(touchSlotConfig) {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptTouching = function (icObj_slot, icObj_piece) {
            // logger.log("attemptTouching", icObj_slot, icObj_piece);

            const canTouch = this.checkCanTouch(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            // logger.log("attempting to touch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canTouch) {
              console.log("can touch");

              const rep_official = icObj_piece;
              const represented = icObj_piece.represented;
              const rep_free = represented.getRepresentation("free");

              // console.log("rep_free.isHeld", rep_free.isHeld);
              // if(rep_free.isHeld) {
              //   presnap(icObj_slot, icObj_piece);
              // } else {
              //   presnap(icObj_slot, icObj_piece);
              //   snap(icObj_slot, icObj_piece);
              // }

              this.touch(icObj_slot, icObj_piece);

            } else {
              console.log("can't touch");
            }

          };

          this.checkCanTouch = function (icObj_slot, icObj_piece) {
            // logger.log("checkCanTouch", icObj_piece);
            var outBool;

            // outBool = Touch.canTouch(icObj_piece, icObj_slot);

            var canTouchFunc = this.scopeObj.engineCarrier.touchSlotConfig.canTouchFunc;
            if (canTouchFunc == null) {

              // canTouchFunc = Touch.canTouch;

              // const infiniteCanvas = this.scopeObj.infiniteCanvas;
              // canTouchFunc = infiniteCanvas.touch2.canTouch;

              const touch2Singleton = Touch2Singleton.sharedInstance();
              canTouchFunc = touch2Singleton.canTouch.bind(touch2Singleton);

              //debug:
              // const infiniteCanvas = this.scopeObj.infiniteCanvas;
              // canTouchFunc = function(icObj__1, icObj__2, context) {
              //   return infiniteCanvas.checkIntersecting([icObj__1, icObj__2]);
              // };
            }

            const context = this.scopeObj.engineCarrier.touchSlotConfig.context;

            outBool = canTouchFunc(icObj_piece, icObj_slot, context);

            return outBool;
          };


          this.touch = async function (icObj_slot, icObj_piece) {
            console.log("touch", icObj_piece);

            const icTouchSlot = this.scopeObj.engineCarrier;


            const rep_official = icObj_piece;
            const represented = icObj_piece.represented;
            const rep_free = represented.getRepresentation("free");
            // const rep_touched  = represented.getRepresentation("snapped");


            //rep_official.touchStateDict[icObj_slot.id] = TouchState.Touched;    //SHU: as of now, don't set prop inside dict
            const touchStateDict__clone = Object.assign({}, rep_official.touchStateDict);
            touchStateDict__clone[icObj_slot.id] = TouchState.Touched;
            // rep_official.touchStateDict = touchStateDict__clone;               //SHU: it does not work well with rep_official, I've tried with rep_free and it seems ok...  (I don't care that much anymore)
            rep_free.touchStateDict = touchStateDict__clone;                  //SHU: as of now, set dict as if it were a depthless prop


            //apply mutation
            console.log("touch: apply mutation");
            // console.log("rep_official.text", rep_official.text);

            // if(rep_official.text != null) {
            //
            //   /*
            //   const number_in   = parseInt(rep_official.text,10);
            //   const number_out  = number_in + 1;
            //
            //   rep_free.text     = "" + number_out;
            //   */
            //
            //   const number_in   = parseInt(rep_official.text,10);
            //   const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            //   const number_out  = transformationFunc(number_in);
            //
            //   rep_free.text     = "" + number_out;
            // }
            // else

            // if(rep_official.mathNode != null) {
            //
            //   // const tex_in    = rep_official.tex;
            //   // const expr_in   = algebra.fromTex(tex_in);
            //   const mathNode_in = rep_official.mathNode;
            //
            //   const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            //   const mathNode_out  = transformationFunc(mathNode_in);
            //
            //   rep_free.mathNode = mathNode_out;
            //
            //   // const tex_out = expr_out.toTex();
            //   // rep_free.tex  = tex_out;
            // }
            // else

            var transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            if (transformationFunc == null) {
              transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc__touch;
            }

            if (transformationFunc != null) {
              console.log("&&&touch");
              console.log("icTouchSlot", icTouchSlot);

              const icObj__touched = rep_free;

              ////temporary
              //// {
              ////   if(icObj__touched.type == "composite" && icObj__touched.parts.contactArea != null) {
              ////     icObj__touched = icObj__touched.parts.facade;
              ////   }
              //// }

              logger.log("icObj__touched", icObj__touched);


              const transformationOutput = await transformationFunc(icObj__touched, icObj_slot);
              switch (transformationOutput.type) {
                case "new":
                  {
                    const infiniteCanvas = this.scopeObj.infiniteCanvas;

                    //get vessel
                    var rep_free__vessel;
                    // if(transformationOutput.vessel != null) {
                    // rep_free__vessel = transformationOutput.vessel;
                    const id__parentVessel = icObj__touched.compositeId;
                    if (id__parentVessel != -1) {
                      logger.log("id__parentVessel != -1", id__parentVessel);
                      const rep_free__parentVessel = infiniteCanvas.getRepresented(id__parentVessel).r_free();
                      rep_free__vessel = rep_free__parentVessel;
                    } else {
                      logger.log("id__parentVessel == -1");
                      const rep_free__supervessel = infiniteCanvas.getSupervessel();
                      rep_free__vessel = rep_free__supervessel;
                    }

                    rep_free__vessel.dict_engine["composite"].engine.awoken.removePart(icObj__touched);

                    //killOld
                    function killOld(icObj__old) {
                      // infiniteCanvas.removeIcObject(icObj__touched);
                      switch (icObj__old.type) {
                        case "composite":
                          {
                            Object.entries(icObj__old.parts).forEach(([partName, icObj__part], i) => {
                              icObj__old.dict_engine["composite"].engine.awoken.removePart(icObj__part);
                              icObj__part.im_dying_now = true;
                            });
                          }
                          break;
                        default:
                          break;
                      }

                      icObj__old.im_dying_now = true;
                    }

                    function findParentInOld(icObj__old, icObj__new) {
                      var outFindResult;

                      const findResult__initial = {
                        isFound: false,
                        parent: null,
                      };

                      outFindResult = findResult__initial;

                      switch (icObj__old.type) {
                        case "composite":
                          {
                            const arr_part = Object.values(icObj__old.parts);

                            //breadth-first
                            outFindResult = Utils.early_break_reduce(arr_part, (acc, x, i, arr) => {
                              const isFound = (x == icObj__new);
                              logger.log("isFound", x, icObj__new, isFound);
                              if (isFound) {
                                acc.parent = icObj__old;
                              }
                              acc.isFound = acc.isFound || isFound;
                              return acc;
                            }, outFindResult, (acc, x, i, arr) => {
                              return (acc.isFound == true);
                            });

                            if (!outFindResult.isFound) {
                              outFindResult = Utils.early_break_reduce(arr_part, (acc, x, i, arr) => {
                                acc = findParentInOld(x, icObj__new);
                                return acc;
                              }, outFindResult, (acc, x, i, arr) => {
                                return (acc.isFound == true);
                              });
                            }

                          }
                          break;
                        default:
                          break;
                      }

                      logger.log("findParentInOld", icObj__old, icObj__new, outFindResult);

                      return outFindResult;
                    }


                    //add new
                    function addNew(icObj__new, isInCanvas) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        Object.entries(icObj__new.parts).forEach(([partName, icObj__part], i) => {
                          icObj__part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      if (!isInCanvas) {
                        infiniteCanvas.addIcObject(icObj__new);
                      }

                      const isPositionCorrection = true;
                      if (isPositionCorrection) {
                        icObj__new.position = {
                          x: rep_free__vessel.position.x,
                          y: rep_free__vessel.position.y,
                        };
                      }

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__vessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new, false);
                    }

                    const icObj__old = icObj__touched;

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      //if icObj__new belongs to icObj__old hierarchy, remove icObj__new from icObj__old hierarchy
                      const findParentInOld_ = findParentInOld(icObj__old, icObj__new);
                      if (findParentInOld_.isFound) {
                        const composite__parent = findParentInOld_.parent;
                        composite__parent.dict_engine["composite"].engine.awoken.removePart(icObj__new);

                        logger.log("parent", composite__parent);
                        logger.log("removed part", icObj__new);

                        killOld(icObj__old);
                        addNew(icObj__new, true);

                      } else {
                        killOld(icObj__old);
                        addNew(icObj__new, false);
                      }

                    } else if (transformationOutput.value instanceof Array) {

                      logger.log("transformationOutput.value instanceof Array");

                      //SHU: TODO: manage the case "filtering multiple objects in composite"

                      const arr_new = transformationOutput.value;

                      const isOldInArray = arr_new.includes(icObj__old);
                      if (isOldInArray) {

                        const arr__truly_new = arr_new.filter(icObj => icObj != icObj__old);
                        addNew(icObj__old, true);
                        arr__truly_new.forEach((icObj__new, i) => {
                          addNew(icObj__new, false);
                        });

                      } else {
                        killOld(icObj__old);

                        arr_new.forEach((icObj__new, i) => {
                          addNew(icObj__new, false);
                        });
                      }

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);

                    const mutationObj = transformationOutput.value;
                    // icObj__touched.mathNode = mutationObj.mathNode;
                    Object.assign(icObj__touched, mutationObj);
                  }
                  break;
                // case "displaced":
                // {
                //
                // }
                // break;
                case "sadness":
                  {
                    icObj__touched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;

                // case "mathNode":     //SHU: horror code   il serait bon un jour d'harmoniser: tout le monde doit utiliser TransformationOutput
                // case "composite":    //SHU: horror code
                // // {
                // //   // icObj__touched.mathNode = transformationOutput.mathNode;
                // // }
                // break;

                default:
                  logger.log("transformationOutput", transformationOutput);
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }

            } else {
              throw new Error("touch: transformationFunc == null");
            }


          };





          this.attemptUntouching = function (icObj_slot, icObj_piece) {
            console.log("attemptUntouching", icObj_slot, icObj_piece);

            const canUntouch = this.checkCanUntouch(icObj_slot, icObj_piece);
            console.log("canUntouch", canUntouch);

            const rep_official = icObj_piece;
            console.log("attempting to untouch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canUntouch) {
              // console.log("can untouch");
              this.untouch(icObj_slot, icObj_piece);

            } else {
              // console.log("can't untouch");
            }

          };

          this.checkCanUntouch = function (icObj_slot, icObj_piece) {
            logger.log("checkCanUntouch", icObj_piece);
            var outBool;

            // outBool = Touch.canUntouch(icObj_piece, icObj_slot);
            outBool = Touch2Singleton.sharedInstance().canUntouch(icObj_piece, icObj_slot);

            return outBool;
          };

          this.untouch = function (icObj_slot, icObj_piece) {
            console.log("untouch", icObj_piece);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;

            // const rep_free     = icObj_piece;   //SHU: this is probably false
            const rep_free = infiniteCanvas.getRepresented(icObj_piece.id).r_free();

            const represented = icObj_piece.represented;
            const rep_official = represented.getRepresentation("official");


            const icTouchSlot = this.scopeObj.engineCarrier;

            const transformationFunc__untouch = icTouchSlot.touchSlotConfig.transformationFunc__untouch;
            if (transformationFunc__untouch != null) {

              const transformationFunc = transformationFunc__untouch;

              const icObj__untouched = rep_free;
              logger.log("icObj__untouched", icObj__untouched);

              const transformationOutput = transformationFunc(icObj__untouched);
              switch (transformationOutput.type) {
                case "new":   //SHU: this code has to be updated
                  {
                    const icTouchSlot = this.scopeObj.infiniteCanvas;

                    const rep_free__supervessel = infiniteCanvas.getSupervessel();

                    rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(icObj__untouched);

                    //remove old
                    {
                      // infiniteCanvas.removeIcObject(icObj__untouched);
                      icObj__untouched.im_dying_now = true;
                    }

                    //add new

                    function addNew(icObj__new) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        icObj__new.parts.forEach((part, i) => {
                          part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      infiniteCanvas.addIcObject(icObj__new);

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new);

                    }

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      addNew(icObj__new);

                    } else if (transformationOutput.value instanceof Array) {

                      transformationOutput.value.forEach((icObj__new, i) => {
                        addNew(icObj__new);
                      });

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);

                    const mutationObj = transformationOutput.value;
                    // icObj__touched.mathNode = mutationObj.mathNode;
                    Object.assign(icObj__untouched, mutationObj);
                  }
                  break;
                // case "displaced":
                // {
                //
                // }
                // break;
                case "sadness":
                  {
                    icObj__untouched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;

                // case "mathNode":     //SHU: horror code   il serait bon un jour d'harmoniser: tout le monde doit utiliser TransformationOutput
                // case "composite":    //SHU: horror code
                // // {
                // //   // icObj__touched.mathNode = transformationOutput.mathNode;
                // // }
                // break;

                default:
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }

            }

            rep_official.touchStateDict[icObj_slot.id] = TouchState.Untouched;
            // rep_free.touchStateDict[icObj_slot.id] = TouchState.Untouched;
          };



          // this.r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
          this.r_official_update_handler = function (icObj_slot, icObj_piece, outerUpdatesDict) {

            // logger.log("r_official_update_handler", icObj_piece);

            const touchState = icObj_piece.touchStateDict[icObj_slot.id];
            logger.log("logTouch", "touchState", touchState);

            if (touchState == TouchState.Untouched) {
              this.attemptTouching(icObj_slot, icObj_piece);
            } else if (touchState == TouchState.Touched) {
              this.attemptUntouching(icObj_slot, icObj_piece);
            }

          };

          // this.r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
          this.r_official_update_handler2 = function (rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions

            // logger.log("r_official_update_handler2", rep_official_incoming);

            // console.log("engine::r_official_update_handler2, this", this);
            // console.log("this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            // console.log("infiniteCanvas", infiniteCanvas);
            const icTouchSlot = this.scopeObj.engineCarrier;

            const touchSlotConfig = this.scopeObj.engineCarrier.touchSlotConfig;
            logger.log("touchSlotConfig", touchSlotConfig);

            const represented = infiniteCanvas.getRepresented(icTouchSlot.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const touchSlot = rep_official;
            const incomingObj = rep_official_incoming;

            if (incomingObj != touchSlot) { //don't touch oneself

              if (!incomingObj.isTouchable) {
                //ignore: incomingObj is intangible
              } else if (!touchSlotConfig.isEnabled) {
                //ignore: touchSlot is intangible
              } else {
                this.r_official_update_handler(touchSlot, incomingObj, outerUpdatesDict);
              }

            } else {
              console.log("I won't touch myself");  //SHU: ...
            }

          };


          this.start = function () {
            console.log("engine::start, this", this);
            // logger.log("touchSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icTouchSlot = this.scopeObj.engineCarrier;


            infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);

            //for each existing canvas object, add touchState wrt this new touchSlot
            infiniteCanvas.onceOnAddRepresentedForIcObject(icTouchSlot, (icTouchSlot) => {

              const id_touchSlot = icTouchSlot.id;

              const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
              const arr_official_preexisiting = arr_official.filter(rep => (rep.id != id_touchSlot));
              arr_official_preexisiting.forEach((rep, i) => {

                rep.touchStateDict[id_touchSlot] = TouchState.Untouched;
                //SHU TODO: check if touches

              });

            });

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }


      class DropTouchSlotEngine {
        // constructor(touchSlotConfig) {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptTouching = function (icObj_slot, icObj_piece) {
            // logger.log("DropTouchSlotEngine::attemptTouching", icObj_slot, icObj_piece);

            const canTouch = this.checkCanTouch(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            console.log("attempting to touch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canTouch) {
              console.log("can touch");

              const rep_official = icObj_piece;
              const represented = icObj_piece.represented;
              const rep_free = represented.getRepresentation("free");

              // console.log("rep_free.isHeld", rep_free.isHeld);
              // if(rep_free.isHeld) {
              //   presnap(icObj_slot, icObj_piece);
              // } else {
              //   presnap(icObj_slot, icObj_piece);
              //   snap(icObj_slot, icObj_piece);
              // }

              this.touch(icObj_slot, icObj_piece);

            } else {
              console.log("can't touch");
            }

          };

          this.checkCanTouch = function (icObj_slot, icObj_piece) {
            // logger.log("DropTouchSlotEngine::checkCanTouch", icObj_piece);
            var outBool;

            // outBool = Touch.canTouch(icObj_piece, icObj_slot);

            var canTouchFunc = this.scopeObj.engineCarrier.touchSlotConfig.canTouchFunc;
            if (canTouchFunc == null) {
              // canTouchFunc = Touch.canTouch;

              const touch2Singleton = Touch2Singleton.sharedInstance();
              canTouchFunc = touch2Singleton.canTouch.bind(touch2Singleton);
            }

            const context = this.scopeObj.engineCarrier.touchSlotConfig.context;

            outBool = canTouchFunc(icObj_piece, icObj_slot, context);

            return outBool;
          };


          this.touch = function (icObj_slot, icObj_piece) {
            logger.log("DropTouchSlotEngine::touch", icObj_piece);

            const icTouchSlot = this.scopeObj.engineCarrier;


            const rep_official = icObj_piece;
            // const represented  = icObj_piece.represented;
            // const rep_free     = represented.getRepresentation("free");
            // const rep_touched  = represented.getRepresentation("snapped");

            rep_official.touchStateDict[icObj_slot.id] = TouchState.Touched;

            const represented = icObj_piece.represented;
            const rep_free = represented.getRepresentation("free");

            //apply mutation
            console.log("touch: apply mutation");
            // console.log("rep_official.text", rep_official.text);

            {
              console.log("&&&touch");
              console.log("icDropTouchSlot", icTouchSlot);

              const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc__touch;

              var icObj__touched = rep_free;

              ////temporary
              //// {
              ////   if(icObj__touched.type == "composite" && icObj__touched.parts.contactArea != null) {
              ////     icObj__touched = icObj__touched.parts.facade;
              ////   }
              //// }

              logger.log("icObj__touched", icObj__touched);


              const transformationOutput = transformationFunc(icObj__touched);
              logger.log("transformationOutput", transformationOutput);
              switch (transformationOutput.type) {
                case "new":
                  {
                    const icTouchSlot = this.scopeObj.infiniteCanvas;

                    const rep_free__supervessel = infiniteCanvas.getSupervessel();

                    rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(icObj__touched);

                    //remove old
                    {
                      // infiniteCanvas.removeIcObject(icObj__touched);
                      icObj__touched.im_dying_now = true;
                    }

                    //add new

                    function addNew(icObj__new) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        icObj__new.parts.forEach((part, i) => {
                          part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      infiniteCanvas.addIcObject(icObj__new);

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new, false);

                    }

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      addNew(icObj__new);

                    } else if (transformationOutput.value instanceof Array) {

                      transformationOutput.value.forEach((icObj__new, i) => {
                        addNew(icObj__new);
                      });

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);
                    //old version
                    // const mutationObj = transformationFunc(icObj__touched);
                    const mutationObj = transformationOutput;

                    switch (transformationOutput.type) {
                      case "mathNode":
                        icObj__touched.mathNode = mutationObj.mathNode;
                        break;
                      default:
                        // throw new Error("unsupported transformationOutput.type: " + transformationOutput.type);      //SHU: careful
                        Object.assign(icObj__touched, mutationObj);
                        break;
                    }
                  }
                  break;
                case "displaced":
                  {
                    logger.log("transformationOutput.type == displaced");
                  }
                  break;
                case "sadness":
                  {
                    icObj__touched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;
                default:
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }


            }


            //debug
            {
              const rep_free__slot = infiniteCanvas.getRepresented(icObj_slot.id).r_free();
              rep_free__slot.fill = ColorUtils.randomColor();
            }



          };





          this.attemptUntouching = function (icObj_slot, icObj_piece) {
            logger.log("logDropTouchSlot", "attemptUntouching", icObj_slot, icObj_piece);

            const canUntouch = this.checkCanUntouch(icObj_slot, icObj_piece);
            logger.log("logDropTouchSlot", "attemptUntouching", "canUntouch:", canUntouch);

            const rep_official = icObj_piece;
            console.log("attempting to untouch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canUntouch) {
              // console.log("can untouch");
              this.untouch(icObj_slot, icObj_piece);

            } else {
              // console.log("can't untouch");
            }

          };

          this.checkCanUntouch = function (icObj_slot, icObj_piece) {
            logger.log("logDropTouchSlot", "checkCanUntouch", icObj_slot, icObj_piece);
            var outBool;

            var canUntouchFunc = this.scopeObj.engineCarrier.touchSlotConfig.canUntouchFunc;
            if (canUntouchFunc == null) {

              const touch2Singleton = Touch2Singleton.sharedInstance();
              canUntouchFunc = touch2Singleton.canUntouch.bind(touch2Singleton);
            }

            const context = this.scopeObj.engineCarrier.touchSlotConfig.context;

            outBool = canUntouchFunc(icObj_piece, icObj_slot, context);

            return outBool;
          };

          this.untouch = function (icObj_slot, icObj_piece) {
            console.log("untouch", icObj_piece);

            const icTouchSlot = this.scopeObj.engineCarrier;

            const represented = icObj_piece.represented;
            const rep_official = represented.getRepresentation("official");
            const rep_free = represented.getRepresentation("free");

            //apply mutation
            console.log("untouch: apply mutation");
            // console.log("rep_official.text", rep_official.text);

            {
              console.log("&&&untouch");
              console.log("icDropTouchSlot", icTouchSlot);

              const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc__untouch;

              const icObj__untouched = rep_free;

              const transformationOutput = transformationFunc(icObj__untouched);
              logger.log("transformationOutput", transformationOutput);
              switch (transformationOutput.type) {
                case "new":
                  {
                    const infiniteCanvas = this.scopeObj.infiniteCanvas;

                    const rep_free__supervessel = infiniteCanvas.getSupervessel();

                    rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(icObj__untouched);

                    //remove old
                    {
                      // infiniteCanvas.removeIcObject(icObj__touched);
                      icObj__untouched.im_dying_now = true;
                    }

                    //add new

                    function addNew(icObj__new) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        icObj__new.parts.forEach((part, i) => {
                          part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      infiniteCanvas.addIcObject(icObj__new);

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new, false);

                    }

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      addNew(icObj__new);

                    } else if (transformationOutput.value instanceof Array) {

                      transformationOutput.value.forEach((icObj__new, i) => {
                        addNew(icObj__new);
                      });

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);
                    //old version
                    // const mutationObj = transformationFunc(icObj__touched);
                    const mutationObj = transformationOutput;

                    switch (transformationOutput.type) {
                      case "mathNode":
                        icObj__untouched.mathNode = mutationObj.mathNode;
                        break;
                      default:
                        // throw new Error("unsupported transformationOutput.type: " + transformationOutput.type);      //SHU: careful
                        Object.assign(icObj__touched, mutationObj);
                        break;
                    }
                  }
                  break;
                case "displaced":
                  {
                    logger.log("transformationOutput.type == displaced");
                  }
                  break;
                case "sadness":
                  {
                    icObj__untouched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;
                default:
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }


            }


            //debug
            {
              const rep_free__slot = infiniteCanvas.getRepresented(icObj_slot.id).r_free();
              rep_free__slot.fill = ColorUtils.randomColor();
            }



            rep_official.touchStateDict[icObj_slot.id] = TouchState.Untouched;
          };



          // this.r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
          this.r_official_update_handler = function (icObj_slot, icObj_piece, outerUpdatesDict) {

            const dropTouchSlot   = this.scopeObj.engineCarrier;
            const touchSlotConfig = this.scopeObj.engineCarrier.touchSlotConfig;

            // logger.log("r_official_update_handler", icObj_piece);

            const touchState = icObj_piece.touchStateDict[icObj_slot.id];
            // logger.log("touchState", touchState);

            if (touchState == TouchState.Untouched) {
              
              //touching is only triggered by dropping the piece in
              if (outerUpdatesDict.isHeld == null || outerUpdatesDict.isHeld.new == true) { 
                return;
              }
              
              const isObjectIgnored_ = touchSlotConfig.filterFunc__touch__isObjectIgnored(icObj_piece);
              logger.log("logPlatform", "isObjectIgnored_:", isObjectIgnored_);
              if (!isObjectIgnored_) {
                this.attemptTouching(icObj_slot, icObj_piece);
              }
            } else if (touchState == TouchState.Touched) {
              
              //allow untouching by "sliding" the piece away
              if (icObj_piece.isHeld) { /*ok*/ }

              const isObjectIgnored_ = touchSlotConfig.filterFunc__untouch__isObjectIgnored(icObj_piece);
              logger.log("logPlatform", "isObjectIgnored_:", isObjectIgnored_);
              if (!isObjectIgnored_) {
                this.attemptUntouching(icObj_slot, icObj_piece);
              }
            }

          };

          // this.isObjectIgnored = function (incomingObj) {  // Platform should override this function
          //   // to allow platform to transport intangible objects
          //   //ignore: incomingObj is intangible         //  while not allowing 'standard' dropTouchSlot to touch intangible objects
          //   return !incomingObj.isTouchable;
          // };

          // this.r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
          this.r_official_update_handler2 = function (rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions

            // logger.log("r_official_update_handler2", rep_official_incoming, outerUpdatesDict);

            // console.log("engine::r_official_update_handler2, this", this);
            // console.log("this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            // console.log("infiniteCanvas", infiniteCanvas);
            const icTouchSlot = this.scopeObj.engineCarrier;

            const represented = infiniteCanvas.getRepresented(icTouchSlot.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const touchSlot   = rep_official;
            const incomingObj = rep_official_incoming;

            const touchSlotConfig = touchSlot.touchSlotConfig;

            if (incomingObj != touchSlot) { //don't touch oneself
                this.r_official_update_handler(touchSlot, incomingObj, outerUpdatesDict);
            } else {
              console.log("I won't touch myself");  //SHU: ...
            }

          };




          this.start = function () {
            console.log("engine::start, this", this);
            logger.log("dropTouchSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icTouchSlot = this.scopeObj.engineCarrier;


            infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);

            //for each existing canvas object, add touchState wrt this new touchSlot
            infiniteCanvas.onceOnAddRepresentedForIcObject(icTouchSlot, (icTouchSlot) => {

              const id_touchSlot = icTouchSlot.id;

              const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
              const arr_official_preexisiting = arr_official.filter(rep => (rep.id != id_touchSlot));
              arr_official_preexisiting.forEach((rep, i) => {

                rep.touchStateDict[id_touchSlot] = TouchState.Untouched;
                //SHU TODO: check if touches

              });

            });

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }


      class PokeSlotEngine {
        // constructor(pokeSlotConfig) {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptPoking = function (icObj_slot, icObj_piece) {
            // logger.log("logPoke", "attemptPoking", icObj_slot, icObj_piece);

            const canPoke = this.checkCanPoke(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            // logger.log("attempting to poke with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canPoke) {
              console.log("can poke");

              const rep_official = icObj_piece;
              const represented  = icObj_piece.represented;
              const rep_free     = represented.getRepresentation("free");

              // console.log("rep_free.isHeld", rep_free.isHeld);
              // if(rep_free.isHeld) {
              //   presnap(icObj_slot, icObj_piece);
              // } else {
              //   presnap(icObj_slot, icObj_piece);
              //   snap(icObj_slot, icObj_piece);
              // }

              this.poke(icObj_slot, icObj_piece);

            } else {
              console.log("can't poke");
            }

          };

          this.checkCanPoke = function (icObj_slot, icObj_piece) {
            // logger.log("checkCanPoke", icObj_piece);
            var outBool;

            // outBool = Touch.canTouch(icObj_piece, icObj_slot);

            var canPokeFunc = this.scopeObj.engineCarrier.pokeSlotConfig.canPokeFunc;
            if (canPokeFunc == null) {

              // canTouchFunc = Touch.canTouch;

              // const infiniteCanvas = this.scopeObj.infiniteCanvas;
              // canTouchFunc = infiniteCanvas.touch2.canTouch;

              const touch2Singleton = Touch2Singleton.sharedInstance();
              canPokeFunc = touch2Singleton.canTouch.bind(touch2Singleton);

              //debug:
              // const infiniteCanvas = this.scopeObj.infiniteCanvas;
              // canTouchFunc = function(icObj__1, icObj__2, context) {
              //   return infiniteCanvas.checkIntersecting([icObj__1, icObj__2]);
              // };
            }

            const context = this.scopeObj.engineCarrier.pokeSlotConfig.context;

            outBool = canPokeFunc(icObj_piece, icObj_slot, context);

            return outBool;
          };


          this.poke = async function (icObj_slot, icObj_piece) {
            // logger.log("logPoke", "poke", icObj_piece);

            const icPokeSlot = this.scopeObj.engineCarrier;


            const rep_official = icObj_piece;
            const represented = icObj_piece.represented;
            const rep_free = represented.getRepresentation("free");
            // const rep_touched  = represented.getRepresentation("snapped");


            //rep_official.touchStateDict[icObj_slot.id] = TouchState.Touched;    //SHU: as of now, don't set prop inside dict
            const touchStateDict__clone = Object.assign({}, rep_official.touchStateDict);
            touchStateDict__clone[icObj_slot.id] = TouchState.Touched;
            // rep_official.touchStateDict = touchStateDict__clone;               //SHU: it does not work well with rep_official, I've tried with rep_free and it seems ok...  (I don't care that much anymore)
            rep_free.touchStateDict = touchStateDict__clone;                  //SHU: as of now, set dict as if it were a depthless prop


            //apply mutation
            console.log("touch: apply mutation");
            // console.log("rep_official.text", rep_official.text);

            // if(rep_official.text != null) {
            //
            //   /*
            //   const number_in   = parseInt(rep_official.text,10);
            //   const number_out  = number_in + 1;
            //
            //   rep_free.text     = "" + number_out;
            //   */
            //
            //   const number_in   = parseInt(rep_official.text,10);
            //   const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            //   const number_out  = transformationFunc(number_in);
            //
            //   rep_free.text     = "" + number_out;
            // }
            // else

            // if(rep_official.mathNode != null) {
            //
            //   // const tex_in    = rep_official.tex;
            //   // const expr_in   = algebra.fromTex(tex_in);
            //   const mathNode_in = rep_official.mathNode;
            //
            //   const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            //   const mathNode_out  = transformationFunc(mathNode_in);
            //
            //   rep_free.mathNode = mathNode_out;
            //
            //   // const tex_out = expr_out.toTex();
            //   // rep_free.tex  = tex_out;
            // }
            // else

            var transformationFunc = icPokeSlot.pokeSlotConfig.transformationFunc;
            if (transformationFunc == null) {
              transformationFunc = icPokeSlot.pokeSlotConfig.transformationFunc__poke;
            }

            if (transformationFunc != null) {
              console.log("&&&poke");
              console.log("icPokeSlot", icPokeSlot);

              const icObj__touched = rep_free;

              ////temporary
              //// {
              ////   if(icObj__touched.type == "composite" && icObj__touched.parts.contactArea != null) {
              ////     icObj__touched = icObj__touched.parts.facade;
              ////   }
              //// }

              // logger.log("icObj__touched", icObj__touched);


              const transformationOutput = await transformationFunc(icObj__touched, icObj_slot);
              switch (transformationOutput.type) {
                case "new":
                  {
                    const infiniteCanvas = this.scopeObj.infiniteCanvas;

                    //get vessel
                    var rep_free__vessel;
                    // if(transformationOutput.vessel != null) {
                    // rep_free__vessel = transformationOutput.vessel;
                    const id__parentVessel = icObj__touched.compositeId;
                    if (id__parentVessel != -1) {
                      logger.log("id__parentVessel != -1", id__parentVessel);
                      const rep_free__parentVessel = infiniteCanvas.getRepresented(id__parentVessel).r_free();
                      rep_free__vessel = rep_free__parentVessel;
                    } else {
                      logger.log("id__parentVessel == -1");
                      const rep_free__supervessel = infiniteCanvas.getSupervessel();
                      rep_free__vessel = rep_free__supervessel;
                    }

                    rep_free__vessel.dict_engine["composite"].engine.awoken.removePart(icObj__touched);

                    //killOld
                    function killOld(icObj__old) {
                      // infiniteCanvas.removeIcObject(icObj__touched);
                      switch (icObj__old.type) {
                        case "composite":
                          {
                            Object.entries(icObj__old.parts).forEach(([partName, icObj__part], i) => {
                              icObj__old.dict_engine["composite"].engine.awoken.removePart(icObj__part);
                              icObj__part.im_dying_now = true;
                            });
                          }
                          break;
                        default:
                          break;
                      }

                      icObj__old.im_dying_now = true;
                    }

                    function findParentInOld(icObj__old, icObj__new) {
                      var outFindResult;

                      const findResult__initial = {
                        isFound: false,
                        parent: null,
                      };

                      outFindResult = findResult__initial;

                      switch (icObj__old.type) {
                        case "composite":
                          {
                            const arr_part = Object.values(icObj__old.parts);

                            //breadth-first
                            outFindResult = Utils.early_break_reduce(arr_part, (acc, x, i, arr) => {
                              const isFound = (x == icObj__new);
                              logger.log("isFound", x, icObj__new, isFound);
                              if (isFound) {
                                acc.parent = icObj__old;
                              }
                              acc.isFound = acc.isFound || isFound;
                              return acc;
                            }, outFindResult, (acc, x, i, arr) => {
                              return (acc.isFound == true);
                            });

                            if (!outFindResult.isFound) {
                              outFindResult = Utils.early_break_reduce(arr_part, (acc, x, i, arr) => {
                                acc = findParentInOld(x, icObj__new);
                                return acc;
                              }, outFindResult, (acc, x, i, arr) => {
                                return (acc.isFound == true);
                              });
                            }

                          }
                          break;
                        default:
                          break;
                      }

                      logger.log("findParentInOld", icObj__old, icObj__new, outFindResult);

                      return outFindResult;
                    }


                    //add new
                    function addNew(icObj__new, isInCanvas) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        Object.entries(icObj__new.parts).forEach(([partName, icObj__part], i) => {
                          icObj__part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      if (!isInCanvas) {
                        infiniteCanvas.addIcObject(icObj__new);
                      }

                      const isPositionCorrection = true;
                      if (isPositionCorrection) {
                        icObj__new.position = {
                          x: rep_free__vessel.position.x,
                          y: rep_free__vessel.position.y,
                        };
                      }

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__vessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new, false);
                    }

                    const icObj__old = icObj__touched;

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      //if icObj__new belongs to icObj__old hierarchy, remove icObj__new from icObj__old hierarchy
                      const findParentInOld_ = findParentInOld(icObj__old, icObj__new);
                      if (findParentInOld_.isFound) {
                        const composite__parent = findParentInOld_.parent;
                        composite__parent.dict_engine["composite"].engine.awoken.removePart(icObj__new);

                        logger.log("parent", composite__parent);
                        logger.log("removed part", icObj__new);

                        killOld(icObj__old);
                        addNew(icObj__new, true);

                      } else {
                        killOld(icObj__old);
                        addNew(icObj__new, false);
                      }

                    } else if (transformationOutput.value instanceof Array) {

                      logger.log("transformationOutput.value instanceof Array");

                      //SHU: TODO: manage the case "filtering multiple objects in composite"

                      const arr_new = transformationOutput.value;

                      const isOldInArray = arr_new.includes(icObj__old);
                      if (isOldInArray) {

                        const arr__truly_new = arr_new.filter(icObj => icObj != icObj__old);
                        addNew(icObj__old, true);
                        arr__truly_new.forEach((icObj__new, i) => {
                          addNew(icObj__new, false);
                        });

                      } else {
                        killOld(icObj__old);

                        arr_new.forEach((icObj__new, i) => {
                          addNew(icObj__new, false);
                        });
                      }

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);

                    const mutationObj = transformationOutput.value;
                    // icObj__touched.mathNode = mutationObj.mathNode;
                    Object.assign(icObj__touched, mutationObj);
                  }
                  break;
                // case "displaced":
                // {
                //
                // }
                // break;
                case "sadness":
                  {
                    icObj__touched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;

                // case "mathNode":     //SHU: horror code   il serait bon un jour d'harmoniser: tout le monde doit utiliser TransformationOutput
                // case "composite":    //SHU: horror code
                // // {
                // //   // icObj__touched.mathNode = transformationOutput.mathNode;
                // // }
                // break;

                default:
                  logger.log("transformationOutput", transformationOutput);
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }

            } else {
              throw new Error("touch: transformationFunc == null");
            }


          };





          this.attemptUnpoking = function (icObj_slot, icObj_piece) {
            // logger.log("logPoke", "attemptUnpoking", icObj_slot, icObj_piece);

            const canUnpoke = this.checkCanUnpoke(icObj_slot, icObj_piece);
            console.log("canUnpoke", canUnpoke);

            const rep_official = icObj_piece;
            console.log("attempting to unpoke with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canUnpoke) {
              // console.log("can unpoke");
              this.unpoke(icObj_slot, icObj_piece);

            } else {
              // console.log("can't unpoke");
            }

          };

          this.checkCanUnpoke = function (icObj_slot, icObj_piece) {
            // logger.log("logPoke", "checkCanUnpoke", icObj_piece);
            var outBool;

            // outBool = Touch.canUntouch(icObj_piece, icObj_slot);
            outBool = Touch2Singleton.sharedInstance().canUntouch(icObj_piece, icObj_slot);

            return outBool;
          };

          this.unpoke = function (icObj_slot, icObj_piece) {
            // logger.log("logPoke", "unpoke", icObj_piece);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;

            // const rep_free     = icObj_piece;   //SHU: this is probably false
            const rep_free = infiniteCanvas.getRepresented(icObj_piece.id).r_free();

            const represented = icObj_piece.represented;
            const rep_official = represented.getRepresentation("official");


            const icPokeSlot = this.scopeObj.engineCarrier;

            const transformationFunc__unpoke = icPokeSlot.pokeSlotConfig.transformationFunc__unpoke;
            if (transformationFunc__unpoke != null) {

              const transformationFunc = transformationFunc__unpoke;

              const icObj__untouched = rep_free;
              logger.log("icObj__untouched", icObj__untouched);

              const transformationOutput = transformationFunc(icObj__untouched);
              switch (transformationOutput.type) {
                case "new":   //SHU: this code has to be updated
                  {
                    const icTouchSlot = this.scopeObj.infiniteCanvas;

                    const rep_free__supervessel = infiniteCanvas.getSupervessel();

                    rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(icObj__untouched);

                    //remove old
                    {
                      // infiniteCanvas.removeIcObject(icObj__untouched);
                      icObj__untouched.im_dying_now = true;
                    }

                    //add new

                    function addNew(icObj__new) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        icObj__new.parts.forEach((part, i) => {
                          part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      infiniteCanvas.addIcObject(icObj__new);

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new);

                    }

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      addNew(icObj__new);

                    } else if (transformationOutput.value instanceof Array) {

                      transformationOutput.value.forEach((icObj__new, i) => {
                        addNew(icObj__new);
                      });

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);

                    const mutationObj = transformationOutput.value;
                    // icObj__touched.mathNode = mutationObj.mathNode;
                    Object.assign(icObj__untouched, mutationObj);
                  }
                  break;
                // case "displaced":
                // {
                //
                // }
                // break;
                case "sadness":
                  {
                    icObj__untouched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;

                // case "mathNode":     //SHU: horror code   il serait bon un jour d'harmoniser: tout le monde doit utiliser TransformationOutput
                // case "composite":    //SHU: horror code
                // // {
                // //   // icObj__touched.mathNode = transformationOutput.mathNode;
                // // }
                // break;

                default:
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }

            }

            rep_official.touchStateDict[icObj_slot.id] = TouchState.Untouched;
            // rep_free.touchStateDict[icObj_slot.id] = TouchState.Untouched;
          };



          // this.r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
          this.r_official_update_handler = function (icObj_slot, icObj_piece, outerUpdatesDict) {
            // logger.log("logPoke", "r_official_update_handler", icObj_piece);

            const touchState = icObj_piece.touchStateDict[icObj_slot.id];
            logger.log("logTouch", "touchState", touchState);

            if (touchState == TouchState.Untouched) {
              this.attemptPoking(icObj_slot, icObj_piece);
            } else if (touchState == TouchState.Touched) {
              this.attemptUnpoking(icObj_slot, icObj_piece);
            }

          };

          // this.r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
          this.r_official_update_handler2 = function (rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions
            // logger.log("logPoke", "r_official_update_handler2", rep_official_incoming);

            // console.log("engine::r_official_update_handler2, this", this);
            // console.log("this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            // console.log("infiniteCanvas", infiniteCanvas);
            const icPokeSlot = this.scopeObj.engineCarrier;

            const pokeSlotConfig = this.scopeObj.engineCarrier.pokeSlotConfig;
            logger.log("pokeSlotConfig", pokeSlotConfig);

            const represented = infiniteCanvas.getRepresented(icPokeSlot.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const pokeSlot    = rep_official;
            const incomingObj = rep_official_incoming;

            if (incomingObj.id == pokeSlot.id) { //only follow pokeSlot's updates
              logger.log("logPoke", "track oneself");

              // if (!incomingObj.isTouchable) {
              //   //ignore: pokeSlot is intangible
              //   logger.log("logPoke", "pokeSlot is intangible");
              // } else 
              if (!pokeSlotConfig.isEnabled) {
                //ignore: pokeSlot is intangible
              } else {

                //get poked objects
                const arr__poked = infiniteCanvas.getArr_icObj__intersecting("free", icPokeSlot);
                logger.log("logPoke", "arr__poked", arr__poked);

                arr__poked.forEach((icObj__poked) => {
                  this.r_official_update_handler(pokeSlot, icObj__poked, outerUpdatesDict);
                });

              }

            } else {
              //don't care about other objects' updates
            }

          };


          this.start = function () {
            console.log("engine::start, this", this);
            // logger.log("pokeSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icPokeSlot     = this.scopeObj.engineCarrier;

            infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);

            //for each existing canvas object, add touchState wrt this new touchSlot
            infiniteCanvas.onceOnAddRepresentedForIcObject(icPokeSlot, (icPokeSlot) => {

              const id_pokeSlot = icPokeSlot.id;

              const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
              const arr_official_preexisiting = arr_official.filter(rep => (rep.id != id_pokeSlot));
              arr_official_preexisiting.forEach((rep, i) => {

                rep.touchStateDict[id_pokeSlot] = TouchState.Untouched;
                //SHU TODO: check if touches

              });

            });

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }

      class DropPokeSlotEngine { 
        //TODO 
      }


      class HookSlotEngine {
        // constructor(hookSlotConfig) {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptHooking = function (icObj_slot, icObj_piece) {
            // logger.log("attemptTouching", icObj_slot, icObj_piece);

            const canHook = this.checkCanHook(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            // logger.log("attempting to hook with hookState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canHook) {
              console.log("can hook");

              const rep_official = icObj_piece;
              const represented = icObj_piece.represented;
              const rep_free = represented.getRepresentation("free");

              // console.log("rep_free.isHeld", rep_free.isHeld);
              // if(rep_free.isHeld) {
              //   presnap(icObj_slot, icObj_piece);
              // } else {
              //   presnap(icObj_slot, icObj_piece);
              //   snap(icObj_slot, icObj_piece);
              // }

              this.hook(icObj_slot, icObj_piece);

            } else {
              console.log("can't hook");
            }

          };

          this.checkCanHook = function (icObj_slot, icObj_piece) {
            // logger.log("checkCanHook", icObj_piece);
            var outBool;

            // outBool = Touch.canTouch(icObj_piece, icObj_slot);

            var canTouchFunc = this.scopeObj.engineCarrier.hookSlotConfig.canHookFunc;
            if (canTouchFunc == null) {

              // canTouchFunc = Touch.canTouch;

              // const infiniteCanvas = this.scopeObj.infiniteCanvas;
              // canTouchFunc = infiniteCanvas.touch2.canTouch;

              // // const touch2Singleton = Touch2Singleton.sharedInstance();
              // // canTouchFunc = touch2Singleton.canTouch.bind(touch2Singleton);

              //debug:
              // const infiniteCanvas = this.scopeObj.infiniteCanvas;
              // canTouchFunc = function(icObj__1, icObj__2, context) {
              //   return infiniteCanvas.checkIntersecting([icObj__1, icObj__2]);
              // };

              canHookFunc = function(icObj__1, icObj__2, context) {
                return true;
              };
            }

            const context = this.scopeObj.engineCarrier.hookSlotConfig.context;

            outBool = canHookFunc(icObj_piece, icObj_slot, context);

            return outBool;
          };


          this.hook = async function (icObj_slot, icObj_piece) {
            console.log("hook", icObj_piece);

            const icHookSlot = this.scopeObj.engineCarrier;


            const rep_official = icObj_piece;
            const represented = icObj_piece.represented;
            const rep_free = represented.getRepresentation("free");
            // const rep_touched  = represented.getRepresentation("snapped");


            //rep_official.touchStateDict[icObj_slot.id] = TouchState.Touched;    //SHU: as of now, don't set prop inside dict
            const hookStateDict__clone = Object.assign({}, rep_official.hookStateDict);
            hookStateDict__clone[icObj_slot.id] = HookState.Hooked;
            // rep_official.touchStateDict = touchStateDict__clone;               //SHU: it does not work well with rep_official, I've tried with rep_free and it seems ok...  (I don't care that much anymore)
            rep_free.hookStateDict = hookStateDict__clone;                  //SHU: as of now, set dict as if it were a depthless prop


            //apply mutation
            console.log("hook: apply mutation");
            // console.log("rep_official.text", rep_official.text);

            // if(rep_official.text != null) {
            //
            //   /*
            //   const number_in   = parseInt(rep_official.text,10);
            //   const number_out  = number_in + 1;
            //
            //   rep_free.text     = "" + number_out;
            //   */
            //
            //   const number_in   = parseInt(rep_official.text,10);
            //   const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            //   const number_out  = transformationFunc(number_in);
            //
            //   rep_free.text     = "" + number_out;
            // }
            // else

            // if(rep_official.mathNode != null) {
            //
            //   // const tex_in    = rep_official.tex;
            //   // const expr_in   = algebra.fromTex(tex_in);
            //   const mathNode_in = rep_official.mathNode;
            //
            //   const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            //   const mathNode_out  = transformationFunc(mathNode_in);
            //
            //   rep_free.mathNode = mathNode_out;
            //
            //   // const tex_out = expr_out.toTex();
            //   // rep_free.tex  = tex_out;
            // }
            // else

            var transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            if (transformationFunc == null) {
              transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc__touch;
            }

            if (transformationFunc != null) {
              console.log("&&&touch");
              console.log("icTouchSlot", icTouchSlot);

              const icObj__touched = rep_free;

              ////temporary
              //// {
              ////   if(icObj__touched.type == "composite" && icObj__touched.parts.contactArea != null) {
              ////     icObj__touched = icObj__touched.parts.facade;
              ////   }
              //// }

              logger.log("icObj__touched", icObj__touched);


              const transformationOutput = await transformationFunc(icObj__touched, icObj_slot);
              switch (transformationOutput.type) {
                case "new":
                  {
                    const infiniteCanvas = this.scopeObj.infiniteCanvas;

                    //get vessel
                    var rep_free__vessel;
                    // if(transformationOutput.vessel != null) {
                    // rep_free__vessel = transformationOutput.vessel;
                    const id__parentVessel = icObj__touched.compositeId;
                    if (id__parentVessel != -1) {
                      logger.log("id__parentVessel != -1", id__parentVessel);
                      const rep_free__parentVessel = infiniteCanvas.getRepresented(id__parentVessel).r_free();
                      rep_free__vessel = rep_free__parentVessel;
                    } else {
                      logger.log("id__parentVessel == -1");
                      const rep_free__supervessel = infiniteCanvas.getSupervessel();
                      rep_free__vessel = rep_free__supervessel;
                    }

                    rep_free__vessel.dict_engine["composite"].engine.awoken.removePart(icObj__touched);

                    //killOld
                    function killOld(icObj__old) {
                      // infiniteCanvas.removeIcObject(icObj__touched);
                      switch (icObj__old.type) {
                        case "composite":
                          {
                            Object.entries(icObj__old.parts).forEach(([partName, icObj__part], i) => {
                              icObj__old.dict_engine["composite"].engine.awoken.removePart(icObj__part);
                              icObj__part.im_dying_now = true;
                            });
                          }
                          break;
                        default:
                          break;
                      }

                      icObj__old.im_dying_now = true;
                    }

                    function findParentInOld(icObj__old, icObj__new) {
                      var outFindResult;

                      const findResult__initial = {
                        isFound: false,
                        parent: null,
                      };

                      outFindResult = findResult__initial;

                      switch (icObj__old.type) {
                        case "composite":
                          {
                            const arr_part = Object.values(icObj__old.parts);

                            //breadth-first
                            outFindResult = Utils.early_break_reduce(arr_part, (acc, x, i, arr) => {
                              const isFound = (x == icObj__new);
                              logger.log("isFound", x, icObj__new, isFound);
                              if (isFound) {
                                acc.parent = icObj__old;
                              }
                              acc.isFound = acc.isFound || isFound;
                              return acc;
                            }, outFindResult, (acc, x, i, arr) => {
                              return (acc.isFound == true);
                            });

                            if (!outFindResult.isFound) {
                              outFindResult = Utils.early_break_reduce(arr_part, (acc, x, i, arr) => {
                                acc = findParentInOld(x, icObj__new);
                                return acc;
                              }, outFindResult, (acc, x, i, arr) => {
                                return (acc.isFound == true);
                              });
                            }

                          }
                          break;
                        default:
                          break;
                      }

                      logger.log("findParentInOld", icObj__old, icObj__new, outFindResult);

                      return outFindResult;
                    }


                    //add new
                    function addNew(icObj__new, isInCanvas) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        Object.entries(icObj__new.parts).forEach(([partName, icObj__part], i) => {
                          icObj__part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      if (!isInCanvas) {
                        infiniteCanvas.addIcObject(icObj__new);
                      }

                      const isPositionCorrection = true;
                      if (isPositionCorrection) {
                        icObj__new.position = {
                          x: rep_free__vessel.position.x,
                          y: rep_free__vessel.position.y,
                        };
                      }

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__vessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new, false);
                    }

                    const icObj__old = icObj__touched;

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      //if icObj__new belongs to icObj__old hierarchy, remove icObj__new from icObj__old hierarchy
                      const findParentInOld_ = findParentInOld(icObj__old, icObj__new);
                      if (findParentInOld_.isFound) {
                        const composite__parent = findParentInOld_.parent;
                        composite__parent.dict_engine["composite"].engine.awoken.removePart(icObj__new);

                        logger.log("parent", composite__parent);
                        logger.log("removed part", icObj__new);

                        killOld(icObj__old);
                        addNew(icObj__new, true);

                      } else {
                        killOld(icObj__old);
                        addNew(icObj__new, false);
                      }

                    } else if (transformationOutput.value instanceof Array) {

                      logger.log("transformationOutput.value instanceof Array");

                      //SHU: TODO: manage the case "filtering multiple objects in composite"

                      const arr_new = transformationOutput.value;

                      const isOldInArray = arr_new.includes(icObj__old);
                      if (isOldInArray) {

                        const arr__truly_new = arr_new.filter(icObj => icObj != icObj__old);
                        addNew(icObj__old, true);
                        arr__truly_new.forEach((icObj__new, i) => {
                          addNew(icObj__new, false);
                        });

                      } else {
                        killOld(icObj__old);

                        arr_new.forEach((icObj__new, i) => {
                          addNew(icObj__new, false);
                        });
                      }

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);

                    const mutationObj = transformationOutput.value;
                    // icObj__touched.mathNode = mutationObj.mathNode;
                    Object.assign(icObj__touched, mutationObj);
                  }
                  break;
                // case "displaced":
                // {
                //
                // }
                // break;
                case "sadness":
                  {
                    icObj__touched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;

                // case "mathNode":     //SHU: horror code   il serait bon un jour d'harmoniser: tout le monde doit utiliser TransformationOutput
                // case "composite":    //SHU: horror code
                // // {
                // //   // icObj__touched.mathNode = transformationOutput.mathNode;
                // // }
                // break;

                default:
                  logger.log("transformationOutput", transformationOutput);
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }

            } else {
              throw new Error("touch: transformationFunc == null");
            }


          };





          this.attemptUntouching = function (icObj_slot, icObj_piece) {
            console.log("attemptUntouching", icObj_slot, icObj_piece);

            const canUntouch = this.checkCanUntouch(icObj_slot, icObj_piece);
            console.log("canUntouch", canUntouch);

            const rep_official = icObj_piece;
            console.log("attempting to untouch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canUntouch) {
              // console.log("can untouch");
              this.untouch(icObj_slot, icObj_piece);

            } else {
              // console.log("can't untouch");
            }

          };

          this.checkCanUntouch = function (icObj_slot, icObj_piece) {
            logger.log("checkCanUntouch", icObj_piece);
            var outBool;

            // outBool = Touch.canUntouch(icObj_piece, icObj_slot);
            outBool = Touch2Singleton.sharedInstance().canUntouch(icObj_piece, icObj_slot);

            return outBool;
          };

          this.untouch = function (icObj_slot, icObj_piece) {
            console.log("untouch", icObj_piece);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;

            // const rep_free     = icObj_piece;   //SHU: this is probably false
            const rep_free = infiniteCanvas.getRepresented(icObj_piece.id).r_free();

            const represented = icObj_piece.represented;
            const rep_official = represented.getRepresentation("official");


            const icTouchSlot = this.scopeObj.engineCarrier;

            const transformationFunc__untouch = icTouchSlot.touchSlotConfig.transformationFunc__untouch;
            if (transformationFunc__untouch != null) {

              const transformationFunc = transformationFunc__untouch;

              const icObj__untouched = rep_free;
              logger.log("icObj__untouched", icObj__untouched);

              const transformationOutput = transformationFunc(icObj__untouched);
              switch (transformationOutput.type) {
                case "new":   //SHU: this code has to be updated
                  {
                    const icTouchSlot = this.scopeObj.infiniteCanvas;

                    const rep_free__supervessel = infiniteCanvas.getSupervessel();

                    rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(icObj__untouched);

                    //remove old
                    {
                      // infiniteCanvas.removeIcObject(icObj__untouched);
                      icObj__untouched.im_dying_now = true;
                    }

                    //add new

                    function addNew(icObj__new) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        icObj__new.parts.forEach((part, i) => {
                          part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      infiniteCanvas.addIcObject(icObj__new);

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new);

                    }

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      addNew(icObj__new);

                    } else if (transformationOutput.value instanceof Array) {

                      transformationOutput.value.forEach((icObj__new, i) => {
                        addNew(icObj__new);
                      });

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);

                    const mutationObj = transformationOutput.value;
                    // icObj__touched.mathNode = mutationObj.mathNode;
                    Object.assign(icObj__untouched, mutationObj);
                  }
                  break;
                // case "displaced":
                // {
                //
                // }
                // break;
                case "sadness":
                  {
                    icObj__untouched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;

                // case "mathNode":     //SHU: horror code   il serait bon un jour d'harmoniser: tout le monde doit utiliser TransformationOutput
                // case "composite":    //SHU: horror code
                // // {
                // //   // icObj__touched.mathNode = transformationOutput.mathNode;
                // // }
                // break;

                default:
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }

            }

            rep_official.touchStateDict[icObj_slot.id] = TouchState.Untouched;
            // rep_free.touchStateDict[icObj_slot.id] = TouchState.Untouched;
          };



          // this.r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
          this.r_official_update_handler = function (icObj_slot, icObj_piece, outerUpdatesDict) {

            // logger.log("r_official_update_handler", icObj_piece);

            const touchState = icObj_piece.touchStateDict[icObj_slot.id];
            logger.log("logTouch", "touchState", touchState);

            if (touchState == TouchState.Untouched) {
              this.attemptTouching(icObj_slot, icObj_piece);
            } else if (touchState == TouchState.Touched) {
              this.attemptUntouching(icObj_slot, icObj_piece);
            }

          };

          // this.r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
          this.r_official_update_handler2 = function (rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions

            // logger.log("r_official_update_handler2", rep_official_incoming);

            // console.log("engine::r_official_update_handler2, this", this);
            // console.log("this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            // console.log("infiniteCanvas", infiniteCanvas);
            const icTouchSlot = this.scopeObj.engineCarrier;

            const touchSlotConfig = this.scopeObj.engineCarrier.touchSlotConfig;
            logger.log("touchSlotConfig", touchSlotConfig);

            const represented = infiniteCanvas.getRepresented(icTouchSlot.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const touchSlot = rep_official;
            const incomingObj = rep_official_incoming;

            if (incomingObj != touchSlot) { //don't touch oneself

              if (!incomingObj.isTouchable) {
                //ignore: incomingObj is intangible
              } else if (!touchSlotConfig.isEnabled) {
                //ignore: touchSlot is intangible
              } else {
                this.r_official_update_handler(touchSlot, incomingObj, outerUpdatesDict);
              }

            } else {
              console.log("I won't touch myself");  //SHU: ...
            }

          };


          this.start = function () {
            console.log("engine::start, this", this);
            // logger.log("touchSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icTouchSlot = this.scopeObj.engineCarrier;


            infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);

            //for each existing canvas object, add touchState wrt this new touchSlot
            infiniteCanvas.onceOnAddRepresentedForIcObject(icTouchSlot, (icTouchSlot) => {

              const id_touchSlot = icTouchSlot.id;

              const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
              const arr_official_preexisiting = arr_official.filter(rep => (rep.id != id_touchSlot));
              arr_official_preexisiting.forEach((rep, i) => {

                rep.touchStateDict[id_touchSlot] = TouchState.Untouched;
                //SHU TODO: check if touches

              });

            });

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }





      class ApplySlotEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptTouching = function (icObj_slot, icObj_piece) {
            // logger.log("attemptTouching", icObj_slot, icObj_piece);

            const canTouch = this.checkCanTouch(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            // logger.log("attempting to touch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canTouch) {
              console.log("can touch");

              const rep_official = icObj_piece;
              const represented = icObj_piece.represented;
              const rep_free = represented.getRepresentation("free");

              // console.log("rep_free.isHeld", rep_free.isHeld);
              // if(rep_free.isHeld) {
              //   presnap(icObj_slot, icObj_piece);
              // } else {
              //   presnap(icObj_slot, icObj_piece);
              //   snap(icObj_slot, icObj_piece);
              // }

              this.touch(icObj_slot, icObj_piece);

            } else {
              console.log("can't touch");
            }

          };

          this.checkCanTouch = function (icObj_slot, icObj_piece) {
            // logger.log("checkCanTouch", icObj_piece);
            var outBool;

            // outBool = Touch.canTouch(icObj_piece, icObj_slot);

            var canTouchFunc = this.scopeObj.engineCarrier.applySlotConfig.canTouchFunc;
            if (canTouchFunc == null) {

              // canTouchFunc = Touch.canTouch;

              // const infiniteCanvas = this.scopeObj.infiniteCanvas;
              // canTouchFunc = infiniteCanvas.touch2.canTouch;

              const touch2Singleton = Touch2Singleton.sharedInstance();
              canTouchFunc = touch2Singleton.canTouch.bind(touch2Singleton);

              //debug:
              // const infiniteCanvas = this.scopeObj.infiniteCanvas;
              // canTouchFunc = function(icObj__1, icObj__2, context) {
              //   return infiniteCanvas.checkIntersecting([icObj__1, icObj__2]);
              // };
            }

            const context = this.scopeObj.engineCarrier.applySlotConfig.context;

            outBool = canTouchFunc(icObj_piece, icObj_slot, context);

            return outBool;
          };


          this.touch = async function (icObj_slot, icObj_piece) {
            console.log("touch", icObj_piece);

            const icApplySlot   = this.scopeObj.engineCarrier;

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icEventSource  = infiniteCanvas.eventSource;

            const rep_official = icObj_piece;
            const represented = icObj_piece.represented;
            const rep_free = represented.getRepresentation("free");
            // const rep_touched  = represented.getRepresentation("snapped");


            //rep_official.touchStateDict[icObj_slot.id] = TouchState.Touched;    
            const touchStateDict__clone = Object.assign({}, rep_official.touchStateDict);
            touchStateDict__clone[icObj_slot.id] = TouchState.Touched;
            // rep_official.touchStateDict = touchStateDict__clone;               
            rep_free.touchStateDict = touchStateDict__clone;                  


            //await for (!)apply(!) event

          };

          // this.lol() = async function() {
          //   //apply mutation
          //   console.log("touch: apply mutation");
          //   // console.log("rep_official.text", rep_official.text);

          //   // if(rep_official.text != null) {
          //   //
          //   //   /*
          //   //   const number_in   = parseInt(rep_official.text,10);
          //   //   const number_out  = number_in + 1;
          //   //
          //   //   rep_free.text     = "" + number_out;
          //   //   */
          //   //
          //   //   const number_in   = parseInt(rep_official.text,10);
          //   //   const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
          //   //   const number_out  = transformationFunc(number_in);
          //   //
          //   //   rep_free.text     = "" + number_out;
          //   // }
          //   // else

          //   // if(rep_official.mathNode != null) {
          //   //
          //   //   // const tex_in    = rep_official.tex;
          //   //   // const expr_in   = algebra.fromTex(tex_in);
          //   //   const mathNode_in = rep_official.mathNode;
          //   //
          //   //   const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
          //   //   const mathNode_out  = transformationFunc(mathNode_in);
          //   //
          //   //   rep_free.mathNode = mathNode_out;
          //   //
          //   //   // const tex_out = expr_out.toTex();
          //   //   // rep_free.tex  = tex_out;
          //   // }
          //   // else

          //   var transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
          //   if (transformationFunc == null) {
          //     transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc__touch;
          //   }

          //   if (transformationFunc != null) {
          //     console.log("&&&touch");
          //     console.log("icTouchSlot", icTouchSlot);

          //     const icObj__touched = rep_free;

          //     ////temporary
          //     //// {
          //     ////   if(icObj__touched.type == "composite" && icObj__touched.parts.contactArea != null) {
          //     ////     icObj__touched = icObj__touched.parts.facade;
          //     ////   }
          //     //// }

          //     logger.log("icObj__touched", icObj__touched);


          //     const transformationOutput = await transformationFunc(icObj__touched, icObj_slot);
          //     switch (transformationOutput.type) {
          //       case "new":
          //         {
          //           const infiniteCanvas = this.scopeObj.infiniteCanvas;

          //           //get vessel
          //           var rep_free__vessel;
          //           // if(transformationOutput.vessel != null) {
          //           // rep_free__vessel = transformationOutput.vessel;
          //           const id__parentVessel = icObj__touched.compositeId;
          //           if (id__parentVessel != -1) {
          //             logger.log("id__parentVessel != -1", id__parentVessel);
          //             const rep_free__parentVessel = infiniteCanvas.getRepresented(id__parentVessel).r_free();
          //             rep_free__vessel = rep_free__parentVessel;
          //           } else {
          //             logger.log("id__parentVessel == -1");
          //             const rep_free__supervessel = infiniteCanvas.getSupervessel();
          //             rep_free__vessel = rep_free__supervessel;
          //           }

          //           rep_free__vessel.dict_engine["composite"].engine.awoken.removePart(icObj__touched);

          //           //killOld
          //           function killOld(icObj__old) {
          //             // infiniteCanvas.removeIcObject(icObj__touched);
          //             switch (icObj__old.type) {
          //               case "composite":
          //                 {
          //                   Object.entries(icObj__old.parts).forEach(([partName, icObj__part], i) => {
          //                     icObj__old.dict_engine["composite"].engine.awoken.removePart(icObj__part);
          //                     icObj__part.im_dying_now = true;
          //                   });
          //                 }
          //                 break;
          //               default:
          //                 break;
          //             }

          //             icObj__old.im_dying_now = true;
          //           }

          //           function findParentInOld(icObj__old, icObj__new) {
          //             var outFindResult;

          //             const findResult__initial = {
          //               isFound: false,
          //               parent: null,
          //             };

          //             outFindResult = findResult__initial;

          //             switch (icObj__old.type) {
          //               case "composite":
          //                 {
          //                   const arr_part = Object.values(icObj__old.parts);

          //                   //breadth-first
          //                   outFindResult = Utils.early_break_reduce(arr_part, (acc, x, i, arr) => {
          //                     const isFound = (x == icObj__new);
          //                     logger.log("isFound", x, icObj__new, isFound);
          //                     if (isFound) {
          //                       acc.parent = icObj__old;
          //                     }
          //                     acc.isFound = acc.isFound || isFound;
          //                     return acc;
          //                   }, outFindResult, (acc, x, i, arr) => {
          //                     return (acc.isFound == true);
          //                   });

          //                   if (!outFindResult.isFound) {
          //                     outFindResult = Utils.early_break_reduce(arr_part, (acc, x, i, arr) => {
          //                       acc = findParentInOld(x, icObj__new);
          //                       return acc;
          //                     }, outFindResult, (acc, x, i, arr) => {
          //                       return (acc.isFound == true);
          //                     });
          //                   }

          //                 }
          //                 break;
          //               default:
          //                 break;
          //             }

          //             logger.log("findParentInOld", icObj__old, icObj__new, outFindResult);

          //             return outFindResult;
          //           }


          //           //add new
          //           function addNew(icObj__new, isInCanvas) {
          //             icObj__new.isTouchable = true;
          //             icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
          //             if (icObj__new.type == "composite") {
          //               Object.entries(icObj__new.parts).forEach(([partName, icObj__part], i) => {
          //                 icObj__part.touchStateDict[icObj_slot.id] = TouchState.Touched;
          //               });
          //             }

          //             if (!isInCanvas) {
          //               infiniteCanvas.addIcObject(icObj__new);
          //             }

          //             const isPositionCorrection = true;
          //             if (isPositionCorrection) {
          //               icObj__new.position = {
          //                 x: rep_free__vessel.position.x,
          //                 y: rep_free__vessel.position.y,
          //               };
          //             }

          //             const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
          //             rep_free__vessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new, false);
          //           }

          //           const icObj__old = icObj__touched;

          //           if (transformationOutput.value instanceof IcObject) {

          //             const icObj__new = transformationOutput.value;
          //             logger.log("icObj__new", icObj__new);

          //             //if icObj__new belongs to icObj__old hierarchy, remove icObj__new from icObj__old hierarchy
          //             const findParentInOld_ = findParentInOld(icObj__old, icObj__new);
          //             if (findParentInOld_.isFound) {
          //               const composite__parent = findParentInOld_.parent;
          //               composite__parent.dict_engine["composite"].engine.awoken.removePart(icObj__new);

          //               logger.log("parent", composite__parent);
          //               logger.log("removed part", icObj__new);

          //               killOld(icObj__old);
          //               addNew(icObj__new, true);

          //             } else {
          //               killOld(icObj__old);
          //               addNew(icObj__new, false);
          //             }

          //           } else if (transformationOutput.value instanceof Array) {

          //             logger.log("transformationOutput.value instanceof Array");

          //             //SHU: TODO: manage the case "filtering multiple objects in composite"

          //             const arr_new = transformationOutput.value;

          //             const isOldInArray = arr_new.includes(icObj__old);
          //             if (isOldInArray) {

          //               const arr__truly_new = arr_new.filter(icObj => icObj != icObj__old);
          //               addNew(icObj__old, true);
          //               arr__truly_new.forEach((icObj__new, i) => {
          //                 addNew(icObj__new, false);
          //               });

          //             } else {
          //               killOld(icObj__old);

          //               arr_new.forEach((icObj__new, i) => {
          //                 addNew(icObj__new, false);
          //               });
          //             }

          //           } else {
          //             throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
          //           }
          //         }
          //         break;
          //       case "old":
          //         {
          //           //do nothing: object has not changed
          //         }
          //         break;
          //       case "mutated":
          //         {
          //           logger.log("transformationOutput:", transformationOutput);

          //           const mutationObj = transformationOutput.value;
          //           // icObj__touched.mathNode = mutationObj.mathNode;
          //           Object.assign(icObj__touched, mutationObj);
          //         }
          //         break;
          //       // case "displaced":
          //       // {
          //       //
          //       // }
          //       // break;
          //       case "sadness":
          //         {
          //           icObj__touched.mathNode = transformationOutput.value.mathNode;
          //         }
          //         break;

          //       // case "mathNode":     //SHU: horror code   il serait bon un jour d'harmoniser: tout le monde doit utiliser TransformationOutput
          //       // case "composite":    //SHU: horror code
          //       // // {
          //       // //   // icObj__touched.mathNode = transformationOutput.mathNode;
          //       // // }
          //       // break;

          //       default:
          //         logger.log("transformationOutput", transformationOutput);
          //         throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
          //         break;
          //     }

          //   } else {
          //     throw new Error("touch: transformationFunc == null");
          //   }
          // };





          this.attemptUntouching = function (icObj_slot, icObj_piece) {
            console.log("attemptUntouching", icObj_slot, icObj_piece);

            const canUntouch = this.checkCanUntouch(icObj_slot, icObj_piece);
            console.log("canUntouch", canUntouch);

            const rep_official = icObj_piece;
            console.log("attempting to untouch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canUntouch) {
              // console.log("can untouch");
              this.untouch(icObj_slot, icObj_piece);

            } else {
              // console.log("can't untouch");
            }

          };

          this.checkCanUntouch = function (icObj_slot, icObj_piece) {
            logger.log("checkCanUntouch", icObj_piece);
            var outBool;

            // outBool = Touch.canUntouch(icObj_piece, icObj_slot);
            outBool = Touch2Singleton.sharedInstance().canUntouch(icObj_piece, icObj_slot);

            return outBool;
          };

          this.untouch = function (icObj_slot, icObj_piece) {
            console.log("untouch", icObj_piece);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;

            // const rep_free     = icObj_piece;   //SHU: this is probably false
            const rep_free = infiniteCanvas.getRepresented(icObj_piece.id).r_free();

            const represented = icObj_piece.represented;
            const rep_official = represented.getRepresentation("official");


            const icApplySlot = this.scopeObj.engineCarrier;

            rep_official.touchStateDict[icObj_slot.id] = TouchState.Untouched;
            // rep_free.touchStateDict[icObj_slot.id] = TouchState.Untouched;
          };



          // this.r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
          this.r_official_update_handler = function (icObj_slot, icObj_piece, outerUpdatesDict) {

            // logger.log("r_official_update_handler", icObj_piece);

            const touchState = icObj_piece.touchStateDict[icObj_slot.id];
            logger.log("logTouch", "touchState", touchState);

            if (touchState == TouchState.Untouched) {
              this.attemptTouching(icObj_slot, icObj_piece);
            } else if (touchState == TouchState.Touched) {
              this.attemptUntouching(icObj_slot, icObj_piece);
            }

          };

          // this.r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
          this.r_official_update_handler2 = function (rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions

            // logger.log("r_official_update_handler2", rep_official_incoming);

            // console.log("engine::r_official_update_handler2, this", this);
            // console.log("this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            // console.log("infiniteCanvas", infiniteCanvas);
            const icTouchSlot = this.scopeObj.engineCarrier;

            const touchSlotConfig = this.scopeObj.engineCarrier.touchSlotConfig;
            logger.log("touchSlotConfig", touchSlotConfig);

            const represented = infiniteCanvas.getRepresented(icTouchSlot.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const touchSlot = rep_official;
            const incomingObj = rep_official_incoming;

            if (incomingObj != touchSlot) { //don't touch oneself

              if (!incomingObj.isTouchable) {
                //ignore: incomingObj is intangible
              } else if (!touchSlotConfig.isEnabled) {
                //ignore: touchSlot is intangible
              } else {
                this.r_official_update_handler(touchSlot, incomingObj, outerUpdatesDict);
              }

            } else {
              console.log("I won't touch myself");  //SHU: ...
            }

          };


          this.start = function () {
            console.log("engine::start, this", this);
            // logger.log("touchSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icApplySlot    = this.scopeObj.engineCarrier;


            // infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);

            // //for each existing canvas object, add touchState wrt this new touchSlot
            // infiniteCanvas.onceOnAddRepresentedForIcObject(icTouchSlot, (icTouchSlot) => {

            //   const id_touchSlot = icTouchSlot.id;

            //   const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
            //   const arr_official_preexisiting = arr_official.filter(rep => (rep.id != id_touchSlot));
            //   arr_official_preexisiting.forEach((rep, i) => {

            //     rep.touchStateDict[id_touchSlot] = TouchState.Untouched;
            //     //SHU TODO: check if touches

            //   });

            // });

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }



      class DiveSlotEngine {
        // constructor(diveSlotConfig) {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptTouching = function (icObj_slot, icObj_piece) {
            // logger.log("attemptTouching", icObj_slot, icObj_piece);

            const canTouch = this.checkCanTouch(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            // logger.log("attempting to touch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canTouch) {
              console.log("can touch");

              const rep_official = icObj_piece;
              const represented = icObj_piece.represented;
              const rep_free = represented.getRepresentation("free");

              // console.log("rep_free.isHeld", rep_free.isHeld);
              // if(rep_free.isHeld) {
              //   presnap(icObj_slot, icObj_piece);
              // } else {
              //   presnap(icObj_slot, icObj_piece);
              //   snap(icObj_slot, icObj_piece);
              // }

              this.touch(icObj_slot, icObj_piece);

            } else {
              console.log("can't touch");
            }

          };

          this.checkCanTouch = function (icObj_slot, icObj_piece) {
            logger.log("DiveSlot", "checkCanTouch", icObj_piece);
            var outBool;

            var canTouchFunc = this.scopeObj.engineCarrier.diveSlotConfig.canTouchFunc;
            if (canTouchFunc == null) {

              const diveTouchSingleton = DiveTouchSingleton.sharedInstance();
              canTouchFunc = diveTouchSingleton.canTouch.bind(diveTouchSingleton);

            }

            const context = this.scopeObj.engineCarrier.diveSlotConfig.context;

            outBool = canTouchFunc(icObj_piece, icObj_slot, context);

            return outBool;
          };


          this.touch = async function (icObj_slot, icObj_piece) {
            console.log("DiveSlot", "touch", icObj_piece);

            const icDiveSlot = this.scopeObj.engineCarrier;


            const rep_official = icObj_piece;
            const represented = icObj_piece.represented;
            const rep_free = represented.getRepresentation("free");
            // const rep_touched  = represented.getRepresentation("snapped");


            //rep_official.touchStateDict[icObj_slot.id] = TouchState.Touched;    //SHU: as of now, don't set prop inside dict
            const touchStateDict__clone = Object.assign({}, rep_official.touchStateDict);
            touchStateDict__clone[icObj_slot.id] = TouchState.Touched;
            // rep_official.touchStateDict = touchStateDict__clone;               //SHU: it does not work well with rep_official, I've tried with rep_free and it seems ok...  (I don't care that much anymore)
            rep_free.touchStateDict = touchStateDict__clone;                  //SHU: as of now, set dict as if it were a depthless prop


            //apply mutation
            console.log("touch: apply mutation");

            var transformationFunc = icDiveSlot.diveSlotConfig.transformationFunc;
            if (transformationFunc == null) {
              transformationFunc = icDiveSlot.diveSlotConfig.transformationFunc__touch;
            }

            if (transformationFunc != null) {
              console.log("&&&touch");
              console.log("icDiveSlot", icDiveSlot);

              const icObj__touched = rep_free;

              ////temporary
              //// {
              ////   if(icObj__touched.type == "composite" && icObj__touched.parts.contactArea != null) {
              ////     icObj__touched = icObj__touched.parts.facade;
              ////   }
              //// }

              logger.log("icObj__touched", icObj__touched);


              const transformationOutput = await transformationFunc(icObj__touched, icObj_slot);
              switch (transformationOutput.type) {
                case "new":
                  {
                    const infiniteCanvas = this.scopeObj.infiniteCanvas;

                    //get vessel
                    var rep_free__vessel;
                    // if(transformationOutput.vessel != null) {
                    // rep_free__vessel = transformationOutput.vessel;
                    const id__parentVessel = icObj__touched.compositeId;
                    if (id__parentVessel != -1) {
                      logger.log("id__parentVessel != -1", id__parentVessel);
                      const rep_free__parentVessel = infiniteCanvas.getRepresented(id__parentVessel).r_free();
                      rep_free__vessel = rep_free__parentVessel;
                    } else {
                      logger.log("id__parentVessel == -1");
                      const rep_free__supervessel = infiniteCanvas.getSupervessel();
                      rep_free__vessel = rep_free__supervessel;
                    }

                    rep_free__vessel.dict_engine["composite"].engine.awoken.removePart(icObj__touched);

                    //killOld
                    function killOld(icObj__old) {
                      // infiniteCanvas.removeIcObject(icObj__touched);
                      switch (icObj__old.type) {
                        case "composite":
                          {
                            Object.entries(icObj__old.parts).forEach(([partName, icObj__part], i) => {
                              icObj__old.dict_engine["composite"].engine.awoken.removePart(icObj__part);
                              icObj__part.im_dying_now = true;
                            });
                          }
                          break;
                        default:
                          break;
                      }

                      icObj__old.im_dying_now = true;
                    }

                    function findParentInOld(icObj__old, icObj__new) {
                      var outFindResult;

                      const findResult__initial = {
                        isFound: false,
                        parent: null,
                      };

                      outFindResult = findResult__initial;

                      switch (icObj__old.type) {
                        case "composite":
                          {
                            const arr_part = Object.values(icObj__old.parts);

                            //breadth-first
                            outFindResult = Utils.early_break_reduce(arr_part, (acc, x, i, arr) => {
                              const isFound = (x == icObj__new);
                              logger.log("isFound", x, icObj__new, isFound);
                              if (isFound) {
                                acc.parent = icObj__old;
                              }
                              acc.isFound = acc.isFound || isFound;
                              return acc;
                            }, outFindResult, (acc, x, i, arr) => {
                              return (acc.isFound == true);
                            });

                            if (!outFindResult.isFound) {
                              outFindResult = Utils.early_break_reduce(arr_part, (acc, x, i, arr) => {
                                acc = findParentInOld(x, icObj__new);
                                return acc;
                              }, outFindResult, (acc, x, i, arr) => {
                                return (acc.isFound == true);
                              });
                            }

                          }
                          break;
                        default:
                          break;
                      }

                      logger.log("findParentInOld", icObj__old, icObj__new, outFindResult);

                      return outFindResult;
                    }


                    //add new
                    function addNew(icObj__new, isInCanvas) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        Object.entries(icObj__new.parts).forEach(([partName, icObj__part], i) => {
                          icObj__part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      if (!isInCanvas) {
                        infiniteCanvas.addIcObject(icObj__new);
                      }

                      const isPositionCorrection = true;
                      if (isPositionCorrection) {
                        icObj__new.position = {
                          x: rep_free__vessel.position.x,
                          y: rep_free__vessel.position.y,
                        };
                      }

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__vessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new, false);
                    }

                    const icObj__old = icObj__touched;

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      //if icObj__new belongs to icObj__old hierarchy, remove icObj__new from icObj__old hierarchy
                      const findParentInOld_ = findParentInOld(icObj__old, icObj__new);
                      if (findParentInOld_.isFound) {
                        const composite__parent = findParentInOld_.parent;
                        composite__parent.dict_engine["composite"].engine.awoken.removePart(icObj__new);

                        logger.log("parent", composite__parent);
                        logger.log("removed part", icObj__new);

                        killOld(icObj__old);
                        addNew(icObj__new, true);

                      } else {
                        killOld(icObj__old);
                        addNew(icObj__new, false);
                      }

                    } else if (transformationOutput.value instanceof Array) {

                      logger.log("transformationOutput.value instanceof Array");

                      //SHU: TODO: manage the case "filtering multiple objects in composite"

                      const arr_new = transformationOutput.value;

                      const isOldInArray = arr_new.includes(icObj__old);
                      if (isOldInArray) {

                        const arr__truly_new = arr_new.filter(icObj => icObj != icObj__old);
                        addNew(icObj__old, true);
                        arr__truly_new.forEach((icObj__new, i) => {
                          addNew(icObj__new, false);
                        });

                      } else {
                        killOld(icObj__old);

                        arr_new.forEach((icObj__new, i) => {
                          addNew(icObj__new, false);
                        });
                      }

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);

                    const mutationObj = transformationOutput.value;
                    // icObj__touched.mathNode = mutationObj.mathNode;
                    Object.assign(icObj__touched, mutationObj);
                  }
                  break;
                // case "displaced":
                // {
                //
                // }
                // break;
                case "sadness":
                  {
                    icObj__touched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;

                // case "mathNode":     //SHU: horror code   il serait bon un jour d'harmoniser: tout le monde doit utiliser TransformationOutput
                // case "composite":    //SHU: horror code
                // // {
                // //   // icObj__touched.mathNode = transformationOutput.mathNode;
                // // }
                // break;

                default:
                  logger.log("transformationOutput", transformationOutput);
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }

            } else {
              throw new Error("touch: transformationFunc == null");
            }


          };





          this.attemptUntouching = function (icObj_slot, icObj_piece) {
            console.log("attemptUntouching", icObj_slot, icObj_piece);

            const canUntouch = this.checkCanUntouch(icObj_slot, icObj_piece);
            console.log("canUntouch", canUntouch);

            const rep_official = icObj_piece;
            console.log("attempting to untouch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canUntouch) {
              // console.log("can untouch");
              this.untouch(icObj_slot, icObj_piece);

            } else {
              // console.log("can't untouch");
            }

          };

          this.checkCanUntouch = function (icObj_slot, icObj_piece) {
            logger.log("DiveSlot", "checkCanUntouch", icObj_piece);
            var outBool;

            var canUntouchFunc = this.scopeObj.engineCarrier.diveSlotConfig.canUntouchFunc;
            if (canUntouchFunc == null) {

              const diveTouchSingleton = DiveTouchSingleton.sharedInstance();
              canUntouchFunc = diveTouchSingleton.canUntouch.bind(diveTouchSingleton);
            }

            const context = this.scopeObj.engineCarrier.diveSlotConfig.context;

            outBool = canUntouchFunc(icObj_piece, icObj_slot, context);

            return outBool;
          };

          this.untouch = function (icObj_slot, icObj_piece) {
            console.log("untouch", icObj_piece);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;

            // const rep_free     = icObj_piece;   //SHU: this is probably false
            const rep_free = infiniteCanvas.getRepresented(icObj_piece.id).r_free();

            const represented = icObj_piece.represented;
            const rep_official = represented.getRepresentation("official");


            const icDiveSlot = this.scopeObj.engineCarrier;

            const transformationFunc__untouch = icDiveSlot.diveSlotConfig.transformationFunc__untouch;
            if (transformationFunc__untouch != null) {

              const transformationFunc = transformationFunc__untouch;

              const icObj__untouched = rep_free;
              logger.log("icObj__untouched", icObj__untouched);

              const transformationOutput = transformationFunc(icObj__untouched);
              switch (transformationOutput.type) {
                case "new":   //SHU: this code has to be updated
                  {
                    const infiniteCanvas = this.scopeObj.infiniteCanvas;

                    const rep_free__supervessel = infiniteCanvas.getSupervessel();

                    rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(icObj__untouched);

                    //remove old
                    {
                      // infiniteCanvas.removeIcObject(icObj__untouched);
                      icObj__untouched.im_dying_now = true;
                    }

                    //add new

                    function addNew(icObj__new) {
                      icObj__new.isTouchable = true;
                      icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                      if (icObj__new.type == "composite") {
                        icObj__new.parts.forEach((part, i) => {
                          part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                        });
                      }

                      infiniteCanvas.addIcObject(icObj__new);

                      const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                      rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new);

                    }

                    if (transformationOutput.value instanceof IcObject) {

                      const icObj__new = transformationOutput.value;
                      logger.log("icObj__new", icObj__new);

                      addNew(icObj__new);

                    } else if (transformationOutput.value instanceof Array) {

                      transformationOutput.value.forEach((icObj__new, i) => {
                        addNew(icObj__new);
                      });

                    } else {
                      throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                    }
                  }
                  break;
                case "old":
                  {
                    //do nothing: object has not changed
                  }
                  break;
                case "mutated":
                  {
                    logger.log("transformationOutput:", transformationOutput);

                    const mutationObj = transformationOutput.value;
                    // icObj__touched.mathNode = mutationObj.mathNode;
                    Object.assign(icObj__untouched, mutationObj);
                  }
                  break;
                // case "displaced":
                // {
                //
                // }
                // break;
                case "sadness":
                  {
                    icObj__untouched.mathNode = transformationOutput.value.mathNode;
                  }
                  break;

                // case "mathNode":     //SHU: horror code   il serait bon un jour d'harmoniser: tout le monde doit utiliser TransformationOutput
                // case "composite":    //SHU: horror code
                // // {
                // //   // icObj__touched.mathNode = transformationOutput.mathNode;
                // // }
                // break;

                default:
                  throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
                  break;
              }

            }

            rep_official.touchStateDict[icObj_slot.id] = TouchState.Untouched;
            // rep_free.touchStateDict[icObj_slot.id] = TouchState.Untouched;
          };



          // this.r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
          this.r_official_update_handler = function (icObj_slot, icObj_piece, outerUpdatesDict) {
            logger.log("logDiveSlot", "r_official_update_handler", icObj_piece);

            const touchState = icObj_piece.touchStateDict[icObj_slot.id];
            logger.log("logTouch", "touchState", touchState);

            if (touchState == TouchState.Untouched) {
              this.attemptTouching(icObj_slot, icObj_piece);
            } else if (touchState == TouchState.Touched) {
              this.attemptUntouching(icObj_slot, icObj_piece);
            }

          };

          // this.r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
          this.r_official_update_handler2 = function (rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions

            // logger.log("r_official_update_handler2", rep_official_incoming);

            // console.log("engine::r_official_update_handler2, this", this);
            // console.log("this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            // console.log("infiniteCanvas", infiniteCanvas);
            const icDiveSlot = this.scopeObj.engineCarrier;

            const diveSlotConfig = this.scopeObj.engineCarrier.diveSlotConfig;
            // logger.log("diveSlotConfig", diveSlotConfig);

            const represented = infiniteCanvas.getRepresented(icDiveSlot.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const diveSlot    = rep_official;
            const incomingObj = rep_official_incoming;

            if (incomingObj != diveSlot) { //don't touch oneself

              if (!incomingObj.isTouchable) {
                //ignore: incomingObj is intangible
              } else if (!diveSlotConfig.isEnabled) {
                //ignore: diveSlot is intangible
              } else {
                this.r_official_update_handler(diveSlot, incomingObj, outerUpdatesDict);
              }

            } else {
              console.log("I won't touch myself");  //SHU: ...
            }

          };


          this.start = function () {
            console.log("engine::start, this", this);
            // logger.log("DiveSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icDiveSlot     = this.scopeObj.engineCarrier;


            infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);

            //for each existing canvas object, add touchState wrt this new diveSlot
            infiniteCanvas.onceOnAddRepresentedForIcObject(icDiveSlot, (icDiveSlot) => {

              const id_diveSlot = icDiveSlot.id;

              const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
              const arr_official_preexisiting = arr_official.filter(rep => (rep.id != id_diveSlot));
              arr_official_preexisiting.forEach((rep, i) => {

                rep.touchStateDict[id_diveSlot] = TouchState.Untouched;
                //SHU TODO: check if touches

              });

            });

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }



      class PortalEngine {
      // constructor(diveSlotConfig) {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptCrossing = function (icObj_slot, icObj_piece) {
            // logger.log("attemptCrossing", icObj_slot, icObj_piece);

            const canCross = this.checkCanCross(icObj_slot, icObj_piece);
            logger.log("logPortal", "canCross:", canCross);

            const rep_official = icObj_piece;
            // logger.log("attempting to cross with crossState: " + rep_official.crossStateDict[icObj_slot.id]);

            if (canCross) {
              this.hasAlreadyCrossed = true;
              setTimeout(() => {
                this.hasAlreadyCrossed = false;
              }, 500);

              // const rep_official = icObj_piece;
              // const represented  = icObj_piece.represented;
              // const rep_free     = represented.getRepresentation("free");

              // console.log("rep_free.isHeld", rep_free.isHeld);
              // if(rep_free.isHeld) {
              //   presnap(icObj_slot, icObj_piece);
              // } else {
              //   presnap(icObj_slot, icObj_piece);
              //   snap(icObj_slot, icObj_piece);
              // }

              this.cross(icObj_slot, icObj_piece);

            } else {
              console.log("can't cross");
            }

          };

          this.checkCanCross = function (icObj_slot, icObj_piece) {
            logger.log("logPortal", "checkCanCross", icObj_piece);
            var outBool;

            if(this.hasAlreadyCrossed) {
              return false;
            }

            var canCrossFunc = this.scopeObj.engineCarrier.portalConfig.canCrossFunc;
            if (canCrossFunc == null) {

              const portalCrossingSingleton = PortalCrossingSingleton.sharedInstance();
              canCrossFunc = portalCrossingSingleton.canCross.bind(portalCrossingSingleton);
            }

            const context = this.scopeObj.engineCarrier.portalConfig.context;


            const icPortal       = this.scopeObj.engineCarrier;
            const infiniteCanvas = this.scopeObj.infiniteCanvas;

            const rep_free__portal = infiniteCanvas.getRepresented(icPortal.id).r_free();

            const pov__current = icObj_piece;
            const rect__in     = rep_free__portal.parts["rect__in"];

            // outBool = canCrossFunc(icObj_piece, icObj_slot, context);
            outBool = canCrossFunc(pov__current, rect__in, context);

            return outBool;
          };

          this.cross = async function (icObj_slot, icObj_piece) {
            // console.log("PortalEngine", "cross", icObj_piece);

            const icPortal       = this.scopeObj.engineCarrier;
            const infiniteCanvas = this.scopeObj.infiniteCanvas;

            const rep_free__portal = infiniteCanvas.getRepresented(icPortal.id).r_free();
            
            const rep_free__rect1 = rep_free__portal.parts["rect__in"];
            // logger.log("LogPortal", "cross", "rep_free__rect1:", rep_free__rect1);

            const rep_free__rect2 = rep_free__portal.parts["rect__out"];
            // logger.log("LogPortal", "cross", "rep_free__rect2:", rep_free__rect2);


            // const pov__in = infiniteCanvas.getCurrentPov();
            const pov__in = icObj_piece;
            // logger.log("LogPortal", "cross", "pov__in:", pov__in);
            
            const pov__out = infiniteCanvas.getPov2WrtIcObj2_sameWayAsPov1WrtIcObj1(rep_free__rect2, pov__in, rep_free__rect1);
            // logger.log("LogPortal", "cross", "pov__out:", pov__out);

            // infiniteCanvas.offListeners();
        
            //horror: horrific workaround (ignore mouseWheel zooming event while setting new pov)
            infiniteCanvas.set_pov(pov__out, function cb() {
              infiniteCanvas.isPovBeing_setPovd__portal_crossing = true;
              setTimeout(() => {
                infiniteCanvas.isPovBeing_setPovd__portal_crossing = false;
              }, 20);
            });

            // infiniteCanvas.onListeners();
          };

          this.r_official_update_handler = function (icObj_slot, icObj_piece, outerUpdatesDict) {
            // logger.log("logPortal", "r_official_update_handler", icObj_piece);

              this.attemptCrossing(icObj_slot, icObj_piece);
          };


          this.start = function () {
            // logger.log("PortalEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icPortal       = this.scopeObj.engineCarrier;

            //listen to infiniteCanvas.scale
            infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
              // logger.log("logPortal", "infiniteCanvas.scale.X:", infiniteCanvas.scale.X);

              const pov__in = infiniteCanvas.getCurrentPov();

              this.r_official_update_handler(icPortal, pov__in, {
                scale: {
                  new: infiniteCanvas.scale,
                  old: null,
                },
              });

            });

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }
      }




      class CoreEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          // this.checkCanTouch = function(icObj_slot, icObj_piece) {
          //   // logger.log("checkCanTouch", icObj_piece);
          //   var outBool;

          //   // outBool = Touch.canTouch(icObj_piece, icObj_slot);

          //   var canTouchFunc = this.scopeObj.engineCarrier.coreConfig.canTouchFunc;
          //   if(canTouchFunc == null) {

          //     // canTouchFunc = Touch.canTouch;

          //     // const infiniteCanvas = this.scopeObj.infiniteCanvas;
          //     // canTouchFunc = infiniteCanvas.touch2.canTouch;

          //     canTouchFunc = Touch2Singleton.sharedInstance().canTouch;
          //   }

          //   const context = this.scopeObj.engineCarrier.coreConfig.context;

          //   outBool = canTouchFunc(icObj_piece, icObj_slot, context);

          //   return outBool;
          // };


          this.adsorb = function (icObj_piece) {
            console.log("adsorb", icObj_piece);
            // console.log("adsorb", "this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icCore = this.scopeObj.engineCarrier;

            // const rep_free__piece = infiniteCanvas.getRepresented(icObj_piece.id).r_free();
            const rep_free__core = infiniteCanvas.getRepresented(icCore.id).r_free();

            //add to ghost
            rep_free__core.parts.ghost.dict_engine["composite"].engine.awoken.addPart(icObj_piece);

          };

          this.desorb = function (icObj_piece) {
            console.log("desorb", icObj_piece);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icCore = this.scopeObj.engineCarrier;

            // const rep_free__piece = infiniteCanvas.getRepresented(icObj_piece.id).r_free();
            const rep_free__core = infiniteCanvas.getRepresented(icCore.id).r_free();

            //remove from ghost
            rep_free__core.parts.ghost.dict_engine["composite"].engine.awoken.removePart(icObj_piece);
          };

          this.start = function () {
            console.log("CoreEngine::start, this", this);

            // logger.log("touchSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icCore = this.scopeObj.engineCarrier;
            const icTouchSlot = icCore.parts.touchSlot;

            const rep_free__touchSlot = infiniteCanvas.getRepresented(icTouchSlot.id).r_free();


            // const touchSlotEngine = icTouchSlot.dict_engine["touchSlot"].engine;
            const touchSlotEngine = icTouchSlot.dict_engine["touchSlot"].engine.awoken;


            const touchSlotConfig = {
              transformationFunc: function (icObj) {
                logger.log("icCore.touchSlot", "transformationFunc");

                const coreEngine = icCore.dict_engine["core"].engine.awoken;
                coreEngine.adsorb(icObj);

                return new TransformationOutput("mutated", icObj, icObj);
              },
            };

            rep_free__touchSlot.touchSlotConfig = touchSlotConfig;

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }








      class SnapSlotEngine {
        // constructor(touchSlotConfig) {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptSnapping = function (icObj_slot, icObj_piece) {
            console.log("attemptSnapping", icObj_slot, icObj_piece);

            const canSnap = this.checkCanSnap(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            console.log("attempting to snap with snapState: " + rep_official.snapState);

            // const isValidPieceSnapState = (rep_official.snapState == SnapState.Unsnapped);
            //
            // if(isValidPieceSnapState) {
            //
            // } else {
            //   console.log("can't snap while snapState == " + rep_official.snapState)
            //   // throw new Error("attempting to snap with snapState: " + rep_official.snapState);
            //   return;
            // }

            if (canSnap) {
              console.log("can snap");

              const rep_official = icObj_piece;
              const represented = icObj_piece.represented;
              const rep_free = represented.getRepresentation("free");

              console.log("rep_free.isHeld", rep_free.isHeld);
              if (rep_free.isHeld) {
                this.presnap(icObj_slot, icObj_piece);
              } else {
                this.presnap(icObj_slot, icObj_piece);
                this.snap(icObj_slot, icObj_piece);
              }

            } else {
              console.log("can't snap");
            }

          };


          this.checkCanSnap = function (icObj_slot, icObj_piece) {
            console.log("checkCanSnap", icObj_piece);
            var outBool;

            const icSnapSlot = this.scopeObj.engineCarrier;
            const canSnapFunc = icSnapSlot.snapSlotConfig.canSnapFunc;

            outBool = canSnapFunc(icObj_piece, icObj_slot);

            return outBool;
          };

          var rep_free_onRelease__triggerSnap = null;
          var rep_free_afterPresnap__attemptUnsnapping = null;

          var rep_free_callbacks = {
            onRelease__triggerSnap: null,
            afterPresnap__attemptUnsnapping: null,
          };


          this.presnap = function (icObj_slot, icObj_piece) {
            console.log("presnap", icObj_piece);

            const rep_official = icObj_piece;
            const represented = icObj_piece.represented;
            const rep_free = represented.getRepresentation("free");
            const rep_snapped = represented.createNewRepresentation("snapped");

            rep_official.snapState = SnapState.Presnapped;
            // rep_official.snappedTo = icObj_slot;
            rep_official.snappedTo = icObj_slot.id;


            rep_official.unfollow(rep_free);


            rep_snapped.position = Object.assign({}, icObj_slot.position);
            rep_snapped.homeScale = Object.assign({}, icObj_slot.homeScale);
            rep_snapped.scale = Object.assign({}, icObj_slot.scale);
            rep_snapped.orientation = icObj_slot.orientation;

            rep_snapped.opacity = 0.8;


            //debug
            // rep_snapped.text = "rep_snapped__snapped";

            infiniteCanvas.addRepresentation(represented, rep_snapped);


            // rep_official.syncWith(rep_snapped);
            rep_official.syncWithObj({
              position: rep_snapped.position,
              size: rep_snapped.size,
              homeScale: rep_snapped.homeScale,
              scale: rep_snapped.scale,

              // didUpdateListeners : rep_snapped.didUpdateListeners,
              // holdListeners      : rep_snapped.holdListeners,
              // releaseListeners   : rep_snapped.releaseListeners,
            });
            rep_official.follow(rep_snapped);


            rep_free.opacity = 0.2;
            //debug
            // rep_free.opacity = 1.0;
            // rep_free.fill = "blue";
            // rep_free.text = "rep_free__presnapped";


            //add release listener
            // icObj_fRep.onHold((icObj) => {
            //
            // });

            //add release listener for rep_free
            rep_free_onRelease__triggerSnap = (rep_free) => {
              console.log("rep_free_onRelease__triggerSnap");

              this.snap(icObj_slot, icObj_piece);
            };
            rep_free.onRelease(rep_free_onRelease__triggerSnap);


            //add unsnap listener for rep_free
            rep_free_afterPresnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
              console.log("rep_free_afterPresnap__attemptUnsnapping", rep_free);

              this.attemptUnsnapping(icObj_slot, rep_free);
            };
            rep_free.onInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);

          };


          this.snap = function (icObj_slot, icObj_piece) {
            console.log("snap", icObj_piece);

            const rep_official = icObj_piece;
            const represented = icObj_piece.represented;
            const rep_free = represented.getRepresentation("free");
            const rep_snapped = represented.getRepresentation("snapped");

            console.log("**snap", "rep_free.isHeld", rep_free.isHeld);

            console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
            if (rep_free_afterPresnap__attemptUnsnapping != null) {
              rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
            }
            rep_free_afterPresnap__attemptUnsnapping = null;


            rep_free.offRelease(rep_free_onRelease__triggerSnap);
            rep_free_onRelease__triggerSnap = null;



            // rep_free.syncWith(rep_snapped);
            // rep_free.syncWith(rep_official);

            //SHU TODO: MYSTERE ET BOULE DE GOMME: il y a un truc avec syncWith qui casse rep_free ... ???

            rep_free.syncWithObj({
              position: rep_snapped.position,
              size: rep_snapped.size,
              homeScale: rep_snapped.homeScale,
              scale: rep_snapped.scale,

              // didUpdateListeners : rep_snapped.didUpdateListeners,
              // holdListeners      : rep_snapped.holdListeners,
              // releaseListeners   : rep_snapped.releaseListeners,
            });



            rep_free.opacity = 1.0;
            //debug
            // rep_free.opacity = 1.0;
            // rep_free.fill = "red";
            // rep_free.text = "rep_free__snapped";

            rep_official.unfollow(rep_snapped);
            rep_official.follow(rep_free);
            rep_official.snapState = SnapState.Snapped;
            // rep_official.snappedTo = icObj_slot;
            // rep_official.snappedTo = icObj_slot.id;



            console.log("remove rep_snapped", rep_snapped.id_rep);
            rep_snapped.im_dying_now = true;
            infiniteCanvas.removeRepresentation(represented, rep_snapped);
            represented.removeRepresentation(rep_snapped);

            //add unsnap listener for rep_free
            // rep_free_afterSnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
            //   console.log("rep_free_afterSnap__attemptUnsnapping", rep_free);
            //
            //   attemptUnsnapping(icObj_slot, rep_free);
            // };
            // rep_free.onInnerUpdate(rep_free_afterSnap__attemptUnsnapping);


            //debug
            // rep_free.onHold((rep_free) => {
            //   console.log("###rep_free.id_rep", rep_free.id_rep);
            //   console.log("###rep_free.onHold", "rep_free.isHeld", rep_free.isHeld);
            // });

          };





          this.attemptUnsnapping = function (icObj_slot, icObj_piece) {
            console.log("attemptUnsnapping", icObj_slot, icObj_piece);

            const canUnsnap = this.checkCanUnsnap(icObj_slot, icObj_piece);
            console.log("canUnsnap", canUnsnap);

            const rep_official = icObj_piece;
            console.log("attempting to unsnap with snapState: " + rep_official.snapState);

            // const isValidPieceSnapState = (rep_official.snapState == SnapState.Presnapped);
            //
            // if(isValidPieceSnapState) {
            //
            // } else {
            //   console.log("can't unsnap while snapState == " + rep_official.snapState)
            //   // throw new Error("attempting to unsnap with snapState: " + rep_official.snapState);
            //   return;
            // }

            if (canUnsnap) {
              // console.log("can unsnap");
              this.unsnap(icObj_slot, icObj_piece);     //presnap already sets up an unsnap listener

            } else {
              // console.log("can't unsnap");

              //SHU TODO: hasLeftSlot
              // const hasLeftSlot = Snap.hasLeftSlot()
              const hasLeftSlot = true;

              if (hasLeftSlot) {


                // const rep_official = icObj_piece;
                const represented = icObj_piece.represented;
                const rep_free = represented.getRepresentation("free");

                console.log("#rep_free.id_rep", rep_free.id_rep);
                console.log("#rep_free.isHeld", rep_free.isHeld);

                if (rep_free.isHeld) {
                  if (icObj_piece.snapState == SnapState.Snapped) {
                    this.presnap(icObj_slot, icObj_piece);
                  }
                } else {
                  //do nothing
                  // snap(icObj_slot, icObj_piece);
                }

              } else {
                //do nothing
                // snap(icObj_slot, icObj_piece);
              }



            }

          };

          this.checkCanUnsnap = function (icObj_slot, icObj_piece) {
            console.log("checkCanUnsnap", icObj_piece);
            var outBool;

            const icSnapSlot = this.scopeObj.engineCarrier;
            const canUnsnapFunc = icSnapSlot.snapSlotConfig.canUnsnapFunc;

            outBool = canUnsnapFunc(icObj_piece, icObj_slot);

            return outBool;
          };


          this.unsnap = function (icObj_slot, icObj_piece) {
            console.log("unsnap", icObj_piece);

            // const represented  = icObj_piece.represented;
            // const rep_official = represented.getRepresentation("official");
            // const rep_snapped  = represented.getRepresentation("snapped");

            const rep_unknown = icObj_piece; //SHU TODO: solve snapSlot's rep madness
            const represented = icObj_piece.represented;
            const rep_official = represented.getRepresentation("official");
            const rep_free = represented.getRepresentation("free");
            const rep_snapped = represented.getRepresentation("snapped");


            console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
            if (rep_free_afterPresnap__attemptUnsnapping != null) {
              rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
            }
            rep_free_afterPresnap__attemptUnsnapping = null;

            // if(rep_free_afterSnap__attemptUnsnapping != null) {
            //   rep_free.offInnerUpdate(rep_free_afterSnap__attemptUnsnapping);
            // }
            // rep_free_afterSnap__attemptUnsnapping = null;


            // rep_free.offRelease(rep_free_onRelease__triggerSnap);
            // rep_free_onRelease__triggerSnap = null;

            if (rep_free.offRelease != null) { //****************************************  SHU: il y a un problème ici, quand j'aurai trois neurones de disponibles, j'investiguerai
              rep_free.offRelease(rep_free_onRelease__triggerSnap);
              rep_free_onRelease__triggerSnap = null;
            }                                 //****************************************


            rep_official.syncWith(rep_free);
            rep_official.follow(rep_free);


            if (rep_snapped != null) {
              console.log("remove rep_snapped", rep_snapped.id_rep);
              rep_snapped.im_dying_now = true;
              infiniteCanvas.removeRepresentation(represented, rep_snapped);
              represented.removeRepresentation(rep_snapped);
            } else {
              console.log("rep_snapped already destroyed somewhere else");
            }


            // rep_free.im_dying_now = true; //SHU: this is interesting

            /*
            rep_free.opacity = 1.0;
              //debug
              // rep_free.fill = "lime";
              // rep_free.text = "rep_free__unsnapped";
              // setTimeout(() => {
              //   rep_free.fill = "lime";
              //   rep_free.text = "rep_free__unsnapped";
              // }, 0);
            */

            setTimeout(() => {                  //SHU: looks like setTimeout is needed here
              rep_free.opacity = 1.0;

              rep_official.snapState = SnapState.Unsnapped;
              // rep_official.snappedTo = null;
              rep_official.snappedTo = -1;
            }, 0);

          };






          this.r_official_update_handler = function (icObj_slot, icObj_piece, outerUpdatesDict) {
            console.log("r_official_update_handler", icObj_piece);

            console.log("icObj_piece.snapState", icObj_piece.snapState);

            // if(outerUpdatesDict["snapState"] == SnapState.Snapped) {
            //   //official just changed snapState to .Snapped
            //   //ignore
            //   return;
            // }

            if (icObj_piece.snapState == SnapState.Unsnapped) {
              this.attemptSnapping(icObj_slot, icObj_piece);
            } else if (icObj_piece.snapState == SnapState.Snapped) {
              this.attemptUnsnapping(icObj_slot, icObj_piece);               //SHU666666 : this is the key line to understand what is wrong
            } else if (icObj_piece.snapState == SnapState.Presnapped) {

            }

          };

          this.r_official_update_handler2 = function (rep_official_incoming, outerUpdatesDict) {
            // console.log("r_official_update_handler2", rep_official_incoming);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icSnapSlot = this.scopeObj.engineCarrier;

            const represented = infiniteCanvas.getRepresented(icSnapSlot.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const snapSlot = rep_official;
            const incomingObj = rep_official_incoming;

            if (incomingObj != snapSlot) { //don't snap oneself

              if (!incomingObj.isSnappable) {
                //ignore: incomingObj is diamagnetic
              } else {
                console.log("++++incomingObj.snappedTo", incomingObj.snappedTo);
                // if(incomingObj.snappedTo != null && incomingObj.snappedTo != snapSlot) {
                if (incomingObj.snappedTo != -1 && incomingObj.snappedTo != snapSlot.id) {
                  //ignore: incomingObj is already snapped to another slot
                } else {
                  this.r_official_update_handler(snapSlot, incomingObj, outerUpdatesDict);
                }
              }

            } else {
              console.log("I won't snap myself");
            }

          };




          this.start = function () {
            console.log("engine::start, this", this);
            console.log("snapSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icSnapSlot = this.scopeObj.engineCarrier;

            infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);
          };

          this.stop = function () {
            //SHU TODO: infiniteCanvas.offIcObjUpdate when snap slot is destroyed
          };



          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }


      class CompositeEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            // logger.log("logCP", "CompositeEngine", "this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          };


          this.createHandleListener = function () {
            const handle__listener = (representation, propName, oldValue, newValue) => {
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.manageHandleUpdate(representation, updatesDict);
            };

            return handle__listener;
          };

          this.createContentListener = function () {
            const content__listener = (representation, propName, oldValue, newValue) => {
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.manageContentUpdate(representation, updatesDict);
            };

            return content__listener;
          };

          // this.counter__partListeners = 0;
          this.createPartListener = function () {

            // const index__partListener = this.counter__partListeners;

            const part__listener = (representation, propName, oldValue, newValue) => {
              // logger.log("partListener", index__partListener);
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.managePartUpdate(representation, updatesDict);
            };

            // this.counter__partListeners += 1;

            return part__listener;
          };



          this.createListeners = function () {
            var outListenersDict = {};

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;


            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();


            const handle__listener = this.createHandleListener();
            // outListenersDict["handle"] = handle__listener;
            outListenersDict[handle.id] = handle__listener;

            const content__rep_free = handle__rep_free.content;
            if(content__rep_free != null) {
              const content__listener = this.createContentListener();
              // outListenersDict["content"] = content__listener;
              outListenersDict[content__rep_free.id] = content__listener;
            }

            const parts = handle__rep_free.parts;
            const part_listeners = Object.entries(parts).reduce((acc, [partName, part__rep_free]) => {

              const part__listener = this.createPartListener();

              // acc[partName] = part__listener;
              acc[part__rep_free.id] = part__listener;

              return acc;
            }, {});

            Object.assign(outListenersDict, part_listeners);

            return outListenersDict;
          };




          this.getArr_everyone = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;


            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            const content = handle__rep_free.content;
            const parts   = handle__rep_free.parts;

            return [handle__rep_free, content] + Object.values(parts);
          };

          this.getArr_everyoneBut = function (rep) {
            const arr_everyoneElse = this.getArr_everyone().filter(rep => rep.id != solo_rep.id);
            return arr_everyoneElse;
          };

          this.onEveryoneBut = function (solo_rep) {
            const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = this.listeners[rep.id];
              rep.onInnerUpdate(listener);
            });
          };

          this.offEveryoneBut = function (rep) {
            const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = this.listeners[rep.id];
              rep.offInnerUpdate(listener);
            });
          };


          //part update
          this.managePartUpdate = function (icObj_compositePart, outerUpdatesDict) {

            [...Object.keys(outerUpdatesDict)].forEach((key__update) => {
              switch(key__update) {
                case "position":
                  this.managePartUpdate__position(icObj_compositePart, outerUpdatesDict);
                  break;
                case "homeScale":
                  this.managePartUpdate__homeScale(icObj_compositePart, outerUpdatesDict);
                  break;
                default:
                  break;
              }
            });

          };

          this.managePartUpdate__position = function (icObj_compositePart, outerUpdatesDict) {
            logger.log("logComposite", "managePartUpdate__position", icObj_compositePart);

            //SHU FLUID

            logger.log("managePartUpdate__position", icObj_compositePart);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            const compositeConfig = handle.compositeConfig;
            console.log("compositeConfig", compositeConfig);
            const id__compositePart = icObj_compositePart.id;
            logger.log("logComposite", "id__compositePart", id__compositePart);

            const isMobile    = compositeConfig[id__compositePart].isMobile;
            const isAlterable = compositeConfig[id__compositePart].isAlterable;

            if (isMobile) {
              //ignore
            } else {

              logger.log("logComposite", "managePartUpdate__position", ".isAltering:", infiniteCanvas.isAltering);

              if(infiniteCanvas.isDeepAltering) {
                //only move selected part: do nothing with other parts
              } 
              else if(infiniteCanvas.isAltering) {

                if(isAlterable) {
                  //only bulkMove closest composite of selected part (SHU: bulkMove "most meaningful" closest composite would be a better achievement)

                } else {
                  logger.log("logPlatform", ".isAlterable:false");


                  //find closest alterable composite

                  const closestAlterableComposite__rep_free = infiniteCanvas.getParentCompositeForContentOrPart(icObj_compositePart, "free");
                  logger.log("logComposite", "managePartUpdate__position", "isAltering", "closestAlterableComposite__rep_free:", closestAlterableComposite__rep_free);
                  
                  // closestAlterableComposite__rep_free.dict_engine["composite"].engine.awoken.manageHandleUpdate__position__bulkMove(icObj_compositePart, outerUpdatesDict);
                  
                  const listener = this.listeners[closestAlterableComposite__rep_free.id];

                  const isRootObject = closestAlterableComposite__rep_free.isRootObject(infiniteCanvas);

                  if(!isRootObject) {
                    //listen:off
                    closestAlterableComposite__rep_free.offInnerUpdate(listener);
                  }
                  
                  closestAlterableComposite__rep_free.dict_engine["composite"].engine.awoken.managePartUpdate__position__bulkMove(icObj_compositePart, outerUpdatesDict);
                  
                  if(!isRootObject) {
                    //listen:on
                    closestAlterableComposite__rep_free.onInnerUpdate(listener);
                  }

                }

              }
              else {
                //bulkMove everything accordingly
                this.managePartUpdate__position__bulkMove(icObj_compositePart, outerUpdatesDict);

              }

            }
          
          };



          this.managePartUpdate__position__bulkMove = function (icObj_compositePart, outerUpdatesDict) {
            logger.log("logComposite", "managePartUpdate__position__bulkMove", icObj_compositePart);

            //SHU FLUID

            logger.log("managePartUpdate__position__bulkMove", icObj_compositePart);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            const compositeConfig = handle.compositeConfig;
            console.log("compositeConfig", compositeConfig);
            const id__compositePart = icObj_compositePart.id;
            logger.log("logComposite", "id__compositePart", id__compositePart);

            const isMobile = compositeConfig[id__compositePart].isMobile;

            if (isMobile) {
              //ignore
            } else {

              //move everything accordingly

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free = handle__represented.r_free();

              if ((outerUpdatesDict.position != null) || (outerUpdatesDict.point_start != null)) {

                var offset;
                if (outerUpdatesDict.position != null) {
                  offset = {
                    dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                    dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
                  };
                } else {
                  //moved part was segment
                  offset = {
                    dx: outerUpdatesDict.point_start.new.x - outerUpdatesDict.point_start.old.x,
                    dy: outerUpdatesDict.point_start.new.y - outerUpdatesDict.point_start.old.y,
                  };
                }

                const content = handle__rep_free.content;
                const parts   = handle__rep_free.parts;

                const arr_parts_all             = Object.values(parts);
                const arr_content_and_parts_all = [content, ...arr_parts_all].filter(icObj => (icObj != null));

                const arr_parts_other = arr_content_and_parts_all.filter(part => part.id != icObj_compositePart.id);

                const arr_handle_and_other = [handle__rep_free, ...arr_parts_other];

                // arr_parts_other.forEach((rep_free, i) => {
                arr_handle_and_other.forEach((rep_free, i) => {

                  const listener = this.listeners[rep_free.id];
                  // console.log("°°°listener", listener);

                  //listen:off
                  rep_free.offInnerUpdate(listener);

                  //mutate
                  // logger.log("mutating part:", rep_free.id);
                  {
                    if (rep_free.position != null) {
                      const position_new = {
                        x: rep_free.position.x + offset.dx,
                        y: rep_free.position.y + offset.dy,
                      };

                      rep_free.position = position_new;
                    } else if (rep_free.point_start != null) {
                      //move other segment parts
                      const point_start_new = {
                        x: rep_free.point_start.x + offset.dx,
                        y: rep_free.point_start.y + offset.dy,
                      };
                      rep_free.point_start = point_start_new;
                      const point_end_new = {
                        x: rep_free.point_end.x + offset.dx,
                        y: rep_free.point_end.y + offset.dy,
                      };
                      rep_free.point_end = point_end_new;
                    }
                  }

                  //listen:on
                  rep_free.onInnerUpdate(listener);

                });

              }

           }
          
          };


          // this.managePartUpdate__homeScale = function (icObj_compositePart, outerUpdatesDict) {}

          this.managePartUpdate__homeScale = function (icObj_compositePart, outerUpdatesDict) {

            logger.log("logComposite", "managePartUpdate__homeScale", icObj_compositePart);

            //SHU FLUID

            logger.log("managePartUpdate__homeScale", icObj_compositePart);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            const compositeConfig = handle.compositeConfig;
            console.log("compositeConfig", compositeConfig);
            const id__compositePart = icObj_compositePart.id;
            logger.log("logComposite", "id__compositePart", id__compositePart);

            const isMobile    = compositeConfig[id__compositePart].isMobile;
            const isAlterable = compositeConfig[id__compositePart].isAlterable;

            if (isMobile) {
              //ignore
            } else {

              logger.log("logComposite", "managePartUpdate__homeScale", ".isAltering:", infiniteCanvas.isAltering);

              if(infiniteCanvas.isDeepAltering) {
                //only move selected part: do nothing with other parts
              } 
              else if(infiniteCanvas.isAltering) {

                if(isAlterable) {
                  //only bulkMove closest composite of selected part (SHU: bulkMove "most meaningful" closest composite would be a better achievement)

                } else {
                  logger.log("logPlatform", ".isAlterable:false");


                  //find closest alterable composite

                  const closestAlterableComposite__rep_free = infiniteCanvas.getParentCompositeForContentOrPart(icObj_compositePart, "free");
                  logger.log("logComposite", "managePartUpdate__homeScale", "isAltering", "closestAlterableComposite__rep_free:", closestAlterableComposite__rep_free);
                  
                  // closestAlterableComposite__rep_free.dict_engine["composite"].engine.awoken.manageHandleUpdate__position__bulkMove(icObj_compositePart, outerUpdatesDict);
                  
                  const listener = this.listeners[closestAlterableComposite__rep_free.id];

                  const isRootObject = closestAlterableComposite__rep_free.isRootObject(infiniteCanvas);

                  if(!isRootObject) {
                    //listen:off
                    closestAlterableComposite__rep_free.offInnerUpdate(listener);
                  }
                  
                  closestAlterableComposite__rep_free.dict_engine["composite"].engine.awoken.managePartUpdate__homeScale__bulkRescale(icObj_compositePart, outerUpdatesDict);
                  
                  if(!isRootObject) {
                    //listen:on
                    closestAlterableComposite__rep_free.onInnerUpdate(listener);
                  }

                }

              }
              else {
                //bulkMove everything accordingly
                this.manageHandleUpdate__homeScale(icObj_compositePart, outerUpdatesDict);

              }

            }

          };

          
          this.managePartUpdate__homeScale__bulkRescale = function (icObj_compositePart, outerUpdatesDict) {
            logger.log("logCompZscroll", "managePartUpdate__homeScale__bulkRescale", icObj_compositePart, outerUpdatesDict);

            //get free_rep
            const icObj_handle        = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(icObj_handle.id);
            const handle__rep_free    = handle__represented.r_free();

            if (outerUpdatesDict.homeScale != null) {

              const scaleFactor = {
                X: outerUpdatesDict.homeScale.new.X / outerUpdatesDict.homeScale.old.X,
                Y: outerUpdatesDict.homeScale.new.Y / outerUpdatesDict.homeScale.old.Y,
              };
              logger.log("logCompZscroll", "scaleFactor", scaleFactor);

              if(scaleFactor.X == 1 && scaleFactor.Y == 1) {  //SHU: bwerk
                //ignore
                return;
              }

              const content = handle__rep_free.content;
              const parts   = handle__rep_free.parts;

              const arr_parts_all             = Object.values(parts);
              const arr_content_and_parts_all = [content, ...arr_parts_all].filter(icObj => (icObj != null));

              const arr_parts_other = arr_content_and_parts_all.filter(part => part.id != icObj_compositePart.id);

              const arr_handle_and_other = [handle__rep_free, ...arr_parts_other];

              arr_handle_and_other.forEach((part__rep_free, i) => {

                const listener = this.listeners[part__rep_free.id];

                //listen:off
                // if(typeof part__rep_free.offInnerUpdate === "function") { //SHU HORROR
                part__rep_free.offInnerUpdate(listener);
                // }



                //mutate
                // logger.log("mutating part:", part__rep_free.id);
                // if(part__rep_free.type != "composite")
                {

                  //homeScale
                  const homeScale__new__part = {
                    X: part__rep_free.homeScale.X * scaleFactor.X,
                    Y: part__rep_free.homeScale.Y * scaleFactor.Y,
                  };
                  logger.log("logCompZscroll", "homeScale__old__part", part__rep_free.homeScale);
                  logger.log("logCompZscroll", "homeScale__new__part", homeScale__new__part);
                  part__rep_free.homeScale = homeScale__new__part;


                  //other (induced)
                    //position
                  const offset_wrt_handle__old = {
                    dx: part__rep_free.position.x - handle__rep_free.position.x,
                    dy: part__rep_free.position.y - handle__rep_free.position.y,
                  };
                  logger.log("logCompZscroll", "offset_wrt_handle__old", offset_wrt_handle__old);

                  const offset_wrt_handle__new = {
                    dx: offset_wrt_handle__old.dx / scaleFactor.X,
                    dy: offset_wrt_handle__old.dy / scaleFactor.Y,
                  };
                  logger.log("logCompZscroll", "offset_wrt_handle__new", offset_wrt_handle__new);


                  if (part__rep_free.position != null) {
                    const position_new = {
                      x: part__rep_free.position.x - offset_wrt_handle__old.dx + offset_wrt_handle__new.dx,
                      y: part__rep_free.position.y - offset_wrt_handle__old.dy + offset_wrt_handle__new.dy,
                    };
                    logger.log("logCompZscroll", "position_new", position_new);

                    part__rep_free.position = position_new;

                  } else if (part__rep_free.point_start != null) {
                    //move segment parts
                    const point_start_new = {
                      x: part__rep_free.point_start.x + offset_wrt_handle__new.dx,
                      y: part__rep_free.point_start.y + offset_wrt_handle__new.dy,
                    };
                    part__rep_free.point_start = point_start_new;

                    const v__old = {
                      dx: part__rep_free.point_end.x - part__rep_free.point_start.x,
                      dy: part__rep_free.point_end.y - part__rep_free.point_start.y,
                    };
                    const v__new = {
                      dx: v__old.dx / scaleFactor.X,
                      dy: v__old.dy / scaleFactor.Y,
                    };

                    const point_end_new = {
                      x: part__rep_free.point_end.x + v__new.dx,
                      y: part__rep_free.point_end.y + v__new.dy,
                    };
                    part__rep_free.point_end = point_end_new;
                  }
                } 
                // else {
                //   //bulkMove everything accordingly
                //   const engine__part_which_is_handle = part__rep_free.dict_engine["composite"].engine.awoken;
                //   engine__part_which_is_handle.manageHandleUpdate__homeScale(part__rep_free, outerUpdatesDict);
                // }

                //listen:on
                // if(typeof part__rep_free.onInnerUpdate === "function") { //SHU HORROR
                part__rep_free.onInnerUpdate(listener);
                // }

              });

            }

          };

          //content update
          this.manageContentUpdate = function (icObj_compositeContent, outerUpdatesDict) {

            [...Object.keys(outerUpdatesDict)].forEach((key__update) => {
              switch(key__update) {
                case "position":
                  this.managePartUpdate__position(icObj_compositeContent, outerUpdatesDict);
                  break;
                case "homeScale":
                  this.managePartUpdate__homeScale(icObj_compositeContent, outerUpdatesDict);
                  break;
                default:
                  break;
              }
            });

          };

          // this.manageContentUpdate__position = function (icObj_compositePart, outerUpdatesDict) {

          //   //SHU FLUID

          //   logger.log("managePartUpdate__position", icObj_compositePart);

          //   const infiniteCanvas = this.scopeObj.infiniteCanvas;
          //   const handle = this.scopeObj.engineCarrier;

          //   const compositeConfig = handle.compositeConfig;
          //   console.log("compositeConfig", compositeConfig);
          //   const id__compositePart = icObj_compositePart.id;
          //   console.log("id__compositePart", id__compositePart);

          //   const isMobile = compositeConfig[id__compositePart].isMobile;

          //   if (isMobile) {
          //     //ignore
          //   } else {

          //     if(infiniteCanvas.isAltering) {
          //       //only move selected part: do nothing with other parts
          //     } else {
          //       //move everything accordingly

          //       //get free_rep
          //       const handle__represented = infiniteCanvas.getRepresented(handle.id);
          //       const handle__rep_free = handle__represented.r_free();

          //       // const part__represented   = infiniteCanvas.getRepresented(icObj_compositePart.id);

          //       // rep_free__composite.composite.managePartUpdate(rep_free__compositePart, outerUpdatesDict);
          //       if ((outerUpdatesDict.position != null) || (outerUpdatesDict.point_start != null)) {

          //         var offset;
          //         if (outerUpdatesDict.position != null) {
          //           offset = {
          //             dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
          //             dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
          //           };
          //         } else {
          //           //moved part was segment
          //           offset = {
          //             dx: outerUpdatesDict.point_start.new.x - outerUpdatesDict.point_start.old.x,
          //             dy: outerUpdatesDict.point_start.new.y - outerUpdatesDict.point_start.old.y,
          //           };
          //         }

          //         const parts = handle__rep_free.parts;

          //         const arr_parts_all = Object.values(parts);
          //         const arr_parts_other = arr_parts_all.filter(part => part.id != icObj_compositePart.id);

          //         const arr_handle_and_other = [handle__rep_free, ...arr_parts_other];

          //         // arr_parts_other.forEach((rep_free, i) => {
          //         arr_handle_and_other.forEach((rep_free, i) => {

          //           const listener = this.listeners[rep_free.id];
          //           // console.log("°°°listener", listener);

          //           //listen:off
          //           rep_free.offInnerUpdate(listener);

          //           //mutate
          //           // logger.log("mutating part:", rep_free.id);
          //           {
          //             if (rep_free.position != null) {
          //               const position_new = {
          //                 x: rep_free.position.x + offset.dx,
          //                 y: rep_free.position.y + offset.dy,
          //               };

          //               rep_free.position = position_new;
          //             } else if (rep_free.point_start != null) {
          //               //move other segment parts
          //               const point_start_new = {
          //                 x: rep_free.point_start.x + offset.dx,
          //                 y: rep_free.point_start.y + offset.dy,
          //               };
          //               rep_free.point_start = point_start_new;
          //               const point_end_new = {
          //                 x: rep_free.point_end.x + offset.dx,
          //                 y: rep_free.point_end.y + offset.dy,
          //               };
          //               rep_free.point_end = point_end_new;
          //             }
          //           }

          //           //listen:on
          //           rep_free.onInnerUpdate(listener);

          //         });

          //       }

          //     }

          //   }

          // };


          // this.manageContentUpdate__homeScale = function (icObj_compositePart, outerUpdatesDict) {

          // };



          //handle update
          this.manageHandleUpdate = function (icObj_composite, outerUpdatesDict) {

            [...Object.keys(outerUpdatesDict)].forEach((key__update) => {
              switch(key__update) {
                case "position":
                  this.manageHandleUpdate__position(icObj_composite, outerUpdatesDict);
                  break;
                case "homeScale":
                  this.manageHandleUpdate__homeScale(icObj_composite, outerUpdatesDict);
                  break;
                default:
                  break;
              }
            });

          };

          this.manageHandleUpdate__position = function (icObj_composite, outerUpdatesDict) {
            logger.log("logComposite", "manageHandleUpdate__position", icObj_composite);

            if(infiniteCanvas.isDeepAltering) {
                //only move selected handle: do nothing with parts
            } 
            // else if(infiniteCanvas.isAltering) {}
            else {

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(icObj_composite.id);
              const handle__rep_free = handle__represented.r_free();

              if (outerUpdatesDict.position != null) {

                const offset = {
                  dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                  dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
                };

                const content = handle__rep_free.content;
                const parts   = handle__rep_free.parts;

                const arr_parts_all             = Object.values(parts);
                const arr_content_and_parts_all = [content, ...arr_parts_all].filter(icObj => (icObj != null));

                arr_content_and_parts_all.forEach((part__rep_free, i) => {

                  const listener = this.listeners[part__rep_free.id];

                  //listen:off
                  // if(typeof part__rep_free.offInnerUpdate === "function") { //SHU HORROR
                  part__rep_free.offInnerUpdate(listener);
                  // }



                  //mutate
                  // logger.log("mutating part:", part__rep_free.id);
                  {
                    if (part__rep_free.position != null) {
                      const position_new = {
                        x: part__rep_free.position.x + offset.dx,
                        y: part__rep_free.position.y + offset.dy,
                      };

                      part__rep_free.position = position_new;
                    } else if (part__rep_free.point_start != null) {
                      //move segment parts
                      const point_start_new = {
                        x: part__rep_free.point_start.x + offset.dx,
                        y: part__rep_free.point_start.y + offset.dy,
                      };
                      part__rep_free.point_start = point_start_new;
                      const point_end_new = {
                        x: part__rep_free.point_end.x + offset.dx,
                        y: part__rep_free.point_end.y + offset.dy,
                      };
                      part__rep_free.point_end = point_end_new;
                    }
                  }

                  //listen:on
                  // if(typeof part__rep_free.onInnerUpdate === "function") { //SHU HORROR
                  part__rep_free.onInnerUpdate(listener);
                  // }

                });

              }
              // else if(outerUpdatesDict.parts != null) {
              //   logger.log("outerUpdatesDict.parts", outerUpdatesDict.parts);
              //
              //   // const arr_parts__old = [];
              //   // const arr_parts__new = [];
              //
              //   Object.values(outerUpdatesDict.parts.new).forEach((part__rep_free, i) => {
              //     const part__listener = this.createPartListener();
              //     this.listeners[part__rep_free.id] = part__listener;
              //
              //     if(handle__rep_free.compositeConfig[part__rep_free.id] == null) {
              //       const config__part = {
              //         // isMobile: true,
              //         isMobile: false,
              //       };
              //       handle__rep_free.compositeConfig[part__rep_free.id] = config__part;
              //     }
              //
              //     //'activate' listener
              //     // const part__listener = this.listeners[part__rep_free.id];
              //     part__rep_free.onInnerUpdate(part__listener);
              //
              //   });
              //
              // }

            }

          };


          // this.manageHandleUpdate__position__bulkMove = function (icObj_composite, outerUpdatesDict) {
          //   logger.log("logComposite", "manageHandleUpdate__position", icObj_composite);

          //   if(infiniteCanvas.isDeepAltering) {
          //       //only move selected handle: do nothing with parts
          //   } 
          //   // else if(infiniteCanvas.isAltering) {}
          //   else {

          //     //get free_rep
          //     const handle__represented = infiniteCanvas.getRepresented(icObj_composite.id);
          //     const handle__rep_free = handle__represented.r_free();

          //     if (outerUpdatesDict.position != null) {

          //       const offset = {
          //         dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
          //         dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
          //       };

          //       const content = handle__rep_free.content;
          //       const parts   = handle__rep_free.parts;

          //       const arr_parts_all             = Object.values(parts);
          //       const arr_content_and_parts_all = [content, ...arr_parts_all].filter(icObj => (icObj != null));

          //       arr_content_and_parts_all.forEach((part__rep_free, i) => {

          //         const listener = this.listeners[part__rep_free.id];

          //         //listen:off
          //         // if(typeof part__rep_free.offInnerUpdate === "function") { //SHU HORROR
          //         part__rep_free.offInnerUpdate(listener);
          //         // }



          //         //mutate
          //         // logger.log("mutating part:", part__rep_free.id);
          //         {
          //           if (part__rep_free.position != null) {
          //             const position_new = {
          //               x: part__rep_free.position.x + offset.dx,
          //               y: part__rep_free.position.y + offset.dy,
          //             };

          //             part__rep_free.position = position_new;
          //           } else if (part__rep_free.point_start != null) {
          //             //move segment parts
          //             const point_start_new = {
          //               x: part__rep_free.point_start.x + offset.dx,
          //               y: part__rep_free.point_start.y + offset.dy,
          //             };
          //             part__rep_free.point_start = point_start_new;
          //             const point_end_new = {
          //               x: part__rep_free.point_end.x + offset.dx,
          //               y: part__rep_free.point_end.y + offset.dy,
          //             };
          //             part__rep_free.point_end = point_end_new;
          //           }
          //         }

          //         //listen:on
          //         // if(typeof part__rep_free.onInnerUpdate === "function") { //SHU HORROR
          //         part__rep_free.onInnerUpdate(listener);
          //         // }

          //       });

          //     }
          //     // else if(outerUpdatesDict.parts != null) {
          //     //   logger.log("outerUpdatesDict.parts", outerUpdatesDict.parts);
          //     //
          //     //   // const arr_parts__old = [];
          //     //   // const arr_parts__new = [];
          //     //
          //     //   Object.values(outerUpdatesDict.parts.new).forEach((part__rep_free, i) => {
          //     //     const part__listener = this.createPartListener();
          //     //     this.listeners[part__rep_free.id] = part__listener;
          //     //
          //     //     if(handle__rep_free.compositeConfig[part__rep_free.id] == null) {
          //     //       const config__part = {
          //     //         // isMobile: true,
          //     //         isMobile: false,
          //     //       };
          //     //       handle__rep_free.compositeConfig[part__rep_free.id] = config__part;
          //     //     }
          //     //
          //     //     //'activate' listener
          //     //     // const part__listener = this.listeners[part__rep_free.id];
          //     //     part__rep_free.onInnerUpdate(part__listener);
          //     //
          //     //   });
          //     //
          //     // }

          //   }

          // };


          this.manageHandleUpdate__homeScale = function (icObj_composite, outerUpdatesDict) {
            logger.log("logCompZscroll", "manageHandleUpdate__homeScale", icObj_composite, outerUpdatesDict);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(icObj_composite.id);
            const handle__rep_free    = handle__represented.r_free();

            if(infiniteCanvas.isDeepAltering) {
                //only move selected handle: do nothing with parts
            } else if(infiniteCanvas.isAltering) {
              //only move closest parent of selected handle
            } else {

              if (outerUpdatesDict.homeScale != null) {

                const scaleFactor = {
                  X: outerUpdatesDict.homeScale.new.X / outerUpdatesDict.homeScale.old.X,
                  Y: outerUpdatesDict.homeScale.new.Y / outerUpdatesDict.homeScale.old.Y,
                };
                logger.log("logCompZscroll", "scaleFactor", scaleFactor);

                if(scaleFactor.X == 1 && scaleFactor.Y == 1) {  //SHU: bwerk
                  //ignore
                  return;
                }

                const content = handle__rep_free.content;
                const parts   = handle__rep_free.parts;

                const arr_parts_all             = Object.values(parts);
                const arr_content_and_parts_all = [content, ...arr_parts_all].filter(icObj => (icObj != null));

                arr_content_and_parts_all.forEach((part__rep_free, i) => {

                  const listener = this.listeners[part__rep_free.id];

                  //listen:off
                  // if(typeof part__rep_free.offInnerUpdate === "function") { //SHU HORROR
                  part__rep_free.offInnerUpdate(listener);
                  // }



                  //mutate
                  // logger.log("mutating part:", part__rep_free.id);
                  {

                    //homeScale
                    const homeScale__new__part = {
                      X: part__rep_free.homeScale.X * scaleFactor.X,
                      Y: part__rep_free.homeScale.Y * scaleFactor.Y,
                    };
                    logger.log("logCompZscroll", "homeScale__old__part", part__rep_free.homeScale);
                    logger.log("logCompZscroll", "homeScale__new__part", homeScale__new__part);
                    part__rep_free.homeScale = homeScale__new__part;


                    //other (induced)
                      //position
                    const offset_wrt_handle__old = {
                      dx: part__rep_free.position.x - handle__rep_free.position.x,
                      dy: part__rep_free.position.y - handle__rep_free.position.y,
                    };
                    logger.log("logCompZscroll", "offset_wrt_handle__old", offset_wrt_handle__old);

                    const offset_wrt_handle__new = {
                      dx: offset_wrt_handle__old.dx / scaleFactor.X,
                      dy: offset_wrt_handle__old.dy / scaleFactor.Y,
                    };
                    logger.log("logCompZscroll", "offset_wrt_handle__new", offset_wrt_handle__new);


                    if (part__rep_free.position != null) {
                      const position_new = {
                        x: part__rep_free.position.x - offset_wrt_handle__old.dx + offset_wrt_handle__new.dx,
                        y: part__rep_free.position.y - offset_wrt_handle__old.dy + offset_wrt_handle__new.dy,
                      };
                      logger.log("logCompZscroll", "position_new", position_new);

                      part__rep_free.position = position_new;

                    } else if (part__rep_free.point_start != null) {
                      //move segment parts
                      const point_start_new = {
                        x: part__rep_free.point_start.x + offset_wrt_handle__new.dx,
                        y: part__rep_free.point_start.y + offset_wrt_handle__new.dy,
                      };
                      part__rep_free.point_start = point_start_new;

                      const v__old = {
                        dx: part__rep_free.point_end.x - part__rep_free.point_start.x,
                        dy: part__rep_free.point_end.y - part__rep_free.point_start.y,
                      };
                      const v__new = {
                        dx: v__old.dx / scaleFactor.X,
                        dy: v__old.dy / scaleFactor.Y,
                      };

                      const point_end_new = {
                        x: part__rep_free.point_end.x + v__new.dx,
                        y: part__rep_free.point_end.y + v__new.dy,
                      };
                      part__rep_free.point_end = point_end_new;
                    }
                  }

                  //listen:on
                  // if(typeof part__rep_free.onInnerUpdate === "function") { //SHU HORROR
                  part__rep_free.onInnerUpdate(listener);
                  // }

                });

              }
              // else if(outerUpdatesDict.parts != null) {
              //   logger.log("outerUpdatesDict.parts", outerUpdatesDict.parts);
              //
              //   // const arr_parts__old = [];
              //   // const arr_parts__new = [];
              //
              //   Object.values(outerUpdatesDict.parts.new).forEach((part__rep_free, i) => {
              //     const part__listener = this.createPartListener();
              //     this.listeners[part__rep_free.id] = part__listener;
              //
              //     if(handle__rep_free.compositeConfig[part__rep_free.id] == null) {
              //       const config__part = {
              //         // isMobile: true,
              //         isMobile: false,
              //       };
              //       handle__rep_free.compositeConfig[part__rep_free.id] = config__part;
              //     }
              //
              //     //'activate' listener
              //     // const part__listener = this.listeners[part__rep_free.id];
              //     part__rep_free.onInnerUpdate(part__listener);
              //
              //   });
              //
              // }

            }

          };


          this.manageHandleUpdate__homeScale__bulkRescale = function (icObj_composite, outerUpdatesDict) {
            logger.log("logCompZscroll", "manageHandleUpdate__homeScale__bulkRescale", icObj_composite, outerUpdatesDict);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(icObj_composite.id);
            const handle__rep_free    = handle__represented.r_free();

            if (outerUpdatesDict.homeScale != null) {

              const scaleFactor = {
                X: outerUpdatesDict.homeScale.new.X / outerUpdatesDict.homeScale.old.X,
                Y: outerUpdatesDict.homeScale.new.Y / outerUpdatesDict.homeScale.old.Y,
              };
              logger.log("logCompZscroll", "scaleFactor", scaleFactor);

              if(scaleFactor.X == 1 && scaleFactor.Y == 1) {  //SHU: bwerk
                //ignore
                return;
              }

              const content = handle__rep_free.content;
              const parts   = handle__rep_free.parts;

              const arr_parts_all             = Object.values(parts);
              const arr_content_and_parts_all = [content, ...arr_parts_all].filter(icObj => (icObj != null));

              arr_content_and_parts_all.forEach((part__rep_free, i) => {

                const listener = this.listeners[part__rep_free.id];

                //listen:off
                // if(typeof part__rep_free.offInnerUpdate === "function") { //SHU HORROR
                part__rep_free.offInnerUpdate(listener);
                // }



                //mutate
                // logger.log("mutating part:", part__rep_free.id);
                {

                  //homeScale
                  const homeScale__new__part = {
                    X: part__rep_free.homeScale.X * scaleFactor.X,
                    Y: part__rep_free.homeScale.Y * scaleFactor.Y,
                  };
                  logger.log("logCompZscroll", "homeScale__old__part", part__rep_free.homeScale);
                  logger.log("logCompZscroll", "homeScale__new__part", homeScale__new__part);
                  part__rep_free.homeScale = homeScale__new__part;


                  //other (induced)
                    //position
                  const offset_wrt_handle__old = {
                    dx: part__rep_free.position.x - handle__rep_free.position.x,
                    dy: part__rep_free.position.y - handle__rep_free.position.y,
                  };
                  logger.log("logCompZscroll", "offset_wrt_handle__old", offset_wrt_handle__old);

                  const offset_wrt_handle__new = {
                    dx: offset_wrt_handle__old.dx / scaleFactor.X,
                    dy: offset_wrt_handle__old.dy / scaleFactor.Y,
                  };
                  logger.log("logCompZscroll", "offset_wrt_handle__new", offset_wrt_handle__new);


                  if (part__rep_free.position != null) {
                    const position_new = {
                      x: part__rep_free.position.x - offset_wrt_handle__old.dx + offset_wrt_handle__new.dx,
                      y: part__rep_free.position.y - offset_wrt_handle__old.dy + offset_wrt_handle__new.dy,
                    };
                    logger.log("logCompZscroll", "position_new", position_new);

                    part__rep_free.position = position_new;

                  } else if (part__rep_free.point_start != null) {
                    //move segment parts
                    const point_start_new = {
                      x: part__rep_free.point_start.x + offset_wrt_handle__new.dx,
                      y: part__rep_free.point_start.y + offset_wrt_handle__new.dy,
                    };
                    part__rep_free.point_start = point_start_new;

                    const v__old = {
                      dx: part__rep_free.point_end.x - part__rep_free.point_start.x,
                      dy: part__rep_free.point_end.y - part__rep_free.point_start.y,
                    };
                    const v__new = {
                      dx: v__old.dx / scaleFactor.X,
                      dy: v__old.dy / scaleFactor.Y,
                    };

                    const point_end_new = {
                      x: part__rep_free.point_end.x + v__new.dx,
                      y: part__rep_free.point_end.y + v__new.dy,
                    };
                    part__rep_free.point_end = point_end_new;
                  }
                }

                //listen:on
                // if(typeof part__rep_free.onInnerUpdate === "function") { //SHU HORROR
                part__rep_free.onInnerUpdate(listener);
                // }

              });

            }

          };




          this.addContent = function(content__rep_free, isMobile = false) {
            // this.addContent = function(content, config__content) {
              logger.log("logComposite", "addContent", this, part__rep_free, isMobile);

            //get free_rep
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            //set content
            handle__rep_free.content = content__rep_free;

            //add config
            const config__content = {
              isMobile: isMobile,
            };
            handle__rep_free.compositeConfig[content__rep_free.id] = config__content;

            //parent
            content__rep_free.compositeId = handle.id;

            //setup listener
            //create
            const listener__content = this.createContentListener();
            //store
            this.listeners[content__rep_free.id] = listener__content;
            //activate
            content__rep_free.onInnerUpdate(listener__content);
          };

          this.removeContent = function (content__rep_free) {
            logger.log("logComposite", "removeContent", this, content__rep_free);

            //get free_rep
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            //deactivate listener
            //retrieve
            const listener__content = this.listeners[content__rep_free.id];
            //deactivate
            content__rep_free.offInnerUpdate(listener__content);
            delete this.listeners[content__rep_free.id];

            //unparent
            content__rep_free.compositeId = -1;

            //unset
            handle__rep_free.content = null;

            //remove partConfig
            delete handle__rep_free.compositeConfig[content__rep_free.id];

          };


          this.addPart = function (part__rep_free, isMobile = true, isAlterable = true) {
            // this.addPart = function(part, config__part) {
            logger.log("logComposite", "addPart", this, part__rep_free, isMobile);

            //get free_rep
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            //add part to .parts
            const miniDict = {
              [part__rep_free.id]: part__rep_free,
            };

            handle__rep_free.parts = Object.assign({}, handle__rep_free.parts, miniDict);
            // // // Object.assign(handle__rep_free.parts, miniDict);
            // // //handle__rep_free.parts[part.id] = part;

            //add partConfig
            const config__part = {
              // isMobile: true,
              isMobile:    isMobile,
              isAlterable: isAlterable,
            };
            handle__rep_free.compositeConfig[part__rep_free.id] = config__part;

            //parent
            part__rep_free.compositeId = handle.id;

            //setup listener
            //create
            const part__listener = this.createPartListener();
            //store
            this.listeners[part__rep_free.id] = part__listener;
            //activate
            part__rep_free.onInnerUpdate(part__listener);

          };

          this.addNamedPart = function (partName, part__rep_free, isMobile = true, isAlterable = true) {
            // this.addPart = function(part, config__part) {
            logger.log("logComposite", "addPart", this, part__rep_free, isMobile);

            //get free_rep
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            //add part to .parts
            const miniDict = {
              [partName]: part__rep_free,
            };

            handle__rep_free.parts = Object.assign({}, handle__rep_free.parts, miniDict);
            // // // Object.assign(handle__rep_free.parts, miniDict);
            // // //handle__rep_free.parts[part.id] = part;

            // //add partConfig
            // const config__part = {
            //   // isMobile: true,
            //   isMobile: isMobile,
            //   isAlterable: isAlterable,
            // };
            // handle__rep_free.compositeConfig[part__rep_free.id] = config__part;

            //parent
            part__rep_free.compositeId = handle.id;

            //setup listener
            //activate
            // part__rep_free.onInnerUpdate(this.listeners[part__rep_free.id]);    //SHU: ???

            //setup listener
            //create
            const part__listener = this.createPartListener();
            //store
            this.listeners[part__rep_free.id] = part__listener;
            //activate
            part__rep_free.onInnerUpdate(part__listener);
          };

          this.removePart__shallow = function (part__rep_free) {
            logger.log("logComposite", "removePart", this, part__rep_free);

            //get free_rep
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            //deactivate listener
            //retrieve
            const part__listener = this.listeners[part__rep_free.id];
            //deactivate
            part__rep_free.offInnerUpdate(part__listener);
            // delete this.listeners[part__rep_free.id];        //////////////////////////////////

            //unparent
            part__rep_free.compositeId = -1;

            //remove part from .parts
            // logger.log(handle__rep_free.parts", handle__rep_free.parts);
            //get key
            const key__part = Object.keys(handle__rep_free.parts).find(key => (handle__rep_free.parts[key] == part__rep_free));
            //update parts dict
            // delete handle__rep_free.parts[key__part];
            const parts__updated = Object.assign({}, handle__rep_free.parts);
            delete parts__updated[key__part];
            handle__rep_free.parts = parts__updated;


            //remove partConfig
            delete handle__rep_free.compositeConfig[part__rep_free.id];

          };

          this.removePart = function (part__rep_free) {   // /!\ this function removes a part__rep_free, not a part__rep_original 
            logger.log("logComposite", "removePart", this, part__rep_free);

            //get free_rep
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            //deactivate listener
            //retrieve
            const part__listener = this.listeners[part__rep_free.id];
            //deactivate
            part__rep_free.offInnerUpdate(part__listener);
            delete this.listeners[part__rep_free.id];

            //unparent
            part__rep_free.compositeId = -1;

            //remove part from .parts
            // logger.log(handle__rep_free.parts", handle__rep_free.parts);
            //get key
            const key__part = Object.keys(handle__rep_free.parts).find(key => (handle__rep_free.parts[key] == part__rep_free));
            //update parts dict
            // delete handle__rep_free.parts[key__part];
            const parts__updated = Object.assign({}, handle__rep_free.parts);
            delete parts__updated[key__part];
            handle__rep_free.parts = parts__updated;


            //remove partConfig
            delete handle__rep_free.compositeConfig[part__rep_free.id];

          };


          this.addParts = function (arr_icObj, isMobile = false) {
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            arr_icObj.forEach(icObj__part => {
              this.addPart(icObj__part, isMobile);
            });
          };

          this.removeAllParts = function () {
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            Object.values(handle__rep_free.parts).forEach(icObj__part => {
              this.removePart(icObj__part);
            });

          };




          this.start = function () {
            console.log("CompositeEngine::start, this", this);
            console.log("CompositeEngine::start", "this.scopeObj", this.scopeObj);

            this.listeners = this.createListeners();

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            console.log("CompositeEngine.start", handle.id);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            //listen to handle
            const handle__listener = this.listeners[handle.id];
            handle__rep_free.onInnerUpdate(handle__listener);

            //listen to content
            const content__rep_free = handle__rep_free.content;
            if(content__rep_free != null) {
              const content__listener = this.listeners[content__rep_free.id];
              content__rep_free.onInnerUpdate(content__listener);

              //set compositeId if not done yet         //SHU: horror
              content__rep_free.compositeId = handle__rep_free.id;
            }

            //listen to parts
            const parts = handle__rep_free.parts;
            const arr_parts_all = Object.values(parts);
            arr_parts_all.forEach((part__rep_free, i) => {
              logger.log("part__rep_free", part__rep_free);

              //set compositeId if not done yet         //SHU: horror
              part__rep_free.compositeId = handle__rep_free.id;

              //'activate' listeners
              logger.log("this.listeners", this.listeners);
              const part__listener = this.listeners[part__rep_free.id];
              // if(typeof part__rep_free.onInnerUpdate === "function") { //SHU HORROR
              logger.log("part__rep_free", part__rep_free);
              part__rep_free.onInnerUpdate(part__listener);
              // }
            });


            //debug (~tests)
            // setTimeout(() => {
            //   console.log("ççç setTimeout handle__rep_free.id_rep", handle__rep_free.id_rep);
            //
            //   handle__rep_free.position = {
            //     x: handle__rep_free.position.x + 200,
            //     y: handle__rep_free.position.y - 50,
            //   };
            // }, 3000);
            //
            // setTimeout(() => {
            //   const part1 = arr_parts_all[0];
            //   part1.position = {
            //     x: part1.position.x - 200,
            //     y: part1.position.y - 100,
            //   };
            // }, 6000);
            //
            // setTimeout(() => {
            //   const part3 = arr_parts_all[2];
            //   part3.position = {
            //     x: part3.position.x + 150,
            //     y: part3.position.y + 100,
            //   };
            // }, 9000);
          };

          this.stop = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            console.log("compositeEngine.stop", handle);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            const handle__listener = this.listeners[handle.id];
            handle__rep_free.offInnerUpdate(handle__listener);

            const content__rep_free = handle__rep_free.content;
            if(content__rep_free != null) {
              const content__listener = this.listeners[content__rep_free.id];
              content__rep_free.offInnerUpdate(content__listener);

              this.removeContent(content__rep_free);
            }

            const parts = handle__rep_free.parts;
            const arr_parts_all = Object.values(parts);
            arr_parts_all.forEach((part__rep_free, i) => {

              // const part__listener = this.listeners[part__rep_free.id];
              // part__rep_free.offInnerUpdate(part__listener);

              this.removePart(part__rep_free);
            });

          };



          this.virgin = Object.assign({}, this);  //virgin == not bound


        }

      }


      class Compositer {

        // static createPart(icObj, isMobile = true) {
        //   var outPart;
        //
        //   outPart = new CompositePart(icObj, isMobile);
        //
        //   return outPart;
        // }

        static defaultCompositeConfig(parts, isMobile = false, isAlterable = true) {
          var outConfig;

          outConfig = Object.entries(parts).reduce((acc, [partName, part], index) => {
            // const isMobile = true;

            // acc[partName] = {
            acc[part.id] = {
              isMobile:    isMobile,
              isAlterable: isAlterable,
            };

            return acc;
          }, {});

          return outConfig;
        }

      }


      // class CompositePart {
      //   constructor(icObj, isMobile) {
      //
      //     this.icObj    = icObj;
      //     this.isMobile = isMobile;
      //
      //   }
      // }



      class ArrayEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            // logger.log("logCP", "CompositeEngine", "this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          };


          this.getArr_icObj = function() {
            const handle = this.scopeObj.engineCarrier;

            return handle.arr_icObj;
          };

          this.getArr_rep_free = function() {
            const arr_icObj = this.getArr_icObj();

            const arr_rep_free = arr_icObj.map((icObj__elt) => {
              return infiniteCanvas.getRepresented(icObj__elt.id).r_free();
            });

            return arr_rep_free;
          };




          this.layout__array = function() {
            logger.log("logArrayEngine", "layout__array");

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();


            // const content = handle__rep_free.content;
            // const parts   = handle__rep_free.parts;

            // const arr_parts_all             = Object.values(parts);
            // const arr_content_and_parts_all = [content, ...arr_parts_all].filter(icObj => (icObj != null));

            const arr_rep_free = this.getArr_rep_free();

            const engine__composite = handle__rep_free.dict_engine["composite"].engine.awoken;

            arr_rep_free.forEach((rep_free__elt, i) => {
              logger.log("rep_free__elt", rep_free__elt);

              const listener = engine__composite.listeners[rep_free__elt.id];

              //listen:off (composite part)
              rep_free__elt.offInnerUpdate(listener);

              //update position
              const position__origin = {
                x: handle__rep_free.position.x,
                y: handle__rep_free.position.y,
              };

              const offset = {
                dx: i * 180,
                dy: 0,
              };

              const position_new = {
                x: position__origin.x + offset.dx,
                y: position__origin.y + offset.dy,
              };
              rep_free__elt.position = position_new;

              //listen:on (composite part)
              rep_free__elt.onInnerUpdate(listener);

            });

          };





          //horror: disable array layout for a little time, so that compositeEngine does its stuff
          this.offFlag_then_func_then_onFlag = function(func) {
            this.isEnabled__arrayLayout = false;
            func();
            setTimeout(() => {
              this.isEnabled__arrayLayout = true;
            }, 50);
          };


        

          this.append = function(rep_free_in) {
            logger.log("logArray", "append", this, rep_free_in);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;
            
            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();         

            this.offFlag_then_func_then_onFlag(() => {
              //add to composite
              handle__rep_free.dict_engine["composite"].engine.awoken.addPart(rep_free_in, false);

              //add to arr_icObj
              handle__rep_free.arr_icObj.push(rep_free_in);
            });
          };

          this.extend = function(icArray_in) {
            logger.log("logArray", "extend", this, icArray_in);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;
            
            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            const engine_in    = icArray_in.dict_engine["array"].engine.awoken;

            this.offFlag_then_func_then_onFlag(() => {
              const arr_rep_free__in = engine_in.getArr_rep_free();
              
              engine_in.popAll();
              icArray_in.im_dying_now = true;

              //add to composite
              handle__rep_free.dict_engine["composite"].engine.awoken.addParts(arr_rep_free__in, false);

              //add to arr_icObj
              handle__rep_free.arr_icObj.push(...arr_rep_free__in);
            });

          };

          this.popFirst = function (n = 1) {
            logger.log("logArray", "popFirst", this, n);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;
            
            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();         

            this.offFlag_then_func_then_onFlag(() => {

              //get element to remove
              const icObj__popped = handle__rep_free.arr_icObj.shift();
              const rep_free__popped = infiniteCanvas.getRepresented(icObj__popped.id).r_free();

              //remove from composite
              handle__rep_free.dict_engine["composite"].engine.awoken.removePart(rep_free__popped);
            });
          };

          this.popLast = function (n = 1) {
            logger.log("logArray", "popLast", this, n);
            
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;
            
            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();         

            this.offFlag_then_func_then_onFlag(() => {

              //get element to remove
              const rep_free__popped = handle__rep_free.arr_icObj.pop();

              //remove from composite
              handle__rep_free.dict_engine["composite"].engine.awoken.removePart(rep_free__popped);
            });
          };

          this.popAll = function(n = 1) {
            logger.log("logArray", "popAll", this, n);
            
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;
            
            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();         

            this.offFlag_then_func_then_onFlag(() => {

              //remove all
              handle__rep_free.arr_icObj = [];

              //remove all from composite
              handle__rep_free.dict_engine["composite"].engine.awoken.removeAllParts();
            });
          };

          this.partition = function(n = 2) {
            logger.log("logArray", "partition", this, n);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;
            
            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();     


          };




          this.start = function () {
            console.log("ArrayEngine::start, this", this);
            console.log("ArrayEngine::start", "this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            console.log("ArrayEngine.start", handle.id);

            
            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            this.isEnabled__arrayLayout = true;

            handle__rep_free.onInnerUpdate(() => {
              if(this.isEnabled__arrayLayout) {
                this.layout__array();
              }
            });

          };

          this.stop = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            console.log("ArrayEngine.stop", handle);

            

          };



          this.virgin = Object.assign({}, this);  //virgin == not bound


        }

      }






      class PlatformEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          };
          

          this.getArr_childPlatforms = function() {
            const icPlatform     = this.scopeObj.engineCarrier;
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            
            const arr_platform = CompositeUtils.getAllContained_filtered(icPlatform.parts.terrace, (icObj) => {
              return (icObj.cType == "platform");
            });

            return arr_platform;
          };





          this.createListeners = function () {
            var outListenersDict = {};

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const platform       = this.scopeObj.engineCarrier;

            const icDropTouchSlot      = platform.parts.dropTouchSlot;
            const icComposite__terrace = platform.parts.terrace;

            //listen to terrace events
            const compositeEngine__terrace = icComposite__terrace.dict_engine["composite"].engine.awoken;
            
              //addPart
            Hooker.installHooks(compositeEngine__terrace, "addPart");
            const listener__terrace_addPart = compositeEngine__terrace.did["addPart"];
            outListenersDict["terrace_addPart"] = listener__terrace_addPart;
            
              //removePart
            Hooker.installHooks(compositeEngine__terrace, "removePart");
            const listener__terrace_removePart = compositeEngine__terrace.did["removePart"];
            outListenersDict["terrace_removePart"] = listener__terrace_removePart;


            return outListenersDict;
          };


          
          this.onObjectAdded = function(icObj__added) {
            logger.log("logPlatform", "platformEngine::onObjectAdded", "icObj__added:", icObj__added);
            const platform = this.scopeObj.engineCarrier;

            platform.arr_terraced.push(icObj__added);

            logger.log("logPlatform", "platform.arr_terraced:", platform.arr_terraced);

            this.updateDropTouchSlot();
          };

          this.onObjectRemoved = function(icObj__removed) {
            logger.log("logPlatform", "platformEngine::onObjectRemoved", icObj__removed);
            const platform = this.scopeObj.engineCarrier;

            platform.arr_terraced = Utils.arrayByRemovingElement(platform.arr_terraced, icObj__removed);

            logger.log("logPlatform", "platform.arr_terraced:", platform.arr_terraced);

            this.updateDropTouchSlot();
          };

          this.updateDropTouchSlot = function() {

            const platformEngine = this;

            const infiniteCanvas = this.scopeObj.infiniteCanvas;

            const icPlatform           = this.scopeObj.engineCarrier;
            const icDropTouchSlot      = icPlatform.parts.dropTouchSlot;
            const icComposite__terrace = icPlatform.parts.terrace;

            //do something ?

            //here we could program stuff like: terrace is full so ignore all other incoming objects
          };



          this.setupDropTouchSlot = function() {

            const platformEngine = this;
            
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icPlatform     = this.scopeObj.engineCarrier;

            const rep_free__platform   = this.scopeObj.engineCarrier;
            const icDropTouchSlot      = rep_free__platform.parts.dropTouchSlot;
            const icComposite__terrace = rep_free__platform.parts.terrace;

            const transformationFunc__touch = (icObj) => {
              // const icObj__sadness = icObjToIcObjFunc(icObj);
              logger.log("logPlatform", "transformationFunc__touch", icObj);

              // rep_free__platform.parts.terrace.dict_engine["composite"].engine.awoken.addPart(icObj, false);
              const rootObject = icObj.getRootObject(infiniteCanvas);
                //root object is added just below terrace (remember it later when thinking about removal)
              rep_free__platform.parts.terrace.dict_engine["composite"].engine.awoken.addPart(rootObject, false);

              const transformationOutput = new TransformationOutput("displaced", icObj, icObj);
              return transformationOutput;
            };
            rep_free__platform.parts.dropTouchSlot.touchSlotConfig.transformationFunc__touch = transformationFunc__touch;

            const transformationFunc__untouch = (icObj) => {
              logger.log("logPlatform", "transformationFunc__untouch", icObj);

              // rep_free__platform.parts.terrace.dict_engine["composite"].engine.awoken.removePart(icObj);
              // const rootObject = icObj.getRootObject(infiniteCanvas);
              const highestRootBeforeTerrace = CompositeUtils.getHighestRootObjectBefore(icObj, rep_free__platform.parts.terrace);

              rep_free__platform.parts.terrace.dict_engine["composite"].engine.awoken.removePart(highestRootBeforeTerrace);

              const transformationOutput = new TransformationOutput("displaced", icObj, icObj);
              return transformationOutput;
            };
            rep_free__platform.parts.dropTouchSlot.touchSlotConfig.transformationFunc__untouch = transformationFunc__untouch;


            // //bugfix: 'double move' (== avoid "composition ouroboros")
            // const filterFunc__touch__isObjectIgnored = function (incomingObj) {
            //   logger.log("dropTouchSlotEngine__platformEdition.isObjectIgnored", incomingObj);
            //   // return false;
            //   const isMyPlatform = (incomingObj.id == icPlatform.id);
            //   const isMyTerrace  = (incomingObj.id == icComposite__terrace.id);
            //   const isMyParent   = CompositeUtils.isContainerOf(incomingObj, icPlatform); //SHU /!\ serialization issues ?

            //   const isPartOfMyPlatform = CompositeUtils.isHavingCommonContainer(incomingObj, icPlatform, infiniteCanvas);
            //   const isPartOfMyTerrace  = CompositeUtils.isHavingCommonContainer(incomingObj, icComposite__terrace, infiniteCanvas);
            //   const isPartOfMyParentButNotOnMyTerrace = isPartOfMyPlatform && !isPartOfMyTerrace;
              
            //   // const isIgnored = isMyTerrace || isMyPlatform || isMyParent || isPartOfMyParent;
            //   const isIgnored = isMyTerrace || isMyPlatform || isMyParent || isPartOfMyParentButNotOnMyTerrace;
            //   logger.log("dropTouchSlotEngine__platformEdition.isObjectIgnored", "isIgnored:", isIgnored);

            //   return isIgnored;
            // };
            // rep_free__platform.parts.dropTouchSlot.touchSlotConfig.filterFunc__touch__isObjectIgnored = filterFunc__touch__isObjectIgnored;


            const filterFunc__touch__isObjectIgnored__original = function (incomingObj) {
              logger.log("dropTouchSlotEngine__platformEdition.isObjectIgnored", "incomingObj:", incomingObj, "icPlatform:", icPlatform);

              // return false;
              const isMyPlatform = (incomingObj.id == icPlatform.id);
              const isMyTerrace  = (incomingObj.id == icComposite__terrace.id);
              const isMyParent   = CompositeUtils.isContainerOf(incomingObj, icPlatform); //SHU /!\ serialization issues ?

              const isHCCWithMyPlatform = CompositeUtils.isHavingCommonContainer(incomingObj, icPlatform, infiniteCanvas);
              // const isPartOfMyTerrace  = CompositeUtils.isHavingCommonContainer(incomingObj, icComposite__terrace, infiniteCanvas);
              const isPartOfMyTerrace  = CompositeUtils.isContainerOf(icComposite__terrace, incomingObj);
              // const isPartOfMyParentButNotOfMyTerrace = isPartOfMyPlatform && !isPartOfMyTerrace;
              
              // const isIgnored = isMyTerrace || isMyPlatform || isMyParent || isPartOfMyParent;
              const isIgnored = isMyTerrace || isMyPlatform || isMyParent || (isHCCWithMyPlatform && !isPartOfMyTerrace);
              logger.log("dropTouchSlotEngine__platformEdition.isObjectIgnored", "isIgnored:", isIgnored);

              return isIgnored;
            };

            const filterFunc__touch__isObjectIgnored__platformOnPlatform = function(incomingObj) {
              //get child platforms
              const arr_childPlatforms = platformEngine.getArr_childPlatforms();

              const canTouchFunc_geometryWise = function (above, below, context) {
                // const canTouchFunc = Touch.canTouch;
  
                const touch2Singleton = Touch2Singleton.sharedInstance();
                const canTouchFunc    = touch2Singleton.canTouch.bind(touch2Singleton);
  
                return canTouchFunc(above, below);
              };

              //ignore if incoming obj is touching a child platfom's dropTouchSlot, _geometryWise_
                  //SHU: maybe there could be a function in childPlatform to call (ask directly childPlatform if it may handle incomingObj)
              const isObjectIgnored = (arr_childPlatforms.find((icChildPlatform) => {
                const icChildDropTouchSlot = icChildPlatform.parts.dropTouchSlot;
                const canTouch_geometryWise = canTouchFunc_geometryWise(incomingObj, icChildDropTouchSlot);
                logger.log("logPlatform", "platformEngine", "canTouch_geometryWise:", canTouch_geometryWise);
                return canTouch_geometryWise;
              })  != null);

              return isObjectIgnored;
            };

            const filterFunc__touch__isObjectIgnored = function(incomingObj) {
              return   filterFunc__touch__isObjectIgnored__original(incomingObj)
                    || filterFunc__touch__isObjectIgnored__platformOnPlatform(incomingObj); 
            }

            icDropTouchSlot.touchSlotConfig.filterFunc__touch__isObjectIgnored = filterFunc__touch__isObjectIgnored;

          };




          this.start = function () {
            logger.log("engine::start, this", this);
            console.log("platformEngine::start", "this.scopeObj", this.scopeObj);

            const platformEngine = this;

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            console.log("platformEngine.start", handle.id);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            //create listeners
            this.listeners = this.createListeners();

            //listen to terrace
            const listener__terrrace_addPart = this.listeners["terrace_addPart"];
            listener__terrrace_addPart.on((icObj) => {
              // logger.log("logPlatform", "terrace did addPart", icObj);
              
              platformEngine.onObjectAdded(icObj);
            });

            const listener__terrace_removePart = this.listeners["terrace_removePart"];
            listener__terrace_removePart.on((icObj) => {
              // logger.log("logPlatform", "terrace did addPart", icObj);
              
              platformEngine.onObjectRemoved(icObj);
            });

            this.setupDropTouchSlot();


          };

          this.stop = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            console.log("compositeEngine.stop", handle);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            const handle__listener = this.listeners[handle.id];
            handle__rep_free.offInnerUpdate(handle__listener);

            const parts = handle__rep_free.parts;
            const arr_parts_all = Object.values(parts);
            arr_parts_all.forEach((part__rep_free, i) => {

              const part__listener = this.listeners[part__rep_free.id];
              part__rep_free.offInnerUpdate(part__listener);
            });

          };



          this.virgin = Object.assign({}, this);  //virgin == not bound


        }

      }



      class LinkEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          };


          // this.createLinkListener = function() {
          //   const link__listener = (representation, propName, oldValue, newValue) => {
          //     const updatesDict = {
          //       [propName]: {
          //         old: oldValue,
          //         new: newValue,
          //       },
          //     };
          //     this.manageLinkUpdate(representation, updatesDict);
          //   };
          //
          //   return link__listener;
          // };

          this.createPartListener = function () {
            const part__listener = (representation, propName, oldValue, newValue) => {
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.managePartUpdate(representation, updatesDict);
            };

            return part__listener;
          };



          this.createListeners = function () {
            var outListenersDict = {};

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const link = this.scopeObj.engineCarrier;


            //get free_rep
            const link__represented = infiniteCanvas.getRepresented(link.id);
            const link__rep_free = link__represented.r_free();

            // const link__listener = this.createLinkListener();
            // outListenersDict[link.id] = link__listener;

            const parts = link__rep_free.parts;
            const part_listeners = Object.entries(parts).reduce((acc, [partName, part__rep_free]) => {

              const part__listener = this.createPartListener();

              // acc[partName] = part__listener;
              acc[part__rep_free.id] = part__listener;

              return acc;
            }, {});

            Object.assign(outListenersDict, part_listeners);

            return outListenersDict;
          };




          this.getArr_everyone = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const link = this.scopeObj.engineCarrier;


            //get free_rep
            const link__represented = infiniteCanvas.getRepresented(link.id);
            const link__rep_free = link__represented.r_free();

            const parts = link__rep_free.parts;

            return [link__rep_free] + Object.values(parts);
          };

          this.getArr_everyoneBut = function (solo_rep) {
            const arr_everyoneElse = this.getArr_everyone().filter(rep => rep.id != solo_rep.id);
            return arr_everyoneElse;
          };

          this.onEveryoneBut = function (solo_rep) {
            const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = this.listeners[rep.id];
              rep.onInnerUpdate(listener);
            });
          };

          this.offEveryoneBut = function (rep) {
            const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = this.listeners[rep.id];
              rep.offInnerUpdate(listener);
            });
          };

          //part update
          this.managePartUpdate = function (icObj_compositePart, outerUpdatesDict) {
            logger.log("managePartUpdate", icObj_compositePart);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const link = this.scopeObj.engineCarrier;

            const compositeConfig = handle.compositeConfig;
            console.log("compositeConfig", compositeConfig);
            const id__compositePart = icObj_compositePart.id;
            console.log("id__compositePart", id__compositePart);

            const isMobile = compositeConfig[id__compositePart].isMobile;

            if (isMobile) {
              //ignore
            } else {

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free = handle__represented.r_free();

              // const part__represented   = infiniteCanvas.getRepresented(icObj_compositePart.id);

              // rep_free__composite.composite.managePartUpdate(rep_free__compositePart, outerUpdatesDict);
              if (outerUpdatesDict.position != null) {

                const offset = {
                  dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                  dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
                };

                const parts = handle__rep_free.parts;

                const arr_parts_all = Object.values(parts);
                const arr_parts_other = arr_parts_all.filter(part => part.id != icObj_compositePart.id);

                const arr_handle_and_other = [handle__rep_free, ...arr_parts_other];

                // arr_parts_other.forEach((rep_free, i) => {
                arr_handle_and_other.forEach((rep_free, i) => {

                  const listener = this.listeners[rep_free.id];
                  // console.log("°°°listener", listener);

                  //listen:off
                  rep_free.offInnerUpdate(listener);

                  //mutate
                  // logger.log("mutating part:", rep_free.id);
                  {
                    const position_new = {
                      x: rep_free.position.x + offset.dx,
                      y: rep_free.position.y + offset.dy,
                    };

                    rep_free.position = position_new;
                  }

                  //listen:on
                  rep_free.onInnerUpdate(listener);

                });


                //   {
                //     const rep_free = handle__rep_free;
                //
                //     //listen:off
                //     rep_free.offInnerUpdate(listener);
                //
                //     //mutate
                //     {
                //       const position_new = {
                //         x: rep_free.position.x + offset.dx,
                //         y: rep_free.position.y + offset.dy,
                //       };
                //
                //       rep_free.position = position_new;
                //     }
                //
                //     //listen:on
                //     rep_free.onInnerUpdate(listener);
                //   }


              }

            }

          };

          //link update
          this.manageLinkUpdate = function (icObj_link, outerUpdatesDict) {
            console.log("manageLinkUpdate", icObj_link);

            //get free_rep
            const link__represented = infiniteCanvas.getRepresented(icObj_link.id);
            const link__rep_free = link__represented.r_free();

            // if(outerUpdatesDict.position != null) {
            //
            //   const offset = {
            //     dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
            //     dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
            //   };
            //
            //   const parts           = handle__rep_free.parts;
            //   const arr_parts_all   = Object.values(parts);
            //   arr_parts_all.forEach((part__rep_free, i) => {
            //
            //     const listener = this.listeners[part__rep_free.id];
            //
            //     //listen:off
            //     part__rep_free.offInnerUpdate(listener);
            //
            //
            //     //mutate
            //     // logger.log("mutating part:", part__rep_free.id);
            //     {
            //       const position_new = {
            //         x: part__rep_free.position.x + offset.dx,
            //         y: part__rep_free.position.y + offset.dy,
            //       };
            //
            //       part__rep_free.position = position_new;
            //     }
            //
            //     //listen:on
            //     part__rep_free.onInnerUpdate(listener);
            //
            //   });
            //
            // }
            // // else if(outerUpdatesDict.parts != null) {
            // //   logger.log("outerUpdatesDict.parts", outerUpdatesDict.parts);
            // //
            // //   // const arr_parts__old = [];
            // //   // const arr_parts__new = [];
            // //
            // //   Object.values(outerUpdatesDict.parts.new).forEach((part__rep_free, i) => {
            // //     const part__listener = this.createPartListener();
            // //     this.listeners[part__rep_free.id] = part__listener;
            // //
            // //     if(handle__rep_free.compositeConfig[part__rep_free.id] == null) {
            // //       const config__part = {
            // //         // isMobile: true,
            // //         isMobile: false,
            // //       };
            // //       handle__rep_free.compositeConfig[part__rep_free.id] = config__part;
            // //     }
            // //
            // //     //'activate' listener
            // //     // const part__listener = this.listeners[part__rep_free.id];
            // //     part__rep_free.onInnerUpdate(part__listener);
            // //
            // //   });
            // //
            // // }

          };







          this.start = function () {
            console.log("engine::start, this", this);
            console.log("LinkEngine::start", "this.scopeObj", this.scopeObj);

            this.listeners = this.createListeners();

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const link = this.scopeObj.engineCarrier;

            console.log("linkEngine.start", link.id);

            //get free_rep
            const link__represented = infiniteCanvas.getRepresented(link.id);
            const link__rep_free = link__represented.r_free();


            //listen to link
            const link__listener = this.listeners[link.id];
            link__rep_free.onInnerUpdate(link__listener);

            //listen to parts
            const parts = link__rep_free.parts;
            const arr_parts_all = Object.values(parts);
            arr_parts_all.forEach((part__rep_free, i) => {
              // logger.log("part__rep_free", part__rep_free);

              //'activate' listeners
              const part__listener = this.listeners[part__rep_free.id];
              part__rep_free.onInnerUpdate(part__listener);
            });

          };

          this.stop = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const link = this.scopeObj.engineCarrier;

            console.log("linkEngine.stop", handle);

            //get free_rep
            const link__represented = infiniteCanvas.getRepresented(link.id);
            const link__rep_free = link__represented.r_free();

            const link__listener = this.listeners[link.id];
            link__rep_free.offInnerUpdate(link__listener);

            const parts = link__rep_free.parts;
            const arr_parts_all = Object.values(parts);
            arr_parts_all.forEach((part__rep_free, i) => {

              const part__listener = this.listeners[part__rep_free.id];
              part__rep_free.offInnerUpdate(part__listener);
            });

          };



          this.virgin = Object.assign({}, this);  //virgin == not bound


        }

      }


      class SliderEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          };


          this.createHandleListener = function () {
            const handle__listener = (representation, propName, oldValue, newValue) => {
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.manageHandleUpdate(representation, updatesDict);
            };

            return handle__listener;
          };




          // this.counter__partListeners = 0;
          // this.createPartListener = function () {

          //   // const index__partListener = this.counter__partListeners;

          //   const part__listener = (representation, propName, oldValue, newValue) => {
          //     // logger.log("partListener", index__partListener);
          //     const updatesDict = {
          //       [propName]: {
          //         old: oldValue,
          //         new: newValue,
          //       },
          //     };
          //     this.managePartUpdate(representation, updatesDict);
          //   };

          //   // this.counter__partListeners += 1;

          //   return part__listener;
          // };



          this.createListeners = function () {
            var outListenersDict = {};

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;


            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();



            const handle__listener = this.createHandleListener();

            // outListenersDict["handle"] = handle__listener;
            outListenersDict[handle.id] = handle__listener;


            // const parts = handle__rep_free.parts;
            // const part_listeners = Object.entries(parts).reduce((acc, [partName, part__rep_free]) => {

            //   const part__listener = this.createPartListener();

            //   // acc[partName] = part__listener;
            //   acc[part__rep_free.id] = part__listener;

            //   return acc;
            // }, {});

            // Object.assign(outListenersDict, part_listeners);

            return outListenersDict;
          };


          //handle update
          this.manageHandleUpdate = function (icObj_composite, outerUpdatesDict) {
            console.log("manageHandleUpdate", icObj_composite);

            if (outerUpdatesDict.mathNode != null) {
              logger.log("outerUpdatesDict.mathNode != null", outerUpdatesDict.mathNode);

              const mathNode = outerUpdatesDict.mathNode.new;

              this.updateKnobWithMathNode(mathNode);
            }

          };

          this.updateKnobWithMathNode = function (mathNode) {
            var value;
            if (mathNode.value != null) {
              value = mathNode.value;
            } else {
              value = mathNode.evaluate({});
            }

            this.updateKnobWithValue(value);
          }

          this.updateKnobWithValue = function (value) {

            const icObj_composite = this.scopeObj.engineCarrier;

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(icObj_composite.id);
            const handle__rep_free = handle__represented.r_free();

            // const knob__rep_free      = handle__rep_free.parts.knob;
            const knob__rep_free = handle__rep_free.parts.labeledPoint_knob;

            //compute knob new center position
            const position = this.positionForValue(value);

            //unlock knob position (in composite)
            const compositeConfig = this.scopeObj.engineCarrier.compositeConfig;
            compositeConfig[knob__rep_free.id].isMobile = true;

            //change knob position
            knob__rep_free.position = position;

            //change knob value
            const mathNode__rep_free = knob__rep_free.parts.mathNode;
            mathNode__rep_free.mathNode = new math.ConstantNode(value);

            //lock knob position (in composite)
            compositeConfig[knob__rep_free.id].isMobile = false;
          };

          //model --> view

          this.positionForValue = function (value) {
            const value__L = this.scopeObj.engineCarrier.value__L;
            const value__R = this.scopeObj.engineCarrier.value__R;

            const progress = (value - value__L) / (value__R - value__L);

            const position = this.positionForProgress(progress);

            return position;
          };

          this.positionForProgress = function (progress) {
            const icPoint__L = this.scopeObj.engineCarrier.parts.labeledPoint_L.parts.point;
            const icPoint__R = this.scopeObj.engineCarrier.parts.labeledPoint_R.parts.point;

            const position_L = icPoint__L.position;
            const position_R = icPoint__R.position;

            const position__progress = Geometry.pointOnSegment__progress(position_L, position_R, progress);

            return position__progress;
          };

          //view --> model

          this.valueForPosition = function (position) {

          };

          this.progressForPosition = function (position) {

          };


          //part update
          this.manageValueUpdate = function (valueUpdateDict) {

            const parts = handle__rep_free.parts;

            const arr_parts_all = Object.values(parts);
            const arr_parts_other = arr_parts_all.filter(part => part.id != icObj_compositePart.id);

            const arr_handle_and_other = [handle__rep_free, ...arr_parts_other];

            // arr_parts_other.forEach((rep_free, i) => {
            arr_handle_and_other.forEach((rep_free, i) => {

              const listener = this.listeners[rep_free.id];
              // console.log("°°°listener", listener);

              //listen:off
              rep_free.offInnerUpdate(listener);

              //mutate
              // logger.log("mutating part:", rep_free.id);
              {
                const position_new = {
                  x: rep_free.position.x + offset.dx,
                  y: rep_free.position.y + offset.dy,
                };

                rep_free.position = position_new;
              }

              //listen:on
              rep_free.onInnerUpdate(listener);

            });

          }

          // this.updateViewWithModel = function(model) {


          // };

          // this.updateKnobWithValue = function(value) {


          // };

          // this.updateKnobWithProgress = function(progress) {


          // };


          this.start = function () {
            console.log("SliderEngine::start, this", this);
            console.log("SliderEngine::start", "this.scopeObj", this.scopeObj);

            //initialize view
            const mathNode = this.scopeObj.engineCarrier.mathNode;
            this.updateKnobWithMathNode(mathNode);


            this.listeners = this.createListeners();

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            //listen to handle
            const handle__listener = this.listeners[handle.id];
            handle__rep_free.onInnerUpdate(handle__listener);



            // //listen to parts
            // const parts = handle__rep_free.parts;
            // const arr_parts_all = Object.values(parts);
            // arr_parts_all.forEach((part__rep_free, i) => {
            //   logger.log("part__rep_free", part__rep_free);

            //   //set compositeId if not done yet         //SHU: horror
            //   part__rep_free.compositeId = handle__rep_free.id;

            //   //'activate' listeners
            //   logger.log("this.listeners", this.listeners);
            //   const part__listener = this.listeners[part__rep_free.id];
            //   part__rep_free.onInnerUpdate(part__listener);
            // });


            //debug (~tests)
            // setTimeout(() => {
            //   console.log("ççç setTimeout handle__rep_free.id_rep", handle__rep_free.id_rep);
            //
            //   handle__rep_free.position = {
            //     x: handle__rep_free.position.x + 200,
            //     y: handle__rep_free.position.y - 50,
            //   };
            // }, 3000);
            //
            // setTimeout(() => {
            //   const part1 = arr_parts_all[0];
            //   part1.position = {
            //     x: part1.position.x - 200,
            //     y: part1.position.y - 100,
            //   };
            // }, 6000);
            //
            // setTimeout(() => {
            //   const part3 = arr_parts_all[2];
            //   part3.position = {
            //     x: part3.position.x + 150,
            //     y: part3.position.y + 100,
            //   };
            // }, 9000);
          };

          this.stop = function () {
            console.log("sliderEngine.stop", handle);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free = handle__represented.r_free();

            const handle__listener = this.listeners[handle.id];
            handle__rep_free.offInnerUpdate(handle__listener);

            // const parts = handle__rep_free.parts;
            // const arr_parts_all = Object.values(parts);
            // arr_parts_all.forEach((part__rep_free, i) => {

            //   // const part__listener = this.listeners[part__rep_free.id];
            //   // part__rep_free.offInnerUpdate(part__listener);

            //   this.removePart(part__rep_free);
            // });


            this.listeners = null;

          };



          this.virgin = Object.assign({}, this);  //virgin == not bound


        }

      }


      class MixedScaleEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          };


          this.updateScaleWithICScale = function (icScale) {
            logger.log("mixedScaleEngine::updateScaleWithICScale", icScale);

            const icObj = this.scopeObj.engineCarrier;
            const rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();

            if (icScale.X < rep_free.scale__mixed.X) {
              rep_free.isScaleless = false;
            } else {
              rep_free.isScaleless = true;
            }

          };


          this.start = function () {
            console.log("MixedScaleEngine::start, this", this);
            console.log("MixedScaleEngine::start", "this.scopeObj", this.scopeObj);
            const engine = this;

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icObj = this.scopeObj.engineCarrier;

            //listen to iC
            // infiniteCanvas.rx_scale_observable.subscribe({
            //   next: (value) => {

            //   },
            // });
            infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
              const icScale = infiniteCanvas.scale;
              engine.updateScaleWithICScale(icScale);
            });

          };

          this.stop = function () {
            console.log("MixedScaleEngine::stop");

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle = this.scopeObj.engineCarrier;

            // infiniteCanvas.didUpdateListenersDict["scaleChanged"].pop((infiniteCanvas) => {
            //   const icScale = infiniteCanvas.scale;
            //   engine.updateScaleWithICScale(icScale);
            // });

            this.listeners = null;
          };



          this.virgin = Object.assign({}, this);  //virgin == not bound
        }

      }



      class ZSegmentEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          };


          this.createZSStrokeListener = function () {

            const zsstroke__listener = (representation, propName, oldValue, newValue) => {
              // logger.log("zsstroke__listener");
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.manageZSStrokeUpdate(representation, updatesDict);
            };

            return zsstroke__listener;
          };


          this.createZPointListener = function () {

            const zPoint__listener = (representation, propName, oldValue, newValue) => {
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.manageZPointUpdate(representation, updatesDict);
            };

            return zPoint__listener;
          };



          this.createListeners = function () {
            var outListenersDict = {};

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            //zsstroke
            {
              const listener__zsstroke = this.createZSStrokeListener();
              const id__zsstroke = handle__rep_free.parts.zsstroke.id;
              outListenersDict[id__zsstroke] = listener__zsstroke;
            }

            //zPoints
            //zPoint_start
            {
              const listener__zPoint = this.createZPointListener();
              const id__zPoint_start = handle__rep_free.parts.zPoint_start.id;
              outListenersDict[id__zPoint_start] = listener__zPoint;
            }

            //zPoint_end
            {
              const listener__zPoint = this.createZPointListener();
              const id__zPoint_end = handle__rep_free.parts.zPoint_end.id;
              outListenersDict[id__zPoint_end] = listener__zPoint;
            }

            return outListenersDict;
          };




          // this.getArr_everyone = function () {

          //   const infiniteCanvas = this.scopeObj.infiniteCanvas;
          //   const handle = this.scopeObj.engineCarrier;


          //   //get free_rep
          //   const handle__represented = infiniteCanvas.getRepresented(handle.id);
          //   const handle__rep_free = handle__represented.r_free();

          //   const parts = handle__rep_free.parts;

          //   return [handle__rep_free] + Object.values(parts);
          // };

          // this.getArr_everyoneBut = function (rep) {
          //   const arr_everyoneElse = this.getArr_everyone().filter(rep => rep.id != solo_rep.id);
          //   return arr_everyoneElse;
          // };

          // this.onEveryoneBut = function (solo_rep) {
          //   const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
          //   arr_everyoneElse.forEach((rep, i) => {
          //     const listener = this.listeners[rep.id];
          //     rep.onInnerUpdate(listener);
          //   });
          // };

          // this.offEveryoneBut = function (rep) {
          //   const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
          //   arr_everyoneElse.forEach((rep, i) => {
          //     const listener = this.listeners[rep.id];
          //     rep.offInnerUpdate(listener);
          //   });
          // };


          //zsstroke update
          this.manageZSStrokeUpdate = function (icObj_compositePart, outerUpdatesDict) {

          };

          this.updateZSStroke = function(id__zPoint) {
            logger.log("logZSegment", "updateZZStroke", id__zPoint);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            const c1 = handle__rep_free.parts.zPoint_start;
            const c2 = handle__rep_free.parts.zPoint_end;
            
            const p1 = c1.position;
            const p2 = c2.position;
            
            const r1 = c1.radius;
            const r2 = c2.radius;
            const r1__screen = r1 * 1.0 / c1.homeScale.X * c1.scale.X;
            const r2__screen = r2 * 1.0 / c2.homeScale.X * c2.scale.X;
            
            const arr__arr_point = Geometry.getArr_extangent_point__circleCircle(p1,r1__screen,p2,r2__screen);
            // logger.log("logZSegment", "arr__arr_point", arr__arr_point);
            const arr_point = [arr__arr_point[0][0], arr__arr_point[0][1], arr__arr_point[1][1], arr__arr_point[1][0]];

            const rect_enveloppe__arr_point    = Geometry.getEnveloppeRect(arr_point);
            const rect_enveloppe__circleCircle = Geometry.getEnveloppeRect__circleCircle(p1,r1__screen, p2,r2__screen);

            //update existing zsstroke
            {
              const rep_free__zsstroke = handle__rep_free.parts.zsstroke;

              const listener__zsStroke = this.listeners[rep_free__zsstroke.id];
              rep_free__zsstroke.offInnerUpdate(listener__zsStroke);

              rep_free__zsstroke.arr_point = arr_point; 

              rep_free__zsstroke.position = {
                x: rect_enveloppe__arr_point.x,
                y: rect_enveloppe__arr_point.y,
              };

              rep_free__zsstroke.homeScale = {
                X: 1.0,
                Y: 1.0,
              };

              rep_free__zsstroke.onInnerUpdate(listener__zsStroke);
            }

          };

          //zPoint update
          this.manageZPointUpdate = function (icObj_zPoint, outerUpdatesDict) {
            logger.log("logZSegment", "manageZPointUpdate", icObj_zPoint, outerUpdatesDict);

            //SHU FLUID
            logger.log("manageZPointUpdate", icObj_zPoint, outerUpdatesDict);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            const id__zPoint = icObj_zPoint.id;
            console.log("id__zPoint", id__zPoint);

            // const compositeConfig = handle.compositeConfig;
            // console.log("compositeConfig", compositeConfig);
            // const isMobile = compositeConfig[id__point].isMobile;

            // if (isMobile) {

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            // const part__represented   = infiniteCanvas.getRepresented(icObj_compositePart.id);

            // rep_free__composite.composite.managePartUpdate(rep_free__compositePart, outerUpdatesDict);
            // if ((handle__rep_free.compositeConfig[id__zPoint].isMobile) && (outerUpdatesDict.position != null || outerUpdatesDict.homeScale != null || outerUpdatesDict.scale != null)) {
            if (outerUpdatesDict.position != null || outerUpdatesDict.homeScale != null || outerUpdatesDict.scale != null) {

              const rep_free__zsstroke = handle__rep_free.parts.zsstroke;
              {
                //mutate
                logger.log("mutating zsstroke:", rep_free__zsstroke.id);
                {
                  this.updateZSStroke(id__zPoint);
                }
              }

            }

            // }

          };


          this.start = function () {
            console.log("ZSegmentEngine::start, this", this);
            console.log("ZSegmentEngine::start", "this.scopeObj", this.scopeObj);

            this.listeners = this.createListeners();

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            console.log("ZSegmentEngine.start", handle.id);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            //listen to handle
            // const handle__listener = this.listeners[handle.id];
            // handle__rep_free.onInnerUpdate(handle__listener);

            //listen to points
            // const parts = handle__rep_free.parts;
            // const arr_parts_all = Object.values(parts);

            const arr_zPoint = [handle__rep_free.parts.zPoint_start, handle__rep_free.parts.zPoint_end];
            arr_zPoint.forEach((zPoint__rep_free, i) => {
              logger.log("zPoint__rep_free", zPoint__rep_free);

              //set compositeId if not done yet         //SHU: horror
              // part__rep_free.compositeId = handle__rep_free.id;

              //'activate' listeners
              logger.log("this.listeners", this.listeners);
              const listener__zPoint = this.listeners[zPoint__rep_free.id];
              logger.log("zPoint__listener", listener__zPoint);
              // if(typeof part__rep_free.onInnerUpdate === "function") { //SHU HORROR
              zPoint__rep_free.onInnerUpdate(listener__zPoint);
              // }
            });

            //listen to zsstroke
            const rep_free__zsstroke = handle__rep_free.parts.zsstroke;
            const listener__zsstroke = this.listeners[rep_free__zsstroke.id];
            rep_free__zsstroke.onInnerUpdate(listener__zsstroke);


          };

          this.stop = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            console.log("ZSegmentEngine.stop", handle);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            // const handle__listener = this.listeners[handle.id];
            // handle__rep_free.offInnerUpdate(handle__listener);

            // const parts = handle__rep_free.parts;
            // const arr_parts_all = Object.values(parts);
            // arr_parts_all.forEach((part__rep_free, i) => {

            //   // const part__listener = this.listeners[part__rep_free.id];
            //   // part__rep_free.offInnerUpdate(part__listener);

            //   this.removePart(part__rep_free);
            // });

          };



          this.virgin = Object.assign({}, this);  //virgin == not bound


        }

      }



      class IntersectionEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptTouching = function (icObj_slot, icObj_piece) {
            // logger.log("attemptTouching", icObj_slot, icObj_piece);

            const canTouch = this.checkCanTouch(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            // logger.log("attempting to touch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if (canTouch) {
              logger.log("logIntersection", "can touch");

              const rep_official = icObj_piece;
              const represented = icObj_piece.represented;
              const rep_free     = represented.getRepresentation("free");

              // console.log("rep_free.isHeld", rep_free.isHeld);
              // if(rep_free.isHeld) {
              //   presnap(icObj_slot, icObj_piece);
              // } else {
              //   presnap(icObj_slot, icObj_piece);
              //   snap(icObj_slot, icObj_piece);
              // }

              this.touch(icObj_slot, icObj_piece);

            } else {
              logger.log("logIntersection", "can't touch");
            }

          };

          this.checkCanTouch = function (icObj_slot, icObj_piece) {
            // logger.log("checkCanTouch", icObj_piece);
            var outBool;

            const isTouching = this.dict_touching[icObj_piece.id];
            const isFollower = (icObj_piece.id_following == icObj_slot.id);

            if(!isTouching && !isFollower) {
              // const context = this.scopeObj.engineCarrier.touchSlotConfig.context;
              const context = null;

              const touch2Singleton = Touch2Singleton.sharedInstance();
              const canTouchFunc = touch2Singleton.canTouch.bind(touch2Singleton);

              outBool = canTouchFunc(icObj_piece, icObj_slot, context);
            } else {
              outBool = false;
            }

            return outBool;
          };


          this.touch = async function (icObj_slot, icObj_piece) {
            console.log("touch", icObj_piece);

            this.dict_touching[icObj_piece.id] = true;

            const infiniteCanvas     = this.scopeObj.infiniteCanvas;

            const icObj__carrier     = this.scopeObj.engineCarrier;
            const rep_free__follower = this.rep_free__follower;



            const rep_official = icObj_piece;
            const represented = icObj_piece.represented;
            const rep_free = represented.getRepresentation("free");

            const trueRect1 = icObj__carrier.getTrueRect();
            const trueRect2 = icObj_piece.getTrueRect();

            const arr_point__corners = [...Geometry.getArrPoint__corners(trueRect1), ...Geometry.getArrPoint__corners(trueRect2)];
            const trueRect__enveloppe = Geometry.getEnveloppeRect(arr_point__corners);           
            

            const icRect__enveloppe = infiniteCanvas.createIcRect(trueRect__enveloppe);
            icRect__enveloppe.fill = "#ffffff"
            icRect__enveloppe.id_following = icObj__carrier.id;
            infiniteCanvas.onceOnAddRepresentedForIcObject(icRect__enveloppe, (icRect__enveloppe) => {
              const rep_free__enveloppe = infiniteCanvas.getRepresented(icRect__enveloppe.id).r_free();
              rep_free__follower.dict_engine["composite"].engine.awoken.addNamedPart("enveloppe", rep_free__enveloppe);
            });
            infiniteCanvas.addIcObject(icRect__enveloppe); 


          };





          // this.attemptUntouching = function (icObj_slot, icObj_piece) {
          //   console.log("attemptUntouching", icObj_slot, icObj_piece);

          //   const canUntouch = this.checkCanUntouch(icObj_slot, icObj_piece);
          //   console.log("canUntouch", canUntouch);

          //   const rep_official = icObj_piece;
          //   console.log("attempting to untouch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

          //   if (canUntouch) {
          //     // console.log("can untouch");
          //     this.untouch(icObj_slot, icObj_piece);

          //   } else {
          //     // console.log("can't untouch");
          //   }

          // };

          // this.checkCanUntouch = function (icObj_slot, icObj_piece) {
          //   logger.log("checkCanUntouch", icObj_piece);
          //   var outBool;

          //   // outBool = Touch.canUntouch(icObj_piece, icObj_slot);
          //   outBool = Touch2Singleton.sharedInstance().canUntouch(icObj_piece, icObj_slot);

          //   return outBool;
          // };

          // this.untouch = function (icObj_slot, icObj_piece) {
          //   console.log("untouch", icObj_piece);

          //   const infiniteCanvas = this.scopeObj.infiniteCanvas;

          //   // const rep_free     = icObj_piece;   //SHU: this is probably false
          //   const rep_free = infiniteCanvas.getRepresented(icObj_piece.id).r_free();

          //   const represented = icObj_piece.represented;
          //   const rep_official = represented.getRepresentation("official");


          //   const icTouchSlot = this.scopeObj.engineCarrier;

          //   const transformationFunc__untouch = icTouchSlot.touchSlotConfig.transformationFunc__untouch;
          //   if (transformationFunc__untouch != null) {

          //     const transformationFunc = transformationFunc__untouch;

          //     const icObj__untouched = rep_free;
          //     logger.log("icObj__untouched", icObj__untouched);

          //     const transformationOutput = transformationFunc(icObj__untouched);
          //     switch (transformationOutput.type) {
          //       case "new":   //SHU: this code has to be updated
          //         {
          //           const icTouchSlot = this.scopeObj.infiniteCanvas;

          //           const rep_free__supervessel = infiniteCanvas.getSupervessel();

          //           rep_free__supervessel.dict_engine["composite"].engine.awoken.removePart(icObj__untouched);

          //           //remove old
          //           {
          //             // infiniteCanvas.removeIcObject(icObj__untouched);
          //             icObj__untouched.im_dying_now = true;
          //           }

          //           //add new

          //           function addNew(icObj__new) {
          //             icObj__new.isTouchable = true;
          //             icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
          //             if (icObj__new.type == "composite") {
          //               icObj__new.parts.forEach((part, i) => {
          //                 part.touchStateDict[icObj_slot.id] = TouchState.Touched;
          //               });
          //             }

          //             infiniteCanvas.addIcObject(icObj__new);

          //             const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
          //             rep_free__supervessel.dict_engine["composite"].engine.awoken.addPart(rep_free__new);

          //           }

          //           if (transformationOutput.value instanceof IcObject) {

          //             const icObj__new = transformationOutput.value;
          //             logger.log("icObj__new", icObj__new);

          //             addNew(icObj__new);

          //           } else if (transformationOutput.value instanceof Array) {

          //             transformationOutput.value.forEach((icObj__new, i) => {
          //               addNew(icObj__new);
          //             });

          //           } else {
          //             throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
          //           }
          //         }
          //         break;
          //       case "old":
          //         {
          //           //do nothing: object has not changed
          //         }
          //         break;
          //       case "mutated":
          //         {
          //           logger.log("transformationOutput:", transformationOutput);

          //           const mutationObj = transformationOutput.value;
          //           // icObj__touched.mathNode = mutationObj.mathNode;
          //           Object.assign(icObj__untouched, mutationObj);
          //         }
          //         break;
          //       // case "displaced":
          //       // {
          //       //
          //       // }
          //       // break;
          //       case "sadness":
          //         {
          //           icObj__untouched.mathNode = transformationOutput.value.mathNode;
          //         }
          //         break;

          //       // case "mathNode":     //SHU: horror code   il serait bon un jour d'harmoniser: tout le monde doit utiliser TransformationOutput
          //       // case "composite":    //SHU: horror code
          //       // // {
          //       // //   // icObj__touched.mathNode = transformationOutput.mathNode;
          //       // // }
          //       // break;

          //       default:
          //         throw new Error("unsupported transformationOutput type: " + transformationOutput.type);
          //         break;
          //     }

          //   }

          //   rep_official.touchStateDict[icObj_slot.id] = TouchState.Untouched;
          //   // rep_free.touchStateDict[icObj_slot.id] = TouchState.Untouched;
          // };





          // this.r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
          this.r_official_update_handler2 = function (rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions

            // logger.log("r_official_update_handler2", rep_official_incoming);

            // console.log("engine::r_official_update_handler2, this", this);
            // console.log("this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            // console.log("infiniteCanvas", infiniteCanvas);
            const icTouchSlot = this.scopeObj.engineCarrier;

            const touchSlotConfig = this.scopeObj.engineCarrier.touchSlotConfig;
            logger.log("touchSlotConfig", touchSlotConfig);

            const represented = infiniteCanvas.getRepresented(icTouchSlot.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const touchSlot    = rep_official;
            const incomingObj  = rep_official_incoming;

            if (incomingObj != touchSlot) {

              this.attemptTouching(touchSlot, incomingObj);

            } else {
              // console.log("I won't touch myself");  //SHU: ...

              //get all neighboring objects
              const arr_icObj = infiniteCanvas.getArr_icObj__intersecting("free", touchSlot);
              arr_icObj.forEach((incomingObj) => {
                this.attemptTouching(touchSlot, incomingObj);
              });
            }

          };


          this.start = function () {
            const intersectionEngine = this;

            logger.log("IntersectionEngine::start, this", this);
            // logger.log("touchSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icObj__carrier = this.scopeObj.engineCarrier;




            const trueRect__composite = {
              x:      icObj__carrier.position.x,
              y:      icObj__carrier.position.y,
              width:  icObj__carrier.size.width  / 3.0,
              height: icObj__carrier.size.height / 3.0,
            };
            const parts = {};
            const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
            const icComposite = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig);
            icComposite.homeScale = Object.assign({}, icObj__carrier.homeScale);
            icComposite.fill = "lime";
            icComposite.id_following = icObj__carrier.id;
            infiniteCanvas.onceOnAddRepresentedForIcObject(icComposite, (icComposite) => {
              const rep_free__follower = infiniteCanvas.getRepresented(icComposite.id).r_free();
              // rep_free__follower.opacity = 0.8;
              intersectionEngine.rep_free__follower = rep_free__follower;
            });
            infiniteCanvas.addIcObject(icComposite);


            this.dict_touching = {};
            

            infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);

            // //for each existing canvas object, add touchState wrt this new touchSlot
            // infiniteCanvas.onceOnAddRepresentedForIcObject(icTouchSlot, (icTouchSlot) => {

            //   const id_touchSlot = icTouchSlot.id;

            //   const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
            //   const arr_official_preexisiting = arr_official.filter(rep => (rep.id != id_touchSlot));
            //   arr_official_preexisiting.forEach((rep, i) => {

            //     rep.touchStateDict[id_touchSlot] = TouchState.Untouched;
            //     //SHU TODO: check if touches

            //   });

            // });

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }






      class ButtonEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }


          this.clickListener = function () {
            const button       = this.scopeObj.engineCarrier;
            const buttonConfig = button.buttonConfig;
            
            const buttonFunc   = buttonConfig.buttonFunc;
            buttonFunc(this.scopeObj);
          };

          this.start = function () {
            console.log("engine::start, this", this);
            console.log("buttonEngine::start", "this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const button = this.scopeObj.engineCarrier;

            console.log("buttonEngine.start", button.id);

            //get free_rep
            const button__represented = infiniteCanvas.getRepresented(button.id);
            const button__rep_free = button__represented.r_free();


            //"prestart"
            button__rep_free.addInteraction_click();


            //listen to button
            const button__listener = this.clickListener;
            button__rep_free.onClick(button__listener);

          };

          this.stop = function () {
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const button         = this.scopeObj.engineCarrier;

            console.log("buttonEngine.stop", button.id);

            //get free_rep
            const button__represented = infiniteCanvas.getRepresented(button.id);
            const button__rep_free    = button__represented.r_free();

            const button__listener = this.clickListener;
            button__rep_free.offClick(button__listener);

            this.clickListener = null;

            // button__rep_free.removeInteraction_click();
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound


        }


      }


      class VideoEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }

          // this.r_official_update_handler2 = function(rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions
          //
          //   // logger.log("r_official_update_handler2", rep_official_incoming);
          //
          //   // console.log("engine::r_official_update_handler2, this", this);
          //   // console.log("this.scopeObj", this.scopeObj);
          //
          // };

          this.start = function () {
            console.log("engine::start, this", this);
            logger.log("dropTouchSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icVideo        = this.scopeObj.engineCarrier;

            {
              function startRefreshLoop() {
                logger.log("log1", "startRefreshLoop");

                /// get context from canvas (canvas not shown in example)
                var ctx = canvas.getContext('2d');

                var counter = 1;                  /// this is used to reduce FPS

                /// register refresh loop
                function refreshLoop() {

                  const represented = infiniteCanvas.getRepresented(icVideo.id);
                  // console.log("represented", represented);
                  const rep_official = represented.r_official();
                  const rep_free = represented.r_free();

                  const video = icVideo.video;


                  /// reduce frame-rate
                  const nb_skipped_frames__video = 0;
                  if (counter % (nb_skipped_frames__video + 1) == 0) {
                    setNewFrame();
                    counter = 1;
                  } else {
                    counter = counter + 1;
                  }

                  if (icVideo.isShouldRequestAnimationFrame) {
                    requestAnimationFrame(refreshLoop);
                  }


                  function setNewFrame() {
                    // logger.log("log1", "setNewFrame");

                    ImageUtils.imageFromVideo_p(video).then((img) => {
                      rep_free.img = img;
                    });

                  }

                }

                icVideo.isShouldRequestAnimationFrame = true;
                icVideo.requestAnimationFrame = requestAnimationFrame(refreshLoop);

              }

              startRefreshLoop();

            }

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }
      }

      class AudioEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }

          // this.r_official_update_handler2 = function(rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions
          //
          //   // logger.log("r_official_update_handler2", rep_official_incoming);
          //
          //   // console.log("engine::r_official_update_handler2, this", this);
          //   // console.log("this.scopeObj", this.scopeObj);
          //
          // };

          this.start = function () {
            console.log("engine::start, this", this);
            logger.log("dropTouchSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icAudio        = this.scopeObj.engineCarrier;

            {
              function startRefreshLoop() {
                logger.log("log1", "startRefreshLoop");

                /// get context from canvas (canvas not shown in example)
                var ctx = canvas.getContext('2d');

                var counter = 1;                  /// this is used to reduce FPS

                /// register refresh loop
                function refreshLoop() {

                  const represented = infiniteCanvas.getRepresented(icAudio.id);
                  // console.log("represented", represented);
                  const rep_official = represented.r_official();
                  const rep_free     = represented.r_free();

                  const audio = icAudio.audio;


                  /// reduce frame-rate
                  const nb_skipped_frames__audio = 0;
                  if (counter % (nb_skipped_frames__audio + 1) == 0) {
                    setNewFrame();
                    counter = 1;
                  } else {
                    counter = counter + 1;
                  }

                  if (rep_free.isShouldRequestAnimationFrame) {
                    requestAnimationFrame(refreshLoop);
                  }


                  function setNewFrame() {
                    // logger.log("log1", "setNewFrame");

                    // ImageUtils.imageFromAudio_p(audio).then((img) => {
                    //   rep_free.img = img;
                    // });

                  }

                }

                icAudio.isShouldRequestAnimationFrame = true;
                icAudio.requestAnimationFrame         = requestAnimationFrame(refreshLoop);

              }

              startRefreshLoop();

            }

          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }
      }


      class EyeEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }

          // this.r_official_update_handler2 = function(rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions
          //
          //   // logger.log("r_official_update_handler2", rep_official_incoming);
          //
          //   // console.log("engine::r_official_update_handler2, this", this);
          //   // console.log("this.scopeObj", this.scopeObj);
          //
          // };

          this.start = function () {
            console.log("engine::start, this", this);
            logger.log("EyeEngine::start", "this.scopeObj", this.scopeObj);
            
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icEye          = this.scopeObj.engineCarrier;

            // {
            //   function startRefreshLoop() {
            //     logger.log("log1", "startRefreshLoop");
            //
            //     /// get context from canvas (canvas not shown in example)
            //     var ctx    = canvas.getContext('2d'),
            //         toggle = true;                  /// this is used to reduce FPS
            //
            //     /// register refresh loop
            //     function refreshLoop() {
            //
            //         const represented  = infiniteCanvas.getRepresented(icVideo.id);
            //         // console.log("represented", represented);
            //         const rep_official = represented.r_official();
            //         const rep_free     = represented.r_free();
            //
            //         const video = icVideo.video;
            //
            //         /// reduce frame-rate to half
            //         // toggle = !toggle;
            //
            //         // if (toggle) {
            //           captureNewFrame();
            //         // }
            //
            //         function captureNewFrame() {
            //           // logger.log("log1", "setNewFrame");
            //
            //           ImageUtils.imageFromVideo_p(video).then((img) => {
            //             rep_free.img__captured = img;
            //           });
            //
            //           if(icObj.isShouldRequestAnimationFrame) {
            //             requestAnimationFrame(refreshLoop);
            //           }
            //
            //         }
            //
            //     }
            //
            //     icObj.isShouldRequestAnimationFrame = true;
            //     icObj.requestAnimationFrame         = requestAnimationFrame(refreshLoop);
            //
            //   }
            //
            //   startRefreshLoop();
            //
            // }

            //debug
            // setTimeout(function () {
            //   const img__captured = icEye.img__captured;
            //   infiniteCanvas.addNewImage(img__captured);
            // }, 6000);

            //create rx signal



            //listen to signal


          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }
      }


      class DisplayEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }

          this.manageRxSignal__in = function(rx_signal__in) {
            logger.log("LogDisplay", "manageRxSignal__in", rx_signal__in);

            //unsubscribe to old signal (if any)
            rep_free__icDisplay.rxsub?.unsubscribe();

            rep_free__icDisplay.rxsub = rx_signal__in.subscribe({
              next: (img) => {
                rep_free__icDisplay.img = img;
              },
            });

          };

          this.r_official_update_handler2 = function(rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions
            logger.log("LogDisplay", "r_official_update_handler2", rep_official_incoming, outerUpdatesDict);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icDisplay      = this.scopeObj.engineCarrier;

            const incomingObj    = rep_official_incoming;

            const rep_free__icDisplay = infiniteCanvas.getRepresented(icDisplay.id).r_free();

            if(incomingObj == icDisplay) {

              if("rx_signal__in" in outerUpdatesDict) {
                logger.log("LogDisplay", "r_official_update_handler2", rep_official_incoming, outerUpdatesDict);

                const rx_signal__in = outerUpdatesDict["rx_signal__in"].new;

                this.manageRxSignal__in(rx_signal__in);
              }

            } else {
              //ignore
            }
          
          };

          this.start = function () {
            console.log("engine::start, this", this);
            logger.log("DisplayEngine::start", "this.scopeObj", this.scopeObj);
            
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icDisplay      = this.scopeObj.engineCarrier;

            //listen to rx_signal__in
            infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);


          };

          this.stop = function () {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }
      }


      // class ReplayEngine {
      //   constructor() {
      //
      //     this.initialized = false;
      //
      //     this.initialize = function(scopeObj) {
      //
      //       //"wake up":
      //       //bind all funcs
      //       // function isFunction(functionToCheck) {
      //       //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
      //       // }
      //       const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);
      //
      //       this.awoken = {
      //         'i_am': "awoken",
      //       };
      //       console.log("this.virgin", this.virgin);
      //       Object.entries(this.virgin)
      //             .filter(([propName, prop]) => isFunction(prop))
      //             .forEach(([propName, prop], i) => {
      //               this.awoken[propName] = prop.bind(this.awoken);
      //             });
      //
      //       // this.scopeObj  = scopeObj;
      //         //engineCarrier,
      //         //infiniteCanvas,
      //       this.awoken.scopeObj = scopeObj;
      //
      //       this.initialized = true;
      //     }
      //
      //
      //     this.clickListener = function() {
      //       const button     = this.scopeObj.engineCarrier;
      //       const buttonFunc = button.buttonConfig.buttonFunc;
      //       buttonFunc(this.scopeObj);
      //     };
      //
      //     this.start = function() {
      //       console.log("engine::start, this", this);
      //       console.log("buttonEngine::start", "this.scopeObj", this.scopeObj);
      //
      //       const infiniteCanvas = this.scopeObj.infiniteCanvas;
      //       const button         = this.scopeObj.engineCarrier;
      //
      //       console.log("buttonEngine.start", button.id);
      //
      //       //get free_rep
      //       const button__represented = infiniteCanvas.getRepresented(button.id);
      //       const button__rep_free    = button__represented.r_free();
      //
      //
      //       //"prestart"
      //       button__rep_free.addInteraction_click();
      //
      //
      //       //listen to button
      //       const button__listener = this.clickListener;
      //       button__rep_free.onClick(button__listener);
      //
      //     };
      //
      //     this.stop = function() {
      //       const infiniteCanvas = this.scopeObj.infiniteCanvas;
      //       const button         = this.scopeObj.engineCarrier;
      //
      //       console.log("buttonEngine.start", button.id);
      //
      //       //get free_rep
      //       const button__represented = infiniteCanvas.getRepresented(button.id);
      //       const button__rep_free    = button__represented.r_free();
      //
      //       const button__listener = this.clickListener;
      //       button__rep_free.offClick(button__listener);
      //     };
      //
      //
      //     this.virgin = Object.assign({}, this);  //virgin == not bound
      //
      //
      //   }
      //
      //
      // }


      // class PathmadeOperatorEngine {
      //   constructor() {
      //
      //     this.initialized = false;
      //
      //     this.initialize = function(scopeObj) {
      //
      //       //"wake up":
      //       //bind all funcs
      //       // function isFunction(functionToCheck) {
      //       //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
      //       // }
      //       const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);
      //
      //       this.awoken = {
      //         'i_am': "awoken",
      //       };
      //       console.log("this.virgin", this.virgin);
      //       Object.entries(this.virgin)
      //             .filter(([propName, prop]) => isFunction(prop))
      //             .forEach(([propName, prop], i) => {
      //               this.awoken[propName] = prop.bind(this.awoken);
      //             });
      //
      //       // this.scopeObj  = scopeObj;
      //         //engineCarrier,
      //         //infiniteCanvas,
      //       this.awoken.scopeObj = scopeObj;
      //
      //       this.initialized = true;
      //     }
      //
      //
      //     this.clickListener = function() {
      //       const button     = this.scopeObj.engineCarrier;
      //       const buttonFunc = button.buttonConfig.buttonFunc;
      //       buttonFunc(this.scopeObj);
      //     };
      //
      //     this.start = function() {
      //       console.log("engine::start, this", this);
      //       console.log("buttonEngine::start", "this.scopeObj", this.scopeObj);
      //
      //       const infiniteCanvas = this.scopeObj.infiniteCanvas;
      //       const button         = this.scopeObj.engineCarrier;
      //
      //       console.log("buttonEngine.start", button.id);
      //
      //       //get free_rep
      //       const button__represented = infiniteCanvas.getRepresented(button.id);
      //       const button__rep_free    = button__represented.r_free();
      //
      //
      //       //"prestart"
      //       button__rep_free.addInteraction_click();
      //
      //
      //       //listen to button
      //       const button__listener = this.clickListener;
      //       button__rep_free.onClick(button__listener);
      //
      //     };
      //
      //     this.stop = function() {
      //       const infiniteCanvas = this.scopeObj.infiniteCanvas;
      //       const button         = this.scopeObj.engineCarrier;
      //
      //       console.log("buttonEngine.start", button.id);
      //
      //       //get free_rep
      //       const button__represented = infiniteCanvas.getRepresented(button.id);
      //       const button__rep_free    = button__represented.r_free();
      //
      //       const button__listener = this.clickListener;
      //       button__rep_free.offClick(button__listener);
      //     };
      //
      //
      //     this.virgin = Object.assign({}, this);  //virgin == not bound
      //
      //
      //   }
      //
      //
      // }


      class GeminiShadeEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }




          this.start = function () {
            logger.log("GeminiShadeEngine.start", this);
            const engine = this;

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const gemini = this.scopeObj.engineCarrier;
            const id__target = this.scopeObj.engineCarrier.id__target;

            //get free_rep
            const represented__gemini = infiniteCanvas.getRepresented(gemini.id);
            const rep_free__gemini = represented__gemini.r_free();
            const rep_official__gemini = represented__gemini.r_official();


            //get target's free_rep
            const represented__target = infiniteCanvas.getRepresented(id__target);
            const rep_free__target = represented__target.r_free();
            const rep_official__target = represented__target.r_official();




            //create listeners

            const set_propName__ignore = new Set([
              "id",
              "type",

              "position",
              "size",
              "homeScale",
              "orientation",
              "scale",
              "flip",
              "zIndex",

              "fill",
              "stroke",
              "opacity",
              "strokeWidth",
              "backgroundColor",

              "canBeMoved",
              "canBeRotated",
              "canBeResized",
              "canBeSelected",
              "canBeHeld",

              "isSnappable",
              "snapState",
              "snappedTo",

              "isTouchable",
              "touchStateDict",

              "cType",
              "isMobile",
              "compositeId",

              "isHeld",
              "isUsingCenterPosition",

              "isSelected",
              "didUpdateListeners",

              "edit",

              "holdListeners",
              "nowHeld",
              "onHold",
              "offHold",
              "releaseListeners",
              "nowReleased",
              "onRelease",
              "offRelease",




              "id__target",
              // "eType",
              // "engine",
              "dict_engine",
              "getScopeObj",

              "im_dying_now",
              "im_dead_now",
            ]);

            const set_propName__ignore_in = set_propName__ignore;
            const set_propName__ignore_out = set_propName__ignore;


            const broadcast = function (rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_out.has(propName);
              if (isIgnored) {
                return;
              }
              logger.log("broadcast", propName, newValue);

              //off listener
              if (rep_free__target.didUpdateFromInnerListeners.includes(engine.receive)) {
                rep_free__target.offInnerUpdate(engine.receive);
              }

              //mutate
              rep_free__target[propName] = newValue;

              //on listener
              rep_free__target.onInnerUpdate(engine.receive);

            };

            const receive = function (rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_in.has(propName);
              if (isIgnored) {
                return;
              }
              logger.log("receive", propName, newValue);

              //off listener
              if (rep_free__gemini.didUpdateFromInnerListeners.includes(engine.broadcast)) {
                rep_free__gemini.offInnerUpdate(engine.broadcast);
              }

              //mutate
              rep_free__gemini[propName] = newValue;

              //on listener
              rep_free__gemini.onInnerUpdate(engine.broadcast);

            };

            //store listeners
            engine.broadcast = broadcast;
            engine.receive = receive;

            this.geminiBind = function (gemini, target) {

              target.onInnerUpdate(this.receive);
              gemini.onInnerUpdate(this.broadcast);
              // gemini.follow(target);
              // target.follow(gemini);

              //create and store uninstaller
              this.geminiUnbind = function () {
                gemini.offInnerUpdate(this.broadcast);
                target.offInnerUpdate(this.receive);
                // gemini.unfollow(target);
                // target.unfollow(gemini);
              };

            };

            this.geminiBind(rep_free__gemini, rep_free__target);


            /*
            const broadcast = function(rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_out.has(propName);
              if(isIgnored) {
                return;
              }
              logger.log("broadcast", propName, newValue);

              //off listener
              if(rep_official__target.didUpdateFromInnerListeners.includes(engine.receive)) {
                rep_official__target.offInnerUpdate(engine.receive);
              }

              //mutate
              rep_official__target[propName] = newValue;

              //on listener
              rep_official__target.onInnerUpdate(engine.receive);

            };

            const receive = function(rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_in.has(propName);
              if(isIgnored) {
                return;
              }
              logger.log("receive", propName, newValue);

              //off listener
              if(rep_official__gemini.didUpdateFromInnerListeners.includes(engine.broadcast)) {
                rep_official__gemini.offInnerUpdate(engine.broadcast);
              }

              //mutate
              rep_official__gemini[propName] = newValue;

              //on listener
              rep_official__gemini.onInnerUpdate(engine.broadcast);

            };

            //store listeners
            engine.broadcast = broadcast;
            engine.receive   = receive;

            this.geminiBind(rep_official__gemini, rep_official__target);
            */
          };

          this.stop = function () {
            this.geminiUnbind();

            this.broadcast = null;
            this.receive = null;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound


        }


      }


      class GeminiEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }




          this.start = function () {
            logger.log("GeminiShadeEngine.start", this);
            const engine = this;

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const gemini = this.scopeObj.engineCarrier;
            const id__target = this.scopeObj.engineCarrier.id__target;

            //get free_rep
            const represented__gemini = infiniteCanvas.getRepresented(gemini.id);
            const rep_free__gemini = represented__gemini.r_free();
            const rep_official__gemini = represented__gemini.r_official();


            //get target's free_rep
            const represented__target = infiniteCanvas.getRepresented(id__target);
            const rep_free__target = represented__target.r_free();
            const rep_official__target = represented__target.r_official();




            //create listeners

            const set_propName__ignore = new Set([
              "id",
              "type",

              "position",
              "size",
              "homeScale",
              "orientation",
              "scale",
              "flip",
              "zIndex",

              "fill",
              "stroke",
              "opacity",
              "strokeWidth",
              "backgroundColor",

              "canBeMoved",
              "canBeRotated",
              "canBeResized",
              "canBeSelected",
              "canBeHeld",

              "isSnappable",
              "snapState",
              "snappedTo",

              "isTouchable",
              "touchStateDict",

              "cType",
              "isMobile",
              "compositeId",

              "isHeld",
              "isUsingCenterPosition",

              "isSelected",
              "didUpdateListeners",

              "edit",

              "holdListeners",
              "nowHeld",
              "onHold",
              "offHold",
              "releaseListeners",
              "nowReleased",
              "onRelease",
              "offRelease",




              "id__target",
              // "eType",
              // "engine",
              "dict_engine",
              "getScopeObj",

              "im_dying_now",
              "im_dead_now",
            ]);

            const set_propName__ignore_in = set_propName__ignore;
            const set_propName__ignore_out = set_propName__ignore;


            const broadcast = function (rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_out.has(propName);
              if (isIgnored) {
                return;
              }
              logger.log("broadcast", propName, newValue);

              //off listener
              if (rep_free__target.didUpdateFromInnerListeners.includes(engine.receive)) {
                rep_free__target.offInnerUpdate(engine.receive);
              }

              //mutate
              rep_free__target[propName] = newValue;

              //on listener
              rep_free__target.onInnerUpdate(engine.receive);

            };

            const receive = function (rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_in.has(propName);
              if (isIgnored) {
                return;
              }
              logger.log("receive", propName, newValue);

              //off listener
              if (rep_free__gemini.didUpdateFromInnerListeners.includes(engine.broadcast)) {
                rep_free__gemini.offInnerUpdate(engine.broadcast);
              }

              //mutate
              rep_free__gemini[propName] = newValue;

              //on listener
              rep_free__gemini.onInnerUpdate(engine.broadcast);

            };

            //store listeners
            engine.broadcast = broadcast;
            engine.receive = receive;

            this.geminiBind = function (gemini, target) {

              target.onInnerUpdate(this.receive);
              gemini.onInnerUpdate(this.broadcast);
              // gemini.follow(target);
              // target.follow(gemini);

              //create and store uninstaller
              this.geminiUnbind = function () {
                gemini.offInnerUpdate(this.broadcast);
                target.offInnerUpdate(this.receive);
                // gemini.unfollow(target);
                // target.unfollow(gemini);
              };

            };

            this.geminiBind(rep_free__gemini, rep_free__target);


            /*
            const broadcast = function(rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_out.has(propName);
              if(isIgnored) {
                return;
              }
              logger.log("broadcast", propName, newValue);

              //off listener
              if(rep_official__target.didUpdateFromInnerListeners.includes(engine.receive)) {
                rep_official__target.offInnerUpdate(engine.receive);
              }

              //mutate
              rep_official__target[propName] = newValue;

              //on listener
              rep_official__target.onInnerUpdate(engine.receive);

            };

            const receive = function(rep_free, propName, oldValue, newValue) {

              const isIgnored = set_propName__ignore_in.has(propName);
              if(isIgnored) {
                return;
              }
              logger.log("receive", propName, newValue);

              //off listener
              if(rep_official__gemini.didUpdateFromInnerListeners.includes(engine.broadcast)) {
                rep_official__gemini.offInnerUpdate(engine.broadcast);
              }

              //mutate
              rep_official__gemini[propName] = newValue;

              //on listener
              rep_official__gemini.onInnerUpdate(engine.broadcast);

            };

            //store listeners
            engine.broadcast = broadcast;
            engine.receive   = receive;

            this.geminiBind(rep_official__gemini, rep_official__target);
            */
          };

          this.stop = function () {
            this.geminiUnbind();

            this.broadcast = null;
            this.receive = null;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound


        }


      }






      class GMOperatorTextChangeEngine {


        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }


          this.createTransformationFunc = function (mathOperatorSymbol_in, mathOperatorFuncName_in, node_b_in) {
            return (node_a) => {
              var outNode;

              const mathOperatorSymbol = mathOperatorSymbol_in;
              const mathOperatorFuncName = mathOperatorFuncName_in;
              const node_b = node_b_in;

              function standardOperation(node_in) {
                var outNode;

                // const node_b        = new math.ConstantNode(mathValue);
                const node_operator = new math.OperatorNode(mathOperatorSymbol, mathOperatorFuncName, [node_in, node_b]);

                const node_unsimplified = node_operator;

                if (node_in.autoSimplify) {
                  const node_simplified = math.simplify(node_unsimplified);
                  outNode = node_simplified;
                } else {
                  outNode = node_unsimplified;
                }

                outNode.autoSimplify = node_in.autoSimplify;

                return outNode;
              }

              // logger.log("node_a", node_a);
              if (node_a.isEquation) {
                console.log("node_a", node_a);
                const node_left = standardOperation(node_a.params[0]);
                const node_right = standardOperation(node_a.params[1]);
                const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                node_equation.isEquation = true;

                outNode = node_equation;
              } else {
                outNode = standardOperation(node_a);
              }

              // outNode.autoSimplify = node_a.autoSimplify;

              return outNode;
            };
          };

          this.transformationFuncForText = function (text) {
            logger.log("transformationFuncForText", text);

            const components = text.split(" ");
            const str__mathOperatorSymbol = components[0];
            const str__mathValue          = components[1];

            // const mathValue          = Number(str__mathValue);

            // const mathValueTex       = MathExpression.fromText(str__mathValue).toLatex();
            // console.log("mathValueTex", mathValueTex);

            // const node_b             = math.parse(mathValueTex);   //SHU: math only parses expressions written in math.js DSL
            const node_b = math.parse(str__mathValue);
            console.log("node_b", node_b);

            const mathOperatorFuncName = Operator.funcNameForSymbolString(str__mathOperatorSymbol);

            const transformationFunc = this.createTransformationFunc(str__mathOperatorSymbol, mathOperatorFuncName, node_b);
            // return transformationFunc;

            const icObjTransformationFunc = (icObj) => {
              var transformationOutput;

              var outIcObj;

              const mathNode__new = transformationFunc(icObj.mathNode);

              /* //does not work well
              // outIcObj = icObj.clone();
              // // logger.log("icObj.mathNode", icObj.mathNode);
              // outIcObj.mathNode = transformationFunc(mathNode__new);
              */
              //does work well
              outIcObj = infiniteCanvas.createIcMathNode(icObj.position.x, icObj.position.y, mathNode__new);

              // transformationOutput = new TransformationOutput("mutated", outIcObj, icObj);
              transformationOutput = new TransformationOutput("new", outIcObj, icObj);

              return transformationOutput;
            };

            return icObjTransformationFunc;
          };


          this.updateTouchSlotWithText = function (text) {

            const gmOperator = this.scopeObj.engineCarrier;
            const touchSlot = gmOperator.parts["touchSlot"];

            const transformationFunc = this.transformationFuncForText(text);
            const touchSlotConfig = {
              transformationFunc: transformationFunc,
            };
            touchSlot.touchSlotConfig = touchSlotConfig;

          };

          this.textChangeListener = function (rep_free_in) {
            console.log("textChangeListener, rep_free_in", rep_free_in);

            //SHU TODO: trouver pourquoi la facade récupérée n'est pas une rep_free   (quel merdier...)
            const rep_free = infiniteCanvas.getRepresented(rep_free_in.id).r_free();
            console.log("textChangeListener, rep_free", rep_free);

            const text = rep_free.text;
            this.updateTouchSlotWithText(text);
          };





          this.start = function () {
            console.log("engine::start, this", this);
            console.log("GMOperatorTextChangeEngine::start", "this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const gmOperator = this.scopeObj.engineCarrier;

            console.log("GMOperatorTextChangeEngine.start", gmOperator);

            const facade = gmOperator.parts["facade"];

            const rep_free = facade;

            if (rep_free.onEditExit == null) {
              rep_free.addInteraction_edit();
            }

            rep_free.onEditExit(this.textChangeListener);
          };

          this.stop = function () {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const gmOperator = this.scopeObj.engineCarrier;

            console.log("GMOperatorTextChangeEngine.stop", gmOperator);

            const rep_free = gmOperator;

            rep_free.offEditExit(this.textChangeListener);
          };



          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

        lol() {



        }

      }



      class GMOperatorMama {

        static operatorConfigForRank(rank) {
          var outOperatorConfig = null;

          var name = null;
          var transformationFunc = null;
          switch (rank) {
            case 0:
              name = "+1";
              // transformationFunc = (number) => (number + 1);
              // transformationFunc = (expr) => {
              // console.log("expr", expr);
              transformationFunc = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  const node_b = new math.ConstantNode(1);
                  const node_operator = new math.OperatorNode('+', 'add', [node_in, node_b]);

                  const node_unsimplified = node_operator;

                  if (node_in.autoSimplify) {
                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;
                  } else {
                    outNode = node_unsimplified;
                  }

                  outNode.autoSimplify = node_in.autoSimplify;

                  return outNode;
                }

                if (node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left = standardOperation(node_a.params[0]);
                  const node_right = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                // outNode.autoSimplify = node_a.autoSimplify;

                return outNode;
              };
              break;
            case 1:
              name = "+10";
              // transformationFunc = (number) => (number + 10);
              // transformationFunc = (expr) => expr.add(10);
              transformationFunc = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  const node_b = new math.ConstantNode(10);
                  const node_operator = new math.OperatorNode('+', 'add', [node_a, node_b]);

                  const node_unsimplified = node_operator;

                  if (node_a.autoSimplify) {
                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;
                  } else {
                    outNode = node_unsimplified;
                  }

                  outNode.autoSimplify = node_a.autoSimplify;

                  return outNode;
                }

                if (node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left = standardOperation(node_a.params[0]);
                  const node_right = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                // outNode.autoSimplify = node_a.autoSimplify;

                return outNode;
              };
              break;
            case 2:
              name = "×2";
              // transformationFunc = (number) => (number * 2);
              // transformationFunc = (expr) => expr.multiply(2);
              const transformationFunc__mathNode = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  const node_b = new math.ConstantNode(2);
                  const node_operator = new math.OperatorNode('x', 'multiply', [node_a, node_b]);

                  const node_unsimplified = node_operator;

                  if (node_a.autoSimplify) {
                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;
                  } else {
                    outNode = node_unsimplified;
                  }

                  outNode.autoSimplify = node_a.autoSimplify;

                  return outNode;
                };

                if (node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left = standardOperation(node_a.params[0]);
                  const node_right = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                // outNode.autoSimplify = node_a.autoSimplify;

                return outNode;

              };

              /*
              const transformationFunc__default = (icObj) => {

                icObj.scale = {
                  X: icObj.scale.X * 2,
                  Y: icObj.scale.Y * 2,
                };

                return icObj;
              }

              transformationFunc = (icObj) => {
                var out;
                console.log("transformationFunc, icObj", icObj);

                switch(icObj.type) {
                  case "mathNode":
                    out = transformationFunc__mathNode(icObj);
                    break;
                  default:
                    out = transformationFunc__default(icObj);
                    break;
                }

                return out;
              }
              */
              transformationFunc = transformationFunc__mathNode;


              break;
            case 3:
              name = "×(-1)";
              // transformationFunc = (number) => (number * (-1));
              // transformationFunc = (expr) => expr.multiply(-1);
              transformationFunc = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  const node_minus_1 = new math.ConstantNode(-1);
                  const node_minus_1_with_parentheses = new math.ParenthesisNode(node_minus_1);
                  const node_b = node_minus_1_with_parentheses;

                  const node_operator = new math.OperatorNode('x', 'multiply', [node_a, node_b]);

                  const node_unsimplified = node_operator;

                  if (node_a.autoSimplify) {
                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;
                  } else {
                    outNode = node_unsimplified;
                  }

                  outNode.autoSimplify = node_a.autoSimplify;

                  return outNode;
                }


                if (node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left = standardOperation(node_a.params[0]);
                  const node_right = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                // outNode.autoSimplify = node_a.autoSimplify;

                return outNode;

              };
              break;
            default:
              break;
          }

          // const operatorConfig = new OperatorConfig(name, transformationFunc);

          const icObjTransformationFunc = (icObj) => {
            var outIcObj;

            outIcObj = icObj.clone();

            outIcObj.mathNode = transformationFunc(icObj.mathNode);

            return outIcObj;
          };
          // const operatorConfig = new OperatorConfig(name, icObjTransformationFunc);


          const transformationFunc_oldStyle = icObjTransformationFunc;
          const transformationFunc_newStyle = function (icObj) {
            var transformationOutput;

            const icObj__mutated = transformationFunc_oldStyle(icObj);
            transformationOutput = new TransformationOutput("mutated", icObj__mutated, icObj);

            return transformationOutput;
          };
          const operatorConfig = new OperatorConfig(name, transformationFunc_newStyle);


          outOperatorConfig = operatorConfig;

          return outOperatorConfig;
        }

      }

      class OperatorConfig {

        constructor(name, transformationFunc) {
          this.name = name;
          this.transformationFunc = transformationFunc;
        }

      }


      class Hooker {

        static createHook() {

          const listeners = [];
          const hookObj = {
            listeners: listeners,
            trigger: (...args) => {
              listeners.forEach((listener, i) => {
                listener(...args);
              });
            },
            on: (listener) => {
              listeners.push(listener);
            },
            off: (listener) => {
              listeners.push(listener);
            },
          };

          return hookObj;
        }

        static installHooks(obj, funcName) {

          const func_original = obj[funcName];
          if (func_original == null) {
            throw new Error('obj["' + funcName + '"]' + " == null");
          }

          //create hooks
          if (obj.will == null) {
            obj.will = {};
          }
          obj.will[funcName] = this.createHook();

          if (obj.did == null) {
            obj.did = {};
          }
          obj.did[funcName] = this.createHook();



          //decorate func                         //SHU: en fait on pourrait ne pas faire assigner obj.will et obj.did et garder ces objects enfermés dans la définition de la fonction décorée
          // const func_original  = obj[funcName];
          const func_decorated = (...args) => {
            // console.log("func_decorated", ...args);
            obj.will[funcName].trigger(...args);
            func_original(...args);
            obj.did[funcName].trigger(...args);
          };

          obj[funcName] = func_decorated;
        }

      }







      /**** view  / (controller) ****/



      class FabricIntegration {

        constructor(infiniteCanvas, inputProperties) {

          //initialize fabric properties
          // fabric.Object.prototype.transparentCorners = false;
          // fabric.Object.prototype.cornerStyle = 'circle';
          // fabric.Object.prototype.cornerColor = 'black';
          // fabric.Object.prototype.borderColor = 'black';
          // fabric.Object.prototype.padding     = 10;
          //
          //
          fabric.Rect.prototype.rx = 5;    //shuxylo
          fabric.Rect.prototype.ry = 5;


          fabric.Object.prototype.getFObjZIndex = function () {
            // logger.log("this", this);
            // logger.log("this.canvas", this.canvas);
            if (!this.canvas) {          //SHU TODO: understand where this strange state originates from
              return 0;
            }
            return this.canvas.getObjects().indexOf(this);
          };

          fabric.Object.prototype.getRect = function () {
            if (!this.canvas) {          //SHU TODO: understand where this strange state originates from
              return 0;
            }
            return {
              left:    this.left,
              top:     this.top,
              width:   this.width,
              height:  this.height,
            };
          };


          // // fabricjs group - always show border
          // fabric.Group.prototype.initialize = (function (initialize) {
          //     return function () {
          //         initialize.apply(this, arguments)
          //         // prepend rect before=behind group objects
          //         this._objects = [
          //         new fabric.Rect({
          //             // position from group center
          //             left: -0.5*this.width,
          //             top: -0.5*this.height,
          //             width: this.width,
          //             height: this.height,
          //
          //             stroke: '#00f',
          //             strokeWidth: 2,
          //             fill: false,
          //         })]
          //         .concat(this._objects)
          //
          //         // TODO repaint border on group resize event
          //
          //         // TODO remove border on group destroy
          //     };
          // })(fabric.Group.prototype.initialize);





          this.infiniteCanvas  = infiniteCanvas;
          this.inputProperties = inputProperties;

          this.mouseIntegration = null;   //set after birth

          const fabricCanvas = new fabric.Canvas(infiniteCanvas.canvas.id, {

            // backgroundColor: 'rgb(250,60,60)',     //redish
            // backgroundColor: 'rgb(100,100,100)',
            // backgroundColor: 'rgb(200,200,200)',      //it is important to choose a nice bgColor to stay motivated during dev
            backgroundColor: 'rgb(210,240,240)',
            // backgroundColor: 'rgb(100,100,100)',
            // backgroundColor: 'rgb(255,255,255)',
            // backgroundColor: 'rgb(200,250,200)',
            // backgroundColor: 'rgb(250,190,200)',





            selectionColor: 'blue',
            selectionLineWidth: 2.0,

            // width:  canvas.width,
            // height: canvas.height,

            // scale: 100.0,
            // scale: 1e-10,
            // scale: 1e10,


            // imageSmoothingEnabled: true,
            imageSmoothingEnabled: false,

            preserveObjectStacking: true,
          });
          logger.log("logFabric", "fabricCanvas:", fabricCanvas);


          installFabricZIndexUpgrade(fabricCanvas);         //fabric+zIndex.js
          installFabricBrushPreviewUpgrade(fabricCanvas);   //fabric+brushPreview.js
          installFabricCombUpgrade(fabricCanvas);           //fabric+comb.js

          installFabricStraightStrokeUpgrade(fabricCanvas); //fabric+straightStroke.js

          // installFabricStickerStrokeUpgrade__image(fabric.Image.prototype);   //fabric+stickerStroke.js
          // installFabricStickerStrokeUpgrade(fabric.Object.prototype);         //fabric+stickerStroke.js

          //improve performance: (?)
          // fabricCanvas.contextTop       = fabricCanvas.upperCanvasEl.getContext('2d', { willReadFrequently: true }); 
          // fabricCanvas.contextContainer = fabricCanvas.lowerCanvasEl.getContext('2d', { willReadFrequently: true }); 
          // fabricCanvas.contextCache     = fabricCanvas.cacheCanvasEl.getContext('2d', { willReadFrequently: true }); 

          //debug
          function install_boundingboxing() {

            fabricCanvas.on('after:render', function () {

              fabricCanvas.forEachObject(function (fObj) {

                if (fObj.icObj.isSupervessel) {
                  //ignore
                  return;
                }

                const dataURL = fObj.toDataURL();
                const isDataURL = dataURL.startsWith("data");
                if (isDataURL) {
                  ImageUtils.getImageDataObj(dataURL)
                    .then(function (dataObj) {
                      const data = dataObj.data;
                      const w = dataObj.w;
                      const h = dataObj.h;

                      logger.log("w", w);
                      logger.log("h", h);

                      logger.log("fObj", fObj);

                      var boundRect = fObj.getBoundingRect();
                      logger.log("boundRect", boundRect);
                      fabricCanvas.contextContainer.strokeStyle = 'blue';
                      fabricCanvas.contextContainer.strokeRect(
                        boundRect.left,
                        boundRect.top,
                        boundRect.width,
                        boundRect.height,
                      );

                      // const point__pixel_check = {
                      //   x: 452,
                      //   y: 670,
                      // };
                      // const rgbaColorString__pixel_check = ImageUtils.getPixelRgbaColorString(data, w, h, point__pixel_check.x, point__pixel_check.y);
                      // logger.log("rgbaColorString__pixel_check", rgbaColorString__pixel_check);
                      //
                      // if(rgbaColorString__pixel_check != "rgba(255,0,255,255)") {
                      //   throw new Error("pixel check failed");
                      // } else {
                      //   logger.log("pixel check ok");
                      // }

                      const realBound = ImageUtils.boundingBox__pixelWise(data, w, h);

                      const rect__realBound = {
                        left: realBound.x1,
                        top:  realBound.y1,
                        width:  realBound.x2 - realBound.x1,
                        height: realBound.y2 - realBound.y1,
                      };

                      fabricCanvas.contextContainer.strokeStyle = 'red';
                      fabricCanvas.contextContainer.strokeRect(
                        (boundRect.left + 10) + rect__realBound.left,
                        (boundRect.top + 10) + rect__realBound.top,
                        rect__realBound.width,
                        rect__realBound.height,
                      );

                    });

                }

              });

            });

          }

          // install_boundingboxing();


          this.fabricCanvas = fabricCanvas;
          this.context = fabricCanvas.getContext("2d");
          //console.log("fabricCanvas", fabricCanvas);

          //render more objects ?
          // this.fabricCanvas.renderOnAddRemove = false;
          // this.fabricCanvas.objectCaching     = false;


          this.fabric_objects = [];
          // this.inner_fabric_objects = [];
          // this.outer_fabric_objects = [];

          this.fabric_objects__pure = [];


          this.fabric_objects__hud = [];


          this.fObjForIcObj_dict = {};

          this.singleUseBehaviors = {};

          this.dict_brush = {};          


          //debug
          {
            // this.isEnabled_supervessel = true;
            this.isEnabled_supervessel = false;
          }

          // this.debugFabric();
          this.synchronizeWithIcObjects(infiniteCanvas.icObjects);

          // this.debugOriginalAxes();

          this.initializeSelectionMgmt();  //shuxylo

          this.initializeFreeDrawing();

          this.initializeFabricObjectCopyCut();

          this.configureActiveSelectionListeners();

          this.initializeVaryingBgColor();
        }

        setFabricObjects(fabric_objects__new) {
          this.fabric_objects = fabric_objects__new;
        }

        getFabricObjects() {
          return this.fabric_objects;
        }

        createSupervessel() {
          // logger.log("createSupervessel");

          const infiniteCanvas = this.infiniteCanvas;

          const trueRect_0 = {
            x: -200,
            y: -200,
            width: 100,
            height: 100,
          };

          const parts = [];
          const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
          const icComposite = infiniteCanvas.createIcComposite(trueRect_0, parts, compositeConfig);
          infiniteCanvas.addIcObject(icComposite);

          const rep_free = infiniteCanvas.getRepresented(icComposite.id).r_free();
          const fColor = new fabric.Color("lightgray");
          fColor.setAlpha(0.666);
          const rgbaColorString = fColor.toRgba();
          rep_free.fill = rgbaColorString;

          // rep_free.strokeWidth = 1.5;
          // rep_free.stroke      = "red";

          rep_free.isSupervessel = true;

          return rep_free;
        }

        // createSuperante() {
        //   // logger.log("createSuperante");
        //
        //   const infiniteCanvas = this.infiniteCanvas;
        //
        //   const trueRect_0 = {
        //     x: 100,
        //     y: 100,
        //     width:  50,
        //     height: 50,
        //   };
        //
        //   const parts           = [];
        //   const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
        //   const icComposite     = infiniteCanvas.createIcComposite(trueRect_0, parts, compositeConfig);
        //   infiniteCanvas.addIcObject(icComposite);
        //
        //   const rep_free = infiniteCanvas.getRepresented(icComposite.id).r_free();
        //   const fColor = new fabric.Color("yellow");
        //   fColor.setAlpha(0.666);
        //   const rgbaColorString = fColor.toRgba();
        //   rep_free.fill        = rgbaColorString;
        //
        //   // rep_free.strokeWidth = 1.5;
        //   // rep_free.stroke      = "red";
        //
        //   rep_free.isSuperante = true;
        //
        //   return rep_free;
        // }

        initializeSelectionMgmt() {
          const fabricIntegration = this;

          const fabricCanvas = fabricIntegration.fabricCanvas;

          //create supervessel
          // setTimeout(() => {      //SHU: encore une envie de vomir
          //   const rep_free__supervessel = fabricIntegration.createSupervessel();
          //   // const rep_free__superante   = fabricIntegration.createSuperante();
          // }, 500);

          // fabricCanvas.on('selection:cleared', function(options) {
          //   // console.log("selection:cleared", options);
          //   const selectionMgmtObj = getSelectionMgmtObject(options);
          //   processSelectionMgmtObject(selectionObj);
          // });
          // fabricCanvas.on('selection:created', function(options) {
          //   // console.log("selection:created", options);
          //   const selectionMgmtObj = getSelectionMgmtObject(options);
          //   processSelectionMgmtObject(selectionObj);
          // });
          // fabricCanvas.on('selection:updated', function(options) {
          //   // console.log("selection:updated", options);
          //   const selectionMgmtObj = getSelectionMgmtObject(options);
          //   processSelectionMgmtObject(selectionObj);
          // });

          function selectionHandler__default(options) {
            const selectionMgmtObj = getSelectionMgmtObject(options);
            processSelectionMgmtObject(selectionMgmtObj, options);     //SHU666666 this call is very heavy
          }



          function isSelectionAllowed__scaleWise(icObj) {
            logger.log("isSelectionAllowed__scaleWise", icObj);

            const range_homeScaleX = {
              min: infiniteCanvas.scale.X * 0.90,
              max: infiniteCanvas.scale.X * 1.10,
            };
            logger.log("range_homeScaleX", range_homeScaleX);

            const homeScaleX__icObj = icObj.homeScale.X;
            logger.log("homeScaleX__icObj", homeScaleX__icObj);

            const isInRange_homeScaleX = (homeScaleX__icObj >= range_homeScaleX.min) && (homeScaleX__icObj < range_homeScaleX.max);
            logger.log("isInRange_homeScaleX", isInRange_homeScaleX);

            return isInRange_homeScaleX;
          }

          var shouldCancelFabricSelectionEvent = false; //SHU: this is ugly, I know, but I don't how to do it differently
          var selectionMgmtObj__previous = null;

          fabricCanvas.on('mouse:down:before', (e) => {
            logger.log("mouse:down:before", e);

            // if(keyboardIntegration.keyDownToggles.backquote.isActive) {
            //   this.fabricCanvas.isDrawingMode = true;
            // }


            if (this.isEnabled_supervessel) {  //SHU: debug clause

              const fObj__supervessel = fabricIntegration.getFObj__supervessel();
              const icObj__supervessel = fObj__supervessel.icObj;

              if (e.target != null) {

                const fObj__clicked = e.target;
                const icObj__clicked = fObj__clicked.icObj;

                if (fObj__clicked == fObj__supervessel) {
                  //ignore
                  return;
                }

                //scale-aware selection     //SHU: disabled for the moment
                // const isSelectionAllowed__scaleWise_ = isSelectionAllowed__scaleWise(icObj__clicked);
                // if(!isSelectionAllowed__scaleWise_) {
                //   // fabricCanvas._setupCurrentTransform(e, fObj__supervessel);
                //   // fabricCanvas.setActiveObject(fObj__supervessel);
                //   const mouseEvent = e.e;
                //   mouseEvent.stopPropagation();
                //
                //   return;
                // }

                if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {   //SHU: ouloulouloulou, aïe aïe aïe aïe aïe...
                  logger.log("lolilol");

                  fabricCanvas._setupCurrentTransform(e, fObj__supervessel);  //magic happens here
                  fabricCanvas.setActiveObject(fObj__supervessel);

                  icObj__supervessel.dict_engine["composite"].engine.awoken.addPart(icObj__clicked, false);

                  //is it necessary ? {
                  const options = {
                    selected: [fObj__supervessel],
                  };
                  selectionHandler__default(options);
                  //} ?

                } else {

                  const arr_part__supervessel = Object.values(icObj__supervessel.parts);
                  if (arr_part__supervessel.length > 0) {

                    const arr_part = Object.values(icObj__supervessel.parts);
                    arr_part.forEach((part, i) => {
                      icObj__supervessel.dict_engine["composite"].engine.awoken.removePart(part);
                    });

                  }

                  logger.log("icObj__supervessel", icObj__supervessel);

                  icObj__supervessel.zIndex = icObj__clicked.zIndex + 1;
                  icObj__supervessel.position = {
                    x: icObj__clicked.position.x,
                    y: icObj__clicked.position.y,
                  };


                  fabricCanvas._setupCurrentTransform(e, fObj__supervessel);  //magic happens here

                  fabricCanvas.setActiveObject(fObj__supervessel);

                  icObj__supervessel.dict_engine["composite"].engine.awoken.addPart(icObj__clicked, false);

                  //is it necessary ? {
                  const options = {
                    selected: [fObj__supervessel],
                  };
                  selectionHandler__default(options);
                  //} ?

                }

                // }

              } else {
                // const fObj__supervessel  = fabricIntegration.getFObj__supervessel();
                // const icObj__supervessel = fObj__supervessel.icObj;

                const arr_part = Object.values(icObj__supervessel.parts);
                arr_part.forEach((part, i) => {
                  icObj__supervessel.dict_engine["composite"].engine.awoken.removePart(part);
                });
              }

            }

          });
          fabricCanvas.on('mouse:up', (e) => {
            logger.log("logFD, mouse:up", e.button);
          });
          fabricCanvas.on('mouse:down', (e) => {
            logger.log("logFD, mouse:down", e.button);
          });

          fabricCanvas.on('selection:created', (e) => {
            logger.log("selection:created", e);
            selectionHandler__default(e);
          });
          fabricCanvas.on('before:transform', (e) => {
            logger.log("before:transform", e);
          });

          fabricCanvas.on('selection:updated', (e) => {
            logger.log("selection:updated", e);
            selectionHandler__default(e);
          });

          fabricCanvas.on('selection:cleared', (e) => {
            logger.log("selection:cleared", e);
            selectionHandler__default(e);
          });

          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          function getSelectionMgmtObject(options) {
            var outObj;

            const arr_fObj = Object.values(fabricIntegration.fabric_objects);

            var arr_selected = (options.selected != null) ? options.selected : [];

            // //scale-aware selection
            // arr_selected = arr_selected.filter(fObj => {
            //   const icObj = fObj.icObj;
            //
            //   const isSelectionAllowed__scaleWise_ = isSelectionAllowed__scaleWise(icObj);
            //   return isSelectionAllowed__scaleWise_;
            // });

            const difference = arr_fObj.filter(x => !arr_selected.includes(x));
            const arr_unselected = difference;

            outObj = {
              arr_selected:   arr_selected,
              arr_unselected: arr_unselected,
            };

            return outObj;
          }

          function processSelectionMgmtObject(selectionMgmtObj, options) {
            logger.log("processSelectionMgmtObject", selectionMgmtObj, options);

            //debug
            selectionMgmtObj.arr_selected.forEach((fObj, i) => {
              fObj.borderColor = ColorUtils.randomColor();
              fObj.borderScaleFactor = 3.0;
            });


            selectionMgmtObj.arr_selected.forEach((fObj, i) => {
              const icObj = fObj.icObj;
              icObj.isSelected = true;
            });
            selectionMgmtObj.arr_unselected.forEach((fObj, i) => {
              const icObj = fObj.icObj;
              icObj.isSelected = false;
            });


            //supervessel
            if (selectionMgmtObj.arr_selected.length == 0) {
              logger.log("selectionMgmtObj.arr_selected.length == 0");

            } else if (selectionMgmtObj.arr_selected.length == 1) {
              logger.log("selectionMgmtObj.arr_selected.length == 1");

              // const fObj__selected  = selectionMgmtObj.arr_selected.find(e => true);
              // const icObj__selected = fObj__selected.icObj;
              // // icObj__selected.nowReleased();
              // //XXX fabricCanvas.dismissActiveObject();
              //
              // const icObj__supervessel = fabricIntegration.getIcObj__supervessel();
              // icObj__supervessel.position = {
              //   x: icObj__selected.position.x,
              //   y: icObj__selected.position.y,
              // };
              //
              // const fObj__supervessel = fabricIntegration.getFObj__supervessel();
              // fabricCanvas.setActiveObject(fObj__supervessel);
              // // icObj__supervessel.nowHeld();
              //
              // const o2 = fObj__supervessel;
              // // fabricCanvas._setupCurrentTransform(o2.e, o2.target);
              //
              // // fabricCanvas.on('mouse:down', function(o) {
              // //   // logger.log("789789");
              // //   // fabricCanvas._setupCurrentTransform(o.e, o.target);
              // //   fabricCanvas._setupCurrentTransform(o2.e, o2.target);
              // // });
              //
              // // fabricCanvas.fire("event:dragleave", () => {
              // //
              // // });
              // // fabricCanvas.fire("event:dragenter", () => {
              // //
              // // });
              //
              // //look for Event instance
              // const e = null;
              // logger.log("options", options);
              // const transform__current = fabricCanvas.getCurrentTransform();
              // logger.log("transform__current", transform__current);
              //
              // fabricCanvas._setupCurrentTransform(e, o2);
              // // fabricCanvas.renderAll();

            } else {
              logger.log("selectionMgmtObj.arr_selected.length > 1");

              const arr_icObj__selected = selectionMgmtObj.arr_selected.map((fObj) => fObj.icObj);

              //create transient composite
              //create composite
              const icObj__selected0 = arr_icObj__selected.find(e => true);
              const trueRect__composite = {
                x: icObj__selected0.position.x,
                y: icObj__selected0.position.y,
                width:  10,
                height: 10,
              };
              const parts = arr_icObj__selected.reduce((acc, icFreeDrawing) => {
                const partName = "selected__" + icFreeDrawing.id;
                acc[partName] = icFreeDrawing;
                return acc;
              }, {});
              const compositeConfig = Compositer.defaultCompositeConfig(parts, false, false);
              const icComposite     = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig); 
              icComposite.cType = "selection";
              icComposite.isEntity = true;
              // icComposite.fillColor = "green";

              //SHU: illusion
              icComposite.fill    = "transparent";
              // icComposite.opacity = 0;

              //add composite 
              infiniteCanvas.addNewIcObject(icComposite);

            }

            selectionMgmtObj__previous = selectionMgmtObj;

          }

        }

        getFObj__supervessel() {
          const fObj__supervessel = this.getFabricObjects().find(fObj => fObj.icObj.isSupervessel);
          return fObj__supervessel;
        }

        getIcObj__supervessel() {
          const icObj__supervessel = this.getFabricObjects().map(fObj => fObj.icObj).find(icObj => icObj.isSupervessel);
          return icObj__supervessel;
        }


        setSupervesselEnabled(enabled) {
          console.log("setSupervesselEnabled", enabled);
          this.isEnabled_supervessel = enabled;
          // this.fabricCanvas.requestRenderAll();
        }


        getFObj__dummy() {
          const fObj__dummy = this.getFabricObjects().find(fObj => fObj.icObj.isDummy);
          return fObj__dummy;
        }




        // debugOriginalAxes() {
        //
        //   this.debugOriginalAxis_X();
        //   this.debugOriginalAxis_Y();
        // }
        //
        // debugOriginalAxis_X() {
        //
        //   // const line = new fabric.Line([0, -100, 0, +100], {
        //   //   left: 0,
        //   //   top: 0,
        //   //   stroke: 'red'
        //   // });
        //   //
        //   // this.addInnerFabricObject(line);
        //
        //   const rect = new fabric.Rect({
        //     left: 0,
        //     top: 0,
        //     width: 1000,
        //     height: 10,
        //     fill: 'blue',
        //   });
        //
        //   this.addInnerFabricObject(rect);
        //
        //
        //
        // }
        //
        // debugOriginalAxis_Y() {
        //
        //   // const line = new fabric.Line([-100, 0, 100, 0], {
        //   //   left: 0,
        //   //   top: 0,
        //   //   stroke: 'red'
        //   // });
        //   //
        //   // this.addInnerFabricObject(line);
        //
        //   const rect = new fabric.Rect({
        //     left: 0,
        //     top: 0,
        //     width: 10,
        //     height: 1000,
        //     fill: 'red',
        //   });
        //
        //   this.addInnerFabricObject(rect);
        //
        // }



        redrawCanvas(redrawOccasion) {
          console.log("redrawCanvas", redrawOccasion);

          switch (redrawOccasion) {

            case RedrawOccasion.offsetChanged:
              this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.scaleChanged: //order is important here
              this.updateFabricObjectsSize(redrawOccasion);
              this.updateFabricObjectsPosition(redrawOccasion);
              break;

            case RedrawOccasion.orientationChanged:
              this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.objectAdded:
              this.updateFabricObjectsPosition(redrawOccasion);
              this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.pureObjectAdded:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.objectRemoved:
              this.updateFabricObjectsPosition(redrawOccasion);
              this.updateFabricObjectsSize(redrawOccasion);
              break;


            case RedrawOccasion.windowResize:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.animation_bounce: //order is important here
              this.updateFabricObjectsSize(redrawOccasion);
              this.updateFabricObjectsPosition(redrawOccasion);
              break;


            case RedrawOccasion.forceRedraw:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            default:
              throw new Error("unknown redraw occasion:" + redrawOccasion);
              break;
          }

          this.fabricCanvas.renderAll(); //SHU: render only what is visible (is fabric smart enough ?)
        }


        synchronizeWithIcObjects(icObjects) {

          icObjects.any.forEach((icObj, i) => {
            this.addFabricObjectWithIcObj(icObj);
          });

        }

        fObjZIndexForIcObj(icObj) {
          var outIndex;

          //get zIndex-ordered icObj array
          const arr_icObj = Object.values(fabricIntegration.fabric_objects).map(fObj => fObj.icObj);


          //create order dict
          var mapped = arr_icObj.map(function (icObj_elt, i) {
            const mapped_obj = {
              index: i,
              object: icObj_elt,
              sortingValue: icObj_elt.zIndex,
            };

            return mapped_obj;
          })

          mapped.sort(function (a, b) {
            if (a.sortingValue > b.sortingValue) {
              return 1;
            }
            if (a.sortingValue < b.sortingValue) {
              return -1;
            }
            return 0;
          });
          // console.log("mapped", mapped);

          const dict_indexForObjectId = mapped.reduce((acc, mappedObj, index) => {
            // console.log("mappedObj", mappedObj, "index", index);
            const id_object = mappedObj.object.id;
            acc[id_object] = index;
            return acc;
          }, {});
          // console.log("dict_indexForObjectId", dict_indexForObjectId);


          //get index in order dict
          outIndex = dict_indexForObjectId[icObj.id];

          return outIndex;
        }

        fObjZIndexForIcZIndex(zIndex__ic) {
          var outIndex;

          //get zIndex-ordered icObj array
          const arr_icObj = Object.values(fabricIntegration.fabric_objects).map(fObj => fObj.icObj);


          //create order dict
          var mapped = arr_icObj.map(function (icObj_elt, i) {
            const mapped_obj = {
              index: i,
              object: icObj_elt,
              sortingValue: icObj_elt.zIndex,
            };

            return mapped_obj;
          });

          mapped.sort(function (a, b) {
            if (a.sortingValue > b.sortingValue) {
              return 1;
            }
            if (a.sortingValue < b.sortingValue) {
              return -1;
            }
            return 0;
          });

          const zIndex__fObj = Utils.early_break_reduce(mapped, (acc, x, i, arr) => {
            const x__zIndex = x.sortingValue;

            if(zIndex__ic < x__zIndex) {
              acc = {
                found: true,
                index: i,
              };
            }
            return acc;
          }, {
            found: false,
            index: mapped.length,
          }, (acc, x, i, arr) => {
            return acc.found;  
          }).index;

          outIndex = zIndex__fObj;

          return outIndex;
        }


        addFabricObjectWithIcObj(icObj__r_free) {
          logger.log("logRecycle", "addFabricObjectWithIcObj", icObj__r_free.type);
          const fabricIntegration = this;
          const fabricCanvas = this.fabricCanvas;

          const infiniteCanvas = this.infiniteCanvas;

          console.log("addFabricObjectWithIcObj", "icObj", icObj__r_free);
          // const fObj = this.createFabricObjectWithIcObj(icObj);

          // var icObj_fRep = icObj__r_free.createSisterRepresentation();
          var icObj_fRep = icObj__r_free;

          //recycle if possible
          var fObj_p;
          const fObj__to_recycle = fabricIntegration.getFObj_with_id_recycle(icObj__r_free.id);
          if(fObj__to_recycle != null) {
            fObj_p = fabricIntegration.recycleFabricObjectForIcObj_p(icObj_fRep, fObj__to_recycle);
          } else {
            fObj_p = fabricIntegration.createFabricObjectWithIcObj_p(icObj_fRep);
          }

          fObj_p.then(fObj => {
            manageCreatedFObj(fObj);
          });

          function manageCreatedFObj(fObj) {

            function standardRedraw(fObj) {
              const icObj = fObj.icObj;
              fObj.set({
                opacity: icObj.opacity,
                fill: icObj.fill,
              });

              if (icObj.text) {
                console.log("fObj", fObj);
                fObj.set({
                  text: icObj.text,
                  fill: icObj.textColor,
                });
              }

              switch (icObj.type) {
                case "mnrei_rectangle":
                  fObj.set({
                    width:  icObj.size.width,
                    height: icObj.size.height,
                  });
                  break;
                case "segment":
                  logger.log("standardRedraw: segment");
                  fObj.set({
                    x1: icObj.point_start.x,
                    y1: icObj.point_start.y,
                    x2: icObj.point_end.x,
                    y2: icObj.point_end.y,
                  });
                  break;
                // case "polygon":
                //   {
                //     fObj.set({
                //       points: icObj.arr_point,
                //     });

                //     // const position_screen = icObj.getScreenPositionWithoutOffset();
                //     // // console.log("position_screen", position_screen);
                //     // const homeSize_screen = icObj.getHomeScreenSize();
                //     // // console.log("homeSize_screen", homeSize_screen);

                //     // fObj.set({
                //     //   left: position_screen.x,
                //     //   top:  position_screen.y,
                //     //   width:  homeSize_screen.width,
                //     //   height: homeSize_screen.height,

                //     //   rx: homeSize_screen.width  / 2.0,
                //     //   ry: homeSize_screen.height / 2.0,

                //     //   points: icObj.arr_point,
                //     // });

                //     fObj.setCoords();
                //   }
                //   break;
                case "arc_of_circle":
                  if (fObj.isDirty__clipPath) {
                    logger.log("standardRedraw:", "arc_of_circle", icObj.arcStart, icObj.arcEnd);
                    //set clipPath (arc of square)
                    const clipPath = fabricIntegration.createFabricClipPath_ArcOfSquare(icObj.radius, icObj.strokeWidth, icObj.arcStart, icObj.arcEnd);
                    fObj.set({
                      clipPath: clipPath,
                    });
                    fObj.isDirty__clipPath = false;
                  }
                  break;
                case "image":
                  {
                    // logger.log("standardRedraw:", "image", icObj.img);
                    fObj.setElement(icObj.img);
                    fObj.setCoords();
                  }
                  break;
                case "video":
                  {
                    // logger.log("standardRedraw:", "video", icObj.video);
                    fObj.setElement(icObj.video);
                    fObj.setCoords();
                  }
                  break;
                case "icCanvas":
                  {
                    logger.log("logICIC", "standardRedraw", "icCanvas");
                    const fabricCanvas    = icObj.dict__iC.fabricIntegration.fabricCanvas;
                    const el__lowerCanvas = fabricCanvas.lowerCanvasEl;
                    fObj.setElement(el__lowerCanvas);
                    fObj.setCoords();
                  }
                  break;
                default:
                  break;
              }

              fabricIntegration.updateFabricObject_size_default(fObj);
              fabricIntegration.updateFabricObject_position_default(fObj);

              fabricCanvas.renderAll();
            }

            // function hardRedraw() {   //REDRAw HACK
            //   infiniteCanvas.updateScaleAndDOffset({
            //     X: infiniteCanvas.scale.X * (1.0 + 1e-10),
            //     Y: infiniteCanvas.scale.Y * (1.0 + 1e-10),
            //   }, { dx: 0, dy: 0 });
            //   infiniteCanvas.redrawCanvas(RedrawOccasion.scaleChanged);
            // }

            const innerUpdateListener = (icObj_fRep, propName, oldValue, newValue) => {
              // logger.log("innerUpdateListener", icObj_fRep.id_rep, propName, newValue);

              if (propName == "im_dying_now") {
                console.log("im_dying_now");
                if (icObj_fRep.im_dying_now) {
                  fabricIntegration.removeFabricObject(fObj);
                  icObj_fRep.im_dying_now = false;
                  icObj_fRep.im_dead_now = true;
                }
              }
              else if (propName == "im_active_now") {
                console.log("im_active_now");
                if (icObj_fRep.im_active_now) {
                  fabricIntegration.fabricCanvas.setActiveObject(fObj);
                }
              }
              else if (propName == "isLocked") {
                console.log("isLocked");
                if (icObj_fRep.isLocked) {
                  fabricIntegration.lockFObj(fObj);
                }
                else {
                  fabricIntegration.unlockFObj(fObj);
                }
              }
              else if (propName == "icObj__activeSelection") {
                console.log("icObj__activeSelection");
                if (icObj_fRep.icObj__activeSelection != null) {
                  //switch to group coordinates

                } else {
                  //back to individual coordinates

                }
              }

              // else if(propName == "isHeld") {
              //   console.log("innerUpdate", "isHeld");
              // }
              else if (propName == "zIndex") {
                const zIndex_icObj = icObj_fRep.zIndex;
                console.log("zIndex_icObj", zIndex_icObj);

                // fObj.moveTo(zIndex_icObj);
                const zIndex_fObj__target = fabricIntegration.fObjZIndexForIcObj(icObj_fRep);
                fObj.moveTo(zIndex_fObj__target);

                //debug
                const zIndex_fObj__actual = fObj.getFObjZIndex();
                console.log("zIndex_fObj__actual", zIndex_fObj__actual);
              }


              // else if(propName == "text") {
              //   logger.log("innerUpdate, text", fObj.text);
              //   standardRedraw(fObj);
              // }
              else if (propName == "tex"
                || propName == "mathNode"
                || propName == "richMathNode") {

                if (fObj.refreshTex_p != null) {
                  fObj.refreshTex_p()
                    .then((fObj) => {
                      standardRedraw(fObj);
                      // hardRedraw();
                    });
                }

              }
              else if (propName == "htmlElt") {
                fObj.refreshScreenshot_p()
                  .then((fObj) => {
                    standardRedraw(fObj);
                  });
              }
              else if (propName == "el_html") {
                fObj.refreshScreenshot_p()
                  .then((fObj) => {
                    standardRedraw(fObj);
                  });
              }
              else if (propName == "arcStart" || propName == "arcEnd") {
                fObj.isDirty__clipPath = true;
                standardRedraw(fObj);
              }
              else if (propName == "point_start" || propName == "point_end") {
                standardRedraw(fObj);
              } 
              else if(propName == "arr_point") {
                logger.log("logZSegment", "innerUpdate", "arr_point", icObj.arr_point);
                const arr_point = icObj.arr_point;

                if(icObj.type == "compositeSegment") {
                  fObj.set({
                    points: arr_point,
                  });
                  fObj._setPositionDimensions({});
                  fObj.setCoords();
  
                  standardRedraw(fObj);
                } else {
                  //composite curve
                }
                
              }
              else if (propName == "img") {
                // fObj.refreshImg_p()
                // .then((fObj) => {
                //   standardRedraw(fObj);
                // });
                logger.log("log1", "icObj_fRep", "onInnerUpdate", "img", icObj_fRep);

                fObj.setElement(icObj.img);
                fObj.setCoords();
                fabricCanvas.renderAll();   //added for icVideo img refresh
                // standardRedraw(fObj);
              }
              else if (propName == "video") {
                // fObj.refreshImg_p()
                // .then((fObj) => {
                //   standardRedraw(fObj);
                // });
                console.log("icObj_fRep", "onInnerUpdate", "video", icObj_fRep);
                fObj.setElement(icObj.video);
                fObj.setCoords();
              }
              else if (propName == "backgroundColor") {
                // logger.log("innerUpdateListener", "backgroundColor");
                fObj.set({
                  backgroundColor: newValue,
                });
                standardRedraw(fObj);
              }
              else if (propName == "stroke") {
                // logger.log("logUp", "innerUpdateListener", "stroke");
                if (fObj.refreshTex_p != null) {
                  fObj.refreshTex_p()
                    .then((fObj) => {
                      standardRedraw(fObj);
                      // hardRedraw();
                    });
                } else {
                  standardRedraw(fObj);
                }
              } else if (propName == "strokeWidth") {
                // logger.log("innerUpdateListener", "strokeWidth");
                fObj.set({
                  strokeWidth: newValue,
                });
                standardRedraw(fObj);
              } else if (propName == "exoObject") {
                // logger.log("innerUpdateListener", "exoObject");
                const exoObject__new = newValue;
                fObj.set({
                  stroke:      exoObject__new.stroke,
                  strokeWidth: exoObject__new.strokeWidth,
                  //etc.
                });
                standardRedraw(fObj);
              }
              else {
                // logger.log("icObj_fRep","onInnerUpdate", icObj_fRep);
                standardRedraw(fObj);

                // if(icObj.type == "sparkle") {
                //
                // }
              }

            };
            fObj.fListener_inner = innerUpdateListener;
            icObj_fRep.onInnerUpdate(innerUpdateListener);

            // const outerUpdateListener = (icObj_fRep) => {
            const outerUpdateListener = (icObj_fRep, propName, oldValue, newValue) => {
              // logger.log("outerUpdateListener", icObj_fRep.id_rep, propName, newValue);

              if (propName == "im_dying_now") {
                console.log("im_dying_now");
                if (icObj_fRep.im_dying_now) {
                  fabricIntegration.removeFabricObject(fObj);
                  icObj_fRep.im_dying_now = false;
                  icObj_fRep.im_dead_now = true;
                }
              }
              else if (propName == "isLocked") {
                console.log("isLocked");
                if (icObj_fRep.isLocked) {
                  fabricIntegration.lockFObj(fObj);
                }
                else {
                  fabricIntegration.unlockFObj(fObj);
                }
              }
              // else if(propName == "isHeld") {
              //   console.log("outerUpdate", "isHeld");
              // }
              else if (propName == "text") {
                // logger.log("outerUpdate, text", fObj.text);
                standardRedraw(fObj);
              }
              else if (propName == "tex"
                || propName == "mathNode"
                || propName == "richMathNode") {

                if (fObj.refreshTex_p != null) {
                  fObj.refreshTex_p()
                    .then((fObj) => {
                      standardRedraw(fObj);
                      // hardRedraw();
                    });
                }

              }
              else if (propName == "htmlElt") {
                fObj.refreshScreenshot_p()
                  .then((fObj) => {
                    standardRedraw(fObj);
                  });
              }
              else if (propName == "el_html") {
                fObj.refreshScreenshot_p()
                  .then((fObj) => {
                    standardRedraw(fObj);
                  });
              }
              else if (propName == "img") {
                console.log("log1", "icObj_fRep", "onOuterUpdate", "img", icObj_fRep);

                // fObj.refreshImg_p()
                // .then((fObj) => {
                //   standardRedraw(fObj);
                // });

                fObj.setElement(icObj.img);
                fObj.setCoords();
              }
              else if (propName == "video") {
                console.log("icObj_fRep", "onOuterUpdate", "video", icObj_fRep);

                // fObj.refreshImg_p()
                // .then((fObj) => {
                //   standardRedraw(fObj);
                // });

                fObj.setElement(icObj.video);
                fObj.setCoords();
              }
              else {
                console.log("icObj_fRep", "onOuterUpdate", icObj_fRep);
                standardRedraw(fObj);
              }

            };
            fObj.fListener_outer = outerUpdateListener;
            icObj_fRep.onOuterUpdate(outerUpdateListener);


            // if(icObj_fRep.onHold != null) {
            //   icObj_fRep.onHold((icObj) => {
            //
            //   });
            // }
            //
            // if(icObj_fRep.onRelease != null) {
            //   icObj_fRep.onRelease((icObj) => {
            //
            //   });
            // }


            if (fObj.id_recycle != null) {
              fabricIntegration.addInnerFabricObject(fObj);
            } else {
              fabricIntegration.addOuterFabricObject(fObj);
            }

            //"initial refresh"
            const icObj = fObj.icObj;
            if (icObj.type == "tex"
              || icObj.type == "mathNode"
              || icObj.type == "richMathNode") {

              if (fObj.refreshTex_p != null) {
                fObj.refreshTex_p()
                  .then((fObj) => {
                    fabricCanvas.renderAll();
                    standardRedraw(fObj);         //SHU: rajouté pour que les TeX (tout simples) spawnent correctement
                    // hardRedraw();
                  });
              }

            }
            else if (icObj.type == "htmlElt") {
              fObj.refreshScreenshot_p()
                .then((fObj) => {
                  fabricCanvas.renderAll();
                });
            }
            else if (icObj.type == "htmlObject") {
              fObj.refreshScreenshot_p()
                .then((fObj) => {
                  fabricCanvas.renderAll();
                });
            }

            if (icObj.im_active_now) {
              fabricIntegration.fabricCanvas.setActiveObject(fObj);

              icObj.nowHeld();

              //SHU TODO
              //while held, position offset should follow cursor offset     (a DSL would be nice someday)

            }

            standardRedraw(fObj);

          }

        }

        lockFObj(fObj) {
          fObj.lockMovementX = true;
          fObj.lockMovementY = true;
          fObj.lockRotation = true;
          fObj.lockScalingFlip = true;
          fObj.lockScalingX = true;
          fObj.lockScalingY = true;
          fObj.lockSkewingX = true;
          fObj.lockSkewingY = true;

          fObj.selectable = false;
        }

        unlockFObj(fObj) {
          fObj.lockMovementX = false;
          fObj.lockMovementY = false;
          fObj.lockRotation = false;
          fObj.lockScalingFlip = false;
          fObj.lockScalingX = false;
          fObj.lockScalingY = false;
          fObj.lockSkewingX = false;
          fObj.lockSkewingY = false;

          fObj.selectable = true;
        }


        recycleFabricObjectForIcObj_p(icObj, fObj) {
          logger.log("logRecycle", "recycleFabricObjectForIcObj_p", icObj, fObj);

          const infiniteCanvas = this.infiniteCanvas;

          fObj.set({
            icObj: icObj,
          });

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }

          this.addInteraction_select(fObj);
          // this.addListeners(fObj);



          fObj.hasBorders = true;


          const fObj_p = Promise.resolve(fObj);

          return fObj_p;
        }


        addFabricObjectWithPureIcObj(icObj) {

          const fObj = this.createFabricObjectWithIcObj(icObj);

          if (fObj) {
            this.addPureOuterFabricObject(fObj);
          }

        }

        createFabricObjectWithIcObj_p(icObj) {
          var fObj_p = null;

          switch (icObj.type) {
            case "rect":
            case "povRect":
              {
                const fObj = this.createFabricRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "printPovRect":
                {
                  const fObj = this.createFabricRectWithIcObj(icObj);
                  fObj_p = Promise.resolve(fObj);
                }
                break;
            case "text":
            case "tag":
              {
                const fObj = this.createFabricITextWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "image":
              {
                const fObj = this.createFabricImageWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "patternRectImage":
              {
                const fObj = this.createFabricPatternRectImageWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "video":
              {
                const fObj = this.createFabricVideoWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "audio":
              {
                const fObj = this.createFabricAudioWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "point":
              {

                var fObj;
                switch (icObj.pointType) {
                  case "rect":
                    fObj = this.createFabricRectWithIcPoint(icObj);
                    break;
                  case "cross":
                    fObj = this.createFabricCrossWithIcObj(icObj);
                    break;
                  case "circle":
                    fObj = this.createFabricCircleWithIcPoint(icObj);
                    break;
                  case "composite":
                    fObj = this.createFabricCompositeWithIcObj__point(icObj);
                    break;
                  default:
                    // fObj = this.createFabricRectWithIcPoint(icObj);
                    fObj = this.createFabricCircleWithIcPoint(icObj);
                    break;
                }

                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "spotPoint":
              {
                const fObj = this.createFabricSpotPointWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            case "curve3":
              {
                const fObj = this.createFabricCurve3WithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "circle":
              {
                const fObj = this.createFabricCircleWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "ellipse":
              {
                const fObj = this.createFabricEllipseWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            case "arc_of_square":
              {
                const fObj = this.createFabricArcOfSquareWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "arc_of_circle":
              {
                const fObj = this.createFabricArcOfCircleWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "arc_of_ellipse":
              {
                const fObj = this.createFabricArcOfEllipseWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "arc_of_path":
              {
                const fObj = this.createFabricArcOfPathWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "polygon":
              {
                const fObj = this.createFabricPolygon(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "freeDrawing":
              {
                // fObj = this.createFabricPolylineWithIcFreeDrawing(icObj);
                const fObj = this.createFabricFreeDrawingWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "floodFill":
              {
                const fObj = this.createFabricFloodFillWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "svg":
              {
                fObj_p = this.createFabricSvgWithIcObj_p(icObj);
              }
              break;

            case "tex":
              {
                const fObj = this.createFabricTexWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "bigTex":
              {
                const fObj = this.createFabricBigTexWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "htmlObject":
              {
                const fObj = this.createFabricHtmlObjectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            case "mathNode":
              {
                const fObj = this.createFabricMathNodeWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "richMathNode":
              {
                const fObj = this.createFabricRichMathNodeWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "mnrei_rectangle":
              {
                const fObj = this.createFabricRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "htmlElt":
              {
                const fObj = this.createFabricHtmlEltWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;



            case "group":
              {
                const fObj = this.createFabricGroupWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;





            case "toggleRect":
              {
                const fObj = this.createFabricToggleRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            case "snapSlot":
              {
                const fObj = this.createFabricSnapSlotWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "touchSlot":
              {
                const fObj = this.createFabricTouchSlotWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "dropTouchSlot":
              {
                const fObj = this.createFabricDropTouchSlotWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "applySlot":
                {
                  const fObj = this.createFabricApplySlotWithIcObj(icObj);
                  fObj_p = Promise.resolve(fObj);
                }
                break;
            case "diveSlot":
              {
                const fObj = this.createFabricDiveSlotWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "pokeSlot":
              {
                const fObj = this.createFabricPokeSlotWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;



            case "composite":
              {
                const fObj = this.createFabricCompositeWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "button":
              {
                const fObj = this.createFabricButtonWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;




            case "well":
              {
                const fObj = this.createFabricWellWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "greenMouseWell":
              {
                const fObj = this.createFabricGreenMouseWellWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            case "rxSubject":
              {
                const fObj = this.createFabricRxSubjectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "rxSubscription":
              {
                const fObj = this.createFabricRxSubscriptionWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;



            case "observer":
              {
                const fObj = this.createFabricRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "trigger":
              {
                const fObj = this.createFabricRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "eventEmitter":
              {
                const fObj = this.createFabricRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "eventReceiver":
              {
                const fObj = this.createFabricRectWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "eye":
              {
                const fObj = this.createFabricEyeWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;
            case "display":
                {
                  const fObj = this.createFabricDisplayWithIcObj(icObj);
                  fObj_p = Promise.resolve(fObj);
                }
                break;



            case "line":
              {
                const fObj = this.createFabricLineWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "segment":
              // case "vibratingSegment":
              {
                const fObj = this.createFabricSegmentWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "spotLine":
              {
                const fObj = this.createFabricLineWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "spotSegment":
              {
                const fObj = this.createFabricSegmentWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "HUD_line":
              {
                const fObj = this.createFabricLineWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "HUD_segment":
              {
                const fObj = this.createFabricSegmentWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "compositeSegment":
              {
                const fObj = this.createFabricCompositeWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;





            case "replay":
              {
                const fObj = this.createFabricReplayWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

            case "pathmadeOperator":
              {
                const fObj = this.createFabricPathmadeOperatorWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;



            case "sparkle":
              {
                const fObj = this.createFabricSparkleWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;

              
            case "icCanvas":
              {
                const fObj = this.createFabricCanvasWithIcObj(icObj);
                fObj_p = Promise.resolve(fObj);
              }
              break;


            default:
              throw new Error("addFabricObjectWithIcObj " + "unsupported type: " + icObj.type);
              break;
          }

          //common props
          fObj_p = fObj_p.then(fObj => {
            fObj.opacity = icObj.opacity;

            if (icObj.isLocked) {
              this.lockFObj(fObj);
            }

            return fObj;
          });

          return fObj_p;
        }


        createFabricRectWithIcObj(icObj) {
          console.log("createFabricRectWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          // if(icObj.homeScale != null) {
          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,


            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,

            // fill: '#f55',
            // fill: 'red',
            fill: icObj.fill,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });
          // } else {

          // }


          if (icObj.isSharpRect) {
            fObj.set({
              rx: 0,
              ry: 0,
            });
          }

          if (icObj.originX != null) {
            fObj.set({
              originX: icObj.originX,
            });
          }
          if (icObj.originY != null) {
            fObj.set({
              originY: icObj.originY,
            });
          }

          if (icObj.isUsingCenterPosition != null && icObj.isUsingCenterPosition) {
            fObj.set({
              originX: icObj.originX,
              originY: icObj.originY,
            });
          }

          // console.log("----", "fObj", fObj);

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);




          //debug
          // fObj.setControlsVisibility({
          //    mt: false,
          //    mb: false,
          //    ml: false,
          //    mr: false,
          //
          //    tl: true,
          //    tr: false,
          //    br: false,
          //    bl: false,
          //
          //    mtr: true,
          // });

          // fObj.hasControls = false;
          fObj.hasBorders = true;


          return fObj;

        }

        createFabricRectWithIcPoint(icObj) {
          console.log("createFabricRectWithIcPoint", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          const point_precision_factor = 100;
          const pointSize = {
            width: point_precision_factor,
            height: point_precision_factor,
          };
          const pointScale = {
            X: point_precision_factor * infiniteCanvas.scale.X,
            Y: point_precision_factor * infiniteCanvas.scale.Y,
          };

          var fObj = this.createFabricRectWithIcObj(icObj);
          fObj.set({
            width: pointSize.width,
            height: pointSize.height,

            strokeWidth: 1,
            stroke: "pink",
            fill: "black",

            originX: "center",
            originY: "center",

            icObj: icObj,
          });

          // var fRect = this.createFabricRectWithIcObj(icObj);
          // fRect.set({
          //   width:  pointSize.width,
          //   height: pointSize.height,
          //
          //   strokeWidth: 1,
          //   stroke: "pink",
          //   fill: "black",
          //
          //   originX: "center",
          //   originY: "center",
          // });
          //
          // var fObj = new fabric.Group();
          // fObj.addWithUpdate();
          // fObj.set({
          //   scaleX: pointScale.X,
          //   scaleY: pointScale.Y,
          //
          //   icObj: icObj,
          // });

          return fObj;
        }


        createFabricITextWithIcObj(icObj) {
          // console.log("createFabricITextWithIcObj", icObj);

          // const scale = this.infiniteCanvas.scale;

          var fObj = new fabric.IText(icObj.text);
          fObj.set({
            left: icObj.position.x,
            top:  icObj.position.y,
            // width:  100,
            // height: 100,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,


            fontSize: icObj.fontSize,

            // scaleX: scale,
            // scaleY: scale,

            // fill: '#f55',
            // fill: 'black',
            fill: icObj.textColor,
            backgroundColor: icObj.backgroundColor ? icObj.backgroundColor : "",

            // opacity: 0.7,


            //~'persistent'
            // birth_scale : birth_scale,

            // trueRect : trueRect,
            // true_fontSize : true_fontSize,
            icObj: icObj,

          });

          if (icObj.isUsingCenterPosition != null && icObj.isUsingCenterPosition) {
            fObj.set({
              originX: icObj.originX,
              originY: icObj.originY,
            });
          }

          //initial size poll
          icObj.size = {          //SHU TODO: convert screen coords to infiniteCanvas coords
            width: fObj.width,
            height: fObj.height,
          };

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          this.addInteraction_editText(fObj);

          return fObj;
        }

        createFabricImageWithIcObj(icObj) {

          // const scale  = infiniteCanvas.scale;

          var fObj = new fabric.Image(icObj.img);

          fObj.set({
            left: icObj.position.x,
            top:  icObj.position.y,

            // width:  icObj.img.width,
            // height: icObj.img.height,

            // width:  icObj.size.width,
            // height: icObj.size.height,

            width:  100,
            height: 100,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            icObj: icObj,
          });


          if (icObj.force_width) {
            const factor__force_width = icObj.width / icObj.img.width;
            fObj.set({
              scaleX: fObj.scaleX * factor__force_width,
            });
          }
          if (icObj.force_height) {
            const factor__force_height = icObj.height / icObj.img.height;
            fObj.set({
              scaleY: fObj.scaleY * factor__force_height,
            });
          }

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }

        createFabricPatternRectImageWithIcObj(icObj) {

          // const scale  = infiniteCanvas.scale;

          var fObj = new fabric.Rect();

          FileIntegration.dataUrlForImgViaCanvas_p(icObj.img).then(dataURL => {

            fabric.util.loadImage(dataURL, function(img) {
              const pattern = new fabric.Pattern({
                source: img,
                repeat: false,
              });
              fObj.set({
                fill: pattern,
              });
            });

          });



          fObj.set({
            left: icObj.position.x,
            top:  icObj.position.y,

            // width:  icObj.img.width,
            // height: icObj.img.height,

            // width:  icObj.size.width,
            // height: icObj.size.height,

            width:  icObj.size.width,
            height: icObj.size.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,


            // fill: pattern,
            // fill: "blue",


            icObj: icObj,
          });


          if (icObj.force_width) {
            const factor__force_width = icObj.width / icObj.img.width;
            fObj.set({
              scaleX: fObj.scaleX * factor__force_width,
            });
          }
          if (icObj.force_height) {
            const factor__force_height = icObj.height / icObj.img.height;
            fObj.set({
              scaleY: fObj.scaleY * factor__force_height,
            });
          }

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }

        createFabricVideoWithIcObj(icObj) {
          logger.log("log1", "createFabricVideoWithIcObj", icObj);

          // const scale  = infiniteCanvas.scale;

          var fObj = new fabric.Image(icObj.canvasElt);

          fObj.set({
            left: icObj.position.x,
            top: icObj.position.y,

            // width:  icObj.video.width,
            // height: icObj.video.height,

            // width:  icObj.size.width,
            // height: icObj.size.height,

            width: 100,
            height: 100,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            objectCaching: false,  //??


            strokeWidth: 2,
            stroke: "yellow",

            fill: "cyan",

            icObj: icObj,
          });


          if (icObj.force_width) {
            const factor__force_width = icObj.width / icObj.img.width;
            fObj.set({
              scaleX: fObj.scaleX * factor__force_width,
            });
          }
          if (icObj.force_height) {
            const factor__force_height = icObj.height / icObj.img.height;
            fObj.set({
              scaleY: fObj.scaleY * factor__force_height,
            });
          }

          fObj.setCoords();


          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }

        createFabricAudioWithIcObj(icObj) {
          logger.log("log1", "createFabricAudioWithIcObj", icObj);

          var fObj = this.createFabricRectWithIcObj(icObj);

          return fObj;
        }




        createFabricSpotPointWithIcObj(icObj) {
          logger.log("createFabricSpotPointWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Circle();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          logger.log("homeSize_screen", homeSize_screen);

          fObj.set({
            // left: position_screen.x,
            // top:  position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            // radius: icObj.radius,
            radius: icObj.size.width / 2.0,

            strokeWidth: icObj.strokeWidth,
            // stroke: 'blue',
            stroke: icObj.stroke,


            // fill: '#f55',
            // fill: 'red',
            // fill: '',
            fill: icObj.fill,


            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          if (icObj.isUsingCenterPosition != null && icObj.isUsingCenterPosition) {
            fObj.set({
              originX: "center",
              originY: "center",
            });
          }

          fObj.setPositionByOrigin(icObj.position, "center", "center");

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }


        createFabricCircleWithIcPoint(icObj) {
          logger.log("createFabricCircleWithIcPoint", icObj);

          const fabricIntegration = this;

          // console.log("createFabricCircleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Circle();

          const radius__default = 5;

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,


            radius: radius__default,

            // fill: '#f55',
            // fill: 'blue',
            fill: icObj.fillColor,

            stroke: 'black',
            strokeWidth: 2,

            // opacity: 0.7,

            originX: "center",
            originY: "center",

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          // if(icObj.canBeResized) {
          //   this.addInteraction_resize2(fObj);
          // }
          // if(icObj.canBeRotated) {
          //   this.addInteraction_rotate(fObj);
          // }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;

        }

        createFabricCrossWithIcObj(icObj) {
          logger.log("createFabricCrossWithIcObj", icObj);

          const fabricIntegration = this;
          const infiniteCanvas = this.infiniteCanvas;

          const radius__default = 100;
          const strokeWidth__default = 0.05;

          const position_screen = icObj.getScreenPositionWithoutOffset();
          logger.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          logger.log("homeSize_screen", homeSize_screen);

          var fRect1 = new fabric.Rect(); //horizontal rect
          fRect1.set({
            width: 2 * radius__default,
            height: strokeWidth__default,

            originX: "center",
            originY: "center",

            cornerStyle: '',
            rx: 0,
            ry: 0,

            stroke: "black",
            strokeWidth: strokeWidth__default,

            fill: "black",
          });

          var fRect2 = new fabric.Rect(); //vertical rect
          fRect2.set({
            width: strokeWidth__default,
            height: 2 * radius__default,

            originX: "center",
            originY: "center",

            cornerStyle: '',
            rx: 0,
            ry: 0,

            stroke: "black",
            strokeWidth: strokeWidth__default,

            fill: "black",
          });


          var fCross = new fabric.Group();
          fCross.set({
            width: 2 * radius__default,
            height: 2 * radius__default,

            originX: "center",
            originY: "center",
          });
          fCross.add(...[fRect1, fRect2]);
          // fCross.addWithUpdate(...[fRect1,fRect2]);

          var fObj = fCross;
          fCross.set({

            scaleX: infiniteCanvas.scale.X * 100,
            scaleY: infiniteCanvas.scale.X * 100,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,
            // angle : 45,

            // fill: '#f55',
            // fill: 'blue',
            // fill: icObj.fillColor,

            originX: "center",
            originY: "center",


            // opacity: 0.7,
            icObj: icObj,
          });

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          // if(icObj.canBeResized) {
          //   this.addInteraction_resize2(fObj);
          // }
          // if(icObj.canBeRotated) {
          //   this.addInteraction_rotate(fObj);
          // }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }



        createFabricCurve3WithIcObj(icObj) {
          logger.log("logFabric", "createFabricCurve3WithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          const arr_point__icObj = icObj.arr_point;
          const size__icObj      = icObj.size;
          
          //offset all points
          const offset = {
            dx: - icObj.position.x - size__icObj.width  / 2.0,
            dy: - icObj.position.y - size__icObj.height / 2.0,
          };
          const arr_point__offsetted = arr_point__icObj.map((point_raw) => {
            return Geometry.createPointWithOffset(point_raw, offset);
          });  

          //create square
          var fObj = new fabric.Curve3(arr_point__offsetted.slice(0,3));

          fObj.set({
            width:    size__icObj.width,
            height:   size__icObj.height,

            originX: "left",
            originY: "top",

            stroke: "magenta",
            strokeWidth: 3,

            icObj: icObj,
          });

          return fObj;
        }



        createFabricCircleWithIcObj(icObj) {
          logger.log("createFabricCircleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Circle();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,
            top:  position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            radius: icObj.radius,

            strokeWidth: icObj.strokeWidth,
            // stroke: 'blue',
            stroke: icObj.stroke,


            // fill: '#f55',
            // fill: 'red',
            // fill: '',
            fill: icObj.fill,


            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          if (icObj.isUsingCenterPosition != null && icObj.isUsingCenterPosition) {
            fObj.set({
              originX: "center",
              originY: "center",
            });
          }

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }


        createFabricEllipseWithIcObj(icObj) {
          logger.log("createFabricEllipseWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Ellipse();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            //radius: icObj.radius,
            rx: homeSize_screen.width  / 2.0,
            ry: homeSize_screen.height / 2.0,

            // fill: '#f55',
            // fill: 'red',
            // fill: '',
            fill: icObj.fill,

            // stroke: 'blue',
            stroke: icObj.stroke,
            strokeWidth: 5,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }


        createFabricArcOfSquareWithIcObj(icObj) {
          logger.log("createFabricArcOfSquareWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          //create square
          var fObj = this.createFabricRectWithIcObj(icObj);

          //set clipPath
          const radius = icObj.radius + icObj.strokeWidth;;

          const point0 = Geometry.createPoint(0, 0);
          const pointC1 = Geometry.pointOnSquare__angleInDegrees(point0, radius, icObj.arcStart);
          const pointC2 = Geometry.pointOnSquare__angleInDegrees(point0, radius, icObj.arcEnd);

          const arr_angle__corners = [...Array(4).keys()].map(index => 45 + index * 90);
          logger.log("arr_angle__corners", arr_angle__corners);
          const dict_point__corners = Object.fromEntries(arr_angle__corners.map(angle => {
            const point = Geometry.pointOnSquare__angleInDegrees(point0, radius, angle);
            return [angle, point];
          }));

          const dict_point__arc = {
            [icObj.arcStart]: pointC1,
            [icObj.arcEnd]: pointC2,
          };

          const dict_point = Object.assign(dict_point__corners, dict_point__arc);
          logger.log("dict_point", dict_point);

          var arr_point = Object.entries(dict_point).filter(([angle, point]) => {
            const isBetween = (icObj.arcStart <= angle) && (angle <= icObj.arcEnd);
            return isBetween;
          }).sort((e1, e2) => {
            return e1.angle < e2.angle;
          }).map(([angle, point]) => point);
          logger.log("arr_point", arr_point);

          arr_point = [point0].concat(arr_point);

          var clipPath = new fabric.Polygon(arr_point);

          logger.log("clipPath", clipPath);
          fObj.clipPath = clipPath;

          return fObj;
        }


        createFabricArcOfCircleWithIcObj(icObj) {
          logger.log("createFabricArcOfCircleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          //create circle
          var fObj = this.createFabricCircleWithIcObj(icObj);

          //set clipPath (arc of square)
          var clipPath = this.createFabricClipPath_ArcOfSquare(icObj.radius, icObj.strokeWidth, icObj.arcStart, icObj.arcEnd);
          logger.log("clipPath", clipPath);

          fObj.clipPath = clipPath;

          return fObj;
        }

        createFabricClipPath_ArcOfSquare(radius_in, strokeWidth, arcStart, arcEnd) {
          const radius = radius_in + strokeWidth;

          const point0 = Geometry.createPoint(0, 0);
          const pointC1 = Geometry.pointOnSquare__angleInDegrees(point0, radius, arcStart);
          const pointC2 = Geometry.pointOnSquare__angleInDegrees(point0, radius, arcEnd);

          const arr_angle__corners = [...Array(4).keys()].map(index => 45 + index * 90);
          logger.log("arr_angle__corners", arr_angle__corners);
          const dict_point__corners = Object.fromEntries(arr_angle__corners.map(angle => {
            const point = Geometry.pointOnSquare__angleInDegrees(point0, radius, angle);
            return [angle, point];
          }));

          const dict_point__arc = {
            [arcStart]: pointC1,
            [arcEnd]: pointC2,
          };

          const dict_point = Object.assign(dict_point__corners, dict_point__arc);
          logger.log("dict_point", dict_point);

          var arr_point = Object.entries(dict_point).filter(([angle, point]) => {
            const isBetween = (arcStart <= angle) && (angle <= arcEnd);
            return isBetween;
          }).sort((e1, e2) => {
            return e1.angle < e2.angle;
          }).map(([angle, point]) => point);
          logger.log("arr_point", arr_point);

          arr_point = [point0].concat(arr_point);

          var clipPath = new fabric.Polygon(arr_point);

          return clipPath;
        }

        createFabricArcOfEllipseWithIcObj(icObj) {
          logger.log("createFabricArcOfEllipseWithIcObj", icObj);


          return fObj;

        }

        createFabricArcOfPathWithIcObj(icObj) {
          logger.log("createFabricArcOfPathWithIcObj", icObj);



          return fObj;

        }

        createFabricPolygon(icObj) {
          logger.log("createFabricPolygon", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          //create polygon
          var fObj = new fabric.Polygon(icObj.arr_point);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,
            top:  position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            //radius: icObj.radius,
            // rx: homeSize_screen.width  / 2.0,
            // ry: homeSize_screen.height / 2.0,

            // fill: '#f55',
            // fill: 'red',
            // fill: '',
            fill: icObj.fill,

            // stroke: 'blue',
            stroke: icObj.stroke,
            strokeWidth: 5,

            // opacity: 0.7,

            originX: "left",
            originY: "top",

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;
        }



        createFabricSvgWithIcFreeDrawing(icObj) {
          console.log("createFabricSvgWithIcFreeDrawing", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,



            fill: icObj.fill,

            // opacity: 0.7,

            icObj: icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }



        createFabricSvgWithIcObj_p(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const dataUrl = SvgHelper.toDataURL(icObj.svg);

          const promise = new Promise((resolve, reject) => {

            fabric.Image.fromURL(dataUrl, function (img) {
              console.log("img", img);
              // fabricCanvas.add(img);
              // console.log('CORS enabled + crossOrigin property - DataURL: ', img.toDataURL());
              resolve(img);
            },
              null,
              {
                crossOrigin: 'Anonymous',
              });

          });

          const promise2 = promise.then((fObj) => {

            fObj.set({
              left: icObj.position.x,
              top: icObj.position.y,

              width: fObj.width,
              height: fObj.height,
              // width:  icObj.size.width,
              // height: icObj.size.height,


              scaleX: icObj.scale.X,
              scaleY: icObj.scale.Y,

              flipX: icObj.flip.X,
              flipY: icObj.flip.Y,

              angle: icObj.orientation,

              icObj: icObj,
            });

            // const width  = icObj.size.width;
            // const height = icObj.size.height;
            // fObj.scaleToHeight(width);
            // fObj.scaleToWidth(height);


            //event listeners
            if (icObj.canBeHeld) {
              this.addInteraction_hold(fObj);
            }
            if (icObj.canBeMoved) {
              this.addInteraction_move(fObj);
            }
            if (icObj.canBeResized) {
              this.addInteraction_resize2(fObj);
            }
            if (icObj.canBeRotated) {
              this.addInteraction_rotate(fObj);
            }


            this.addInteraction_select(fObj);
            // this.addListeners(fObj);

            return fObj;
          });

          return promise2;
        }


        createFabricTexWithIcObj(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left: icObj.position.x,
            top: icObj.position.y,

            width: icObj.size.width,
            height: icObj.size.height,


            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            originX: "left",
            originY: "top",


            icObj: icObj,
          });


          fObj.refreshTex_p = () => {
            console.log("refreshTex");

            const tex  = icObj.tex;
            const fill = icObj.fill;

            const svgEl = TexHelper.toSvgEl(tex, fill);
            const dataUrl = SvgHelper.toDataURL(svgEl);
            const fObj_svg_image_p = new Promise((resolve, reject) => {

              fabric.Image.fromURL(dataUrl, function (img) {
                console.log("img", img);
                // fabricCanvas.add(img);
                // console.log('CORS enabled + crossOrigin property - DataURL: ', img.toDataURL());

                // img.set({
                //   originX: "left",
                //   originY: "top",
                //   left:0,
                //   top:0,
                // });
                // img.setCoords();

                resolve(img);
              },
                null,
                {
                  crossOrigin: 'Anonymous',
                });

            });

            const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
              if (fObj.child_tex != null) {
                fObj.remove(fObj.child_tex);
              }

              //add svg image as child
              fObj.child_tex = fObj_child;

              // fObj.add(fObj_child);
              fObj.addWithUpdate(fObj_child);
              console.log("fObj, added child:", fObj_child);

              /*
              fObj.set({
                width:  icObj.size.width,
                height: icObj.size.height,
              });
              */


              function adapt_child() {
                const width = icObj.size.width;
                const height = icObj.size.height;
                fObj_child.scaleToHeight(width);
                fObj_child.scaleToWidth(height);
              }

              function adapt_group() {
                fObj.set({
                  width: fObj_child.width,
                  height: fObj_child.height,
                });
              }

              adapt_child();


              return fObj;
            });

            return add_fObjfObj_svg_image_p;
          };

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          // fObj.refreshTex_p()
          // .then((fObj) => {
          //   fabricCanvas.renderAll();
          // });

          return fObj;
        }


        createFabricBigTexWithIcObj(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left: icObj.position.x,
            top:  icObj.position.y,

            width:  icObj.size.width,
            height: icObj.size.height,


            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            originX: "left",
            originY: "top",


            icObj: icObj,
          });


          fObj.refreshTex_p = () => {
            console.log("refreshTex");

            const tex  = icObj.tex;
            const fill = icObj.fill;

            const svgEl   = TexHelper.toSvgEl(tex, fill);
            const dataUrl = SvgHelper.toDataURL(svgEl);
            const fObj_svg_image_p = new Promise((resolve, reject) => {

              fabric.Image.fromURL(dataUrl, function (img) {
                console.log("img", img);
                // fabricCanvas.add(img);
                // console.log('CORS enabled + crossOrigin property - DataURL: ', img.toDataURL());

                // img.set({
                //   originX: "left",
                //   originY: "top",
                //   left:0,
                //   top:0,
                // });
                // img.setCoords();

                resolve(img);
              },
                null,
                {
                  crossOrigin: 'Anonymous',
                });

            });

            const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
              if (fObj.child_tex != null) {
                fObj.remove(fObj.child_tex);
              }

              //add svg image as child
              fObj.child_tex = fObj_child;

              // fObj.add(fObj_child);
              fObj.addWithUpdate(fObj_child);
              console.log("fObj, added child:", fObj_child);

              /*
              fObj.set({
                width:  icObj.size.width,
                height: icObj.size.height,
              });
              */


              function adapt_child() {
                const width = icObj.size.width;
                const height = icObj.size.height;
                fObj_child.scaleToHeight(width);
                fObj_child.scaleToWidth(height);
              }

              function adapt_group() {
                fObj.set({
                  width: fObj_child.width,
                  height: fObj_child.height,
                });
              }

              adapt_child();


              return fObj;
            });

            return add_fObjfObj_svg_image_p;
          };

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          // fObj.refreshTex_p()
          // .then((fObj) => {
          //   fabricCanvas.renderAll();
          // });

          return fObj;
        }

        createFabricHtmlObjectWithIcObj(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left: icObj.position.x,
            top:  icObj.position.y,

            width:  icObj.size.width,
            height: icObj.size.height,


            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            originX: "left",
            originY: "top",


            icObj: icObj,
          });


          fObj.refreshScreenshot_p = () => {
            console.log("refreshScreenshot_p");

            const el_html = icObj.el_html;

            // const canvasElt_p = html2canvas(html_elt);
            // const canvasElt_p = html2canvas(el_html, {
            //   // onclone: function (clone__htmlElt) {
            //   // clone__htmlElt.style.visibility = "visible";
            //   // clone__htmlElt.style.display = "block";
            //   // },
            // });

            const canvasElt_p = Promise.resolve(el_html);

            const fObj_hmtlElt_image_p = canvasElt_p.then((canvasElt) => {

              function getNumericalValueForPxString(pxString) {
                return parseInt(pxString.replace("px", ""));
              }

              const width__canvasElt  = getNumericalValueForPxString(canvasElt.style.width);
              const height__canvasElt = getNumericalValueForPxString(canvasElt.style.height);

              const img = new fabric.Image(canvasElt);

              const group = fObj;
              img.set({
                // left: 0,
                // top: 0,
                //SHU: that smell of Scotch Tape
                left: -group.width  / 2,
                top:  -group.height / 2,

                //debug
                // stroke: "yellow",
                // strokeWidth: 2,
              });

              return img;
            });

            const add_fObjfObj_htmlElt_image_p = fObj_hmtlElt_image_p.then((fObj_child) => {
              if (fObj.child_htmlScreenshot != null) {
                fObj.remove(fObj.child_htmlScreenshot);
              }

              //add image as child
              fObj.child_htmlScreenshot = fObj_child;

              // fObj.add(fObj_child);
              fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children
              console.log("fObj, added child:", fObj_child);

              return fObj;
            });

            return add_fObjfObj_htmlElt_image_p;
          };

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }

        // createFabricMathNodeWithIcObj(icObj) {
        //
        //   const fabricCanvas = this.fabricCanvas;
        //
        //   const fObj = new fabric.Group();
        //
        //   fObj.set({
        //     left:   icObj.position.x,
        //     top:    icObj.position.y,
        //
        //     width:  icObj.size.width,
        //     height: icObj.size.height,
        //
        //
        //     scaleX: icObj.scale.X,
        //     scaleY: icObj.scale.Y,
        //
        //     flipX:   icObj.flip.X,
        //     flipY:   icObj.flip.Y,
        //
        //     angle :  icObj.orientation,
        //
        //     originX: "left",
        //     originY: "top",
        //
        //
        //     icObj: icObj,
        //   });
        //
        //
        //   fObj.refreshTex_p = () => {
        //     console.log("refreshTex");
        //
        //     const tex   = icObj.mathNode.toTex();
        //     console.log("tex:", tex);
        //
        //     function upgradeTex(tex) {
        //       var outTex;
        //
        //       outTex = tex.replaceAll("\\cdot", "\\times");
        //
        //       return outTex;
        //     }
        //
        //     const tex_upgraded = upgradeTex(tex);
        //
        //     const fill  = icObj.fill;
        //
        //     // const svgEl   = TexHelper.toSvgEl(tex, fill);
        //     const svgEl   = TexHelper.toSvgEl(tex_upgraded, fill);
        //
        //     svgEl.setAttribute("width",  fObj.width);
        //     svgEl.setAttribute("height", fObj.height);
        //
        //     const dataUrl = SvgHelper.toDataURL(svgEl);
        //     const fObj_svg_image_p = new Promise((resolve, reject) => {
        //
        //       fabric.Image.fromURL(dataUrl, function (img) {
        //         // console.log("img", img);
        //
        //         const group = fObj;
        //         img.set({
        //           // left: 0,
        //           // top: 0,
        //           //SHU: that smell of Scotch Tape
        //           left: -group.width/2,
        //           top:  -group.height/2,
        //
        //           //debug
        //           // stroke: "yellow",
        //           // strokeWidth: 2,
        //         });
        //
        //         resolve(img);
        //       },
        //       null,
        //       {
        //         crossOrigin: 'Anonymous',
        //       });
        //
        //     });
        //
        //     const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
        //       if(fObj.child_tex != null) {
        //         fObj.remove(fObj.child_tex);
        //       }
        //
        //       //add svg image as child
        //       fObj.child_tex = fObj_child;
        //
        //       fObj.add(fObj_child);
        //       // fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children
        //       console.log("fObj, added child:", fObj_child);
        //
        //       return fObj;
        //     });
        //
        //     return add_fObjfObj_svg_image_p;
        //   };
        //
        //   //event listeners
        //   if(icObj.canBeHeld) {
        //     this.addInteraction_hold(fObj);
        //   }
        //   if(icObj.canBeMoved) {
        //     this.addInteraction_move(fObj);
        //   }
        //   if(icObj.canBeResized) {
        //     this.addInteraction_resize2(fObj);
        //   }
        //   if(icObj.canBeRotated) {
        //     this.addInteraction_rotate(fObj);
        //   }
        //
        //
        //   this.addInteraction_select(fObj);
        //   // this.addListeners(fObj);
        //
        //   this.addInteraction_doubleClick(fObj);
        //
        //
        //
        //   return fObj;
        // }

        createFabricMathNodeWithIcObj(icObj) {
          // logger.log("createFabricMathNodeWithIcObj", icObj);

          const fabricIntegration = this;
          const fabricCanvas      = this.fabricCanvas;

          const fObj = new fabric.Group();

          const fColor__stroke    = new fabric.Color(icObj.stroke);
          const color_rgb__stroke = fColor__stroke.toRgb();
          // const opacity__stroke   = fColor__stroke.opacity;

          fObj.set({
            left: icObj.position.x,
            top:  icObj.position.y,

            // width:  icObj.size.width,
            // height: icObj.size.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            originX: "center",
            // originX: icObj.originX ? icObj.originX : "left",
            originY: "top",


            // backgroundColor: icObj.backgroundColor ? icObj.backgroundColor : "",
            // fill:         "yellow",
            // stroke:       icObj.stroke,
            // strokeWidth : icObj.strokeWidth,

            stroke:  color_rgb__stroke,
            // opacity: opacity__stroke,
            opacity: icObj.opacity,

            icObj: icObj,
          });


          fObj.refreshTex_p = () => {
            // logger.log("logMathNode", "refreshTex_p", "mathNode:", icObj.mathNode);

            const mathNode = icObj.mathNode;

            const tex = mathNode.toTex();
            logger.log("logTex", "tex:", tex);


            const func__upgradeTex_in = icObj.func__upgradeTex;

            function upgradeTex__default(tex) {
              var outTex;

              //beautify
              //"3 * x" -> "3x"
              //"3 * (" -> "3("
              function beautifyLitexp(str_in) {
                logger.log("logTex", "beautifyLitexp", str_in);

                const re = /([0-9]+)\\cdot (\w+)/;
                const str = str_in.replace(re, '$1$2');
                logger.log("logTex", "beautified", str);

                return str;
              }

              outTex = beautifyLitexp(tex);

              outTex = outTex.replaceAll("\\right)\\cdot\\left(", "\\right)\\left("); 

              outTex = outTex.replaceAll("\\cdot i", "i");
              outTex = outTex.replaceAll("\\cdot", "\\times");

              outTex = outTex.replaceAll("\\timesi", "i");


              outTex = outTex.replaceAll("\\frac{ }", "÷");

              outTex = outTex.replaceAll(".", "{,}");

              return outTex;
            }

            var func__upgradeTex;
            if(func__upgradeTex_in != null) {
              func__upgradeTex = func__upgradeTex_in;
            } else {
              func__upgradeTex = upgradeTex__default;
            }



            var tex_upgraded = func__upgradeTex(tex);

            if(icObj.mathNode instanceof HorizSquaresBarIntegerConstantNode) {
              logger.log("logMathNode", "mathNode instanceof HorizSquaresBarIntegerConstantNode");
              tex_upgraded = tex;
            } else {
              logger.log("logMathNode", "mathNode:", icObj.mathNode);
              tex_upgraded = func__upgradeTex(tex);
            }




            const fill = icObj.fill;

            // const svgEl   = TexHelper.toSvgEl(tex, fill);
            const svgEl = TexHelper.toSvgEl(tex_upgraded, fill);
            // logger.log("logUp", "svgEl:", svgEl);

            // svgEl.setAttribute("width",  fObj.width);
            // svgEl.setAttribute("height", fObj.height);
            // logger.log('svgEl.getAttribute("width")',  svgEl.getAttribute("width"));
            // logger.log('svgEl.getAttribute("height")', svgEl.getAttribute("height"));
            const width_ex__svgEl  = parseFloat(svgEl.getAttribute("width").replace("ex", ""));
            const height_ex__svgEl = parseFloat(svgEl.getAttribute("height").replace("ex", ""));

            const depth__mathNode = getDepth(icObj.mathNode);

            const scaleFactor = Math.max(20, 70 - depth__mathNode * 8);
            // const scaleFactor     = 10 + depth__mathNode * 10;

            const width_px__svgEl  = width_ex__svgEl * scaleFactor;
            const height_px__svgEl = height_ex__svgEl * scaleFactor;
            // logger.log('width_px__svgEl',   width_px__svgEl);
            // logger.log('height_px__svgEl',  height_px__svgEl);


            const fColor__stroke    = new fabric.Color(icObj.stroke);
            const color_rgb__stroke = fColor__stroke.toRgb();

            svgEl.style.color = color_rgb__stroke;


            const dataUrl = SvgHelper.toDataURL(svgEl);
            const fObj_svg_image_p = new Promise((resolve, reject) => {

              fabric.Image.fromURL(dataUrl, function (img) {
                // console.log("img", img);

                const group = fObj;
                img.set({
                  // left: 0,
                  // top: 0,
                  //SHU: that smell of Scotch Tape
                  left: -group.width / 2,
                  top: -group.height / 2,

                  // width:  group.width,
                  // height: group.height,
                  // width:  width_px__svgEl,
                  // height: height_px__svgEl,

                  //debug
                  // stroke: "yellow",
                  // strokeWidth: 2,

                  // stroke:      icObj.stroke,
                  // strokeWidth: icObj.strokeWidth,

                  backgroundColor: icObj.backgroundColor ? icObj.backgroundColor : "",
                });

                img.scaleToWidth(width_px__svgEl);
                img.scaleToHeight(height_px__svgEl);

                resolve(img);
              },
                null,
                {
                  crossOrigin: 'Anonymous',
                });

            });

            const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
              if (fObj.child_tex != null) {
                fObj.remove(fObj.child_tex);
              }

              //add svg image as child
              fObj.child_tex = fObj_child;

              // fObj.add(fObj_child);
              fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children    //SHU: this seems to solve the out-of-bounds drawing issue
              console.log("fObj, added child:", fObj_child);

              return fObj;
            });

            return add_fObjfObj_svg_image_p;
          };

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          this.addInteraction_doubleClick(fObj);



          return fObj;
        }


        createFabricRichMathNodeWithIcObj(icObj) {
          logger.log("createFabricRichMathNodeWithIcObj", icObj);

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left: icObj.position.x,
            top: icObj.position.y,

            // width:  icObj.size.width,
            // height: icObj.size.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            originX: "center",
            // originX: icObj.originX ? icObj.originX : "left",
            originY: "top",

            icObj: icObj,
          });


          fObj.refreshTex_p = () => {
            console.log("refreshTex");

            const richMathNode = icObj.richMathNode;
            const mathNode = richMathNode.mathNode;

            // const tex   = mathNode.toTex();
            const tex = richMathNode.toTex();
            logger.log("tex:", tex);

            function upgradeTex(tex) {
              var outTex;

              outTex = tex.replaceAll("\\cdot", "\\times");

              // outTex = "{\\color{blue} 0} {\\color{white} +} {\\color{red} 1}";

              return outTex;
            }

            const tex_upgraded = upgradeTex(tex);

            const fill = icObj.fill;

            // const svgEl   = TexHelper.toSvgEl(tex, fill);
            const svgEl = TexHelper.toSvgEl(tex_upgraded, fill);

            // svgEl.setAttribute("width",  fObj.width);
            // svgEl.setAttribute("height", fObj.height);
            // logger.log('svgEl.getAttribute("width")',  svgEl.getAttribute("width"));
            // logger.log('svgEl.getAttribute("height")', svgEl.getAttribute("height"));
            const width_ex__svgEl  = parseFloat(svgEl.getAttribute("width").replace("ex", ""));
            const height_ex__svgEl = parseFloat(svgEl.getAttribute("height").replace("ex", ""));


            const depth__mathNode = getDepth(mathNode);

            const scaleFactor = Math.max(20, 70 - depth__mathNode * 8);
            // const scaleFactor     = 10 + depth__mathNode * 10;

            const width_px__svgEl = width_ex__svgEl * scaleFactor;
            const height_px__svgEl = height_ex__svgEl * scaleFactor;
            // logger.log('width_px__svgEl',   width_px__svgEl);
            // logger.log('height_px__svgEl',  height_px__svgEl);

            fObj.set({
              width: width_px__svgEl,
              height: height_px__svgEl,
            });

            const dataUrl = SvgHelper.toDataURL(svgEl);
            const fObj_svg_image_p = new Promise((resolve, reject) => {

              fabric.Image.fromURL(dataUrl, function (img) {
                // console.log("img", img);

                const group = fObj;
                img.set({
                  // left: 0,
                  // top: 0,
                  //SHU: that smell of Scotch Tape
                  left: -group.width / 2,
                  top: -group.height / 2,

                  // width:  group.width,
                  // height: group.height,
                  // width:  width_px__svgEl,
                  // height: height_px__svgEl,

                  //debug
                  // stroke: "yellow",
                  // strokeWidth: 2,
                });

                img.scaleToWidth(width_px__svgEl);
                img.scaleToHeight(height_px__svgEl);

                resolve(img);
              },
                null,
                {
                  crossOrigin: 'Anonymous',
                });

            });

            const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
              if (fObj.child_tex != null) {
                fObj.remove(fObj.child_tex);
              }

              //add svg image as child
              fObj.child_tex = fObj_child;

              fObj.add(fObj_child);
              // fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children
              console.log("fObj, added child:", fObj_child);

              return fObj;
            });

            return add_fObjfObj_svg_image_p;
          };

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          this.addInteraction_doubleClick(fObj);



          return fObj;
        }


        createFabricHtmlEltWithIcObj(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left: icObj.position.x,
            top: icObj.position.y,

            width: icObj.size.width,
            height: icObj.size.height,


            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            originX: "left",
            originY: "top",


            icObj: icObj,
          });


          fObj.refreshScreenshot_p = () => {
            console.log("refreshScreenshot_p");

            const html_elt = icObj.htmlElt;
            console.log("html_elt", html_elt);

            const canvasElt_p = html2canvas(html_elt, {
              // onclone: function (clone__htmlElt) {
              // clone__htmlElt.style.visibility = "visible";
              // clone__htmlElt.style.display = "block";
              // },
            });

            const fObj_hmtlElt_image_p = canvasElt_p.then((canvasElt) => {

              function getNumericalValueForPxString(pxString) {
                return parseInt(pxString.replace("px", ""));
              }

              const width__canvasElt = getNumericalValueForPxString(canvasElt.style.width);
              const height__canvasElt = getNumericalValueForPxString(canvasElt.style.height);

              const img = new fabric.Image(canvasElt);

              const group = fObj;
              img.set({
                // left: 0,
                // top: 0,
                //SHU: that smell of Scotch Tape
                left: -group.width / 2,
                top: -group.height / 2,

                //debug
                // stroke: "yellow",
                // strokeWidth: 2,
              });

              return img;
            });

            const add_fObjfObj_htmlElt_image_p = fObj_hmtlElt_image_p.then((fObj_child) => {
              if (fObj.child_htmlScreenshot != null) {
                fObj.remove(fObj.child_htmlScreenshot);
              }

              //add image as child
              fObj.child_htmlScreenshot = fObj_child;

              // fObj.add(fObj_child);
              fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children
              console.log("fObj, added child:", fObj_child);

              return fObj;
            });

            return add_fObjfObj_htmlElt_image_p;
          };

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }


        createFabricEyeWithIcObj(icObj) {
          logger.log("log1", "createFabricEyeWithIcObj", icObj);

          // const scale  = infiniteCanvas.scale;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();

          fObj.set({
            left: position_screen.x,
            top: position_screen.y,
            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            objectCaching: false,  //??




            strokeWidth: icObj.strokeWidth,
            stroke: icObj.stroke,

            //transparent fill
            fill: "transparent",

            //sharp corners
            rx: icObj.rx,
            ry: icObj.ry,


            icObj: icObj,
          });
          fObj.setCoords();

          logger.log("log1", "fObj", fObj);


          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);



          //image capture loop
          {
            const fabricCanvas = this.fabricCanvas;
            const ctx = fabricCanvas.getContext('2d');

            function startRefreshLoop() {
              logger.log("log1", "startRefreshLoop");

              var counter = 1;                  /// this is used to reduce FPS

              /// register refresh loop
              function refreshLoop() {

                /// reduce frame-rate
                const nb_skipped_frames__eye = 2009;
                if (counter % (nb_skipped_frames__eye + 1) == 0) {
                  captureNewFrame();
                  counter = 1;
                } else {
                  counter = counter + 1;
                }

                if (fObj.isShouldRequestAnimationFrame) {
                  requestAnimationFrame(refreshLoop);
                }




                function captureNewFrame() {
                  // logger.log("log1", "captureNewFrame");

                  const pov__current = infiniteCanvas.getCurrentPov();

                  const icObj = fObj.icObj;

                  //save
                  const pov__icObj__TL = infiniteCanvas.getPovForIcObj__TL(icObj);
                  const strokeWidth__current = fObj.strokeWidth;

                  //change
                  fObj.set({
                    strokeWidth: 0,
                  });
                  infiniteCanvas.set_pov(pov__icObj__TL);

                  {
                    // const rect_frame = {
                    //   left:   (fObj.left   + fObj.strokeWidth)       / fObj.icObj.homeScale.X,
                    //   top:    (fObj.top    + fObj.strokeWidth)       / fObj.icObj.homeScale.X,
                    //   width:  (fObj.width  - (2 * fObj.strokeWidth)) / fObj.icObj.homeScale.X,
                    //   height: (fObj.height - (2 * fObj.strokeWidth)) / fObj.icObj.homeScale.X,
                    // };

                    const rect_frame = {      //SHU: magic values !
                      left:   icObj.size.width  * 3.0/4.0,       
                      top:    icObj.size.height * 3.0/4.0,
                      width:  icObj.size.width  * 1.5,
                      height: icObj.size.height * 1.5,
                    };
  
                    const imageData__captured = ctx.getImageData(rect_frame.left, rect_frame.top, rect_frame.width, rect_frame.height);
                    // logger.log("imageData__captured", imageData__captured);
                    // logger.log("fObj.icObj", fObj.icObj);
                    // fObj.icObj.imageData__captured = imageData__captured; //SHU: this is ok, this may be uncommented
  
                    const img__captured = ImageUtils.imageFromImageData(imageData__captured);
                    // logger.log("img__captured", img__captured);
                    // fObj.icObj.img__captured = img__captured;             //SHU: this is ok, this may be uncommented 
                    fObj.icObj.rx_signal__out.next(img__captured);
                  }

                  //restore 
                  fObj.set({
                    strokeWidth: strokeWidth__current,
                  });
                  infiniteCanvas.set_pov(pov__current);

                }

              }

              fObj.isShouldRequestAnimationFrame = true;
              fObj.requestAnimationFrame = requestAnimationFrame(refreshLoop);

            }

            startRefreshLoop();

          }





          return fObj;
        }


        createFabricDisplayWithIcObj(icObj) {
          logger.log("log1", "createFabricDisplayWithIcObj", icObj);

          // const scale  = infiniteCanvas.scale;

          var fObj = new fabric.Image();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();

          fObj.set({
            left: position_screen.x,
            top: position_screen.y,
            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            objectCaching: false,  //??




            strokeWidth: icObj.strokeWidth,
            stroke:      icObj.stroke,

            //transparent fill
            fill: "transparent",

            //sharp corners
            rx: icObj.rx,
            ry: icObj.ry,


            icObj: icObj,
          });
          fObj.setCoords();

          logger.log("log1", "fObj", fObj);


          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }



        //group

        createFabricGroupWithIcObj(icObj) {
          console.log("createFabricGroupWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Group();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            fill: icObj.fill,

            // opacity: 0.7,

            icObj: icObj,
          });


          //create inner objects
          const fGroup = fObj;
          const childFObjs = icObj.children.map(icObj => {
            return this.createFabricGroupContentForFabricGroup(icObj, fGroup);
          });

          //add inner objects
          fObj.add(...childFObjs);



          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;

        }

        createFabricGroupContentForFabricGroup(icObj, fGroup) {
          const icGroup = fGroup.icObj;

          var fObj = this.createFabricObjectWithIcObj(icObj);

          //set the right coordinates:
          const icGroup_rect = Geometry.createRect(icGroup.position.x, icGroup.position.y, icGroup.size.width, icGroup.size.height);
          const fGroup_rect = Geometry.createRect(fGroup.left, fGroup.top, fGroup.width, fGroup.height);

          const position = Geometry.getPointFromRectToRect(icObj.position, icGroup_rect, fGroup_rect);

          // const offsetFromCenterToTL = {
          //   dx: -fGroup.width,
          //   dy: -fGroup.height,
          // };

          const offsetFromCenterToTL = {
            dx: -fGroup.width / 2,
            dy: -fGroup.height / 2,
          };

          fObj.set({
            left: position.x + offsetFromCenterToTL.dx,
            top: position.y + offsetFromCenterToTL.dy,
          });

          return fObj;

        }








        createFabricToggleRectWithIcObj(icObj) {
          console.log("createFabricToggleRectWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            strokeWidth: 0,

            icObj: icObj,
          });

          setTimeout(() => {  //SHU: golden hammer? setTimeout!
            configureWithIsActive(fObj, icObj.isActive);
          }, 0);

          function configureWithIsActive(fObj, isActive) {
            logger.log("configureWithIsActive", fObj, isActive);

            const cfg = isActive ? fObj.icObj.activeCfg : fObj.icObj.inactiveCfg;
            logger.log("cfg", cfg);

            fObj.set({
              fill: cfg.fill,
              opacity: cfg.opacity,
            });

            logger.log("fObj", fObj);

            fObj.dirty = true;
          }

          fObj.hasControls = false;
          fObj.hasBorders = true;


          //event listeners
          if (icObj.canBeSelected) {

            this.addInteraction_select(fObj);

            if (icObj.canBeHeld) {
              this.addInteraction_hold(fObj);
            }

            if (icObj.canBeMoved) {
              this.addInteraction_move(fObj);
            }
            if (icObj.canBeResized) {
              this.addInteraction_resize2(fObj);
            }
            if (icObj.canBeRotated) {
              this.addInteraction_rotate(fObj);
            }


            const fabricCanvas = this.fabricCanvas;

            fObj.on('mouseup', function (options) {
              console.log("mouseup", "options", options);

              const icObj = fObj.icObj;

              const isActive_update = !icObj.isActive;

              const icObj_new = Object.assign({}, icObj);
              icObj_new.isActive = isActive_update;

              icObj.update(icObj_new, false);

              configureWithIsActive(fObj, isActive_update);

              fabricCanvas.renderAll();

            });


          } else {
            fObj.selectable = false;
          }

          // this.addListeners(fObj);



          return fObj;

        }


        createFabricSnapSlotWithIcObj(icObj) {
          console.log("createFabricSnapSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj: icObj,
          });


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }

        createFabricTouchSlotWithIcObj(icObj) {
          console.log("createFabricTouchSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj: icObj,
          });


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }

        createFabricDropTouchSlotWithIcObj(icObj) {
          console.log("createFabricDropTouchSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj: icObj,
          });


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }

        createFabricApplySlotWithIcObj(icObj) {
          console.log("createFabricApplySlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    
            top:  position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj: icObj,
          });


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }


        createFabricDiveSlotWithIcObj(icObj) {
          console.log("createFabricDiveSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    
            top:  position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj: icObj,
          });


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }

        createFabricPokeSlotWithIcObj(icObj) {
          console.log("createFabricPokeSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          const rgbaColorString__fill = "rgba(33,66,200,0.5)";
          const fColor__fill = new fabric.Color(rgbaColorString__fill);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            
            fill: fColor__fill,

            icObj: icObj,
          });


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          return fObj;
        }


        createFabricCompositeWithIcObj(icObj) {
          console.log("createFabricCompositeWithIcObj", icObj);

          const fObj = this.createFabricRectWithIcObj(icObj);

          return fObj;
        }

        createFabricCompositePartWithIcObj(icObj) {
          console.log("createFabricCompositeWithIcObj", icObj);

          const fObj = this.createFabricObjectWithIcObj(icObj);

          return fObj;
        }


        createFabricButtonWithIcObj(icObj) {
          console.log("createFabricSnapSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,

            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: icObj.fill,

            icObj: icObj,
          });


          // if(icObj.canBeHeld) {
          //   this.addInteraction_hold(fObj);
          // }
          fObj.selectable = false;
          this.addInteraction_click(fObj);

          return fObj;
        }



        createFabricWellWithIcObj(icObj) {
          console.log("createFabricWellWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj: icObj,
          });


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }

        createFabricGreenMouseWellWithIcObj(icObj) {
          console.log("createFabricGreenMouseWellWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            //to avoid overlapping when clicking
            padding: 0,
            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj: icObj,
          });


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }


        createFabricRxSubjectWithIcObj(icObj) {
          return this.createFabricRectWithIcObj(icObj);
        }

        createFabricRxSubscriptionWithIcObj(icObj) {
          return this.createFabricRectWithIcObj(icObj);
        }





        createFabricSegmentWithIcObj(icObj) {
          logger.log("createFabricSegmentWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Line();

          // console.log("line:", fObj);
          // throw new Error("please die here");

          function screenPointWithoutOffset(infiniteCanvas, truePoint) {
            const screenX = truePoint.x * infiniteCanvas.scale.X;
            const screenY = truePoint.y * infiniteCanvas.scale.Y;
            return Geometry.createPoint(screenX, screenY);
          }

          const screenPoint_start = screenPointWithoutOffset(infiniteCanvas, icObj.point_start);
          const screenPoint_end = screenPointWithoutOffset(infiniteCanvas, icObj.point_end);

          fObj.set({
            x1: screenPoint_start.x,
            y1: screenPoint_start.y,

            x2: screenPoint_end.x,
            y2: screenPoint_end.y,

            // x1:   100,
            // y1:   100,
            //
            // x2:   500,
            // y2:   500,

            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth ? icObj.strokeWidth : 5,
            fill: "red",

            // stroke:      icObj.stroke,
            // strokeWidth: icObj.strokeWidth,
            // fill:        icObj.fill,

            originY: "center",    //SHU: temporary solution: only working for horizontal segments

            icObj: icObj,
          });



          //write now known icObj props
          // const screenRect = {
          //   left: fObj.left,
          //   top: fObj.top,
          //   width: fObj.width,
          //   height: fObj.height,
          // };

          // const trueRect = infiniteCanvas.toTrueRect(screenRect);

          // icObj.position = {
          //   x: trueRect.x,
          //   y: trueRect.y,
          // };

          // icObj.size = {
          //   width: trueRect.width,
          //   height: trueRect.height,
          // };




          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }



          return fObj;
        }

        createFabricHUDSegmentWithIcObj(icObj) {
          console.log("createFabricSegmentWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Line();

          // console.log("line:", fObj);
          // throw new Error("please die here");

          const screenPoint_start = infiniteCanvas.toScreenPoint(icObj.point_start);
          logger.log("screenPoint_start", screenPoint_start);
          const screenPoint_end = infiniteCanvas.toScreenPoint(icObj.point_end);
          logger.log("screenPoint_end", screenPoint_end);


          fObj.set({
            x1: screenPoint_start.x,
            y1: screenPoint_start.y,

            x2: screenPoint_end.x,
            y2: screenPoint_end.y,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            // x1:   100,
            // y1:   100,
            //
            // x2:   500,
            // y2:   500,

            stroke: "black",
            strokeWidth: 5,
            fill: "red",

            // stroke:      icObj.stroke,
            // strokeWidth: icObj.strokeWidth,
            // fill:        icObj.fill,

            icObj: icObj,
          });



          //write now known icObj props
          const screenRect = {
            left: fObj.left,
            top: fObj.top,
            width: fObj.width,
            height: fObj.height,
          };
          logger.log("screenRect", screenRect);

          const trueRect = infiniteCanvas.toTrueRect(screenRect);
          logger.log("trueRect", trueRect);


          icObj.position = {
            x: trueRect.left,
            y: trueRect.top,
          };

          icObj.size = {
            width: trueRect.width,
            height: trueRect.height,
          };




          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }

          return fObj;
        }






        createFabricReplayWithIcObj(icObj) {
          console.log("createFabricReplayWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,


            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,

            // fill: '#f55',
            // fill: 'red',
            fill: icObj.fill,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          if (icObj.isSharpRect) {
            fObj.set({
              rx: 0,
              ry: 0,
            });
          }

          // console.log("----", "fObj", fObj);

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);




          //debug
          // fObj.setControlsVisibility({
          //    mt: false,
          //    mb: false,
          //    ml: false,
          //    mr: false,
          //
          //    tl: true,
          //    tr: false,
          //    br: false,
          //    bl: false,
          //
          //    mtr: true,
          // });

          // fObj.hasControls = false;
          fObj.hasBorders = true;


          return fObj;
        }


        createFabricPathmadeOperatorWithIcObj(icObj) {
          console.log("createFabricPathmadeOperatorWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            width: homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,


            stroke: icObj.stroke,
            strokeWidth: icObj.strokeWidth,

            // fill: '#f55',
            // fill: 'red',
            fill: icObj.fill,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          if (icObj.isSharpRect) {
            fObj.set({
              rx: 0,
              ry: 0,
            });
          }

          // console.log("----", "fObj", fObj);

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);




          //debug
          // fObj.setControlsVisibility({
          //    mt: false,
          //    mb: false,
          //    ml: false,
          //    mr: false,
          //
          //    tl: true,
          //    tr: false,
          //    br: false,
          //    bl: false,
          //
          //    mtr: true,
          // });

          // fObj.hasControls = false;
          fObj.hasBorders = true;


          return fObj;
        }





        createFabricFreeDrawingWithIcObj(icObj) {
          console.log("createFabricFreeDrawingWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          const exoObject = icObj.exoObject;

          var fObj = new fabric.Path(exoObject.path);

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,
            //
            // scaleX:  icObj.scale.X,
            // scaleY:  icObj.scale.Y,
            //
            // flipX:   icObj.flip.X,
            // flipY:   icObj.flip.Y,


            angle: icObj.orientation,


            stroke:           exoObject.stroke,
            strokeDashArray:  exoObject.strokeDashArray,
            strokeLineCap:    exoObject.strokeLineCap,
            strokeLineJoin:   exoObject.strokeLineJoin,
            strokeMiterLimit: exoObject.strokeMiterLimit,
            strokeWidth:      exoObject.strokeWidth,

            fill:             exoObject.fill,

            opacity: icObj.opacity,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);




          //debug
          fObj.setControlsVisibility({
            mt: false,
            mb: false,
            ml: false,
            mr: false,

            tl: true,
            tr: false,
            br: false,
            bl: false,

            mtr: true,
          });

          // fObj.hasControls = false;
          fObj.hasBorders = true;


          return fObj;
        }



        createFabricFloodFillWithIcObj(icObj) {
          console.log("createFabricFloodFillWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          const img = icObj.exoObject;

          var fObj = new fabric.Image(img);

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:  position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,
            //
            // scaleX:  icObj.scale.X,
            // scaleY:  icObj.scale.Y,
            //
            // flipX:   icObj.flip.X,
            // flipY:   icObj.flip.Y,


            angle: icObj.orientation,

            opacity: icObj.opacity,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);




          // //debug
          // fObj.setControlsVisibility({
          //   mt: false,
          //   mb: false,
          //   ml: false,
          //   mr: false,

          //   tl: true,
          //   tr: false,
          //   br: false,
          //   bl: false,

          //   mtr: true,
          // });

          // fObj.hasControls = false;
          fObj.hasBorders = true;


          return fObj;
        }


        createFabricSparkleWithIcObj(icObj) {
          console.log("createFabricSparkleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          // var fObj = new fabric.Triangle();
          var fObj = new fabric.Image(icObj.img);


          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          // const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top: position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,
            width: icObj.img.width,
            height: icObj.img.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,


            angle: icObj.orientation,

            // fill: '#f55',
            // fill: 'red',
            fill: icObj.fill,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj: icObj,
          });

          if (icObj.isUsingCenterPosition) {
            fObj.set({
              originX: "center",          //:)
              originY: "center",          //:)
            });
          }


          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          return fObj;
        }



        createFabricCanvasWithIcObj(icObj) {

          // const scale  = infiniteCanvas.scale;
          const fabricCanvas    = icObj.dict__iC.fabricIntegration.fabricCanvas;
          const el__lowerCanvas = fabricCanvas.lowerCanvasEl;

          var fObj = new fabric.Image(el__lowerCanvas);

          fObj.set({
            left: icObj.position.x,
            top: icObj.position.y,

            // width:  icObj.img.width,
            // height: icObj.img.height,

            // width:  icObj.size.width,
            // height: icObj.size.height,

            width: 100,
            height: 100,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX: icObj.flip.X,
            flipY: icObj.flip.Y,

            angle: icObj.orientation,

            icObj: icObj,
          });


          if (icObj.force_width) {
            const factor__force_width = icObj.width / icObj.img.width;
            fObj.set({
              scaleX: fObj.scaleX * factor__force_width,
            });
          }
          if (icObj.force_height) {
            const factor__force_height = icObj.height / icObj.img.height;
            fObj.set({
              scaleY: fObj.scaleY * factor__force_height,
            });
          }

          //event listeners
          if (icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if (icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if (icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if (icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }





        addInteraction_move(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas = this.fabricCanvas;

          fabricCanvas.on('before:transform', function (options) {
            logger.log("before:transform", "options", options);

            if (fObj.icObj.type == "segment") {
              fObj.point_start__original = fObj.icObj.point_start;
              fObj.point_end__original = fObj.icObj.point_end;

              fObj.position__target__original = Geometry.createPoint(options.transform.target.left, options.transform.target.top);
            }

          });

          fObj.on('moving', function (options) {
            logger.log("moving", "options", options);

            const offset = infiniteCanvas.offset;
            const scale = infiniteCanvas.scale;

            const icObj = fObj.icObj;

            //---new style: rep inner update---
            const rep_free = fObj.icObj;
            console.log("ççç on 'moving' rep_free.id_rep", rep_free.id_rep);
            const listener = fObj.fListener_inner;

            //listen:off
            rep_free.offInnerUpdate(listener);

            //mutate
            switch (icObj.type) {
              case "segment":
                {
                  const transform = options.transform;

                  // const offset__transform__screen1 = Geometry.createPoint(transform.offsetX, transform.offsetY);   //NOT WORKING
                  // logger.log("offset__transform__screen1", offset__transform__screen1);

                  const offset__transform__screen2 = Geometry.createPoint(options.target.left - fObj.position__target__original.x, options.target.top - fObj.position__target__original.y);
                  logger.log("offset__transform__screen2", offset__transform__screen2);

                  const offset__transform__ic = infiniteCanvas.toTruePoint(offset__transform__screen2);

                  const v = Geometry.vector_2d(infiniteCanvas.toTruePoint(Geometry.createPoint(0, 0)), offset__transform__ic);

                  //update .point_start and .point_end
                  rep_free.point_start = Geometry.translatedPoint(fObj.point_start__original, v);
                  rep_free.point_end = Geometry.translatedPoint(fObj.point_end__original, v);

                }
                break;
              default:
                {
                  const target = options.transform.target;

                  const screenPoint = {
                    x: target.left,
                    y: target.top,
                  };

                  const position_update = infiniteCanvas.toTruePoint(screenPoint);

                  //update .position
                  rep_free.position = position_update;
                }
                break;
            }

            //listen:on
            rep_free.onInnerUpdate(listener);

          });

        }

        // addInteraction_resize(fObj) {
        //
        //   const infiniteCanvas = this.infiniteCanvas;
        //   const fabricCanvas   = this.fabricCanvas;
        //
        //   var isScaling = false;
        //   var original_trueRect = null;
        //   fObj.on('scaling', function(options) {
        //     console.log("scaling", "options", options);
        //     const original = options.transform.original;
        //
        //     const target   = options.transform.target;
        //
        //     if(!isScaling) {
        //       original_trueRect = Geometry.createRect(target.icObj.position.x, target.icObj.position.y, target.icObj.size.width, target.icObj.size.height);
        //       console.log("original_trueRect", original_trueRect);
        //       isScaling = true;
        //     }
        //
        //     const scaleFactorX = target.scaleX / original.scaleX;
        //     const scaleFactorY = target.scaleY / original.scaleY;
        //
        //     console.log("scaleFactorX", scaleFactorX);
        //
        //     const trueRect_width__new  = (original_trueRect.width  * scaleFactorX);
        //     const trueRect_height__new = (original_trueRect.height * scaleFactorY);
        //
        //     console.log("trueRect_width__new", trueRect_width__new);
        //
        //
        //
        //     const offset = infiniteCanvas.offset;
        //     const scale  = infiniteCanvas.scale;
        //
        //     // const trueRect_update = {
        //     //   width:  trueRect_width__new,
        //     //   height: trueRect_height__new,
        //     // };
        //     //
        //     // // Object.assign(target.trueRect, trueRect_update);
        //     // Object.assign(fObj.trueRect, trueRect_update);
        //
        //     const trueRect_update = {
        //       left:  target.left / scale.X - offset.dx,
        //       top:   target.top  / scale.Y - offset.dy,
        //
        //       width:  (original_trueRect.width  * scaleFactorX),
        //       height: (original_trueRect.height * scaleFactorY),
        //     };
        //
        //     const icObj_update = {
        //       position: Geometry.createPoint(trueRect_update.left, trueRect_update.top),
        //       size:     Geometry.createSize(trueRect_update.width, trueRect_update.height),
        //     };
        //
        //     const icObj = fObj.icObj;
        //
        //     const icObj_new = Object.assign({}, icObj);
        //     Object.assign(icObj_new, icObj_update);
        //
        //     icObj.update(icObj_new, false);
        //
        //   });
        //   fObj.on('scaled', function(options) {
        //     console.log("scaled", "options", options);
        //     isScaling = false;
        //     original_trueRect = null;
        //
        //     const original = options.transform.original;
        //     const target   = options.transform.target;
        //
        //     target.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //
        //       //not used:
        //       // width:  target.trueRect.width  * scale,
        //       // height: target.trueRect.height * scale,
        //
        //       //used instead:
        //       // width:  target.trueRect.width,
        //       // height: target.trueRect.height,
        //       width:  target.icObj.size.width,
        //       height: target.icObj.size.height,
        //
        //       scaleX : original.scaleX,
        //       scaleY : original.scaleY,
        //     });
        //     target.setCoords();
        //   });
        //
        // }

        addInteraction_resize2(fObj) {

          const fabricIntegration = this;

          const infiniteCanvas = fabricIntegration.infiniteCanvas;
          const fabricCanvas = fabricIntegration.fabricCanvas;

          var isScaling = false;
          var original_homeScale = null;
          var original_scale = null;

          function doResize(fObj, options) {

            const original = options.transform.original;
            const target = options.transform.target;

            if (!isScaling) {
              original_homeScale = Object.assign({}, target.icObj.homeScale);
              // console.log("original_homeScale", original_homeScale);
              original_scale = Object.assign({}, target.icObj.scale);

              isScaling = true;
            }

            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);

            switch (options.transform.action) {

              case "scale":
                handle_proportionnal_scale();
                break;

              case "scaleX":
              case "scaleY":
                handle_axis_scale();
                // handle_proportionnal_scale();


                break;
            }

            function handle_proportionnal_scale() {

              const icObj = fObj.icObj;

              var homeScale_new;

              // if(fObj instanceof fabric.Text) {

              // const fontSize_fObj = fObj.fontSize;
              // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
              //
              // homeScale_new = {
              //   X: original_homeScale.X,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

              // } else {

              homeScale_new = {
                X: original_homeScale.X / scaleFactor.X,
                Y: original_homeScale.Y / scaleFactor.Y,
              };

              // }
              console.log("homeScale_new", homeScale_new);

              const icObj_update = {
                homeScale: homeScale_new,
              };

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new, icObj_update);

              icObj.update(icObj_new, false);



              //update position
              {

                const fObj_pos = {
                  x: fObj.left,
                  y: fObj.top,
                };

                const position_update = infiniteCanvas.toTruePoint(fObj_pos);

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.position, position_update);

                icObj.update(icObj_new, false);

              }

              // //update flipX
              // {
              //   const flipX_update = fObj.flipX;
              //
              //   const icObj_new = Object.assign({}, icObj);
              //   Object.assign(icObj_new.flipX, flipX_update);
              //
              //   icObj.update(icObj_new, false);
              // }


            }

            function handle_axis_scale() {

              const icObj = fObj.icObj;

              var scale_new;

              // if(fObj instanceof fabric.Text) {

              // const fontSize_fObj = fObj.fontSize;
              // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
              //
              // homeScale_new = {
              //   X: original_homeScale.X,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

              // } else {

              scale_new = {
                X: original_scale.X * scaleFactor.X,
                Y: original_scale.Y * scaleFactor.Y,
              };

              // }
              console.log("scale_new", scale_new);

              const icObj_update = {
                scale: scale_new,
              };

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new, icObj_update);

              icObj.update(icObj_new, false);




              //update position
              {

                const fObj_pos = {
                  x: fObj.left,
                  y: fObj.top,
                };

                const position_update = infiniteCanvas.toTruePoint(fObj_pos);

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.position, position_update);

                icObj.update(icObj_new, false);

              }

              //update flipX
              {
                const flip_update = {
                  X: (fObj.flipX != null) ? fObj.flipX : false,
                  Y: (fObj.flipY != null) ? fObj.flipY : false,
                };

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.flip, flip_update);

                icObj.update(icObj_new, false);
              }



            }

          }

          const icObj = fObj.icObj;

          fObj.on('scaling', function (options) {
            console.log("scaling", "options", options);

            switch (icObj.type) {
              case "composite":
                doResize(fObj, options);
                Object.values(icObj.parts).forEach((icObj__part, i) => {
                  const fObj__part = fabricIntegration.getFObjForIcObj(icObj__part);
                  doResize(fObj__part, options);
                });
                break;
              default:
                doResize(fObj, options);
                break;
            }

          });
          fObj.on('scaled', function (options) {
            console.log("scaled", "options", options);
            isScaling = false;

            /*
            const original = options.transform.original;
            const target   = options.transform.target;

            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);


            const icObj = fObj.icObj;

            var homeScale_new;

            if(fObj instanceof fabric.Text) {

              // const fontSize_fObj = fObj.fontSize;
              // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
              //
              // homeScale_new = {
              //   X: scale.X / scale_fObj.X / scaleFactor__fontSize,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

            } else {

              homeScale_new = {
                X: original_homeScale.X / scaleFactor.X,
                Y: original_homeScale.Y / scaleFactor.Y,
              };

            }
            console.log("homeScale_new", homeScale_new);


            const icObj_update = {
              homeScale: homeScale_new,
            };

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);

            icObj.update(icObj_new, false);
            */

            original_homeScale = null;

          });

        }


        addInteraction_rotate(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          // const fabricCanvas   = this.fabricCanvas;

          // var isRotating = false;

          fObj.on('rotating', function (options) {
            // console.log("rotating", "options", options);

            // if(!isRotating) {
            //   isRotating = true;
            //
            //
            // }

            const original = options.transform.original;


            const target = options.transform.target;

            const icObj = fObj.icObj;

            // const orientation_update = target.angle + infiniteCanvas.orientation;
            const orientation_update = Geometry.boundedAngleInDegrees(target.angle + infiniteCanvas.orientation);
            // console.log("orientation_update", orientation_update);




            // console.log("target.angle",     target.angle);
            // console.log("original.angle", original.angle);
            //
            // const rotationAngle = target.angle - original.angle;
            // const rotationAngle_bounded = Geometry.boundedAngleInDegrees(rotationAngle);
            // console.log("rotationAngle", rotationAngle);
            //
            // const originalRect   = Geometry.createRect(original.left, original.top, target.width, target.height);
            // const originalTL     = Geometry.getPointTL(originalRect);
            // const originalCenter = Geometry.getCenterPoint(originalRect);
            // console.log("originalTL",     originalTL);
            // console.log("originalCenter", originalCenter);
            //
            // const screenTL_new = Geometry.pointWithRotation(originalTL, originalCenter, rotationAngle_bounded);
            // console.log("screenTL_new", screenTL_new);
            //
            //
            //
            //
            //
            //
            // const position_update = infiniteCanvas.toTruePoint(screenTL_new);



            const screenPoint = {
              x: target.left,
              y: target.top,
            };

            const position_update = infiniteCanvas.toTruePoint(screenPoint);


            const icObj_new = Object.assign({}, icObj);
            // Object.assign(icObj_new.orientation, orientation_update);

            icObj_new.orientation = orientation_update;

            Object.assign(icObj_new.position, position_update);

            icObj.update(icObj_new, false);
          });

        }


        addInteraction_select(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas = this.fabricCanvas;


          // fObj.on('selected', function(options) {
          //   console.log("selected", "options", options);
          //
          //   // const activeGroup = fabricCanvas.getActiveGroup();
          //
          //   /*
          //   const activeObject   = fabricCanvas.getActiveObject();
          //
          //   // console.log("activeObject", activeObject);
          //
          //   const icObj = activeObject.icObj;
          //
          //   console.log("icObj.size.width",  icObj.size.width);
          //   console.log("icObj.homeScale.X", icObj.homeScale.X);
          //   console.log("icObj.scale.X",     icObj.scale.X);
          //
          //   console.log("icObj.getTrueSize()", activeObject.icObj.getTrueSize());
          //
          //   console.log("activeObject.scaleX", activeObject.scaleX);
          //   console.log("activeObject.scaleY", activeObject.scaleY);
          //
          //   console.log("infiniteCanvas.scale.X", infiniteCanvas.scale.X);
          //
          //   if(fObj instanceof fabric.Text) {
          //     console.log("icObj.fontSize", icObj.fontSize);
          //     console.log(" fObj.fontSize",  fObj.fontSize);
          //   }
          //   */
          //
          //   const icObj = fObj.icObj;
          //   icObj.isSelected = true;
          //
          // });

          // fObj.on('deselected', function(options) {
          //   console.log("selected", "options", options);
          // });

        }

        addInteraction_hold(fObj) {
          // logger.trace("addInteraction_hold", fObj);

          const fabricIntegration = this;

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          const icObj = fObj.icObj;

          // var isHeld = false;
          //hold
          fObj.on('mousedown', function (options) {
            logger.log("logFObj", "mousedown", fObj, options);
            icObj.nowHeld();
          });

          //release
          fObj.on('mouseup', function (options) {
            logger.log("logFObj", "mouseup", fObj, options);

            //SHU: can be copied  at onMouseUp workaround (iC.hasBeenObjectHolding) 
            {
              if (fabricIntegration.singleUseBehaviors["stickyRelease"]) {

                // infiniteCanvas.manageStickyRelease(icObj);
                //create composite

                //add parts


                fabricIntegration.singleUseBehaviors["stickyRelease"] = false;
              } else {
                icObj.nowReleased();
              }
            }

          });

        }


        addInteraction_editText(fObj) {

          // fObj.on('changed', function(options) {
          //
          // });

          fObj.on('changed', function (options) {
            console.log("changed", "options", options);

            console.log("fObj.text", fObj.text);

            const text_new = fObj.text;

            const icObj = fObj.icObj;


            //old way
            /*
            const icObj_update = {
              text: text_new,
            };
            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);
            icObj.update(icObj_new, false);
            */

            //new way
            icObj.text = text_new;
          });


          fObj.on('editing:entered', function (options) {
            const icObj = fObj.icObj;
            // logger.log("logCP", 'editing:entered', "icObj:", icObj);
            icObj.nowEditEnter();
          });

          fObj.on('editing:exited', function (options) {
            const icObj = fObj.icObj;
            console.log("editing:exited, icObj", icObj);
            console.log("editing:exited, icObj.text", icObj.text);

            icObj.nowEditExit();
          });

        }

        addInteraction_click(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          // fObj.on('mousedown', function (options) {
          //   console.log("mousedown", "options", options);

          fObj.handler__click = function (options) {
            console.log("mouseup", "options", options);

            const icObj = fObj.icObj;

            icObj.nowClicked();
          };

          fObj.on('mouseup', fObj.handler__click);
        }

        removeInteraction_click(fObj) {

          fObj.off('mouseup', fObj.handler__click);
          fObj.handler__click = null;
        }

        addInteraction_doubleClick(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas = this.fabricCanvas;

          fObj.on('mousedblclick', function (options) {
            console.log("mousedblclick", "options", options);

            const icObj = fObj.icObj;

            icObj.edit.start();
          });

        }






        configureActiveSelectionListeners() {
          // object:moving
          // object:scaling
          // object:rotating
          // object:skewing
          // object:moved
          // object:scaled
          // object:rotated
          // object:skewed

          const fabricIntegration = this;

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          //creation
          this.fabricCanvas.on("selection:created", (options) => {
            logger.log("selection:created", options);

            const activeObject = this.fabricCanvas.getActiveObject();

            if (activeObject instanceof fabric.ActiveSelection) {
              const activeSelection = activeObject;
              logger.log("logAS", "selection:created", "activeSelection:", activeSelection);

              // this.fabricCanvas._discardActiveObject();

              // //inject 'initial' props
              // const icActiveSelection = infiniteCanvas.createIcActiveSelection_from_activeSelectionFObj(activeSelection);

              // activeSelection.icObj = icActiveSelection;

              // activeSelection.forEachObject((fObj, index, arr_fObj) => {
              //   logger.log("logAS", "activeSelection", "forEachObject", fObj);
              //   setGroupCoords(fObj, activeSelection);
              //   savePrivateCoords(fObj, activeSelection);
              // }, fabricIntegration.fabricCanvas.contextTop);

              // //store
              // infiniteCanvas.activeSelection = icActiveSelection;

            } else {
              logger.log("logAS", "activeObject is not fabric.ActiveSelection", typeof activeObject);

              // const activeSelection = activeObject;
              // console.log("activeSelection", activeSelection);

              // //inject 'initial' props
              // const icActiveSelection = infiniteCanvas.createIcActiveSelection_from_activeSelectionFObj(activeSelection);
              // icActiveSelection.children = [activeObject.icObj];

              // activeSelection.icObj = icActiveSelection;

              // //store
              // infiniteCanvas.activeSelection = icActiveSelection;
            }

          });

          function setGroupCoords(fObj, activeSelection) {
            logger.log("logAS", "setGroupCoords", fObj, activeSelection);

            const left__solo = fObj.left;
            const top__solo  = fObj.top;

            //set new "group coords"
            const activeSelectionCL = activeSelection.left + activeSelection.width  / 2;
            const activeSelectionCT = activeSelection.top  + activeSelection.height / 2;
            logger.log("logAS", "activeSelectionCL", activeSelectionCL);
            logger.log("logAS", "activeSelectionCT", activeSelectionCT);

            fObj.left = left__solo - activeSelectionCL;
            fObj.top  = top__solo  - activeSelectionCT;
          }

          function savePrivateCoords(fObj, activeSelection) {
            logger.log("logAS", "savePrivateCoords", fObj, activeSelection);

            //save wrtGroup coords
            fObj.left__wrtGroup = fObj.left;
            fObj.top__wrtGroup  = fObj.top;

            const activeSelectionCL = activeSelection.left + activeSelection.width  / 2;
            const activeSelectionCT = activeSelection.top  + activeSelection.height / 2;
            logger.log("logAS", "activeSelectionCL", activeSelectionCL);
            logger.log("logAS", "activeSelectionCT", activeSelectionCT);


            //save solo coords
            fObj.left__solo = fObj.left__wrtGroup + activeSelectionCL;
            fObj.top__solo  = fObj.top__wrtGroup  + activeSelectionCT;
          }


          //update
          this.fabricCanvas.on("selection:updated", (options) => {
            logger.log("selection:updated", options);

            //TBD

          });





          //move
          // this.fabricCanvas.on("object:moving", (options) => {
          //   // console.log("object:moving", event);
          //
          //   const target = options.target;
          //   if(target.type == "activeSelection") {
          //     activeSelection_moving(target);
          //   }
          //
          // });
          // this.fabricCanvas.on("object:moved", (options) => {
          //   logger.log("logAS", "object:moved", options);

          // this.fabricCanvas.on("object:modified", (options) => {
          //   logger.log("logAS", "object:modified", options);

          //   if(options.action == "drag") {
          //     const target = options.target;
          //     if (target.icObj.type == "activeSelection") {
          //       activeSelection_moved(target);
          //     }
          //   }

          // });

          // //scale
          // this.fabricCanvas.on("object:scaling", (options) => {
          //   // console.log("object:scaling", options);

          //   const target = options.target;
          //   if (target.type == "activeSelection") {
          //     activeSelection_scaling(options);
          //   }

          // });
          // this.fabricCanvas.on("object:scaled", (options) => {
          //   // console.log("object:scaling", event);

          //   const target = options.target;
          //   if (target.type == "activeSelection") {
          //     activeSelection_scaled(target);
          //   }

          // });


          // //rotate
          // this.fabricCanvas.on("object:rotating", (options) => {
          //   // console.log("object:rotating", event);

          //   const target = options.target;
          //   if (target.type == "activeSelection") {
          //     activeSelection_rotating(options);
          //   }

          // });







          function activeSelection_moved(activeSelection) {
            logger.log("logAS", "activeSelection_moved", activeSelection);

            //update activeSelection position
            {
              const fObj = activeSelection;

              const icObj = fObj.icObj;

              const fObj_screenPos = {
                x: fObj.left,
                y: fObj.top,
              };

              const position_update = infiniteCanvas.toTruePoint(fObj_screenPos);

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new.position, position_update);

              icObj.update(icObj_new, false);
            }

            //update children position

            function updateChildIcObj_position(fObj) {

              savePrivateCoords(fObj, activeSelection);

              const fObj_screenPos = {
                x: fObj.left__solo,
                y: fObj.top__solo,
              };

              const position_update = infiniteCanvas.toTruePoint(fObj_screenPos);

              const icObj = fObj.icObj;
              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new.position, position_update);

              icObj.update(icObj_new, false);
            }

            activeSelection.forEachObject((fObj, index, arr_fObj) => {
              updateChildIcObj_position(fObj);
              fObj.left = fObj.left__wrtGroup;
              fObj.top  = fObj.top__wrtGroup;
            }, fabricIntegration.fabricCanvas.contextTop);


          }



          var isScaling = false;
          var original_props = {};
          function activeSelection_scaling(options) {
            console.log("activeSelection scaling", options);

            const target = options.target;
            const original = options.transform.original;

            const activeSelection = target;

            if (!isScaling) {

              //store original props
              const activeSelection_icObj_propDict = {
                homeScale: Object.assign({}, activeSelection.icObj.homeScale),
                scale: Object.assign({}, activeSelection.icObj.scale),
              };

              original_props["activeSelection_icObj"] = activeSelection_icObj_propDict;

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                const propDict = {
                  homeScale: Object.assign({}, icObj.homeScale),
                  scale: Object.assign({}, icObj.scale),
                };

                original_props[icObj.id] = propDict;

              }, fabricIntegration.fabricCanvas.contextTop);

              isScaling = true;
            }



            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);

            switch (options.transform.action) {

              case "scale":
                handle_proportionnal_scale(activeSelection);
                break;

              case "scaleX":
              case "scaleY":
                handle_axis_scale(activeSelection);

                break;
            }

            function handle_proportionnal_scale(activeSelection) {

              //update activeSelection icObj
              {
                const icObj = activeSelection.icObj;

                var homeScale_new;

                const original_homeScale = original_props["activeSelection_icObj"].homeScale;

                homeScale_new = {
                  X: original_homeScale.X / scaleFactor.X,
                  Y: original_homeScale.Y / scaleFactor.Y,
                };

                console.log("homeScale_new", homeScale_new);

                const icObj_update = {
                  homeScale: homeScale_new,
                };

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new, icObj_update);

                icObj.update(icObj_new, false);
              }


              //update children

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                //update scale
                {
                  var homeScale_new;

                  const original_homeScale = original_props[icObj.id].homeScale;

                  homeScale_new = {
                    X: original_homeScale.X / scaleFactor.X,
                    Y: original_homeScale.Y / scaleFactor.Y,
                  };

                  console.log("homeScale_new", homeScale_new);

                  const icObj_update = {
                    homeScale: homeScale_new,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new, icObj_update);

                  icObj.update(icObj_new, false);
                }


                //update position
                {

                  const activeSelectionCenterX = activeSelection.width / 2;
                  const activeSelectionCenterY = activeSelection.height / 2;

                  const fObj_pos_wrt_ASTL = {
                    left: activeSelectionCenterX + fObj.left,
                    top: activeSelectionCenterY + fObj.top,
                  };

                  const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

                  const fObj_screenPos = {
                    x: activeSelection.left + scaleFactor.X * (Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left - Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top),
                    y: activeSelection.top + scaleFactor.Y * (Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left + Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top),
                  };

                  const position_update = infiniteCanvas.toTruePoint(fObj_screenPos);

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.position, position_update);

                  icObj.update(icObj_new, false);

                }
              });

            }

            function handle_axis_scale(activeSelection) {

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                //update scale
                {
                  var scale_new;

                  const original_scale = original_props[icObj.id].scale;

                  scale_new = {
                    X: original_scale.X * scaleFactor.X,
                    Y: original_scale.Y * scaleFactor.Y,
                  };

                  console.log("scale_new", scale_new);

                  const icObj_update = {
                    scale: scale_new,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new, icObj_update);

                  icObj.update(icObj_new, false);
                }


                var fObj_sign = {
                  X: +1,
                  Y: +1
                };
                switch (options.originX) {
                  case "left":
                    fObj_sign.X = +1;
                    break;
                  case "right":
                    fObj_sign.X = -1;
                    break;
                }

                switch (options.originY) {
                  case "top":
                    fObj_sign.Y = +1;
                    break;
                  case "bottom":
                    fObj_sign.Y = -1;
                    break;
                }


                //update position
                {

                  const activeSelectionCenterX = fObj_sign.X * activeSelection.width / 2;
                  const activeSelectionCenterY = fObj_sign.Y * activeSelection.height / 2;

                  const fObj_pos_wrt_ASTL = {
                    left: activeSelectionCenterX + fObj_sign.X * fObj.left,
                    top: activeSelectionCenterY + fObj_sign.Y * fObj.top,
                  };

                  const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

                  const fObj_screenPos = {
                    x: activeSelection.left + scaleFactor.X * (Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left - Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top),
                    y: activeSelection.top + scaleFactor.Y * (Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left + Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top),
                  };

                  const position_update = infiniteCanvas.toTruePoint(fObj_screenPos);

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.position, position_update);

                  icObj.update(icObj_new, false);

                }

                //update flip
                {
                  const flip_update = {
                    X: (activeSelection.flipX != null) ? activeSelection.flipX : false,
                    Y: (activeSelection.flipY != null) ? activeSelection.flipY : false,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.flip, flip_update);

                  icObj.update(icObj_new, false);
                }

              });

            }


          }

          function activeSelection_scaled(activeSelection) {
            isScaling = false;
            original_props = {};
          }





          function activeSelection_rotating(options) {
            console.log("activeSelection rotating", options);

            const target = options.transform.target;
            // const original = options.transform.original;

            const activeSelection = target;

            activeSelection.forEachObject((fObj, index, arr_fObj) => {
              const icObj = fObj.icObj;

              const activeSelectionCenterX = activeSelection.width / 2;
              const activeSelectionCenterY = activeSelection.height / 2;

              const fObj_pos_wrt_ASTL = {
                left: activeSelectionCenterX + fObj.left,
                top: activeSelectionCenterY + fObj.top,
              };

              const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

              const fObj_screenPos = {
                x: activeSelection.left + Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left - Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top,
                y: activeSelection.top + Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left + Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top,
              };

              const position_update = infiniteCanvas.toTruePoint(fObj_screenPos);




              const fObj_angle = target.angle + fObj.angle;
              const orientation_update = Geometry.boundedAngleInDegrees(fObj_angle + infiniteCanvas.orientation);

              const icObj_new = Object.assign({}, icObj);

              Object.assign(icObj_new.position, position_update);
              icObj_new.orientation = orientation_update;

              icObj.update(icObj_new, false);
            });

          }


        }







        addListeners(fObj) {

          fObj.on('modified', function (options) {
            console.log("modified", "options", options);
          });

        }



        // createFabricSampleObjectWithCanvasBoundingRect(canvasBoundingTrueRect) {
        //
        //   const trueRect = {
        //     left: canvasBoundingTrueRect.left,
        //     top:  canvasBoundingTrueRect.top,
        //     width:  50,
        //     height: 50,
        //   };
        //
        //   var fObj = new fabric.Rect();
        //   fObj.set({
        //     left:   trueRect.left,
        //     top:    trueRect.top,
        //     width:  trueRect.width,
        //     height: trueRect.height,
        //
        //     // fill: '#f55',
        //     fill: 'red',
        //     // opacity: 0.7,
        //
        //     trueRect : trueRect,
        //   });
        //
        //   //event listeners
        //
        //   fObj.on('moving', function(options) {
        //     console.log("moving", "options", options);
        //
        //     const target = options.target;
        //
        //     const trueRect_left__new = (target.left / scale - offset.dx);
        //     const trueRect_top__new  = (target.top  / scale - offset.dy);
        //
        //     const trueRect_update = {
        //       left: trueRect_left__new,
        //       top:  trueRect_top__new,
        //     };
        //
        //     Object.assign(target.trueRect, trueRect_update);
        //     Object.assign(.trueRect, trueRect_update);
        //
        //   });
        //
        //
        //   var isScaling = false;
        //   var original_trueRect = null;
        //   fObj.on('scaling', function(options) {
        //     console.log("scaling", "options", options);
        //     const original = options.transform.original;
        //
        //     const target   = options.transform.target;
        //
        //     if(!isScaling) {
        //       original_trueRect = Object.assign({}, target.trueRect);
        //       console.log("original_trueRect", original_trueRect);
        //       isScaling = true;
        //     }
        //
        //     const scaleFactorX = target.scaleX / original.scaleX;
        //     const scaleFactorY = target.scaleY / original.scaleY;
        //
        //     console.log("scaleFactorX", scaleFactorX);
        //
        //
        //     const trueRect_width__new  = (original_trueRect.width  * scaleFactorX);
        //     const trueRect_height__new = (original_trueRect.height * scaleFactorY);
        //
        //     console.log("trueRect_width__new", trueRect_width__new);
        //
        //     const trueRect_update = {
        //       width:  trueRect_width__new,
        //       height: trueRect_height__new,
        //     };
        //
        //     // Object.assign(target.trueRect, trueRect_update);
        //     Object.assign(fObj.trueRect, trueRect_update);
        //   });
        //   fObj.on('scaled', function(options) {
        //     console.log("scaled", "options", options);
        //     isScaling = false;
        //     original_trueRect = null;
        //
        //     const original = options.transform.original;
        //     const target   = options.transform.target;
        //
        //     target.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //
        //       //not used:
        //       // width:  target.trueRect.width  * scale,
        //       // height: target.trueRect.height * scale,
        //
        //       //used instead:
        //       width:  target.trueRect.width,
        //       height: target.trueRect.height,
        //
        //       scaleX : original.scaleX,
        //       scaleY : original.scaleY,
        //     });
        //     target.setCoords();
        //   });
        //
        //
        //   fObj.on('modified', function(options) {
        //     console.log("modified", "options", options);
        //   });
        //
        //   fObj.on('selected', function(options) {
        //     console.log("selected", "options", options);
        //     const activeObject   = this.infiniteCanvas.canvas.getActiveObject();
        //
        //     console.log("activeObject.trueRect", activeObject.trueRect);
        //     console.log("activeObject.scaleX", activeObject.scaleX);
        //     console.log("activeObject.scaleY", activeObject.scaleY);
        //
        //
        //   });
        //
        //   // fabric.util.addListener(canvas, 'object:modified', function (event, self) {
        //   //   console.log('object:modified', "event", event);
        //   //
        //   // });
        //
        //   return fObj;
        // }



        addOuterFabricObject(fObj) {
          console.log("addOuterFabricObject", fObj);

          const fabricIntegration = this;

          // this.outer_fabric_objects.push(fObj);
          fabricIntegration.fabric_objects.push(fObj);

          const icObj = fObj.icObj;
          fabricIntegration.fObjForIcObj_dict[icObj.id] = fObj;

          fabricIntegration.fabricCanvas.add(fObj);

          const zIndex_fObj__target = fabricIntegration.fObjZIndexForIcObj(fObj.icObj);
          fObj.moveTo(zIndex_fObj__target);

        }

        // addPureOuterFabricObject(fObj) {
        //   console.log("addPureOuterFabricObject", fObj);
        //
        //   // this.outer_fabric_objects.push(fObj);
        //   this.fabric_objects__pure.push(fObj);
        //
        //   this.fabricCanvas.add(fObj);
        // }

        addInnerFabricObject(fObj) {
          console.log("addInnerFabricObject", fObj);

          const fabricIntegration = this;

          fabricIntegration.fabric_objects.push(fObj);

          const icObj = fObj.icObj;
          fabricIntegration.fObjForIcObj_dict[icObj.id] = fObj;

          // fabricIntegration.fabricCanvas.add(fObj);

          const zIndex_fObj__target = fabricIntegration.fObjZIndexForIcObj(fObj.icObj);
          fObj.moveTo(zIndex_fObj__target);
        }


        removeFabricObject(fObj) {
          logger.log("log1", "removeFabricObject", fObj);

          if (fObj.icObj.type == "video") {
            fObj.isShouldRequestAnimationFrame = false;

            /* paradoxically, this code generates bad behavior
            // logger.log("log1", "cancelRequestAnimationFrame", fObj.requestAnimationFrame);
            // cancelRequestAnimationFrame(fObj.requestAnimationFrame);
            // fObj.requestAnimationFrame = null;
            */

            fObj.dispose();
          }


          /*
          //nuke
          // this.fabricCanvas.remove(...this.fabricCanvas.getObjects());
          this.fabricCanvas.remove(...this.fabric_objects);
          */

          console.log("this.fabric_objects.length", this.fabric_objects.length);
          {
            const fabric_objects_new = Utils.arrayByRemovingElement(this.fabric_objects, fObj);

            this.setFabricObjects(fabric_objects_new);
          }
          console.log("this.fabric_objects.length", this.fabric_objects.length);


          console.log("this.fabric_objects", this.fabric_objects);




          // fObj.remove();
          this.fabricCanvas.remove(fObj);

          /*
          //antinuke
          this.fabricCanvas.add(...this.fabric_objects);
          */

          // console.log("this.fabricCanvas", this.fabricCanvas);
          // this.fabricCanvas.requestRenderAll();
        }


        selectAll() {
          const fabricCanvas = this.fabricCanvas;

          fabricCanvas.discardActiveObject();
          const arr_affected = fabricCanvas.getObjects()
            .filter(fObj => fObj.icObj.canBeSelected);
          const sel = new fabric.ActiveSelection(arr_affected, {
            canvas: canvas,
          });
          fabricCanvas.setActiveObject(sel);
          fabricCanvas.requestRenderAll();
        }

        deselectAll() {
          const fabricCanvas = this.fabricCanvas;

          fabricCanvas.discardActiveObject();
          fabricCanvas.renderAll();
        }




        // debugFabric() {
        //
        //   const trueRect = {
        //     top:  100,
        //     left: 100,
        //     width: 20,
        //     height: 20,
        //   };
        //
        //   // create a rectangle object
        //   var fObj = new fabric.Rect({
        //     left: trueRect.left,
        //     top: trueRect.top,
        //     fill: 'red',
        //     width: trueRect.width,
        //     height: trueRect.height,
        //     trueRect : trueRect,
        //   });
        //
        //   this.addFabricObject(fObj);
        // }

        // updateFabricObjectsPosition(redrawOccasion) {
        //   console.log("updateFabricObjectsPosition", redrawOccasion);
        //
        //   const offset      = this.infiniteCanvas.offset;
        //   const scale       = this.infiniteCanvas.scale;
        //
        //   this.fabric_objects.forEach((fObj, i) => {
        //     //console.log("fObj A", fObj);
        //
        //     const icObj = fObj.icObj;
        //
        //     const truePos = {
        //       x: icObj.position.x  + offset.dx,
        //       y: icObj.position.y  + offset.dy,
        //     };
        //
        //     fObj.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //       left: truePos.x * scale.X,
        //       top:  truePos.y * scale.Y,
        //     });
        //
        //     // Object.assign(fObj.trueRect, truePos);
        //     fObj.setCoords();
        //
        //     //console.log("fObj B", fObj);
        //
        //   });
        // }

        updateFabricObjectsPosition(redrawOccasion) {
          const infiniteCanvas = this.infiniteCanvas;

          switch (redrawOccasion) {
            case RedrawOccasion.scaleChanged:
              if(!infiniteCanvas.isDryScrolling) {
                this.updateFabricObjectsPosition_zScroll(redrawOccasion);
              } else {
                this.updateFabricObjectsPosition_default(redrawOccasion);
              }
              break;

            // case RedrawOccasion.orientationChanged:
            //   this.updateFabricObjectsPosition_rScroll();
            //   break;

            default:
              this.updateFabricObjectsPosition_default(redrawOccasion);
              break;
          }

        }

        updateFabricObjectsPosition_zScroll(redrawOccasion) {
          const infiniteCanvas = this.infiniteCanvas;

          const activeObject = this.fabricCanvas.getActiveObject();

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          //SHU: this case is (?) rare (?)
          if (activeObject instanceof fabric.ActiveSelection) {
          //   logger.log("logZScroll", "updateFabricObjectsPosition_zScroll", "activeObject instanceof fabric.ActiveSelection");

          //   // if(activeObject.icObj.isCompositeContentOrPart() || activeObject.icObj.type == "composite") {

          //   //   //get composite
          //   //   var icObj__composite;
          //   //   if(activeObject.icObj.isCompositeContentOrPart()) {
          //   //     const id__composite = activeObject.icObj.compositeId;
          //   //     icObj__composite = infiniteCanvas.getRepresented(id__composite).rep_free();
          //   //   } else {
          //   //     icObj__composite = activeObject.icObj;
          //   //   }

          //   //   //get all .isMobile==false in this composite
          //   //   const arr_children = Object.values(icObj__composite.parts);
          //   //   const arr_children_immobile = arr_children.filter((icObj) => {
          //   //     return icObj.isMobile == false;
          //   //   });

          //   //   arr_children_immobile.forEach((fObj, i) => {
          //   //     this.updateFabricObject_position_zScroll__contained(activeSelection, fObj);
          //   //   });

          //   // } else 
          //   {

          //     const activeSelection = activeObject;

          //     this.updateFabricObject_position_zScroll__container(activeSelection);

          //     const arr_affected = activeSelection.getObjects()
          //       .filter(fObj => fObj.icObj.canBeMoved);

          //     const arr1 = fabric_objects;
          //     const arr2 = arr_affected;

          //     let difference = arr1.filter(x => !arr2.includes(x));
          //     const arr_unaffected = difference;

          //     arr_affected.forEach((fObj, i) => {
          //       this.updateFabricObject_position_zScroll__contained(activeSelection, fObj);
          //     });

          //     arr_unaffected.forEach((fObj, i) => {
          //       this.updateFabricObject_position_default(fObj);
          //     });

          //   }

          } else {
            logger.log("logZScroll", "updateFabricObjectsPosition_zScroll", "fabric_objects", fabric_objects);

            // if(activeObject.icObj.isCompositeContentOrPart() || activeObject.icObj.type == "composite") {

            //   //get composite
            //   var icObj__composite;
            //   if(activeObject.icObj.isCompositeContentOrPart()) {
            //     const id__composite = activeObject.icObj.compositeId;
            //     icObj__composite = infiniteCanvas.getRepresented(id__composite).rep_free();
            //   } else {
            //     icObj__composite = activeObject.icObj;
            //   }

            //   //get all .isMobile==false in this composite
            //   const arr_children = Object.values(icObj__composite.parts);
            //   const arr_children_immobile = arr_children.filter((icObj) => {
            //     return icObj.isMobile == false;
            //   });

            //   arr_children_immobile.forEach((fObj, i) => {
            //     this.updateFabricObject_position_zScroll__contained(activeSelection, fObj);
            //   });

            // }

            fabric_objects.forEach((fObj, i) => {

              if (fObj == activeObject) {
                this.updateFabricObject_position_zScroll__container(fObj);
              } else {
                this.updateFabricObject_position_default(fObj);
              }

            });
          }

        }

        // updateFabricObjectsPosition_rScroll(redrawOccasion) {
        //
        //   const activeObject = this.fabricCanvas.getActiveObject();
        //
        //   // const fabric_objects = this.fabric_objects;
        //   const fabric_objects = this.getFabricObjects();
        //
        //   fabric_objects.forEach((fObj, i) => {
        //
        //     if(fObj == activeObject) {
        //       this.updateFabricObject_position_rScroll(fObj);
        //     } else {
        //       this.updateFabricObject_position_default(fObj);
        //     }
        //
        //   });
        //
        // }


        updateFabricObjectsPosition_default(redrawOccasion) {

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          var arr_fObj_to_move = [];

          const activeObject = this.fabricCanvas.getActiveObject();
          if (activeObject instanceof fabric.ActiveSelection) {   //when panning while there is an activeSelection
            const activeSelection = activeObject;
            logger.log("logAS", "updateFabricObjectsPosition_default", "ActiveSelection:", activeSelection);

            // arr_fObj_to_move = [];
            // arr_fObj_to_move.push(activeSelection);

            // const arr_affected = activeSelection.getObjects();

            // const arr1 = fabric_objects;
            // const arr2 = arr_affected;

            // let difference = arr1.filter(x => !arr2.includes(x));
            // const arr_unaffected = difference;

            // arr_fObj_to_move.push(...arr_unaffected);

          } else  //when panning while there is no activeSelection
          {
            arr_fObj_to_move = [...fabric_objects];
          }

          arr_fObj_to_move.forEach((fObj, i) => {
            this.updateFabricObject_position_default(fObj);
          });

        }

        // updateFabricObject_position_rScroll(fObj) {
        //
        //   const infiniteCanvas = this.infiniteCanvas;
        //
        //   const offset      = infiniteCanvas.offset;
        //   const scale       = infiniteCanvas.scale;
        //
        //   const orientation = 0;
        //
        //   const orientationBaseVectors = infiniteCanvas.getOrientationBaseVectors();
        //
        //   // const origin = {
        //   //   x:0,
        //   //   y:0,
        //   // };
        //
        //   // const centerPoint = infiniteCanvas.getTrueCenterPoint();
        //   // console.log("centerPoint", centerPoint);
        //
        //   function compute_fObj_position_vector(icObj) {
        //
        //     const v1_no_orientation = {
        //       x: icObj.position.x,
        //       y: icObj.position.y,
        //     }
        //
        //     const v1_with_orientation = {
        //       x: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.u),
        //       y: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.v),
        //     };
        //
        //     const v1_with_orientation__with_offset = {
        //       x: v1_with_orientation.x + offset.dx,
        //       y: v1_with_orientation.y + offset.dy,
        //     };
        //
        //     const v1_with_orientation__with_offset__scaled = {
        //       x: v1_with_orientation__with_offset.x * scale.X,
        //       y: v1_with_orientation__with_offset.y * scale.Y,
        //     };
        //
        //     return v1_with_orientation__with_offset__scaled;
        //
        //   }
        //
        //
        //
        //   const icObj = fObj.icObj;
        //
        //   const v = compute_fObj_position_vector(icObj);
        //
        //   fObj.set({
        //     // x: x + offsetX,
        //     // y: y + offsetY,
        //     left: v.x,
        //     top:  v.y,
        //
        //     angle: icObj.orientation - orientation,
        //   });
        //
        //   // Object.assign(fObj.trueRect, truePos);
        //   fObj.setCoords();
        //
        // }

        updateFabricObject_position_zScroll__container(fObj) {
          logger.log("logZScroll", "updateFabricObject_position_zScroll__container", fObj);
          const infiniteCanvas = this.infiniteCanvas;

          const icObj = fObj.icObj;


          var position_update = null;

          const mouseIntegration = this.mouseIntegration;
          // if (mouseIntegration.leftMouseDown) {
          //   logger.log("logZScroll", "leftMouseDown zScroll");

          //   const cursor_truePoint = infiniteCanvas.getTrueCursor();
          //   //SHU: TODO: (later) prendre en compte le point grâce auquel on a attrapé l'objet (ce n'est pas le coin top left)
          //   position_update = cursor_truePoint;
          // } else 
          {
            console.log("logZScroll", "leftMouseUp zScroll");

            const fObj_screenPos = {
              x: fObj.left,
              y: fObj.top,
            };
            position_update = infiniteCanvas.toTruePoint(fObj_screenPos);
          }

          const icObj_new = Object.assign({}, icObj);
          Object.assign(icObj_new.position, position_update);

          icObj.update(icObj_new, false);
        }

        updateFabricObject_position_zScroll__contained(activeSelection, fObj) {
          logger.log("logZScroll", "updateFabricObject_position_zScroll__contained", fObj);

          const infiniteCanvas = this.infiniteCanvas;

          if(fObj.icObj.type == "composite") {
            this.updateFabricObject_position_zScroll__composite(activeSelection, fObj);
          } else {

            const scaleFactor = {
              X: activeSelection.scaleX,
              Y: activeSelection.scaleY,
            };

            const factor = scaleFactor.X / fObj.icObj.scale.X;
            logger.log("logZScroll", "factor", factor);


            //update position
            {
              const icObj = fObj.icObj;

              // const activeSelectionCenterX = activeSelection.width  / 2;
              // const activeSelectionCenterY = activeSelection.height / 2;

              // const fObj_pos_wrt_ASTL = {
              //   left: fObj.left - activeSelectionCenterX,
              //   top:  fObj.top  - activeSelectionCenterY,
              // };
              // logger.log("logZScroll", "fObj_pos_wrt_ASTL", fObj_pos_wrt_ASTL);


              const screePoint__activeSelection_TL = {
                left: activeSelection.left, 
                top:  activeSelection.top,
                
                x: activeSelection.left,
                y: activeSelection.top,
              };
              logger.log("logZScroll", "screePoint__activeSelection_TL", screePoint__activeSelection_TL);

              const truePoint__activeSelection_TL = infiniteCanvas.toNoOrPoint(screePoint__activeSelection_TL);
              logger.log("logZScroll", "truePoint__activeSelection_TL", truePoint__activeSelection_TL);


              const screenPoint__fObj_TL = {
                left: fObj.left, 
                top:  fObj.top,
                
                x: fObj.left,
                y: fObj.top,
              };
              logger.log("logZScroll", "screenPoint__fObj_TL", screenPoint__fObj_TL);

              const truePoint__fObj_TL = infiniteCanvas.toNoOrPoint(screenPoint__fObj_TL);
              logger.log("logZScroll", "truePoint__fObj_TL", truePoint__fObj_TL);

              const truePoint__fObj_TL__after_homot = Geometry.pointWithHomothety(truePoint__fObj_TL, truePoint__activeSelection_TL, factor);




              const position_update = truePoint__fObj_TL__after_homot;


              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new.position, position_update);

              icObj.update(icObj_new, false);

            }

          }

        }

        updateFabricObject_position_zScroll__composite(fObj) {
          logger.log("logZScroll", "updateFabricObject_position_zScroll__composite", fObj);

          const scaleFactor = {
            X: activeSelection.scaleX,
            Y: activeSelection.scaleY,
          };

          //update position
          {
            const icObj = fObj.icObj;

            const activeSelectionCenterX = activeSelection.width / 2;
            const activeSelectionCenterY = activeSelection.height / 2;

            const fObj_pos_wrt_ASTL = {
              left: activeSelectionCenterX + fObj.left,
              top: activeSelectionCenterY + fObj.top,
            };

            const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

            const fObj_screenPos = {
              x: activeSelection.left + scaleFactor.X * (Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left - Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top),
              y: activeSelection.top  + scaleFactor.Y * (Math.sin(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.left + Math.cos(activeSelection_angleInRadians) * fObj_pos_wrt_ASTL.top),
            };

            const position_update = infiniteCanvas.toTruePoint(fObj_screenPos);

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new.position, position_update);

            icObj.update(icObj_new, false);

          }

        }


        updateFabricObject_position_default(fObj) {
          // logger.log("updateFabricObject_position_default", fObj);

          //SHU: TODO: update fabric.Line object position
          // if(fObj instanceof fabric.Line) {
          // return;
          // }

          //ignore these types
          switch (fObj.icObj.type) {
            case "HUD_point":
            case "HUD_segment":
            case "HUD_line":
              return;
          }

          // if(fObj.icObj.type == "sparkle") {
          //   return;
          // }


          const infiniteCanvas = this.infiniteCanvas;

          const offset = infiniteCanvas.offset;
          const scale = infiniteCanvas.scale;

          const orientation = infiniteCanvas.orientation;

          const orientationBaseVectors = infiniteCanvas.getOrientationBaseVectors();

          // const origin = {
          //   x:0,
          //   y:0,
          // };

          // const centerPoint = infiniteCanvas.getTrueCenterPoint();
          // console.log("centerPoint", centerPoint);

          function compute_fObj_position_vector(position) {

            const v1_no_orientation = {
              x: position.x,
              y: position.y,
            }

            const v1_with_orientation = {
              x: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.u),
              y: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.v),
            };

            const v1_with_orientation__with_offset = {
              x: v1_with_orientation.x + offset.dx,
              y: v1_with_orientation.y + offset.dy,
            };

            const v1_with_orientation__with_offset__scaled = {
              x: v1_with_orientation__with_offset.x * scale.X,
              y: v1_with_orientation__with_offset.y * scale.Y,
            };

            return v1_with_orientation__with_offset__scaled;

          }


          switch (fObj.icObj.type) {
            case "segment":
              {
                const icObj = fObj.icObj;

                const v1 = compute_fObj_position_vector(icObj.point_start);
                const v2 = compute_fObj_position_vector(icObj.point_end);

                fObj.set({
                  x1: v1.x,
                  y1: v1.y,
                  x2: v2.x,
                  y2: v2.y,

                  angle: icObj.orientation - orientation,
                });
              }
              break;
            default:
              {
                const icObj = fObj.icObj;

                const v = compute_fObj_position_vector(icObj.position);
                // logger.log("v", v);

                fObj.set({
                  // x: x + offsetX,
                  // y: y + offsetY,
                  left: v.x,
                  top: v.y,

                  angle: icObj.orientation - orientation,
                });

                //SHU ?
                // if(fObj.clipPath != null) {

                //   const fObj__clipPath  = fObj.clipPath; 
                //   const icObj__clipPath = fObj__clipPath.icObj;
                //   const v__clipPath     = compute_fObj_position_vector(icObj__clipPath.position);

                //   fObj__clipPath.set({
                //     left: v__clipPath.x,
                //     top:  v__clipPath.y,
  
                //     angle: icObj__clipPath.orientation - orientation,
                //   });

                // }

              }
              break;
          }

          fObj.setCoords();
        }






        updateFabricObjectsSize(redrawOccasion) {
          console.log("updateFabricObjectsSize", redrawOccasion);

          switch (redrawOccasion) {
            case RedrawOccasion.scaleChanged:
              if(!infiniteCanvas.isDryScrolling) {
                this.updateFabricObjectsSize_zScroll();
              } else {
                this.updateFabricObjectsSize_default();
              }
              break;

            default:
              this.updateFabricObjectsSize_default();
              break;
          }

          // canvas.renderAll();
        }


        updateFabricObjectsSize_zScroll() {

          const activeObject = this.fabricCanvas.getActiveObject();
          logger.log("logZScroll", "updateFabricObjectsSize_zScroll", "activeObject", activeObject);

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          if (activeObject instanceof fabric.ActiveSelection) {
            logger.log("logZScroll", "updateFabricObjectsSize_zScroll", "activeObject instanceof fabric.ActiveSelection");

            // const activeSelection = activeObject;

            // this.updateFabricObject_size_zScroll(activeSelection);

            // const arr_affected = activeSelection.getObjects()
            //   .filter(fObj => fObj.icObj.canBeMoved);


            // const arr1 = fabric_objects;
            // const arr2 = arr_affected;

            // let difference = arr1.filter(x => !arr2.includes(x));
            // const arr_unaffected = difference;

            // arr_affected.forEach((fObj, i) => {
            //   this.updateFabricObject_size_zScroll(fObj);
            // });

            // arr_unaffected.forEach((fObj, i) => {
            //   this.updateFabricObject_size_default(fObj);
            // });

          } else {
            fabric_objects.forEach((fObj, i) => {

              if(!infiniteCanvas.isAltering && !infiniteCanvas.isDeepAltering && (activeObject != null) && (fObj == activeObject) && (fObj.icObj.isCompositeContentOrPart() || fObj.icObj.type == "composite")) {
                //activeObject object is part of composite: affect all objects in composite  
                
                if(fObj.icObj.isCompositeContentOrPart()) {
                  logger.log("logZScroll", "updateFabricObjectsSize_zScroll", "fObj.icObj.isCompositeContentOrPart()");
                } else if(fObj.icObj.type == "composite") {
                  logger.log("logZScroll", "updateFabricObjectsSize_zScroll", 'activeObject.icObj.type == "composite"');
                }

                // //get composite
                // var icObj__composite;
                // if(fObj.icObj.isCompositeContentOrPart()) {
                //   const id__composite = fObj.icObj.compositeId;
                //   icObj__composite    = infiniteCanvas.getRepresented(id__composite).getRepresentation("free");
                // } else {
                //   icObj__composite = fObj.icObj;
                // }

                // //update composite scale
                // const fObj__composite = this.getFObjForIcObj(icObj__composite);
                // this.updateFabricObject_size_zScroll(fObj__composite);

                //get root composite
                var icObj__root_composite;
                if(fObj.icObj.isCompositeContentOrPart()) {
                  const root_composite__rep_official = infiniteCanvas.getRootCompositeForContentOrPart(fObj.icObj);
                  const root_composite__rep_free     = infiniteCanvas.getRepresented(root_composite__rep_official.id).getRepresentation("free");
                  icObj__root_composite    = root_composite__rep_free;
                } else {
                  icObj__root_composite = fObj.icObj;
                }

                //update root composite scale
                // const fObj__root_composite = this.getFObjForIcObj(icObj__root_composite);
                // this.updateFabricObject_size_zScroll(fObj__root_composite);
                {
                  const scale      = infiniteCanvas.scale;
                  const scale_fObj = {X: fObj.scaleX, Y: fObj.scaleY};
                  const icObj      = fObj.icObj;

                  const scaleFactor = {
                    X: scale.X / (scale_fObj.X * icObj.homeScale.X),
                    Y: scale.Y / (scale_fObj.Y * icObj.homeScale.Y),
                  };

                  const homeScale_new = {
                    X: icObj__root_composite.homeScale.X * (scaleFactor.X),    
                    Y: icObj__root_composite.homeScale.Y * (scaleFactor.Y),    
                  };
                  logger.log("logZScroll", "updateStdFObj_size_zScroll", "homeScale_new", homeScale_new);

                  const icObj_update = {
                    homeScale: homeScale_new,
                  };

                  const icObj__root_composite_new = Object.assign({}, icObj__root_composite);
                  Object.assign(icObj__root_composite_new, icObj_update);

                  icObj__root_composite.update(icObj__root_composite_new, false);
                }

              } else 
              if (fObj == activeObject) {
                this.updateFabricObject_size_zScroll(fObj);
              } else if(fObj == "children of active object") {

              } else {
                this.updateFabricObject_size_default(fObj);
              }

            });
          }



        }

        updateFabricObjectsSize_default() {
          console.log("updateFabricObjectsSize_default");

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          fabric_objects.forEach((fObj, i) => {
            this.updateFabricObject_size_default(fObj);
          });

        }



        updateFabricObject_size_zScroll(fObj) {
          console.log("updateFabricObject_size_zScroll", fObj);
          console.log("fObj.icObj", fObj.icObj);

          const scale = this.infiniteCanvas.scale;

          // if(fObj instanceof fabric.ActiveSelection) {
          // updateActiveSelectionFObj_size_zScroll(fObj);
          // } else {
          updateStdFObj_size_zScroll(fObj);
          // }



          function updateStdFObj_size_zScroll(fObj) {
            logger.log("logZScroll", "updateStdFObj_size_zScroll", fObj);

            const scale_fObj = {
              X: fObj.scaleX,
              Y: fObj.scaleY,
            };
            console.log("scale_fObj", scale_fObj);

            const icObj = fObj.icObj;
            logger.log("logZScroll", "updateStdFObj_size_zScroll", "icObj", icObj);


            var homeScale_new;

            if (fObj instanceof fabric.Text) {

              const fontSize_fObj = fObj.fontSize;
              const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;

              // homeScale_new = {
              //   X: scale.X / scale_fObj.X / scaleFactor__fontSize,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

              homeScale_new = {
                X: scale.X / (scale_fObj.X / icObj.scale.X) / scaleFactor__fontSize,
                Y: scale.Y / (scale_fObj.Y / icObj.scale.Y) / scaleFactor__fontSize,
              };

            } else {

              // homeScale_new = {
              //   X: scale.X / scale_fObj.X,
              //   Y: scale.Y / scale_fObj.Y,
              // };

              homeScale_new = {
                X: scale.X / (scale_fObj.X / icObj.scale.X),
                Y: scale.Y / (scale_fObj.Y / icObj.scale.Y),
              };

              // homeScale_new = {
              //   X: scale.X,
              //   Y: scale.Y,
              // };

            }
            logger.log("logZScroll", "updateStdFObj_size_zScroll", "homeScale_new", homeScale_new);

            const icObj_update = {
              homeScale: homeScale_new,
            };

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);

            icObj.update(icObj_new, false);

            // fObj.setCoords();

          }

          // function updateActiveSelectionFObj_size_zScroll(activeSelection) {

          //   activeSelection.getObjects().forEach((fObj, i) => {
          //     updateStdFObj_size_zScroll(fObj);
          //   });


          // }


        }

        updateFabricObject_size_default(fObj) {
          console.log("updateFabricObject_size_default", fObj);

          //SHU: TODO: update fabric.Line object position
          // if(fObj instanceof fabric.Line) {
          //   return;
          // }

          //ignore these types
          switch (fObj.icObj.type) {
            case "HUD_point":
            case "HUD_segment":
            case "HUD_line":
              return;
            case "point":
            case "segment":
            case "line":
              return;
          }

          if (fObj.icObj.isScaleless) {    //for mixedScale objects
            return;
          }

          // if(fObj.icObj.type == "sparkle") {
          //   return;
          // }


          const scale = this.infiniteCanvas.scale;
          console.log("scale", scale);

          console.log("scale.X", scale.X);
          console.log("fObj.icObj.homeScale.X", fObj.icObj.homeScale.X);

          const scaleFactorX = scale.X / fObj.icObj.homeScale.X;
          const scaleFactorY = scale.Y / fObj.icObj.homeScale.Y;

          const scaleFactor = {
            X: scaleFactorX,
            Y: scaleFactorY,
          };

          console.log("scaleFactorX", scaleFactorX);



          if (fObj instanceof fabric.Text) {

            // const fontSize = fObj.true_fontSize * scale;
            // const fontSize = fObj.icObj.fontSize * scale.X;
            const fontSize = fObj.icObj.fontSize * scaleFactor.X;

            console.log("fontSize", fontSize);
            // fObj.set({
            //   fontSize: fontSize,
            // });

            const fontSize_max = 10000;
            // if(fontSize > fontSize_max) {
            //
            //   const scaleAmount_fix = (fontSize - fontSize_max) / fontSize_max;
            //   const scale_fix = 1.0 * (1 + scaleAmount_fix);
            //   console.log("scale_fix", scale_fix);
            //
            //   fObj.set({
            //     fontSize: fontSize_max,
            //
            //     scaleX: scale_fix,
            //     scaleY: scale_fix,
            //   });
            //
            // } else {
            //   fObj.set({
            //     fontSize: fontSize,
            //
            //     scaleX: 1,
            //     scaleY: 1,
            //   });
            // }

            function scaleWithTargetFontSize(targetFontSize) {

              const scaleAmount_fix = (fontSize - targetFontSize) / targetFontSize;
              const scale_fix = {
                X: fObj.icObj.scale.X * (1 + scaleAmount_fix),
                Y: fObj.icObj.scale.Y * (1 + scaleAmount_fix),
              };
              console.log("scale_fix", scale_fix);

              fObj.set({
                fontSize: targetFontSize,

                scaleX: scale_fix.X,
                scaleY: scale_fix.Y,
              });

            }

            if (fontSize > fontSize_max) {

              scaleWithTargetFontSize(fontSize_max);

            } else {
              // fObj.set({
              //   fontSize: fontSize,
              //
              //   scaleX: fObj.icObj.scale.X,
              //   scaleY: fObj.icObj.scale.Y,
              // });

              const closestIntegerFontSize = Math.max(1, Math.floor(fontSize));

              scaleWithTargetFontSize(closestIntegerFontSize);

            }



          }
          // else if(fObj instanceof fabric.Image) {
          //
          //   // fObj.scale(scale);
          //
          //   const width  = fObj.icObj.img.width  * scale.X;
          //   const height = fObj.icObj.img.height * scale.Y;
          //
          //   fObj.scaleToWidth(width);
          //   fObj.scaleToHeight(height);
          //
          // } else if(fObj instanceof fabric.Rect) {
          else {

            // if(fObj.icObj.isPoint != null && fObj.icObj.isPoint) {
            //
            //   const point_precision_factor = 100;
            //   fObj.set({
            //     // width:  point_precision_factor * this.infiniteCanvas.scaleX,
            //     // height: point_precision_factor * this.infiniteCanvas.scaleY,
            //
            //     scaleX: point_precision_factor * this.infiniteCanvas.scaleX,
            //     scaleY: point_precision_factor * this.infiniteCanvas.scaleY,
            //   });
            //
            // }
            // else {

            console.log("fObj", fObj);
            fObj.set({
              scaleX: fObj.icObj.scale.X * scaleFactor.X,
              scaleY: fObj.icObj.scale.Y * scaleFactor.Y,
            });

            //SHU ?
            // if(fObj.clipPath != null) {

            //   const fObj__clipPath  = fObj.clipPath;

            //   fObj__clipPath.set({
            //     scaleX: fObj__clipPath.icObj.scale.X * scaleFactor.X,
            //     scaleY: fObj__clipPath.icObj.scale.Y * scaleFactor.Y,
            //   });

            // }

            // }

            //handle when image is forced to scale to icObj's width and height
            if (fObj instanceof fabric.Image) {
              const icObj = fObj.icObj;
              if (icObj.force_width) {
                const factor__force_width = icObj.width / icObj.img.width;
                fObj.set({
                  scaleX: fObj.scaleX * factor__force_width,
                });
              }
              if (icObj.force_height) {
                const factor__force_height = icObj.height / icObj.img.height;
                fObj.set({
                  scaleY: fObj.scaleY * factor__force_height,
                });
              }
            }

          }
          // else {
          //   console.log("unknown instance type");
          // }

          fObj.setCoords();

        }






        updateIcObjWithFObj(fObj) {
          console.log("updateIcObjWithFObj", fObj);

          const offset = this.infiniteCanvas.offset;
          const scale = this.infiniteCanvas.scale;
          console.log("scale", scale);


          const trueRect_update = {
            left: fObj.left / scale.X - offset.dx,
            top: fObj.top / scale.Y - offset.dy,

            width: fObj.width / scale.X,
            height: fObj.height / scale.Y,
          };

          const icObj_update = {
            position: Geometry.createPoint(trueRect_update.left, trueRect_update.top),
            size: Geometry.createSize(trueRect_update.width, trueRect_update.height),
          };

          const icObj = fObj.icObj;

          const icObj_new = Object.assign({}, icObj);
          Object.assign(icObj_new, icObj_update);

          console.log("icObj_new", icObj_new);

          icObj.update(icObj_new, false);

        }



        //varying bg color

        initializeVaryingBgColor() {
          const fabricCanvas = this.fabricCanvas;

          function createBgColorAnimation() {

            const duration__step = 2000;

            //get color_from
            const fColor__bg = new fabric.Color(fabricCanvas.backgroundColor);
            // logger.log("logBG", "fColor__bg:", fColor__bg);
            const arr__rgba = fColor__bg.getSource();
            const animated__from = {
              r: arr__rgba[0],
              g: arr__rgba[1],
              b: arr__rgba[2],
            };
            const animatedObj = {
              r: animated__from.r,
              g: animated__from.g,
              b: animated__from.b,
            };

            const dict__rgb__to = ColorUtils.randomColor__dict();
            var animated__to    = Object.assign({}, dict__rgb__to);
              
            const cfg_anim__easy = {
              duration:  duration__step,
            };
            const cfg_anim = Object.assign({
              targets: animatedObj,

              /*animated props*/
              r: animated__to.r,
              g: animated__to.g,
              b: animated__to.b,
              /*--------------*/

              direction: 'normal',
              easing:    'linear',

              autoplay: false,
              loop:     false,

              update: (anim) => {
                // logger.log("logBG", "initializeVaryingBgColor", "update", "anim:", anim);
                const str__color_rgb = 'rgb(' + animatedObj.r + ',' + animatedObj.g + ',' + animatedObj.b + ')'; 
                fabricCanvas.backgroundColor = str__color_rgb;
                fabricCanvas.requestRenderAll();
              },

            }, cfg_anim__easy);

            var animation = anime(cfg_anim);

            animation.finished.then(() => {

              animation = null;

              const animation__bgColor = createBgColorAnimation();
              animation__bgColor.play();

            });

            return animation;
          }

          //const animation__bgColor = createBgColorAnimation();
          //animation__bgColor.play();
            
        }






        //free drawing

        initializeFreeDrawing() {

          const fabricIntegration = this;

          if (fabric.PatternBrush) {
            var vLinePatternBrush = new fabric.PatternBrush(canvas);
            vLinePatternBrush.getPatternSrc = function () {

              var patternCanvas = fabric.document.createElement('canvas');
              patternCanvas.width = patternCanvas.height = 10;
              var ctx = patternCanvas.getContext('2d');

              ctx.strokeStyle = this.color;
              ctx.lineWidth = 5;
              ctx.beginPath();
              ctx.moveTo(0, 5);
              ctx.lineTo(10, 5);
              ctx.closePath();
              ctx.stroke();

              return patternCanvas;
            };

            var hLinePatternBrush = new fabric.PatternBrush(canvas);
            hLinePatternBrush.getPatternSrc = function () {

              var patternCanvas = fabric.document.createElement('canvas');
              patternCanvas.width = patternCanvas.height = 10;
              var ctx = patternCanvas.getContext('2d');

              ctx.strokeStyle = this.color;
              ctx.lineWidth = 5;
              ctx.beginPath();
              ctx.moveTo(5, 0);
              ctx.lineTo(5, 10);
              ctx.closePath();
              ctx.stroke();

              return patternCanvas;
            };

            var squarePatternBrush = new fabric.PatternBrush(canvas);
            squarePatternBrush.getPatternSrc = function () {

              var squareWidth = 10, squareDistance = 2;

              var patternCanvas = fabric.document.createElement('canvas');
              patternCanvas.width = patternCanvas.height = squareWidth + squareDistance;
              var ctx = patternCanvas.getContext('2d');

              ctx.fillStyle = this.color;
              ctx.fillRect(0, 0, squareWidth, squareWidth);

              return patternCanvas;
            };

            var diamondPatternBrush = new fabric.PatternBrush(canvas);
            diamondPatternBrush.getPatternSrc = function () {

              var squareWidth = 10, squareDistance = 5;
              var patternCanvas = fabric.document.createElement('canvas');
              var rect = new fabric.Rect({
                width: squareWidth,
                height: squareWidth,
                angle: 45,
                fill: this.color
              });

              var canvasWidth = rect.getBoundingRect().width;

              patternCanvas.width = patternCanvas.height = canvasWidth + squareDistance;
              rect.set({ left: canvasWidth / 2, top: canvasWidth / 2 });

              var ctx = patternCanvas.getContext('2d');
              rect.render(ctx);

              return patternCanvas;
            };

            // var img = new Image();
            // img.src = 'img/sparkle_gradient.png';
            //
            // var texturePatternBrush = new fabric.PatternBrush(canvas);
            // texturePatternBrush.source = img;
          }


          //install PencilBrush
          try {
            // const brush__zpencil = new fabric.ZPencilBrush(this.fabricCanvas);
            const brush__zpencil = fabric.ZPencilBrush.createInstance(this.fabricCanvas);
            brush__zpencil.color = new fabric.Color("black").toRgba();
            brush__zpencil.width = 20;
            brush__zpencil.zIndex__ic = 0;
            brush__zpencil.zIndex     = 0;
            brushUpgrade__preview(brush__zpencil);
            brushUpgrade__pathWithBrushProperty(brush__zpencil);
            this.fabricCanvas.freeDrawingBrush = brush__zpencil;
            this.fabricCanvas.freeDrawingBrush._setBrushStyles(this.fabricCanvas.contextContainer);

            fabricIntegration.storeBrush(brush__zpencil, "main");
          } catch(e) {
            logger.log("logComb", "error: ", e);
          }

          //install PencilBrush
          try {
            // const brush__zpencil = new fabric.ZPencilBrush(this.fabricCanvas);
            const brush__zpencil = fabric.ZPencilBrush.createInstance(this.fabricCanvas);
            brush__zpencil.color = "rgba(233,212,96,0.42)";
            brush__zpencil.width = 67;
            brush__zpencil.zIndex__ic = 0;
            brush__zpencil.zIndex     = 0;
            brushUpgrade__preview(brush__zpencil);
            brushUpgrade__pathWithBrushProperty(brush__zpencil);
            this.fabricCanvas.pathmadeDrawingBrush = brush__zpencil;
            this.fabricCanvas.pathmadeDrawingBrush._setBrushStyles(this.fabricCanvas.contextContainer);

            fabricIntegration.storeBrush(brush__zpencil, "pathmade");
          } catch(e) {
            logger.log("logComb", "error: ", e);
          }

          //install PencilBrush
          try {
            const brush__ssPencil = fabric.StraightStrokePencilBrush.createInstance(this.fabricCanvas);
            brush__ssPencil.color = "rgba(233,96,212,0.42)";
            brush__ssPencil.width = 67;
            brush__ssPencil.zIndex__ic = 0;
            brush__ssPencil.zIndex     = 0;
            // brushUpgrade__preview(brush__ssPencil);
            // brushUpgrade__pathWithBrushProperty(brush__ssPencil);

            // this.fabricCanvas.pathmadeSSBrush = brush__ssPencil;
            // this.fabricCanvas.pathmadeSSBrush._setBrushStyles(this.fabricCanvas.contextContainer);

            fabricIntegration.storeBrush(brush__ssPencil, "ssPathmade");
          } catch(e) {
            logger.log("logComb", "error: ", e);
          }


          //install adhesive freeDrawing
          // this.fabricCanvas.on('mouse:down:before', (this.freeDrawing__adhesive__checkForSupport).bind(this));


          //install PencilBrush
          try {
            // const brush__zpencil = new fabric.ZPencilBrush(this.fabricCanvas);
            const brush__zpencil = fabric.ZPencilBrush.createInstance(this.fabricCanvas);
            brush__zpencil.color = new fabric.Color("black").toRgba();
            brush__zpencil.opacity = 0.4;
            brush__zpencil.width = 20;
            brush__zpencil.zIndex__ic = 0;
            brush__zpencil.zIndex     = 0;
            brushUpgrade__preview(brush__zpencil);
            brushUpgrade__pathWithBrushProperty(brush__zpencil);
            this.fabricCanvas.fdApplyBrush = brush__zpencil;
            this.fabricCanvas.fdApplyBrush.config = {};
            this.fabricCanvas.fdApplyBrush._setBrushStyles(this.fabricCanvas.contextContainer);

            fabricIntegration.storeBrush(brush__zpencil, "fdApply");
          } catch(e) {
            logger.log("logFDApply", "error: ", e);
          }
        }

        freeDrawing__adhesive__checkForSupport() {
          logger.log("logFD", "freeDrawing__adhesive__checkForSupport");

          const fabricIntegration = this;
          const infiniteCanvas    = fabricIntegration.infiniteCanvas;

          const fCursor       = fabricIntegration.getFCursor(false);
          const fObj__support = fabricIntegration.getFObjAtFPosition(fCursor);
          logger.log("logFD", "freeDrawing__adhesive__checkForSupport", "fObj__support:", fObj__support);

          //OR
          // const trueCursor = infiniteCanvas.getTrueCursor();
          // const iCObj      = infiniteCanvas.getIcObjContainingPoint(trueCursor)

          if(fObj__support != null) {
            const icObj__support = fObj__support.icObj;
            if(icObj__support != null) {
              infiniteCanvas.adhesive__support__icObj = icObj__support;
              logger.log("logFD", "freeDrawing__adhesive__checkForSupport", "icObj__support:", icObj__support);

            } 
          }
          
        }


        storeBrush(brush, brushName) {
          this.dict_brush[brushName] = brush;
        }

        getStoredBrush(brushName) {
          return this.dict_brush[brushName];
        }



        saveBrush(brushName) {
          const fabricCanvas = this.fabricCanvas;
          const brush        = fabricCanvas.freeDrawingBrush; 

          const brush__clone = brush.deepClone();
          this.storeBrush(brush__clone, brushName);
        }
        
        // restoreBrush(brushName) {
        swapToBrush(brushName) {
          const fabricCanvas = this.fabricCanvas;

          const brush = this.getStoredBrush(brushName);
          
          fabricCanvas.freeDrawingBrush = brush; 
        }


        configureFreeDrawingBrush(dict_update) {
          // logger.log("logFDZ", "configureFreeDrawingBrush", "dict_update:", dict_update);

          const brush = this.fabricCanvas.freeDrawingBrush;
          // if(brush instanceof fabric.CombPencilBrush) {
          //   brush = brush.arr_brush[0].brush_raw;   //SHU: a bit ugly
          //   // logger.log("logComb", "brush = brush.arr_brush[0];");
          // } 

          Object.entries(dict_update).forEach(([k,v]) => {
            switch(k) {
              case "color":
                {
                  brush.color = v;
                }
                break;
              case "opacity":
                {
                  const fColor = new fabric.Color(brush.color);
                  fColor.setAlpha(v);
                  brush.color = fColor.toRgba();
                }
                break;
              case "lightness":
                {
                  const fColor__old = new fabric.Color(brush.color);
                  const lightness = v;
                  const fColor__new = ColorUtils.fColorWithLightness(fColor__old, lightness);
                  brush.color = fColor__new.toRgba(); 
                }
                break;
              case "width":
                {
                  brush.width = v;
                }
                break;
              case "homeScale":
                {
                  brush.homeScale = v;
                }
                break;
              case "zIndex__ic":
                {
                  logger.log("logFDZ", "configureFreeDrawingBrush", "zIndex__ic:", v);
                  brush.zIndex__ic = v;
                  
                  const zIndex__fObj = this.fObjZIndexForIcZIndex(v);
                  logger.log("logFDZ", "configureFreeDrawingBrush", "zIndex__fObj:", zIndex__fObj);
                  brush.zIndex         = zIndex__fObj;
                }
                break;
              default:
                {
                  throw new Error("unsupported brush update key: " + key);
                }
                break;
            }
          });


        }

        // brushConfig__freeDrawing() {
        //   var outBrushConfig = {};

        //   outBrushConfig.width  = this.inputProperties.getActiveBrushWidth();

        //   const rgbaColorString = this.inputProperties.getActiveRgbaColorString();
        //   outBrushConfig.color  = rgbaColorString;

        //   const fColor = new fabric.Color(rgbaColorString);
        //   logger.log("fColor", fColor);
        //   outBrushConfig.fColor = fColor;

        //   if(this.infiniteCanvas.lock_homeScale_isActive) {
        //     outBrushConfig.homeScale = this.inputProperties.getActiveHomeScale();
        //   }

        //   outBrushConfig.zIndex__ic = this.inputProperties.getActiveBrushZIndex();

        //   outBrushConfig.isAdhesive = this.inputProperties.brushIsAdhesive;
        //   // outBrushConfig.isAdhesive = this.inputProperties.isAdhesive;

        //   return outBrushConfig;
        // }

        enterFreeDrawing__atomic(cfg) {
          logger.log("logFD", "enterFreeDrawing__atomic", cfg);

          const fabricIntegration = this;

          // fabricIntegration.configureFreeDrawingBrush({
          //   zIndex__ic: this.inputProperties.getActiveBrushZIndex(),
          // });

          function freeDrawing_objectAdded__atomic(e) {
            logger.log("logFD", "freeDrawing_objectAdded__atomic", e);

            const fObj = e.target;

            // const brush__atDrawingStart = fabricIntegration.brushConfig__current;
            const brush__atDrawingEnd   = fObj.__brush;

            // const fColor   = new fabric.Color(brush__atDrawingStart.color);
            const fColor   = new fabric.Color(brush__atDrawingEnd.color); //SHU: TODO: brush__atDrawingStart
            const rgbColor = fColor.toRgb();
            const opacity  = fColor.getAlpha();
            
            fObj.set({
              strokeWidth:  brush__atDrawingEnd.width,

              stroke:  rgbColor,
              opacity: opacity,

              isCosmetic: cfg.isCosmetic,   //<--\
                                            //    |--- //SHU: these too are quite incompatible...
              isAdhesive: cfg.isAdhesive,   //<--/
            });

            logger.log("logFD", "fObj.zIndex", fObj.zIndex);
            logger.log("logFD", "fObj", fObj);
            fObj.moveTo(fObj.zIndex);

            fObj.zIndex__ic = brush__atDrawingEnd.zIndex__ic;

            fabricIntegration.manageCreatedFreeDrawingObject__atomic(fObj);
          }

          this.freeDrawing_objectAdded__atomic = freeDrawing_objectAdded__atomic;
          this.fabricCanvas.on('object:added', this.freeDrawing_objectAdded__atomic);
        }

        leaveFreeDrawing__atomic(fObj) {
          logger.log("logFD", "leaveFreeDrawing__atomic");
          this.fabricCanvas.off('object:added', this.freeDrawing_objectAdded__atomic);
          this.freeDrawing_objectAdded__atomic = null;        
        }

        manageCreatedFreeDrawingObject__atomic(fObj) {
          logger.log("logFD", "manageCreatedFreeDrawingObject__atomic", fObj);
          
          //listener:off 
          this.fabricCanvas.off('object:added', this.freeDrawing_objectAdded__atomic);

          //work
          {
            const icObj = this.infiniteCanvas.createIcFreeDrawing_from_freeDrawingFObj(fObj);
            logger.log("logFD", "fObj.zIndex__ic", fObj.zIndex__ic);
            icObj.zIndex = fObj.zIndex__ic;

            //recycle fObj
            fObj.id_recycle = icObj.id;

            this.infiniteCanvas.addIcObject(icObj); 

            // //manage .isAdhesive
            // if(fObj.isAdhesive) {
            //   //simple


            //   //complex: joining adhesive

            // }

            this.arr_icFreeDrawing.push(icObj);
          }

          //allow: many freeDrawings in one freeDrawing session
          this.fabricCanvas.on('object:added', this.freeDrawing_objectAdded__atomic);

        }

        enterFreeDrawing(cfg) {
          logger.log("logFD", "enterFreeDrawing");
          const fabricIntegration = this;

          //setup brush
          // const brushConfig = this.brushConfig__freeDrawing();
          // this.configureFreeDrawingBrush(brushConfig);
          this.configureFreeDrawingBrush({
            
          });

          const brushZIndex_new = infiniteCanvas.getFreshIcZIndex__max();
          fabricIntegration.configureFreeDrawingBrush({zIndex__ic: brushZIndex_new});

          this.fabricCanvas.isDrawingMode = true;

          //create arr for icFreeDrawings
          this.arr_icFreeDrawing = [];

          //check for adhesive support
          this.freeDrawing__adhesive__checkForSupport();
          
          //call atomic
          this.enterFreeDrawing__atomic(cfg);
        }

        leaveFreeDrawing() {
          logger.log("logFD", "leaveFreeDrawing");
          this.brush__preview__stop();

          this.leaveFreeDrawing__atomic();

          //get all created freeDrawing objects
          this.manageCreatedFreeDrawingObjects(this.arr_icFreeDrawing);

          //restore singleBrush
          if(inputProperties.brush__single != null) {
            const singleBrush = inputProperties.brush__single;
            // fabricIntegration.setBrush__hotSwap(singleBrush);
            singleBrush._reset();
            fabricIntegration.fabricCanvas.freeDrawingBrush = singleBrush;
          }

          this.fabricCanvas.isDrawingMode = false;
        }

        brush__preview__stop() {
          const brush = this.fabricCanvas.freeDrawingBrush;
          brush.clearPreview?.();
        }

        manageCreatedFreeDrawingObjects(arr_icFreeDrawing) {
          logger.log("logFD", "manageCreatedFreeDrawingObjects", arr_icFreeDrawing);

          const infiniteCanvas = this.infiniteCanvas;

          var icObj__freeDrawing__result;
          if(arr_icFreeDrawing.length > 1) {

            //create composite
            const icFreeDrawing0 = arr_icFreeDrawing.find(e => true);
            const trueRect__composite = {
              x: icFreeDrawing0.position.x,
              y: icFreeDrawing0.position.y,
              width:  10,
              height: 10,
            };
            const parts = arr_icFreeDrawing.reduce((acc, icFreeDrawing) => {
              const partName = "freeDrawing__" + icFreeDrawing.id;
              acc[partName] = icFreeDrawing;
              return acc;
            }, {});
            const compositeConfig = Compositer.defaultCompositeConfig(parts, false, false);
            const icComposite     = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig); 
            icComposite.cType = "freeDrawingObj";
            icComposite.isEntity = true;
            // icComposite.fillColor = "green";

            //SHU: illusion
            icComposite.fill    = "transparent";
            // icComposite.opacity = 0;

            //add composite 
            infiniteCanvas.addNewIcObject(icComposite);

            icObj__freeDrawing__result = icComposite;

          } else {
            //only one icObj (arr_icFreeDrawing.length == 1) : don't create composite 
            const icFreeDrawing0       = arr_icFreeDrawing.find(e => true);
            icObj__freeDrawing__result = icFreeDrawing0; 
          }

          // if(icObj__freeDrawing__result.fObj.isAdhesive) {
          const isAdhesive = arr_icFreeDrawing.find(e => true)?.exoObject.isAdhesive;
          if(isAdhesive) {

            if((arr_icFreeDrawing.length > 0) && (infiniteCanvas.adhesive__support__icObj != null)) {
              const icObj__support__start           = infiniteCanvas.adhesive__support__icObj;
              const rep_free__icObj__support__start = infiniteCanvas.getRepresented(icObj__support__start.id).r_free(); //SHU: probably overkill

              //manage adhesion
              infiniteCanvas.manageAdhesion(icObj__freeDrawing__result, rep_free__icObj__support__start);  
            }

            if(infiniteCanvas.adhesive__isAdhesiveKick) {
              const true_cursor = infiniteCanvas.getTrueCursor();
              const icObj__support__end = infiniteCanvas.getCandidateSupportUnderPoint(true_cursor, icObj__freeDrawing__result);
              if(icObj__support__end != null) {
                const rep_free__icObj__support__end = infiniteCanvas.getRepresented(icObj__support__end.id).r_free();

                //manage adhesion
                infiniteCanvas.manageAdhesion(icObj__freeDrawing__result, rep_free__icObj__support__end);  
              }

              infiniteCanvas.adhesive__isAdhesiveKick = false;
            }

          }


          //clear
          this.arr_icFreeDrawing = [];
          infiniteCanvas.adhesive__support__icObj = null;
        }

        simulateMouseUpInDrawingMode(func_after) {
          const fabricIntegration = this;
          const fabricCanvas      = fabricIntegration.fabricCanvas;

          //end current freeDrawing
            //BAD IDEA
          // MouseIntegration.triggerMouseEvent(fabricCanvas.upperCanvasEl, "mouseup");
            //GOOD IDEA
          // const functionCallsQueue = new FunctionCallsQueue(false).add(() => {
          globalsSingleton.functionCallsQueue.add(() => {

            //step 1

            const fCursor__mouseUp = fabricIntegration.getFCursor(false);
            const x__mouseUp = fCursor__mouseUp.x;
            const y__mouseUp = fCursor__mouseUp.y;
            const mouseEvent__mouseUp = new MouseEvent("mouseup", {
              isTrusted: true,
              altKey : false, 
              bubbles : true,
              button : 0,
              buttons : 0,
              cancelBubble : false,
              cancelable : true,
              clientX: x__mouseUp,
              clientY: y__mouseUp,
              composed: true,
              ctrlKey: false,
              currentTarget: null,
              defaultPrevented: false,
              detail: 1,
              eventPhase: 0,
              fromElement: null,
              layerX: x__mouseUp,
              layerY: y__mouseUp,
              metaKey: false,
              movementX: 0,
              movementY: 0,
              offsetX: x__mouseUp,
              offsetY: y__mouseUp,
              pageX: x__mouseUp,
              pageY: y__mouseUp,
              relatedTarget: null,
              returnValue: true,
              screenX: x__mouseUp,
              screenY: y__mouseUp,
              shiftKey: false,
              sourceCapabilities: new InputDeviceCapabilities({firesTouchEvents: false}),
              srcElement: fabricCanvas.upperCanvasEl,
              target:     fabricCanvas.upperCanvasEl,
              timeStamp: 5848.39999999851,
              toElement:  fabricCanvas.upperCanvasEl,
              view: window,
              which: 1,
              x: x__mouseUp,
              y: y__mouseUp,
            });
            const options__mouseUp = {
              absolutePointer: fabricCanvas._absolutePointer,
              button: 1,
              e:       mouseEvent__mouseUp,
              isClick: false,
              pointer: fCursor__mouseUp,
              subTargets: [],
              target: null,
              transform: null,
            };
            fabricCanvas._onMouseUpInDrawingMode(options__mouseUp);

          }).add(() => {
            //step 2
            func_after();  
          });

          // start the sequence
          setTimeout(() => globalsSingleton.functionCallsQueue.next(), 1);
        }

        simulateMouseUp__with_freeDrawingBrush(func_after) {
          const fabricIntegration = this;
          const fabricCanvas      = fabricIntegration.fabricCanvas;

          //end current freeDrawing
            //BAD IDEA
          // MouseIntegration.triggerMouseEvent(fabricCanvas.upperCanvasEl, "mouseup");
            //GOOD IDEA
          // const functionCallsQueue = new FunctionCallsQueue(false).add(() => {
          globalsSingleton.functionCallsQueue.add(() => {

            //step 1

            const fCursor__mouseUp = fabricIntegration.getFCursor(false);
            const x__mouseUp = fCursor__mouseUp.x;
            const y__mouseUp = fCursor__mouseUp.y;
            const mouseEvent__mouseUp = new MouseEvent("mouseup", {
              isTrusted: true,
              altKey : false, 
              bubbles : true,
              button : 0,
              buttons : 0,
              cancelBubble : false,
              cancelable : true,
              clientX: x__mouseUp,
              clientY: y__mouseUp,
              composed: true,
              ctrlKey: false,
              currentTarget: null,
              defaultPrevented: false,
              detail: 1,
              eventPhase: 0,
              fromElement: null,
              layerX: x__mouseUp,
              layerY: y__mouseUp,
              metaKey: false,
              movementX: 0,
              movementY: 0,
              offsetX: x__mouseUp,
              offsetY: y__mouseUp,
              pageX: x__mouseUp,
              pageY: y__mouseUp,
              relatedTarget: null,
              returnValue: true,
              screenX: x__mouseUp,
              screenY: y__mouseUp,
              shiftKey: false,
              sourceCapabilities: new InputDeviceCapabilities({firesTouchEvents: false}),
              srcElement: fabricCanvas.upperCanvasEl,
              target:     fabricCanvas.upperCanvasEl,
              timeStamp: 5848.39999999851,
              toElement:  fabricCanvas.upperCanvasEl,
              view: window,
              which: 1,
              x: x__mouseUp,
              y: y__mouseUp,
            });
            const options__mouseUp = {
              absolutePointer: fabricCanvas._absolutePointer,
              button: 1,
              e:       mouseEvent__mouseUp,
              isClick: false,
              pointer: fCursor__mouseUp,
              subTargets: [],
              target: null,
              transform: null,
            };
            fabricCanvas.freeDrawingBrush.onMouseUp(options__mouseUp);

          }).add(() => {
            //step 2
            func_after();  
          });

          // start the sequence
          setTimeout(() => globalsSingleton.functionCallsQueue.next(), 1);
        }

        simulateMouseDown__with_freeDrawingBrush(func_after) {
          const fabricIntegration = this;
          const fabricCanvas      = fabricIntegration.fabricCanvas;

          //end current freeDrawing
            //BAD IDEA
          // MouseIntegration.triggerMouseEvent(fabricCanvas.upperCanvasEl, "mouseup");
            //GOOD IDEA
          // const functionCallsQueue = new FunctionCallsQueue(false).add(() => {
          globalsSingleton.functionCallsQueue.add(() => {
            //step 3
            //start new freeDrawing
              //BAD IDEA
            // MouseIntegration.triggerMouseEvent(fabricCanvas.upperCanvasEl, "mousedown");
              //GOOD IDEA
            const fCursor__mouseDown = fabricIntegration.getFCursor(false);
            const x__mouseDown = fCursor__mouseDown.x;
            const y__mouseDown = fCursor__mouseDown.y;
            const mouseEvent__mouseDown = new MouseEvent("mousedown", {
              isTrusted: true,
              altKey : false, 
              bubbles : true,
              button : 0,
              buttons : 1,
              cancelBubble : false,
              cancelable : true,
              clientX: x__mouseDown,
              clientY: y__mouseDown,
              composed: true,
              ctrlKey: false,
              currentTarget: null,
              defaultPrevented: false,
              detail: 1,
              eventPhase: 0,
              fromElement: null,
              layerX: x__mouseDown,
              layerY: y__mouseDown,
              metaKey: false,
              movementX: 0,
              movementY: 0,
              offsetX: x__mouseDown,
              offsetY: y__mouseDown,
              pageX: x__mouseDown,
              pageY: y__mouseDown,
              relatedTarget: null,
              returnValue: true,
              screenX: x__mouseDown,
              screenY: y__mouseDown,
              shiftKey: false,
              sourceCapabilities: new InputDeviceCapabilities({firesTouchEvents: false}),
              srcElement: fabricCanvas.upperCanvasEl,
              target:     fabricCanvas.upperCanvasEl,
              timeStamp: 5848.39999999851,
              toElement:  fabricCanvas.upperCanvasEl,
              view: window,
              which: 1,
              x: x__mouseDown,
              y: y__mouseDown,
            });
            const options__mouseDown = {
              absolutePointer: fabricCanvas._absolutePointer,
              button: 1,
              e:       mouseEvent__mouseDown,
              isClick: false,
              pointer: fabricCanvas._pointer,
              subTargets: [],
              target: null,
              transform: null,
            };
            fabricCanvas.freeDrawingBrush.onMouseDown(fCursor__mouseDown, options__mouseDown);

          }).add(() => {
            //step 2
            func_after();  
          });

          // start the sequence
          setTimeout(() => globalsSingleton.functionCallsQueue.next(), 1);
        }

        simulateMouseUpDown__with_freeDrawingBrush(func_inBetween) {
            const fabricIntegration = this;
            const fabricCanvas      = fabricIntegration.fabricCanvas;

            //end current freeDrawing
              //BAD IDEA
            // MouseIntegration.triggerMouseEvent(fabricCanvas.upperCanvasEl, "mouseup");
              //GOOD IDEA
            // const functionCallsQueue = new FunctionCallsQueue(false).add(() => {
            globalsSingleton.functionCallsQueue.add(() => {

              //step 1

              const fCursor__mouseUp = fabricIntegration.getFCursor(false);
              const x__mouseUp = fCursor__mouseUp.x;
              const y__mouseUp = fCursor__mouseUp.y;
              const mouseEvent__mouseUp = new MouseEvent("mouseup", {
                isTrusted: true,
                altKey : false, 
                bubbles : true,
                button : 0,
                buttons : 0,
                cancelBubble : false,
                cancelable : true,
                clientX: x__mouseUp,
                clientY: y__mouseUp,
                composed: true,
                ctrlKey: false,
                currentTarget: null,
                defaultPrevented: false,
                detail: 1,
                eventPhase: 0,
                fromElement: null,
                layerX: x__mouseUp,
                layerY: y__mouseUp,
                metaKey: false,
                movementX: 0,
                movementY: 0,
                offsetX: x__mouseUp,
                offsetY: y__mouseUp,
                pageX: x__mouseUp,
                pageY: y__mouseUp,
                relatedTarget: null,
                returnValue: true,
                screenX: x__mouseUp,
                screenY: y__mouseUp,
                shiftKey: false,
                sourceCapabilities: new InputDeviceCapabilities({firesTouchEvents: false}),
                srcElement: fabricCanvas.upperCanvasEl,
                target:     fabricCanvas.upperCanvasEl,
                timeStamp: 5848.39999999851,
                toElement:  fabricCanvas.upperCanvasEl,
                view: window,
                which: 1,
                x: x__mouseUp,
                y: y__mouseUp,
              });
              const options__mouseUp = {
                absolutePointer: fabricCanvas._absolutePointer,
                button: 1,
                e:       mouseEvent__mouseUp,
                isClick: false,
                pointer: fCursor__mouseUp,
                subTargets: [],
                target: null,
                transform: null,
              };
              fabricCanvas.freeDrawingBrush.onMouseUp(options__mouseUp);

            }).add(() => {
              //step 2
              func_inBetween();
              
            }).add(() => {
              //step 3
              //start new freeDrawing
                //BAD IDEA
              // MouseIntegration.triggerMouseEvent(fabricCanvas.upperCanvasEl, "mousedown");
                //GOOD IDEA
              const fCursor__mouseDown = fabricIntegration.getFCursor(false);
              const x__mouseDown = fCursor__mouseDown.x;
              const y__mouseDown = fCursor__mouseDown.y;
              const mouseEvent__mouseDown = new MouseEvent("mousedown", {
                isTrusted: true,
                altKey : false, 
                bubbles : true,
                button : 0,
                buttons : 1,
                cancelBubble : false,
                cancelable : true,
                clientX: x__mouseDown,
                clientY: y__mouseDown,
                composed: true,
                ctrlKey: false,
                currentTarget: null,
                defaultPrevented: false,
                detail: 1,
                eventPhase: 0,
                fromElement: null,
                layerX: x__mouseDown,
                layerY: y__mouseDown,
                metaKey: false,
                movementX: 0,
                movementY: 0,
                offsetX: x__mouseDown,
                offsetY: y__mouseDown,
                pageX: x__mouseDown,
                pageY: y__mouseDown,
                relatedTarget: null,
                returnValue: true,
                screenX: x__mouseDown,
                screenY: y__mouseDown,
                shiftKey: false,
                sourceCapabilities: new InputDeviceCapabilities({firesTouchEvents: false}),
                srcElement: fabricCanvas.upperCanvasEl,
                target:     fabricCanvas.upperCanvasEl,
                timeStamp: 5848.39999999851,
                toElement:  fabricCanvas.upperCanvasEl,
                view: window,
                which: 1,
                x: x__mouseDown,
                y: y__mouseDown,
              });
              const options__mouseDown = {
                absolutePointer: fabricCanvas._absolutePointer,
                button: 1,
                e:       mouseEvent__mouseDown,
                isClick: false,
                pointer: fabricCanvas._pointer,
                subTargets: [],
                target: null,
                transform: null,
              };
              fabricCanvas.freeDrawingBrush.onMouseDown(fCursor__mouseDown, options__mouseDown);
            });

            // start the sequence
            setTimeout(() => globalsSingleton.functionCallsQueue.next(), 1);
        }


        simulateMouseUp__whenHolding(fObj__held, func_after) {
          const fabricIntegration = this;
          const fabricCanvas      = fabricIntegration.fabricCanvas;

          const target = fObj__held;

          globalsSingleton.functionCallsQueue.add(() => {

            //step 1

            const fCursor__mouseUp = fabricIntegration.getFCursor(false);
            const x__mouseUp = fCursor__mouseUp.x;
            const y__mouseUp = fCursor__mouseUp.y;
            const mouseEvent__mouseUp = new MouseEvent("mouseup", {
              isTrusted: true,
              altKey : false, 
              bubbles : true,
              button : 0,
              buttons : 0,
              cancelBubble : false,
              cancelable : true,
              clientX: x__mouseUp,
              clientY: y__mouseUp,
              composed: true,
              ctrlKey: false,
              currentTarget: null,
              defaultPrevented: false,
              detail: 1,
              eventPhase: 0,
              fromElement: null,
              layerX: x__mouseUp,
              layerY: y__mouseUp,
              metaKey: false,
              movementX: 0,
              movementY: 0,
              offsetX: x__mouseUp,
              offsetY: y__mouseUp,
              pageX: x__mouseUp,
              pageY: y__mouseUp,
              relatedTarget: null,
              returnValue: true,
              screenX: x__mouseUp,
              screenY: y__mouseUp,
              shiftKey: false,
              sourceCapabilities: new InputDeviceCapabilities({firesTouchEvents: false}),
              srcElement: fabricCanvas.upperCanvasEl,
              target:     fabricCanvas.upperCanvasEl,
              timeStamp: 5848.39999999851,
              toElement:  fabricCanvas.upperCanvasEl,
              view: window,
              which: 1,
              x: x__mouseUp,
              y: y__mouseUp,
            });
            const options__mouseUp = {
              absolutePointer: fabricCanvas._absolutePointer,
              button: 1,
              e:       mouseEvent__mouseUp,
              isClick: false,
              pointer: fCursor__mouseUp,
              subTargets: [],
              target: target,
              transform: null,
            };

            // fabricCanvas._onMouseUp(options__mouseUp);
            const fabricCanvas_mouseUp__partial = (function(e, target)
            {
              const isClick      = false;
              const shouldRender = false;

              //CODE from fabric.js
              //------------
              this._setCursorFromEvent(e, target);
              this._handleEvent(e, 'up', LEFT_CLICK, isClick);
              this._groupSelector = null;
              this._currentTransform = null;
              // reset the target information about which corner is selected
              target && (target.__corner = 0);
              if (shouldRender) {
                this.requestRenderAll();
              }
              else if (!isClick) {
                this.renderTop();
              }
              //------------

            }).bind(fabricCanvas);

            fabricCanvas_mouseUp__partial(options__mouseUp, target);

          }).add(() => {
            //step 2
            func_after();  
          });

          // start the sequence
          setTimeout(() => globalsSingleton.functionCallsQueue.next(), 1);
        }





        simulateMouseUp(func_inBetween) {
            const fabricIntegration = this;
            const fabricCanvas      = fabricIntegration.fabricCanvas;

            globalsSingleton.functionCallsQueue.add(() => {

              const fCursor__mouseUp = fabricIntegration.getFCursor(false);
              const x__mouseUp = fCursor__mouseUp.x;
              const y__mouseUp = fCursor__mouseUp.y;
              const mouseEvent__mouseUp = new MouseEvent("mouseup", {
                isTrusted: true,
                altKey : false, 
                bubbles : true,
                button : 0,
                buttons : 0,
                cancelBubble : false,
                cancelable : true,
                clientX: x__mouseUp,
                clientY: y__mouseUp,
                composed: true,
                ctrlKey: false,
                currentTarget: null,
                defaultPrevented: false,
                detail: 1,
                eventPhase: 0,
                fromElement: null,
                layerX: x__mouseUp,
                layerY: y__mouseUp,
                metaKey: false,
                movementX: 0,
                movementY: 0,
                offsetX: x__mouseUp,
                offsetY: y__mouseUp,
                pageX: x__mouseUp,
                pageY: y__mouseUp,
                relatedTarget: null,
                returnValue: true,
                screenX: x__mouseUp,
                screenY: y__mouseUp,
                shiftKey: false,
                sourceCapabilities: new InputDeviceCapabilities({firesTouchEvents: false}),
                srcElement: fabricCanvas.upperCanvasEl,
                target:     fabricCanvas.upperCanvasEl,
                timeStamp: 5848.39999999851,
                toElement:  fabricCanvas.upperCanvasEl,
                view: window,
                which: 1,
                x: x__mouseUp,
                y: y__mouseUp,
              });
              const options__mouseUp = {
                absolutePointer: fabricCanvas._absolutePointer,
                button: 1,
                e:       mouseEvent__mouseUp,
                isClick: false,
                pointer: fCursor__mouseUp,
                subTargets: [],
                target: null,
                transform: null,
              };
              fabricCanvas._onMouseUp(options__mouseUp);

            });

            // start the sequence
            setTimeout(() => globalsSingleton.functionCallsQueue.next(), 1);
        }


        simulateMouseDownUp(func_inBetween) {
            const fabricIntegration = this;
            const fabricCanvas      = fabricIntegration.fabricCanvas;

            globalsSingleton.functionCallsQueue.add(() => {

              //step 1
              const fCursor__mouseDown = fabricIntegration.getFCursor(false);
              const x__mouseDown = fCursor__mouseDown.x;
              const y__mouseDown = fCursor__mouseDown.y;
              const mouseEvent__mouseDown = new MouseEvent("mousedown", {
                isTrusted: true,
                altKey : false, 
                bubbles : true,
                button : 0,
                buttons : 1,
                cancelBubble : false,
                cancelable : true,
                clientX: x__mouseDown,
                clientY: y__mouseDown,
                composed: true,
                ctrlKey: false,
                currentTarget: null,
                defaultPrevented: false,
                detail: 1,
                eventPhase: 0,
                fromElement: null,
                layerX: x__mouseDown,
                layerY: y__mouseDown,
                metaKey: false,
                movementX: 0,
                movementY: 0,
                offsetX: x__mouseDown,
                offsetY: y__mouseDown,
                pageX: x__mouseDown,
                pageY: y__mouseDown,
                relatedTarget: null,
                returnValue: true,
                screenX: x__mouseDown,
                screenY: y__mouseDown,
                shiftKey: false,
                sourceCapabilities: new InputDeviceCapabilities({firesTouchEvents: false}),
                srcElement: fabricCanvas.upperCanvasEl,
                target:     fabricCanvas.upperCanvasEl,
                timeStamp: 5848.39999999851,
                toElement:  fabricCanvas.upperCanvasEl,
                view: window,
                which: 1,
                x: x__mouseDown,
                y: y__mouseDown,
              });
              const options__mouseDown = {
                absolutePointer: fabricCanvas._absolutePointer,
                button: 1,
                e:       mouseEvent__mouseDown,
                isClick: false,
                pointer: fabricCanvas._pointer,
                subTargets: [],
                target: null,
                transform: null,
              };
              fabricCanvas._onMouseDown(options__mouseDown);

            }).add(() => {
              //step 2
              func_inBetween();
              
            }).add(() => {
              //step 3
              const fCursor__mouseUp = fabricIntegration.getFCursor(false);
              const x__mouseUp = fCursor__mouseUp.x;
              const y__mouseUp = fCursor__mouseUp.y;
              const mouseEvent__mouseUp = new MouseEvent("mouseup", {
                isTrusted: true,
                altKey : false, 
                bubbles : true,
                button : 0,
                buttons : 0,
                cancelBubble : false,
                cancelable : true,
                clientX: x__mouseUp,
                clientY: y__mouseUp,
                composed: true,
                ctrlKey: false,
                currentTarget: null,
                defaultPrevented: false,
                detail: 1,
                eventPhase: 0,
                fromElement: null,
                layerX: x__mouseUp,
                layerY: y__mouseUp,
                metaKey: false,
                movementX: 0,
                movementY: 0,
                offsetX: x__mouseUp,
                offsetY: y__mouseUp,
                pageX: x__mouseUp,
                pageY: y__mouseUp,
                relatedTarget: null,
                returnValue: true,
                screenX: x__mouseUp,
                screenY: y__mouseUp,
                shiftKey: false,
                sourceCapabilities: new InputDeviceCapabilities({firesTouchEvents: false}),
                srcElement: fabricCanvas.upperCanvasEl,
                target:     fabricCanvas.upperCanvasEl,
                timeStamp: 5848.39999999851,
                toElement:  fabricCanvas.upperCanvasEl,
                view: window,
                which: 1,
                x: x__mouseUp,
                y: y__mouseUp,
              });
              const options__mouseUp = {
                absolutePointer: fabricCanvas._absolutePointer,
                button: 1,
                e:       mouseEvent__mouseUp,
                isClick: false,
                pointer: fCursor__mouseUp,
                subTargets: [],
                target: null,
                transform: null,
              };
              fabricCanvas._onMouseUp(options__mouseUp);

            });

            // start the sequence
            setTimeout(() => globalsSingleton.functionCallsQueue.next(), 1);
        }


        setBrush__hotSwap(brush__new) {
          const fabricIntegration = this;
          fabricIntegration.simulateMouseUpDown__with_freeDrawingBrush(() => {
            fabricIntegration.fabricCanvas.freeDrawingBrush = brush__new;
          });
        }



        simulateMouseUpDown(func_inBetween) {
            const fabricIntegration = this;
            const fabricCanvas      = fabricIntegration.fabricCanvas;

            globalsSingleton.functionCallsQueue.add(() => {

              //step 1
              const fCursor__mouseUp = fabricIntegration.getFCursor(false);
              const x__mouseUp = fCursor__mouseUp.x;
              const y__mouseUp = fCursor__mouseUp.y;
              const mouseEvent__mouseUp = new MouseEvent("mouseup", {
                isTrusted: true,
                altKey : false, 
                bubbles : true,
                button : 0,
                buttons : 0,
                cancelBubble : false,
                cancelable : true,
                clientX: x__mouseUp,
                clientY: y__mouseUp,
                composed: true,
                ctrlKey: false,
                currentTarget: null,
                defaultPrevented: false,
                detail: 1,
                eventPhase: 0,
                fromElement: null,
                layerX: x__mouseUp,
                layerY: y__mouseUp,
                metaKey: false,
                movementX: 0,
                movementY: 0,
                offsetX: x__mouseUp,
                offsetY: y__mouseUp,
                pageX: x__mouseUp,
                pageY: y__mouseUp,
                relatedTarget: null,
                returnValue: true,
                screenX: x__mouseUp,
                screenY: y__mouseUp,
                shiftKey: false,
                sourceCapabilities: new InputDeviceCapabilities({firesTouchEvents: false}),
                srcElement: fabricCanvas.upperCanvasEl,
                target:     fabricCanvas.upperCanvasEl,
                timeStamp: 5848.39999999851,
                toElement:  fabricCanvas.upperCanvasEl,
                view: window,
                which: 1,
                x: x__mouseUp,
                y: y__mouseUp,
              });
              const options__mouseUp = {
                absolutePointer: fabricCanvas._absolutePointer,
                button: 1,
                e:       mouseEvent__mouseUp,
                isClick: false,
                pointer: fCursor__mouseUp,
                subTargets: [],
                target: null,
                transform: null,
              };
              fabricCanvas._onMouseUp(options__mouseUp);

            }).add(() => {
              //step 2
              func_inBetween();
              
            }).add(() => {
              //step 3
              const fCursor__mouseDown = fabricIntegration.getFCursor(false);
              const x__mouseDown = fCursor__mouseDown.x;
              const y__mouseDown = fCursor__mouseDown.y;
              const mouseEvent__mouseDown = new MouseEvent("mousedown", {
                isTrusted: true,
                altKey : false, 
                bubbles : true,
                button : 0,
                buttons : 1,
                cancelBubble : false,
                cancelable : true,
                clientX: x__mouseDown,
                clientY: y__mouseDown,
                composed: true,
                ctrlKey: false,
                currentTarget: null,
                defaultPrevented: false,
                detail: 1,
                eventPhase: 0,
                fromElement: null,
                layerX: x__mouseDown,
                layerY: y__mouseDown,
                metaKey: false,
                movementX: 0,
                movementY: 0,
                offsetX: x__mouseDown,
                offsetY: y__mouseDown,
                pageX: x__mouseDown,
                pageY: y__mouseDown,
                relatedTarget: null,
                returnValue: true,
                screenX: x__mouseDown,
                screenY: y__mouseDown,
                shiftKey: false,
                sourceCapabilities: new InputDeviceCapabilities({firesTouchEvents: false}),
                srcElement: fabricCanvas.upperCanvasEl,
                target:     fabricCanvas.upperCanvasEl,
                timeStamp: 5848.39999999851,
                toElement:  fabricCanvas.upperCanvasEl,
                view: window,
                which: 1,
                x: x__mouseDown,
                y: y__mouseDown,
              });
              const options__mouseDown = {
                absolutePointer: fabricCanvas._absolutePointer,
                button: 1,
                e:       mouseEvent__mouseDown,
                isClick: false,
                pointer: fabricCanvas._pointer,
                subTargets: [],
                target: null,
                transform: null,
              };
              fabricCanvas._onMouseDown(options__mouseDown);

            });

            // start the sequence
            setTimeout(() => globalsSingleton.functionCallsQueue.next(), 1);
        }

        simulateMouseUpDownToHoldFObj(fObj, func_inBetween) {
          const fabricIntegration = this;
          const fabricCanvas      = fabricIntegration.fabricCanvas;

          globalsSingleton.functionCallsQueue.add(() => {

            //step 1
            const fCursor__mouseUp = fabricIntegration.getFCursor(false);
            const x__mouseUp = fCursor__mouseUp.x;
            const y__mouseUp = fCursor__mouseUp.y;
            const mouseEvent__mouseUp = new MouseEvent("mouseup", {
              isTrusted: true,
              altKey : false, 
              bubbles : true,
              button : 0,
              buttons : 0,
              cancelBubble : false,
              cancelable : true,
              clientX: x__mouseUp,
              clientY: y__mouseUp,
              composed: true,
              ctrlKey: false,
              currentTarget: null,
              defaultPrevented: false,
              detail: 1,
              eventPhase: 0,
              fromElement: null,
              layerX: x__mouseUp,
              layerY: y__mouseUp,
              metaKey: false,
              movementX: 0,
              movementY: 0,
              offsetX: x__mouseUp,
              offsetY: y__mouseUp,
              pageX: x__mouseUp,
              pageY: y__mouseUp,
              relatedTarget: null,
              returnValue: true,
              screenX: x__mouseUp,
              screenY: y__mouseUp,
              shiftKey: false,
              sourceCapabilities: new InputDeviceCapabilities({firesTouchEvents: false}),
              srcElement: fabricCanvas.upperCanvasEl,
              target:     fabricCanvas.upperCanvasEl,
              timeStamp: 5848.39999999851,
              toElement:  fabricCanvas.upperCanvasEl,
              view: window,
              which: 1,
              x: x__mouseUp,
              y: y__mouseUp,
            });
            const options__mouseUp = {
              absolutePointer: fabricCanvas._absolutePointer,
              button: 1,
              e:       mouseEvent__mouseUp,
              isClick: false,
              pointer: fCursor__mouseUp,
              subTargets: [],
              target: null,
              transform: null,
            };
            fabricCanvas._onMouseUp(options__mouseUp);

          }).add(() => {
            //step 2
            func_inBetween();
            
          }).add(() => {
            //step 3
            const fCursor__mouseDown = fabricIntegration.getFCursor(false);
            const x__mouseDown = fCursor__mouseDown.x;
            const y__mouseDown = fCursor__mouseDown.y;
            const mouseEvent__mouseDown = new MouseEvent("mousedown", {
              isTrusted: true,
              altKey : false, 
              bubbles : true,
              button : 0,
              buttons : 1,
              cancelBubble : false,
              cancelable : true,
              clientX: x__mouseDown,
              clientY: y__mouseDown,
              composed: true,
              ctrlKey: false,
              currentTarget: null,
              defaultPrevented: false,
              detail: 1,
              eventPhase: 0,
              fromElement: null,
              layerX: x__mouseDown,
              layerY: y__mouseDown,
              metaKey: false,
              movementX: 0,
              movementY: 0,
              offsetX: x__mouseDown,
              offsetY: y__mouseDown,
              pageX: x__mouseDown,
              pageY: y__mouseDown,
              relatedTarget: null,
              returnValue: true,
              screenX: x__mouseDown,
              screenY: y__mouseDown,
              shiftKey: false,
              sourceCapabilities: new InputDeviceCapabilities({firesTouchEvents: false}),
              srcElement: fabricCanvas.upperCanvasEl,
              target:     fObj,
              timeStamp: 5848.39999999851,
              toElement:  fabricCanvas.upperCanvasEl,
              view: window,
              which: 1,
              x: x__mouseDown,
              y: y__mouseDown,
            });
            const options__mouseDown = {
              absolutePointer: fabricCanvas._absolutePointer,
              button: 1,
              e:       mouseEvent__mouseDown,
              isClick: false,
              pointer: fabricCanvas._pointer,
              subTargets: [fObj],
              target: fObj,
              transform: null,
            };
            fabricCanvas._onMouseDown(options__mouseDown);

          });

          // start the sequence
          setTimeout(() => globalsSingleton.functionCallsQueue.next(), 1);
        }

        putFObjUnderMouseCursor(fObj) {
          
        }



        //pathmade

        enterPathmadeOperatorPathDrawing__grains(type__pathmadeOp, cfg) {
          const fabricIntegration = this;
          const fabricCanvas   = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          //set creationMode
          fabricIntegration.buildMode__operatorPathDrawing = "grains";

          //start drawing mode
          fabricIntegration.enterPathmadeOperatorPathDrawing(type__pathmadeOp, cfg);
        }

        leavePathmadeOperatorPathDrawing__grains() {

          const fabricIntegration = this;
          const fabricCanvas   = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          //end drawing mode
          fabricIntegration.leavePathmadeOperatorPathDrawing();

          //unset creationMode
          delete fabricIntegration.buildMode__operatorPathDrawing;
        }



        enterPathmadeOperatorPathDrawing__composite(type__pathmadeOp) {
          const fabricIntegration = this;
          const fabricCanvas   = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          //start multiPathmadeOperator creation
          infiniteCanvas.createIcMultiPathmadeOperator_start(type__pathmadeOp);

          //set creationMode
          fabricIntegration.buildMode__operatorPathDrawing = "composite";

          //start drawing mode
          fabricIntegration.enterPathmadeOperatorPathDrawing(type__pathmadeOp);
        }

        leavePathmadeOperatorPathDrawing__composite() {

          const fabricIntegration = this;
          const fabricCanvas = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          //end drawing mode
          fabricIntegration.leavePathmadeOperatorPathDrawing();

          //unset creationMode
          delete fabricIntegration.buildMode__operatorPathDrawing;

          //end multiPathmadeOperator creation
          const icMultiPathmadeOperator = infiniteCanvas.createIcMultiPathmadeOperator_end();
          infiniteCanvas.addIcObject(icMultiPathmadeOperator);

        }

        // brushConfig__operatorPathDrawing() {
        //   var outBrushConfig = {};

        //   const rgbaColorString = "rgba(233,212,96,0.5)";
        //   const fColor = new fabric.Color(rgbaColorString);

        //   outBrushConfig = {
        //     width:   67,
        //     color:   fColor.toRgb(),
        //     opacity: fColor.getAlpha(),
        //   };          

        //   return outBrushConfig;
        // }

        enterPathmadeOperatorPathDrawing(type__pathmadeOp, cfg) {
          const fabricIntegration = this;
          const fabricCanvas   = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          // fabricIntegration.saveBrush("main");

          // const brushConfig = fabricIntegration.brushConfig__operatorPathDrawing();
          // fabricIntegration.configureFreeDrawingBrush(brushConfig);
          fabricIntegration.swapToBrush("pathmade");

          const brushZIndex_new = infiniteCanvas.getFreshIcZIndex__max();
          fabricIntegration.configureFreeDrawingBrush({zIndex__ic: brushZIndex_new});



          fabricCanvas.isDrawingMode = true;


          //replay related
          function startRecording(e) {
            // logger.log("startRecording", e);
            fabricCanvas.off('mouse:down:before', startRecording);


            fabricIntegration.dict_current_operatorPathDrawing_objects = {
              arr_fObj__dummy: [],
              arr_fObj__path:  [],
            };
            fabricIntegration.dict_icPathmade = {};

            function operatorPathDrawing_objectAdded(e) {
              logger.log("operatorPathDrawing_objectAdded", e);

              const fObj = e.target;

              if(fObj.__brush == null) {
                //fObj dummy was added
                // fabricIntegration.dict_current_operatorPathDrawing_objects.arr_fObj__dummy.push(fObj);
              } else {

                // const brush__atDrawingStart = fabricIntegration.brushConfig__current;
                const brush__atDrawingEnd   = fObj.__brush;
    
                // const fColor   = new fabric.Color(brush__atDrawingStart.color);
                const fColor   = new fabric.Color(brush__atDrawingEnd.color); //SHU: TODO: brush__atDrawingStart
                const rgbColor = fColor.toRgb();
                const opacity  = fColor.getAlpha();
                
                fObj.set({
                  strokeWidth:  brush__atDrawingEnd.width,
    
                  stroke:  rgbColor,
                  opacity: opacity,
    
                  isCosmetic: cfg.isCosmetic,   //<--\
                                                //    |--- //SHU: these too are quite incompatible...
                  isAdhesive: cfg.isAdhesive,   //<--/
                });
    
                logger.log("logFD", "fObj.zIndex", fObj.zIndex);
                logger.log("logFD", "fObj", fObj);
                fObj.moveTo(fObj.zIndex);
    
                fObj.zIndex__ic = brush__atDrawingEnd.zIndex__ic;
    
                fabricIntegration.dict_current_operatorPathDrawing_objects.arr_fObj__path.push(fObj);
              }
              
            }

            fabricIntegration.operatorPathDrawing_objectAdded = operatorPathDrawing_objectAdded;
            fabricCanvas.on('object:added', fabricIntegration.operatorPathDrawing_objectAdded);


            function onMouseMove__dummy(e) {
              // logger.log("onMouseMove__dummy", e);
              const rep_free__dummy = fabricIntegration.operatorPathDrawing_dummy;

              const true_cursor = infiniteCanvas.getTrueCursor();
              rep_free__dummy.position = {
                x: true_cursor.x,
                y: true_cursor.y,
              };

            }
            fabricIntegration.operatorPathDrawing_onMouseMove__dummy = onMouseMove__dummy;




            //create dummy
            const true_cursor = infiniteCanvas.getTrueCursor();
            const trueRect = {
              x: true_cursor.x,
              y: true_cursor.y,
              width: 100,
              height: 100,
            };
            const icDummy = infiniteCanvas.createIcDummy(trueRect);
            icDummy.originX = "center";
            icDummy.originY = "center";

            infiniteCanvas.onceOnAddRepresentedForIcObject(icDummy, (icDummy) => {
              const rep_free__dummy = infiniteCanvas.getRepresented(icDummy.id).r_free();
              fabricIntegration.operatorPathDrawing_dummy = rep_free__dummy;
            });
            infiniteCanvas.addIcObject(icDummy);

            //grab dummy
            // setTimeout(() => {
            //   const fObj__dummy = fabricIntegration.getFObj__dummy();
            //   logger.log("fObj__dummy", fObj__dummy);
            //   fabricCanvas._setupCurrentTransform(e, fObj__dummy);  //magic happens here
            //   fabricCanvas.setActiveObject(fObj__dummy);
            // }, 300);

            //make dummy follow cursor
            fabricCanvas.on('mouse:move', fabricIntegration.operatorPathDrawing_onMouseMove__dummy);


            //start pathmadeOperator creation
            infiniteCanvas.createIcPathmadeOperator_start(type__pathmadeOp);
          }

          function stopRecording(e) {
            // logger.log("startRecording", e);
            fabricCanvas.off('mouse:up', stopRecording);

            //store dummy size
            const icDummy = fabricIntegration.operatorPathDrawing_dummy;
            const size__start = Object.assign({}, icDummy.size);

            //revoke dummy
            fabricCanvas.off('mouse:move', fabricIntegration.operatorPathDrawing_onMouseMove__dummy);
            
            //kill dummy
            // if (fabricIntegration.operatorPathDrawing_dummy != null) {
              fabricIntegration.operatorPathDrawing_dummy.im_dying_now = true;
            // }


            fabricIntegration.fabricCanvas.off('object:added', fabricIntegration.freeDrawing_objectAdded);

            //get newly created fabric objects
            const dict_operatorPathDrawing_objects_created = Object.assign({}, fabricIntegration.dict_current_operatorPathDrawing_objects);
            fabricIntegration.dict_current_operatorPathDrawing_objects = {};

            fabricIntegration.manageCreatedPathmadeFabricObjects(dict_operatorPathDrawing_objects_created);

            //stop pathmadeOperator creation
            infiniteCanvas.createIcPathmadeOperator_end_p(size__start)
              .then(icPathmadeOperator => {

                switch (fabricIntegration.buildMode__operatorPathDrawing) {
                  case "grains":
                    {
                      infiniteCanvas.addIcObject(icPathmadeOperator);
                    }
                    break;
                  case "composite":
                    {
                      infiniteCanvas.rx_icPathmadeOperator_subject.next(icPathmadeOperator);
                    }
                    break;
                  default:
                    throw new Error("fabricIntegration.buildMode__operatorPathDrawing, unsupported buildMode: " + fabricIntegration.buildMode__operatorPathDrawing);
                    break;
                }

              });

            //wait for next recording
            fabricCanvas.on('mouse:down:before', startRecording);
            fabricCanvas.on('mouse:up', stopRecording);
          }

          //wait for next recording
          fabricCanvas.on('mouse:down:before', startRecording);
          fabricCanvas.on('mouse:up', stopRecording);

          //store methods for uninstalling
          fabricIntegration.operatorPathDrawing_startRecording = startRecording;
          fabricIntegration.operatorPathDrawing_stopRecording  = stopRecording;
        }

        leavePathmadeOperatorPathDrawing() {
          const fabricIntegration = this;
          const fabricCanvas = fabricIntegration.fabricCanvas;

          //stop waiting for next recording
          fabricCanvas.off('mouse:down:before', fabricIntegration.operatorPathDrawing_startRecording);
          delete fabricIntegration.operatorPathDrawing_startRecording;
          fabricCanvas.off('mouse:up', fabricIntegration.operatorPathDrawing_stopRecording);
          delete fabricIntegration.operatorPathDrawing_stopRecording;

          //leave drawing mode
          fabricIntegration.fabricCanvas.isDrawingMode = false;

          //restore brush
          fabricIntegration.swapToBrush("main");
        }

        manageCreatedPathmadeFabricObjects(dict_arr_fObj) {
          logger.log("logPathmade", "manageCreatedPathmadeFabricObjects", dict_arr_fObj);

          const fabricIntegration = this;
          const infiniteCanvas    = fabricIntegration.infiniteCanvas;

          const creationManager   = infiniteCanvas.creationManagers["pathmadeOperator"];
          creationManager.dict_icObj = {};

          const arr_fObj__dummy = dict_arr_fObj.arr_fObj__dummy;
          const arr_fObj__path  = dict_arr_fObj.arr_fObj__path;

          //manage dummys
          {

            this.dict_icPathmade.arr_icObj__dummy = [];

            arr_fObj__dummy.forEach((fObj) => {

              const icObj = this.infiniteCanvas.createIcDummy_from_fObj(fObj)
              logger.log("logFD", "fObj.zIndex__ic", fObj.zIndex__ic);
              icObj.zIndex = fObj.zIndex__ic;
  
              //recycle fObj
              fObj.id_recycle = icObj.id;
  
              this.infiniteCanvas.addIcObject(icObj); 
  
              // //manage .isAdhesive
              // if(fObj.isAdhesive) {
              //   //simple
  
              //   //complex: joining adhesive
  
              // }
  
              this.dict_icPathmade.arr_icObj__dummy.push(icObj);

              // creationManager.dict_icObj.icObj_start = icObj;

            });

          }

          //manage pathFObjs: conveyor engine
          {
            if (arr_fObj__path.length != 1) {
              throw new Error("operatorPath, arr_fObj__path.length != 1");
            }
  
            //group newly created fabric objects (or not (for easy delete))
 
            arr_fObj__path.forEach((fObj__path) => {
              const path = fObj__path.path;
              creationManager.path = path;
            });
          }

          //manage pathFObjs: display
          {

            this.dict_icPathmade.arr_icObj__path = [];

            //create icObj from fObj
            arr_fObj__path.forEach((fObj__path) => {

              const icObj = this.infiniteCanvas.createIcFreeDrawing_from_freeDrawingFObj(fObj__path);
              logger.log("logFD", "fObj.zIndex__ic", fObj__path.zIndex__ic);
              icObj.zIndex = fObj__path.zIndex__ic;
  
              //recycle fObj
              fObj__path.id_recycle = icObj.id;
  
              this.infiniteCanvas.addIcObject(icObj); 
  
              // //manage .isAdhesive
              // if(fObj.isAdhesive) {
              //   //simple
  
              //   //complex: joining adhesive
  
              // }
  
              this.dict_icPathmade.arr_icObj__path.push(icObj);
            });

            creationManager.dict_icObj.icObj_path = this.dict_icPathmade.arr_icObj__path.find(e => true);

          }

          this.manageCreatedPathmadeIcObjects(this.dict_icPathmade);

        }

        manageCreatedPathmadeIcObjects(dict_icPathmade) {
          logger.log("logFD", "manageCreatedPathmadeObjects", dict_icPathmade);

          const arr_icFreeDrawing = dict_icPathmade.arr_icObj__path;

          const infiniteCanvas = this.infiniteCanvas;

          var icObj__freeDrawing__result;
          if(arr_icFreeDrawing.length > 1) {

            //create composite
            const icFreeDrawing0 = arr_icFreeDrawing.find(e => true);
            const trueRect__composite = {
              x: icFreeDrawing0.position.x,
              y: icFreeDrawing0.position.y,
              width:  10,
              height: 10,
            };
            const parts = arr_icFreeDrawing.reduce((acc, icFreeDrawing) => {
              const partName = "freeDrawing__" + icFreeDrawing.id;
              acc[partName] = icFreeDrawing;
              return acc;
            }, {});
            const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
            const icComposite     = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig); 
            icComposite.cType = "freeDrawingObj";
            // icComposite.fillColor = "green";

            //SHU: illusion
            icComposite.fill    = "transparent";
            // icComposite.opacity = 0;

            //add composite 
            infiniteCanvas.addNewIcObject(icComposite);

            icObj__freeDrawing__result = icComposite;

          } else {
            //only one icObj (arr_icFreeDrawing.length == 1) : don't create composite 
            const icFreeDrawing0       = arr_icFreeDrawing.find(e => true);
            icObj__freeDrawing__result = icFreeDrawing0; 
          }

          // if(icObj__freeDrawing__result.fObj.isAdhesive) {
          const isAdhesive = arr_icFreeDrawing.find(e => true)?.exoObject.isAdhesive;
          if(isAdhesive) {

            if((arr_icFreeDrawing.length > 0) && (infiniteCanvas.adhesive__support__icObj != null)) {
              const icObj__support__start           = infiniteCanvas.adhesive__support__icObj;
              const rep_free__icObj__support__start = infiniteCanvas.getRepresented(icObj__support__start.id).r_free(); //SHU: probably overkill

              //manage adhesion
              infiniteCanvas.manageAdhesion(icObj__freeDrawing__result, rep_free__icObj__support__start);  
            }

            if(infiniteCanvas.adhesive__isAdhesiveKick) {
              const true_cursor = infiniteCanvas.getTrueCursor();
              const icObj__support__end = infiniteCanvas.getCandidateSupportUnderPoint(true_cursor, icObj__freeDrawing__result);
              if(icObj__support__end != null) {
                const rep_free__icObj__support__end = infiniteCanvas.getRepresented(icObj__support__end.id).r_free();

                //manage adhesion
                infiniteCanvas.manageAdhesion(icObj__freeDrawing__result, rep_free__icObj__support__end);  
              }

              infiniteCanvas.adhesive__isAdhesiveKick = false;
            }

          }


          //clear
          // this.arr_icFreeDrawing = [];
          // infiniteCanvas.adhesive__support__icObj = null;
        }





        



        enterSSPathmadeOperatorDrawing__grains(type__pathmadeOp, cfg) {
          const fabricIntegration = this;
          const fabricCanvas   = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          //set creationMode
          fabricIntegration.buildMode__ssPathmadeOperatorDrawing = "grains";

          //start straightStroking mode
          fabricIntegration.enterSSPathmadeOperatorDrawing(type__pathmadeOp, cfg);
        }

        leaveSSPathmadeOperatorDrawing__grains() {

          const fabricIntegration = this;
          const fabricCanvas   = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          //end straightStroking mode
          fabricIntegration.leaveSSPathmadeOperatorDrawing();

          //unset creationMode
          delete fabricIntegration.buildMode__ssPathmadeOperatorDrawing;
        }


        enterSSPathmadeOperatorDrawing(type__pathmadeOp, cfg) {
          const fabricIntegration = this;

          const fabricCanvas   = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          // fabricIntegration.saveBrush("main");

          // const brushConfig = fabricIntegration.brushConfig__operatorPathStraightStroking();
          // fabricIntegration.configureFreeDrawingBrush(brushConfig);
          fabricIntegration.swapToBrush("ssPathmade");

          const brushZIndex_new = infiniteCanvas.getFreshIcZIndex__max();
          fabricIntegration.configureFreeDrawingBrush({zIndex__ic: brushZIndex_new});

          //enter drawing mode
          fabricCanvas.isDrawingMode = true;

          const size__start = {
            width:  70,
            height: 70,
          };


          function startDrawing(e) {
            // logger.log("startDrawing", e);
            fabricCanvas.off('mouse:down:before', startDrawing);

            fabricIntegration.dict_current_ssPathmadeOperatorDrawing_fObjects = {
              // arr_fObj__dummy: [],
              arr_fObj__path:  [],
            };
            fabricIntegration.dict_icSSPathmade = {};

            function ssPathmadeOperatorDrawing_objectAdded(e) {
              logger.log("logSSPathmade", "ssPathmadeOperatorDrawing_objectAdded", e);

              const fObj = e.target;

              if(fObj.path == null) {
                //fObj dummy was added
                // fabricIntegration.dict_current_ssPathmadeOperatorDrawing_fObjects.arr_fObj__dummy.push(fObj);
              } else {

                // // const brush__atDrawingStart = fabricIntegration.brushConfig__current;
                // const brush__atDrawingEnd   = fObj.__brush;
    
                // // const fColor   = new fabric.Color(brush__atDrawingStart.color);
                // const fColor   = new fabric.Color(brush__atDrawingEnd.color); //SHU: TODO: brush__atDrawingStart
                // const rgbColor = fColor.toRgb();
                // const opacity  = fColor.getAlpha();
                
                // fObj.set({
                //   strokeWidth:  brush__atDrawingEnd.width,
    
                //   stroke:  rgbColor,
                //   opacity: opacity,
    
                //   isCosmetic: cfg.isCosmetic,   //<--\
                //                                 //    |--- //SHU: these too are quite incompatible...
                //   isAdhesive: cfg.isAdhesive,   //<--/
                // });
    
                logger.log("logFD", "fObj.zIndex", fObj.zIndex);
                logger.log("logFD", "fObj", fObj);
                fObj.moveTo(fObj.zIndex);
    
                // fObj.zIndex__ic = brush__atDrawingEnd.zIndex__ic;
                //debug
                fObj.zIndex__ic = 0;  //SHU: todo
    
                fabricIntegration.dict_current_ssPathmadeOperatorDrawing_fObjects.arr_fObj__path.push(fObj);
              }
              
            }

            fabricIntegration.ssPathmadeOperatorDrawing_objectAdded = ssPathmadeOperatorDrawing_objectAdded;
            fabricCanvas.on('object:added', fabricIntegration.ssPathmadeOperatorDrawing_objectAdded);



            // //create dummy
            // const true_cursor = infiniteCanvas.getTrueCursor();
            // const trueRect = {
            //   x: true_cursor.x,
            //   y: true_cursor.y,
            //   width: 100,
            //   height: 100,
            // };
            // const icDummy = infiniteCanvas.createIcDummy(trueRect);
            // icDummy.originX = "center";
            // icDummy.originY = "center";

            // infiniteCanvas.onceOnAddRepresentedForIcObject(icDummy, (icDummy) => {
            //   const rep_free__dummy = infiniteCanvas.getRepresented(icDummy.id).r_free();
            //   fabricIntegration.ssPathmadeOperatorDrawing_dummy = rep_free__dummy;
            // });
            // infiniteCanvas.addIcObject(icDummy);


            //start pathmadeOperator creation
            infiniteCanvas.createIcSSPathmadeOperator_start(type__pathmadeOp);
          }

          function stopDrawing(e) {
            // logger.log("stopDrawing", e);
            fabricCanvas.off('mouse:up', stopDrawing);

            //store dummy size
            // const icDummy = fabricIntegration.ssPathmadeOperatorDrawing_dummy;
            // const size__start = Object.assign({}, icDummy.size);


            
            // //kill dummy
            // fabricIntegration.ssPathmadeOperatorDrawing_dummy.im_dying_now = true;


            fabricIntegration.fabricCanvas.off('object:added', fabricIntegration.ssPathmadeOperatorDrawing_objectAdded);

            //get newly created fabric objects
            logger.log("logSSPathmade", "fabricIntegration.dict_current_ssPathmadeOperatorDrawing_fObjects:", fabricIntegration.dict_current_ssPathmadeOperatorDrawing_fObjects);
            const dict_ssPathmadeOperatorDrawing_fObjects = Object.assign({}, fabricIntegration.dict_current_ssPathmadeOperatorDrawing_fObjects);
            fabricIntegration.dict_current_ssPathmadeOperatorDrawing_fObjects = {};

            fabricIntegration.manageCreatedSSPathmadeFabricObjects(dict_ssPathmadeOperatorDrawing_fObjects);

            //stop pathmadeOperator creation
            infiniteCanvas.createIcSSPathmadeOperator_end_p(size__start)
              .then(icSSPathmadeOperator => {

                switch (fabricIntegration.buildMode__ssPathmadeOperatorDrawing) {
                  case "grains":
                    {
                      infiniteCanvas.addIcObject(icSSPathmadeOperator);
                    }
                    break;
                  case "composite":
                    {
                      infiniteCanvas.rx_icSSPathmadeOperator_subject.next(icSSPathmadeOperator);
                    }
                    break;
                  default:
                    throw new Error("fabricIntegration.buildMode__ssPathmadeOperatorDrawing, unsupported buildMode: " + fabricIntegration.buildMode__ssPathmadeOperatorDrawing);
                    break;
                }

              });

            //wait for next drawing
            fabricCanvas.on('mouse:down:before', startDrawing);
            fabricCanvas.on('mouse:up',          stopDrawing);
          }

          //wait for next drawing
          fabricCanvas.on('mouse:down:before', startDrawing);
          fabricCanvas.on('mouse:up',          stopDrawing);

          //store methods for uninstalling
          fabricIntegration.ssPathmadeOperator_startDrawing = startDrawing;
          fabricIntegration.ssPathmadeOperator_stopDrawing  = stopDrawing;
        }

        leaveSSPathmadeOperatorDrawing() {
          const fabricIntegration = this;
          const fabricCanvas      = fabricIntegration.fabricCanvas;

          //off mouse listeners
          fabricCanvas.off('mouse:down:before', fabricIntegration.ssPathmadeOperator_startDrawing);
          delete fabricIntegration.ssPathmadeOperator_startDrawing;
          fabricCanvas.off('mouse:up', fabricIntegration.ssPathmadeOperator_stopDrawing);
          delete fabricIntegration.ssPathmadeOperator_stopDrawing;

          //leave drawing mode
          fabricIntegration.fabricCanvas.isDrawingMode = false;

          //restore brush
          fabricIntegration.swapToBrush("main");
        }

        manageCreatedSSPathmadeFabricObjects(dict_arr_fObj) {
          logger.log("logPathmade", "manageCreatedSSPathmadeFabricObjects", dict_arr_fObj);

          const fabricIntegration = this;
          const infiniteCanvas    = fabricIntegration.infiniteCanvas;

          const creationManager      = infiniteCanvas.creationManagers["ssPathmadeOperator"];
          creationManager.dict_icObj = {};

          // const arr_fObj__dummy = dict_arr_fObj.arr_fObj__dummy;
          const arr_fObj__path  = dict_arr_fObj.arr_fObj__path;

          // //manage dummys
          // {

          //   this.dict_icPathmade.arr_icObj__dummy = [];

          //   arr_fObj__dummy.forEach((fObj) => {

          //     const icObj = this.infiniteCanvas.createIcDummy_from_fObj(fObj)
          //     logger.log("logFD", "fObj.zIndex__ic", fObj.zIndex__ic);
          //     icObj.zIndex = fObj.zIndex__ic;
  
          //     //recycle fObj
          //     fObj.id_recycle = icObj.id;
  
          //     this.infiniteCanvas.addIcObject(icObj); 
  
          //     // //manage .isAdhesive
          //     // if(fObj.isAdhesive) {
          //     //   //simple
  
          //     //   //complex: joining adhesive
  
          //     // }
  
          //     this.dict_icSSPathmade.arr_icObj__dummy.push(icObj);

          //     // creationManager.dict_icObj.icObj_start = icObj;

          //   });

          // }

          //manage pathFObjs: conveyor engine
          {
            if (arr_fObj__path.length != 1) {
              // logger.log("logSSPathmade", "arr_fObj__path:", arr_fObj__path);
              throw new Error("operatorPath, arr_fObj__path.length != 1");
            }
  
            //group newly created fabric objects (or not (for easy delete))
 
            arr_fObj__path.forEach((fObj__path) => {
              const path = fObj__path.path;
              creationManager.path = path;
            });

            const arr_point = arr_fObj__path.reduce((acc, fObj__path) => {
              const path = fObj__path.path;

              const point__start = PathUtils.startingPointFromPath(path);
              const point__end   = PathUtils.endingPointFromPath(path);
              
              acc.push(point__start);
              acc.push(point__end);

              return acc;
            }, []);
            creationManager.arr_point = arr_point;
          }

          //manage pathFObjs: display
          {

            fabricIntegration.dict_icSSPathmade.arr_icObj__path = [];

            //create icObj from fObj
            arr_fObj__path.forEach((fObj__path) => {

              const icObj = this.infiniteCanvas.createIcFreeDrawing_from_freeDrawingFObj(fObj__path);
              logger.log("logFD", "fObj.zIndex__ic", fObj__path.zIndex__ic);
              icObj.zIndex = fObj__path.zIndex__ic;
  
              //recycle fObj
              fObj__path.id_recycle = icObj.id;
  
              this.infiniteCanvas.addIcObject(icObj); 
  
              // //manage .isAdhesive
              // if(fObj.isAdhesive) {
              //   //simple
  
              //   //complex: joining adhesive
  
              // }
  
              fabricIntegration.dict_icSSPathmade.arr_icObj__path.push(icObj);
            });

            creationManager.dict_icObj.icObj_path = fabricIntegration.dict_icSSPathmade.arr_icObj__path.find(e => true);

          }

          this.manageCreatedSSPathmadeIcObjects(fabricIntegration.dict_icSSPathmade);

        }

        manageCreatedSSPathmadeIcObjects(dict_icSSPathmade) {
          logger.log("logFD", "manageCreatedSSPathmadeIcObjects", dict_icSSPathmade);

          const arr_icFreeDrawing = dict_icSSPathmade.arr_icObj__path;

          const infiniteCanvas = this.infiniteCanvas;

          var icObj__freeDrawing__result;
          if(arr_icFreeDrawing.length > 1) {

            //create composite
            const icFreeDrawing0 = arr_icFreeDrawing.find(e => true);
            const trueRect__composite = {
              x: icFreeDrawing0.position.x,
              y: icFreeDrawing0.position.y,
              width:  10,
              height: 10,
            };
            const parts = arr_icFreeDrawing.reduce((acc, icFreeDrawing) => {
              const partName = "freeDrawing__" + icFreeDrawing.id;
              acc[partName] = icFreeDrawing;
              return acc;
            }, {});
            const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
            const icComposite     = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig); 
            icComposite.cType = "freeDrawingObj";
            // icComposite.fillColor = "green";

            //SHU: illusion
            icComposite.fill    = "transparent";
            // icComposite.opacity = 0;

            //add composite 
            infiniteCanvas.addNewIcObject(icComposite);

            icObj__freeDrawing__result = icComposite;

          } else {
            //only one icObj (arr_icFreeDrawing.length == 1) : don't create composite 
            const icFreeDrawing0       = arr_icFreeDrawing.find(e => true);
            icObj__freeDrawing__result = icFreeDrawing0; 
          }

          // if(icObj__freeDrawing__result.fObj.isAdhesive) {
          const isAdhesive = arr_icFreeDrawing.find(e => true)?.exoObject.isAdhesive;
          if(isAdhesive) {

            if((arr_icFreeDrawing.length > 0) && (infiniteCanvas.adhesive__support__icObj != null)) {
              const icObj__support__start           = infiniteCanvas.adhesive__support__icObj;
              const rep_free__icObj__support__start = infiniteCanvas.getRepresented(icObj__support__start.id).r_free(); //SHU: probably overkill

              //manage adhesion
              infiniteCanvas.manageAdhesion(icObj__freeDrawing__result, rep_free__icObj__support__start);  
            }

            if(infiniteCanvas.adhesive__isAdhesiveKick) {
              const true_cursor = infiniteCanvas.getTrueCursor();
              const icObj__support__end = infiniteCanvas.getCandidateSupportUnderPoint(true_cursor, icObj__freeDrawing__result);
              if(icObj__support__end != null) {
                const rep_free__icObj__support__end = infiniteCanvas.getRepresented(icObj__support__end.id).r_free();

                //manage adhesion
                infiniteCanvas.manageAdhesion(icObj__freeDrawing__result, rep_free__icObj__support__end);  
              }

              infiniteCanvas.adhesive__isAdhesiveKick = false;
            }

          }


          //clear
          // this.arr_icFreeDrawing = [];
          // infiniteCanvas.adhesive__support__icObj = null;
        }


        enterFreeDrawingApply(cfg) {
          const fabricIntegration = this;
          const fabricCanvas   = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          // fabricIntegration.saveBrush("main");

          // const brushConfig = fabricIntegration.brushConfig__operatorPathDrawing();
          // fabricIntegration.configureFreeDrawingBrush(brushConfig);
          fabricIntegration.swapToBrush("fdApply");

          fabricCanvas.fdApplyBrush.config.func__apply = cfg.func__apply;

          fabricCanvas.isDrawingMode = true;
        }

        leaveFreeDrawingApply() {
          const fabricIntegration = this;
          const fabricCanvas   = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          fabricCanvas.isDrawingMode = false;
        }



        enterSlicing() {
          const fabricIntegration = this;

          const brush = this.fabricCanvas.freeDrawingBrush;

          brush.width = 20;

          // const rgbColor = this.inputProperties.getActiveColor();
          // const opacity  = this.inputProperties.getActiveOpacity();
          const rgbaColorString = this.inputProperties.getActiveRgbaColorString();

          const fColor = new fabric.Color(rgbaColorString);
          logger.log("fColor", fColor);
          const rgbColor = fColor.toRgb();
          const opacity = fColor.getAlpha();

          // brush.color   = this.inputProperties.getActiveColor();
          brush.color = rgbaColorString;

          this.fabricCanvas.isDrawingMode = true;

          this.current_freeDrawing_objects = [];
          function freeDrawing_objectAdded(e) {
            console.log("freeDrawing_objectAdded", e);

            const fObj = e.target;
            fObj.set({
              stroke: rgbColor,
              opacity: opacity,
            });

            fabricIntegration.current_freeDrawing_objects.push(e.target);
            // console.log("fabricIntegration.current_freeDrawing_objects", fabricIntegration.current_freeDrawing_objects);
          }

          this.freeDrawing_objectAdded = freeDrawing_objectAdded;
          this.fabricCanvas.on('object:added', this.freeDrawing_objectAdded);

        }

        leaveSlicing() {
          this.fabricCanvas.isDrawingMode = false;
          this.fabricCanvas.off('object:added', this.freeDrawing_objectAdded);

          //get newly created fabric objects
          // var last = canvas_objects[canvas_objects.length -1]; //Get last object
          const freeDrawing_objects_created = [...this.current_freeDrawing_objects];
          this.current_freeDrawing_objects = [];

          this.manageSlicing(freeDrawing_objects_created);

        }

        manageSlicing(arr_fObj) {
          console.log("manageSlicing", arr_fObj);

          if (arr_fObj.length != 1) {
            throw new Error("slicing requires one stroke only");
          }

          //get fObj under stroke

          //top part:    exclude sawcut
          //bottom part: include sawcut


          //create output objects



          //remove strokes
          arr_fObj.forEach((fObj) => {
            this.fabricCanvas.remove(fObj);
          });

        }

        getPart(fObj__src, fObj__sliceStroke, isTopLeft = true) {
          var outfObj;

          return outFObj;
        }


        enterInnerPainting() {
          const fabricIntegration = this;

          const brush = this.fabricCanvas.freeDrawingBrush;

          brush.width = 20;

          // const rgbColor = this.inputProperties.getActiveColor();
          // const opacity  = this.inputProperties.getActiveOpacity();
          const rgbaColorString = this.inputProperties.getActiveRgbaColorString();

          const fColor = new fabric.Color(rgbaColorString);
          logger.log("fColor", fColor);
          const rgbColor = fColor.toRgb();
          const opacity = fColor.getAlpha();

          // brush.color   = this.inputProperties.getActiveColor();
          brush.color = rgbaColorString;

          this.fabricCanvas.isDrawingMode = true;

          this.current_freeDrawing_objects = [];
          function freeDrawing_objectAdded(e) {
            console.log("freeDrawing_objectAdded", e);

            const fObj = e.target;
            fObj.set({
              stroke: rgbColor,
              opacity: opacity,
            });

            fabricIntegration.current_freeDrawing_objects.push(e.target);
            // console.log("fabricIntegration.current_freeDrawing_objects", fabricIntegration.current_freeDrawing_objects);
          }

          this.freeDrawing_objectAdded = freeDrawing_objectAdded;
          this.fabricCanvas.on('object:added', this.freeDrawing_objectAdded);

        }

        leaveInnerPainting() {
          this.fabricCanvas.isDrawingMode = false;
          this.fabricCanvas.off('object:added', this.freeDrawing_objectAdded);

          //get newly created fabric objects
          // var last = canvas_objects[canvas_objects.length -1]; //Get last object
          const freeDrawing_objects_created = [...this.current_freeDrawing_objects];
          this.current_freeDrawing_objects = [];

          this.manageCreatedFreeDrawingObjects(freeDrawing_objects_created);

        }

        manageInnerPainting(arr_fObj) {
          console.log("manageInnerPainting", arr_fObj);

          //group newly created fabric objects (or not (for easy delete))

          //create icObj from fObj
          arr_fObj.forEach((fObj) => {
            const icObj = this.infiniteCanvas.createIcFreeDrawing_from_freeDrawingFObj(fObj);
            this.infiniteCanvas.addNewIcObject(icObj);

            //SHU: HERE WE COULD HAVE RECYCLED ALREADY CREATED FOBJ AND AVOID RECREATING A NEW ONE
            this.fabricCanvas.remove(fObj);
          });

        }

        getFCursor(isPixelRatioFixEnabled = true) {
          const cursor              = infiniteCanvas.cursor;
          // logger.log("logCanvas", "cursor", cursor);

          const pos__cursor__ic     = infiniteCanvas.toNoOrPoint(cursor);
          // logger.log("logCanvas", "pos__cursor__ic", pos__cursor__ic);

          const pos__cursor__screen = infiniteCanvas.toScreenPoint(pos__cursor__ic);
          // logger.log("logCanvas", "pos__cursor__screen", pos__cursor__screen);

          var factor;
          if(isPixelRatioFixEnabled) {
            factor = window.devicePixelRatio;
          } else {
            factor = 1.0;
          }

          const pos = {
            x: Math.floor(pos__cursor__screen.x * factor),
            y: Math.floor(pos__cursor__screen.y * factor),
          };

          return pos;
        }



        getFColor__under_cursor_p() {
          var out_p;

          const fabricIntegration = this;

          const fabricCanvas   = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;
          const cursor         = infiniteCanvas.cursor;

          logger.log("fabricCanvas", fabricCanvas);

          //global     //SHU: this is working
          // {
          //   const html_elt = document.body;
          //   logger.log("html_elt", html_elt);
          
          //   const canvasElt_p = html2canvas(html_elt);
          
          //   const magicValue = 0.75; //SHU: ugliness is my co-pilot
          //   const pos = {
          //     x: Math.floor(cursor.x * magicValue),
          //     y: Math.floor(cursor.y * magicValue),
          //   };
          
          //   const color_p = canvasElt_p
          //   // .then((canvasElt) => {
          //   //
          //   //   const dataURL = canvasElt.toDataURL('png');
          //   //   logger.log("dataURL", dataURL);
          //   //   FileIntegration.save_image(dataURL, "canvas_debug");
          //   //
          //   //   return canvasElt;
          //   // })
          //   .then((canvasElt) => {
          //     logger.log("canvasElt", canvasElt);
          
          //     return fabricIntegration.getFColor__atPos(canvasElt, pos);
          //   });
          
          //   out_p = color_p;
          // }

          //local 1
          {
            const canvasElt = fabricCanvas;
            // const canvasElt = fabricCanvas.lowerCanvasEl;
            // const canvasElt = fabricCanvas.upperCanvasEl;

            const pos__cursor__screen = this.getFCursor();

            const canvasElt_p = Promise.resolve(canvasElt);
            const color_p = canvasElt_p
              .then((canvasElt) => {
                logger.log("canvasElt", canvasElt);

                return fabricIntegration.getFColor__atPos(canvasElt, pos__cursor__screen);
              });

            out_p = color_p;
          }

          // //local 2
          // {
          //   //get fObj under cursor
          //
          //   //render fObj only
          //
          //   //get color
          // }

          return out_p;
        }

        getFColor__atPos(canvas, pos) {
          var outFColor;

          logger.log("pos", pos.x, pos.y);

          const ctx = canvas.getContext("2d");
          // const ctx = canvas.contextContainer;
          logger.log("ctx", ctx);

          logger.log("logCanvas", "canvas", canvas);
          logger.log("logCanvas", "ctx", ctx);


          const px = ctx.getImageData(pos.x, pos.y, 1, 1).data;
          //debug
          // const px = ctx.getImageData(180, 180, 1, 1).data;
          // const px = ctx.getImageData(252, 297, 1, 1).data;
          // const px = ctx.getImageData(260, 297, 1, 1).data;

          logger.log("px", px);

          // const dataURL = canvas.toDataURL('png');
          // const fImg = new fabric.Image(dataUrl);

          const r = px[0];
          const g = px[1];
          const b = px[2];
          var a;
          if (px.length == 4) {
            a = px[3] / 255.0;
          } else {
            a = 1;
          }

          const rgbaString = 'rgba(' + [r, g, b, a].join(",") + ')';
          logger.log("rgbaString", rgbaString);

          outFColor = new fabric.Color(rgbaString);

          return outFColor;
        }




        getFObj__under_cursor_p() {
          var out_p;

          const fabricIntegration = this;

          const fabricCanvas   = fabricIntegration.fabricCanvas;
          const infiniteCanvas = fabricIntegration.infiniteCanvas;
          const cursor         = infiniteCanvas.cursor;

          //local 1
          {
            const canvasElt = fabricCanvas;
            // const canvasElt = fabricCanvas.lowerCanvasEl;
            // const canvasElt = fabricCanvas.upperCanvasEl;

            const pos__cursor__screen = this.getFCursor();

            const canvasElt_p = Promise.resolve(canvasElt);

            const fObj_p = canvasElt_p
              .then((canvasElt) => {
                logger.log("canvasElt", canvasElt);

                return fabricIntegration.getFObj__atPos(canvasElt, pos__cursor__screen);
              });

            out_p = fObj_p;
          }

          return out_p;
        }


        getFObj__atPos(canvas, pos) {
          const options = {
            x: pos.x,
            y: pos.y,
          };
          return canvas.findTarget(options);
        }



        floodFillAroundCursor() {

          const rgbaString__activeColor = inputProperties.getActiveRgbaColorString();
          const arrRgba__activeColor = ColorUtils.arrRgbaFromRgbaString(rgbaString__activeColor);

          const fillColor = arrRgba__activeColor;
          const fillTolerance = 2;



          const fabricIntegration = this;
          const fcanvas           = fabricIntegration.fabricCanvas;

          const infiniteCanvas    = fabricIntegration.infiniteCanvas;

          // const cursor = infiniteCanvas.cursor;
          // const cursor = infiniteCanvas.getTrueCursor();
          const cursor = this.getFCursor();

          var mouseX = cursor.x, 
            mouseY  = cursor.y,
            canvas  = fcanvas.lowerCanvasEl,
            context = canvas.getContext('2d'),
            parsedColor = arrRgba__activeColor,
            imageData = context.getImageData(0, 0, canvas.width, canvas.height),
            getPointOffset = function (x, y) {
              return 4 * (y * imageData.width + x)
            },
            targetOffset = getPointOffset(mouseX, mouseY),
            target = imageData.data.slice(targetOffset, targetOffset + 4);

          if (FloodFill.withinTolerance(target, 0, parsedColor, fillTolerance)) {
            // Trying to fill something which is (essentially) the fill color
            logger.log('Ignore... same color')
            return;
          }

          // Perform flood fill
          var data = FloodFill.fill(
            imageData.data,
            getPointOffset,
            { x: mouseX, y: mouseY },
            parsedColor,
            target,
            fillTolerance,
            imageData.width ,
            imageData.height,
          );

          if (0 == data.width || 0 == data.height) {
            return;
          }

          var tmpCanvas = document.createElement('canvas'); 
          var tmpCtx    = tmpCanvas.getContext('2d');
          
          tmpCanvas.width  = canvas.width;
          tmpCanvas.height = canvas.height;
          var palette = tmpCtx.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height); // x, y, w, h
          
          palette.data.set(new Uint8ClampedArray(data.coords)); // Assuming values 0..255, RGBA
          tmpCtx.putImageData(palette, 0, 0); // Repost the data.
          var imgData = tmpCtx.getImageData(data.x, data.y, data.width, data.height); // Get cropped image

          tmpCanvas.width  = data.width;
          tmpCanvas.height = data.height;
          tmpCtx.putImageData(imgData, 0, 0);

          logger.log("logScale", "window.devicePixelRatio", window.devicePixelRatio);

          // Convert canvas back to image:
          var img = new Image();
          img.onload = function () {
            // logger.log("logFloodFill", "img", img);

            // "exoObject" way
            const fImg = new fabric.Image(img, {
              left: data.x * 1.0 / window.devicePixelRatio,
              top:  data.y * 1.0 / window.devicePixelRatio,
              selectable: true,
            });
            fcanvas.add(fImg);

            fabricIntegration.manageCreatedFloodFillObjects([fImg]);


            // //without using exoObject
            // const screenPoint__fObj = { 
            //   x: data.x * 1.0 / window.devicePixelRatio, 
            //   y: data.y * 1.0 / window.devicePixelRatio,
            // };
            // const truePoint__fObj = infiniteCanvas.toTruePoint(screenPoint__fObj);
            // const icImage  = infiniteCanvas.createIcImage(truePoint__fObj.x, truePoint__fObj.y, img);
            // icImage.zIndex = math.max(infiniteCanvas.getArrIcZIndex()) + 1; 
            // infiniteCanvas.addIcObject(icImage);
          };
          img.src = tmpCanvas.toDataURL('image/png');

        }


        floodFillAroundCursor__area_ruler() {

          const rgbaString__activeColor = inputProperties.getActiveRgbaColorString();
          const arrRgba__activeColor = ColorUtils.arrRgbaFromRgbaString(rgbaString__activeColor);

          const fillColor = arrRgba__activeColor;
          const fillTolerance = 2;



          const fabricIntegration = this;
          const fcanvas = fabricIntegration.fabricCanvas;

          const infiniteCanvas = fabricIntegration.infiniteCanvas;

          const cursor = infiniteCanvas.cursor;

          var mouseX = cursor.x, mouseY = cursor.y,
            canvas = fcanvas.lowerCanvasEl,
            context = canvas.getContext('2d'),
            parsedColor = arrRgba__activeColor,
            imageData = context.getImageData(0, 0, canvas.width, canvas.height),
            getPointOffset = function (x, y) {
              return 4 * (y * imageData.width + x)
            },
            targetOffset = getPointOffset(mouseX, mouseY),
            target = imageData.data.slice(targetOffset, targetOffset + 4);

          if (FloodFill.withinTolerance(target, 0, parsedColor, fillTolerance)) {
            // Trying to fill something which is (essentially) the fill color
            logger.log('Ignore... same color')
            return;
          }

          // Perform flood fill
          var data = FloodFill.fill(
            imageData.data,
            getPointOffset,
            { x: mouseX, y: mouseY },
            parsedColor,
            target,
            fillTolerance,
            imageData.width,
            imageData.height
          );

          if (0 == data.width || 0 == data.height) {
            return;
          }

          var tmpCanvas = document.createElement('canvas'), tmpCtx = tmpCanvas.getContext('2d');
          tmpCanvas.width = canvas.width;
          tmpCanvas.height = canvas.height;

          var palette = tmpCtx.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height); // x, y, w, h
          palette.data.set(new Uint8ClampedArray(data.coords)); // Assuming values 0..255, RGBA
          tmpCtx.putImageData(palette, 0, 0); // Repost the data.
          var imgData = tmpCtx.getImageData(data.x, data.y, data.width, data.height); // Get cropped image

          tmpCanvas.width = data.width;
          tmpCanvas.height = data.height;
          tmpCtx.putImageData(imgData, 0, 0);

          // Convert canvas back to image:
          var img = new Image();
          img.onload = function () {
            // // "exoObject" way
            // const fImg = new fabric.Image(img, {
            //   left: data.x,
            //   top:  data.y,
            //   selectable: false
            // });
            // fcanvas.add(fImg);

            // fabricIntegration.manageCreatedFloodFillObjects([fImg]);


            //without using exoObject
            const screenPoint__fObj = { x: data.x, y: data.y };
            const truePoint__fObj = infiniteCanvas.toTruePoint(screenPoint__fObj);
            const icImage = infiniteCanvas.createIcImage(truePoint__fObj.x, truePoint__fObj.y, img);
            icImage.zIndex = math.max(infiniteCanvas.getArrIcZIndex()) + 1;
            infiniteCanvas.addIcObject(icImage);


            /////////////////////
            //compute image area: area = sum(non transparent pixels) * scale_x * scale_y;
            function area__pixelwise(imgData) {
              const w = imgData.width;
              const h = imgData.height;
              const nb_comp = 4;
              const pos_alpha = 3;
              const arr_index_alpha = [...Array(w * h).keys()].map(index => index * nb_comp + pos_alpha);
              return arr_index_alpha.reduce((acc, i) => {
                const alpha_pixel = imgData.data[i];
                // logger.log("alpha_pixel[", i, "]", alpha_pixel);
                const value_pixel = (alpha_pixel != 0) ? 1 : 0;
                acc = acc + value_pixel;
                return acc;
              }, 0);
            }
            const value_area__raw = area__pixelwise(imgData);
            // logger.log("value_area__raw", value_area__raw);
            const value_area__scaled = value_area__raw * (1.0 / infiniteCanvas.scale.X) * (1.0 / infiniteCanvas.scale.Y);
            // logger.log("value_area__scaled", value_area__scaled);
            const text = "area: " + math.format(value_area__scaled);
            const icText = infiniteCanvas.createIcText(truePoint__fObj.x, truePoint__fObj.y, text);
            icText.zIndex = math.max(infiniteCanvas.getArrIcZIndex()) + 1;
            infiniteCanvas.addIcObject(icText);
            /////////////////////

          };
          img.src = tmpCanvas.toDataURL('image/png');

        }


        manageCreatedFloodFillObjects(arr_fObj) {
          console.log("manageCreatedFloodFillObjects", arr_fObj);

          //group newly created fabric objects (or not (for easy delete))

          arr_fObj.forEach((fObj) => {
            const icObj = this.infiniteCanvas.createIcFloodFill_from_floodFillFObj(fObj);

            icObj.homeScale = {
              X: this.infiniteCanvas.scale.X * window.devicePixelRatio,     //SHU: /!\ ugly fix
              Y: this.infiniteCanvas.scale.Y * window.devicePixelRatio,
            };
            icObj.zIndex = this.infiniteCanvas.getFreshIcZIndex__max();

            //recycle fObj
            fObj.id_recycle = icObj.id;

            this.infiniteCanvas.addIcObject(icObj); 
          });

        }




        captureImageInRect(rect_in) {
          const fabricCanvas = this.fabricCanvas;
          const ctx          = fabricCanvas.getContext('2d');

          const imageData__captured = ctx.getImageData(rect_in.left, rect_in.top, rect_in.width, rect_in.height);
          const img__captured       = ImageUtils.imageFromImageData(imageData__captured);
   
          return img__captured;
        }






        deleteSelection() {
          const fabricIntegration = this;

          const fObj = this.fabricCanvas.getActiveObject();

          fabricIntegration.deleteGeneralFObj(fObj);
        }

        deleteAllObjects() {
          const fabricIntegration = this;

          const arr_fObj = this.fabricCanvas.getObjects();

          arr_fObj.forEach((fObj, i) => {
            fabricIntegration.deleteAtomicFObj(fObj);
          });

        }

        deleteAtomicFObj(fObj_to_delete) {
          const fabricIntegration = this;

          const icObj = fObj_to_delete.icObj;

          if (icObj.isSupervessel) {
            //ignore
            return;
          }

          icObj.delete_p()
            .then(() => {
              fabricIntegration.removeFabricObject(fObj_to_delete);
              icObj.im_dying_now = false;
              icObj.im_dead_now = true;
            })
            .catch(err => {
              console.log("fObj.icObj.delete_p", "error", err);
            });

        }

        deleteGeneralFObj(fObj) {
          const fabricIntegration = this;

          if (fObj instanceof fabric.ActiveSelection) {

            fObj.getObjects().forEach((fObj, i) => {
              fabricIntegration.deleteAtomicFObj(fObj);
            });

            fabricIntegration.fabricCanvas.discardActiveObject();
            fabricIntegration.fabricCanvas.requestRenderAll();

          } else {
            fabricIntegration.deleteAtomicFObj(fObj);
          }

        }



        shouldIgnoreShortcutInput() {
          var outBool;

          const fObj = this.fabricCanvas.getActiveObject();
          if (fObj) {
            outBool = fObj.isEditing;
          } else {
            outBool = false;
          }

          return outBool;
        }




        initializeFabricObjectCopyCut() {
          const fabricIntegration = this;

          const legacyOnCopyFunc = document.oncopy;
          document.oncopy = function (event) {

            if (legacyOnCopyFunc) {
              legacyOnCopyFunc(event);
            }

            fabricIntegration.copySelection(event);
          };

          const legacyOnCutFunc = document.oncut;
          document.oncut = function (event) {

            if (legacyOnCutFunc) {
              legacyOnCutFunc(event);
            }

            fabricIntegration.cutSelection(event);
          };

        }

        copySelection(event) {
          const clipboardIntegration = this.clipboardIntegration;
          // this.fabricCanvas.getActiveObject().clone(function(cloned) {
          //   clipboardIntegration.manageInnerCopy("fabric.general", cloned);
          // });
          const fActiveObject = this.fabricCanvas.getActiveObject(); 
          // logger.log("logCP", "fActiveObject", fActiveObject);
          const icObj = fActiveObject.icObj;
          logger.log("logCP", "copySelection", "icObj.type:", icObj.type);

          switch(icObj.type) {
            case "activeSelection":
              {
                if(icObj.children.length == 1) {
                  const icObj_single = icObj.children.find(e => true);
                  // logger.log("logCP", "copySelection", "icObj_single:", icObj_single);
                  copy_single_or_composite(icObj_single);
                } else {
                  copy_group(icObj.children);
                }
              }
              break;
            default:
              {  
                copy_single_or_composite(icObj);
              }
              break;
          }

          function copy_group(arr_icObj) {
            //SHU TODO
            // const cloned = icObj.deepClone();
            // cloned.position.x += 10;
            // cloned.position.y += 10;

            // clipboardIntegration.manageInnerCopy("fabric.general", cloned);
          }

          function copy_single_or_composite(icObj_src) {
            // logger.log("logCP", "copy_single_or_composite", "icObj_src:", icObj_src);

            const isCompositeContentOrPart = (icObj_src.compositeId != -1);
            const isComposite     = (icObj_src.type == "composite");
            if(infiniteCanvas.isAltering) {

              copy_isAltering(icObj_src);

            } else {

              if(isCompositeContentOrPart) {
                //get root composite
                const icObj__rootComposite = infiniteCanvas.getRootCompositeForContentOrPart(icObj_src);
                copy_composite(icObj__rootComposite);
              } else if(isComposite) {
                copy_composite(icObj_src);
              } 
              else {
                copy_single(icObj_src);
              }

            }

          }

          function copy_single(icObj_single) {
            // logger.log("logCP", "copy_single", "icObj_single:", icObj_single);

            const cloned = icObj_single.deepClone();
            cloned.position.x += 10;
            cloned.position.y += 10;

            //shift id
            cloned.id = infiniteCanvas.generateIcObjectId();

            clipboardIntegration.manageInnerCopy("fabric.general", cloned);
          }

          function copy_composite(icObj__composite) {
            // logger.log("logCP", "copy_composite", "icObj__composite:", icObj__composite);

            const icObj__cloned = icObj__composite.deepClone();
            icObj__cloned.position.x += 10;
            icObj__cloned.position.y += 10;

            //shift ids
            CompositeUtils.shiftToNextAvailableId(icObj__cloned, icObj__composite, infiniteCanvas);

            clipboardIntegration.manageInnerCopy("fabric.general", icObj__cloned);
          }

          function copy_isAltering(icObj_src) {
              logger.log("logCP", "copy_isAltering", "icObj_src:", icObj_src);

              const isComposite = (icObj_src.type == "composite");

              const icObj__cloned = icObj_src.deepClone();
              icObj__cloned.position.x += 10;
              icObj__cloned.position.y += 10;

              if(isComposite) {
                //shift ids
                CompositeUtils.shiftToNextAvailableId(icObj__cloned, icObj_src, infiniteCanvas);
              } else {
                //shift id
                icObj__cloned.id = infiniteCanvas.generateIcObjectId();
              }

              //forget being composite part 
              icObj__cloned.compositeId = -1;

              clipboardIntegration.manageInnerCopy("fabric.general", icObj__cloned);
          }

        }

        cutSelection(event) {
          console.log("cutSelection", event);

          //copy
          this.copySelection(event);

          //remove object
          const icObj = this.fabricCanvas.getActiveObject().icObj;
          // const fObj  = this.fabricCanvas.getActiveObject();

          const infiniteCanvas = this.infiniteCanvas;
          infiniteCanvas.removeIcObject(icObj);
        }


        setAntiAliasEnabled(enabled) {
          console.log("setAntiAliasEnabled", enabled);
          this.fabricCanvas.imageSmoothingEnabled = enabled;
          this.fabricCanvas.requestRenderAll();
        }




        //Groups

        groupSelectedObjects() {

          //get selected objects
          const canvas = this.fabricCanvas;

          if (!canvas.getActiveObject()) {
            return;
          }
          if (canvas.getActiveObject().type !== 'activeSelection') {
            return;
          }

          const activeSelection = canvas.getActiveObject();
          console.log("activeSelection to create group", activeSelection);

          const fObj = canvas.getActiveObject().toGroup();
          console.log("fabric created group", fObj);

          // const fObj_childObjects = fObj.getObjects();
          // console.log("fObj_childObjects", fObj_childObjects);

          const icObj = infiniteCanvas.createIcGroup_from_groupFObj(fObj);
          fObj.icObj = icObj;

          //debug
          // const fRect = new fabric.Rect();
          // fRect.set({
          //   left:   fObj.left,
          //   top:    fObj.top,
          //   width:  fObj.width,
          //   height: fObj.height,
          //
          //   fill: 'red',
          // });
          // this.fabricCanvas.add(fRect);

          {
            const fRect = new fabric.Rect();

            const trueRect = infiniteCanvas.toTrueRect(fObj);
            const position = Geometry.getPointTL(trueRect);
            const size = Geometry.createSize(trueRect.width, trueRect.height);

            const homeScale = Object.assign({}, infiniteCanvas.scale);

            const type = "rect";
            const icObj = infiniteCanvas.createIcObject(type, position, size, homeScale);

            const position_screen = icObj.getScreenPositionWithoutOffset();
            // console.log("position_screen", position_screen);
            const homeSize_screen = icObj.getHomeScreenSize();
            // console.log("homeSize_screen", homeSize_screen);

            fRect.set({
              left: position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
              top: position_screen.y,

              width: homeSize_screen.width,
              height: homeSize_screen.height,

              fill: 'red',
            });

            this.fabricCanvas.add(fRect);
          }



          //test pour le moment
          // this.fabricCanvas.remove(fObj);



          icObj.children.forEach((child_icObj, i) => {
            infiniteCanvas.removeIcObject(child_icObj);
          });
          infiniteCanvas.addIcObject(icObj);


          canvas.requestRenderAll();

        }

        ungroupSelectedObject() {

          const canvas = this.fabricCanvas;

          if (!canvas.getActiveObject()) {
            return;
          }
          if (canvas.getActiveObject().type != 'group') {
            return;
          }
          canvas.getActiveObject().toActiveSelection();
          canvas.requestRenderAll();

        }


        //Composites

        composeSelectedObjects() {
          console.log("composeSelectedObjects");
          const infiniteCanvas = this.infiniteCanvas;

          //get selected objects
          const canvas = this.fabricCanvas;

          const activeObject = canvas.getActiveObject();
          if (activeObject == null) {
            return;
          }
          if (activeObject.type != 'activeSelection') {
            console.log("can only compose objects from an activeSelection");
            return;
          }

          const activeSelection = activeObject;
          console.log("activeSelection", activeSelection);

          const arr_fObj = activeSelection.getObjects();

          this.deselectAll();



          const arr_topLevelFObj = arr_fObj.filter(fObj => {
            const isTopLevelObj = !fObj.icObj.isCompositeContentOrPart();
            return isTopLevelObj;
          });

          const arr_topLevelIcObj = arr_topLevelFObj.map((fObj, i) => {
            return fObj.icObj;
          });

          const arr_topLevelIcObj_without_supervessel = arr_topLevelIcObj.filter(icObj => {
            const isSupervessel = (icObj.isSupervessel != null) && icObj.isSupervessel;
            return !isSupervessel;
          });

          infiniteCanvas.compose(arr_topLevelIcObj_without_supervessel);

          // this.deselectAll();
          // canvas.renderAll();

        }

        decomposeSelectedObject() {
          console.log("decomposeSelectedObject");
          const infiniteCanvas = this.infiniteCanvas;

          const canvas = this.fabricCanvas;

          var icObj_composite;

          const activeObject = canvas.getActiveObject();
          if (activeObject.type == 'activeSelection') {
            const activeSelection = activeObject;
            const arr_fObj = activeSelection.getObjects();
            const arr_icObj = arr_fObj.map((fObj, i) => {
              return fObj.icObj;
            });
            icObj_composite = arr_icObj.find(icObj => (icObj.type == "composite"));

          } else if (activeObject != null) {
            const fObj = activeObject;
            const icObj = fObj.icObj;

            if (icObj.isSupervessel) {   //SHU: at last...
              //ignore
              return;
            }

            if (icObj.type == "composite") {
              icObj_composite = icObj;
            }
          }

          if (icObj_composite != null) {
            this.deselectAll();
            infiniteCanvas.decompose(icObj_composite);
          }

        }



        //spread
        spreadSelectedObjects() {
          console.log("composeSelectedObjects");
          const infiniteCanvas = this.infiniteCanvas;

          //get selected objects
          const canvas = this.fabricCanvas;

          const activeObject = canvas.getActiveObject();
          if (activeObject == null) {
            return;
          }
          if (activeObject.type != 'activeSelection') {
            console.log("can only compose objects from an activeSelection");
            return;
          }

          const activeSelection = activeObject;
          console.log("activeSelection", activeSelection);

          const arr_fObj = activeSelection.getObjects();

          this.deselectAll();



          const arr_topLevelFObj = arr_fObj.filter(fObj => {
            const isTopLevelObj = !fObj.icObj.isCompositeContentOrPart();
            return isTopLevelObj;
          });

          const arr_topLevelIcObj = arr_topLevelFObj.map((fObj, i) => {
            return fObj.icObj;
          });

          const arr_topLevelIcObj_without_supervessel = arr_topLevelIcObj.filter(icObj => {
            const isSupervessel = (icObj.isSupervessel != null) && icObj.isSupervessel;
            return !isSupervessel;
          });


          // infiniteCanvas.spreadApart__centered(arr_topLevelIcObj_without_supervessel);
          // infiniteCanvas.spreadApart__recursive(arr_topLevelIcObj_without_supervessel);
          infiniteCanvas.spreadApart__2by2(arr_topLevelIcObj_without_supervessel);
        }




        getFObjForIcObj(icObj) {
          const fObj = this.fObjForIcObj_dict[icObj.id];

          if (!fObj) {
            console.log("icObj", icObj);
            console.log("this.fObjForIcObj_dict", this.fObjForIcObj_dict);
            throw new Error("fObj not found for icObj.id: " + icObj.id);
          }

          return fObj;
        }

        getFObj_with_id_recycle(id_recycle) {
          const arr_fObj = this.fabricCanvas.getObjects();
          return arr_fObj.find(fObj => {
            return (fObj.id_recycle == id_recycle)
          }); 
        }

        getFObjAtFPosition(fPosition) {
          logger.log("logFD", "getFObjAtFPosition", fPosition);
          const arr_fObj    = this.fabricCanvas.getObjects().reverse();
          
          const fObj__under = Utils.early_break_reduce(arr_fObj, (acc,fObj,i,arr) => {
            const isFobjContainingPoint   = fObj.containsPoint(fPosition);
            const isNonVoidContentAtPoint = !(this.fabricCanvas.isTargetTransparent(fObj, fPosition.x, fPosition.y));
            if(isFobjContainingPoint && isNonVoidContentAtPoint) {
              acc = fObj;
            }
            return acc;
          }, null, (acc, x, i, arr) => {
            return acc != null;
          });

          return fObj__under;
        }


        //Composites

        linkSelectedObjects() {
          console.log("linkSelectedObjects");
          const infiniteCanvas = this.infiniteCanvas;

          //get selected objects
          const canvas = this.fabricCanvas;

          const activeObject = canvas.getActiveObject();
          if (activeObject == null) {
            return;
          }
          if (activeObject.type != 'activeSelection') {
            console.log("can only compose objects from an activeSelection");
            return;
          }

          const activeSelection = activeObject;
          console.log("activeSelection", activeSelection);

          const arr_fObj = activeSelection.getObjects();

          this.deselectAll();



          const arr_topLevelFObj = arr_fObj.filter(fObj => {
            const isTopLevelObj = !fObj.icObj.isCompositeContentOrPart();
            return isTopLevelObj;
          });

          const arr_topLevelIcObj = arr_topLevelFObj.map((fObj, i) => {
            return fObj.icObj;
          });

          const arr_topLevelIcObj_without_supervessel = arr_topLevelIcObj.filter(icObj => {
            const isSupervessel = (icObj.isSupervessel != null) && icObj.isSupervessel;
            return !isSupervessel;
          });

          const icObj__1 = arr_topLevelIcObj_without_supervessel[0];
          const icObj__2 = arr_topLevelIcObj_without_supervessel[1];

          infiniteCanvas.link(icObj__1, icObj__2);
        }

        unlinkSelectedObjects() {
          console.log("unlinkSelectedObjects");
          const infiniteCanvas = this.infiniteCanvas;

          const canvas = this.fabricCanvas;

          var icObj_link;

          const activeObject = canvas.getActiveObject();
          if (activeObject.type == 'activeSelection') {
            const activeSelection = activeObject;
            const arr_fObj = activeSelection.getObjects();
            const arr_icObj = arr_fObj.map((fObj, i) => {
              return fObj.icObj;
            });
            icObj_link = arr_icObj.find(icObj => (icObj.type == "link"));

          } else if (activeObject != null) {
            const fObj = activeObject;
            const icObj = fObj.icObj;

            if (icObj.isSupervessel) {   //SHU: at last...
              //ignore
              return;
            }

            if (icObj.type == "link") {
              icObj_link = icObj;
            }
          }

          if (icObj_link != null) {
            this.deselectAll();
            infiniteCanvas.unlink(icObj_link);
          }

        }



        // syncWithIcObj(icObj) {
        //   const fObj = this.getFObjForIcObj(icObj);
        //   this.updateFObjWithIcObj(fObj, icObj);
        //
        //   this.fabricCanvas.requestRenderAll();
        //   // this.fabricCanvas.renderAll();
        // }
        //

        //
        // updateFObjWithIcObj(fObj, icObj) {
        //   logger.log("updateFObjWithIcObj", fObj, icObj);
        //
        //   function configureWithIsActive(fObj, isActive) {
        //
        //     const cfg = isActive ? fObj.icObj.activeCfg : fObj.icObj.inactiveCfg;
        //
        //     fObj.set({
        //       fill:    cfg.fill,
        //       opacity: cfg.opacity,
        //     });
        //
        //     fObj.set("dirty", true);
        //   }
        //
        //   configureWithIsActive(fObj, icObj.isActive);
        //
        //   // fObj.setCoords();
        // }


        prepareSingleUseBehavior(behaviorName) {
          const fabricIntegration = this;
          fabricIntegration.singleUseBehaviors[behaviorName] = true;
        }


      }


















      /*******************/


      class Geometry {

        static createPoint(x, y) {
          const point = {
            x: x,
            y: y,
          };
          return point;
        }

        static createSegment(point1, point2) {
          const segment = {
            point1: point1,
            point2: point2,
          };
          return segment;
        }

        static createRect(x, y, w, h) {
          const rect = {
            left: x,
            top: y,
            width: w,
            height: h,
          };
          return rect;
        }

        static createLTRect(xyRect) {
          return Geometry.createRect(xyRect.x, xyRect.y, xyRect.width, xyRect.height);
        }

        static createXYRect(ltRect) {
          const xyRect = {
            x: ltRect.left,
            y: ltRect.top,
            width: ltRect.width,
            height: ltRect.height,
          };
          return xyRect;
        }

        static createCenteredXYRect(pointCenter, w, h) {
          const xyRect = {
            x: pointCenter.x - w / 2.0,
            y: pointCenter.y - h / 2.0,
            width: w,
            height: h,
          };
          return xyRect;
        }



        static getCenterScaledRect(ltRect, scale) {
          const pointCenter = Geometry.getCenterPoint(ltRect);
          const width = ltRect.width * scale;
          const height = ltRect.height * scale;

          const xyRect = Geometry.createCenteredXYRect(pointCenter, width, height);
          return xyRect;
        }

        static getCenterScaledPolygon(arr_point, scale) {
          const rect__enveloppe = Geometry.getEnveloppeRect(arr_point);
          logger.log("rect__enveloppe", rect__enveloppe);
          const pointCenter = Geometry.getCenterPoint(Geometry.createLTRect(rect__enveloppe));
          logger.log("pointCenter", pointCenter);

          const arr_point__scaled = arr_point.map((point) => {
            const point__scaled = Geometry.getCenterScaledPoint(pointCenter, point, scale);
            return point__scaled;
          });
          logger.log("arr_point__scaled", arr_point__scaled);

          return arr_point__scaled;
        }

        static getCenterScaledPoint(pointCenter, pointSrc, scale) {
          const v = {
            X: pointSrc.x - pointCenter.x,
            Y: pointSrc.y - pointCenter.y,
          };
          const x = pointCenter.x + v.X * scale;
          const y = pointCenter.y + v.Y * scale;

          return Geometry.createPoint(x, y);
        }

        static getArrPoint__corners(xyRect) {
          const arr_offset = [
            {dx: 0, dy: 0},
            {dx: xyRect.width, dy: 0},
            {dx: xyRect.width, dy: xyRect.height},
            {dx: 0, dy: xyRect.height},
          ];
          return arr_offset.map((offset) => {
            return {
              x: xyRect.x + offset.dx,
              y: xyRect.y + offset.dy,
            }
          });
        }

        static getTranslatedPolygon(arr_point, point__src, point__dst) {
          const v = Geometry.vector_2d(point__src, point__dst);
          const arr_point__translated = arr_point.map((point) => {
            return Geometry.translatedPoint(point, v);
          });
          return arr_point__translated;
        }

        static vector_2d(p1, p2) {
          const v = {
            X: p2.x - p1.x,
            Y: p2.y - p1.y,
          };
          return v;
        }

        static vector_2d__normalized(v_in) {
          var outV;

          const d = Geometry.norm_2d(v_in);
          outV = {
            // X: v_in.X / math.sqrt(d),    //SHU: woups
            // Y: v_in.Y / math.sqrt(d),    
            X: v_in.X / d,    
            Y: v_in.Y / d,
          };
          
          return outV;
        }

        static translatedPoint(point, v) {
          const x = point.x + v.X;
          const y = point.y + v.Y;
          return Geometry.createPoint(x, y);
        }

        static translatedXYRect(xyRect, offset) {
          return {
            x: xyRect.x + offset.dx,
            y: xyRect.y + offset.dy,
            width:  xyRect.width,
            height: xyRect.height,
          };
        }


        static createLine(point0, point1) {
          const line = {
            x0: point0.x,
            y0: point0.y,

            x1: point1.x,
            y1: point1.y,
          }
          return line;
        }

        static createTriangle() {
          const pointA = Geometry.createPoint(100, 100);
          const pointB = Geometry.createPoint(0, 300);
          const pointC = Geometry.createPoint(-100, -200);

          const lineAB = Geometry.createLine(pointA, pointB);
          const lineAC = Geometry.createLine(pointA, pointC);
          const lineBC = Geometry.createLine(pointB, pointC);

          const lines = [lineAB, lineAC, lineBC];
          return lines;
        }

        static createAxes() {
          const length = 10000;

          const pointX0 = Geometry.createPoint(0, 0);
          const pointX1 = Geometry.createPoint(length, 0);
          const lineX = Geometry.createLine(pointX0, pointX1);

          const pointY0 = Geometry.createPoint(0, 0);
          const pointY1 = Geometry.createPoint(0, length);
          const lineY = Geometry.createLine(pointY0, pointY1);

          const lines = [lineX, lineY];
          return lines;
        }



        static createSize(width, height) {
          const size = {
            width: width,
            height: height,
          };
          return size;
        }








        static containedRect(containerRect, size) {
          var outRect;

          const containerSize = {
            width: containerRect.width,
            height: containerRect.height,
          };
          const containedSize_ = Geometry.containedSize(containerSize, size);


          const center = Geometry.getCenterPoint(containerRect);
          const offset = {
            dx: - containedSize_.width / 2,
            dy: - containedSize_.height / 2,
          };
          const pointTL = Geometry.createPointWithOffset(center, offset);


          outRect = createRect(pointTL.x, pointTL.y, containedSize_.width, containedSize_.height);
          return outRect;
        }

        static getPointTL(rect) {
          const pointTL = Geometry.createPoint(rect.left, rect.top);
          return pointTL;
        }

        static getPointBR(rect) {
          const pointBR = Geometry.createPoint(rect.left + rect.width, rect.top + rect.height);
          return pointBR;
        }

        static getCenterPoint(rect) {
          const pointTL = Geometry.getPointTL(rect);
          const offset = {
            dx: rect.width / 2,
            dy: rect.height / 2,
          };
          return Geometry.createPointWithOffset(pointTL, offset);
        }

        static createPointWithOffset(point, offset) {
          return Geometry.createPoint(point.x + offset.dx, point.y + offset.dy);
        }

        static containedSize(containerSize, size) {
          var outSize;

          const size_ratio__container = containerSize.width / containerSize.height;
          const size_ratio__rect = size.width / size.height;

          //console.log("size_ratio__container", size_ratio__container);
          //console.log("size_ratio__rect", size_ratio__rect);


          var scaleFactor;
          if (size_ratio__container > size_ratio__rect) {
            scaleFactor = containerSize.height / size.height;
          } else {
            scaleFactor = containerSize.width / size.width;
          }

          //console.log("scaleFactor", scaleFactor);


          outSize = {
            width: size.width * scaleFactor,
            height: size.height * scaleFactor,
          }

          return outSize;
        }

        static getRectRadius(rect) {
          const pointTL = Geometry.getPointTL(rect);
          const pointBR = Geometry.getPointBR(rect);
          const v__diagonal = Geometry.vector_2d(pointTL, pointBR);
          const norm__diagonal = Geometry.norm_2d(v__diagonal);
          const radius = norm__diagonal / 2.0;
          return radius;
        }



        static dotProduct_2d(v1, v2) {
          return v1.x * v2.x + v1.y * v2.y;
        }

        static norm_2d(v1_in) {
          logger.log("norm_2d", v1_in);
          var v1 = v1_in;
          if (v1.x == null) {    //SHU: buerk
            v1.x = v1.X;
            v1.y = v1.Y;
          }
          const v1Dotv1 = Geometry.dotProduct_2d(v1, v1);
          logger.log("v1Dotv1", v1Dotv1);
          return Math.sqrt(v1Dotv1);
        }

        static vector_3d(v1, z = 0) {
          return {
            x: v1.x,
            y: v1.y,
            z: z,
          };
        }

        static dotProduct_3d(v1, v2) {
          return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
        }

        static crossProduct_3d(v1, v2) {
          return {
            x: v1.y * v2.z - v1.z * v2.y,
            y: v1.z * v2.x - v1.x * v2.z,
            z: v1.x * v2.y - v1.y * v2.x,
          };
        }

        static boundedAngleInDegrees(angleInDegrees) {

          var angleInDegrees_bounded = angleInDegrees;

          angleInDegrees_bounded = angleInDegrees_bounded % 360;
          if (angleInDegrees_bounded < 0) {
            angleInDegrees_bounded += 360;
          }

          return angleInDegrees_bounded;
        }

        static pointWithRotation__rad(point_from, point_center, angleInRadians) {
          return Geometry.pointWithRotation(point_from, point_center, angleInRadians * 180.0 / math.PI);
        }

        static pointWithRotation(point_from, point_center, angleInDegrees) {
          console.log("pointWithRotation", point_from, point_center, angleInDegrees);

          const v = {
            x: point_from.x - point_center.x,
            y: point_from.y - point_center.y,
          };
          console.log("v.x", v.x);
          console.log("v.y", v.y);

          // const radius = Geometry.norm_2d(v);

          const angleInRadians = angleInDegrees / 180 * Math.PI;

          const dx = Math.cos(angleInRadians) * v.x - Math.sin(angleInRadians) * v.y;
          const dy = Math.sin(angleInRadians) * v.x + Math.cos(angleInRadians) * v.y;
          console.log("dx", dx);
          console.log("dy", dy);


          const point_to = {
            x: point_center.x + dx,
            y: point_center.y + dy,
          };


          return point_to;
        }

        static getPointFromRectToRect(point_from, rect_from, rect_to) {
          const point_to = {
            x: point_from.x * (rect_to.width / rect_from.width),
            y: point_from.y * (rect_to.height / rect_from.height),
          };

          return point_to;
        }





        static rectRelForRectInRectContainer(rect, rect_container) {
          var outRectRel;

          outRectRel = {
            l: (rect.x - rect_container.x)               / rect_container.width,
            t: (rect.y - rect_container.y)               / rect_container.height,
            r: (rect.x + rect.width  - rect_container.x) / rect_container.width,
            b: (rect.y + rect.height - rect_container.y) / rect_container.height,
          };

          return outRectRel;
        }

        static rectForRectRel(rectRel, rect_container) {
          var outRect;

          outRect = {
            x: rect_container.x + rectRel.l * rect_container.width,
            y: rect_container.y + rectRel.t * rect_container.height,
            width:  (rectRel.r - rectRel.l) * rect_container.width,
            height: (rectRel.b - rectRel.t) * rect_container.height,
          };

          //4 to the floor
          // outRect = {
          //   x:      math.floor(outRect.x),
          //   y:      math.floor(outRect.y),
          //   width:  math.floor(outRect.width),
          //   height: math.floor(outRect.height),
          // };

          return outRect;
        }

        static getRectC_from_rectsAB_and_rectD(rectA, rectB, rectD) {
          const rectRel__A_in_B = Geometry.rectRelForRectInRectContainer(rectA, rectB);
          logger.log("logGeometry", "rectRel__A_in_B:", rectRel__A_in_B);

          const rectC = Geometry.rectForRectRel(rectRel__A_in_B, rectD);
          logger.log("logGeometry", "rectC:", rectC);
          
          return rectC; 
        }

        
        static scaleRelForRectInRectContainer(rect, rect_container) {  //never tested
          var outScale;

          const rectRel = Geometry.rectRelForRectInRectContainer(rect, rect_container);

          outScale = {
            X: rectRel.r - rectRel.l, 
            Y: rectRel.b - rectRel.t,
          };

          return outScale;
        }




        static createLRRect(xyRect) {
          const lrRect = {
            left:   xyRect.x,
            top:    xyRect.y,
            width:  xyRect.width,
            height: xyRect.height,
          };
          return lrRect;
        }

        static createLRTBRect(lrRect) {
          const lrtbRect = {
            left:   lrRect.left,
            right:  lrRect.left + lrRect.width,
            top:    lrRect.top,
            bottom: lrRect.top + lrRect.height,
          };
          return lrtbRect;
        }

        static intersectRect(rect1, rect2) {
          // logger.log("intersectRect", rect1, rect2);

          const r1 = this.createLRTBRect(rect1);
          // logger.log("r1", r1);
          const r2 = this.createLRTBRect(rect2);
          // logger.log("r2", r2);

          return !(r2.left > r1.right ||
            r2.right < r1.left ||
            r2.top > r1.bottom ||
            r2.bottom < r1.top);
        }

        // static intersectRect(rect1, rect2) {
        //   const r1 = {
        //     x: rect1.x,
        //     y: rect1.y,
        //     w: rect1.width,
        //     h: rect1.height,
        //   };
        //   const r2 = {
        //     x: rect2.x,
        //     y: rect2.y,
        //     w: rect2.width,
        //     h: rect2.height,
        //   };
        //
        //   var quickCheck = (r1.x <= r2.x + r2.w &&
        //           r2.x <= r1.x + r1.w &&
        //           r1.y <= r2.y + r2.h &&
        //           r2.y <= r1.y + r1.h);
        //   if (quickCheck) return true;
        //   var x_overlap = Math.max(0, Math.min(r1.x + r1.w, r2.x + r2.w) - Math.max(r1.x, r2.x));
        //   var y_overlap = Math.max(0, Math.min(r1.y + r1.h, r2.y + r2.h) - Math.max(r1.y, r2.y));
        //   var overlapArea = x_overlap * y_overlap;
        //   return !(overlapArea == 0);
        // }

        static isRectFullyContainedInRect(rect1, rect2) {
          const r1 = this.createLRTBRect(this.createLTRect(rect1));
          const r2 = this.createLRTBRect(this.createLTRect(rect2));
          logger.log("logGeom", "isRectFullyContainedInRect", "r1", r1);
          logger.log("logGeom", "isRectFullyContainedInRect", "r2", r2);
          
          return !( r1.left < r2.left ||
                     r1.top < r2.top ||
                   r1.right > r2.right ||
                  r1.bottom > r2.bottom);
        }

        static isPointContainedInRect(point, rect) {
          logger.log("logGeom", "isPointContainedInRect", "rect", rect);

          const r1 = this.createLRTBRect({
            left:   rect.x,
            top:    rect.y,
            width:  rect.width,
            height: rect.height,
          });
          logger.log("logGeom", "isPointContainedInRect", "r1", r1);
          
          return !(  point.x <= r1.left  ||
                     point.y <= r1.top   ||
                     point.x >= r1.right ||
                     point.y >= r1.bottom  );
        }

        static distance(p1, p2) {
          const v = {
            x: p2.x - p1.x,
            y: p2.y - p1.y,
          };

          const norm = this.norm_2d(v);

          return norm;
        }

        //point on object

        static pointOnCircle__angleInRadians(pointCenter, radius, angleInRadians) {
          const x = pointCenter.x + radius * Math.cos(-angleInRadians);  //conventional anticlockwise rotation
          const y = pointCenter.y + radius * Math.sin(-angleInRadians);
          const point = Geometry.createPoint(x, y);
          return point;
        }

        static pointOnCircle__angleInDegrees(pointCenter, radius, angleInDegrees) {
          const angleInRadians = angleInDegrees / 180.0 * Math.PI;
          return Geometry.pointOnCircle__angleInRadians(pointCenter, radius, angleInRadians);
        }

        static pointOnCircle__progress(pointCenter, radius, progress) {
          const angleInDegrees = progress * 360.0;
          return Geometry.pointOnCircle__angleInDegrees(pointCenter, radius, angleInDegrees);
        }

        static pointOnEllipse__angleInRadians(pointCenter, rx, ry, angleInRadians) {
          logger.log("pointOnEllipse__angleInRadians", pointCenter, rx, ry, angleInRadians);
          const x = pointCenter.x + rx * Math.cos(-angleInRadians);    //conventional anticlockwise rotation
          const y = pointCenter.y + ry * Math.sin(-angleInRadians);
          const point = Geometry.createPoint(x, y);
          return point;
        }

        static pointOnEllipse__angleInDegrees(pointCenter, rx, ry, angleInDegrees) {
          const angleInRadians = angleInDegrees / 180.0 * Math.PI;
          return Geometry.pointOnEllipse__angleInRadians(pointCenter, rx, ry, angleInRadians);
        }

        static pointOnEllipse__progress(pointCenter, rx, ry, progress) {
          const angleInDegrees = progress * 360.0;
          return Geometry.pointOnEllipse__angleInDegrees(pointCenter, rx, ry, angleInDegrees);
        }

        static pointOnPath__progress(path, progress) {
          //get total path length

          //get point at arc position : progress * total_length

        }

        static pointOnSegment__progress(point1, point2, progress) {
          const v = {
            X: (point2.x - point1.x) * progress,
            Y: (point2.y - point1.y) * progress,
          };
          return Geometry.translatedPoint(point1, v);
        }

        static pointOnSegment__nth(point1, point2, index, nb_total) {
          const progress = 1.0 * index / (nb_total - 1);
          return Geometry.pointOnSegment__progress(point1, point2, progress);
        }


        static pointOnSquare__angleInRadians(pointCenter, radius, angleInRadians) {
          var x;
          var y;
          const index_quarter = Math.floor((angleInRadians /*+ Math.PI / 4*/) / (Math.PI / 2));
          logger.log("index_quarter", index_quarter);
          switch (index_quarter) {
            case 0:
              x = pointCenter.x + radius;
              y = pointCenter.y + radius * Math.tan(-angleInRadians);
              break;
            case 1:
              x = pointCenter.y - radius / Math.tan(-angleInRadians);
              y = pointCenter.x - radius;
              break;
            case 2:
              x = pointCenter.x - radius;
              y = pointCenter.y - radius * Math.tan(-angleInRadians);
              break;
            case 3:
              x = pointCenter.y + radius / Math.tan(-angleInRadians);
              y = pointCenter.x + radius;
              break;
            default:
              throw new Error("angleInRadians must be between 0 and 2*Math.PI");
              break;
          }
          const point = Geometry.createPoint(x, y);
          return point;
        }

        static pointOnSquare__angleInDegrees(pointCenter, radius, angleInDegrees) {
          const angleInRadians = angleInDegrees / 180.0 * Math.PI;
          return Geometry.pointOnSquare__angleInRadians(pointCenter, radius, angleInRadians);
        }

        static pointOnSquare__progress(pointCenter, radius, progress) {
          const angleInDegrees = progress * 360.0;
          return Geometry.pointOnSquare__angleInDegrees(pointCenter, radius, angleInDegrees);
        }


        static getEnveloppeRect(arr_point) {

          const point0 = arr_point[0];
          const obj_tlbr = arr_point.reduce((acc, point) => {
            acc.left = Math.min(point.x, acc.left);
            acc.right = Math.max(point.x, acc.right);
            acc.top = Math.min(point.y, acc.top);
            acc.bottom = Math.max(point.y, acc.bottom);
            return acc;
          }, {
            left: point0.x,
            right: point0.x,
            top: point0.y,
            bottom: point0.y,
          });

          const outRect = {
            x: obj_tlbr.left,
            y: obj_tlbr.top,
            width: (obj_tlbr.right - obj_tlbr.left),
            height: (obj_tlbr.bottom - obj_tlbr.top),
          };

          return outRect;
        }

        static pointWithHomothety(pointSrc, pointCenter, factor) {
          const v = {
            x: pointSrc.x - pointCenter.x,
            y: pointSrc.y - pointCenter.y,
          };
          const pointDst = {
            x: pointCenter.x + v.x * factor,
            y: pointCenter.y + v.y * factor,
          };
          return pointDst;
        }

        static rectWithHomothety(rectSrc, pointCenter, factor) {
          const outRect = {
            x: Geometry.pointWithHomothety(rectSrc.x, pointCenter, factor),
            y: Geometry.pointWithHomothety(rectSrc.y, pointCenter, factor),
            width:  rectSrc.width  * factor,
            height: rectSrc.height * factor,
          };
          return outRect;
        }


        static segmentWithPointAndOffset(point1, offset) {
          const point2 = Geometry.createPointWithOffset(point1, offset);
          return Geometry.createSegment(point1, point2);
        }

        static segmentWithPointOriginAndOffset1Offset2(point0, offset1, offset2) {
          const point1 = Geometry.createPointWithOffset(point0, offset1);
          const point2 = Geometry.createPointWithOffset(point0, offset2);
          return Geometry.createSegment(point1, point2);
        }

        static segment_L(xyRect) {
          const pointTL = Geometry.createPoint(xyRect.x, xyRect.y);

          const offset1 = {
            dx: 0,
            dy: 0,
          };
          const offset2 = {
            dx: 0,
            dy: xyRect.height,
          };

          return Geometry.segmentWithPointOriginAndOffset1Offset2(pointTL, offset1, offset2);
        }

        static segment_R(xyRect) {
          const pointTL = Geometry.createPoint(xyRect.x, xyRect.y);

          const offset1 = {
            dx: xyRect.width,
            dy: 0,
          };
          const offset2 = {
            dx: xyRect.width,
            dy: xyRect.height,
          };

          return Geometry.segmentWithPointOriginAndOffset1Offset2(pointTL, offset1, offset2);
        }

        static segment_T(xyRect) {
          const pointTL = Geometry.createPoint(xyRect.x, xyRect.y);

          const offset1 = {
            dx: 0,
            dy: 0,
          };
          const offset2 = {
            dx: xyRect.width,
            dy: 0,
          };

          return Geometry.segmentWithPointOriginAndOffset1Offset2(pointTL, offset1, offset2);
        }

        static segment_B(xyRect) {
          const pointTL = Geometry.createPoint(xyRect.x, xyRect.y);

          const offset1 = {
            dx: 0,
            dy: xyRect.height,
          };
          const offset2 = {
            dx: xyRect.width,
            dy: xyRect.height,
          };

          return Geometry.segmentWithPointOriginAndOffset1Offset2(pointTL, offset1, offset2);
        }


        static createWebSegment__progress(segment1, segment2, progress) {
          const point1__progress = Geometry.pointOnSegment__progress(segment1.point1, segment1.point2, progress);
          const point2__progress = Geometry.pointOnSegment__progress(segment2.point1, segment2.point2, progress);
          return Geometry.createSegment(point1__progress, point2__progress);
        }

        static createWebSegment__nth(segment1, segment2, index, nb_total) {
          const progress = 1.0 * index / (nb_total - 1);
          return Geometry.createWebSegment__progress(segment1, segment2, progress);
        }


        // static createWebPath__progress(path1, path2, progress) {
        //   const point1 = 
        //   const point2 = 
          
        //   return Geometry.createSegment()
        // }

        // static createWebPath__nth(segment_1, segment_2, index, nb_total) {
        //   const progress = 1.0 * index / (nb_total - 1);
        //   return Geometry.pointOnSegment__progress(point_start, point_end, progress);
        // }



        static getArr_extangent_point__circleCircle(p1,r1,p2,r2) {
          logger.log("logZSegment", "getArr_extangent_point__circleCircle", p1,r1,p2,r2);

          var outArr;

          //get small/big
          const [c__min, c__max] = [{p: p1, r: r1}, {p: p2, r: r2}].sort((obj1,obj2) => {
            return obj1.r < obj2.r;
          });
          logger.log("logZSegment", "c__min", c__min);
          logger.log("logZSegment", "c__max", c__max);

          // const c__diff = {
          //   p: c__max.p,
          //   r: c__max.r - c__min.r,
          // };
          // const [point__B1, point__B2] = Geometry.getArr_tangent_point__circlePoint(c__diff.p, c__diff.r, c__min.p);

          const v = Geometry.vector_2d(c__min.p, c__max.p);     
          logger.log("logZSegment", "v", v);

          const d = Geometry.norm_2d(v);
          logger.log("logZSegment", "d", d);

          const angle__gamma = -Math.atan2( (c__max.p.y - c__min.p.y) , (c__max.p.x - c__min.p.x) );
          logger.log("logZSegment", "angle__gamma", angle__gamma);

          
          outArr = [-1,1].reduce((acc,sign) => {
            const angle__beta  = sign * Math.asin( (c__max.r - c__min.r) / d);
            const angle__alpha = angle__gamma - angle__beta;
            
            const arr__point = [
              {
                x: c__min.p.x + sign * c__min.r * Math.sin(angle__alpha),
                y: c__min.p.y + sign * c__min.r * Math.cos(angle__alpha),
              },
              {
                x: c__max.p.x + sign * c__max.r * Math.sin(angle__alpha),
                y: c__max.p.y + sign * c__max.r * Math.cos(angle__alpha),
              },
            ];
            logger.log("logZSegment", "arr__point", arr__point);

            acc.push(arr__point);
            
            return acc;  
            
          }, []);
        
          return outArr;
        }

        static getArr_tangent_point__circlePoint(p1,r1,p2) {
          const v = Geometry.vector_2d(p2, p1);     
          const d = Geometry.norm_2d(v);
          const v__normalized = Geometry.vector_2d__normalized(v);
          
          // const angle__beta = math.asin(r1/d);
          // const s = d * math.cos(angle__beta);

          const angle__kappa = math.acos(r1/d);
          
          const point__A  = {
            x: p1.x - v__normalized.X * r1,
            y: p1.y - v__normalized.Y * r1,
          };

          const point__B1 = Geometry.pointWithRotation__rad(point__A, p1, +angle__kappa);
          const point__B2 = Geometry.pointWithRotation__rad(point__A, p1, -angle__kappa);

          return [point__B1, point__B2];
        }

        // static getArr_tangent_line_eq__circlePoint(p1,r1,p2) {     
        //
        // }


        static getEnveloppeRect__circleCircle(p1,r1,p2,r2) {
          var outRect;

          const pointTL = {
            x: math.min(p1.x - r1, p2.x - r2),
            y: math.min(p1.y - r1, p2.y - r2),
          };
          const pointBR = {
            x: math.max(p1.x + r1, p2.x + r2),
            y: math.max(p1.y + r1, p2.y + r2),
          };

          outRect = {
            x: pointTL.x,
            y: pointTL.y,
            width:  pointBR.x - pointTL.x,
            height: pointBR.y - pointTL.y,
          }

          return outRect;
        }


        static createRandomPoint(pointTL, pointBR) {
          const point = {
            x: math.floor(pointTL.x + (pointBR.x - pointTL.x) * math.random()),
            y: math.floor(pointTL.y + (pointBR.y - pointTL.y) * math.random()),
          };
          return point;
        }



        static convert__arrPointToArrXY(arr_point) {
          return arr_point.reduce((acc,point) => {
            acc.push(point.x);
            acc.push(point.y);
            return acc;
          }, []);
        }
        
        static convert__arrXYToArrPoint(arr_xy) {
          return Utils.partition(arr_xy, 2).reduce((acc,[x,y]) => {
            const point = Geometry.createPoint(x,y);
            acc.push(point);
            return acc;
          }, []);
        }
        
        static getArrPoint_curve_easy(arr_point__checkpoint,tension,numOfSeg,close) {
            const arr_xy__checkpoint  = Geometry.convert__arrPointToArrXY(arr_point__checkpoint);
            
            const arr_xy__curve       = getCurvePoints(arr_xy__checkpoint,tension,numOfSeg,close);  //from lib/curve_calc.min.js
            
            const arr_point__curve    = Geometry.convert__arrXYToArrPoint(arr_xy__curve);
            return arr_point__curve; 
        }

        /*********--------------------*/
        //?arr_point__curve must be pairwise equidistant?
        static getArrVect2d_curveTangentVects(arr_point__curve) {
          const arr_zip = Utils.zip(arr_point__curve.slice(0,-1), arr_point__curve.slice(1));  
          return arr_zip.reduce((acc, [point__n, point__nPlus1]) => {
            const vect__tangent = Geometry.vector_2d(point__n, point__nPlus1);
            acc.push(vect__tangent);
            return acc;
          }, []);
        }

        static getArrVect2d_curveNormalVects(arr_point__curve) {
          const arr_vect__tangent = Geometry.getArrVect2d_curveTangentVects(arr_point__curve);
          return arr_vect__tangent.map((vect2d__tangent) => {
            const vect2d__normal = {
              X: +vect2d__tangent.Y,
              Y: -vect2d__tangent.X,
            };
            return vect2d__normal;
          });
        }
        
        static getArrVect2d_curveTangentUnitVects(arr_point__curve) {
          return Geometry.getArrVect2d_curveTangentVects(arr_point__curve).map((vect2d) => {
            return Geometry.vector_2d__normalized(vect2d);
          });
        }
        
        static getArrVect2d_curveNormalUnitVects(arr_point__curve) {
          return Geometry.getArrVect2d_curveNormalVects(arr_point__curve).map((vect2d) => {
            return Geometry.vector_2d__normalized(vect2d);
          });
        }
        /*-------------------*********/

        static createArrPoint_carriedFunc(arr_point__curve, func_amplitude) {
            const arr_vect__unitNormal__length_nMinus1 = Geometry.getArrVect2d_curveNormalUnitVects(arr_point__curve);
            // logger.log("logCurve3", "arr_vect__unitNormal__length_nMinus1:", arr_vect__unitNormal__length_nMinus1);

            const arr_vect__unitNormal__length_n = [
              arr_vect__unitNormal__length_nMinus1[0],
              ...Utils.zip(arr_vect__unitNormal__length_nMinus1.slice(0,-1), arr_vect__unitNormal__length_nMinus1.slice(1)).map(([v1,v2]) => {
                const v__mean = {
                  X: (v1.X + v2.X) / 2.0,
                  Y: (v1.Y + v2.Y) / 2.0,
                };
                return v__mean;
              }),
              arr_vect__unitNormal__length_nMinus1.slice(-1)[0],
            ].map((vect2d) => {
              return Geometry.vector_2d__normalized(vect2d);
            });
            // logger.log("logCurve3", "arr_vect__unitNormal__length_n:", arr_vect__unitNormal__length_n);

            const nb_points = arr_point__curve.length;
            const arr_point__carried = Utils.zip(arr_point__curve, arr_vect__unitNormal__length_n).map(([point__curve, vect__unitNormal], index) => {
              const progress  = index / (nb_points - 1);
              const amplitude = func_amplitude(progress);
              const vect_offset = {
                X: vect__unitNormal.X * amplitude,
                Y: vect__unitNormal.Y * amplitude,
              };
              logger.log("logCurve", "vect_offset", vect_offset);
              const point__carried = {
                x: point__curve.x + vect_offset.X,
                y: point__curve.y + vect_offset.Y,
              };
              return point__carried;
            });
            return arr_point__carried;
        }

        static getMiniDict_point_vector_at_progress(arr_point__curve, progress) {

        }


      }


      const SnapState = {
        "Unsnapped": "Unsnapped",
        "Presnapped": "Presnapped",
        "Snapped": "Snapped",
      };

      class Snap { //GeometryWise snapping

        static canSnap(icObj_over, icObj_below) { //SHU: what would be nice would be to use the norm of a transformation matrix to settle threshold
          // const ratio__position        = {
          //   x:  (icObj_over.position.x - icObj_below.position.x) / icObj_below.position.x,
          //   y:  (icObj_over.position.y - icObj_below.position.y) / icObj_below.position.y,
          // };
          // console.log("ratio__position", ratio__position);
          // if(!(Math.abs(ratio__position.x) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__position.y) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__size        = {
          //   width:  (icObj_over.size.width  - icObj_below.size.width)  / icObj_below.size.width,
          //   height: (icObj_over.size.height - icObj_below.size.height) / icObj_below.size.height,
          // };
          // console.log("ratio__size", ratio__size);
          // if(!(Math.abs(ratio__size.width) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__size.height) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__orientation = (icObj_over.orientation - icObj_below.orientation) / icObj_below.orientation;
          // console.log("ratio__orientation", ratio__orientation);
          // if(!(Math.abs(ratio__orientation) < 0.10)) {
          //   return false;
          // }


          //snapping params:
          // const snapping_params = {
          //   // position: {
          //   //   x: 0.10,
          //   //   y: 0.10,
          //   // },
          //   position: {
          //     x: 0.05,
          //     y: 0.05,
          //   },
          //   size: {
          //     width:  0.05,
          //     height: 0.05,
          //   },
          //   homeScale: {
          //
          //   },
          //   orientation: {
          //     orientation: 0.05,
          //   },
          // };

          const snapping_params = {
            // position: {
            //   x: 0.10,
            //   y: 0.10,
            // },
            position: {
              x: 0.50,
              y: 0.50,
            },
            size: {
              width: 0.05,
              height: 0.05,
            },
            // homeScale: {
            //   X:  0.05,
            //   Y:  0.05,
            // },
            orientation: {
              orientation: 0.05,
            },
          };


          //SHU TODO: a nice and complex canSnapFunc
          const canSnapFunc = (icObj_over, icObj_below) => {

          };


          // const unsamenessRatio__position = {
          //   x:  Snap.unsamenessRatio(icObj_over.position.x, icObj_below.position.x),
          //   y:  Snap.unsamenessRatio(icObj_over.position.y, icObj_below.position.y),
          // };
          // if(unsamenessRatio__position.x > snapping_params.position.x) {
          //   return false;
          // }
          // if(unsamenessRatio__position.y > snapping_params.position.y) {
          //   return false;
          // }

          const distance = Geometry.distance(icObj_over.position, icObj_below.position);
          console.log("distance", distance);
          if (distance > 200) {
            return false;
          }

          /*
          const unsamenessRatio__size = {
            width:  Snap.unsamenessRatio(icObj_over.size.width,  icObj_below.size.width),
            height: Snap.unsamenessRatio(icObj_over.size.height, icObj_below.size.height),
          };
          console.log("°°unsamenessRatio__size.width",  unsamenessRatio__size.width);
          console.log("°°icObj_over.size.width",  icObj_over.size.width);
          console.log("°°icObj_below.size.width",  icObj_below.size.width);

          console.log("°°unsamenessRatio__size.height", unsamenessRatio__size.height);
          console.log("°°icObj_over.size.height",  icObj_over.size.height);
          console.log("°°icObj_below.size.height",  icObj_below.size.height);

          if(unsamenessRatio__size.width > snapping_params.size.width) {
            return false;
          }
          if(unsamenessRatio__size.height > snapping_params.size.height) {
            return false;
          }

          const icObj_over__zero_centered_orientation  = (icObj_over.orientation > 180 ? icObj_over.orientation - 180 : icObj_over.orientation);
          const icObj_below__zero_centered_orientation = (icObj_below.orientation > 180 ? icObj_below.orientation - 180 : icObj_below.orientation);

          const unsamenessRatio__orientation = {
            // orientation: Snap.unsamenessRatio(icObj_over.orientation,  icObj_below.orientation),
            // orientation: Math.abs((icObj_over.orientation - icObj_below.orientation) / 360.0),
            orientation: Snap.unsamenessRatio(icObj_over__zero_centered_orientation,  icObj_below__zero_centered_orientation),
          };
          console.log("unsamenessRatio__orientation.orientation", unsamenessRatio__orientation.orientation);
          if(unsamenessRatio__orientation.orientation > snapping_params.orientation.orientation) {
            return false;
          }
          */

          return true;
        }

        static canSnap_noSize(icObj_over, icObj_below) {

          const snapping_params = {
            // position: {
            //   x: 0.10,
            //   y: 0.10,
            // },
            position: {
              x: 0.50,
              y: 0.50,
            },
            // size: {
            //   width:  0.05,
            //   height: 0.05,
            // },
            // homeScale: {
            //   X:  0.05,
            //   Y:  0.05,
            // },
            orientation: {
              orientation: 0.05,
            },
          };


          //SHU TODO: a nice and complex canSnapFunc
          const canSnapFunc = (icObj_over, icObj_below) => {

          };


          const unsamenessRatio__position = {
            x: Snap.unsamenessRatio(icObj_over.position.x, icObj_below.position.x),
            y: Snap.unsamenessRatio(icObj_over.position.y, icObj_below.position.y),
          };
          if (unsamenessRatio__position.x > snapping_params.position.x) {
            return false;
          }
          if (unsamenessRatio__position.y > snapping_params.position.y) {
            return false;
          }

          // const unsamenessRatio__size = {
          //   width:  Snap.unsamenessRatio(icObj_over.size.width,  icObj_below.size.width),
          //   height: Snap.unsamenessRatio(icObj_over.size.height, icObj_below.size.height),
          // };
          // console.log("°°unsamenessRatio__size.width",  unsamenessRatio__size.width);
          // console.log("°°icObj_over.size.width",  icObj_over.size.width);
          // console.log("°°icObj_below.size.width",  icObj_below.size.width);
          //
          // console.log("°°unsamenessRatio__size.height", unsamenessRatio__size.height);
          // console.log("°°icObj_over.size.height",  icObj_over.size.height);
          // console.log("°°icObj_below.size.height",  icObj_below.size.height);
          //
          // if(unsamenessRatio__size.width > snapping_params.size.width) {
          //   return false;
          // }
          // if(unsamenessRatio__size.height > snapping_params.size.height) {
          //   return false;
          // }

          const icObj_over__zero_centered_orientation = (icObj_over.orientation > 180 ? icObj_over.orientation - 180 : icObj_over.orientation);
          const icObj_below__zero_centered_orientation = (icObj_below.orientation > 180 ? icObj_below.orientation - 180 : icObj_below.orientation);

          const unsamenessRatio__orientation = {
            // orientation: Snap.unsamenessRatio(icObj_over.orientation,  icObj_below.orientation),
            // orientation: Math.abs((icObj_over.orientation - icObj_below.orientation) / 360.0),
            orientation: Snap.unsamenessRatio(icObj_over__zero_centered_orientation, icObj_below__zero_centered_orientation),
          };
          console.log("unsamenessRatio__orientation.orientation", unsamenessRatio__orientation.orientation);
          if (unsamenessRatio__orientation.orientation > snapping_params.orientation.orientation) {
            return false;
          }

          return true;
        }


        static canUnsnap(icObj_over, icObj_below) {
          return !this.canSnap(icObj_over, icObj_below);
        }

        /*
        static canUnsnap(icObj_over, icObj_below) { //SHU: what would be nice would be to use the norm of a transformation matrix to settle threshold
          // const ratio__position        = {
          //   x:  (icObj_over.position.x - icObj_below.position.x) / icObj_below.position.x,
          //   y:  (icObj_over.position.y - icObj_below.position.y) / icObj_below.position.y,
          // };
          // console.log("ratio__position", ratio__position);
          // if(!(Math.abs(ratio__position.x) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__position.y) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__size        = {
          //   width:  (icObj_over.size.width  - icObj_below.size.width)  / icObj_below.size.width,
          //   height: (icObj_over.size.height - icObj_below.size.height) / icObj_below.size.height,
          // };
          // console.log("ratio__size", ratio__size);
          // if(!(Math.abs(ratio__size.width) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__size.height) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__orientation = (icObj_over.orientation - icObj_below.orientation) / icObj_below.orientation;
          // console.log("ratio__orientation", ratio__orientation);
          // if(!(Math.abs(ratio__orientation) < 0.10)) {
          //   return false;
          // }


          //snapping params:
          const unsnapping_params = {
            // position: {
            //   x: 0.10,
            //   y: 0.10,
            // },
            position: {
              x: 0.10,
              y: 0.10,
            },
            size: {
              width:  0.10,
              height: 0.10,
            },
            orientation: {
              orientation: 0.10,
            },
          };

          // //SHU TODO: a nice and complex canUnsnapFunc
          // const canUnsnapFunc = (icObj_over, icObj_below) => {
          //
          // };


          const unsamenessRatio__position = {
            x:  Snap.unsamenessRatio(icObj_over.position.x, icObj_below.position.x),
            y:  Snap.unsamenessRatio(icObj_over.position.y, icObj_below.position.y),
          };
          if(unsamenessRatio__position.x < unsnapping_params.position.x) {
            return false;
          }
          if(unsamenessRatio__position.y < unsnapping_params.position.y) {
            return false;
          }

          const unsamenessRatio__size = {
            width:  Snap.unsamenessRatio(icObj_over.size.width,  icObj_below.size.width),
            height: Snap.unsamenessRatio(icObj_over.size.height, icObj_below.size.height),
          };
          if(unsamenessRatio__size.width < unsnapping_params.size.width) {
            return false;
          }
          if(unsamenessRatio__size.height < unsnapping_params.size.height) {
            return false;
          }

          const unsamenessRatio__orientation = {
            orientation: Snap.unsamenessRatio(icObj_over.orientation,  icObj_below.orientation),
          };
          if(unsamenessRatio__orientation.orientation < unsnapping_params.orientation.orientation) {
            return false;
          }

          return true;
        }
        */



        static unsamenessRatio(nb1, nb2) {
          var outNumber;
          outNumber = (nb1 - nb2);
          // if(outNumber != 0) {
          if (nb2 != 0) {
            outNumber = outNumber / nb2;
          }
          outNumber = Math.abs(outNumber);
          return outNumber;
        }

        static snapAnimation(icObj_over, icObj2_below) {

        }



        static defaultSnapEngine(infiniteCanvas, icSnapSlot) {
          var outSnapEngine;

          const canSnapFunc = (above, below) => {
            return Snap.canSnap(above, below);
          };

          const canUnsnapFunc = (above, below) => {
            return Snap.canUnsnap(above, below);
          };

          // const snapEngine = {
          //   canSnapFunc:   canSnapFunc,
          //   canUnsnapFunc: canUnsnapFunc,
          // };
          //
          // outSnapEngine = snapEngine;

          const snapEngine = SnapEngine.defaultInstance(infiniteCanvas, icSnapSlot);

          Hooker.installHooks(snapEngine, "presnap");
          // snapEngine.will["presnap"].on((...args) => {
          //   console.log("will presnap", ...args);
          // });
          // snapEngine.did["presnap"].on((...args) => {
          //   console.log("did presnap", ...args);
          // });
          Hooker.installHooks(snapEngine, "snap");
          Hooker.installHooks(snapEngine, "unsnap");



          snapEngine.canSnapFunc = canSnapFunc;
          snapEngine.canUnsnapFunc = canUnsnapFunc;

          outSnapEngine = snapEngine;

          return outSnapEngine;
        }

        static defaultSnapSlotConfig() {
          const canSnapFunc = (above, below) => {
            return Snap.canSnap(above, below);
          };

          const canUnsnapFunc = (above, below) => {
            return Snap.canUnsnap(above, below);
          };

          const snapSlotConfig = {
            canSnapFunc: canSnapFunc,
            canUnsnapFunc: canUnsnapFunc,
          };

          return snapSlotConfig;
        }

      }

      // class SnapEngine {
      //
      //   constructor() {
      //
      //   }
      //
      //   start() {
      //
      //   }
      //
      //   stop() {
      //
      //   }
      //
      //   static defaultInstance(infiniteCanvas, icSnapSlot) {
      //     var outEngine;
      //
      //     const snapEngine = new SnapEngine();
      //
      //     const attemptSnapping = function(icObj_slot, icObj_piece) {
      //       console.log("attemptSnapping", icObj_slot, icObj_piece);
      //
      //       const canSnap = snapEngine.checkCanSnap(icObj_slot, icObj_piece);
      //
      //       const rep_official = icObj_piece;
      //       console.log("attempting to snap with snapState: " + rep_official.snapState);
      //
      //       // const isValidPieceSnapState = (rep_official.snapState == SnapState.Unsnapped);
      //       //
      //       // if(isValidPieceSnapState) {
      //       //
      //       // } else {
      //       //   console.log("can't snap while snapState == " + rep_official.snapState)
      //       //   // throw new Error("attempting to snap with snapState: " + rep_official.snapState);
      //       //   return;
      //       // }
      //
      //       if(canSnap) {
      //         console.log("can snap");
      //
      //         const rep_official = icObj_piece;
      //         const represented  = icObj_piece.represented;
      //         const rep_free     = represented.getRepresentation("free");
      //
      //         console.log("rep_free.isHeld", rep_free.isHeld);
      //         if(rep_free.isHeld) {
      //           snapEngine.presnap(icObj_slot, icObj_piece);
      //         } else {
      //           snapEngine.presnap(icObj_slot, icObj_piece);
      //           snapEngine.snap(icObj_slot, icObj_piece);
      //         }
      //
      //       } else {
      //         console.log("can't snap");
      //       }
      //
      //     };
      //     snapEngine.attemptSnapping = attemptSnapping;
      //
      //     const checkCanSnap = function(icObj_slot, icObj_piece) {
      //       console.log("checkCanSnap", icObj_piece);
      //       var outBool;
      //
      //       // outBool = Snap.canSnap(icObj_piece, icObj_slot);
      //       outBool = snapEngine.canSnapFunc(icObj_piece, icObj_slot);
      //
      //       return outBool;
      //     };
      //
      //     var rep_free_onRelease__triggerSnap          = null;
      //     var rep_free_afterPresnap__attemptUnsnapping = null;
      //
      //     var rep_free_callbacks = {
      //       onRelease__triggerSnap:          null,
      //       afterPresnap__attemptUnsnapping: null,
      //     };
      //     snapEngine.checkCanSnap = checkCanSnap;
      //
      //     const presnap = function(icObj_slot, icObj_piece) {
      //       console.log("presnap", icObj_piece);
      //
      //       const rep_official = icObj_piece;
      //       const represented  = icObj_piece.represented;
      //       const rep_free     = represented.getRepresentation("free");
      //       const rep_snapped  = represented.createNewRepresentation("snapped");
      //
      //       rep_official.snapState = SnapState.Presnapped;
      //       // rep_official.snappedTo = icObj_slot;
      //       rep_official.snappedTo = icObj_slot.id;
      //
      //
      //       rep_official.unfollow(rep_free);
      //
      //
      //       rep_snapped.position     = Object.assign({}, icObj_slot.position);
      //       rep_snapped.homeScale    = Object.assign({}, icObj_slot.homeScale);
      //       rep_snapped.scale        = Object.assign({}, icObj_slot.scale);
      //       rep_snapped.orientation  = icObj_slot.orientation;
      //
      //       infiniteCanvas.addRepresentation(represented, rep_snapped);
      //
      //
      //       // rep_official.syncWith(rep_snapped);
      //       rep_official.syncWithObj({
      //         position:   rep_snapped.position,
      //         size:       rep_snapped.size,
      //         homeScale:  rep_snapped.homeScale,
      //         scale:      rep_snapped.scale,
      //
      //         // didUpdateListeners : rep_snapped.didUpdateListeners,
      //         // holdListeners      : rep_snapped.holdListeners,
      //         // releaseListeners   : rep_snapped.releaseListeners,
      //       });
      //       rep_official.follow(rep_snapped);
      //
      //
      //       rep_free.opacity = 0.0;
      //         //debug
      //       rep_free.opacity = 1.0;
      //       rep_free.fill = "blue";
      //
      //       //add release listener
      //       // icObj_fRep.onHold((icObj) => {
      //       //
      //       // });
      //
      //       //add release listener for rep_free
      //       rep_free_onRelease__triggerSnap = (rep_free) => {
      //         console.log("rep_free_onRelease__triggerSnap");
      //
      //         snapEngine.snap(icObj_slot, icObj_piece);
      //       };
      //       rep_free.onRelease(rep_free_onRelease__triggerSnap);
      //
      //
      //       //add unsnap listener for rep_free
      //       rep_free_afterPresnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
      //         console.log("rep_free_afterPresnap__attemptUnsnapping", rep_free);
      //
      //         snapEngine.attemptUnsnapping(icObj_slot, rep_free);
      //       };
      //       rep_free.onInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
      //
      //     };
      //     snapEngine.presnap = presnap;
      //
      //
      //     const snap = function(icObj_slot, icObj_piece) {
      //       console.log("snap", icObj_piece);
      //
      //       const rep_official = icObj_piece;
      //       const represented  = icObj_piece.represented;
      //       const rep_free     = represented.getRepresentation("free");
      //       const rep_snapped  = represented.getRepresentation("snapped");
      //
      //       console.log("**snap", "rep_free.isHeld", rep_free.isHeld);
      //
      //       console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
      //       if(rep_free_afterPresnap__attemptUnsnapping != null) {
      //         rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
      //       }
      //       rep_free_afterPresnap__attemptUnsnapping = null;
      //
      //
      //       rep_free.offRelease(rep_free_onRelease__triggerSnap);
      //       rep_free_onRelease__triggerSnap = null;
      //
      //
      //
      //       // rep_free.syncWith(rep_snapped);
      //       // rep_free.syncWith(rep_official);
      //
      //       //SHU TODO: MYSTERE ET BOULE DE GOMME: il y a un truc avec syncWith qui casse rep_free ... ???
      //
      //       rep_free.syncWithObj({
      //         position:   rep_snapped.position,
      //         size:       rep_snapped.size,
      //         homeScale:  rep_snapped.homeScale,
      //         scale:      rep_snapped.scale,
      //
      //         // didUpdateListeners : rep_snapped.didUpdateListeners,
      //         // holdListeners      : rep_snapped.holdListeners,
      //         // releaseListeners   : rep_snapped.releaseListeners,
      //       });
      //
      //
      //
      //       rep_free.opacity = 1.0;
      //         //debug
      //       rep_free.opacity = 1.0;
      //       rep_free.fill = "red";
      //
      //       rep_official.unfollow(rep_snapped);
      //       rep_official.follow(rep_free);
      //       rep_official.snapState = SnapState.Snapped;
      //       // rep_official.snappedTo = icObj_slot;
      //       // rep_official.snappedTo = icObj_slot.id;
      //
      //
      //
      //       console.log("remove rep_snapped", rep_snapped.id_rep);
      //       rep_snapped.im_dying_now = true;
      //       infiniteCanvas.removeRepresentation(represented, rep_snapped);
      //       represented.removeRepresentation(rep_snapped);
      //
      //       //add unsnap listener for rep_free
      //       // rep_free_afterSnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
      //       //   console.log("rep_free_afterSnap__attemptUnsnapping", rep_free);
      //       //
      //       //   attemptUnsnapping(icObj_slot, rep_free);
      //       // };
      //       // rep_free.onInnerUpdate(rep_free_afterSnap__attemptUnsnapping);
      //
      //
      //         //debug
      //       // rep_free.onHold((rep_free) => {
      //       //   console.log("###rep_free.id_rep", rep_free.id_rep);
      //       //   console.log("###rep_free.onHold", "rep_free.isHeld", rep_free.isHeld);
      //       // });
      //
      //     };
      //     snapEngine.snap = snap;
      //
      //
      //
      //
      //
      //     const attemptUnsnapping = function(icObj_slot, icObj_piece) {
      //       console.log("attemptUnsnapping", icObj_slot, icObj_piece);
      //
      //       const canUnsnap = snapEngine.checkCanUnsnap(icObj_slot, icObj_piece);
      //       console.log("canUnsnap", canUnsnap);
      //
      //       const rep_official = icObj_piece;
      //       console.log("attempting to unsnap with snapState: " + rep_official.snapState);
      //
      //       // const isValidPieceSnapState = (rep_official.snapState == SnapState.Presnapped);
      //       //
      //       // if(isValidPieceSnapState) {
      //       //
      //       // } else {
      //       //   console.log("can't unsnap while snapState == " + rep_official.snapState)
      //       //   // throw new Error("attempting to unsnap with snapState: " + rep_official.snapState);
      //       //   return;
      //       // }
      //
      //       if(canUnsnap) {
      //         // console.log("can unsnap");
      //         snapEngine.unsnap(icObj_slot, icObj_piece);     //presnap already sets up an unsnap listener
      //
      //       } else {
      //         // console.log("can't unsnap");
      //
      //         //SHU TODO: hasLeftSlot
      //         // const hasLeftSlot = Snap.hasLeftSlot()
      //         const hasLeftSlot = true;
      //
      //         if(hasLeftSlot) {
      //
      //
      //           // const rep_official = icObj_piece;
      //           const represented  = icObj_piece.represented;
      //           const rep_free     = represented.getRepresentation("free");
      //
      //           console.log("#rep_free.id_rep", rep_free.id_rep);
      //           console.log("#rep_free.isHeld", rep_free.isHeld);
      //
      //           if(rep_free.isHeld) {
      //             if(icObj_piece.snapState == SnapState.Snapped) {
      //               snapEngine.presnap(icObj_slot, icObj_piece);
      //             }
      //           } else {
      //             //do nothing
      //             // snap(icObj_slot, icObj_piece);
      //           }
      //
      //         } else {
      //           //do nothing
      //           // snap(icObj_slot, icObj_piece);
      //         }
      //
      //
      //
      //       }
      //
      //     };
      //     snapEngine.attemptUnsnapping = attemptUnsnapping;
      //
      //     const checkCanUnsnap = function(icObj_slot, icObj_piece) {
      //       console.log("checkCanUnsnap", icObj_piece);
      //       var outBool;
      //
      //       // outBool = Snap.canUnsnap(icObj_piece, icObj_slot);
      //       outBool = snapEngine.canUnsnapFunc(icObj_piece, icObj_slot);
      //
      //       return outBool;
      //     };
      //     snapEngine.checkCanUnsnap = checkCanSnap;
      //
      //
      //     const unsnap = function(icObj_slot, icObj_piece) {
      //       console.log("unsnap", icObj_piece);
      //
      //       // const represented  = icObj_piece.represented;
      //       // const rep_official = represented.getRepresentation("official");
      //       // const rep_snapped  = represented.getRepresentation("snapped");
      //
      //       const rep_unknown  = icObj_piece; //SHU TODO: solve snapSlot's rep madness
      //       const represented  = icObj_piece.represented;
      //       const rep_official = represented.getRepresentation("official");
      //       const rep_free     = represented.getRepresentation("free");
      //       const rep_snapped  = represented.getRepresentation("snapped");
      //
      //
      //       console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
      //       if(rep_free_afterPresnap__attemptUnsnapping != null) {
      //         rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
      //       }
      //       rep_free_afterPresnap__attemptUnsnapping = null;
      //
      //       // if(rep_free_afterSnap__attemptUnsnapping != null) {
      //       //   rep_free.offInnerUpdate(rep_free_afterSnap__attemptUnsnapping);
      //       // }
      //       // rep_free_afterSnap__attemptUnsnapping = null;
      //
      //
      //       // rep_free.offRelease(rep_free_onRelease__triggerSnap);
      //       // rep_free_onRelease__triggerSnap = null;
      //
      //       if(rep_free.offRelease != null) { //****************************************  SHU: il y a un problème ici, quand j'aurai trois neurones de disponibles, j'investiguerai
      //         rep_free.offRelease(rep_free_onRelease__triggerSnap);
      //         rep_free_onRelease__triggerSnap = null;
      //       }                                 //****************************************
      //
      //
      //       rep_official.syncWith(rep_free);
      //       rep_official.follow(rep_free);
      //
      //
      //       if(rep_snapped != null) {
      //         console.log("remove rep_snapped", rep_snapped.id_rep);
      //         rep_snapped.im_dying_now = true;
      //         infiniteCanvas.removeRepresentation(represented, rep_snapped);
      //         represented.removeRepresentation(rep_snapped);
      //       } else {
      //         console.log("rep_snapped already destroyed somewhere else");
      //       }
      //
      //
      //       // rep_free.im_dying_now = true; //SHU: this is interesting
      //
      //       rep_free.opacity = 1.0;
      //         //debug
      //       rep_free.fill = "lime";
      //
      //       rep_official.snapState = SnapState.Unsnapped;
      //       // rep_official.snappedTo = null;
      //       rep_official.snappedTo = -1;
      //
      //     };
      //     snapEngine.unsnap = unsnap;
      //
      //
      //
      //
      //
      //
      //     const r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
      //       console.log("r_official_update_handler", icObj_piece);
      //
      //       console.log("icObj_piece.snapState", icObj_piece.snapState);
      //
      //       // if(outerUpdatesDict["snapState"] == SnapState.Snapped) {
      //       //   //official just changed snapState to .Snapped
      //       //   //ignore
      //       //   return;
      //       // }
      //
      //       if(icObj_piece.snapState == SnapState.Unsnapped) {
      //         snapEngine.attemptSnapping(icObj_slot, icObj_piece);
      //       } else if(icObj_piece.snapState == SnapState.Snapped) {
      //         snapEngine.attemptUnsnapping(icObj_slot, icObj_piece);               //SHU666666 : this is the key line to understand what is wrong
      //       } else if(icObj_piece.snapState == SnapState.Presnapped) {
      //
      //       }
      //
      //     };
      //     snapEngine.r_official_update_handler = r_official_update_handler;
      //
      //     const r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
      //       console.log("r_official_update_handler2", rep_official_incoming);
      //
      //       const represented  = infiniteCanvas.getRepresented(icSnapSlot.id);
      //       console.log("represented", represented);
      //       const rep_official = represented.r_official();
      //
      //       const snapSlot    = rep_official;
      //       const incomingObj = rep_official_incoming;
      //
      //       if(incomingObj != snapSlot) { //don't snap oneself
      //
      //         if(!incomingObj.isSnappable) {
      //           //ignore: incomingObj is diamagnetic
      //         } else {
      //           console.log("++++incomingObj.snappedTo", incomingObj.snappedTo);
      //           // if(incomingObj.snappedTo != null && incomingObj.snappedTo != snapSlot) {
      //           if(incomingObj.snappedTo != -1 && incomingObj.snappedTo != snapSlot.id) {
      //             //ignore: incomingObj is already snapped to another slot
      //           } else {
      //             snapEngine.r_official_update_handler(snapSlot, incomingObj, outerUpdatesDict);
      //           }
      //         }
      //
      //       } else {
      //         console.log("I won't snap myself");
      //       }
      //
      //     };
      //     snapEngine.r_official_update_handler2 = r_official_update_handler2;
      //
      //     outEngine = snapEngine;
      //
      //     return outEngine;
      //   }
      //
      // }



      const TouchState = {
        "Untouched": "Untouched",
        "Touched": "Touched",
      };

      class Touch { //GeometryWise touching

        static canTouch(icObj_over, icObj_below) {

          const rect__over  = icObj_over.getRect();
          const rect__below = icObj_below.getRect();

          logger.log("rect__over", rect__over);
          logger.log("rect__below", rect__below);

          const isIntersecting = Geometry.intersectRect(rect__over, rect__below);
          logger.log("isIntersecting", isIntersecting);

          return isIntersecting;
        }

        static canUntouch(icObj_over, icObj_below) {
          return !this.canTouch(icObj_over, icObj_below);
        }

      }


      class Touch2 { //GeometryWise Screen-wise touching

        constructor(fabricIntegration) {
          this.fabricIntegration = fabricIntegration;
        }

        isIntersecting(icObj_over, icObj_below) {
          //flemme: use fabric fObj.intersectsWithObject(fObj2)
          // logger.log("logTouch2", "isIntersecting", "icObj_over:", icObj_over, "icObj_below:", icObj_below);

          //const over__represented  = infiniteCanvas.getRepresented(icObj_over.id);
          //const over__rep_free     = over__represented.r_free();
          // const over__fObj         = over__rep_free.fObj;                            //<-- this is not available

          const over__fObj = fabricIntegration.getFObjForIcObj(icObj_over);
          // logger.log("logTouch2", "isIntersecting", "over__fObj", over__fObj);


          // const below__represented  = infiniteCanvas.getRepresented(icObj_below.id);
          // const below__rep_free     = below__represented.r_free();
          // const below__fObj         = below__rep_free.fObj;                          //<-- this is not available
          const below__fObj = fabricIntegration.getFObjForIcObj(icObj_below);
          // logger.log("logTouch2", "isIntersecting", "below__fObj", below__fObj);


          const isIntersecting_ = over__fObj.intersectsWithObject(below__fObj);
          // const isIntersecting_ = over__fObj.intersectsWithObject(below__fObj, true);
          // logger.log("logTouch2", "isIntersecting", "isIntersecting_:", isIntersecting_);


          // const ltwhRect__over = {
          //   left:   over__fObj.left,
          //   top:    over__fObj.top,
          //   width:  over__fObj.width,
          //   height: over__fObj.height,
          // };
          // const ltwhRect__below = {
          //   left:   below__fObj.left,
          //   top:    below__fObj.top,
          //   width:  below__fObj.width,
          //   height: below__fObj.height,
          // };
          // const isIntersecting2_ = Geometry.intersectRect(ltwhRect__over, ltwhRect__below);
          // logger.log("logTouch2", "isIntersecting", "isIntersecting2_:", isIntersecting_);

          return isIntersecting_;
        }

        canTouch(icObj_over, icObj_below) {
          return this.isIntersecting(icObj_over, icObj_below);
        }

        canUntouch(icObj_over, icObj_below) {
          return !this.canTouch(icObj_over, icObj_below);
        }

      }

      const Touch2Singleton = (function () {
        var instance;

        function createInstance(fabricIntegration) {
          var object = new Touch2(fabricIntegration);
          return object;
        }

        return {
          initializeInstance: function (fabricIntegration) {
            const sharedInstance = createInstance(fabricIntegration);
            instance = sharedInstance;
          },
          sharedInstance: function () {
            if (!instance) {
              // instance = createInstance();
              throw new Error("Touch2Singleton has not been initialized, call initializeInstance before using singleton");
            }
            return instance;
          }
        };
      })();




      class DiveTouch { //GeometryWise Screen-wise touching

        constructor(fabricIntegration) {
          this.fabricIntegration = fabricIntegration;
          this.touch2 = new Touch2(fabricIntegration);
        }

        isIntersecting(icObj_over, icObj_below) {
          var isIntersecting;

          const isIntersecting__touch = this.touch2.isIntersecting(icObj_over, icObj_below);

          logger.log("DiveTouch", "{");
          logger.log("DiveTouch", "icObj_over.homeScale.X",  icObj_over.homeScale.X);
          logger.log("DiveTouch", "icObj_below.homeScale.X", icObj_below.homeScale.X);
          logger.log("DiveTouch", "}");

          const isZoom__penetrating = icObj_over.homeScale.X > icObj_below.homeScale.X;
          logger.log("DiveTouch", "isZoom__penetrating", isZoom__penetrating);

          isIntersecting = isIntersecting__touch && isZoom__penetrating;

          return isIntersecting;
        }

        canTouch(icObj_over, icObj_below) {
          return this.isIntersecting(icObj_over, icObj_below);
        }

        canUntouch(icObj_over, icObj_below) {
          return !this.canTouch(icObj_over, icObj_below);
        }

      }



      const DiveTouchSingleton = (function () {
        var instance;

        function createInstance(fabricIntegration) {
          var object = new DiveTouch(fabricIntegration);
          return object;
        }

        return {
          initializeInstance: function (fabricIntegration) {
            const sharedInstance = createInstance(fabricIntegration);
            instance = sharedInstance;
          },
          sharedInstance: function () {
            if (!instance) {
              // instance = createInstance();
              throw new Error("DiveTouchSingleton has not been initialized, call initializeInstance before using singleton");
            }
            return instance;
          }
        };
      })();


      class PortalCrossing { //GeometryWise Screen-wise

        constructor(infiniteCanvas, fabricIntegration) {
          this.infiniteCanvas    = infiniteCanvas;
          this.fabricIntegration = fabricIntegration;
        }

        isPovFullyContained(pov1, icObj__portal_rect_in) {
          const trueRect2__pov1 = pov1.getTrueRect2();
          const trueRect2__icObj__portal_rect_in = icObj__portal_rect_in.getTrueRect2();
          // const trueRect__icObj__portal_rect_in = icObj__portal_rect_in.getAbsoluteTrueRect2();
          logger.log("logPortal", "trueRect2__pov1:", trueRect2__pov1);
          logger.log("logPortal", "trueRect2__icObj__portal_rect_in:", trueRect2__icObj__portal_rect_in);

          const isFullyContained = Geometry.isRectFullyContainedInRect(trueRect2__pov1, trueRect2__icObj__portal_rect_in);

          //debug
          // const trueRect2__icObj__portal_rect_in__bigger = Geometry.getCenterScaledRect(Geometry.createLTRect(trueRect2__icObj__portal_rect_in), 3.0);
          // const isFullyContained = Geometry.isRectFullyContainedInRect(trueRect2__pov1, trueRect2__icObj__portal_rect_in__bigger);

          return isFullyContained;
        }

        canCross(pov1, icObj__portal_in) {
          return this.isPovFullyContained(pov1, icObj__portal_in);
        }

      }

      const PortalCrossingSingleton = (function () {
        var instance;

        function createInstance(infiniteCanvas, fabricIntegration) {
          var object = new PortalCrossing(infiniteCanvas, fabricIntegration);
          return object;
        }

        return {
          initializeInstance: function (infiniteCanvas, fabricIntegration) {
            const sharedInstance = createInstance(infiniteCanvas, fabricIntegration);
            instance = sharedInstance;
          },
          sharedInstance: function () {
            if (!instance) {
              // instance = createInstance();
              throw new Error("PortalCrossSingleton has not been initialized, call initializeInstance before using singleton");
            }
            return instance;
          }
        };
      })();





      class Curse {

        constructor(curseTrigger) {
          // logger.log("Curse::constructor", curseTrigger);

          this.curseFunc = null;

          this.curseTrigger = curseTrigger;
          this.curseTrigger.curse = this;
        }

        enact() {
          if (this.curseFunc != null) {
            this.curseFunc();
          }
        }

        start() {
          this.curseTrigger.start();
        }

        stop() {
          this.curseTrigger.stop();
        }

        reset() {

        }

      }


      class CurseTrigger_countdown {

        constructor() {
          this.curse = null;


          const curseTrigger = this;

          const countDownConfig = CountDownConfig.defaultConfig();
          countDownConfig.stepFunc = (countDownObj) => {
            // logger.log("stepFunc", countDownObj);

            if (countDownObj.index == 10) {
              curseTrigger.expulse();
            }
          };

          // const engine    = new CountDownEngine_auto(countDownConfig);
          const engine = new CountDownEngine(countDownConfig);

          this.engine = engine;
        }

        impulse() {
          if (this.engine.impulse != null) {
            this.engine.impulse();
          }
        }

        expulse() {
          this.curse.enact();
        }

        start() {
          this.engine.start();
        }

        stop() {
          this.engine.stop();
        }

      }





      class CountDownConfig {

        constructor(value_start, value_end, stepFunc, stepDuration) {
          this.value_start = value_start;
          this.value_end = value_end;

          this.stepFunc = stepFunc;
          this.stepDuration = stepDuration;
        }

        static defaultConfig() {
          var outConfig;

          const value_start = 10;
          const value_end = 0;

          const stepFunc = (stepIndex) => {
            console.log("stepFunc", stepIndex);
          };

          const stepDuration = 1000;

          outConfig = new CountDownConfig(value_start, value_end, stepFunc, stepDuration);

          return outConfig;
        }

      }




      class CountDownSequencer {

        constructor(value_from, value_to = 0) {

          // const animatedObj = {
          //   value: value_from,
          //
          //   index:    0,
          //   progress: 0,
          // };
          // this.animatedObj = animatedObj;

          const nb_values = (value_from - value_to) + 1;
          const arr_keyframes = [...new Array(nb_values).keys()].reverse().map((value, index) => {
            // logger.log("keyframe: value, index", value, index);

            const progress = (value_from - value) / (value_from - value_to);
            // logger.log("keyframe: progress", progress);


            const keyframe = {
              value: value,

              index: index,
              progress: progress,

              duration: 1,
            };

            return keyframe;
          });
          this.arr_keyframes = arr_keyframes;

          const animatedObj = Object.assign({}, arr_keyframes[0]);
          this.animatedObj = animatedObj;

          const arr_butfirst_keyframes = arr_keyframes.slice(1);
          this.arr_butfirst_keyframes = arr_butfirst_keyframes;

          const stepDuration = 1;
          this.stepDuration = stepDuration;

          const duration = (nb_values - 1) * stepDuration;
          // const duration     = nb_values * stepDuration;

          this.duration = duration;

          const countDownSequencer = this;
          const animation = anime({
            // targets: countDownEngine,
            targets: animatedObj,

            /*animated props*/
            // progress: 1,
            /*--------------*/
            // keyframes: arr_keyframes,
            keyframes: arr_butfirst_keyframes,

            direction: 'normal',
            easing: 'linear',
            duration: duration,

            autoplay: false,

            // update: (anim) => {                        //SHU: this would have been nice, but it triggers bizarrely
            //   countDownSequencer.update(animatedObj);
            // },
          });

          this.animation = animation;

          // this.debugAnimation();
        }

        debugAnimation() {
          const duration = this.duration;

          this.arr_keyframes.forEach((keyframe, i) => {

            const progress__keyframe = keyframe.progress;
            const timestamp__keyframe = progress__keyframe * duration;
            // logger.log("timestamp__keyframe", timestamp__keyframe);

            this.animation.seek(timestamp__keyframe);

            // logger.log("this.animatedObj", this.animatedObj);
          });

          this.animation.seek(0);
        }

        // moveToFirstFrame() {
        //   this.animation.seek(0);
        //   this.update(this.animatedObj);
        // }

        moveToNextFrame() {
          // logger.log("moveToNextFrame");

          const index__current = this.animatedObj.index;
          // logger.log("index__current", index__current);
          const index__next = index__current + 1;
          // logger.log("index__next", index__next);

          if (index__next < this.arr_keyframes.length) {

            const keyframe__next = this.arr_keyframes[index__next];
            // logger.log("keyframe__next", keyframe__next);


            const progress__next = keyframe__next.progress;
            const timestamp__next = progress__next * this.duration;
            // logger.log("timestamp__next", timestamp__next);

            this.animation.seek(timestamp__next);
            // logger.log("this.animation.progress", this.animation.progress);
            this.update();

          } else {
            // logger.log("can't move further");
          }

        }


        update() {
          if (this.countDownEngine != null) {
            const animatedObj = this.animatedObj;
            this.countDownEngine.update(animatedObj);
          }
        }

        // pulse() {
        //   this.moveToNextFrame();
        // }

      }


      class CountDownObj {
        constructor(value_from) {
          this.value = value_from;
          this.progress = 0;
        }
      }

      class CountDownEngine {     //SHU:    /!\ this is not an icEngined engine


        constructor(countDownConfig_in = null) {

          var countDownConfig = countDownConfig_in;
          if (countDownConfig == null) {
            countDownConfig = CountDownConfig.defaultConfig();
          }

          this.counter_start = countDownConfig.value_start;
          this.counter_end = countDownConfig.value_end;

          this.stepFunc = countDownConfig.stepFunc;
          this.stepDuration = countDownConfig.stepDuration;

          const nb_steps = math.abs(this.counter_end - this.counter_start);
          this.nb_steps = nb_steps;

          this.arr_steps = [...new Array(nb_steps).keys()];
          this.step_current = 0;

          this.counter = this.counter_start;

          this.progress = 0;

          this.isPaused = true;

          const duration = this.nb_steps * this.stepDuration;

          const countDownSequencer = new CountDownSequencer(nb_steps);
          countDownSequencer.countDownEngine = this;
          this.countDownSequencer = countDownSequencer;



          const rx_countDownCounter = new ReplaySubject(1);
          const countDownObj = countDownSequencer.animatedObj;
          rx_countDownCounter.next(countDownObj.value);
          this.rx_countDownCounter = rx_countDownCounter;


          this.start = function () {
            const countDownEngine = this;

            // countDownEngine.stepFunc(0);
            // countDownEngine.stepFunc(countDownSequencer.animatedObj);
            countDownEngine.update(countDownSequencer.animatedObj);

            countDownEngine.play();
          };
          // }.bind(this);

          this.stop = function () {
            const countDownEngine = this;

            countDownEngine.reset();
          };
          // }.bind(this);

          this.play = function () {
            const countDownEngine = this;

            const date_play = new Date();
            countDownEngine.date_play = date_play;

            countDownEngine.isPaused = false;
            // countDownEngine.animation.play();
          };
          // }.bind(this);

          this.pause = function () {
            const countDownEngine = this;

            const date_pause = new Date();
            countDownEngine.date_pause = date_pause;

            // countDownEngine.animation.pause();
            countDownEngine.isPaused = true;
          };
          // }.bind(this);

          this.reset = function () {
            const countDownEngine = this;

            // countDownEngine.animation.reset();
          };
          // }.bind(this);

          this.update = function (countDownObj) {
            // logger.log("update", countDownObj);
            const countDownEngine = this;

            countDownEngine.stepFunc(countDownObj);
            countDownEngine.rx_countDownCounter.next(countDownObj.value);
          };
          // }.bind(this);


          this.impulse = function () {
            // this.countDownSequencer.pulse();
            this.countDownSequencer.moveToNextFrame();
          };


          this.getCounter = function () {
            return this.countDownSequencer.animatedObj.value;
          };

        }

      }


      // class CountDownEngine {     //SHU:    /!\ this is not an icEngined engine
      //   constructor(countDownConfig_in = null) {
      //
      //     var countDownConfig = countDownConfig_in;
      //     if(countDownConfig == null) {
      //       countDownConfig = CountDownConfig.defaultConfig();
      //     }
      //
      //     this.counter_start = countDownConfig.value_start;
      //     this.counter_end   = countDownConfig.value_end;
      //
      //     this.stepFunc      = countDownConfig.stepFunc;
      //     this.stepDuration  = countDownConfig.stepDuration;
      //
      //     const nb_steps     = math.abs(this.counter_end - this.counter_start);
      //     this.nb_steps      = nb_steps;
      //
      //     this.arr_steps     = [...new Array(nb_steps).keys()];
      //     this.step_current  = 0;
      //
      //     this.counter = this.counter_start;
      //
      //     this.progress = 0;
      //
      //     this.isPaused = true;
      //
      //     const duration = this.nb_steps * this.stepDuration;
      //
      //     this.animatedObj = {
      //       progress: 0
      //     };
      //
      //     const countDownEngine = this;
      //     const animatedObj = this.animatedObj;
      //     const animation = anime({
      //       // targets: countDownEngine,
      //       targets: animatedObj,
      //
      //       /*animated props*/
      //       progress: 1,
      //       /*--------------*/
      //
      //       direction: 'normal',
      //       easing: 'linear',
      //       duration: duration,
      //
      //       autoplay: false,
      //
      //       update: (anim) => {
      //         const progress = anim.progress / 100;
      //         countDownEngine.progress = progress;
      //         countDownEngine.update(progress);
      //       },
      //     });
      //
      //     this.animation = animation;
      //
      //
      //
      //     this.start = function() {
      //       const countDownEngine = this;
      //
      //       countDownEngine.stepFunc(0);
      //       countDownEngine.play();
      //     };
      //     // }.bind(this);
      //
      //     this.stop = function() {
      //       const countDownEngine = this;
      //
      //       countDownEngine.reset();
      //     };
      //     // }.bind(this);
      //
      //     this.play = function() {
      //       const countDownEngine = this;
      //
      //       const date_play           = new Date();
      //       countDownEngine.date_play = date_play;
      //
      //       countDownEngine.isPaused = false;
      //       countDownEngine.animation.play();
      //     };
      //     // }.bind(this);
      //
      //     this.pause = function() {
      //       const countDownEngine = this;
      //
      //       const date_pause           = new Date();
      //       countDownEngine.date_pause = date_pause;
      //
      //       countDownEngine.animation.pause();
      //       countDownEngine.isPaused = true;
      //     };
      //     // }.bind(this);
      //
      //     this.reset = function() {
      //       const countDownEngine = this;
      //
      //       countDownEngine.animation.reset();
      //     };
      //     // }.bind(this);
      //
      //     this.update = function(progress) {
      //       console.log("update", progress);
      //       const countDownEngine = this;
      //
      //       const cursor      = progress * countDownEngine.nb_steps;
      //       const step_cursor = math.floor(cursor);
      //
      //       const isStepChanged = (step_cursor - countDownEngine.step_current) >= 1;
      //       if(isStepChanged) {
      //         countDownEngine.step_current = step_cursor;
      //         countDownEngine.stepFunc(step_cursor);
      //       }
      //     };
      //     // }.bind(this);
      //
      //   }
      //
      // }




      class RxSubjectEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }





          this.next = function (value) {

            const engineCarrier = this.scopeObj.engineCarrier;
            engineCarrier.value = value;

            this.rxSubject.next(value);
          };

          this.getRxSubject = function () {
            return this.rxSubject;
          };



          this.start = function () {
            console.log("RxSubjectEngine::start, this", this);
            console.log("RxSubjectEngine::start", "this.scopeObj", this.scopeObj);

            const engineCarrier = this.scopeObj.engineCarrier;
            const value = engineCarrier.value;

            const replaySubject = new Rx.ReplaySubject(1);
            replaySubject.next(value);

            this.rxSubject = replaySubject;
          };

          this.stop = function () {

            this.rxSubject.complete();
          };



          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }

      class RxSubscriptionEngine {




      }


      class FacetEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }


          this.react = function (nextObj) {

            const engineCarrier = this.scopeObj.engineCarrier;

            const reactFunc = engineCarrier.reactFunc;

            const result = reactFunc(engineCarrier, nextObj);

            return result;
          };


          this.start = function () {
            console.log("FacetEngine::start, this", this);
            console.log("FacetEngine::start", "this.scopeObj", this.scopeObj);

            const engineCarrier = this.scopeObj.engineCarrier;
            // const core          = engineCarrier.core;

            const rxObservable = engineCarrier.rxObservable;

            this.rxsub = rxObservable.subscribe({
              next: (obj) => {
                this.react(obj);
              },
            });

          };

          this.stop = function () {
            this.rxsub.unsubscribe();
          };



          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }











      class Observe {

      }

      class ObserverEngine {

        constructor() {

        }

        start() {

        }

        stop() {

        }

        observe(icObj_incoming) { //this function is to be hooked

        }

        static defaultInstance(infiniteCanvas, icObserver) {
          var outEngine;

          const observerEngine = new ObserverEngine();
          Hooker.installHooks(observerEngine, "observe");


          const r_official_update_handler = (observer, icObj_incoming, outerUpdatesDict) => {
            console.log("observerEngine::r_official_update_handler", icObj_incoming);

            observerEngine.observe(icObj_incoming);
          };
          observerEngine.r_official_update_handler = r_official_update_handler;

          const r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
            console.log("observerEngine::r_official_update_handler2", rep_official_incoming);

            const represented = infiniteCanvas.getRepresented(icObserver.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const observer = rep_official;
            const incomingObj = rep_official_incoming;
            // console.log("incomingObj.id", incomingObj.id);

            if (incomingObj != observer) { //don't observe oneself

              console.log("observer.observerConfig.observed", observer.observerConfig.observed);
              const isObserved = observer.observerConfig.observed[incomingObj.id];

              if (!isObserved) {
                //ignore: incomingObj is not observed
              } else {
                observerEngine.r_official_update_handler(observer, incomingObj, outerUpdatesDict);
              }

            } else {
              console.log("I won't observe myself");
            }

          };
          observerEngine.r_official_update_handler2 = r_official_update_handler2;

          outEngine = observerEngine;

          return outEngine;
        }

      }




      class FuturingEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function (scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
              .filter(([propName, prop]) => isFunction(prop))
              .forEach(([propName, prop], i) => {
                this.awoken[propName] = prop.bind(this.awoken);
              });

            // this.scopeObj  = scopeObj;
            //engineCarrier,
            //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }





          this.add = function (transformation) {

          };

          this.abort_current = function () {

          };

          this.abort_all = function () {

          };



          this.start = function () {
            console.log("RxSubjectEngine::start, this", this);
            console.log("RxSubjectEngine::start", "this.scopeObj", this.scopeObj);

            const engineCarrier = this.scopeObj.engineCarrier;

            this.speed = 1.0;

          };

          this.stop = function () {


          };



          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }









      //I/O

      class FileIntegration {

        constructor(clipboardIntegration) {
          this.clipboardIntegration = clipboardIntegration;

          document.onpaste = function (event) {
            logger.log("onpaste", "event", event);

            clipboardIntegration.rx_outerPaste.next(event);
          };

          // document.onpaste = function() {};
        }

        static openFileDialog(accept, callback) {

          // Create an input element
          var inputElement = document.createElement("input");

          // Set its type to file
          inputElement.type = "file";

          // Set accept to the file types you want the user to select.
          // Include both the file extension and the mime type
          inputElement.accept = accept;

          // set onchange event to call callback when user has selected file
          inputElement.addEventListener("change", callback)

          // dispatch a click event to open the file dialog
          inputElement.dispatchEvent(new MouseEvent("click"));

        }

        static getFileExtension(filename) {
          const arr_comp = filename.split(".");
          return arr_comp[arr_comp.length - 1];
        }

        static openFile_p(accept) {

          return new Promise((resolve, reject) => {

            FileIntegration.openFileDialog(accept, event => {
              const fileList = event.target.files;
              logger.log("logFI", "fileList:", fileList);

              const file_in = fileList[0];
              logger.log("logFI", "openFile_p", "file_in:", file_in);

              const str__extension = this.getFileExtension(file_in.name);
              
              var file;
              switch(str__extension) {
                case "shu":
                  {
                    file = this.createFile__infinishute__from_zipped_p(file_in);
                  }
                  break;
                case "json":
                  {
                    file = file_in;
                  }
                  break;
                case "mp4":
                case "avi":
                case "mkv":
                  {
                    file = file_in;
                  }
                  break;
                case "mp3":
                case "wav":
                case "ogg":
                  {
                    file = file_in;
                  }
                  break;
                default:
                {
                  throw new Error("unsupported file extension: " + str__extension + ", file: " + file);
                }
                break;
              }

              resolve(file);
            });
          });

        }

        static createFile__infinishute__from_zipped_p(file__zipped) {
          return new Promise((resolve, reject) => {

            const jsZip = new JSZip();
            jsZip.loadAsync(file__zipped).then(function(contents) {
              logger.log("jsZip.loadAsync", "contents:", contents);

              const files = contents.files;
              
              const filename__infinishute_json = "infinishute.json";
              
              const jsZipFile__infinishute_json = files[filename__infinishute_json];
              logger.log("openFile__zipped", "jsZipFile__infinishute_json:", jsZipFile__infinishute_json);
              
              jsZipFile__infinishute_json.async('text').then((str__infinishute__json) => {
                logger.log("openFile__zipped", "str__infinishute__json:", str__infinishute__json);

                const blob__infinishute_json = new Blob([str__infinishute__json], {type: "plain/text"});
                const file__infinishute_json = new File([blob__infinishute_json], "infinishute.json");
                resolve(file__infinishute_json);
              });      

            });

          });
        }


        static openFolderDialog(accept, callback) {

          // Create an input element
          var inputElement = document.createElement("input");

          // Set its type to folder
          inputElement.type = "file";

          inputElement.setAttribute("webkitdirectory", "");
          inputElement.setAttribute("mozdirectory", "");
          inputElement.setAttribute("directory", "");

          // Set accept to the file types you want the user to select.
          // Include both the file extension and the mime type
          inputElement.accept = accept;

          // set onchange event to call callback when user has selected file
          inputElement.addEventListener("change", callback)

          // dispatch a click event to open the file dialog
          inputElement.dispatchEvent(new MouseEvent("click"));

        }

        static openFolder_p(accept) {

          return new Promise((resolve, reject) => {

            FileIntegration.openFolderDialog(accept, event => {
              // logger.log("log1", "openFolder_p", "event", event);
              const fileList = event.target.files;
              // logger.log("log1", "fileList", fileList);

              const arr_file = Array.from(fileList);
              resolve(arr_file);
            });
          });

        }

        static openMultipleDialog(accept, callback) {

          // Create an input element
          var inputElement = document.createElement("input");

          // Set its type to folder
          inputElement.type = "file";

          inputElement.setAttribute("multiple", "");

          // Set accept to the file types you want the user to select.
          // Include both the file extension and the mime type
          inputElement.accept = accept;

          // set onchange event to call callback when user has selected file
          inputElement.addEventListener("change", callback)

          // dispatch a click event to open the file dialog
          inputElement.dispatchEvent(new MouseEvent("click"));

        }

        static openMultiple_p(accept) {

          return new Promise((resolve, reject) => {

            FileIntegration.openMultipleDialog(accept, event => {
              // logger.log("log1", "openMultiple_p", "event", event);
              const fileList = event.target.files;
              // logger.log("log1", "fileList", fileList);

              const arr_file = Array.from(fileList);
              resolve(arr_file);
            });
          });

        }

        static fileForImg(img) {
          let dataUrl = img.src.split(',');
          let base64 = dataUrl[1];
          let mime = dataUrl[0].match(/:(.*?);/)[1];
          let bin = atob(base64);
          let length = bin.length;
          // From http://stackoverflow.com/questions/14967647/ (continues on next line)
          // encode-decode-image-with-base64-breaks-image (2013-04-21)
          let buf = new ArrayBuffer(length);
          let arr = new Uint8Array(buf);
          bin
            .split('')
            .forEach((e, i) => arr[i] = e.charCodeAt(0));

          let file = new File([buf], 'filename', { type: mime }); // note: [buf]
          return file;
        }


        // static addImageFromFile_p(file) {
        //
        //   function addZimageForImg(img) {
        //     //console.log("img", img);
        //
        //     // const zimage = createZimageWithCurrentBoundingRect(img);
        //
        //     const canvasBoundingTrueRect = getCanvasBoundingTrueRect();
        //
        //     // object-fit : contain
        //     const img_size = {
        //       width: img.width,
        //       height: img.height
        //     };
        //     const trueRect = containedRect(canvasBoundingTrueRect, img_size);
        //
        //     const zimage = createZimage(img, trueRect);
        //
        //     addZimage(zimage);
        //
        //     redrawCanvas();
        //   }
        //
        //   function addFabricImageForImg(img) {
        //     //console.log("img", img);
        //
        //     // const zimage = createZimageWithCurrentBoundingRect(img);
        //
        //     const canvasBoundingTrueRect = getCanvasBoundingTrueRect();
        //
        //     // object-fit : contain
        //     const img_size = {
        //       width: img.width,
        //       height: img.height
        //     };
        //     const trueRect = containedRect(canvasBoundingTrueRect, img_size);
        //
        //     const fabricImage = createFabricImage(img, trueRect);
        //     addFabricObject(fabricImage);
        //
        //     redrawCanvas();
        //   }
        //
        //   return createImage_p(file)
        //         .then(img => {
        //           // addZimageForImg(img);
        //           addFabricImageForImg(img);
        //         });
        //
        // }

        static dataToBlob_p(data) {
          return fetch(data)
            .then(res => res.blob());
        }


        //IMPORT text

        static accept_text() {
          const accept = ".txt, .rtf";
          return accept;
        }

        static importText_p() {
          const accept = FileIntegration.accept_text();
          return FileIntegration.openFile_p(accept)
            .then(FileIntegration.createText_p);
        }

        static importText_folder_p() {
          const accept = FileIntegration.accept_text();
          return FileIntegration.openFolder_p(accept)
            .then(arr_file => {
              return Promise.all(arr_file.map(FileIntegration.createText_p));
            });
        }

        static importText_multiple_p() {
          const accept = FileIntegration.accept_text();
          return FileIntegration.openMultiple_p(accept)
            .then(arr_file => {
              return Promise.all(arr_file.map(FileIntegration.createText_p));
            });
        }

        static createText_p(file) {
          return FileIntegration.getFileData_p(file)
            .then(FileIntegration.dataToTextSrc_p)
            .then(FileIntegration.textFromTextSrc_p);
        }

        static textFromTextSrc_p(textSrc) {
          logger.log('textSrc', textSrc);

          // return new Promise(r => img.onload=r, img.src=imgSrc)
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = (error) => reject(error);

            // img.crossOrigin = 'Anonymous';

            img.src = imgSrc;
          });
        }

        static dataToImgSrc_p(data) {
          var imgSrc_p;

          if (data.startsWith("data:image")) {
            imgSrc_p = Promise.resolve(data);
          } else {
            imgSrc_p = FileIntegration.dataToBlob_p(data)
              .then(blob1 => {
                //change blob type
                const blob2 = new Blob([blob1], { type: 'image/png' })
                return blob2;
              })
              .then(FileIntegration.getFileData_p);
            // .then(blob2 => {
            //   const imgSrc = URL.createObjectURL(blob2);
            //   ////console.log("converted imgSrc:", imgSrc);
            //   //>>converted imgSrc: blob:http://localhost:8080/7243f1de-493f-412b-b1ec-b042b0cbcac4
            //   return imgSrc;
            // });
          }

          return imgSrc_p;
        }

        static imageContentsToBlob_p(img) {
          return this.dataToBlob_p(img.src);
        }


        //IMPORT image

        static accept_image() {
          const accept = ".jpg, .jpeg, .png";
          return accept;
        }

        static importImage_p() {
          const accept = FileIntegration.accept_image();
          return FileIntegration.openFile_p(accept)
            .then(FileIntegration.createImage_p);
        }

        static importImage_folder_p() {
          const accept = FileIntegration.accept_image();
          return FileIntegration.openFolder_p(accept)
            .then(arr_file => {
              return Promise.all(arr_file.map(FileIntegration.createImage_p));
            });
        }

        static importImage_multiple_p() {
          const accept = FileIntegration.accept_image();
          return FileIntegration.openMultiple_p(accept)
            .then(arr_file => {
              return Promise.all(arr_file.map(FileIntegration.createImage_p));
            });
        }

        static createImage_p(file) {
          return FileIntegration.getFileData_p(file)
            .then(FileIntegration.dataToImgSrc_p)
            .then(FileIntegration.imageFromImgSrc_p);
        }

        static imageFromImgSrc_p(imgSrc) {
          logger.log('imgSrc', imgSrc);

          // return new Promise(r => img.onload=r, img.src=imgSrc)
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = (error) => reject(error);

            // img.crossOrigin = 'Anonymous';

            img.src = imgSrc;
          });
        }

        static dataToImgSrc_p(data) {
          var imgSrc_p;

          if (data.startsWith("data:image")) {
            imgSrc_p = Promise.resolve(data);
          } else {
            imgSrc_p = FileIntegration.dataToBlob_p(data)
              .then(blob1 => {
                //change blob type
                const blob2 = new Blob([blob1], { type: 'image/png' })
                return blob2;
              })
              .then(FileIntegration.getFileData_p);
            // .then(blob2 => {
            //   const imgSrc = URL.createObjectURL(blob2);
            //   ////console.log("converted imgSrc:", imgSrc);
            //   //>>converted imgSrc: blob:http://localhost:8080/7243f1de-493f-412b-b1ec-b042b0cbcac4
            //   return imgSrc;
            // });
          }

          return imgSrc_p;
        }

        static imageContentsToBlob_p(img) {
          return this.dataToBlob_p(img.src);
        }


        //IMPORT video

        static accept_video() {
          const accept = ".mp4, .mkv, .avi";
          return accept;
        }

        static importVideo_p() {
          const accept = FileIntegration.accept_video();
          return FileIntegration.openFile_p(accept)
            .then(FileIntegration.createVideo_p);
        }

        static createVideo_p(file) {
          return FileIntegration.getFileData_p(file)
            .then(FileIntegration.dataToVidSrc_p)
            .then(FileIntegration.videoFromVidSrc_p);
        }

        static videoFromVidSrc_p(vidSrc) {
          logger.log('vidSrc', vidSrc);

          return new Promise((resolve, reject) => {
            const video = document.createElement("video");
            // video.onload  =      () => resolve(video);
            // video.onerror = (error) => reject(error);

            // img.crossOrigin = 'Anonymous';

            video.src = vidSrc;

            /// setup with auto preload and loop
            video.preload = 'auto';
            video.loop = true;

            // video.addEventListener('canplay', start, false);

            resolve(video);
          });

        }

        static videoFromWebcam_p() {

          function webcamStream_p() {
            return navigator.mediaDevices
              .getUserMedia({
                video: {
                  facingMode: "user"
                },
                audio: false
              })
              .catch((error) => {
                logger.log("webcamStream_p, error", error);
              })
          }

          const video_p = webcamStream_p()
            .then(function (stream) {
              // track = stream.getTracks()[0];
              // logger.log("log1", "stream", stream);

              const webcamEl = document.createElement('video');

              webcamEl.style.width = "100px";
              webcamEl.style.height = "100px";
              webcamEl.style.display = "none";
              // logger.log("log1", "webcamEl", webcamEl);

              webcamEl.srcObject = stream;

              return webcamEl;
            });

          return video_p;

        }

        videoFromStreamURL_p(streamURL) {
          return null;
        }

        static dataToVidSrc_p(data) {
          var vidSrc_p;

          if (data.startsWith("data:video")) {
            vidSrc_p = Promise.resolve(data);
          } else {
            vidSrc_p = FileIntegration.dataToBlob_p(data)
              .then(blob1 => {
                //change blob type
                const blob2 = new Blob([blob1], { type: 'video/mp4' })
                return blob2;
              })
              .then(FileIntegration.getFileData_p);
          }

          return vidSrc_p;
        }


        //IMPORT audio

        static accept_audio() {
          const accept = ".mp3, .wav, .ogg";
          return accept;
        }

        static importAudio_p() {
          const accept = FileIntegration.accept_audio();
          return FileIntegration.openFile_p(accept)
            .then(FileIntegration.createAudio_p);
        }

        static createAudio_p(file) {
          return FileIntegration.getFileData_p(file)
            .then(FileIntegration.dataToAudioSrc_p)
            .then(FileIntegration.audioFromAudioSrc_p);
        }

        static audioFromAudioSrc_p(audioSrc) {
          logger.log("logFI", 'audioFromAudioSrc_p', audioSrc);

          return new Promise((resolve, reject) => {
            const audio = document.createElement("audio");
            // audio.onload  =      () => resolve(audio);
            // audio.onerror = (error) => reject(error);

            // img.crossOrigin = 'Anonymous';

            audio.src = audioSrc;

            /// setup with auto preload and loop
            audio.preload = 'auto';
            audio.loop    = true;

            // audio.addEventListener('canplay', start, false);

            resolve(audio);
          });

        }

        static dataToAudioSrc_p(data) {
          var audioSrc_p;

          if (data.startsWith("data:audio")) {
            audioSrc_p = Promise.resolve(data);
          } else {
            audioSrc_p = FileIntegration.dataToBlob_p(data)
              .then(blob1 => {
                //change blob type
                const blob2 = new Blob([blob1], { type: 'audio/mpeg' })
                return blob2;
              })
              .then(FileIntegration.getFileData_p);
          }

          return audioSrc_p;
        }



        //IMPORT htmlobject (pdf,...)

        static accept_htmlObject() {
          const accept = ".pdf, .html";
          return accept;
        }

        static importHtmlObject_p() {
          const accept = FileIntegration.accept_htmlObject();
          return FileIntegration.openFile_p(accept)
            .then(FileIntegration.createHtmlObject_p);
        }

        static importHtmlObject_folder_p() {
          const accept = FileIntegration.accept_htmlObject();
          return FileIntegration.openFolder_p(accept)
            .then(arr_file => {
              return Promise.all(arr_file.map(FileIntegration.createHtmlObject_p));
            });
        }

        static importHtmlObject_multiple_p() {
          const accept = FileIntegration.accept_htmlObject();
          return FileIntegration.openMultiple_p(accept)
            .then(arr_file => {
              return Promise.all(arr_file.map(FileIntegration.createHtmlObject_p));
            });
        }

        static createHtmlObject_p(file) {
          return FileIntegration.getFileData_p(file)
            .then(FileIntegration.dataToHtmlObjectSrc_p)
            .then(FileIntegration.htmlObjectFromHtmlObjectSrc_p);
        }

        static htmlObjectFromHtmlObjectSrc_p(htmlObjectSrc) {
          logger.log("logHTML", 'htmlObjectSrc', htmlObjectSrc);

          let loadingTask = PDFJS.getDocument(htmlObjectSrc);
          // let loadingTask = PDFJS.getDocument({
          //   htmlObjectSrc, 
          //   // Try to export JPEG images directly if they don't need any further
          //   // processing.
          //   nativeImageDecoderSupport: PDFJS.NativeImageDecoding.DISPLAY,
          // });

          // loadingTask.onProgress = function(progressData) {
          //   this.progress(progressData.loaded / progressData.total)
          // };

          return loadingTask.promise.then(function (pdf) {
            logger.log("logPDF", "pdf:", pdf);

            function getPage_p(index) {

              pdf.getPage(1).then(function getPageHelloWorld(page) {
              logger.log("logPDF", "page:", page);

              var scale    = 4.0;
              // var viewport = page.getViewport({scale: scale});
              var viewport = page.getViewport({scale: scale});
              // logger.log("logPDF", "viewport:", viewport);

              //
              // Prepare canvas using PDF page dimensions
              //
              var el_canvas    = document.createElement("canvas");
              el_canvas.height = viewport.height;
              el_canvas.width  = viewport.width;

              //
              // Render PDF page into canvas context
              //
              // 
              var context   = el_canvas.getContext('2d');

              let renderTask = page.render({
                canvasContext: context, 
                viewport: viewport,
              });

              // Wait for rendering to finish
              return renderTask.promise.then(function() {
                  //debug
                  // const dataURL = el_canvas.toDataURL();
                  // FileIntegration.save_image(dataURL);

                  return el_canvas;
              });
              
            });

            }

            return Promise.all( )
            
            

          });

        }

        static dataToHtmlObjectSrc_p(data) {
          var htmlobjectSrc_p;

          // if (data.startsWith("data:image")) {
          //   htmlobjectSrc_p = Promise.resolve(data);
          // } else {
            htmlobjectSrc_p = FileIntegration.dataToBlob_p(data)
              .then(blob1 => {
                //change blob type
                const blob2 = new Blob([blob1], { type: 'application/pdf' })
                return blob2;
              })
              .then(FileIntegration.getFileData_p);
            // .then(blob2 => {
            //   const htmlobjectSrc = URL.createObjectURL(blob2);
            //   ////console.log("converted htmlobjectSrc:", htmlobjectSrc);
            //   //>>converted htmlobjectSrc: blob:http://localhost:8080/7243f1de-493f-412b-b1ec-b042b0cbcac4
            //   return htmlobjectSrc;
            // });
          // }

          return htmlobjectSrc_p;
        }

        static imageContentsToBlob_p(htmlobject) {
          return this.dataToBlob_p(htmlobject.src);
        }


        //IMPORT pdf

        static accept_pdf() {
          const accept = ".pdf";
          return accept;
        }

        static importPDF_p() {
          const accept = FileIntegration.accept_pdf();
          return FileIntegration.openFile_p(accept)
            .then(FileIntegration.createDictPDF_p);
        }

        static importPDF_folder_p() {
          const accept = FileIntegration.accept_pdf();
          return FileIntegration.openFolder_p(accept)
            .then(arr_file => {
              return Promise.all(arr_file.map(FileIntegration.createDictPDF_p));
            });
        }

        static importPDF_multiple_p() {
          const accept = FileIntegration.accept_pdf();
          return FileIntegration.openMultiple_p(accept)
            .then(arr_file => {
              // return Promise.all(arr_file.map(FileIntegration.createDictPDF_p));
              return Promise.all(arr_file.map(FileIntegration.createDictPDF_a_p));
            });
        }

        static createDictPDF_p(file) {
          return FileIntegration.getFileData_p(file)
            .then(FileIntegration.dataToPDFSrc_p)
            .then(FileIntegration.dictPDFFromPDFSrc_p);
        }

        static createDictPDF_a_p(file) {
          return FileIntegration.getFileData_p(file)
            .then(FileIntegration.dataToPDFSrc_p)
            .then(FileIntegration.dictPDFFromPDFSrc_p);
        }

        static dictPDFFromPDFSrc_p(pdfSrc) {
          logger.log("logPDF", 'pdfSrc:', pdfSrc);
          var out_p;

          let loadingTask = PDFJS.getDocument(pdfSrc);
          // let loadingTask = PDFJS.getDocument({
          //   htmlObjectSrc, 
          //   // Try to export JPEG images directly if they don't need any further
          //   // processing.
          //   nativeImageDecoderSupport: PDFJS.NativeImageDecoding.DISPLAY,
          // });

          // loadingTask.onProgress = function(progressData) {
          //   this.progress(progressData.loaded / progressData.total)
          // };

          out_p = loadingTask.promise.then(function (pdf) {
            logger.log("logPDF", "pdf:", pdf);

            // const arr_dict_page_p = [...Array(pdf.numPages).keys()].map(getPage_p);
            const dict_pdf = {
              pdf: pdf,
              // arr_dict_page_p: arr_dict_page_p,
            };

            return dict_pdf;

          });

          return out_p;
        }

        static dataToPDFSrc_p(data) {
          var pdfSrc_p;

          pdfSrc_p = FileIntegration.dataToBlob_p(data)
            .then(blob1 => {
              //change blob type
              const blob2 = new Blob([blob1], { type: 'application/pdf' })
              return blob2;
            })
            .then(FileIntegration.getFileData_p);

          return pdfSrc_p;
        }


        //file utils

        static base64_for_dataUrl(dataUrl) {
          // logger.log("base64_for_dataUrl", dataUrl);
          const idx = dataUrl.indexOf('base64,') + 'base64,'.length;
          const content = dataUrl.substring(idx);
          return content;
        }

        static getFileData_p(file) {
          ////console.log("getFileData_p", file);

          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function (evt) {
              const file_url = evt.target.result; //<=> var file_url = reader.result;
              ////console.log("file_url:", file_url);
              resolve(file_url);
            };
            reader.readAsDataURL(file);
          });

        }

        static getFileText_p(file) {
          logger.log("logFI", "getFileText_p", file);

          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function (evt) {
              const file_url = evt.target.result; //<=> var file_url = reader.result;
              ////console.log("file_url:", file_url);
              resolve(file_url);
            };
            reader.readAsText(file);
          });

        }

        // static getFile_p(filepath) {
        //   ////console.log("getFileText_p", file);
        //
        //   return FileIntegration.getFileData_p(filepath)
        //   .then((dataURL) => {
        //
        //   });
        //
        // }


        // static getFileImage_p(filename) {
        //   const file_url = "/img/" + filename;
        //   return fetch(file_url)
        //         .then(FileIntegration.createImage_p);
        // }


        //folder utils

        // static importFolder_p() {
        //   return FileIntegration.openFolder_p(accept);
        // }







        //PASTE image


        static getPastedFile_p(event) {
          var outPromise;

          var items = (event.clipboardData || event.originalEvent.clipboardData).items;
          //console.log(JSON.stringify(items)); // will give you the mime types

          const arr_files = Object.values(items)
            .filter(item => item.kind == 'file')
            .map(item => item.getAsFile());

          if (arr_files.length == 1) {
            const file = arr_files.find(e => true);
            outPromise = Promise.resolve(file);
          } else {
            const error = new Error("arr_files.length != 1");
            outPromise = Promise.reject(error);
          }

          return outPromise;
        }





        //SAVE / LOAD

        static save_to_file(obj) {
          logger.log("logSer", "save_to_file", obj);

          const json = JSON.stringify(obj);

          const filename = "infinishute.json";
          FileIntegration.download(json, filename, 'text/json');
        }

        static download(content, fileName, contentType) {
          var a = document.createElement("a");
          var file = new Blob([content], { type: contentType });
          a.href = URL.createObjectURL(file);
          a.download = fileName;
          a.click();
        }


        static save_to_file__zipped(obj) {
          logger.log("logSer", "save_to_file__zipped", obj);

          const json = JSON.stringify(obj);

          const jsZip = new JSZip();

          const filename = "infinishute.json";    //SHU:main json
          jsZip.file(filename, json);

            //SHU: using a zip file could allow putting images in ./res/img, videos in ./res/vid, etc. 
          // var folder__res = jsZip.folder("res");
            // var folder__img = jsZip.folder("res/img");
          // folder__img.file("card.png", base64__card, { base64: true });

          jsZip.generateAsync({ type: "blob", compression: "DEFLATE"})
            .then(function (content) {
              // see FileSaver.js
              saveAs(content, "infinishute.shu");
            });
        }




        static save_image(dataURL, imageName = "image") {
          const filename = "image.png";

          var a = document.createElement("a");
          a.href = dataURL;
          a.download = imageName;
          a.click();
        }


        // static objByConvertingImagesToBase64_p(obj) {
        //
        //   const zimages_raw = obj.zimages;
        //
        //   const arr__zimages_serial_p = zimages_raw.map(zimage => {
        //
        //     //console.log("zimage", zimage);
        //     const imgSrc_base64_p = FileIntegration.dataUrlForImgViaCanvas_p(zimage.img);
        //
        //     return imgSrc_base64_p
        //            .then(imgSrc_base64 => {
        //
        //              const zimage_serial = {
        //                imgSrc_base64:  imgSrc_base64,
        //                trueRect:       zimage.trueRect,
        //              };
        //
        //              return zimage_serial;
        //            });
        //
        //   });
        //
        //   return Promise.all(arr__zimages_serial_p)
        //          .then(arr__zimages_serial => {
        //
        //            const obj2 = {};
        //
        //            obj2.zimages  = arr__zimages_serial;
        //            obj2.drawings = obj.drawings;
        //
        //            return obj2;
        //          });
        // }

        static objByConvertingImagesToBase64_p(obj) {

          const zimages_raw = obj.zimages;

          const arr__zimages_serial_p = zimages_raw.map(zimage => {

            //console.log("zimage", zimage);
            const imgSrc_base64_p = FileIntegration.dataUrlForImgViaCanvas_p(zimage.img);

            return imgSrc_base64_p
              .then(imgSrc_base64 => {

                const zimage_serial = {
                  imgSrc_base64: imgSrc_base64,
                  trueRect: zimage.trueRect,
                };

                return zimage_serial;
              });

          });

          return Promise.all(arr__zimages_serial_p)
            .then(arr__zimages_serial => {

              const obj2 = {};

              obj2.zimages = arr__zimages_serial;
              obj2.drawings = obj.drawings;

              return obj2;
            });
        }



        static saveInfinishute_p(infiniShute) {

          // const obj = {
          //   // zimages  : zimages,
          //   // drawings : drawings,
          //
          //   infiniteCanvas: infiniteCanvas,
          // };
          // //console.log("obj", obj);
          //
          // FileIntegration.objByConvertingImagesToBase64_p(obj)
          // .then(obj2 => {
          //   //console.log("obj2", obj2);
          //   FileIntegration.save_to_file(obj2);
          // });


          // FileIntegration.save_to_file(infiniShute);
          FileIntegration.save_to_file__zipped(infiniShute);

          //?
          return Promise.resolve(true);
        }

        static loadInfinishute_p() {
          // const accept = ".json";
          // const accept = ".shu";
          const accept = ".json,.shu";

          // return FileIntegration.openFile_p(accept)
          // return FileIntegration.openFile__zipped_p(accept)
          // .then(FileIntegration.createJson_p);

          return FileIntegration.openFile_p(accept)
            .then(FileIntegration.createJson_p);
        }

        static createJson_p(file) {
          return FileIntegration.getFileText_p(file)
            .then(text => {
              //console.log("text:", text);

              const json = JSON.parse(text);
              //console.log("json:", json);
              return json;
            });

        }

        // static createInfinishute_p(json) {
        //   const infinishute = {};
        //
        //   infinishute.drawings = json.drawings;
        //
        //   const zimages_serial = json.zimages;
        //   const arr__zimage_p = zimages_serial.map(zimage_serial => {
        //
        //     const imgSrc = zimage_serial.imgSrc_base64;
        //     return FileIntegration.imageFromImgSrc_p(imgSrc)
        //            .then(image => {
        //              const zimage = {
        //                img: image,
        //                trueRect: zimage_serial.trueRect,
        //              };
        //
        //              return zimage;
        //            });
        //   })
        //
        //   return Promise.all(arr__zimage_p)
        //                 .then(zimages => {
        //                   infinishute.zimages = zimages;
        //
        //                   return infinishute;
        //                 });
        //
        // }

        // static createInfinishute_p(json) {
        //   const infinishute = {};
        //
        //   return json;
        // }


        static dataUrlForImgViaCanvas_p(img) {

          const src = img.src;

          const outputFormat = "image/png";

          return new Promise((resolve, reject) => {
            var imgAux = new Image();

            imgAux.crossOrigin = 'Anonymous';
            imgAux.onload = function () {
              var canvasAux = document.createElement('CANVAS');
              var ctxAux = canvasAux.getContext('2d');
              var dataURL;
              canvasAux.height = this.naturalHeight;
              canvasAux.width = this.naturalWidth;
              ctxAux.drawImage(this, 0, 0);
              dataURL = canvasAux.toDataURL(outputFormat);
              resolve(dataURL);
            };
            imgAux.onerror = (error) => reject(error);

            imgAux.src = src;
          })
            .catch((e) => {
              logger.log("dataUrlForImgViaCanvas_p", e);
            });

        }

        static dataURLForRect(fObjOrfCanvas, rect__print) {
          logger.log("dataURLForRect", fObjOrfCanvas, rect__print);
          var outDataURL;

          const printOptions = Object.assign({}, rect__print);
          outDataURL = fObjOrfCanvas.toDataURL(printOptions);

          return outDataURL;
        }

        static dataUrlForImgViaCanvas2_p(img) {   //SHU: tried to create workaround for local files but "Tainted canvases may not be exported"
          var out_p;

          function createFObj_p(img) {
            const fObj = new fabric.Image(img);
            return Promise.resolve(fObj);
          }

          out_p = createFObj_p(img)
            .then((fObj) => {
              //prepare canvas
              fabricCanvas__tool.add(fObj);
              fabricCanvas__tool.renderAll();

              return fabricCanvas__tool;
            }).then((fCanvas) => {

              const width = img.width;
              const height = img.height;

              const rect__print = {
                left: 0,
                top: 0,
                width: width,
                height: height,
              };

              const dataURL = FileIntegration.dataURLForRect(fCanvas, rect__print);

              return dataURL;
            });

          return out_p;
        }



      }




      //Clipboard mgmt

      class ClipboardObject {
        constructor(source, content) {
          this.source = source;
          this.content = content;
        }
      }

      class InnerCopyEvent {
        constructor(clipboardObject) {
          this.timestamp = Date.now();
          this.clipboardObject = clipboardObject;
        }
      }

      class ClipboardIntegration {

        constructor(arr_sources) {
          // this.arr_sources = arr_sources;
          const rx_innerCopy = new ReplaySubject(1);
          this.rx_innerCopy  = rx_innerCopy;

          // this.arr_paste_p = arr_sources.map(source => source.paste_p);
          const rx_outerPaste = new Subject();
          this.rx_outerPaste = rx_outerPaste;

          const timestamp__start = Date.now();

          const clipboardIntegration = this;
          // const rx_mixedPaste = Rx.combineLatest(rx_outerPaste, rx_innerCopy)
          const rx_mixedPaste = rx_outerPaste.pipe(Rx_operators.withLatestFrom(rx_innerCopy))
            // .pipe(Rx_operators.map(([clipboardEvent, innerCopyEvent]) => {
            // var outVal;
            .pipe(Rx_operators.mergeMap(([outerPasteEvent, innerCopyEvent]) => {

              var out_p;
              var outObservable;

              console.log("rx_mixedPaste");
              logger.log("logCP", "outerPasteEvent:", outerPasteEvent);
              console.log("innerCopyEvent",  innerCopyEvent);

              const timestamp_outerPaste = outerPasteEvent.timeStamp;
              const timestamp_innerCopy  = innerCopyEvent.timestamp - timestamp__start;

              logger.log("timestamp_outerPaste", timestamp_outerPaste);
              logger.log("timestamp_innerCopy",  timestamp_innerCopy);

              // const isInnerMostRecent = timestamp_inner > timestamp_outer;

              //SHU: ok, so i am not able to get "outerCopyEvent.timestamp"
              //so i'll do a workaround
              const isInnerMostRecent = timestamp_outerPaste - timestamp_innerCopy < 5000;       //SHU: you have 5 seconds to inner paste after inner copying
              logger.log("isInnerMostRecent", isInnerMostRecent);

              if (isInnerMostRecent) {
                const icObj__cloned = innerCopyEvent.clipboardObject.content;

                //clone newly created, shift its id(s), and copy it 
                //{
                const icObj__recloned = icObj__cloned.deepClone();
                icObj__recloned.position.x += 10;
                icObj__recloned.position.y += 10;

                //shift id(s)
                if(icObj__recloned.type == "composite") { 
                  CompositeUtils.shiftToNextAvailableId(icObj__recloned, icObj__cloned, infiniteCanvas);
                } else {
                  icObj__recloned.id = infiniteCanvas.generateIcObjectId(); 
                }

                clipboardIntegration.manageInnerCopy("fabric.general", icObj__recloned);
                //}

                out_p = Promise.resolve(icObj__cloned);

              } else {
                out_p = clipboardIntegration.outerToInner_p(outerPasteEvent);

                //inner to ic
                // const infiniteCanvas = this.infiniteCanvas;

                out_p = out_p.then(content => {
                  var outIcObj;

                  logger.log("content", content);

                  const true_cursor = infiniteCanvas.getTrueCursor();
                  const trueRect = {
                    x: true_cursor.x,
                    y: true_cursor.y,
                    width: 100,
                    height: 100,
                  };

                  if (typeof content == "string") {
                    const text = content;
                    outIcObj = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
                  } else if (content instanceof Image) {
                    const img = content;
                    outIcObj = infiniteCanvas.createIcImage(trueRect.x, trueRect.y, img);
                  } else {
                    outIcObj = infiniteCanvas.createIcRect(trueRect);
                  }

                  return outIcObj;
                });
              }

              // return outVal;
              // return out_p;
              outObservable = Rx.from(out_p);
              return outObservable;
            }));

          this.rx_mixedPaste = rx_mixedPaste;
        }

        manageInnerCopy(source, content) {

          const cbObj = new ClipboardObject(source, content);

          const innerCopyEvent = new InnerCopyEvent(cbObj);
          this.rx_innerCopy.next(innerCopyEvent);




          //copy to navigator clipboard
          const icObj = content;

          const outerWrapper = outerWrapperForIcObj(icObj);
          if (outerWrapper != null) {

            writeToClipboard_p(outerWrapper)
              .then(success => {
                console.log("writeToClipboard_p, success");
              })
              .catch(err => {
                console.log("writeToClipboard_p, error:" + err);
              });


          }

          function outerWrapperForIcObj(icObj) {
            var out;

            switch (icObj.type) {
              case "image":
                const outerWrapper_image = {
                  type: "image",
                  content: icObj.img,
                };
                out = outerWrapper_image;
                break;
              case "text":
                const outerWrapper_text = {
                  type: "text",
                  content: icObj.text,
                };
                out = outerWrapper_text;
                break;
              case "mathNode":
                const outerWrapper_mathNode = {
                  type: "number",
                  content: icObj.mathNode.evaluate({}),
                };
                out = outerWrapper_mathNode;
                break;
              default:
                out = null;
                break;
            }

            return out;
          }

          function writeToClipboard_p(outerWrapper) {
            var out_p;

            switch (outerWrapper.type) {
              case "text":
                const text = outerWrapper.content;
                out_p = writeToClipboard_text_p(text);
                break;
              case "image":
                const img = outerWrapper.content;
                //const imgSrc_p = FileIntegration.dataUrlForImgViaCanvas_p(img);
                // out_p = img_serial_p
                //         .then(imgSrc => {
                //           return writeToClipboard_image_p(imgSrc);
                //         });
                out_p = writeToClipboard_image_p(img);
                break;
              // case "mixed":
              //   writeToClipboard_mixed(outerWrapper.content);
              //   break;
              case "number":
                const value = outerWrapper.content;
                const str__number = "" + value;
                out_p = navigator.clipboard.writeText(str__number);
                break;
              default:
                throw new Error("outerWrapper, unsupported type: " + outerWrapper.type);
            }

            return out_p;
          }

          function writeToClipboard_text_p(text) {
            return navigator.clipboard.writeText(text)
              .then(success => {
                console.log("navigator.clipboard.writeText, success");
              })
              .catch(err => {
                console.log("navigator.clipboard.writeText, error:" + err);
              });
          }

          function writeToClipboard_image_p(img) {
            console.log("writeToClipboard_image", img);

            // const image = await fetch('ceiling-cat.jpg');
            // const blob_image = new Blob([imgSrc], { type: 'image/png' });
            const blob_image_p = FileIntegration.imageContentsToBlob_p(img);

            // const blob_text = new Blob(['Cute sleeping kitten'], {type: 'text/plain'});

            const item_p = blob_image_p.then(blob_image => {
              const item = new ClipboardItem({
                // 'text/plain': blob_text,

                'image/png': blob_image,
              });

              return item;
            });

            return item_p
              .then(item => {
                navigator.clipboard.write([item])
              })
              .then(success => {
                console.log("navigator.clipboard.write, success");
              })
              .catch(err => {
                console.log("navigator.clipboard.write, error:" + err);
              });
          }

        }

        // manageOuterPaste(clipboardEvent) {
        //   this.rx_outerPaste.next(clipboardEvent);
        // }

        outerToInner_p(clipboardEvent) {
          var out_p;
          logger.log("outerToInner_p, clipboardEvent");

          // get text representation of clipboard
          var text = (clipboardEvent.originalEvent || clipboardEvent).clipboardData.getData('text/plain');
          if (text) {
            logger.log("text", text);
            // fileIntegration.onPasteTextListeners.forEach((listener, i) => {
            //   listener(text);
            // });
            out_p = Promise.resolve(text);
          } else {
            logger.log("not a text");

            out_p =
              FileIntegration.getPastedFile_p(clipboardEvent)
                .then(FileIntegration.createImage_p);
            // .then(img => {
            //   fileIntegration.onPasteImageListeners.forEach((listener, i) => {
            //     listener(img);
            //   });
            // });

          }

          return out_p;
        }


        // outerToInner_p(blob) {
        //   var out_p;
        //   logger.log("outerToInner_p", "blob:", blob);

        //   // get text representation of clipboard
        //   var text = (clipboardEvent.originalEvent || clipboardEvent).clipboardData.getData('text/plain');
        //   if (text) {
        //     logger.log("text", text);
        //     // fileIntegration.onPasteTextListeners.forEach((listener, i) => {
        //     //   listener(text);
        //     // });
        //     out_p = Promise.resolve(text);
        //   } else {
        //     logger.log("not a text");

        //     out_p =
        //       FileIntegration.getPastedFile_p(clipboardEvent)
        //         .then(FileIntegration.createImage_p);
        //     // .then(img => {
        //     //   fileIntegration.onPasteImageListeners.forEach((listener, i) => {
        //     //     listener(img);
        //     //   });
        //     // });

        //   }

        //   return out_p;
        // }


        lol() {
          // pasteFabricObjects(event) {
          //   console.log("pasteFabricObjects", event);
          //
          //   const clipboardData = event.clipboardData;
          //   // _clipboard.clone(function(clonedObj) {
          //   navigator.clipboard.read()
          //   .then((items) => {
          //     console.log("items", items);
          //   })
          //   .catch((err) => {
          //     console.log("err", err);
          //   });
          //
          //
          //   clipboardData.clone(function(clonedObj) {
          //     fabricCanvas.discardActiveObject();
          //     clonedObj.set({
          //       left: clonedObj.left + 10,
          //       top: clonedObj.top + 10,
          //       evented: true,
          //     });
          //     if (clonedObj.type === 'activeSelection') {
          //       // active selection needs a reference to the canvas.
          //       clonedObj.canvas = fabricCanvas;
          //       clonedObj.forEachObject(function(obj) {
          //         fabricCanvas.add(obj);
          //       });
          //       // this should solve the unselectability
          //       clonedObj.setCoords();
          //     } else {
          //       fabricCanvas.add(clonedObj);
          //     }
          //
          //     _clipboard.top += 10;
          //     _clipboard.left += 10;
          //
          //     fabricCanvas.setActiveObject(clonedObj);
          //     fabricCanvas.requestRenderAll();
          //   });
          // }
        }

        lol2() {
          fileIntegration.onPasteImageListeners.push((img) => {
            infiniteCanvas.manageImport__image(img);
          });
          fileIntegration.onPasteTextListeners.push((text) => {
            infiniteCanvas.manageImport__text(text);
          });
        }

      }










      //User Input

      class InputProperties {
        constructor() {
          this.scroll_step__default = 1.0 / 500;
          this.scrollProperties = {
            step: this.scroll_step__default,
          };



          this.scroll_step__slow = this.scroll_step__default / 10;
          this.scroll_step__fast = this.scroll_step__default * 10;


          this.move_multiplier__default = 1.0;
          this.moveProperties = {
            moveMultiplier: this.move_multiplier__default,
          };

          this.move_multiplier__slow = this.move_multiplier__default / 10;
          this.move_multiplier__fast = this.move_multiplier__default * 10;


          this.colorProperties = {
            activeIndex: 5,
            list: [
              "lime",

              "red",
              "green",
              "blue",

              "white",
              "black",

              "orange",
              "purple",
              "yellow",

              "transparent",
            ],
          };

          this.setNextColor(0);

          this.opacity   = 1.0;
          this.lightness = 0.5;
          
          const screment = 0;
          this.setNextOpacity(screment);
          this.setNextLightness(screment);


          this.fColor__working = null;



          this.brushColor      = "black";
          this.brushOpacity    = 1;

          this.brushWidth      = 20;
          this.brushWidth__min = 0;
          this.brushWidth__max = 40;
          this.brushWidth__stored    = 20;
          this.brushWidth__isElastic = false;

          this.brushZIndex     = 100;

          this.brushIsAdhesive = true;

          this.brush__single = null;


          this.homeScale = {X:1.0,Y:1.0};
          this.isHomeScaleLocked = false;


          this.comb__nbStrokes = 2;

          this.isAdhesive = false;
        }

        setScrollStep(value) {
          //console.log("setScrollStep", value);
          this.scrollProperties.step = value;
        }

        setMoveMultiplier(value) {
          //console.log("setMoveMultiplier", value);
          this.moveProperties.moveMultiplier = value;
        }



        getActiveColor() {
          //debug
          // if(this.color__working != null) {
          //   return this.color__working;
          // }
          return this.colorProperties.list[this.colorProperties.activeIndex];
        }

        setNextColor(screment) {
          console.log("setNextColor", screment);

          var index = this.colorProperties.activeIndex;
          index += screment;
          if (index >= this.colorProperties.list.length) {
            index -= this.colorProperties.list.length;
          } else if (index < 0) {
            index += this.colorProperties.list.length;
          }

          this.colorProperties.activeIndex = index;

          {
            const color   = this.getActiveColor();
            const opacity = this.getActiveOpacity();

            const fColor = new fabric.Color(color);
            if(color == "transparent") {
              fColor.setAlpha(0);
            } else {
              fColor.setAlpha(opacity);
            }

            this.setFColor__working(fColor);
          }



          //debug
          ic_HUD.setActiveColor(this.getActiveRgbaColorString());
          debug.setActiveColor(this.getActiveRgbaColorString());
        }

        setFColor__working(fColor) {
          this.fColor__working = fColor;

          // this.color__working = new fabric.Color(fColor.toRgb());
          // this.opacity = fColor.getAlpha();
        }

        // setWorkingOpacity(color) {
        //
        // }



        getActiveOpacity() {
          return this.opacity;
        }

        setNextOpacity(screment) {
          console.log("setNextOpacity", screment);

          const opacity_prev = this.opacity;

          const step_opacity = 0.1;
          const screment_opacity = step_opacity * (-screment);

          const opacity_bounded = Math.min(1.0, Math.max(0.0, opacity_prev + screment_opacity));
          this.opacity = opacity_bounded;

          if (this.fColor__working != null) {
            this.fColor__working.setAlpha(opacity_bounded);
          }

          //debug
          ic_HUD.setActiveColor(this.getActiveRgbaColorString());
          debug.setActiveColor(this.getActiveRgbaColorString());
        }


        getActiveLightness() {
          return this.lightness;
        }

        setNextLightness(screment) {
          console.log("setNextLightness", screment);

          const lightness_prev = this.lightness;

          const step_lightness = 0.1;
          const screment_lightness = step_lightness * (-screment);

          const lightness_bounded = Math.min(1.0, Math.max(0.0, lightness_prev + screment_lightness));
          this.lightness = lightness_bounded;

          if (this.fColor__working != null) {
            // this.fColor__working.setAlpha(brightness_bounded);
            this.fColor__working = ColorUtils.fColorWithLightness(this.fColor__working, this.lightness);
          }

          //debug
          const rgbaColorString = this.getActiveRgbaColorString();
          logger.log("logColor", "rgbaColorString", rgbaColorString);
          ic_HUD.setActiveColor(rgbaColorString);
          debug.setActiveColor(rgbaColorString);
        }



        getActiveFColor() {
          var outFColor;

          if (this.fColor__working != null) {
            outFColor = this.fColor__working;
          } else {
            const color      = this.getActiveColor();
            
            const opacity    = this.getActiveOpacity();
            const lightness  = this.getActiveLightness();


            var fColor = new fabric.Color(color);
            if(color == "transparent") {
              fColor.setAlpha(0);
            } else {
              fColor.setAlpha(opacity);
            }

            fColor = ColorUtils.fColorWithLightness(fColor, lightness);

            outFColor = fColor;
          }

          return outFColor;
        }

        getActiveRgbaColorString() {
          return this.getActiveFColor().toRgba();
        }




        setBrushColor(color_in) {
          this.brushColor = brushColor_in;
        }

        setBrushWidth(brushWidth_in) {
          this.brushWidth = brushWidth_in;
        }

        getActiveBrushWidth() {
          return this.brushWidth;
        }

        resulting_brushWidth_forScrement(screment) {
          const brushWidth__prev = this.brushWidth;

          const brushWidth__computed = brushWidth__prev + screment;
          const brushWidth__bounded  = Math.min(this.brushWidth__max, Math.max(this.brushWidth__min, brushWidth__computed));
          
          return brushWidth__bounded;
        }

        store__brushWidth(brushWidth_in) {
          this.brushWidth__stored = brushWidth_in;
        }

        restore__brushWidth() {
          this.brushWidth = this.brushWidth__stored;
        }


        getActiveHomeScale() {
          return this.homeScale;
        }



        setBrushZIndex(brushZIndex_in) {
          this.brushZIndex = brushZIndex_in;
        }

        getActiveBrushZIndex() {
          return this.brushZIndex;
        }

        resulting_brushZIndex_forScrement(screment) {
          const brushZIndex__prev = this.brushZIndex;

          const brushZIndex__computed = brushZIndex__prev + screment;
          // const brushZIndex__bounded  = Math.min(this.brushZIndex__max, Math.max(this.brushZIndex__min, brushZIndex__computed));
          
          // return brushZIndex__bounded;
          return brushZIndex__computed;
        }



        updateBrush__toggleAdhesive() {
          this.brushIsAdhesive = !this.brushIsAdhesive;
        }


        // toggleAdhesive() {
        //   this.isAdhesive = !this.isAdhesive;
        // }

      }





      class KeyDownToggle {

        constructor(name, keyDownFunc, keyDownToggleFunc = null) {
          this.name = name;
          this.keyDownFunc = keyDownFunc;
          this.isActive = false;

          this.keyDownToggleFunc = keyDownToggleFunc;
          if (keyDownToggleFunc == null) {
            this.keyDownToggleFunc = KeyDownToggle.keyDownToggleFunc();
          }
        }

        update(e, down) {
          const updateValue = this.keyDownFunc(e, down);
          logger.log("logKT", "updateValue", updateValue);
          if (updateValue != null) {
            if (this.isActive != updateValue) {
              this.isActive = updateValue;
              this.keyDownToggleFunc(this.isActive);
            }
          }
        }

        static defaultKeyDownFunc(arr_keyCode, propertyName = "code") {
          const keyDownFunc = (e, down) => {
            logger.log("logKT", "keyDownFunc", arr_keyCode, e[propertyName], down);
            
            var str_code;
            switch(propertyName) {
              case "code":
                str_code = e[propertyName]
                break;
              case "button":
                str_code = "button" + e[propertyName]
                break;
              default:
                throw new Error("unsupported propertyName: " + propertyName);
            }
            
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              // if (keyCode == e.code) {
              if(keyCode == str_code) {
                acc = down;
              }
              return acc;
            }, null);

            // updateValue = arr_keyCode.reduce((acc, keyCode) => {
            //   if (keyCode == e.code) {
            //     acc = acc && down;
            //   }
            //   return acc;
            // }, true);

            return updateValue;
          };

          return keyDownFunc;
        }

        static keyDownToggleFunc() {
          return (isActive) => {
            console.log("KeyDownToggle::update", this.name, this.isActive);
          };
        }

      }

      class KeyDownTimeout {

        constructor(name, keyDownFunc, triggeredFunc, delayInMs) {
          this.name = name;
          this.keyDownFunc = keyDownFunc;
          this.triggeredFunc = triggeredFunc;
          this.delayInMs = delayInMs;

          this.isActive = false;
        }

        update(e, down) {
          const updateValue = this.keyDownFunc(e, down);
          if (updateValue != null) {
            if (this.isActive != updateValue) {
              this.isActive = updateValue;
              logger.log("KeyDownTimeout::update", this.name, this.isActive);

              const keyDownTimeout = this;

              function theFunc() {
                logger.log("KeyDownTimeout", "call triggeredFunc()", e);
                keyDownTimeout.triggeredFunc();
              }

              function mayRepeat(theFunc) {
                return setTimeout(function () {
                  if (keyDownTimeout.isActive) {
                    theFunc();
                    keyDownTimeout.id_timeout = mayRepeat(theFunc);
                  }
                }, keyDownTimeout.delayInMs);
              }

              if (this.isActive) {
                theFunc();
                this.id_timeout = mayRepeat(theFunc);
              } else {
                if (this.id_timeout != null) {
                  clearTimeout(this.id_timeout);
                  this.id_timeout = null;
                }
              }

            }
          }
        }

        static defaultKeyDownFunc(arr_keyCode) {
          const keyDownFunc = (e, down) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if (keyCode == e.code) {
                acc = down;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyDownFunc;
        }

      }

      class KeyUpABToggle {

        constructor(name, keyUpFunc, triggeredFunc) {
          this.name = name;
          this.keyUpFunc = keyUpFunc;
          this.triggeredFunc = triggeredFunc;

          this.isModeA = true;
        }

        update(e) {
          const updateValue = this.keyUpFunc(e);
          console.log("updateValue", updateValue);
          if (updateValue) {
            this.isModeA = !this.isModeA;
            console.log("KeyUpABToggle::update", this.name, this.isModeA);

            this.triggeredFunc(this.isModeA);
          }
        }

        static defaultKeyUpFunc(arr_keyCode) {
          const keyUpFunc = (e) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if (keyCode == e.code) {
                acc = true;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyUpFunc;
        }

      }

      class KeyUpTrigger {

        constructor(name, keyUpFunc, triggeredFunc) {
          this.name = name;
          this.keyUpFunc     = keyUpFunc;
          this.triggeredFunc = triggeredFunc;
        }

        update(e) {
          const updateValue = this.keyUpFunc(e);
          console.log("updateValue", updateValue);
          if (updateValue) {
            console.log("KeyUpTrigger::update", this.name);
            this.triggeredFunc(e);
          }
        }

        static defaultKeyUpFunc(arr_keyCode) {
          const keyUpFunc = (e) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if (keyCode == e.code) {
                acc = true;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyUpFunc;
        }

      }

      class KeyboardIntegration {

        constructor(infiniteCanvas, inputProperties, fileIntegration, fabricIntegration) {
          this.infiniteCanvas    = infiniteCanvas;
          this.inputProperties   = inputProperties;

          this.fileIntegration   = fileIntegration;

          this.fabricIntegration = fabricIntegration;


          // this.altKeyDown = false;
          this.keyDownToggles  = {};
          this.keyDownTimeouts = {};

          this.keyUpABToggles  = {};
          this.keyUpTriggers   = {};


          this.configureKeyboardEventHandlers();
        }

        configureKeyboardEventHandlers() {
          const keyboardIntegration = this;
          const infiniteCanvas = this.infiniteCanvas;

          const fabricIntegration = this.fabricIntegration;

          // document.addEventListener('keyup', logKey);
          document.addEventListener('keyup',   handleKeyUp);
          document.addEventListener('keydown', handleKeyDown);


          //keyboardIntegration.configureKeyDownToggles();
          //keyboardIntegration.configureKeyDownTimeouts();
          //keyboardIntegration.configureKeyUpABToggles();
          //keyboardIntegration.configureKeyUpTriggers();


          function updateKeyDownToggles(e, down) {
            const arr_keyDownToggles = Object.values(keyboardIntegration.keyDownToggles);
            arr_keyDownToggles.forEach((keyDownToggle, i) => {
              keyDownToggle.update(e, down);
            });
            // logger.log("logKI", "updateKeyDownToggles", "arr_keyDownToggles:", arr_keyDownToggles.filter((kdt) => kdt.isActive));
          }

          function updateKeyDownTimeouts(e, down) {
            const arr_keyDownTimeouts = Object.values(keyboardIntegration.keyDownTimeouts);
            arr_keyDownTimeouts.forEach((keyDownTimeout, i) => {
              keyDownTimeout.update(e, down);
            });
          }

          function updateKeyUpABToggles(e) {
            const arr_keyUpABToggles = Object.values(keyboardIntegration.keyUpABToggles);
            arr_keyUpABToggles.forEach((keyUpABToggle, i) => {
              keyUpABToggle.update(e);
            });
          }

          function updateKeyUpTriggers(e) {
            const arr_keyUpTriggers = Object.values(keyboardIntegration.keyUpTriggers);
            arr_keyUpTriggers.forEach((keyUpTrigger, i) => {
              keyUpTrigger.update(e);
            });
          }


          function logKey(e) {
            logger.log("logKey", "e.code", e.code);
          }

          function handleKeyUp(e) {
            logger.log("logKB", "handleKeyUp", "e", e);

            logger.log("globalsSingleton.isEditing", globalsSingleton.isEditing);
            if (globalsSingleton.isEditing) {
              if(infiniteCanvas.isNumberTypingLockedMode) {
                switch(e.code) {
                  case "Enter":
                  case "NumpadEnter":
                    {
                      //continue to process keyup event
                    }
                    break;
                  default:
                    {
                      //ignore keyup event
                      return;
                    }
                    break;
                }
              } else if(infiniteCanvas.isNumberTyping) {
                switch(e.code) {
                  case "KeyZ":
                  case "KeyB":
                    {
                      //continue to process keyup event
                    }
                    break;
                  default:
                    {
                      //ignore keyup event
                      return;
                    }
                    break;
                }
              }
            }

            if (fabricIntegration.shouldIgnoreShortcutInput()) {
              return;
            }

            updateKeyDownToggles(e, false);
            updateKeyDownTimeouts(e, false);
            updateKeyUpABToggles(e);
            updateKeyUpTriggers(e);

            if (keyboardIntegration.keyDownToggles.p.isActive) {
              logger.log("keyboardIntegration.keyDownToggles.p.isActive");
              // if(e.code == "ShiftLeft") {
              //   return;
              // }
              handleKeyUp__pov(e);
            } else {
              handleKeyUp__default(e);
            }

            function handleKeyUp__pov(e) {
              logger.log("handleKeyUp__pov", e);
              
              if(!e.code.startsWith("Digit")) {
                
                if(e.code != "KeyS") {
                  return;
                } else {
                  
                  //create pov star
                  const trueRect__screen  = infiniteCanvas.getShownRect();
                  // const icPOVRect         = infiniteCanvas.createIcPOVRect(trueRect__screen);
                  const trueRect__screen2 = {
                    x:      trueRect__screen.x,
                    y:      trueRect__screen.y,
                    width:  trueRect__screen.width  * infiniteCanvas.scale.X,
                    height: trueRect__screen.height * infiniteCanvas.scale.Y,
                  };
                  const icComposite = infiniteCanvas.createIcPOVRectStar(trueRect__screen2);
                  infiniteCanvas.addNewIcObject(icComposite);
                }

              } else {

                const index = e.code.match(/\d+/).find(e=>true);

                if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  //create pov
                  const trueRect__screen  = infiniteCanvas.getShownRect();
                  // const icPOVRect         = infiniteCanvas.createIcPOVRect(trueRect__screen);
                  const trueRect__screen2 = {
                    x:      trueRect__screen.x,
                    y:      trueRect__screen.y,
                    width:  trueRect__screen.width  * infiniteCanvas.scale.X,
                    height: trueRect__screen.height * infiniteCanvas.scale.Y,
                  };
                  const icPOVRect = infiniteCanvas.createIcPOVRect(trueRect__screen2);
                  infiniteCanvas.addNewIcObject(icPOVRect);

                  //store pov
                  infiniteCanvas.storePOVRectAtIndex(icPOVRect, index);
                } else {
                  //create gotopov button
                  const icPOVRect = infiniteCanvas.getStoredPOVRect(index);

                  const trueCursor = infiniteCanvas.getTrueCursor();
                  const trueRect__button = {
                    x:      trueCursor.x,
                    y:      trueCursor.y,
                    width:  100,
                    height: 100,
                  };

                  const icButton  = infiniteCanvas.createIcButton__gotopov(trueRect__button, icPOVRect);
                  infiniteCanvas.addNewIcObject(icButton);
                }

              }

            }

            function handleKeyUp__default(e) {}
              
          }

          function handleKeyDown(e) {
            logger.log("logKB", "handleKeyDown", "e.code", e.code);

            if(e.repeat) {

              // //ignore repeating KeyZ 
              // if (globalsSingleton.isEditing) {
              //   if(infiniteCanvas.isNumberTyping) {
              //     //ignore KeyZ
              //     if(e.code == "KeyZ") {
              //       e.preventDefault();
              //     }
              //   }
              //   return;
              // }

              switch(e.code) {
                case "KeyQ":
                  {
                    //ignore repeating KeyQ while microphoneRecording
                    if (infiniteCanvas.isImportMode && keyboardIntegration.keyDownToggles.altLeft.isActive) {
                      e.preventDefault();
                    }
                    return;
                  }
                  break;
                case "KeyZ":
                  {
                    //ignore repeating KeyZ while numberTyping
                    if (globalsSingleton.isEditing) {
                      if(infiniteCanvas.isNumberTyping) {
                        e.preventDefault();
                      }
                    }
                    return;
                  }
                  break;
                case "KeyB":
                  {
                    //ignore repeating KeyB while batchPasting
                    if (globalsSingleton.isEditing) {
                      // if(infiniteCanvas.isBatchPasting) {
                      if(infiniteCanvas.isNumberTyping) {
                        e.preventDefault();
                      }
                    }
                    return;
                  }
                  break;

                case "Back":
                case "F1":
                  {
                    e.preventDefault();
                  }
                  break;
                default:
                  break;
              }

              updateKeyDownTimeouts(e, true);
            } else {
              handleKeyDownOnce(e);
              updateKeyDownTimeouts(e, true);
            }

          }

          function handleKeyDownOnce(e) {
            logger.log("logKB", "handleKeyDownOnce", "e.code", e.code);

            logger.log("globalsSingleton.isEditing", globalsSingleton.isEditing);
            //prevent initial keyDown from propagating
            switch(e.code) {
              case "KeyZ":
              case "KeyB":
                {
                  if (globalsSingleton.isEditing) {
                    if(infiniteCanvas.isNumberTyping) {
                      e.preventDefault();
                    }
                    return;
                  }
                }
                break;

              // case "ShiftLeft":
              // case "AltLeft":
              //   {
              //     e.preventDefault();
              //     return;
              //   }
              //   break;

              case "F1":
                {
                  e.preventDefault();
                }
                break;

              default:
                break;
            }

            if (fabricIntegration.shouldIgnoreShortcutInput()) {
              return;
            }

            //ignore KeyZ
            if(!infiniteCanvas.isNumberTyping && e.code == "KeyZ") {    //SHU: a bit complicated, it's to prevent MathQuill.mathField from starting with "w"
              e.preventDefault();
            }
            updateKeyDownToggles(e, true);
            // updateKeyDownTimeouts(e, true);


            switch (e.code) {
              /*
              // case "ShiftLeft":
              case "KeyZ":
                handleKey_Shift(e);
                break;
              // case "ControlLeft":
              case "KeyX":
                handleKey_Ctrl(e);
                break;
              */

              // case "AltLeft":
              // case "AltRight":
              //   keyboardIntegration.altKeyDown = true;
              //   break;

              case "KeyC":
                {
                  keyboardIntegration.infiniteCanvas.isColorPickerAvailable = true;
                }
                break;

              // case "KeyV":
              //   {
              //     if (keyboardIntegration.keyDownToggles.ctrlLeft.isActive) {
              //         //io paste
              //         keyboardIntegration.infiniteCanvas.enterIOPasting();
              //     }
              //   }
              //   break;
              
              case "KeyB":
                {
                  keyboardIntegration.infiniteCanvas.isApparentWidthPickerAvailable = true;

                  if (keyboardIntegration.keyDownToggles.ctrlLeft.isActive) {
                      //batch paste
                      keyboardIntegration.infiniteCanvas.enterBatchPasting();
                  }
                }
                break;

              default:
                break;
            }
          }



          // function handleKeyUp_A(e) {
          //   //console.log("handleKeyUp_A", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const zimage_scream = this.createScreamZimage(canvasBoundingTrueRect);
          //   this.addZimage(zimage_scream);
          //
          //   this.redrawCanvas();
          // }

          // function handleKeyUp_F(e) {
          //   //console.log("handleKeyUp_F", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const fObj = this.createFabricSampleObjectWithCanvasBoundingRect(canvasBoundingTrueRect);
          //   this.addFabricObject(fObj);
          //
          //   this.redrawCanvas();
          // }

          // function handleKeyUp_T(e) {
          //   //console.log("handleKeyUp_T", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const fObj = this.createFabricSampleTextObjectWithCanvasBoundingRect(canvasBoundingTrueRect);
          //   this.addFabricObject(fObj);
          //
          //   this.redrawCanvas();
          // }

          //scroll fast/slow

          /*
                  $(document).keydown(function(event) {
                  if (event.ctrlKey==true && (event.which == '61' || event.which == '107' || event.which == '173' || event.which == '109'  || event.which == '187'  || event.which == '189'  ) ) {
                          event.preventDefault();
                       }
                      // 107 Num Key  +
                      // 109 Num Key  -
                      // 173 Min Key  hyphen/underscor Hey
                      // 61 Plus key  +/= key
                  });

                  $(window).bind('mousewheel DOMMouseScroll', function (event) {
                         if (event.ctrlKey == true) {
                         event.preventDefault();
                         }
                  });
          */



          function handleKey_Shift(e) {
            switch (e.type) {
              case "keydown":
                this.setScrollStep(scroll_step__fast);
                this.setMoveMultiplier(move_multiplier__fast);
                break;
              case "keyup":
                this.setScrollStep(scroll_step__default);
                this.setMoveMultiplier(move_multiplier__default);
                break;
              default:
                break;
            }
          }

          function handleKey_Ctrl(e) {
            switch (e.type) {
              case "keydown":
                this.setScrollStep(scroll_step__slow);
                this.setMoveMultiplier(move_multiplier__slow);
                break;
              case "keyup":
                this.setScrollStep(scroll_step__default);
                this.setMoveMultiplier(move_multiplier__default);
                break;
              default:
                break;
            }
          }

        }

        configureKeyDownToggles() {
          const keyboardIntegration = this;
          const infiniteCanvas = this.infiniteCanvas;

          const fabricIntegration = this.fabricIntegration;


          keyboardIntegration.keyDownToggles = {
            // alt: new KeyDownToggle("alt", KeyDownToggle.defaultKeyDownFunc(["AltLeft", "AltRight"])),   //do not use alt, alt is kind of a system key
            r: new KeyDownToggle("r", KeyDownToggle.defaultKeyDownFunc(["KeyR"])),

            c: new KeyDownToggle("c", KeyDownToggle.defaultKeyDownFunc(["KeyC"])),
            v: new KeyDownToggle("v", KeyDownToggle.defaultKeyDownFunc(["KeyV"])),
            b: new KeyDownToggle("b", KeyDownToggle.defaultKeyDownFunc(["KeyB"])),
            d: new KeyDownToggle("d", KeyDownToggle.defaultKeyDownFunc(["KeyD"])),
            n: new KeyDownToggle("n", KeyDownToggle.defaultKeyDownFunc(["KeyN"])),

            i: new KeyDownToggle("i", KeyDownToggle.defaultKeyDownFunc(["KeyI"]), (isActive) => {
              infiniteCanvas.isImportMode = isActive;
            }),

            e: new KeyDownToggle("e", KeyDownToggle.defaultKeyDownFunc(["KeyE"]), (isActive) => {
              infiniteCanvas.isTransportationMode = isActive;
            }),

            shiftLeft: new KeyDownToggle("shiftLeft", KeyDownToggle.defaultKeyDownFunc(["ShiftLeft"]), (isActive) => {
              //only side effect is used
            }),
            altLeft: new KeyDownToggle("altLeft", KeyDownToggle.defaultKeyDownFunc(["AltLeft"]), (isActive) => {
              if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                infiniteCanvas.isDeepAltering = isActive;
              } else {
                infiniteCanvas.isAltering     = isActive;
              }
            }),
            ctrlLeft: new KeyDownToggle("ctrlLeft", KeyDownToggle.defaultKeyDownFunc(["ControlLeft"]), (isActive) => {
              //only side effect is used
            }),
            space: new KeyDownToggle("space", KeyDownToggle.defaultKeyDownFunc(["Space"]), (isActive) => {

              if(fabricIntegration.fabricCanvas.isDrawingMode) {
                if(isActive) {
                  infiniteCanvas.enterCombSetup();
                } else {
                  infiniteCanvas.leaveCombSetup();
                }
              }

            }),

            intlBackslash: new KeyDownToggle("intlBackslash", KeyDownToggle.defaultKeyDownFunc(["IntlBackslash"]), (isActive) => {
              //only side effect is used
            }), 

            w: new KeyDownToggle("w", KeyDownToggle.defaultKeyDownFunc(["KeyZ"]), (isActive) => {
              
              if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                if (isActive) {
                  infiniteCanvas.isNumberTypingLockedMode = true;
                  infiniteCanvas.enterNumberTyping();
                }
              } else {
                if(!infiniteCanvas.isNumberTypingLockedMode) {
                  if (isActive) {
                    infiniteCanvas.enterNumberTyping();
                  } else {
                    infiniteCanvas.leaveNumberTyping();
                  }  
                }
              }
              

            }),

            a: new KeyDownToggle("q", KeyDownToggle.defaultKeyDownFunc(["KeyQ"]), (isActive) => {

              if(infiniteCanvas.isImportMode && keyboardIntegration.keyDownToggles.altLeft.isActive) {
                if (isActive) {
                  infiniteCanvas.enterMicrophoneRecording();
                } else {
                  infiniteCanvas.leaveMicrophoneRecording();
                }
              }

            }),



            p: new KeyDownToggle("p", KeyDownToggle.defaultKeyDownFunc(["KeyP"]), (isActive) => {
              //only side effect is used
            }),

            // shiftLeft: new KeyDownToggle("shiftLeft", KeyDownToggle.defaultKeyDownFunc(["ShiftLeft"]), (isActive) => {
            backquote: new KeyDownToggle("backquote", KeyDownToggle.defaultKeyDownFunc(["Backquote"]), (isActive) => {
              /**/

              const isCosmetic = keyboardIntegration.keyDownToggles.altLeft.isActive;
              const cfg = {
                isCosmetic: isCosmetic,
                isAdhesive: inputProperties.brushIsAdhesive,
              };
              if (isActive) {
                fabricIntegration.enterFreeDrawing(cfg);
              } else {
                fabricIntegration.leaveFreeDrawing();
              }
              /**/
            }),

            q: new KeyDownToggle("q", KeyDownToggle.defaultKeyDownFunc(["KeyA"]), (isActive) => {
              /**/
              const cfg = {};
              if (isActive) {
                infiniteCanvas.enterZSegmentDrawing(cfg);
              } else {
                infiniteCanvas.leaveZSegmentDrawing();
              }
              /**/
            }),

            digit1: new KeyDownToggle("digit1", KeyDownToggle.defaultKeyDownFunc(["Digit1"]), (isActive) => {

              if (keyboardIntegration.keyDownToggles.p.isActive) {
                return;
              } else if (fabricIntegration.fabricCanvas.isDrawingMode) {
                //brushWidthScroll: "elastic kick"
                return;
              }
              else if (keyboardIntegration.keyDownToggles.backquote.isActive) {
                if (isActive) {
                  infiniteCanvas.enterRelativePan();
                } else {
                  infiniteCanvas.leaveRelativePan();
                }
                return;
              }

              // /**/
              // if (isActive) {
              //   fabricIntegration.enterSlicing();
              // } else {
              //   fabricIntegration.leaveSlicing();
              // }
              // /**/

              /**/
              //craneScroll
                //only side effect is used
              /**/
            }),

            // digit2: new KeyDownToggle("digit2", KeyDownToggle.defaultKeyDownFunc(["Digit2"]), (isActive) => {
            //   /**/
            //   if(isActive) {
            //     fabricIntegration.enterInnerPainting();
            //   } else {
            //     fabricIntegration.leaveInnerPainting();
            //   }
            //   /**/
            // }),

            zIndexEditing: new KeyDownToggle("zIndexEditing", KeyDownToggle.defaultKeyDownFunc(["Digit2"]), (isActive) => {
              
              if (keyboardIntegration.keyDownToggles.p.isActive) {
                return;
              }
              
              if (isActive) {
                infiniteCanvas.enterZIndexEditing();
              } else {
                infiniteCanvas.leaveZIndexEditing();
              }

            }),

            pathmadeOperatorDrawing__conveyor: new KeyDownToggle("Digit5", KeyDownToggle.defaultKeyDownFunc(["Digit5"]), (isActive) => {

              //friendly toggle: shiftLeft
              // keyboardIntegration.keyDownToggles.shiftLeft.isActive = isActive;    //SHU: this does not work because this drawing uses a 'record brush'

              if (keyboardIntegration.keyDownToggles.p.isActive) {
                return;
              }

              if (!globalsSingleton.isEditing) {
                if (isActive) {
                  var type;
                  // if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                    // type = "vesseler";
                  // } else {
                    type = "conveyor";
                  // }

                  const cfg = {
                    isCosmetic: false,
                    isAdhesive: inputProperties.brushIsAdhesive,
                  };

                  fabricIntegration.enterPathmadeOperatorPathDrawing__grains(type, cfg);
                } else {
                  fabricIntegration.leavePathmadeOperatorPathDrawing__grains();
                }
              }

            }),

            // ssPathmadeOperator__conveyor: new KeyDownToggle("Digit3", KeyDownToggle.defaultKeyDownFunc(["Digit3"]), (isActive) => {

            //   //friendly toggle: shiftLeft
            //   keyboardIntegration.keyDownToggles.shiftLeft.isActive = isActive;

            //   if (keyboardIntegration.keyDownToggles.p.isActive) {
            //     return;
            //   }

            //   if (!globalsSingleton.isEditing) {
            //     if (isActive) {
            //       var type;
            //       // if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
            //         // type = "vesseler";
            //       // } else {
            //         type = "conveyor";
            //       // }

            //       const cfg = {
            //         isCosmetic: false,
            //         isAdhesive: inputProperties.brushIsAdhesive,
            //       };

            //       fabricIntegration.enterSSPathmadeOperatorDrawing__grains(type, cfg);
            //     } else {
            //       fabricIntegration.leaveSSPathmadeOperatorDrawing__grains();
            //     }
            //   }

            // }),


            // pathmadeOperatorDrawing__shadePossessor: new KeyDownToggle("Digit4", KeyDownToggle.defaultKeyDownFunc(["Digit4"]), (isActive) => {
            //
            //   if(isActive) {
            //     const type = "shadePossessor";
            //     fabricIntegration.enterPathmadeOperatorPathDrawing__grains(type);
            //   } else {
            //     fabricIntegration.leavePathmadeOperatorPathDrawing__grains();
            //   }
            //
            // }),

            pathmadeOperatorDrawing__shadePossessor: new KeyDownToggle("Digit4", KeyDownToggle.defaultKeyDownFunc(["Digit4"]), (isActive) => {

              if (keyboardIntegration.keyDownToggles.p.isActive) {
                return;
              }

              // if (isActive) {
              //   const type = "shadePossessor";

              //   const cfg = {
              //     isCosmetic: false,
              //     isAdhesive: inputProperties.brushIsAdhesive,
              //   };

              //   fabricIntegration.enterPathmadeOperatorPathDrawing__grains(type, cfg);
              // } else {
              //   fabricIntegration.leavePathmadeOperatorPathDrawing__grains();
              // }

              //debug
              if (isActive) {
                const type = "fdApply";

                const cfg = {
                  func__apply: function(icObj) {
                    // const rep_free__icObj = infiniteCanvas.getRepresented(icObj.id).r_free();
                    const rep_free__icObj = icObj;

                    const rgbaColorString = inputProperties.getActiveRgbaColorString();
                    infiniteCanvas.updateMainColorOfObject(rep_free__icObj, rgbaColorString);
                  },
                };

                fabricIntegration.enterFreeDrawingApply(cfg);
              } else {
                fabricIntegration.leaveFreeDrawingApply();
              }

            }),

            digit3: new KeyDownToggle("Digit3", KeyDownToggle.defaultKeyDownFunc(["Digit3"]), (isActive) => {

              if (keyboardIntegration.keyDownToggles.p.isActive) {
                return;
              } else if (keyboardIntegration.keyDownToggles.backquote.isActive) {
                if (isActive) {
                  infiniteCanvas.isZIndexEditing = true;
                } else {
                  infiniteCanvas.isZIndexEditing = false;
                }
                return;
              } else {

                // if (isActive) {
                //   const type = "conveyor";
                //   // const type = "shadePossessor";
                //   fabricIntegration.enterPathmadeOperatorPathDrawing__composite(type);
                // } else {
                //   fabricIntegration.leavePathmadeOperatorPathDrawing__composite();
                // }

              }

            }),

            // recording: new KeyDownToggle("recording", KeyDownToggle.defaultKeyDownFunc(["Digit6"]), (isActive) => {
            //   if(isActive) {
            //     infiniteCanvas.enterRecording();
            //   } else {
            //     infiniteCanvas.leaveRecording();
            //   }
            // }),

          };


          keyboardIntegration.keyDownToggles.altLeft.isActive = false;    //SHU: bugFix...      //!!!

        }

        configureKeyDownTimeouts() {
          const keyboardIntegration = this;
          const infiniteCanvas = this.infiniteCanvas;

          const fabricIntegration = this.fabricIntegration;
          

          const default_timeout_delayInMs = 17; //17 ms == 60 fps
          const arrows_timeout_delayInMs  = 500;

          function create_keyDownFunc__custom_1(arr_keyCode) {
            return (e, down) => {
              var updateValue;

              if (globalsSingleton.isEditing) {
                //ignore
                updateValue = null;
              } else {
                updateValue = arr_keyCode.reduce((acc, keyCode) => {
                  if (keyCode == e.code) {
                    acc = down;
                  }
                  return acc;
                }, null);
              }

              return updateValue;
            };
          }

          function getScaleAmount(factor) {
            var scaleAmount_for_100ms;
            if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
              scaleAmount_for_100ms = factor * 0.3;
            } else {
              scaleAmount_for_100ms = factor * 0.1;
            }

            const scaleAmount = default_timeout_delayInMs / 100 * scaleAmount_for_100ms;
            return scaleAmount;
          }

          keyboardIntegration.keyDownTimeouts = {

            // a: new KeyDownTimeout("a", KeyDownToggle.defaultKeyDownFunc(["KeyQ"]), () => {
            a: new KeyDownTimeout("a", create_keyDownFunc__custom_1(["KeyQ"]), () => {

              if (keyboardIntegration.keyDownToggles.ctrlLeft.isActive) {
                //ignore
                return;
              }
              if (keyboardIntegration.keyDownToggles.intlBackslash.isActive) {
                //ignore
                return;
              }
              if (infiniteCanvas.isImportMode && keyboardIntegration.keyDownToggles.altLeft.isActive) {
                //ignore
                return;
              }

              const scaleAmount = getScaleAmount(-1);
              if(keyboardIntegration.keyDownToggles.digit1.isActive) {
                //craneScroll
                keyboardIntegration.infiniteCanvas.manageUpdate__selectedObj__homeScale__withScaleAmount(scaleAmount);
              } else {
                //zScroll
                keyboardIntegration.infiniteCanvas.manageUpdate__scale_withScaleAmount(scaleAmount);
              }
            
            }, default_timeout_delayInMs),

            // z: new KeyDownTimeout("z", KeyDownToggle.defaultKeyDownFunc(["KeyW"]), () => {
            z: new KeyDownTimeout("z", create_keyDownFunc__custom_1(["KeyW"]), () => {

              const scaleAmount = getScaleAmount(+1);
              if(keyboardIntegration.keyDownToggles.digit1.isActive) {
                //craneScroll
                keyboardIntegration.infiniteCanvas.manageUpdate__selectedObj__homeScale__withScaleAmount(scaleAmount);
              } else {
                //zScroll
                keyboardIntegration.infiniteCanvas.manageUpdate__scale_withScaleAmount(scaleAmount);
              }

            }, default_timeout_delayInMs),


            //arrows

            arrow_up: new KeyDownTimeout("arrow_up", KeyDownToggle.defaultKeyDownFunc(["ArrowUp"]), () => {
              keyboardIntegration.infiniteCanvas.operateOnSupervessel__moveStep(0, -1);
            }, arrows_timeout_delayInMs),
            arrow_down: new KeyDownTimeout("arrow_down", KeyDownToggle.defaultKeyDownFunc(["ArrowDown"]), () => {
              keyboardIntegration.infiniteCanvas.operateOnSupervessel__moveStep(0, +1);
            }, arrows_timeout_delayInMs),
            arrow_left: new KeyDownTimeout("arrow_left", KeyDownToggle.defaultKeyDownFunc(["ArrowLeft"]), () => {
              keyboardIntegration.infiniteCanvas.operateOnSupervessel__moveStep(-1, 0);
            }, arrows_timeout_delayInMs),
            arrow_right: new KeyDownTimeout("arrow_right", KeyDownToggle.defaultKeyDownFunc(["ArrowRight"]), () => {
              keyboardIntegration.infiniteCanvas.operateOnSupervessel__moveStep(+1, 0);
            }, arrows_timeout_delayInMs),

          };

        }

        configureKeyUpABToggles() {
          const keyboardIntegration = this;
          const infiniteCanvas = this.infiniteCanvas;

          const fabricIntegration = this.fabricIntegration;


          keyboardIntegration.keyUpABToggles = {
            ":": new KeyUpABToggle(":", KeyUpABToggle.defaultKeyUpFunc(["Period"]), (isModeA) => {
              keyboardIntegration.fabricIntegration.setAntiAliasEnabled(isModeA);
            }),

            // "n": new KeyUpABToggle("n", KeyUpABToggle.defaultKeyUpFunc(["KeyN"]), (isModeA) => {
            //   keyboardIntegration.fabricIntegration.setSupervesselEnabled(isModeA);
            // }),

            // "d": new KeyUpABToggle("d", KeyUpABToggle.defaultKeyUpFunc(["KeyD"]), (isModeA) => {
            //   // const infiniteCanvas = keyboardIntegration.infiniteCanvas;
            //   // if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
            //   //   if (!isModeA) {
            //   //     infiniteCanvas.createIcLine_start();
            //   //   } else {
            //   //     infiniteCanvas.createIcLine_end();
            //   //   }
            //   // } else {
            //   //   if (!isModeA) {
            //   //     infiniteCanvas.createIcHUDLine_start();
            //   //   } else {
            //   //     infiniteCanvas.createIcHUDLine_end();
            //   //   }
            //   // }
            // }),

            // "KeyZ": new KeyUpABToggle("w", KeyUpABToggle.defaultKeyUpFunc(["KeyZ"]), (isModeA) => {
            //   const infiniteCanvas = keyboardIntegration.infiniteCanvas;
            //   if (!isModeA) {
            //     infiniteCanvas.createIcBrokenLine_start();
            //   } else {
            //     infiniteCanvas.createIcBrokenLine_end();
            //   }
            // }),

            "^": new KeyUpABToggle("^", KeyUpABToggle.defaultKeyUpFunc(["BracketLeft"]), (isModeA) => {
              const infiniteCanvas = keyboardIntegration.infiniteCanvas;
              if (!isModeA) {
                infiniteCanvas.debug_sparkleAnims(true);
              } else {
                infiniteCanvas.debug_sparkleAnims(false);
              }
            }),

            "space": new KeyUpABToggle("space", KeyUpABToggle.defaultKeyUpFunc(["Space"]), (isModeA) => {
              const infiniteCanvas = keyboardIntegration.infiniteCanvas;
              
              if(keyboardIntegration.keyDownToggles.digit1.isActive) {

                if(!isModeA) {
                  inputProperties.homeScale              = Object.assign({}, infiniteCanvas.scale);
                  infiniteCanvas.lock_homeScale_isActive = true;
                } else {
                  infiniteCanvas.lock_homeScale_isActive = false;
                }

              }

            }),

          };

        }


        configureKeyUpTriggers() {
          logger.log("logKI", "configureKeyUpTriggers");

          const keyboardIntegration = this;
          const infiniteCanvas = this.infiniteCanvas;

          const fabricIntegration = this.fabricIntegration;


          keyboardIntegration.keyUpTriggers = {
            // "XX": new KeyUpTrigger("XX", KeyUpTrigger.defaultKeyUpFunc(["KeyXX"]), () => {
            //
            // }),

            "Enter": new KeyUpTrigger("Enter", KeyUpTrigger.defaultKeyUpFunc(["Enter"]), () => {
              if(infiniteCanvas.isNumberTypingLockedMode) {
                infiniteCanvas.leaveNumberTyping();
                infiniteCanvas.isNumberTypingLockedMode = false;
              }
            }),
            "NumpadEnter": new KeyUpTrigger("NumpadEnter", KeyUpTrigger.defaultKeyUpFunc(["NumpadEnter"]), () => {
              if(infiniteCanvas.isNumberTypingLockedMode) {
                infiniteCanvas.leaveNumberTyping();
                infiniteCanvas.isNumberTypingLockedMode = false;
              }
            }),

            "KeyQ": new KeyUpTrigger("KeyQ", KeyUpTrigger.defaultKeyUpFunc(["KeyQ"]), () => {
              if (keyboardIntegration.keyDownToggles.ctrlLeft.isActive) {
                fabricIntegration.selectAll();
              } else if (keyboardIntegration.keyDownToggles.intlBackslash.isActive) {
                if(fabricIntegration.fabricCanvas.isDrawingMode) {
                  logger.log("logAdhere", "adhesiveKick");
                  infiniteCanvas.adhesive__isAdhesiveKick = true;
                } else {
                  if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                    infiniteCanvas.operateOnSelected__clippingAdhere();
                  } else {
                    infiniteCanvas.operateOnSelected__adhere();
                  }
                }
              }
            }),

            "KeyI": new KeyUpTrigger("KeyI", KeyUpTrigger.defaultKeyUpFunc(["KeyI"]), () => {
              // if(infiniteCanvas.importMode == ImportMode.Image) {

              // }

              // if (keyboardIntegration.keyDownToggles.ctrlLeft.isActive) {
              //   // FileIntegration.importVideo_p()
              //   //   .then(video => {
              //   //     infiniteCanvas.manageImport__video(video);
              //   //     keyboardIntegration.keyDownToggles.ctrlLeft.isActive = false; //force untoggle (bugfix)
              //   //   });

              //   FileIntegration.importAudio_p()
              //     .then(audio => {
              //       infiniteCanvas.manageImport__audio(audio);
              //       keyboardIntegration.keyDownToggles.ctrlLeft.isActive = false; //force untoggle (bugfix)
              //     });
                
              // }
              // else if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
              //   FileIntegration.videoFromWebcam_p()
              //     .then(video => {
              //       infiniteCanvas.manageImport__video(video);
              //       keyboardIntegration.keyDownToggles.altLeft.isActive = false;
              //     });
              // }
              // else if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
              //   FileIntegration.importImage_folder_p()
              //     .then(arr_img => {
              //       arr_img.forEach(img => {
              //         infiniteCanvas.manageImport__image(img);
              //       });
              //     });
              // }
              // else {
                FileIntegration.importImage_multiple_p()
                  .then(arr_img => {
                    arr_img.forEach(img => {
                      infiniteCanvas.manageImport__image(img);
                    });
                  });
              // }


              // FileIntegration.importText_multiple_p()
              //     .then(arr_text => {
              //       arr_text.forEach(text => {
              //         infiniteCanvas.manageImport__text(text);
              //       });
              //     });

              try {

                // FileIntegration.importHtmlObject_multiple_p()
                //   .then(arr_elObject => {
                //     arr_elObject.forEach(elObject => {
                //       logger.log("logPDF", "elObject", elObject);
                //       infiniteCanvas.manageImport__htmlObject(elObject);
                //     });
                //   });





                // FileIntegration.importPDF_multiple_p()
                //   .then(arr_dict_pdf => {
                //     arr_dict_pdf.forEach(dict_pdf => {
                //       logger.log("logPDF", "dict_pdf", dict_pdf);
                //       infiniteCanvas.manageImport__pdf(dict_pdf);
                //     });
                //   });

                //shu: this one is working 
                // FileIntegration.importPDF_multiple_p()
                // .then(arr_dict_pdf_a => {
                //   arr_dict_pdf_a.forEach(dict_pdf_a => {
                //     logger.log("logPDF", "dict_pdf_a", dict_pdf_a);
                //     infiniteCanvas.addNewPDF_a(dict_pdf_a);
                //   });
                // });



                // const doc = new jsPDF();
                // doc.setFontSize(10);
                // //page #0
                // doc.text("still_shute", 50, 50);
                
                // const x__margin         = 10;
                // const y__margin         = 10;

                // const nb_lines_per_page = 40;
                // const width__line       = 180;
                // const height__line      = 5;

                // const arr_str  = doc.splitTextToSize(str__still_shute, width__line);
                // const arr_page = Utils.partition(arr_str, nb_lines_per_page);
                // arr_page.forEach((arr_str__page) => {
                //   doc.addPage();

                //   var x = x__margin;
                //   var y = y__margin;

                //   arr_str__page.forEach((str__line) => {
                //     doc.text(str__line, x, y);
                //     y = y + height__line;
                //   });

                // });
                
                // doc.save("a4.pdf");









                // FileIntegration.importEPUB_multiple_p()
                //   .then(arr_dict_epub => {
                //     arr_dict_epub.forEach(dict_epub => {
                //       logger.log("logEPUB", "dict_epub", dict_epub);
                //       infiniteCanvas.manageImport__epub(dict_epub);
                //     });
                //   });







                // function downloadTestEpub(){
                //   const epubMaker = createTestEpub(
                //       { content: "gdfgdfg" },
                //       { content: "gdfgdfg", title: 'Preface' },
                //       { content: "gdfgdfg", title: 'It came from the desert' },
                //       { content: "gdfgdfg", title: 'No, it came from the Blue Lagoon' },
                //       { content: "gdfgdfg", title: 'Actually, it came from above' },
                //       { content: "gdfgdfg", title: 'It went back' },
                //       { content: "gdfgdfg", title: 'Note 1' },
                //       { content: "gdfgdfg", title: 'Note 2' }
                //   );

                //   epubMaker.downloadEpub();
                // }

                // function createTestEpub(header, preface, ch1, ch2, ch3, ch4, rn1, rn2) {
                //     return new EpubMaker()
                //         // .withUuid('github.com/bbottema/js-epub-maker::it-came-from::example-using-idpf-wasteland')
                //         .withTemplate('idpf-wasteland')
                //         // .withAuthor('T. Est')
                //         // .withLanguage('en-GB')
                //         // .withModificationDate(new Date(2015, 8, 7))
                //         // .withRights({
                //         //   description: 'This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.',
                //         //   license: 'http://creativecommons.org/licenses/by-sa/3.0/'
                //         // })
                //         // .withAttributionUrl('https://github.com/bbottema/js-epub-maker')
                //         // .withCover('https://rawgit.com/bbottema/js-epub-maker/master/src/test/content-for-epub/js-epub-maker-cover.jpg', {
                //         //   license: 'http://creativecommons.org/licenses/by-sa/3.0/',
                //         //   attributionUrl: 'http://www.webestools.com/web20-title-generator-logo-title-maker-online-web20-effect-reflect-free-photoshop.html'
                //         // })
                //         .withTitle('It Came From... [Example Using Waste Land Template]')
                //         .withSection(new EpubMaker.Section('frontmatter', 'frontmatter', { title: 'Title page' }, false, true)
                //             .withSubSection(new EpubMaker.Section('titlepage', 'manuscript-header', header, false, false))
                //         )
                //         .withSection(new EpubMaker.Section('bodymatter', 'bodymatter', { title: 'Start of the story' }, false, true)
                //             .withSubSection(new EpubMaker.Section(null, 'preface', preface, true, false))
                //             .withSubSection(new EpubMaker.Section(null, 'part-1', { title: 'Part 1' }, true, false)
                //                 .withSubSection(new EpubMaker.Section(null, 'chapter-1', ch1, true, false))
                //                 .withSubSection(new EpubMaker.Section(null, 'chapter-2', ch2, true, false))
                //             )
                //             .withSubSection(new EpubMaker.Section(null, 'part-2', { title: 'Part 2' }, true, false)
                //                 .withSubSection(new EpubMaker.Section(null, 'chapter-3', ch3, true, false))
                //                 .withSubSection(new EpubMaker.Section(null, 'chapter-4', ch4, true, false))
                //             )
                //         )
                //         .withSection(new EpubMaker.Section('backmatter', 'backmatter', { title: 'Notes and rest' }, false, true)
                //             .withSubSection(new EpubMaker.Section('rearnotes', 'rear-notes', { title: 'Notes on "It Came From"' }, true, false)
                //                 .withSubSection(new EpubMaker.Section('rearnote', 'rearnote-1', rn1, false, false))
                //                 .withSubSection(new EpubMaker.Section('rearnote', 'rearnote-2', rn2, false, false))
                //             )
                //         );
                // }

                // downloadTestEpub();






              } catch(err) {
                logger.log("logPDF", "err:", err);
              }

            }),

            "KeyP": new KeyUpTrigger("KeyP", KeyUpTrigger.defaultKeyUpFunc(["KeyP"]), () => {
              if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {

              } else {

                FileIntegration.importPDF_multiple_p()
                .then(arr_dict_pdf_a => {
                  arr_dict_pdf_a.forEach(dict_pdf_a => {
                    logger.log("logPDF", "dict_pdf_a", dict_pdf_a);
                    infiniteCanvas.addNewPDF_a(dict_pdf_a);
                  });
                });

              }
            }),

            "KeyS": new KeyUpTrigger("KeyS", KeyUpTrigger.defaultKeyUpFunc(["KeyS"]), () => {
              if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                //compose
                fabricIntegration.spreadSelectedObjects();
              } else {
                infiniteCanvas.manageSaveInfinishute_p()
                  .then((success) => {
                    console.log("success", success);
                  });
              }
            }),

            "KeyL": new KeyUpTrigger("KeyL", KeyUpTrigger.defaultKeyUpFunc(["KeyL"]), () => {
              if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                //lock everything
                infiniteCanvas.vitrify();
              } else if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
                //unlock everything
                infiniteCanvas.vivify();
              } else {
                //load
                FileIntegration.loadInfinishute_p()

                  //debug
                  .then(infinishute => {
                    console.log("loaded infinishute", infinishute);
                    return infinishute;
                  })

                  .then(infinishute => {
                    infiniteCanvas.manageLoadInfinishute(infinishute);
                  });
              }
            }),

            "KeyE": new KeyUpTrigger("KeyE", KeyUpTrigger.defaultKeyUpFunc(["KeyE"]), () => {
              const cursor = null;
              // fabricIntegration.activateObjectAtCursor();

              //debug
              // keyboardIntegration.infiniteCanvas.addNewGMOperator_editable("x 1");

              // keyboardIntegration.infiniteCanvas.operateOnActiveObject__export_asImg();

              if(infiniteCanvas.isTransportationMode) {
                infiniteCanvas.isTransportationMode = false;
              } else {
                keyboardIntegration.infiniteCanvas.operateOnSelected__warp();
              }
              
            }),

            "KeyF": new KeyUpTrigger("KeyF", KeyUpTrigger.defaultKeyUpFunc(["KeyF"]), () => {
              // if (keyboardIntegration.keyDownToggles.w.isActive) {
              if(fabricIntegration.fabricCanvas.isDrawingMode) {
                // keyboardIntegration.infiniteCanvas.addNewSpotPoint();
                fabricIntegration.floodFillAroundCursor();
                // fabricIntegration.floodFillAroundCursor__area_ruler();
              } else if (keyboardIntegration.keyDownToggles.zIndexEditing.isActive) {
                keyboardIntegration.infiniteCanvas.manageZIndexEditing_bringToFront();
              } else if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  // keyboardIntegration.infiniteCanvas.addNewSpotPoint();
                  keyboardIntegration.infiniteCanvas.addNewPoint();
              } else {
                if (fabricIntegration.fabricCanvas.isDrawingMode) {
                    //send brush to front
                    keyboardIntegration.infiniteCanvas.manageZIndexEditing_bringToFront();
                  } else {
                    keyboardIntegration.infiniteCanvas.addNewRect();
                  }                      
              }
            }),

            "KeyT": new KeyUpTrigger("KeyT", KeyUpTrigger.defaultKeyUpFunc(["KeyT"]), () => {
              if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                //tag
                const debug_text = "challenge.";
                keyboardIntegration.infiniteCanvas.addNewTag(debug_text);
              } else {
                //text
                const debug_text = "icText";
                // const debug_text = "return infiniteCanvas.createIcRect(trueRect);";
                // const debug_text = "scriptOutput = infiniteCanvas.createIcRect(trueRect);";
                keyboardIntegration.infiniteCanvas.addNewText(debug_text);
              }
            }),

            "KeyA": new KeyUpTrigger("KeyA", KeyUpTrigger.defaultKeyUpFunc(["KeyA"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewCircle();
            }),

            "KeyH": new KeyUpTrigger("KeyH", KeyUpTrigger.defaultKeyUpFunc(["KeyH"]), () => {
              keyboardIntegration.infiniteCanvas.addNewSnapSlot();
            }),

            "KeyR": new KeyUpTrigger("KeyR", KeyUpTrigger.defaultKeyUpFunc(["KeyR"]), () => {
              const infiniteCanvas = keyboardIntegration.infiniteCanvas;
              if(infiniteCanvas.isCombSetup) {
                infiniteCanvas.manageUpdate__comb__toggleOrientation();
              }
            }),

            // "KeyZ": new KeyUpTrigger("KeyZ", KeyUpTrigger.defaultKeyUpFunc(["KeyZ"]), () => {
            //     // FileIntegration.importImage_p()
            //     //   .then(img => {
            //     //     infiniteCanvas.addNewSparkle(img);
            //     //   });
            // }),

            // "IntlBackslash": new KeyUpTrigger("IntlBackslash", KeyUpTrigger.defaultKeyUpFunc(["IntlBackslash"]), () => {
            //     // if(fabricIntegration.fabricCanvas.isDrawingMode) {
            //     //  //toggle: adhesive drawings
            //     //  inputProperties.updateBrush__toggleAdhesive();
            //     // }
                
            //     {
            //       //toggle adhesive
            //       inputProperties.toggleAdhesive();
            //     }
            // }),

            "KeyX": new KeyUpTrigger("KeyX", KeyUpTrigger.defaultKeyUpFunc(["KeyX"]), () => {

              if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                keyboardIntegration.infiniteCanvas.operateOnSelected__punchHoleErase();
              }
              // else
              // if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
              //   const mathNode = new math.SymbolNode("x");
              //   mathNode.autoSimplify = true;
              //
              //   keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
              // }
              else
              {
                if(infiniteCanvas.isEnabled_supervessel) {
                  keyboardIntegration.infiniteCanvas.operateOnActiveObject__poopSameHomeScaleClone();
                } else {
                  keyboardIntegration.infiniteCanvas.operateOnSelected__poopSameHomeScaleClone();
                }
              }
            }),

            "KeyU": new KeyUpTrigger("KeyU", KeyUpTrigger.defaultKeyUpFunc(["KeyU"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewTouchSlot();

              // keyboardIntegration.infiniteCanvas.addNewGMOperator();

              // keyboardIntegration.infiniteCanvas.addNewGMOperator_editable("x (22/7)");

              keyboardIntegration.infiniteCanvas.addNewP2P();
            }),

            "KeyY": new KeyUpTrigger("KeyY", KeyUpTrigger.defaultKeyUpFunc(["KeyY"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewGMChallenge(0);

              if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
                const mathNode = new math.SymbolNode("y");
                mathNode.autoSimplify = true;

                keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
              }
              else {
                keyboardIntegration.infiniteCanvas.addNewStore();
              }
            }),

            "Digit1": new KeyUpTrigger("Digit1", KeyUpTrigger.defaultKeyUpFunc(["Digit1"]), () => {
              if(fabricIntegration.fabricCanvas.isDrawingMode) {
                inputProperties.brushWidth__isElastic = true;
              }
            }),

            // "Digit3": new KeyUpTrigger("Digit3", KeyUpTrigger.defaultKeyUpFunc(["Digit3"]), () => {
            //   // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify__remove_parentheses");
          
            //   // const mathNode = math.parse("3*2");
            //   // keyboardIntegration.infiniteCanvas.addNewMNReictangle(mathNode);
          
            //   // const sandBox_doubleObjects = new SandBox_doubleObjects(keyboardIntegration.infiniteCanvas);
          
            //   keyboardIntegration.infiniteCanvas.addNewToggleRect();
            // }),

            // "Digit4": new KeyUpTrigger("Digit4", KeyUpTrigger.defaultKeyUpFunc(["Digit4"]), () => {
            //   // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify__remove_parentheses");
            //   // keyboardIntegration.infiniteCanvas.operateOnActiveObject__executeScript();
          
            //   // keyboardIntegration.infiniteCanvas.operateOnActiveObject__setBehavior("stickyRelease", true);
            //   fabricIntegration.prepareSingleUseBehavior("stickyRelease");
            // }),

            // "Digit5": new KeyUpTrigger("Digit5", KeyUpTrigger.defaultKeyUpFunc(["Digit5"]), () => {
            //   // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify__remove_parentheses");
            //   // keyboardIntegration.infiniteCanvas.addNewText("=");
          
            //   fabricIntegration.linkSelectedObjects();
            // }),

            "Digit6": new KeyUpTrigger("Digit6", KeyUpTrigger.defaultKeyUpFunc(["Digit6"]), () => {
              // {
              //   // const html_elt = document.getElementById("debug_nbObjects");
              //   // const html_elt = document.body;
              //
              //
              //   const input = document.createElement("INPUT");
              //   input.setAttribute("type", "text");
              //   // input.setAttribute("text", "lolilol");
              //
              //   input.style.backgroundColor = "yellow";
              //   document.body.appendChild(input);
              //
              //   const html_elt = input;
              //
              //
              //   /*
              //   const div = document.createElement("DIV");
              //   div.style.backgroundColor = "yellow";
              //   div.style.width  = "200px";
              //   div.style.height = "200px";
              //
              //   // div.style.visibility = "hidden";
              //   // div.style.display = "none";
              //
              //   document.body.appendChild(div);
              //
              //   const html_elt = div;
              //   */
              //
              //   keyboardIntegration.infiniteCanvas.addNewHtmlElt(html_elt);
              // }

              // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("mark__slash_simplifiable");

              keyboardIntegration.infiniteCanvas.manageEnterOrLeaveRecording();
            }),

            "Digit7": new KeyUpTrigger("Digit7", KeyUpTrigger.defaultKeyUpFunc(["Digit7"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify");
              // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify__step_by_step");
              // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify__top_layer");

              // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("equation__add1");

              keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("split__top_layer");
              // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("decomposition__product_primes");

              // keyboardIntegration.infiniteCanvas.addNewGMSafetyZone();
            }),

            "Digit8": new KeyUpTrigger("Digit8", KeyUpTrigger.defaultKeyUpFunc(["Digit8"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewTouchSlot();
              // keyboardIntegration.infiniteCanvas.addNewGMTargetSlot();

              // keyboardIntegration.infiniteCanvas.addNewGMTargetTouchSlot();

              if(infiniteCanvas.isEnabled_supervessel) {
                keyboardIntegration.infiniteCanvas.operateOnActiveObject__toggleProperty("isTouchable");
              } else {
                keyboardIntegration.infiniteCanvas.operateOnSelected__toggleProperty("isTouchable");
              }
            }),

            "Digit9": new KeyUpTrigger("Digit9", KeyUpTrigger.defaultKeyUpFunc(["Digit9"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewCountdown();
              // keyboardIntegration.infiniteCanvas.addNewIcEngined_debug();

              // keyboardIntegration.infiniteCanvas.manageMoveEvent_debug();
              // keyboardIntegration.infiniteCanvas.addNewCounter();

              inputProperties.updateBrush__toggleAdhesive();
            }),

            "Digit0": new KeyUpTrigger("Digit0", KeyUpTrigger.defaultKeyUpFunc(["Digit0"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewFacet_mathNode();

              keyboardIntegration.infiniteCanvas.manageReplay_debug();
              // keyboardIntegration.infiniteCanvas.manageReplay_debug__machineGun();
            }),

            "F1": new KeyUpTrigger("F1", KeyUpTrigger.defaultKeyUpFunc(["F1"]), (e) => {
              
              e.preventDefault();

              keyboardIntegration.infiniteCanvas.operateOnSelected__crown();
            }),


            "F2": new KeyUpTrigger("F2", KeyUpTrigger.defaultKeyUpFunc(["F2"]), () => {
              const cfg = {
                isConsume: false,
              };
              keyboardIntegration.infiniteCanvas.addNewConductiveOperator_withType("randInBag", cfg);
            }),

            "F4": new KeyUpTrigger("F4", KeyUpTrigger.defaultKeyUpFunc(["F4"]), () => {
              const cfg = {
                isConsume: true,
              };
              keyboardIntegration.infiniteCanvas.addNewConductiveOperator_withType("randInBag", cfg);
            }),

            "F8": new KeyUpTrigger("F8", KeyUpTrigger.defaultKeyUpFunc(["F8"]), () => {
              const cfg = {
                min: 0,
                max: 20,
              };
              keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("rand_int", cfg);
            }),

            "F9": new KeyUpTrigger("F9", KeyUpTrigger.defaultKeyUpFunc(["F9"]), () => {
              // const cfg = {
              //   f_name: "cos",
              // };
              //
              // if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
              //   keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("function", cfg);
              // } else {
              //   keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("functionamer", cfg);
              // }

              keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("format:toFixed");
            }),

            "F10": new KeyUpTrigger("F10", KeyUpTrigger.defaultKeyUpFunc(["F10"]), () => {
              keyboardIntegration.infiniteCanvas.addNewText("=");
            }),



            "KeyJ": new KeyUpTrigger("KeyJ", KeyUpTrigger.defaultKeyUpFunc(["KeyJ"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewWell();

              {
                const cfg = {
                  index: 1,
                };
                keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("c:objectAtIndex", cfg);
              }

              // {
              //   const infiniteCanvas = keyboardIntegration.infiniteCanvas;
              //   const truePoint = infiniteCanvas.getTrueCursor();
              //   const arr_icObj = infiniteCanvas.getArr_icObj__containingPoint("free", truePoint);
              //   logger.log("logIC", "getArr_icObj__containingPoint", arr_icObj);
              // }
            }),

            "KeyN": new KeyUpTrigger("KeyN", KeyUpTrigger.defaultKeyUpFunc(["KeyN"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewComposite();
              // keyboardIntegration.infiniteCanvas.addNewGreenMouseWell();

              const truePoint = infiniteCanvas.getTrueCursor();

              //[[5]]
              const trueRect__5 = {
                x: truePoint.x,
                y: truePoint.y,
                width:  100,
                height: 100,
              };
              const mathNode__5 = new math.ConstantNode(5);
              mathNode__5.autoSimplify = true;
              const icMathNode__5 = infiniteCanvas.createIcMathNode(trueRect__5.x, trueRect__5.y, mathNode__5);

              //(spawn(5))
              const trueRect__appOp_5 = {
                x: truePoint.x,
                y: truePoint.y,
                width:  100,
                height: 100,
              };
              const appOp__spawn5 = infiniteCanvas.createIcGMApplicableOperator_withType(trueRect__appOp_5, "spawner", {
                str__spawned: icMathNode__5.mathNode.toString(),
                icObj_sample: icMathNode__5,
              });

              infiniteCanvas.addIcObject(appOp__spawn5);

            }),

            "KeyM": new KeyUpTrigger("KeyM", KeyUpTrigger.defaultKeyUpFunc(["KeyM"]), () => {
              logger.log("keyM");
              // keyboardIntegration.infiniteCanvas.addNewTouchSlot();
              // keyboardIntegration.infiniteCanvas.addNewBornAgainGreenMouse(1);

              // keyboardIntegration.infiniteCanvas.addNewRxSubject(1);
              // keyboardIntegration.infiniteCanvas.addNewLabelValue("lol", 9);

              keyboardIntegration.infiniteCanvas.operateOnActiveObject__split();     // == split supervessel cargo
            }),

            "Comma": new KeyUpTrigger("Comma", KeyUpTrigger.defaultKeyUpFunc(["Comma"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewButton();
              // keyboardIntegration.infiniteCanvas.addNewRxSubscription();

              keyboardIntegration.infiniteCanvas.operateOnActiveObject__join();     // == join supervessel cargo
            }),

            "Quote": new KeyUpTrigger("Quote", KeyUpTrigger.defaultKeyUpFunc(["Quote"]), () => {
              const tex = '\\frac{1}{x^2-1}';
              // const svgEl = TexHelper.toSvgEl(tex);
              // keyboardIntegration.infiniteCanvas.addNewSvg(svgEl);

              // keyboardIntegration.infiniteCanvas.addNewTex(tex);

              // const expression = new algebra.Expression("x");
              // expression.autoSimplify = false;
              // keyboardIntegration.infiniteCanvas.addNewExpr(expression);

              // const equation = new algebra.Equation(new algebra.Expression("x"), new algebra.Expression("3"));
              // keyboardIntegration.infiniteCanvas.addNewExpr(equation);


              /*
              // const mathNode = math.parse("1");
              const mathNode = new math.ConstantNode(1);
              // const mathNode = new math.SymbolNode("x");
              mathNode.autoSimplify = true;
              // mathNode.autoSimplify = false;
              keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
              */

              // const mathNode = random_mathNode_withDepth(4);
              // const mathNode = random_mathNode_withDepth_and_nbSymbols(4,0);
              // const mathNode = random_mathNode_withDepth_and_nbSymbols(4,1);

              // const mathNode = random_onion_mathNode(5);
              // const mathNode = random_onion_mathNode(5, false);
              // const mathNode = random_onion_mathNode(3);

              // const mathNode = random_onion_mathNode(2);
              const mathNode = random_onion_mathNode(3);
              // mathNode.autoSimplify = false;

              // const mathNode = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
              // mathNode.autoSimplify = true;

              keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
              // keyboardIntegration.infiniteCanvas.addNewGreenMouseBox(mathNode);
            }),



            "Equal": new KeyUpTrigger("Equal", KeyUpTrigger.defaultKeyUpFunc(["Equal"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewObserver();
              keyboardIntegration.infiniteCanvas.addNewClickWell(-22);
            }),

            "Minus": new KeyUpTrigger("Minus", KeyUpTrigger.defaultKeyUpFunc(["Minus"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewTrigger();
              keyboardIntegration.infiniteCanvas.addNewEye();
            }),

            "Backslash": new KeyUpTrigger("Backslash", KeyUpTrigger.defaultKeyUpFunc(["Backslash"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewEventEmitter();

              const mathNode_left = new math.SymbolNode("x");
              mathNode_left.autoSimplify = false;
              const mathNode_right = new math.ConstantNode(1);
              mathNode_right.autoSimplify = true;
              const mathNode_equation = new math.RelationalNode(["equal"], [mathNode_left, mathNode_right]);
              // mathNode_equation.params[0].autoSimplify = false;
              // mathNode_equation.params[1].autoSimplify = true;
              mathNode_equation.isEquation = true;

              const mathNode = mathNode_equation;
              keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
            }),

            "BracketRight": new KeyUpTrigger("BracketRight", KeyUpTrigger.defaultKeyUpFunc(["BracketRight"]), () => {
              // keyboardIntegration.infiniteCanvas.addNewClickWell();
              // keyboardIntegration.infiniteCanvas.addNewEventReceiver();

              // keyboardIntegration.infiniteCanvas.spawnImageCart();
              keyboardIntegration.infiniteCanvas.addNewEventReceiver();
            }),

            "KeyG": new KeyUpTrigger("KeyG", KeyUpTrigger.defaultKeyUpFunc(["KeyG"]), () => {
              if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                //compose
                fabricIntegration.composeSelectedObjects();
              } else if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
                //link
                fabricIntegration.linkSelectedObjects();
              } else {
                //group
                // fabricIntegration.groupSelectedObjects();

                //supervessel grab
                keyboardIntegration.infiniteCanvas.operateOnSupervessel__grab();
              }
            }),

            "KeyV": new KeyUpTrigger("KeyV", KeyUpTrigger.defaultKeyUpFunc(["KeyV"]), () => {
              if (keyboardIntegration.infiniteCanvas.isIOPasting) {
                //ioPaste
                keyboardIntegration.infiniteCanvas.leaveIOPasting();
              }
            }),

            "KeyB": new KeyUpTrigger("KeyB", KeyUpTrigger.defaultKeyUpFunc(["KeyB"]), () => {
              if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                //decompose
                fabricIntegration.decomposeSelectedObject();
              } 
              else if (keyboardIntegration.infiniteCanvas.isBatchPasting) {
                //batch paste
                keyboardIntegration.infiniteCanvas.leaveBatchPasting();
              } 
              else if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
                //unlink
                fabricIntegration.unlinkSelectedObjects();
              }  
              else if (keyboardIntegration.keyDownToggles.zIndexEditing.isActive) {
                keyboardIntegration.infiniteCanvas.manageZIndexEditing_sendToBack();
              } 
              else if (fabricIntegration.fabricCanvas.isDrawingMode && keyboardIntegration.infiniteCanvas.isColorPickerAvailable) {
                const fObj__cursor_p = fabricIntegration.getFObj__under_cursor_p();

                fObj__cursor_p.then((fObj) => {
                  logger.log("fObj__cursor", fObj);

                  if(fObj != null) {

                    const icObj = fObj.icObj;

                    if(icObj.type == "freeDrawing") {
                      const width     = icObj.strokeWidth;
                      const homeScale = icObj.homeScale;

                      //set input properties
                      keyboardIntegration.inputProperties.setBrushWidth(width);
                      keyboardIntegration.inputProperties.homeScale         = homeScale;
                      keyboardIntegration.inputProperties.isHomeScaleLocked = true;

                      //update current brush
                      fabricIntegration.configureFreeDrawingBrush({
                        width:     inputProperties.getActiveBrushWidth(),
                        homeScale: inputProperties.homeScale,
                        // isHomeScaleLocked: true,
                      });

                    } else {
                      //SHU TODO: apparentWidth of any object
                    }

                  } else {
                    keyboardIntegration.inputProperties.isHomeScaleLocked = false;

                    //update current brush
                    fabricIntegration.configureFreeDrawingBrush({
                      // width:     inputProperties.getActiveBrushWidth(),
                      homeScale: keyboardIntegration.infiniteCanvas.scale,
                      // isHomeScaleLocked: true,
                    });

                  }

                });

              } 
              // else {
              //   //ungroup
              //   fabricIntegration.ungroupSelectedObject();
              // }
              else {

                const true_cursor = infiniteCanvas.getTrueCursor();

                const left = true_cursor.x;
                const top = true_cursor.y;

                const width  = 400;   //"information" size
                const height = 200;

                const trueRect__platform = {
                  x: left,
                  y: top,
                  width: width,
                  height: height,
                };

                const icPlatform = infiniteCanvas.createIcPlatform(trueRect__platform);
                infiniteCanvas.addIcObject(icPlatform);

              }
            }),

            "Numpad0": new KeyUpTrigger("Numpad0", KeyUpTrigger.defaultKeyUpFunc(["Numpad0"]), () => {
              keyboardIntegration.infiniteCanvas.move_to_initial_position();
            }),

            "BackQuote": new KeyUpTrigger("BackQuote", KeyUpTrigger.defaultKeyUpFunc(["BackQuote"]), () => {
              //this key is reserved for freeDrawing
            }),

            "Semicolon": new KeyUpTrigger("Semicolon", KeyUpTrigger.defaultKeyUpFunc(["Semicolon"]), () => {
              // if(keyboardIntegration.keyDownToggles.r.isActive) {
              //   keyboardIntegration.infiniteCanvas.manageCenterRotation(-10);
              // } else {
              //   keyboardIntegration.infiniteCanvas.updateWithDOrientation(-10);
              // }

              keyboardIntegration.infiniteCanvas.addNewCollection("1..10");
            }),

            // "KeyP": new KeyUpTrigger("KeyP", KeyUpTrigger.defaultKeyUpFunc(["KeyP"]), () => {
            //   // if(keyboardIntegration.keyDownToggles.r.isActive) {
            //   //   keyboardIntegration.infiniteCanvas.manageCenterRotation(+10);
            //   // } else {
            //   //   keyboardIntegration.infiniteCanvas.updateWithDOrientation(+10);
            //   // }

            //   // keyboardIntegration.infiniteCanvas.addNewCollectionOperator("+1");
            //   // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("c:map:1",  {isCollectionOperator: true});

            //   if (keyboardIntegration.keyDownToggles.altLeft.isActive) {
            //     const mathNode = new math.SymbolNode("y");
            //     mathNode.autoSimplify = true;
            //     keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);

            //   }
            //   else {
            //     keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("c:map:", { operatorString: "+ 1" });
            //   }
            // }),

            "KeyK": new KeyUpTrigger("KeyK", KeyUpTrigger.defaultKeyUpFunc(["KeyK"]), () => {
              // function openUrlInNewTab(url){
              //   var win = window.open(url, '_blank');
              // }
              // openUrlInNewTab("https://www.qwant.com/?l=fr");

              keyboardIntegration.fabricIntegration.deleteAllObjects();
            }),

            "KeyC": new KeyUpTrigger("KeyC", KeyUpTrigger.defaultKeyUpFunc(["KeyC"]), () => {
              if(keyboardIntegration.keyDownToggles.backquote.isActive && keyboardIntegration.infiniteCanvas.isColorPickerAvailable) {
                const fColor__cursor_p = fabricIntegration.getFColor__under_cursor_p();

                fColor__cursor_p.then((fColor) => {

                  logger.log("fColor__cursor", fColor);
                  keyboardIntegration.inputProperties.setFColor__working(fColor);

                  //update current brush color
                  fabricIntegration.configureFreeDrawingBrush({
                    color: inputProperties.getActiveRgbaColorString(),
                  });

                });

              } else if (keyboardIntegration.keyDownToggles.altLeft.isActive) {

                //.isAltering-copy
                const event = null;
                fabricIntegration.copySelection(event);
              } else if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {

                keyboardIntegration.infiniteCanvas.addNewIcCanvas();

              } else {
                //coreify active object
                // keyboardIntegration.infiniteCanvas.operateOnActiveObject__coreify();
              }
            }),

            "KeyO": new KeyUpTrigger("KeyO", KeyUpTrigger.defaultKeyUpFunc(["KeyO"]), () => {
              // {
              //   const infiniteCanvas = keyboardIntegration.infiniteCanvas;
              //   logger.log("infiniteCanvas.offset", Object.assign({}, infiniteCanvas.offset));
              //   logger.log("infiniteCanvas.scale",  Object.assign({}, infiniteCanvas.scale));
              //   logger.log("infiniteCanvas.coords_initial",  Object.assign({},  infiniteCanvas.coords_initial));
              // }
              {
                keyboardIntegration.infiniteCanvas.addNewCustomizableOperator();
              }
            }),

            "Slash": new KeyUpTrigger("Slash", KeyUpTrigger.defaultKeyUpFunc(["Slash"]), () => {
              if(infiniteCanvas.getSelectedIcObj() != null) {
                if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  const icObj__selected = infiniteCanvas.getSelectedIcObj();
                  fabricIntegration.deselectAll();
                  infiniteCanvas.move_to_pov__autoPov(icObj__selected);
                }
                else 
                if(infiniteCanvas.isEnabled_supervessel) {
                  keyboardIntegration.infiniteCanvas.operateOnActiveObject__toggleProperty("mathNode.autoSimplify");
                } else {
                  keyboardIntegration.infiniteCanvas.operateOnSelected__toggleProperty("mathNode.autoSimplify");
                }
              } else {
                const position__cursor = infiniteCanvas.getTrueCursor();
                const trueRect_2 = {
                  x: position__cursor.x,
                  y: position__cursor.y,
                  width:  200,
                  height: 200,
                } 
                const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "simplify:force");
                infiniteCanvas.addIcObject(gmOperator);
              }
            }),

            "Delete": new KeyUpTrigger("Delete", KeyUpTrigger.defaultKeyUpFunc(["Delete"]), () => {
              fabricIntegration.deleteSelection();
            }),

            "Space": new KeyUpTrigger("Space", KeyUpTrigger.defaultKeyUpFunc(["Space"]), () => {
              const infiniteCanvas = keyboardIntegration.infiniteCanvas;
              if(!infiniteCanvas.isDryScrolling) {
                fabricIntegration.deselectAll();
              } else {
                infiniteCanvas.isDryScrolling = false;
              }
            }),
          };




  //         default:

  // //listen to numpad digits
  // const arr_numpad = (e.code).split("Numpad");
  // logger.log("arr_numpad", arr_numpad);
  // const code__numpad = arr_numpad[1];
  // if (code__numpad != null) {
  //   logger.log("arr_numpad[1]", arr_numpad[1]);

  //   switch (code__numpad) {
  //     case "Add":
  //       {
  //         const cfg = {
  //           isConsume: false,
  //         };
  //         keyboardIntegration.infiniteCanvas.addNewConductiveOperator_withType("+", cfg);

  //         //debug (pour les élèves en salle info)
  //         // keyboardIntegration.inputProperties.scrollProperties.step *= 2;
  //       }
  //       break;
  //     case "Subtract":
  //       {
  //         const cfg = {
  //           isConsume: false,
  //         };
  //         keyboardIntegration.infiniteCanvas.addNewConductiveOperator_withType("-", cfg);

  //         //debug (pour les élèves en salle info)
  //         // keyboardIntegration.inputProperties.scrollProperties.step /= 2;
  //       }
  //       break;
  //     case "Multiply":
  //       {
  //         const cfg = {
  //           isConsume: false,
  //         };
  //         keyboardIntegration.infiniteCanvas.addNewConductiveOperator_withType("x", cfg);
  //       }
  //       break;
  //     case "Divide":
  //       {
  //         const cfg = {
  //           isConsume: false,
  //         };
  //         keyboardIntegration.infiniteCanvas.addNewConductiveOperator_withType("/", cfg);
  //       }
  //       break;
  //     default:
  //       {
  //         const num__code = parseInt(code__numpad);
  //         logger.log("num__code", num__code);

  //         if (num__code != NaN) {
  //           const mathNode = new math.ConstantNode(num__code);
  //           mathNode.autoSimplify = true;

  //           keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
  //         }

  //       }
  //       break;
  //   }

        }

      }





      class MouseIntegration {

        constructor(canvasContainer, infiniteCanvas, inputProperties, keyboardIntegration) {

          this.infiniteCanvas  = infiniteCanvas;
          this.inputProperties = inputProperties;

          this.leftMouseDown  = false;
          this.rightMouseDown = false;

          this.keyboardIntegration = keyboardIntegration;



          this.keyDownTimeouts = {};

          this.keyUpABToggles  = {};
          this.keyUpTriggers   = {};

          
          this.configureMouseEventHandlers(canvasContainer);
        }

        // Mouse Event Handlers
        configureMouseEventHandlers(canvasContainer) {
          const mouseIntegration = this;

          const keyboardIntegration = this.keyboardIntegration;
          const inputProperties     = this.inputProperties;

          const infiniteCanvas      = this.infiniteCanvas;


          canvasContainer.addEventListener('mousedown', onMouseDown);
          canvasContainer.addEventListener('mouseup',   onMouseUp,    false);
          canvasContainer.addEventListener('mouseout',  onMouseOut,   false);
          canvasContainer.addEventListener('mousemove', onMouseMove,  false);
          canvasContainer.addEventListener('wheel',     onMouseWheel, false);

          //mouseIntegration.configureKeyDownToggles();



          function configureKeyDownTimeouts() {

            const default_timeout_delayInMs = 17; //17 ms == 60 fps
            const arrows_timeout_delayInMs  = 500;

            function create_keyDownFunc__custom_1(arr_keyCode) {
              return (e, down) => {
                var updateValue;

                if (globalsSingleton.isEditing) {
                  //ignore
                  updateValue = null;
                } else {
                  updateValue = arr_keyCode.reduce((acc, keyCode) => {
                  if (keyCode == e.code) {
                    acc = down;
                  }
                  return acc;
                }, null);
                }

                return updateValue;
              };
            }

            function getScaleAmount(factor) {
              var scaleAmount_for_100ms;
              if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                scaleAmount_for_100ms = factor * 0.3;
              } else {
                scaleAmount_for_100ms = factor * 0.1;
              }

              const scaleAmount = default_timeout_delayInMs / 100 * scaleAmount_for_100ms;
              return scaleAmount;
            }

            mouseIntegration.keyDownTimeouts = {

              // // a: new KeyDownTimeout("a", KeyDownToggle.defaultKeyDownFunc(["KeyQ"]), () => {
              // a: new KeyDownTimeout("a", create_keyDownFunc__custom_1(["KeyQ"]), () => {

              //   if (keyboardIntegration.keyDownToggles.ctrlLeft.isActive) {
              //     //ignore
              //     return;
              //   }
              //   if (keyboardIntegration.keyDownToggles.intlBackslash.isActive) {
              //     //ignore
              //     return;
              //   }

              //   const scaleAmount = getScaleAmount(-1);
              //   if(keyboardIntegration.keyDownToggles.digit1.isActive) {
              //     //craneScroll
              //     keyboardIntegration.infiniteCanvas.manageUpdate__selectedObj__homeScale__withScaleAmount(scaleAmount);
              //   } else {
              //     //zScroll
              //     keyboardIntegration.infiniteCanvas.manageUpdate__scale_withScaleAmount(scaleAmount);
              //   }
              
              // }, default_timeout_delayInMs),

              // // z: new KeyDownTimeout("z", KeyDownToggle.defaultKeyDownFunc(["KeyW"]), () => {
              // z: new KeyDownTimeout("z", create_keyDownFunc__custom_1(["KeyW"]), () => {

              //   const scaleAmount = getScaleAmount(+1);
              //   if(keyboardIntegration.keyDownToggles.digit1.isActive) {
              //     //craneScroll
              //     keyboardIntegration.infiniteCanvas.manageUpdate__selectedObj__homeScale__withScaleAmount(scaleAmount);
              //   } else {
              //     //zScroll
              //     keyboardIntegration.infiniteCanvas.manageUpdate__scale_withScaleAmount(scaleAmount);
              //   }

              // }, default_timeout_delayInMs),


              // //arrows

              // arrow_up: new KeyDownTimeout("arrow_up", KeyDownToggle.defaultKeyDownFunc(["ArrowUp"]), () => {
              //   keyboardIntegration.infiniteCanvas.operateOnSupervessel__moveStep(0, -1);
              // }, arrows_timeout_delayInMs),
              // arrow_down: new KeyDownTimeout("arrow_down", KeyDownToggle.defaultKeyDownFunc(["ArrowDown"]), () => {
              //   keyboardIntegration.infiniteCanvas.operateOnSupervessel__moveStep(0, +1);
              // }, arrows_timeout_delayInMs),
              // arrow_left: new KeyDownTimeout("arrow_left", KeyDownToggle.defaultKeyDownFunc(["ArrowLeft"]), () => {
              //   keyboardIntegration.infiniteCanvas.operateOnSupervessel__moveStep(-1, 0);
              // }, arrows_timeout_delayInMs),
              // arrow_right: new KeyDownTimeout("arrow_right", KeyDownToggle.defaultKeyDownFunc(["ArrowRight"]), () => {
              //   keyboardIntegration.infiniteCanvas.operateOnSupervessel__moveStep(+1, 0);
              // }, arrows_timeout_delayInMs),

            };

          }
          // configureKeyDownTimeouts();


          function configureKeyUpABToggles() {

            mouseIntegration.keyUpABToggles = {
              // ":": new KeyUpABToggle(":", KeyUpABToggle.defaultKeyUpFunc(["Period"]), (isModeA) => {
              //   keyboardIntegration.fabricIntegration.setAntiAliasEnabled(isModeA);
              // }),

              // // "n": new KeyUpABToggle("n", KeyUpABToggle.defaultKeyUpFunc(["KeyN"]), (isModeA) => {
              // //   keyboardIntegration.fabricIntegration.setSupervesselEnabled(isModeA);
              // // }),

              // // "d": new KeyUpABToggle("d", KeyUpABToggle.defaultKeyUpFunc(["KeyD"]), (isModeA) => {
              // //   // const infiniteCanvas = keyboardIntegration.infiniteCanvas;
              // //   // if (keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
              // //   //   if (!isModeA) {
              // //   //     infiniteCanvas.createIcLine_start();
              // //   //   } else {
              // //   //     infiniteCanvas.createIcLine_end();
              // //   //   }
              // //   // } else {
              // //   //   if (!isModeA) {
              // //   //     infiniteCanvas.createIcHUDLine_start();
              // //   //   } else {
              // //   //     infiniteCanvas.createIcHUDLine_end();
              // //   //   }
              // //   // }
              // // }),

              // // "KeyZ": new KeyUpABToggle("w", KeyUpABToggle.defaultKeyUpFunc(["KeyZ"]), (isModeA) => {
              // //   const infiniteCanvas = keyboardIntegration.infiniteCanvas;
              // //   if (!isModeA) {
              // //     infiniteCanvas.createIcBrokenLine_start();
              // //   } else {
              // //     infiniteCanvas.createIcBrokenLine_end();
              // //   }
              // // }),

              // "^": new KeyUpABToggle("^", KeyUpABToggle.defaultKeyUpFunc(["BracketLeft"]), (isModeA) => {
              //   const infiniteCanvas = keyboardIntegration.infiniteCanvas;
              //   if (!isModeA) {
              //     infiniteCanvas.debug_sparkleAnims(true);
              //   } else {
              //     infiniteCanvas.debug_sparkleAnims(false);
              //   }
              // }),

              // "space": new KeyUpABToggle("space", KeyUpABToggle.defaultKeyUpFunc(["Space"]), (isModeA) => {
              //   const infiniteCanvas = keyboardIntegration.infiniteCanvas;
                
              //   if(keyboardIntegration.keyDownToggles.digit1.isActive) {

              //     if(!isModeA) {
              //       inputProperties.homeScale              = Object.assign({}, infiniteCanvas.scale);
              //       infiniteCanvas.lock_homeScale_isActive = true;
              //     } else {
              //       infiniteCanvas.lock_homeScale_isActive = false;
              //     }

              //   }

              // }),

            };

          }
          // configureKeyUpABToggles();



          function updateKeyDownToggles(e, down) {
            const arr_keyDownToggles = Object.values(mouseIntegration.keyDownToggles);
            arr_keyDownToggles.forEach((keyDownToggle, i) => {
              logger.log("logMouse", "updateKeyDownToggles", "keyDownToggle", keyDownToggle);
              keyDownToggle.update(e, down);
            });
          }

          function updateKeyDownTimeouts(e, down) {
            const arr_keyDownTimeouts = Object.values(mouseIntegration.keyDownTimeouts);
            arr_keyDownTimeouts.forEach((keyDownTimeout, i) => {
              keyDownTimeout.update(e, down);
            });
          }

          function updateKeyUpABToggles(e) {
            const arr_keyUpABToggles = Object.values(mouseIntegration.keyUpABToggles);
            arr_keyUpABToggles.forEach((keyUpABToggle, i) => {
              keyUpABToggle.update(e);
            });
          }


          function handleKeyDownOnce(e) {
            logger.log("logMouse", "handleKeyDownOnce", "e.button", e.button);

            logger.log("globalsSingleton.isEditing", globalsSingleton.isEditing);
            //prevent initial keyDown from propagating
            // switch(e.code) {
            //   case "KeyZ":
            //   case "KeyB":
            //     {
            //       if (globalsSingleton.isEditing) {
            //         if(infiniteCanvas.isNumberTyping) {
            //           e.preventDefault();
            //         }
            //         return;
            //       }
            //     }
            //     break;

            //   // case "ShiftLeft":
            //   // case "AltLeft":
            //   //   {
            //   //     e.preventDefault();
            //   //     return;
            //   //   }
            //   //   break;

            //   default:
            //     break;
            // }

            // if (fabricIntegration.shouldIgnoreShortcutInput()) {
            //   return;
            // }

            // //ignore KeyZ
            // if(!infiniteCanvas.isNumberTyping && e.code == "KeyZ") {    //SHU: a bit complicated, it's to prevent MathQuill.mathField from starting with "w"
            //   e.preventDefault();
            // }
            updateKeyDownToggles(e, true);
            // updateKeyDownTimeouts(e, true);


            // switch (e.code) {
            //   /*
            //   // case "ShiftLeft":
            //   case "KeyZ":
            //     handleKey_Shift(e);
            //     break;
            //   // case "ControlLeft":
            //   case "KeyX":
            //     handleKey_Ctrl(e);
            //     break;
            //   */

            //   // case "AltLeft":
            //   // case "AltRight":
            //   //   keyboardIntegration.altKeyDown = true;
            //   //   break;

            //   case "KeyC":
            //     {
            //       keyboardIntegration.infiniteCanvas.isColorPickerAvailable = true;
            //     }
            //     break;
              
            //   case "KeyB":
            //     {
            //       keyboardIntegration.infiniteCanvas.isApparentWidthPickerAvailable = true;

            //       if (keyboardIntegration.keyDownToggles.ctrlLeft.isActive) {
            //           //batch paste
            //           keyboardIntegration.infiniteCanvas.enterBatchPasting();
            //       }
            //     }
            //     break;

            //   default:
            //     break;
            // }
          }










          // mouse functions
          function onMouseDown(event) {

            if(event.repeat) {
              updateKeyDownTimeouts(event, true);
            } else {
              handleKeyDownOnce(event);
              updateKeyDownTimeouts(event, true);
            }






            if (event.button == 0) {
              mouseIntegration.leftMouseDown  = true;

              // if(infiniteCanvas.isCombSetup) {
              //   infiniteCanvas.leaveCombSetup();
              // }

              if(infiniteCanvas.isZSegmentDrawingMode) {
                infiniteCanvas.manageZSegmentCreation();
              }
              
            } else if (event.button == 2) {
              mouseIntegration.rightMouseDown = true;
            }
          }

          function onMouseMove(event) {
            // logger.log("onMouseMove", "event", event);

            // update cursor with mouse position
            const cursor = {
              x: event.pageX,
              y: event.pageY,
            };
            infiniteCanvas.updateCursor(cursor);


            if (mouseIntegration.leftMouseDown) {
              // infiniteCanvas.manageCursorMove_line();

              if(infiniteCanvas.isZSegmentDrawingMode_zPointMoving) {
                const p = infiniteCanvas.getTrueCursor();

                const rep_free__zPoint__end = infiniteCanvas.getRepresented(infiniteCanvas.id__zPointMoving).r_free();
                rep_free__zPoint__end.position = p;
              }

            }
            /*else*/ if (mouseIntegration.rightMouseDown) {
              //console.log("onMouseMove", "rightMouseDown", "event", event);

              // console.log("keyboardIntegration.altKeyDown", keyboardIntegration.altKeyDown);
              // if(keyboardIntegration.keyDownToggles.r.isActive) {
              //   mouseIntegration.infiniteCanvas.manageCursorMove_rotate();
              // } else {
              //   mouseIntegration.infiniteCanvas.manageCursorMove_offset();
              // }

              // logger.log("logComb", "infiniteCanvas.isCombSetup:", infiniteCanvas.isCombSetup);
              if(!infiniteCanvas.isCombSetup) {
                var factor;
                // if (mouseIntegration.leftMouseDown) {
                //   //reverse pan
                //   factor = -1;
                // } else 
                {
                  factor = +1;
                }
                infiniteCanvas.manageCursorMove_offset(factor);
              }


            } 
            
            
            /*else*/ if (keyboardIntegration.keyDownToggles.r.isActive) {   //SHU: pourquoi ça pête ? ???

              var factor;
              if (mouseIntegration.leftMouseDown) {
                //reverse pan
                factor = -1;
              } else {
                factor = +1;
              }
              infiniteCanvas.manageCursorMove_rotate(factor);
            }

          }

          function onMouseUp(event) {
            logger.log("logMouse", "onMouseUp", event);

            updateKeyDownToggles(event, false);
            updateKeyDownTimeouts(event, false);
            updateKeyUpABToggles(event);


            if (event.button == 0) {
              // logger.log("logMouse", "onMouseUp", "event.button == 0");
              mouseIntegration.leftMouseDown  = false;

              infiniteCanvas.isReverseCombSpacing = false;

              // SHU: horrible workaround
              if(infiniteCanvas.hasBeenFreeDrawingPan) {
                logger.log("logMouse", "onMouseUp", "infiniteCanvas.hasBeenFreeDrawingPan");
                fabricIntegration.simulateMouseUpInDrawingMode(()=>{
                  infiniteCanvas.hasBeenFreeDrawingPan = false;
                });
              }

              // SHU: horrible workaround (even worse!)
              if(infiniteCanvas.hasBeenObjectHoldingPan) {
                logger.log("logMouse", "onMouseUp", "infiniteCanvas.hasBeenObjectHoldingPan");
                infiniteCanvas.hasBeenObjectHoldingPan = false;
                MouseIntegration.triggerMouseEvent(fabricIntegration.fabricCanvas.upperCanvasEl, "mousedown");
                MouseIntegration.triggerMouseEvent(fabricIntegration.fabricCanvas.upperCanvasEl, "mouseup");
              }

              if(inputProperties.brushWidth__isElastic) {
                inputProperties.restore__brushWidth();
                inputProperties.brushWidth__isElastic = false;
              }

            } else if (event.button == 2) {
              mouseIntegration.rightMouseDown = false;

              if(infiniteCanvas.isFreeDrawingPan) {
                infiniteCanvas.leavePan__freeDrawing();
              }

              if(infiniteCanvas.isObjectHoldingPan) {
                infiniteCanvas.leavePan__objectHolding();
              }

              // if(infiniteCanvas.isPreparingFreeDrawingComb) {
              // if(fabricIntegration.fabricCanvas.isDrawingMode && !mouseIntegration.leftMouseDown) {
              // if(keyboardIntegration.keyDownToggles.space.isActive) {
              if(infiniteCanvas.isCombSetup && (infiniteCanvas.step__combSetup == 1) ) {
                // this.counter__comb = this.counter__comb + 1;
                infiniteCanvas.combSetup__addBrush();
              }

              if(keyboardIntegration.keyDownToggles.c.isActive) {
                infiniteCanvas.manageApplyCommand__setActiveColor__onUnderlying();
              }

              //SHU999
              infiniteCanvas.operateOnSelected__apply();

            } else if(event.button == 3) {
              event.preventDefault();
            }

            infiniteCanvas.logCursor();
          }

          function onMouseOut(event) {
            //???
          }

          function onMouseWheel(event) {
            logger.log("logMI", "onMouseWheel:", event);

            if (keyboardIntegration.keyDownToggles.e.isActive) {
              transportationScroll(event);
            } 

            /**/else/**/ 
            if (keyboardIntegration.keyDownToggles.ctrlLeft.isActive) {
              event.preventDefault(); //kill Ctrl.scroll to control browser zoom 
              // return false;

              if(keyboardIntegration.keyDownToggles.v.isActive) {
                ioPasteScroll(event);
              } else if(keyboardIntegration.keyDownToggles.b.isActive) {
                batchPasteScroll(event);
              } else {
                //do nothing
              }

            }

            /**/else/**/ 
            if (keyboardIntegration.keyDownToggles.c.isActive && keyboardIntegration.keyDownToggles.v.isActive) {
              lightnessScroll(event);
            } 
            /**/else/**/ 
            if (keyboardIntegration.keyDownToggles.c.isActive) {
              infiniteCanvas.isColorPickerAvailable = false;    //disable colorPicker when colorScroll has been used
              colorScroll(event);
            } 
            /**/else/**/ 
            if (keyboardIntegration.keyDownToggles.v.isActive) {
              opacityScroll(event);
            } 
            /**/else/**/ 
            if (keyboardIntegration.keyDownToggles.b.isActive
                ||
                inputProperties.brushWidth__isElastic
            ) {
              infiniteCanvas.isApparentWidthPickerAvailable = false;  //disable apparentWidthPicker when brushWidthScroll has been used
              brushWidthScroll(event);
            }
            /**/else/**/ 
            if (keyboardIntegration.keyDownToggles.n.isActive) {
              valueScroll(event);
            } 
            /**/else/**/ 
            if (keyboardIntegration.keyDownToggles.space.isActive) {
              orthScroll(event);
            }

            /**/else/**/
            if(infiniteCanvas.isZSegmentDrawingMode_zPointMoving && keyboardIntegration.keyDownToggles.b.isActive) {
              zSegmentZPointEndRadiusScroll(event);
            }
            /**/else/**/ 
            if (infiniteCanvas.isZIndexEditing && keyboardIntegration.keyDownToggles.digit1.isActive) {
              zIndexEditingScroll(event);
              craneScroll(event);
            }
            /**/else/**/ 
            if (infiniteCanvas.isZIndexEditing) {
              zIndexEditingScroll(event);
            }
            /**/else/**/ 
            if (keyboardIntegration.keyDownToggles.digit1.isActive) {
              craneScroll(event);
            }
            else {
              zoomScroll(event);
            }

            function colorScroll(event) {
              const deltaY = event.deltaY;
              const screment = deltaY > 0 ? 1 : -1;
              inputProperties.setNextColor(screment);

              const rgbaColorString = inputProperties.getActiveRgbaColorString();
              infiniteCanvas.manageUpdate__color(rgbaColorString);
            }

            function opacityScroll(event) {
              const deltaY = event.deltaY;
              const screment = deltaY > 0 ? 1 : -1;
              inputProperties.setNextOpacity(screment);

              const opacity = inputProperties.getActiveOpacity();
              infiniteCanvas.manageUpdate__opacity(opacity);
            }

            function lightnessScroll(event) {
              const deltaY = event.deltaY;
              const screment = deltaY > 0 ? 1 : -1;
              inputProperties.setNextLightness(screment);

              const lightness = inputProperties.getActiveLightness();
              infiniteCanvas.manageUpdate__lightness(lightness);
            }

            function brushWidthScroll(event) {
              const deltaY = event.deltaY;
              // const screment = deltaY > 0 ? -1 : +1;
              const screment = deltaY > 0 ? +5 : -5;

              const brushWidth__new = inputProperties.resulting_brushWidth_forScrement(screment);
              inputProperties.setBrushWidth(brushWidth__new);

              infiniteCanvas.manageUpdate__brushWidth(brushWidth__new);
            }

            function valueScroll(event) {
              const deltaY   = event.deltaY;
              const screment = deltaY > 0 ? -1 : +1;

              var cfg;
              if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                cfg = {
                  type:     "pow10",
                  screment: screment,
                };
              } else {
                cfg = {
                  type:     "inc",
                  screment: screment,
                };
              }
              infiniteCanvas.manageUpdate__selectedObj__value(cfg);
            }

            function transportationScroll(event) {
              const deltaY    = event.deltaY;
              const screment  = deltaY > 0 ? 1 : -1;
              infiniteCanvas.manageTransportation(screment);
            }

            function getShiftAmount(event) {
              const deltaY = event.deltaY;
              // const scaleAmount = -deltaY / 500;
              const scroll_step = mouseIntegration.inputProperties.scrollProperties.step;
              //console.log("onMouseWheel", "scroll_step", scroll_step);
              const shiftAmount = deltaY * scroll_step;

              const shiftAmount_max = +0.99;
              const shiftAmount_min = -0.99;
              const shiftAmount_bounded = Math.min(shiftAmount_max, Math.max(shiftAmount_min, shiftAmount));

              return shiftAmount_bounded;
            }

            function orthScroll(event) {
              const shiftAmount = getShiftAmount(event);
              
              mouseIntegration.infiniteCanvas.manageUpdate__freeDrawing__orthScroll(shiftAmount);

              // //chunk update in small steps
              // const nb_microSteps = 50;
              // [...Array(nb_microSteps).keys()].forEach((i) => {
              //   const shiftAmount__chunk = shiftAmount / nb_microSteps;
              //   globalsSingleton.functionCallsQueue.add(() => {
              //     // logger.log("logOrthScroll", "chunk(" + i + ")");
              //     setTimeout(() => {
              //       mouseIntegration.infiniteCanvas.manageUpdate__freeDrawing__orthScroll(shiftAmount__chunk);
              //     }, 1);
                  
              //   });
              //   // globalsSingleton.functionCallsQueue.next();
              // });
              
            }


            function zSegmentZPointEndRadiusScroll(event) {
              const deltaY = event.deltaY;
              // const screment = deltaY > 0 ? -1 : +1;
              const screment = deltaY > 0 ? +5 : -5;

              const zPointRadius__new = inputProperties.resulting_zPointRadius_forScrement(screment);
              inputProperties.setZPointRadius(zPointRadius__new);

              infiniteCanvas.manageUpdate__zPointRadius(zPointRadius__new);
            }


            function zIndexEditingScroll(event) {
              const deltaY = event.deltaY;
              const screment = deltaY > 0 ? 1 : -1;
              infiniteCanvas.manageUpdate__zIndex_withScrement(screment);
            }

            function getScaleAmount(event) {
              const deltaY = event.deltaY;
              // const scaleAmount = -deltaY / 500;
              const scroll_step = mouseIntegration.inputProperties.scrollProperties.step;
              //console.log("onMouseWheel", "scroll_step", scroll_step);
              const scaleAmount = -deltaY * scroll_step;

              const scaleAmount_max = +0.99;
              const scaleAmount_min = -0.99;
              const scaleAmount_bounded = Math.min(scaleAmount_max, Math.max(scaleAmount_min, scaleAmount));

              return scaleAmount_bounded;
            }

            function craneScroll(event) {

              const scaleAmount = getScaleAmount(event);
              mouseIntegration.infiniteCanvas.manageUpdate__selectedObj__homeScale__withScaleAmount(scaleAmount);
            }

            function zoomScroll(event) {

              if(keyboardIntegration.keyDownToggles.space.isActive) {
                mouseIntegration.infiniteCanvas.isDryScrolling = true;
              }

              const scaleAmount = getScaleAmount(event);
              mouseIntegration.infiniteCanvas.manageUpdate__scale_withScaleAmount(scaleAmount);

              /*
              var zoom = canvas.getZoom();
              zoom *= 0.999 ** deltaY;
              // if (zoom > 20) zoom = 20;
              // if (zoom < 0.01) zoom = 0.01;
              canvas.setZoom(zoom);
              event.preventDefault();
              event.stopPropagation();
              */



              // const scale_new = scale * (1 + scaleAmount);

              /*
              // zoom the page based on where the cursor is
              var distX = event.pageX / canvas.clientWidth;
              var distY = event.pageY / canvas.clientHeight;

              // calculate how much we need to zoom
              const unitsZoomedX = trueWidth() * scaleAmount;
              const unitsZoomedY = trueHeight() * scaleAmount;

              const unitsAddLeft = unitsZoomedX * distX;
              const unitsAddTop = unitsZoomedY * distY;

              const dOffsetX = unitsAddLeft;
              const dOffsetY = unitsAddTop;

              const dOffset = {
                dx: dOffsetX,
                dy: dOffsetY,
              };

              updateScaleAndDOffset(scale_new, dOffset);
              */
            }


          }

          // function onMouseWheel(event) {
          //   const deltaY = event.deltaY;
          //   const scaleAmount = -deltaY / 500;
          //   scale = scale * (1 + scaleAmount);
          //
          //   // zoom the page based on where the cursor is
          //   var distX = event.pageX / canvas.clientWidth;
          //   var distY = event.pageY / canvas.clientHeight;
          //
          //   // calculate how much we need to zoom
          //   const unitsZoomedX = trueWidth() * scaleAmount;
          //   const unitsZoomedY = trueHeight() * scaleAmount;
          //
          //   const unitsAddLeft = unitsZoomedX * distX;
          //   const unitsAddTop = unitsZoomedY * distY;
          //
          //   offsetX -= unitsAddLeft;
          //   offsetY -= unitsAddTop;
          // }

        }


        configureKeyDownToggles() {
          const mouseIntegration = this;

          const keyboardIntegration = this.keyboardIntegration;
          const inputProperties     = this.inputProperties;

          const infiniteCanvas      = this.infiniteCanvas;


          mouseIntegration.keyDownToggles = {
            button3: new KeyDownToggle("button3", KeyDownToggle.defaultKeyDownFunc(["button3"], "button"), (isActive) => {
              logger.log("logMouse", "KeyDownToggle", "button3", "isActive:", isActive);
              
              const isCosmetic = keyboardIntegration.keyDownToggles.altLeft.isActive;
              const cfg = {
                isCosmetic: isCosmetic,
                isAdhesive: inputProperties.brushIsAdhesive,
              };
              if (isActive) {
                fabricIntegration.enterFreeDrawing(cfg);
              } else {
                fabricIntegration.leaveFreeDrawing();
              }

            }),


          };

        }

        static triggerMouseEvent(node, eventType) {
          var clickEvent = document.createEvent('MouseEvents');
          clickEvent.initEvent(eventType, true, false);
          node.dispatchEvent(clickEvent);
        }

      }

      class TouchIntegration {

        constructor(canvasContainer, infiniteCanvas, inputProperties) {
          // touch functions
          this.prevTouches = [null, null]; // up to 2 touches
          this.singleTouch = false;
          this.doubleTouch = false;

          this.configureTouchEventHandlers(canvasContainer);
        }

        configureTouchEventHandlers(canvasContainer) {
          // Touch Event Handlers
          canvasContainer.addEventListener('touchstart', onTouchStart);
          canvasContainer.addEventListener('touchend', onTouchEnd);
          canvasContainer.addEventListener('touchcancel', onTouchEnd);
          canvasContainer.addEventListener('touchmove', onTouchMove);


          function onTouchStart(event) {
            if (event.touches.length == 1) {
              this.singleTouch = true;
              this.doubleTouch = false;
            }
            if (event.touches.length >= 2) {
              this.singleTouch = false;
              this.doubleTouch = true;
            }

            // store the last touches
            this.prevTouches[0] = event.touches[0];
            this.prevTouches[1] = event.touches[1];

          }

          function onTouchMove(event) {
            // get first touch coordinates
            const touch0X = event.touches[0].pageX;
            const touch0Y = event.touches[0].pageY;
            const prevTouch0X = this.prevTouches[0].pageX;
            const prevTouch0Y = this.prevTouches[0].pageY;

            const pointTouch0 = {

            };

            const pointPrevTouch0 = {

            };

            const scaledX = toTrueX(pointTouch0);
            const scaledY = toTrueY(pointTouch0);
            const prevScaledX = toTrueX(pointPrevTouch0);
            const prevScaledY = toTrueY(pointPrevTouch0);

            if (singleTouch) {
              // add to history
              drawings.push({
                x0: prevScaledX,
                y0: prevScaledY,
                x1: scaledX,
                y1: scaledY
              })
              drawLine(prevTouch0X, prevTouch0Y, touch0X, touch0Y);
            }

            if (doubleTouch) {
              // get second touch coordinates
              const touch1X = event.touches[1].pageX;
              const touch1Y = event.touches[1].pageY;
              const prevTouch1X = prevTouches[1].pageX;
              const prevTouch1Y = prevTouches[1].pageY;

              // get midpoints
              const midX = (touch0X + touch1X) / 2;
              const midY = (touch0Y + touch1Y) / 2;
              const prevMidX = (prevTouch0X + prevTouch1X) / 2;
              const prevMidY = (prevTouch0Y + prevTouch1Y) / 2;

              // calculate the distances between the touches
              const hypot = Math.sqrt(Math.pow((touch0X - touch1X), 2) + Math.pow((touch0Y - touch1Y), 2));
              const prevHypot = Math.sqrt(Math.pow((prevTouch0X - prevTouch1X), 2) + Math.pow((prevTouch0Y - prevTouch1Y), 2));

              // calculate the screen scale change
              var zoomAmount = hypot / prevHypot;
              scale = scale * zoomAmount;
              const scaleAmount = 1 - zoomAmount;

              // calculate how many pixels the midpoints have moved in the x and y direction
              const panX = midX - prevMidX;
              const panY = midY - prevMidY;
              // scale this movement based on the zoom level
              offsetX += (panX / scale);
              offsetY += (panY / scale);

              // Get the relative position of the middle of the zoom.
              // 0, 0 would be top left.
              // 0, 1 would be top right etc.
              var zoomRatioX = midX / canvas.clientWidth;
              var zoomRatioY = midY / canvas.clientHeight;

              // calculate the amounts zoomed from each edge of the screen
              const unitsZoomedX = trueWidth() * scaleAmount;
              const unitsZoomedY = trueHeight() * scaleAmount;

              const unitsAddLeft = unitsZoomedX * zoomRatioX;
              const unitsAddTop = unitsZoomedY * zoomRatioY;

              offsetX += unitsAddLeft;
              offsetY += unitsAddTop;

              redrawCanvas();
            }
            prevTouches[0] = event.touches[0];
            prevTouches[1] = event.touches[1];
          }

          function onTouchEnd(event) {
            singleTouch = false;
            doubleTouch = false;
          }

        }



      }


    </script>





    <script>
      // disable right clicking
      document.oncontextmenu = function () {
        return false;
      }

      class State {

      }
    </script>




    <script>

      function create_iC(canvas) {
        var outDict;

        const inputProperties      = new InputProperties();

        const clipboardIntegration = new ClipboardIntegration();
        const fileIntegration      = new FileIntegration(clipboardIntegration);


        const infiniteCanvas = new InfiniteCanvas(canvas, inputProperties);
        clipboardIntegration.rx_mixedPaste.subscribe({
          next: (icObj) => {
            logger.log("rx_mixedPaste, next:", icObj);
            infiniteCanvas.addPastedIcObject(icObj);
          },
          error: (e) => {
            logger.log("rx_mixedPaste, error:", e);
          }
        });

        //connect with HUD
        infiniteCanvas.isRecording_observable.subscribe({
          next: (isRecording) => {
            logger.log("isRecording", isRecording);
            ic_HUD.setIsRecording(isRecording);
          },
        });



        // const canvas = document.getElementById("myCanvas");
        const fabricIntegration = new FabricIntegration(infiniteCanvas, inputProperties);
        fabricIntegration.clipboardIntegration = clipboardIntegration;




        //debug {
        // console.log("fabricIntegration.fabricCanvas", fabricIntegration.fabricCanvas);
        // infiniteCanvas.canvasContainer = fabricIntegration.fabricCanvas.contextTop.canvas.parentElement;
        //}

        infiniteCanvas.redrawCanvasListeners.push((redrawOccasion) => {
          fabricIntegration.redrawCanvas(redrawOccasion);
        });
        // infiniteCanvas.didAddObjectListeners.push((icObj) => {
        //   const icObj_free = icObj.r_free();
        //   fabricIntegration.addFabricObjectWithIcObj(icObj_free);
        // });
        infiniteCanvas.didAddRepresentationListeners.push((icObj_represented, icObj_representation) => {
          console.log("infiniteCanvas.didAddRepresentationListeners", icObj_represented, icObj_representation);

          const rep_official = icObj_represented.r_official();
          const rep_free     = icObj_represented.r_free();

          //debug
          if (icObj_representation == rep_free) {

            if (rep_official.type == "sparkle") {

              // const homeScale_sparkle = {
              //   X: rep_official.homeScale.X,
              //   Y: rep_official.homeScale.Y,
              // };
              const home_properties = {
                // homeScale: {
                X: rep_official.homeScale.X,
                Y: rep_official.homeScale.Y,
                // },
                orientation: rep_official.orientation,
              };



              var animation = null;

              // var homeScale_animated = {
              //   X: rep_official.homeScale.X,
              //   Y: rep_official.homeScale.Y,
              // };
              var animated_properties = {
                X: home_properties.X,
                Y: home_properties.Y,
                orientation: home_properties.orientation,
              };

              const duration_one_way = 777;
              var moment = 0;

              var timestamp_animStart = -1;

              var from = null;
              var to = null;


              function animationUpdateFunc() {
                // rep_free.homeScale = homeScale_animated;
                rep_free.homeScale = {
                  X: animated_properties.X,
                  Y: animated_properties.Y,
                };
                rep_free.orientation = animated_properties.orientation;
              }

              function createNewSparkleAnimation(old1, current, old2, new2, new1) {
                console.log("createNewSparkleAnimation");

                const duration_complement = duration_one_way - moment;

                // anime.set(homeScale_animated, current);
                anime.set(animated_properties, current);


                const animation_seam = anime({
                  // targets: homeScale_animated,
                  targets: animated_properties,
                  X: new2.X,
                  Y: new2.Y,
                  orientation: new2.orientation,

                  duration: duration_complement,
                  easing: 'easeOutSine',

                  update: animationUpdateFunc,

                  changeBegin: () => {
                    from = new1;
                    to = new2;

                    timestamp_animStart = Date.now() - moment;
                  },

                  complete: (anim) => {
                    console.log("@@@ completed");

                    //SHU: un peu sale mais comment faire autrement
                    animation = createAnimation_endless();
                    // setTimeout(() => {
                    //   animation = createAnimation_endless();
                    // }, 0);
                  },

                  autoplay: false,
                });

                function createAnimation_endless() {

                  var isForward = true;

                  const animation_endless = anime({
                    // targets: homeScale_animated,
                    // X: new1.X,
                    // Y: new1.Y,
                    targets: animated_properties,
                    X: new1.X,
                    Y: new1.Y,
                    orientation: new1.orientation,

                    direction: 'alternate',
                    easing: 'easeInOutSine',
                    loop: true,


                    autoplay: true,


                    duration: duration_one_way,
                    update: (anim) => {
                      animationUpdateFunc();
                    },

                    loopBegin: function (anim) {

                      if (isForward) {
                        from = new2;
                        to = new1;
                      } else {
                        from = new1;
                        to = new2;
                      }

                      timestamp_animStart = Date.now();
                      moment = 0;

                      isForward = !isForward;
                    },
                    // loopComplete: function(anim) {
                    //
                    // },

                  });

                  return animation_endless;
                }

                return animation_seam;
              }

              function startAnimation() {
                // animation = createNewSparkleAnimationTimeline(homeScale_sparkle, homeScale_sparkle, infiniteCanvas.scale, infiniteCanvas.scale, homeScale_sparkle);
                // animation = createNewSparkleAnimation(homeScale_sparkle, homeScale_sparkle, infiniteCanvas.scale, infiniteCanvas.scale, homeScale_sparkle);

                const from = {
                  X: home_properties.X,
                  Y: home_properties.Y,
                  orientation: home_properties.orientation,
                };
                const to = {
                  X: infiniteCanvas.scale.X,
                  Y: infiniteCanvas.scale.Y,
                  // orientation: home_properties.orientation + 180,
                  orientation: home_properties.orientation + 180 * (home_properties.X / infiniteCanvas.scale.X),
                };
                animation = createNewSparkleAnimation(from, from, to, to, from);

                rep_free.animation = animation;

                animation.play();
                // timestamp_animStart = Date.now() - moment;

              }

              function updateAnimationSeamlessly() {
                console.log("updateAnimationSeamlessly");

                if (animation != null) {
                  // console.log("animation before:", animation);

                  animation.pause();
                  // const homeScale_animated__when_paused = {
                  //   X: homeScale_animated.X,
                  //   Y: homeScale_animated.Y,
                  // };
                  // console.log("homeScale_animated__when_paused.X  ", homeScale_animated__when_paused.X);
                  const animated_properties_when_paused = {
                    X: animated_properties.X,
                    Y: animated_properties.Y,
                    orientation: animated_properties.orientation,
                  };
                  console.log("animated_properties_when_paused.X  ", animated_properties_when_paused.X);

                  const timestamp_animStop = Date.now();

                  moment = (timestamp_animStop - timestamp_animStart);
                  console.log("@@@ timestamp_animStart", timestamp_animStart);
                  console.log("@@@ timestamp_animStop ", timestamp_animStop);

                  console.log("@@@ moment", moment);


                  animation.reset();
                  animation = null;

                  // anime.set(homeScale_animated, homeScale_animated__when_paused);
                  // homeScale_animated = homeScale_animated__when_paused;
                  anime.set(animated_properties, animated_properties_when_paused);
                  animated_properties = animated_properties_when_paused;

                  const old1 = from;
                  const old2 = to;
                  var new1;
                  var new2;

                  const A = home_properties;
                  const B = {
                    X: infiniteCanvas.scale.X,
                    Y: infiniteCanvas.scale.Y,
                    // orientation: home_properties.orientation + 180,
                    orientation: home_properties.orientation + 3.6 * (home_properties.X / infiniteCanvas.scale.X),
                  };

                  if (old1 == home_properties) {
                    new1 = A;
                    new2 = B;
                  } else {
                    new1 = B;
                    new2 = A;
                  }

                  // animation = createNewSparkleAnimation(old1, homeScale_animated__when_paused, old2, new2, new1);
                  animation = createNewSparkleAnimation(old1, animated_properties_when_paused, old2, new2, new1);
                  rep_free.animation = animation;

                  animation.play();
                  // timestamp_animStart = Date.now() - moment;

                  // console.log("animation after:", animation);
                }
              }




              startAnimation();

              //listen to infiniteCanvas.scale
              infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
                // console.log("infiniteCanvas.scale.X", infiniteCanvas.scale.X);
                // console.log("infiniteCanvas.scale.Y", infiniteCanvas.scale.Y);

                const isPovTooCloseToSparkle = (home_properties.X < infiniteCanvas.scale.X);

                if (isPovTooCloseToSparkle) {
                  if (animation != null) {
                    animation.reset();
                    animation = null;
                  }
                } else {
                  if (animation != null) {
                    updateAnimationSeamlessly();
                  } else {
                    startAnimation();
                  }
                }

              });


            }
          }

          fabricIntegration.addFabricObjectWithIcObj(icObj_representation);
        });

        infiniteCanvas.didAddPureObjectListeners.push((icObj) => {
          fabricIntegration.addFabricObjectWithPureIcObj(icObj);
        });

        infiniteCanvas.onAddRepresented((represented) => {
          console.log("onAddRepresented", represented);

          // if(represented.r_official().type == "composite") {
          //   // console.log("---here---");
          //
          //   const icComposite = represented.r_official();
          // }

          // const isEngined = represented.r_official().eType != null;
          const isEngined = represented.r_official().dict_engine != null;
          if (isEngined) {
            logger.log("onAddRepresented", "/", "isEngined");

            // const icEngined = represented.r_official();
            const icEngined = represented.r_free();
            // const icEngined = represented.r_engined();     //SHU: maybe one day...

            const arr_engine__entry__sorted = Object.entries(icEngined.dict_engine).toSorted(([eType1, eMiniDict1], [eType2, eMiniDict2]) => {
              return eMiniDict1.index_start > eMiniDict2.index_start;
            });

            arr_engine__entry__sorted.forEach(([eType, eMiniDict]) => {
              logger.log("initialize", "eType", eType, eMiniDict.index_start);


              //initialize (==hydrate)
              const scopeObj = icEngined.getScopeObj(icEngined);
              scopeObj.infiniteCanvas = infiniteCanvas;

              eMiniDict.engine.initialize(scopeObj);
              console.log("icEngined.dict_engine[eType].engine.awoken.scopeObj.infiniteCanvas, after ", eMiniDict.engine.awoken.scopeObj.infiniteCanvas);


              //start
              // icEngined.engine.start();
              // icEngined.engine.start(scopeObj);
              eMiniDict.engine.awoken.start();

            });

          }

        });

        // infiniteCanvas.requestSyncWithIcObjListeners.push((icObj) => {
        //   fabricIntegration.syncWithIcObj(icObj);
        // });

        // const touch2 = new Touch2(fabricIntegration);
        // infiniteCanvas.touch2 = touch2;

        Touch2Singleton.initializeInstance(fabricIntegration);
        DiveTouchSingleton.initializeInstance(fabricIntegration);
        PortalCrossingSingleton.initializeInstance(infiniteCanvas, fabricIntegration);


        // const clipboardIntegration = new ClipboardIntegration(fileIntegration, fabricIntegration);

        const keyboardIntegration = new KeyboardIntegration(infiniteCanvas, inputProperties, fileIntegration, fabricIntegration);

        const canvasContainer  = document.getElementsByClassName("canvas-container")[0];
        const mouseIntegration = new MouseIntegration(canvasContainer, infiniteCanvas, inputProperties, keyboardIntegration);
        fabricIntegration.mouseIntegration = mouseIntegration;

        // const touchIntegration    = new TouchIntegration(canvasContainer, infiniteCanvas, inputProperties);

        outDict = {
          infiniteCanvas:         infiniteCanvas,
          fabricIntegration:      fabricIntegration,
          inputProperties:        inputProperties,
          keyboardIntegration:    keyboardIntegration,
          mouseIntegration:       mouseIntegration,
          clipboardIntegration:   clipboardIntegration,
          fileIntegration:        fileIntegration,
        };

        return outDict;
      }

      //globals               //SHU: TODO? should be incorporated to globalsSingleton
      var infiniteCanvas;
      var fabricIntegration;
      var inputProperties;
      var keyboardIntegration;
      var mouseIntegration;
      var clipboardIntegration
      var fileIntegration;

      globalsSingleton.functionCallsQueue.add(() => {
        const dict__iC = create_iC(canvas);
        infiniteCanvas       = dict__iC.infiniteCanvas;
        fabricIntegration    = dict__iC.fabricIntegration;
        inputProperties      = dict__iC.inputProperties;
        keyboardIntegration  = dict__iC.keyboardIntegration;
        mouseIntegration     = dict__iC.mouseIntegration;
        clipboardIntegration = dict__iC.clipboardIntegration;
        fileIntegration      = dict__iC.fileIntegration;
      });


    </script>


































    <script>

      class Xylophone {

        constructor(infiniteCanvas, base = 10, exponent_min = -5, exponent_max = +5) {
          this.infiniteCanvas = infiniteCanvas;

          this.base = base;
          this.exponent_min = exponent_min;
          this.exponent_max = exponent_max;

          this.xyloZones = {};

          this.activeNumber = 0;
          this.activeNumberString = "0";  //to avoid decimal <-> binary conversion issues  (0.7 != 0.7000000000000001)

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xylophone = this;
          const infiniteCanvas = this.infiniteCanvas;

          const base = this.base;
          const exponent_min = this.exponent_min;
          const exponent_max = this.exponent_max;

          const arr_exponent = [...Array(exponent_max - exponent_min + 1).keys()].map(i => (exponent_min + i));

          arr_exponent.forEach((exponent, i) => {

            const xyloZone = new XyloZone(infiniteCanvas, base, exponent);

            this.xyloZones[xyloZone.id] = xyloZone;
            xyloZone.didUpdateListeners.push((xyloZone) => {
              this.updateActiveNumber();
            });
          });

        }

        updateActiveNumber() {
          this.activeNumber = Object.values(this.xyloZones)
            .map(xyloZone => xyloZone.activeNumber)
            // .reduce((acc, x) => (acc + x), 0);
            .reduce((acc, x) => (acc.plus(x)), new Decimal(0));
          // console.log("xylophone::updateActiveNumber", this.activeNumber;
          console.log("xylophone::updateActiveNumber", this.activeNumber.toFixed());

          this.didUpdate();
        }

        didUpdate() {
          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }


        getArr_exponent() {
          return Object.values(this.xyloZones).map(xyloZone => xyloZone.exponent);
        }

        getExponent_min() {
          return Math.min(...this.getArr_exponent());
        }

        getExponent_max() {
          return Math.max(...this.getArr_exponent());
        }

      }

      class XyloZone {

        constructor(infiniteCanvas, base, exponent) {
          this.infiniteCanvas = infiniteCanvas;

          const exponentString = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
          const numberString = "" + base + "^" + exponentString;

          this.id = numberString;

          this.base = base;
          this.exponent = exponent;

          this.xylophoneTowers = {};

          this.icObjects = {};

          // this.activeNumber       = 0;
          this.activeNumber = new Decimal(0);
          this.activeNumberString = "" + this.activeNumber;

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xyloZone = this;

          const infiniteCanvas = this.infiniteCanvas;

          function activeCfgForTower(xylophoneTower) {
            var outCfg;

            outCfg = {
              fill: xylophoneTower.color,
              opacity: 1.0,
            };

            return outCfg;
          }

          function inactiveCfgForTower(xylophoneTower) {
            var outCfg;

            if (xylophoneTower.mantissa == 0) {
              outCfg = {
                fill: '',
                opacity: 1.0,
              };
            } else {
              outCfg = {
                fill: xylophoneTower.color,
                opacity: 0.3,
              };
            }

            return outCfg;
          }

          function createCanvasToggleRectForXylophoneTower(xylophoneTower) {
            const trueRect = xylophoneTower.trueRect;

            const activeCfg = activeCfgForTower(xylophoneTower);
            const inactiveCfg = inactiveCfgForTower(xylophoneTower);

            const isActive = false;

            const icToggleRect = infiniteCanvas.createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive);
            icToggleRect.canBeMoved = false;
            icToggleRect.canBeRotated = false;
            icToggleRect.canBeResized = false;
            icToggleRect.canBeSelected = true;

            return icToggleRect;
          }


          const exponent = this.exponent;
          const base = this.base;

          //zero tower
          {
            const xylophoneTower = new XylophoneTower(0, exponent, base);
            xyloZone.xylophoneTowers[xylophoneTower.mantissa] = xylophoneTower;
            xylophoneTower.didUpdateListeners.push((xylophoneTower, source) => {

              switch (source) {
                // case "view":
                //   //no sync needed
                //   xyloZone.updateWithXylophoneTowerViewUpdate(xylophoneTower);
                //   break;
                case "model":
                  //sync needed
                  xylophoneTower.icObj.isActive = xylophoneTower.isActive;
                  infiniteCanvas.requestViewUpdateForIcObj(xylophoneTower.icObj);
                  break;
              }

            });


            const icToggleRect = createCanvasToggleRectForXylophoneTower(xylophoneTower);
            icToggleRect.canBeSelected = false;

            xylophoneTower.icObj = icToggleRect;

            infiniteCanvas.addIcObject(icToggleRect);

            xylophoneTower.updateIsActive(true, "model");
          }

          //other towers
          [...Array(base - 1).keys()].forEach((item, j) => {
            const mantissa = j + 1;

            const xylophoneTower = new XylophoneTower(mantissa, exponent, base);
            xyloZone.xylophoneTowers[xylophoneTower.mantissa] = xylophoneTower;
            xylophoneTower.didUpdateListeners.push((xylophoneTower, source) => {

              switch (source) {
                case "view":
                  //no sync needed
                  xyloZone.updateWithXylophoneTowerViewUpdate(xylophoneTower);
                  break;
                case "model":
                  //sync needed
                  xylophoneTower.icObj.isActive = xylophoneTower.isActive;
                  infiniteCanvas.requestViewUpdateForIcObj(xylophoneTower.icObj);
                  break;
              }

            });

            const icToggleRect = createCanvasToggleRectForXylophoneTower(xylophoneTower);
            xylophoneTower.icObj = icToggleRect;

            infiniteCanvas.addIcObject(icToggleRect);

            icToggleRect.didUpdateListeners.push((icToggleRect) => {
              xylophoneTower.updateIsActive(icToggleRect.isActive, "view");
            });
          });




          //zone-dedicated objects

          // //number text
          // {
          //   const trueRect = this.xylophoneTowers[0].trueRect;
          //
          //   const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "lol");
          //   icText.canBeMoved    = false;
          //   icText.canBeRotated  = false;
          //   icText.canBeResized  = false;
          //   icText.canBeSelected = false;
          //
          //   const scaleFactor = (this.base ** this.exponent);
          //   console.log("number text, scaleFactor", scaleFactor);
          //
          //   icText.homeScale = {
          //     X: icText.homeScale.X / scaleFactor     * 50,
          //     Y: icText.homeScale.Y / scaleFactor     * 50,
          //   };
          //
          //   icText.fill = "yellow";
          //
          //   this.icObjects["numberDisplay"] = icText;
          //
          //   infiniteCanvas.addIcObject(icText);
          //
          //
          //   this.didUpdateListeners.push((xyloZone) => {
          //     const activeNumberString = xyloZone.activeNumber.toFixed();
          //     icText.text = activeNumberString;
          //     // infiniteCanvas.requestViewUpdateForIcObj(icText); //SHU666
          //   });
          // }


        }

        setActiveMantissa(mantissa) {
          const chosenXylophoneTower = this.xylophoneTowers[mantissa];
          chosenXylophoneTower.updateIsActive(true, "model");

          const towers_to_deactivate = Object.values(this.xylophoneTowers).filter(xylophoneTower => xylophoneTower != chosenXylophoneTower);
          towers_to_deactivate.forEach((xylophoneTower, i) => {
            xylophoneTower.updateIsActive(false, "model");
          });

          this.updateActiveNumber();

          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }

        updateWithXylophoneTowerViewUpdate(chosenXylophoneTower) {
          logger.log("updateWithXylophoneTowerViewUpdate", chosenXylophoneTower.mantissa);

          //deactivate all others
          const towers_to_deactivate = Object.values(this.xylophoneTowers).filter(xylophoneTower => xylophoneTower != chosenXylophoneTower);
          towers_to_deactivate.forEach((xylophoneTower, i) => {
            xylophoneTower.updateIsActive(false, "model");
          });

          if (chosenXylophoneTower.isActive) {

          } else {
            const zeroXylophoneTower = this.xylophoneTowers[0];
            zeroXylophoneTower.updateIsActive(true, "model");
          }

          this.updateActiveNumber();
        }

        updateActiveNumber() {
          this.activeNumber = Object.values(this.xylophoneTowers)
            .filter(xylophoneTower => xylophoneTower.isActive)
            .map(xylophoneTower => xylophoneTower.number)
            // .reduce((acc, x) => (acc + x), 0);
            .reduce((acc, x) => (acc.plus(x)), new Decimal(0));
          // console.log("xyloZone::updateActiveNumber", this.activeNumber);
          console.log("xyloZone::updateActiveNumber", this.activeNumber.toFixed());

          this.didUpdate();
        }

        didUpdate() {
          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }

        getTrueRect() {
          const zeroXylophoneTower = this.xylophoneTowers[0];
          return zeroXylophoneTower.trueRect;
        }

      }

      class XylophoneTower {

        constructor(mantissa, exponent, base) {
          const exponentString = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
          const numberString = "" + mantissa + " x " + base + "^" + exponentString;

          this.id = numberString;

          this.mantissa = mantissa;
          this.base = base;
          this.exponent = exponent;

          this.xyloBrickNumber = new XyloBrickNumber(mantissa, exponent, base);

          this.unreliable_number = mantissa * (base ** exponent);
          this.number = null;
          if (base == 10) {
            //'sharp' number (==arbitrary-precision number)
            const decimalNumberFormatString = "" + mantissa + "e" + exponent;
            this.decimal_decimalNumber = new Decimal(decimalNumberFormatString);
            // console.log("this.decimal_decimalNumber", this.decimal_decimalNumber);
            console.log("this.decimal_decimalNumber.toFixed()", this.decimal_decimalNumber.toFixed());


            this.number = this.decimal_decimalNumber;
          } else {
            //SHU TODO: 'sharp management' when base != 10 ...
            //this seems to be linked to the halting problem
            this.number = this.unreliable_number;
          }

          this.successor = (mantissa + 1) * (base ** exponent);
          // this.successorXyloBrickNumber = ;

          this.trueRect = XylophoneTower.trueRectForTower(this);
          this.color = XylophoneTower.colorForMantissa(mantissa);

          this.isActive = false;

          this.didUpdateListeners = [];
        }

        updateIsActive(isActive, source) {
          this.isActive = isActive;

          this.didUpdateListeners.forEach((listener, i) => {
            listener(this, source);
          });

        }

        static trueRectForTower(xylophoneTower) {
          var outTrueRect;

          // const BL = {
          //   x: xylophoneTower.number,
          //   y: 0,
          // };
          // const TR = {
          //   x: xylophoneTower.successor,
          //   y: xylophoneTower.number,
          // }

          if (xylophoneTower.mantissa == 0) {
            const mantissa1_number = (xylophoneTower.base ** xylophoneTower.exponent);
            const nextPower_number = (xylophoneTower.base ** (xylophoneTower.exponent + 1));
            const mantissaN_number = nextPower_number - mantissa1_number;

            outTrueRect = {
              x: mantissa1_number,
              width: nextPower_number - mantissa1_number,

              // y: -nextPower_number,
              // height: nextPower_number,

              y: - mantissaN_number,
              height: mantissaN_number,
            };
          } else {
            outTrueRect = {
              x: xylophoneTower.unreliable_number,
              y: -xylophoneTower.unreliable_number,
              width: (xylophoneTower.base ** xylophoneTower.exponent),
              height: xylophoneTower.unreliable_number,
            };
          }

          return outTrueRect;
        }

        static colorForMantissa(mantissa) {
          var outColor = null;

          switch (mantissa) {
            case 0:
              outColor = "#000000";
              break;

            case 1:
              outColor = "#FF7F0E";
              break;
            case 2:
              outColor = "#2CA02C";
              break;
            case 3:
              outColor = "#D62728";
              break;
            case 4:
              outColor = "#9467BD";
              break;
            case 5:
              outColor = "#8C564B";
              break;
            case 6:
              outColor = "#E377C2";
              break;
            case 7:
              outColor = "#7F7F7F";
              break;
            case 8:
              outColor = "#BCBD22";
              break;
            case 9:
              outColor = "#17BECF";
              break;

            //SHU TODO: colors or patterns for those:
            case 10:  //A
              outColor = "#000000";
              break;
            case 11:  //B
              outColor = "#000000";
              break;
            case 12:  //C
              outColor = "#000000";
              break;
            case 13:  //D
              outColor = "#000000";
              break;
            case 14:  //E
              outColor = "#000000";
              break;
            case 15:  //F
              outColor = "#000000";
              break;

            default:
              throw new Error("unsupported mantissa: " + mantissa);
          }

          return outColor;
        }


      }


      class XyloZonePerception {
        // class XyloZoneDecoration {

        constructor(infiniteCanvas, xyloZone) {
          this.infiniteCanvas = infiniteCanvas;
          this.xyloZone = xyloZone;

          this.trueRect = null;

          this.icObjects = {};

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xyloZonePerception = this;

          const infiniteCanvas = this.infiniteCanvas;

          const xyloZone_trueRect = xyloZonePerception.xyloZone.getTrueRect();

          //listen to xyloZone
          xyloZonePerception.xyloZone.didUpdateListeners.push((xyloZone) => {

          });

        }

        createInfiniteCanvasObjects() {

          function createCanvasToggleRectForXylophonePerception(xylophoneTower) {
            const trueRect = xylophoneTower.trueRect;

            const activeCfg = activeCfgForTower(xylophoneTower);
            const inactiveCfg = inactiveCfgForTower(xylophoneTower);

            const isActive = false;

            const icToggleRect = infiniteCanvas.createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive);
            icToggleRect.canBeMoved = false;
            icToggleRect.canBeRotated = false;
            icToggleRect.canBeResized = false;
            icToggleRect.canBeSelected = true;

            return icToggleRect;
          }

        }

        update(xyloZone) {

        }

      }


      class NumberUtils {

        static randomXylophoneNumber(base, exponent_min, exponent_max) {

          const arr_exponent = [...Array(exponent_max - exponent_min + 1).keys()].map(i => (exponent_min + i));

          const arr_xyloBrickNumber = arr_exponent.map(exponent => {
            const mantissa = Math.floor(Math.random() * 10); // returns a random integer from 0 to 9
            const xyloBrickNumber = new XyloBrickNumber(mantissa, base, exponent);
            return xyloBrickNumber;
          });

          const xylophoneNumber = new XylophoneNumber(arr_xyloBrickNumber);

          return xylophoneNumber;
        }

      }

      class XyloBrickNumber {

        constructor(mantissa, base, exponent) {
          this.mantissa = mantissa;
          this.base = base;
          this.exponent = exponent;

          this.unreliable_number = mantissa * (base ** exponent);

          // const exponentString  = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
          // const sciNumberString = "" + mantissa + " x " + base + "^" + exponentString;
          // this.sciNumberString  = numberString;
          //
          // this.decimalNumberString = DecimalBrickNumber.decimalNumberString(mantissa, base, exponent);
        }

        toDecimalNumber() {
          var outDecimal;

          if (this.base == 10) {
            //'sharp' number (==arbitrary-precision number)
            const decimalNumberFormatString = "" + this.mantissa + "e" + this.exponent;
            const decimalNumber = new Decimal(decimalNumberFormatString);

            outDecimal = decimalNumber;
          } else {
            //SHU TODO: 'sharp management' when base != 10 ...
            //this seems to be linked to the halting problem
            throw new Error("unsupported for now");
          }

          return outDecimal;
        }

        // static decimalNumberString(mantissa, base, exponent) {
        //
        // }

      }

      class XylophoneNumber {

        constructor(arr_xyloBrickNumber) {

          //check not empty
          const isEmpty = (arr_xyloBrickNumber.length == 0);

          if (isEmpty) {
            throw new Error("arr_xyloBrickNumber.length == 0");
          }

          //check same base for all
          const base = arr_xyloBrickNumber.find(e => true).base;
          const isSameBase = arr_xyloBrickNumber.every(xyloBrickNumber => (xyloBrickNumber.base == base));

          if (!isSameBase) {
            console.log("arr_xyloBrickNumber", arr_xyloBrickNumber);
            throw new Error("xyloBrickNumbers have different bases");
          }

          this.base = base;
          this.xyloBrickNumbers = arr_xyloBrickNumber.reduce((acc, xyloBrickNumber) => {
            acc[xyloBrickNumber.exponent] = xyloBrickNumber;
            // acc[xyloBrickNumber.exponent] = xyloBrickNumber.mantissa;
            return acc;
          }, {});

          this.unreliable_number = arr_xyloBrickNumber.reduce((acc, x) => (acc + x.unreliable_number), 0);
        }

        toDecimalNumber() {
          return Object.values(this.xyloBrickNumbers).reduce((acc, x) => {
            const xyloBrickDecimal = x.toDecimalNumber();
            return acc.plus(xyloBrickDecimal);
          }, new Decimal(0));
        }

        // filledToUnit() {
        //
        //   function fillNegative() {
        //     const
        //
        //   }
        //
        //   function fillPositive() {
        //
        //   }
        //
        //
        // }

        // toString() {
        //   const str = Object.keys(this.xyloBrickNumbers).reduce((acc, exponent) => {
        //
        //   }, "");
        //   return str;
        // }

        // isEqual(xylophoneNumber2) {
        //   const xylophoneNumber1 = this;
        //   const areEqual = XylophoneNumber.compare(xylophoneNumber1, xylophoneNumber2) == 0;
        //   return areEqual;
        // }
        //
        // static compare(xylophoneNumber1, xylophoneNumber2) {
        //   var outNumber;
        //
        //   const arr_keys_1 = Object.keys(xylophoneNumber1.xyloBrickNumbers);
        //
        //
        //   return outNumber;
        // }

      }
    </script>
    <!-- <script>
      const xylophone = new Xylophone(infiniteCanvas, 10);
      // const xylophone = null;
      // const xylophone = new Xylophone(infiniteCanvas, 2);    //always a bit confusing

    </script> -->

    <!-- debug -->
    <script>
      class XyloGameHUD {
        constructor(eltsDict) {
          this.eltsDict = eltsDict;
        }

        setCurrentNumberString(numberString) {
          this.eltsDict["currentNumber"].innerHTML = numberString;
        }
        setTargetNumberString(numberString) {
          this.eltsDict["targetNumber"].innerHTML = numberString;
        }
        setCompleted(completed) {
          this.eltsDict["completed"].innerHTML = completed ? "Well done !" : "";
        }
      }
    </script>

    <!-- <div id="xyloGame_container" style="position:absolute; left:0; bottom: 0; font-size: 60px; pointer-events: none;">
      <div>
        <div style="display: inline-block;">current number: </div>
        <div style="display: inline-block;" id="xyloGame_currentNumber"></div>
      </div>
      <div>
        <div style="display: inline-block;">target number: </div>
        <div style="display: inline-block;" id="xyloGame_targetNumber"></div>
      </div>
      <div>
        <div style="display: inline-block;"></div>
        <div style="display: inline-block;" id="xyloGame_completed"></div>
      </div>
    </div>
    <script>
      const xyloGameHUD_eltsDict = {
        currentNumber:  document.getElementById("xyloGame_currentNumber"),
        targetNumber:   document.getElementById("xyloGame_targetNumber"),
        completed:      document.getElementById("xyloGame_completed"),
      };
      const xyloGameHUD = new XyloGameHUD(xyloGameHUD_eltsDict);
    </script> -->


    <script>

      class XylophoneGame1_xyloWrite {

        constructor(xylophone, xyloGameHUD) {
          this.xylophone = xylophone;
          this.xyloGameHUD = xyloGameHUD;

          this.targetXylophoneNumber = null;
          this.targetNumber = null;

          this.initialize();
        }

        initialize() {
          const xylophone = this.xylophone;
          const xyloGameHUD = this.xyloGameHUD;

          const base = xylophone.base;
          const exponent_min = xylophone.getExponent_min();
          const exponent_max = xylophone.getExponent_max();
          const targetXylophoneNumber = NumberUtils.randomXylophoneNumber(base, exponent_min, exponent_max);
          // console.log("targetXylophoneNumber", targetXylophoneNumber.toDecimalNumber().toFixed());

          this.targetXylophoneNumber = targetXylophoneNumber;
          this.targetNumber = targetXylophoneNumber.toDecimalNumber();

          const targetNumberString = this.targetNumber.toFixed();
          xyloGameHUD.setTargetNumberString(targetNumberString);

          const xylophoneNumberString = xylophone.activeNumber.toFixed();
          xyloGameHUD.setCurrentNumberString(xylophoneNumberString);


          xylophone.didUpdateListeners.push((xylophone) => {
            console.log("XylophoneGame1_xyloWrite", "xylophone did update", xylophone);

            // const xylophoneNumberString = xylophone.getActiveNumberString();
            const xylophoneNumberString = xylophone.activeNumber.toFixed();
            console.log("xylophoneNumberString", xylophoneNumberString);
            xyloGameHUD.setCurrentNumberString(xylophoneNumberString);

            const numbersAreEqual = (targetNumberString == xylophoneNumberString);
            xyloGameHUD.setCompleted(numbersAreEqual);
          });
        }

      }

      class XylophoneGame2_xyloRead {

        constructor(infiniteCanvas) {

        }

      }
    </script>
    <!-- <script>
      //SHU: comment //shuxylo line for xylophone to work

      const xylophone = new Xylophone(infiniteCanvas, 10);
      // const xylophone = null;
      // const xylophone = new Xylophone(infiniteCanvas, 2);    //always a bit confusing

      if(xylophone != null) {
        const xyloWrite = new XylophoneGame1_xyloWrite(xylophone, xyloGameHUD);
      }
    </script> -->







    <script>
      class SandBox_doubleObjects {
        constructor(infiniteCanvas) {
          this.infiniteCanvas = infiniteCanvas;

          this.doubleObjects = {};

          this.initialize();
        }

        initialize() {
          const infiniteCanvas = this.infiniteCanvas;

          this.create_doubleObjects_p(infiniteCanvas)
            .then((arr_doubleObject) => {

              const dict_doubleObject = Object.fromEntries(arr_doubleObject.map(dO => [dO.id, dO]));
              Object.assign(this.doubleObjects, dict_doubleObject);

              arr_doubleObject.forEach((doubleObject, i) => {
                this.materialize_doubleObject(doubleObject, infiniteCanvas);
              });

            });

        }

        create_doubleObjects_p(infiniteCanvas) {
          var out_p;

          // //double object #1
          // {
          //   const dO_id        = "dO#1"
          //   const dO_homeScale = {
          //     X:2.0,
          //     Y:2.0,
          //   };
          //
          //   const icRect_front = infiniteCanvas.createIcRect_withLTWH(0, 0, 100, 100);
          //   icRect_front.fill  = "red";
          //   icRect_front.homeScale = dO_homeScale;
          //
          //   const icRect_back = infiniteCanvas.createIcRect_withLTWH(0, 0, 100, 100);
          //   icRect_back.fill = "blue";
          //   icRect_back.homeScale = dO_homeScale;
          //
          //   const doubleObject = new DoubleObject(dO_id, icRect_front, icRect_back);
          //
          //   this.doubleObjects[doubleObject.id] = doubleObject;
          // }

          //double object #2
          const trueRect__dO2 = {
            x: 500,
            y: 500,
            width: 1,
            height: 1,
          };
          const id__dO2 = "dO#2";
          const homeScale__dO2 = {
            X: 2.0,
            Y: 2.0,
          };

          const imgPath__front = "img/double/window_closed.png";
          const imgPath__back = "img/double/window_open.png";

          const do2_p = this.createDoubleObject__imageBased_p(trueRect__dO2, homeScale__dO2, id__dO2, imgPath__front, imgPath__back);

          const arr_p = [do2_p];

          out_p = Promise.all(arr_p);

          return out_p;
        }

        createDoubleObject__imageBased_p(trueRect, homeScale_dO, id_dO, imgPath__front, imgPath__back) {
          var out_p;

          const icObj__front_p = FileIntegration.imageFromImgSrc_p(imgPath__front)
            .then((img__front) => {
              const icObj__front = infiniteCanvas.createIcImage(trueRect.x, trueRect.y, img__front);
              // icObj__front.homeScale = homeScale_dO;
              return icObj__front;
            });
          const icObj__back_p = FileIntegration.imageFromImgSrc_p(imgPath__back)
            .then((img__back) => {
              const icObj__back = infiniteCanvas.createIcImage(trueRect.x, trueRect.y, img__back);
              // img__back.homeScale = homeScale_dO;
              return icObj__back;
            });

          const arr_p = [icObj__front_p, icObj__back_p];
          // const arr_p = [icObj__back_p, icObj__front_p];

          out_p = Promise.all(arr_p)
            .then((arr_icObj) => {
              const icObj__front = arr_icObj[0];
              const icObj__back = arr_icObj[1];
              const doubleObject = new DoubleObject(id_dO, icObj__front, icObj__back);
              return doubleObject;
            })

          return out_p;
        }

        materialize_doubleObject(doubleObject, infiniteCanvas) {
          const icObj_active = doubleObject.getActiveIcObject();
          infiniteCanvas.addIcObject(icObj_active);

          infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
            doubleObject.updateWithObservationScale(infiniteCanvas.scale);
          });

          doubleObject.didUpdateListeners.push((icObj_old, icObj_new) => {
            // infiniteCanvas.requestViewUpdateForIcObj(icObj);

            // logger.log("icObj_old", icObj_old);
            // logger.log("icObj_new", icObj_new);

            // infiniteCanvas.removeIcObject(icObj_old);
            // infiniteCanvas.addIcObject(icObj_new);

            const rep_free__old = infiniteCanvas.getRepresented(icObj_old.id).r_free();
            rep_free__old.im_dying_now = true;

            infiniteCanvas.addIcObject(icObj_new);
          });

        }

      }

      class DoubleObject {

        constructor(id, icObj_front, icObj_back) {
          this.id = id;

          this.icObj_front = icObj_front;
          this.icObj_back = icObj_back;

          logger.log("icObj_front", icObj_front);

          const factor_scaleToggle = 0.90;
          this.scale_toggle = {
            X: icObj_front.homeScale.X * factor_scaleToggle,
            Y: icObj_front.homeScale.Y * factor_scaleToggle,
          };

          // this.icObj_active = null;
          this.icObj_active = icObj_front;

          this.didUpdateListeners = [];
        }

        getActiveIcObject() {
          return this.icObj_active;
        }

        updateWithObservationScale(scale_obs) {
          logger.log("updateWithObservationScale", scale_obs);

          const icObj_active = this.getIcObjectForObservationScale(scale_obs);

          this.setActiveIcObject(icObj_active);
        }

        getIcObjectForObservationScale(scale_obs) {
          var outIcObj;

          // logger.log("scale_obs.X",    scale_obs.X);
          // logger.log("this.scale_toggle.X", this.scale_toggle.X);

          const isFar = scale_obs.X < this.scale_toggle.X && scale_obs.Y < this.scale_toggle.Y;
          // logger.log("isFar", isFar);

          if (isFar) {
            outIcObj = this.icObj_front;
          } else {
            outIcObj = this.icObj_back;
          }

          return outIcObj;
        }

        setActiveIcObject(icObj_new) {

          const icObj_old = this.icObj_active;

          if (icObj_new != icObj_old) {
            this.icObj_active = icObj_new;

            this.didUpdateListeners.forEach((listener, i) => {
              listener(icObj_old, icObj_new);
            });
          }

        }

        // didUpdate() {
        //
        // }



      }

      class ManyAnObject {

      }

        // const sandBox_doubleObjects = new SandBox_doubleObjects(infiniteCanvas);

    </script>


    <script>
      class SandBox_sparkles {
        constructor(infiniteCanvas) {
          this.infiniteCanvas = infiniteCanvas;

          this.objects = {};

          this.initialize();
        }

        initialize() {
          const infiniteCanvas = this.infiniteCanvas;

          this.initialize_objects(infiniteCanvas);

          const arr_objects = Object.values(this.objects);
          arr_objects.forEach((object, i) => {
            this.materialize_object(object, infiniteCanvas);
          });

        }

        initialize_objects(infiniteCanvas) {

          //sparkle #1
          {
            const dO_id = "dO#1"
            const dO_homeScale = {
              X: 20.0,
              Y: 20.0,
            };

            const img_sparkle = "lol";
            const icObj = infiniteCanvas.createIcImage(500, 500, img_sparkle);  //SHU: formally, sparkle could hold any icObject or even more complicated type
            icObj.homeScale = dO_homeScale;                                     //     sparkle can hold any "representable" object

            const sparkle = new Sparkle(dO_id, icObj);
            sparkle.obsScale = infiniteCanvas.scale;

            this.sparkles[sparkle.id] = sparkle;
          }

        }

        materialize_object(object, infiniteCanvas) {

          const sparkle = object;

          const icObj = sparkle.icObj;
          infiniteCanvas.addIcObject(icObj);

          infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
            sparkle.updateWithObservationScale(infiniteCanvas.scale);
          });

          sparkle.didUpdateListeners.push((sparkle) => {
            const icObj = sparkle.icObj;
            infiniteCanvas.requestViewUpdateForIcObj(icObj);
          });

        }

      }

      class Sparkle {

        constructor(id, icObj) {
          this.id = id;

          this.icObj = icObj;

          this.homeScale = Object.assign({}, icObj.homeScale);
          this.obsScale = null;

          this.didUpdateListeners = [];
        }

        updateWithObservationScale(scale_obs) {
          console.log("updateWithObservationScale", scale_obs);
          icObj.homeScale = scale_obs;
        }

        static default_sparkleImage_p() {
          const imageName = "sparkle_gradient.png";



        }

      }

        // const sandBox_sparkles = new SandBox_sparkles(infiniteCanvas);

    </script>

    <script>
      class ZPuzzle {
        constructor(infiniteCanvas) {
          this.infiniteCanvas = infiniteCanvas;

          this.objects = {
            slots: {},
            pieces: {},
          };

          this.initialize();
        }

        initialize() {
          const infiniteCanvas = this.infiniteCanvas;

          this.initialize_objects(infiniteCanvas);

          const arr_slots = Object.values(this.objects.slots);
          arr_slots.forEach((slot, i) => {
            this.materialize_slot(slot, infiniteCanvas);
          });

          const arr_pieces = Object.values(this.objects.pieces);
          arr_pieces.forEach((piece, i) => {
            this.materialize_piece(piece, infiniteCanvas);

            const slot = this.objects.slots[piece.id];
            this.bindSlotAndPiece(slot, piece);
          });

        }

        initialize_objects(infiniteCanvas) {

          //s/p #1
          {
            const id = "id_sp1";
            const icObj = infiniteCanvas.createIcRect_withLTWH(500, 500, 500, 500);
            icObj.fill = ZPuzzle.colorForNumber(1);

            const slotAndPiece = ZPuzzle.debugSlotAndPiece(id, icObj);
            this.objects.slots[id] = slotAndPiece.slot;
            this.objects.pieces[id] = slotAndPiece.piece;
            slotAndPiece.piece.icObj.position = {
              x: slotAndPiece.piece.icObj.position.x + 600,
              y: slotAndPiece.piece.icObj.position.x + 100,
            };
          }

        }



        materialize_slot(slot, infiniteCanvas) {

          const icObj = slot.icObj;
          infiniteCanvas.addIcObject(icObj);

          // infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
          //   sparkle.updateWithObservationScale(infiniteCanvas.scale);
          // });

          // sparkle.didUpdateListeners.push((sparkle) => {
          //   const icObj = sparkle.icObj;
          //   infiniteCanvas.requestViewUpdateForIcObj(icObj);
          // });

        }

        materialize_piece(piece, infiniteCanvas) {

          const icObj = piece.icObj;
          infiniteCanvas.addIcObject(icObj);

          // infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
          //   sparkle.updateWithObservationScale(infiniteCanvas.scale);
          // });

          // sparkle.didUpdateListeners.push((sparkle) => {
          //   const icObj = sparkle.icObj;
          //   infiniteCanvas.requestViewUpdateForIcObj(icObj);
          // });

        }

        bindSlotAndPiece(slot, piece) {
          piece.didUpdateListeners.push((piece) => {
            console.log("piece, didUpdate");

            console.log("piece.isSnapped:", piece.isSnapped);

            if (!piece.isSnapped) {
              slot.attemptSnapping(piece);
            } else {
              // slot.attemptUnsnapping(piece);
            }

          });
        }


        static debugSlotAndPiece(spid, icObj) {
          // const icObj_slot  = icObj.clone();


          // const icObj_slot = backingObj.inner;
          // const backingObj = BackingObject.fromObject(icObj);
          // const icObj_slot = backingObj.getNewRepresentation();
          const icObj_slot = RepresentationFactory.initial(icObj);
          icObj_slot.addOnOuterUpdate((icObj_slot) => {
            console.log("icObj_slot", "onOuterUpdate", icObj_slot);

          });

          icObj_slot.opacity = 0.2;
          const slot = new ZPuzzleSlot(spid, icObj_slot);

          // const icObj_piece = icObj.clone();
          // const icObj_piece = backingObj.getNewRepresentation();
          const icObj_piece = RepresentationFactory.initial(icObj);
          icObj_piece.addOnOuterUpdate((icObj_piece) => {
            console.log("icObj_piece", "onOuterUpdate", icObj_piece);

          });


          //debug
          ///////////////////////
          // icObj_piece.createSisterRepresentation().addOnOuterUpdate((icObj_piece) => {
          //   console.log("icObj_piece sister rep","onOuterUpdate", icObj_piece);
          //
          // });
          //
          // setTimeout(() => {
          //   console.log("setTimeout", "update icObj_piece.position");
          //   icObj_piece.position = {
          //     x: icObj_piece.position.x + 100,
          //     y: icObj_piece.position.y + 100,
          //   };
          // }, 3000);
          //
          // setTimeout(() => {
          //   console.log("setTimeout", "update icObj_piece.position");
          //   icObj_piece.position = {
          //     x: icObj_piece.position.x + 100,
          //     y: icObj_piece.position.y + 100,
          //   };
          // }, 8000);
          ////////////////////////


          const piece = new ZPuzzlePiece(spid, icObj_piece);

          const slotAndPiece = {
            slot: slot,
            piece: piece,
          };

          return slotAndPiece;
        }

        static colorForNumber(number) {
          var outColor;

          switch (number) {
            case 1:
              outColor = "#FF7F0E";
              break;
            case 2:
              outColor = "#2CA02C";
              break;
            case 3:
              outColor = "#D62728";
              break;
            case 4:
              outColor = "#9467BD";
              break;
            case 5:
              outColor = "#8C564B";
              break;
            case 6:
              outColor = "#E377C2";
              break;
            case 7:
              outColor = "#7F7F7F";
              break;
            case 8:
              outColor = "#BCBD22";
              break;
            case 9:
              outColor = "#17BECF";
              break;

            default:
              outColor = "#000000";
              break;
          }

          return outColor;
        }

      }

      class ZPuzzleSlot {

        constructor(id, icObj) {
          this.id = id;

          // this.type = "typeA";

          this.icObj = icObj;

          // this.didUpdateListeners = [];
        }

        attemptSnapping(piece) {
          console.log("attemptSnapping", piece);

          const canSnap = this.checkCanSnap(piece);

          if (canSnap) {
            console.log("can snap");
            this.snap(piece);
          } else {
            console.log("can't snap");
          }

        }

        checkCanSnap(piece) {
          var outBool;

          const slot = this;

          // const isSameType = (piece.type == slot.type);
          // if(!isSameType) {
          //   return false;
          // }

          const isSlotAllowedForPiece = piece.isAllowedSlot(slot);
          if (!isSlotAllowedForPiece) {
            return false;
          }

          const icObj_slot = slot.icObj;
          const icObj_piece = piece.icObj;

          outBool = Snap.canSnap(icObj_piece, icObj_slot);

          return outBool;
        }

        snap(piece) {
          console.log("Zslot", "snap", piece);

          piece.isSnapped = true;


          const icObj_slot = this.icObj;
          const icObj_piece = piece.icObj;

          const icObj_new = Object.assign({}, icObj_piece);
          icObj_new.position = Object.assign({}, icObj_slot.position);
          icObj_new.homeScale = Object.assign({}, icObj_slot.homeScale);
          icObj_new.scale = Object.assign({}, icObj_slot.scale);
          icObj_new.orientation = icObj_slot.orientation;

          icObj_piece.update(icObj_new, "model");
        }

      }

      class ZPuzzlePiece {

        constructor(id, icObj) {
          this.id = id;

          this.icObj = icObj;

          this.isSnapped = false;

          this.didUpdateListeners = [];

          icObj.didUpdateListeners.push((icObj) => {
            console.log("ZPuzzlePiece", "icObj didUpdate", icObj);
            this.didUpdate();
          })
        }

        didUpdate() {
          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }

        isAllowedSlot(slot) {
          var outBool;
          const piece = this;

          const isSameId = (slot.id == piece.id);
          outBool = isSameId;

          return outBool;
        }

      }






        // const zPuzzle_4pieces = ZPuzzle.default_4pieces(infiniteCanvas);
        // const zPuzzle_4pieces = new ZPuzzle(infiniteCanvas);

    </script>



    <script>

      class GolfGame1 {

        constructor(infiniteCanvas, golfGame1Config) {

          this.name = golfGame1Config.name;

          //create objects (courses)
          this.courses = Object.entries(golfGame1Config.golfCourses).reduce((acc, [golfCourseName, golfCourseConfig]) => {

            const golfCourse = new GolfCourse(infiniteCanvas, golfCourseConfig);

            acc[golfCourseName] = golfCourse;

            return acc;
          }, {});


          //add logic
          //segues

          const arr_courses = Object.values(this.courses);
          const arr_courses_from = arr_courses.slice(0, -1);
          const arr_courses_to = arr_courses.slice(1);
          const arr_courses_zipped = Utils.zip(arr_courses_from, arr_courses_to);

          this.arr_segues = arr_courses_zipped.map(([course_from, course_to]) => {
            const segueConfig = {};
            const segue = new GolfSegue(infiniteCanvas, segueConfig, course_from, course_to);
            return segue;
          });

          //steps
          // logger.log("golfGame1Config.steps", golfGame1Config.steps);
          this.steps = Object.entries(golfGame1Config.steps)
            // .filter(([stepName, stepConfig]) => (stepName != "begin" && stepName != "end"))
            .reduce((acc, [stepName, stepConfig], i) => {

              const golfCourseName = stepConfig.golfCourseName;
              const golfCourse = this.courses[golfCourseName];

              const segue = this.arr_segues[i];
              console.log("segue", segue);

              const step = new GolfStep(infiniteCanvas, stepConfig, golfCourse, segue);
              acc[stepName] = step;

              return acc;
            }, {});

        }

        static fromJson(json_golfGame) {

        }














        static mini_gameConfig_9() {
          return {
            name: "Parcours entiers relatifs",
            challenges: [
              "11,+ 5,- 2,x 7,/ 2,78;4",
              // "19,+ 1,- 9,x 6,/ 4,30;3",
              // "24,+ 1,- 1,x 7,/ 2,90;5",
              // "51,+ (-1),- (-1),x (-7),/ 4,-91;3",
              // "-9,+ 8,- 5,x (-3),/ (-2),46;5",
              // "20,+ 1,- 7,x 9,/ 3,42;4",
              // "1,+ 2,- 5,x 7,/ 2,-7;4",
              // "20,+ 4,- 6,x 6,/ 4,21;3",
              // "64,+ 8,- 2,x 5,/ 2,85;5",
            ],
          };
        }

        static gameConfig_9() {
          var outConfig;

          const mini_gameConfig_9 = GolfGame1.mini_gameConfig_9();
          const name = mini_gameConfig_9.name;

          const arr_golfStepMiniString = mini_gameConfig_9.challenges;
          // const arr_golfCourseString = GolfGame1.arr_game_9().map(str => str.split(";")[0]);

          // const courseConfig_begin = GolfCourseConfig.instance_begin();
          // const courseConfig_end   = GolfCourseConfig.instance_end();

          const config = arr_golfStepMiniString.reduce((acc, golfStepMiniString, index) => {

            const arr_str_components = golfStepMiniString.split(";");
            const golfCourseMiniString = arr_str_components[0];
            const golfStepConfigMiniString = arr_str_components[1];

            const courseConfig = GolfCourseConfig.challengeCourseConfig_fromMiniString(golfCourseMiniString);
            courseConfig.rect.x = /*(courseConfig_begin.rect.x + 2000) +*/ index * 2000;

            const courseName = "" + index;
            acc.golfCourses[courseName] = courseConfig;





            const par = golfStepConfigMiniString;
            const componentSpecs = {
              "tee": {
                ammo: 8,        //SHU: tee ammo ^^
              },
            };

            const gmItemConfig = GolfGame1.challengeGMItemConfig(courseConfig);

            const stepConfig = new GolfStepConfig("challenge", courseName, par, componentSpecs, gmItemConfig);

            acc.steps[index] = stepConfig;

            return acc;
          }, {
            name: name,
            golfCourses: {
              // "begin": courseConfig_begin,
              // "end":   courseConfig_end,
            },
            steps: {
              // "begin": GolfStepConfig.step_begin("begin"),
              // "end":   GolfStepConfig.step_end("end"),
            },
          });

          // const miniDict__golfCourses_begin_end = {
          //   "begin": courseConfig_begin,
          //   "end":   courseConfig_end,
          // };
          //
          // const miniDict__steps_begin_end = {
          //   "begin": GolfStepConfig.step_begin("begin"),
          //   "end":   GolfStepConfig.step_end("end"),
          // };

          // config.golfCourses["end"].rect.x = config.golfCourses["8"].rect.x + 2000;   //SHU: buark


          outConfig = config;

          return outConfig;
        }

        static seriousInstance(infiniteCanvas) {
          var out;

          const golfGame1Config = GolfGame1.gameConfig_9();
          // const golfGame1Config = GolfGame1.gameConfig_9__frac();

          out = new GolfGame1(infiniteCanvas, golfGame1Config);

          return out;
        }


        static challengeGMItemConfig(courseConfig) {
          // logger.log("random_challengeGMItemConfig");

          // const mathNode__initial = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
          logger.log("courseConfig", courseConfig);
          // throw new Error("please die here");
          const value__initial = courseConfig.initial;
          const mathNode__initial = new math.ConstantNode(value__initial);
          mathNode__initial.autoSimplify = true;
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");

          // const mathNode__target  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
          const value__target = courseConfig.components.hole.config.value;
          const mathNode__target = new math.ConstantNode(value__target);
          const gmItem__target = GMItem.value(mathNode__target, "target", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          // const nb_operators = 4;

          // const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {
          const arr_gmItem_operator = Object.values(courseConfig.components)
            .filter(component => component.type == "gm_operator")
            .map(component => {

              const operatorMiniString = component.config.operatorString;
              const arr_split_operatorMiniString = operatorMiniString.split(" ");
              const opString = arr_split_operatorMiniString[0];
              const valueString_b = arr_split_operatorMiniString[1];
              const value_b = Number(valueString_b);

              const op = Operator.fromOpString_binary(opString);
              const node_b = new math.ConstantNode(value_b);

              const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

              const name = operatorNodeFuncWrapper.semantics.name;
              const func = operatorNodeFuncWrapper.func;
              const specs = {
                funcWrapper: operatorNodeFuncWrapper,
              };

              const gmItem__operator = GMItem.operator(func, name, "", specs);

              // //666
              // const icObjToIcObjFunc = func;
              // const transformationFunc = (icObj) => {
              //   const icObj__new = icObjToIcObjFunc(icObj);
              //   const transformationOutput = new TransformationOutput("mutated", icObj__new, icObj);
              //   return transformationOutput;
              // };
              // const gmItem__operator = GMItem.operator(transformationFunc, name, "");

              return gmItem__operator;
            });

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,
            operators: arr_gmItem_operator,
          };

          return gmItemConfig;
        }

      }

      class GolfObject {

        constructor(type, icObj) {
          this.type = type;
          this.icObj = icObj;
        }

      }


      class GolfCourseConfig {

        constructor(rect, componentsConfig) {
          this.rect = rect;
          this.componentsConfig = componentsConfig;
        }

        static instance_begin(titleString) {
          var outCourseConfig;

          const courseConfig = GolfCourseConfig.template_begin();

          courseConfig.components.title.config.text = titleString;

          outCourseConfig = courseConfig;

          return outCourseConfig;
        }

        static instance_end(titleString) {
          var outCourseConfig;

          const courseConfig = GolfCourseConfig.template_end();

          courseConfig.components.title.config.text = titleString;

          outCourseConfig = courseConfig;

          return outCourseConfig;
        }

        // static instance_challenge() {
        //
        // }

        static get_size__challenge_area() {
          const size__challenge_area = {
            width:  1600 * (2.0/1.6),
            height: 1000 * (2.0/1.6),
          };
          return size__challenge_area;
        }

        static template_begin() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
              },
              rect_rel: {
                l: 0.0,
                r: 1.0,
                t: 0.0,
                b: 1.0,
              },
            },

            "title": {
              type: "rect",
              zIndex: 0,
              config: {
                // fill: "green",
                fill: "almond",
                text: "<title>",
              },
              rect_rel: {
                l: 0.2,
                r: 0.8,
                t: 0.2,
                b: 0.4,
              },
            },

            "button_start": {
              type: "button",
              zIndex: 20,
              config: {
                // fill: "green",
                fill: "almond",
                text: "<start>",
              },
              rect_rel: {
                l: 0.2,
                r: 0.8,
                t: 0.6,
                b: 0.8,
              },
            },
          };

          const config = {
            rect: {
              x: 0,
              y: 0,
              width:  GolfCourseConfig.get_size__challenge_area().width,
              height: GolfCourseConfig.get_size__challenge_area().height,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }

        static template_end() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                fill: "orange",

              },
              rect_rel: {
                l: 0.0,
                r: 1.0,
                t: 0.0,
                b: 1.0,
              },
            },

            "title": {
              type: "rect",
              zIndex: 0,
              config: {
                // fill: "green",
                fill: "almond",
                text: "<title>",
              },
              rect_rel: {
                l: 0.2,
                r: 0.8,
                t: 0.2,
                b: 0.4,
              },
            },

            "total_score": {
              type: "labelValue",
              zIndex: 0,
              config: {
                // fill: "green",
                fill: "almond",
                text: "total score:",
              },
              rect_rel: {
                l: 0.3,
                r: 0.7,
                t: 0.3,
                b: 0.5,
              },
            },

            "total_par": {
              type: "labelValue",
              zIndex: 0,
              config: {
                // fill: "green",
                fill: "almond",
                text: "total par:",
              },
              rect_rel: {
                l: 0.3,
                r: 0.7,
                t: 0.5,
                b: 0.8,
              },
            },

            // "medal": {
            //   type: "img",
            //   zIndex: 0,
            //   config: {
            //     // fill: "green",
            //     fill: "almond",
            //   },
            //   rect_rel: {
            //     l: 0.7,
            //     r: 0.9,
            //     t: 0.3,
            //     b: 0.6,
            //   },
            // },

          };

          const config = {
            rect: {
              x: 0,
              y: 0,
              width:  GolfCourseConfig.get_size__challenge_area().width,
              height: GolfCourseConfig.get_size__challenge_area().height,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }

        static template_challenge(cfg_in = {}) {
          var outConfig;

          var cfg;
          if(cfg_in != null) {
            cfg = cfg_in; 
          } else {
            cfg = {
              isEq: false,
            };
          }

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
                fill: "lightyellow",
              },
              // rect_rel: {
              //   l: 0.0,
              //   r: 1.0,
              //   t: 0.0,
              //   b: 1.0,
              // },
              rect_rel: {
                l: 0.0 - 0.2,
                r: 1.0 + 0.2,
                t: 0.0 - 0.2,
                b: 1.0 + 0.2,
              },
              // rect_rel: {
              //   l: 0.0 - 0.5,
              //   r: 1.0 + 0.5,
              //   t: 0.0 - 0.5,
              //   b: 1.0 + 0.5,
              // },
            },

            "tee": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.40,
                b: 0.50,
              },
            },

            // "bumpers": {
            "bumper1": {
              type: "gm_operator",
              zIndex: 51,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
              },
              // rect_rel: {
              //   l: 0.15,
              //   r: 0.25,
              //   t: 0.80,
              //   b: 0.90,
              // },
              rect_rel: {
                l: -0.10,
                r:  0.0,
                t:  0.80,
                b:  0.90,
              },
            },
            "bumper2": {
              type: "gm_operator",
              zIndex: 52,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
              },
              // rect_rel: {
              //   l: 0.35,
              //   r: 0.45,
              //   t: 0.80,
              //   b: 0.90,
              // },
              rect_rel: {
                l: 0.20,
                r: 0.30,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper3": {
              type: "gm_operator",
              zIndex: 53,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
              },
              // rect_rel: {
              //   l: 0.55,
              //   r: 0.65,
              //   t: 0.80,
              //   b: 0.90,
              // },
              rect_rel: {
                l: 0.50,
                r: 0.60,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper4": {
              type: "gm_operator",
              zIndex: 54,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
              },
              // rect_rel: {
              //   l: 0.75,
              //   r: 0.85,
              //   t: 0.80,
              //   b: 0.90,
              // },
              rect_rel: {
                l: 0.80,
                r: 0.90,
                t: 0.80,
                b: 0.90,
              },
            },
            // },




            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          //add/overwrite some props for equation challenges
          if(cfg.isEq) {
            components.banner = {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgray",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: -0.15,
                b: -0.05,
              },
            };

            components.hole.type = "gm_eq_targetTouchSlot";
          }

          if(cfg.arr_component__additional != null) {
            cfg.arr_component__additional.forEach((str__component) => {
              switch(str__component) {
                case "pre_validation":
                  {
                    components[str__component] = {
                      type:  "gm_operator",
                      oType: "pre_validation",
                      zIndex: 100,
                      config: {
                        operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
                      },
                      rect_rel: {
                        l: components["hole"].rect_rel.l - 0.10,
                        r: components["hole"].rect_rel.r - 0.10,
                        t: components["hole"].rect_rel.t,
                        b: components["hole"].rect_rel.b,
                      },
                    }
                  }
                  break;
                default:
                  {
                    throw new Error("Unsupported component:", str__component);
                  }
                  break;
              }
            });
          }

          if(cfg.layout__op == "waveform") {

            function mutateToLayoutWaveform(arr_component) {
              arr_component.filter((_,i) => i%2==0).forEach((component) => {
                component.rect_rel.t += 0.10;
                component.rect_rel.b += 0.10;
              });
              arr_component.filter((_,i) => i%2==1).forEach((component) => {
                component.rect_rel.t -= 0.10;
                component.rect_rel.b -= 0.10;
              });
            }
            
            const arr_component__bottom = [
              components.bumper1, 
              components.bumper2, 
              components.bumper3, 
              components.bumper4,
            ];

            mutateToLayoutWaveform(arr_component__bottom);
            
            if("operatorWallPlaceholder1" in components) {
              const arr_component__top = [
                components.operatorWallPlaceholder1, 
                components.operatorWallPlaceholder2,
                components.operatorWallPlaceholder3,
                components.operatorWallPlaceholder4,
              ];

              mutateToLayoutWaveform(arr_component__top);
            }

          }

          const config = {
            rect: {
              x: 0,
              y: 0,
              width:  GolfCourseConfig.get_size__challenge_area().width,
              height: GolfCourseConfig.get_size__challenge_area().height,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }

        static template_challenge_with_placeholders(cfg_in = {}) {
          var outConfig;

          var cfg;
          if(cfg_in != null) {
            cfg = cfg_in; 
          } else {
            cfg = {
              isEq: false,
            };
          }

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
                fill: "lightyellow",
              },
              // rect_rel: {
              //   l: 0.0,
              //   r: 1.0,
              //   t: 0.0,
              //   b: 1.0,
              // },
              rect_rel: {
                l: 0.0 - 0.2,
                r: 1.0 + 0.2,
                t: 0.0 - 0.2,
                b: 1.0 + 0.2,
              },
            },

            "tee": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.40,
                b: 0.50,
              },
            },

            // "bumpers": {
            "bumper1": {
              type: "gm_operator",
              zIndex: 51,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
              },
              // rect_rel: {
              //   l: 0.15,
              //   r: 0.25,
              //   t: 0.80,
              //   b: 0.90,
              // },
              rect_rel: {
                l: -0.10,
                r:  0.0,
                t:  0.80,
                b:  0.90,
              },
            },
            "bumper2": {
              type: "gm_operator",
              zIndex: 52,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
              },
              // rect_rel: {
              //   l: 0.35,
              //   r: 0.45,
              //   t: 0.80,
              //   b: 0.90,
              // },
              rect_rel: {
                l: 0.20,
                r: 0.30,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper3": {
              type: "gm_operator",
              zIndex: 53,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
              },
              // rect_rel: {
              //   l: 0.55,
              //   r: 0.65,
              //   t: 0.80,
              //   b: 0.90,
              // },
              rect_rel: {
                l: 0.50,
                r: 0.60,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper4": {
              type: "gm_operator",
              zIndex: 54,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
              },
              // rect_rel: {
              //   l: 0.75,
              //   r: 0.85,
              //   t: 0.80,
              //   b: 0.90,
              // },
              rect_rel: {
                l: 0.80,
                r: 0.90,
                t: 0.80,
                b: 0.90,
              },
            },
            // },

            "operatorWallPlaceholder1": {
              type: "placeholder",
              zIndex: 55,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: -0.10,
                r:  0.0,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder2": {
              type: "placeholder",
              zIndex: 56,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.20,
                r: 0.30,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder3": {
              type: "placeholder",
              zIndex: 57,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.50,
                r: 0.60,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder4": {
              type: "placeholder",
              zIndex: 58,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.80,
                r: 0.90,
                t: 0.10,
                b: 0.20,
              },
            },


            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          //add/overwrite some props for equation challenges
          if(cfg.isEq) {
            components.banner = {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgray",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: -0.15,
                b: -0.05,
              },
            };

            components.hole.type = "gm_eq_targetTouchSlot";
          }

          if(cfg.layout__op == "waveform") {

            function mutateToLayoutWaveform(arr_component) {
              arr_component.filter((_,i) => i%2==0).forEach((component) => {
                component.rect_rel.t += 0.10;
                component.rect_rel.b += 0.10;
              });
              arr_component.filter((_,i) => i%2==1).forEach((component) => {
                component.rect_rel.t -= 0.10;
                component.rect_rel.b -= 0.10;
              });
            }
            
            const arr_component__bottom = [
              components.bumper1, 
              components.bumper2, 
              components.bumper3, 
              components.bumper4,
            ];

            mutateToLayoutWaveform(arr_component__bottom);
            
            if("operatorWallPlaceholder1" in components) {
              const arr_component__top = [
                components.operatorWallPlaceholder1, 
                components.operatorWallPlaceholder2,
                components.operatorWallPlaceholder3,
                components.operatorWallPlaceholder4,
              ];

              mutateToLayoutWaveform(arr_component__top);
            }

          }

          const config = {
            rect: {
              x: 0,
              y: 0,
              width:  GolfCourseConfig.get_size__challenge_area().width,
              height: GolfCourseConfig.get_size__challenge_area().height,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }

        static template_challenge_with_placeholders__5(cfg_in = {}) {
          var outConfig;

          var cfg;
          if(cfg_in != null) {
            cfg = cfg_in; 
          } else {
            cfg = {
              isEq: false,
            };
          }

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
                fill: "lightyellow",
              },
              // rect_rel: {
              //   l: 0.0,
              //   r: 1.0,
              //   t: 0.0,
              //   b: 1.0,
              // },
              rect_rel: {
                l: 0.0 - 0.2,
                r: 1.0 + 0.2,
                t: 0.0 - 0.2,
                b: 1.0 + 0.2,
              },
            },

            "tee": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.40,
                b: 0.50,
              },
            },

            // "bumpers": {
            "bumper1": {
              type: "gm_operator",
              zIndex: 51,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper2": {
              type: "gm_operator",
              zIndex: 52,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
              },
              rect_rel: {
                l: 0.25,
                r: 0.35,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper3": {
              type: "gm_operator",
              zIndex: 53,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
              },
              rect_rel: {
                l: 0.45,
                r: 0.55,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper4": {
              type: "gm_operator",
              zIndex: 54,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
              },
              rect_rel: {
                l: 0.65,
                r: 0.75,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper5": {
              type: "gm_operator",
              zIndex: 55,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
              },
              rect_rel: {
                l: 0.90,
                r: 1.00,
                t: 0.80,
                b: 0.90,
              },
            },
            // },

            "operatorWallPlaceholder1": {
              type: "placeholder",
              zIndex: 56,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder2": {
              type: "placeholder",
              zIndex: 57,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.25,
                r: 0.35,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder3": {
              type: "placeholder",
              zIndex: 58,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.45,
                r: 0.55,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder4": {
              type: "placeholder",
              zIndex: 59,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.65,
                r: 0.75,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder5": {
              type: "placeholder",
              zIndex: 60,
              config: {
                fill: "gray",
              },
              rect_rel: {
                l: 0.90,
                r: 1.00,
                t: 0.10,
                b: 0.20,
              },
            },


            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          //add/overwrite some props for equation challenges
          if(cfg.isEq) {
            components.banner = {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgray",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: -0.15,
                b: -0.05,
              },
            };

            components.hole.type = "gm_eq_targetTouchSlot";
          }

          const config = {
            rect: {
              x: 0,
              y: 0,
              width:  GolfCourseConfig.get_size__challenge_area().width,
              height: GolfCourseConfig.get_size__challenge_area().height,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }

        static template_challenge_with_refresh(cfg_in = {}) {
          var outConfig;

          outConfig = this.template_challenge(cfg_in);

          outConfig.components.refresh = {
            type: "button",
            zIndex: 100,
            config: {
              fill: "lightgray",
            },
            rect_rel: {
              l: 0.90,
              r: 0.95,
              t: 0.05,
              b: 0.10,
            },
          };

          return outConfig;
        }


        static template_challenge_only2(cfg_in = {}) {
          var outConfig;

          var cfg;
          if(cfg_in != null) {
            cfg = cfg_in; 
          } else {
            cfg = {
              isEq: false,
            };
          }

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
                fill: "lightyellow",
              },
              // rect_rel: {
              //   l: 0.0,
              //   r: 1.0,
              //   t: 0.0,
              //   b: 1.0,
              // },
              rect_rel: {
                l: 0.0 - 0.2,
                r: 1.0 + 0.2,
                t: 0.0 - 0.2,
                b: 1.0 + 0.2,
              },
            },

            "tee": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.40,
                b: 0.50,
              },
            },

            // "bumpers": {
              "bumper1": {
                type: "gm_operator",
                zIndex: 51,
                config: {
                  operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
                },  
                rect_rel: {
                  l: 0.30,
                  r: 0.40,
                  t: 0.80,
                  b: 0.90,
                },
              },
              "bumper2": {
                type: "gm_operator",
                zIndex: 52,
                config: {
                  operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
                },
                rect_rel: {
                  l: 0.60,
                  r: 0.70,
                  t: 0.80,
                  b: 0.90,
                },
              },
            // },




            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          //add/overwrite some props for equation challenges
          if(cfg.isEq) {
            components.banner = {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgray",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: -0.15,
                b: -0.05,
              },
            };

            components.hole.type = "gm_eq_targetTouchSlot";
          }

          const config = {
            rect: {
              x:           0,
              y:           0,
              width:  GolfCourseConfig.get_size__challenge_area().width,
              height: GolfCourseConfig.get_size__challenge_area().height,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }

        static template_challenge_only3() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
                fill: "lightyellow",
              },
              // rect_rel: {
              //   l: 0.0,
              //   r: 1.0,
              //   t: 0.0,
              //   b: 1.0,
              // },
              rect_rel: {
                l: 0.0 - 0.2,
                r: 1.0 + 0.2,
                t: 0.0 - 0.2,
                b: 1.0 + 0.2,
              },
            },

            "tee": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.40,
                b: 0.50,
              },
            },

            // "bumpers": {
              "bumper1": {
                type: "gm_operator",
                zIndex: 51,
                config: {
                  operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
                },  
                rect_rel: {
                  l: 0.20,
                  r: 0.30,
                  t: 0.80,
                  b: 0.90,
                },
              },
              "bumper2": {
                type: "gm_operator",
                zIndex: 52,
                config: {
                  operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
                },
                rect_rel: {
                  l: 0.45,
                  r: 0.55,
                  t: 0.80,
                  b: 0.90,
                },
              },
              "bumper3": {
                type: "gm_operator",
                zIndex: 53,
                config: {
                  operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
                },
                rect_rel: {
                  l: 0.70,
                  r: 0.80,
                  t: 0.80,
                  b: 0.90,
                },
              },
            // },




            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          const config = {
            rect: {
              x:           0,
              y:           0,
              width:  GolfCourseConfig.get_size__challenge_area().width,
              height: GolfCourseConfig.get_size__challenge_area().height,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }



        static template_challenge_with_grayed(nb_op, color__bg = "lightyellow") {
          var outConfig;

          switch (nb_op) {
            case 2:
              outConfig = GolfCourseConfig.template_challenge_with_grayed__2(color__bg);
              break;
            default:
              outConfig = GolfCourseConfig.template_challenge_with_grayed__4(color__bg);
              break;
          }

          return outConfig;
        }



        static template_challenge_with_grayed__2(color__bg) {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                fill: color__bg,
              },
              // rect_rel: {
              //   l: 0.0,
              //   r: 1.0,
              //   t: 0.0,
              //   b: 1.0,
              // },
              rect_rel: {
                l: 0.0 - 0.2,
                r: 1.0 + 0.2,
                t: 0.0 - 0.2,
                b: 1.0 + 0.2,
              },
            },

            "tee": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.40,
                b: 0.50,
              },
            },

            // "bumpers": {
            "bumper1": {
              type: "gm_operator",
              zIndex: 51,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
                isEnabled: false,
              },
              rect_rel: {
                l: 0.25,
                r: 0.35,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper2": {
              type: "gm_operator",
              zIndex: 52,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
                isEnabled: false,
              },
              rect_rel: {
                l: 0.55,
                r: 0.65,
                t: 0.80,
                b: 0.90,
              },
            },


            "operatorWallPlaceholder1": {
              type: "placeholder",
              zIndex: 55,
              config: {
                fill: "gray",
                isEnabled: true,
              },
              rect_rel: {
                l: 0.25,
                r: 0.35,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder2": {
              type: "placeholder",
              zIndex: 56,
              config: {
                fill: "gray",
                isEnabled: true,
              },
              rect_rel: {
                l: 0.55,
                r: 0.65,
                t: 0.10,
                b: 0.20,
              },
            },


            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          const config = {
            rect: {
              x: 0,
              y: 0,
              width:  GolfCourseConfig.get_size__challenge_area().width,
              height: GolfCourseConfig.get_size__challenge_area().height,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }


        static template_challenge_with_grayed__4(color__bg) {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                fill: color__bg,
              },
              // rect_rel: {
              //   l: 0.0,
              //   r: 1.0,
              //   t: 0.0,
              //   b: 1.0,
              // },
              rect_rel: {
                l: 0.0 - 0.2,
                r: 1.0 + 0.2,
                t: 0.0 - 0.2,
                b: 1.0 + 0.2,
              },
            },

            "tee": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.40,
                b: 0.50,
              },
            },

            // "bumpers": {
            "bumper1": {
              type: "gm_operator",
              zIndex: 51,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
                isEnabled: false,
              },
              rect_rel: {
                l: 0.15,
                r: 0.25,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper2": {
              type: "gm_operator",
              zIndex: 52,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
                isEnabled: false,
              },
              rect_rel: {
                l: 0.35,
                r: 0.45,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper3": {
              type: "gm_operator",
              zIndex: 53,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
                isEnabled: false,
              },
              rect_rel: {
                l: 0.55,
                r: 0.65,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper4": {
              type: "gm_operator",
              zIndex: 54,
              config: {
                operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)),
                isEnabled: false,
              },
              rect_rel: {
                l: 0.75,
                r: 0.85,
                t: 0.80,
                b: 0.90,
              },
            },
            // },

            "operatorWallPlaceholder1": {
              type: "placeholder",
              zIndex: 55,
              config: {
                fill: "gray",
                isEnabled: true,
              },
              rect_rel: {
                l: 0.15,
                r: 0.25,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder2": {
              type: "placeholder",
              zIndex: 56,
              config: {
                fill: "gray",
                isEnabled: true,
              },
              rect_rel: {
                l: 0.35,
                r: 0.45,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder3": {
              type: "placeholder",
              zIndex: 57,
              config: {
                fill: "gray",
                isEnabled: true,
              },
              rect_rel: {
                l: 0.55,
                r: 0.65,
                t: 0.10,
                b: 0.20,
              },
            },
            "operatorWallPlaceholder4": {
              type: "placeholder",
              zIndex: 58,
              config: {
                fill: "gray",
                isEnabled: true,
              },
              rect_rel: {
                l: 0.75,
                r: 0.85,
                t: 0.10,
                b: 0.20,
              },
            },


            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          const config = {
            rect: {
              x: 0,
              y: 0,
              width:  GolfCourseConfig.get_size__challenge_area().width,
              height: GolfCourseConfig.get_size__challenge_area().height,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }





        static template_challenge__fraction_add() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
                fill: "lightyellow",
              },
              // rect_rel: {
              //   l: 0.0,
              //   r: 1.0,
              //   t: 0.0,
              //   b: 1.0,
              // },
              rect_rel: {
                l: 0.0 - 0.2,
                r: 1.0 + 0.2,
                t: 0.0 - 0.2,
                b: 1.0 + 0.2,
              },
            },

            "tee1": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.30,
                b: 0.40,
              },
            },

            "tee2": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.50,
                b: 0.60,
              },
            },

            // "bumpers": {
            "bumper1": {
              type: "gm_fractionOne_operator",
              zIndex: 51,
              config: {
                operatorString: "fractionOne:x 2",
              },
              rect_rel: {
                l: 0.15,
                r: 0.25,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper2": {
              type: "gm_fractionOne_operator",
              zIndex: 52,
              config: {
                operatorString: "fractionOne:x 3",
              },
              rect_rel: {
                l: 0.35,
                r: 0.45,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper3": {
              type: "gm_fractionOne_operator",
              zIndex: 53,
              config: {
                operatorString: "fractionOne:x 5",
              },
              rect_rel: {
                l: 0.55,
                r: 0.65,
                t: 0.80,
                b: 0.90,
              },
            },
            "bumper4": {
              type: "gm_fractionOne_operator",
              zIndex: 54,
              config: {
                operatorString: "fractionOne:x 7",
              },
              rect_rel: {
                l: 0.75,
                r: 0.85,
                t: 0.80,
                b: 0.90,
              },
            },
            // },

            "conductiveOp": {
              type: "gm_conductive_operator",
              zIndex: 55,
              config: {
                operatorString: "+",
              },
              rect_rel: {
                l: 0.45,
                r: 0.65,
                t: 0.30,
                b: 0.60,
              },
            },


            // "operatorWallPlaceholder1": {
            //   type: "placeholder",
            //   zIndex: 55,
            //   config: {
            //     fill: "gray",
            //   },
            //   rect_rel: {
            //     l: 0.15,
            //     r: 0.25,
            //     t: 0.10,
            //     b: 0.20,
            //   },
            // },
            // "operatorWallPlaceholder2": {
            //   type: "placeholder",
            //   zIndex: 56,
            //   config: {
            //     fill: "gray",
            //   },
            //   rect_rel: {
            //     l: 0.35,
            //     r: 0.45,
            //     t: 0.10,
            //     b: 0.20,
            //   },
            // },
            // "operatorWallPlaceholder3": {
            //   type: "placeholder",
            //   zIndex: 57,
            //   config: {
            //     fill: "gray",
            //   },
            //   rect_rel: {
            //     l: 0.55,
            //     r: 0.65,
            //     t: 0.10,
            //     b: 0.20,
            //   },
            // },
            // "operatorWallPlaceholder4": {
            //   type: "placeholder",
            //   zIndex: 58,
            //   config: {
            //     fill: "gray",
            //   },
            //   rect_rel: {
            //     l: 0.75,
            //     r: 0.85,
            //     t: 0.10,
            //     b: 0.20,
            //   },
            // },


            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          const config = {
            rect: {
              x: 0,
              y: 0,
              width:  GolfCourseConfig.get_size__challenge_area().width,
              height: GolfCourseConfig.get_size__challenge_area().height,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }


        static configByAddingSafetyZone(config_in) {
          var outConfig;

          outConfig = Object.assign({}, config_in);

          outConfig.components.safetyZone = {
            type: "gm_safetyZone",
            zIndex: 0,
            rect_rel: {
              l: 0.10,
              r: 0.50,
              t: -0.20,
              b: 0.20,
            },
          };

          return outConfig;
        }

        static configByAddingPlatformOp(config_in, opString_in) {
          var outConfig;

          outConfig = Object.assign({}, config_in);

          outConfig.components.platformOp1 = {
            type: "gm_platformOp",
            config: {
              opString: opString_in,
            },
            zIndex: 0,
            rect_rel: {
              l: 0.85,
              r: 0.95,
              t: 0.40,
              b: 0.50,
            },
          };

          return outConfig;
        }




        static challengeCourseConfigMiniObj_fromMiniString(challengeCourseMiniString) {

          const arr_courseStringComponent = challengeCourseMiniString.split(",");
          const nb_compoments = arr_courseStringComponent.length;

          const courseConfigMiniObj = arr_courseStringComponent.reduce((acc, x, i) => {

            const componentString = x;

            switch (i) {
              case 0:
                const initial = parseInt(componentString);
                acc["initial"] = initial;
                break;
              case (nb_compoments - 1):
                const target = parseInt(componentString);
                acc["target"] = target;
                break;
              default:
                const operatorString = componentString;
                if (acc["operators"] == null) {
                  acc["operators"] = [];
                }
                acc["operators"].push(operatorString);
                break;
            }

            return acc;
          }, {});

          return courseConfigMiniObj;
        }


        static challengeCourseConfig_fromMiniString(courseMiniString) {
          var outCourseConfig;

          const courseConfigMiniObj = GolfCourseConfig.challengeCourseConfigMiniObj_fromMiniString(courseMiniString);

          const courseConfig = GolfCourseConfig.template_challenge();

          // courseConfig.components.ball.config.value = courseConfigMiniObj.initial;
          courseConfig.initial = courseConfigMiniObj.initial;

          courseConfig.components.hole.config.value = courseConfigMiniObj.target;

          //SHU TODO: remove this ugliness
          // const entries_bumper = Object.entries(courseConfig.components).filter(([componentName, component]) => componentName.startsWith("bumper"));
          const entries_bumper = Object.entries(courseConfig.components).filter(([componentName, component]) => component.type == "gm_operator");
          entries_bumper.forEach(([componentName, component], i) => {
            component.config.operatorString = courseConfigMiniObj.operators[i];
          });

          outCourseConfig = courseConfig;

          return outCourseConfig;
        }

      }


      class GolfCourse {

        constructor(infiniteCanvas, golfCourseConfig) {
          console.log("GolfCourse, constructor", golfCourseConfig);
          this.infiniteCanvas = infiniteCanvas;

          this.rect = golfCourseConfig.rect;

          // this.components =
          const components = Object.entries(golfCourseConfig.components).reduce((acc, [componentName, componentConfig]) => {

            const icObj = this.createIcObjForComponent(infiniteCanvas, componentConfig);
            logger.log("logGolf", "createIcObjForComponent", "componentConfig:", componentConfig);
            logger.log("logGolf", "createIcObjForComponent", "icObj:", icObj);
            infiniteCanvas.addIcObject(icObj);

            const represented = infiniteCanvas.getRepresented(icObj.id);
            const rep_free = represented.r_free();

            const component = new GolfObject(componentConfig.type, rep_free);

            acc[componentName] = component;

            return acc;
          }, {});
          this.components = components;
        }


        createIcObjForComponent(infiniteCanvas, componentConfig) {
          logger.log("logGolf", "createIcObjForComponent", componentConfig);
          var outIcObj;

          const rect_rel__component = componentConfig.rect_rel;
          const trueRect__component = Geometry.rectForRectRel(rect_rel__component, this.rect);

          switch (componentConfig.type) {
            case "rect":
              {
                const config = componentConfig.config;
                const fill = config.fill;
                outIcObj = infiniteCanvas.createIcRect(trueRect__component);
                outIcObj.fill = fill;
              }
              break;

            case "gm_clickWell":
              {
                const config = componentConfig.config;
                const value = config.value;
                // outIcObj = infiniteCanvas.createIcGMClickWell(trueRect__component, value);
                outIcObj = infiniteCanvas.createIcBornAgainGreenMouse(trueRect__component, value);
              }
              break;
            case "gm_operator":
              {
                const config = componentConfig.config;
                const cfg = {
                  operatorNodeFactoryFuncWrapper: config.operatorNodeFactoryFuncWrapper,
                  isEnabled:      (config.isEnabled != null) ? config.isEnabled : true,
                };
                outIcObj = infiniteCanvas.createIcGMOperator(trueRect__component, cfg);
              }
              break;

            case "gm_fractionOne_operator":
              {
                // const config         = componentConfig.config;
                // const operatorString = config.operatorString;
                outIcObj = infiniteCanvas.createIcFractionOneOperator(trueRect__component);
              }
              break;
            case "gm_conductive_operator":
              {
                const config = componentConfig.config;
                const operatorString = config.operatorString;
                outIcObj = infiniteCanvas.createIcConductiveOperator(trueRect__component);
              }
              break;

            case "gm_targetTouchSlot":
              {
                const config = componentConfig.config;
                const value__core   = config.value;
                const value__facade = config.value__facade;

                const cfg = {
                  targetValue: config.operatorString,
                  isEnabled:   (config.isEnabled != null) ? config.isEnabled : true,
                };
                outIcObj = infiniteCanvas.createIcGMTargetTouchSlot(trueRect__component, cfg);

                /*
                const mathNode__core   = math.parse("42");
                const mathNode__facade = math.parse("1000");
                outIcObj = infiniteCanvas.createIcGMEqTargetTouchSlot(trueRect__component, mathNode__core, mathNode__facade);
                */

                // outIcObj = infiniteCanvas.createIcGMBoxTargetTouchSlot(trueRect__component, value);
                // outIcObj = infiniteCanvas.createIcGMBlob(trueRect__component, value);
              }
              break;

            case "gm_eq_targetTouchSlot":
              {
              const config = componentConfig.config;
              const value__core   = config.value;
              const value__facade = config.value__facade;
              // outIcObj = infiniteCanvas.createIcGMTargetTouchSlot(trueRect__component, value);

              const mathNode__core   = math.parse("42");
              const mathNode__facade = math.parse("1000");

              outIcObj = infiniteCanvas.createIcGMEqTargetTouchSlot(trueRect__component, mathNode__core, mathNode__facade);

              // outIcObj = infiniteCanvas.createIcGMBoxTargetTouchSlot(trueRect__component, value);
              // outIcObj = infiniteCanvas.createIcGMBlob(trueRect__component, value);
              }
              break;

            case "gm_safetyZone":
              {
                outIcObj = infiniteCanvas.createIcGMSafetyZone(trueRect__component);
              }
              break;

            case "gm_platformOp":
              {
                const config = componentConfig.config;
                const opString = config.opString;

                const value = config.value;
                outIcObj = infiniteCanvas.createIcGMPlatformOp(trueRect__component, opString);
              }
              break;


            case "button":
              {
                const config = componentConfig.config;
                const fill = config.fill;
                outIcObj = infiniteCanvas.createIcButton(trueRect__component);
                outIcObj.fill = fill;
              }
              break;

            case "labelValue":
              {
                const config = componentConfig.config;
                const fill = config.fill;
                const text = config.text;
                outIcObj = infiniteCanvas.createIcLabelValue(trueRect__component, text, 0);
                outIcObj.fill = fill;
              }
              break;

            // case "img":
            //   {
            //   const config = componentConfig.config;
            //   const fill   = config.fill;
            //   const text   = config.text;
            //   outIcObj = infiniteCanvas.createIcImage(trueRect__component, null);
            //   outIcObj.fill = fill;
            //   }
            //   break;

            case "placeholder":
              {
                const config = componentConfig.config;
                
                const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1));
                
                const cfg = {
                  operatorNodeFactoryFuncWrapper: operatorNodeFactoryFuncWrapper,
                  isEnabled: (config.isEnabled != null) ? config.isEnabled : true,
                };

                outIcObj = infiniteCanvas.createIcGMOperator(trueRect__component, cfg);

                outIcObj.isPlaceholder = true;
              }
              break;


            default:
              throw new Error("unsupported type: " + componentConfig.type);
              break;
          }

          //common props
          const zIndex = componentConfig.zIndex;
          outIcObj.zIndex = zIndex;

          return outIcObj;
        }

        fillHole() {
          const icObj_hole = this.components["hole"].icObj;
          // icObj_hole.parts["facade"].fill = "yellow";
          icObj_hole.parts["touchSlot"].fill = "yellow";
        }

        freeHole() {
          const icObj_hole = this.components["hole"].icObj;
          // icObj_hole.parts["facade"].fill = "yellow";
          icObj_hole.parts["touchSlot"].fill = "";
        }


        mutateIntoScoreLabel(score) {

          const golfCourse = this;
          const infiniteCanvas = this.infiniteCanvas;

          //remove almost all golfCourse components
          // Object.entries(golfCourse.components)
          // .filter(([componentName, component]) => {
          //   return (componentName != "bg");
          // })
          // .forEach(([componentName, component], i) => {
          //   const icObj = component.icObj;
          //
          //   // icObj.im_dying_now = true;
          //   // infiniteCanvas.removeIcObject(icObj);
          //
          //   const represented = icObj.represented;
          //   infiniteCanvas.removeRepresented(represented, true);
          // });

          //change bg color
          const icObj_bg = golfCourse.components["bg"].icObj;

          // function colorForScore(score) {
          //   var outColor;
          //
          //   switch(score.medal) {
          //     case "bronze":
          //     outColor = "bronze";
          //     break;
          //     case "silver":
          //     outColor = "silver";
          //     break;
          //     case "gold":
          //     outColor = "gold";
          //     break;
          //   }
          //
          //   return outColor;
          // }
          icObj_bg.fill = "gold";

          //add score label
          const rect__scoreLabel = {
            x: golfCourse.rect.x,
            y: golfCourse.rect.y,
            width: golfCourse.rect.width,
            height: golfCourse.rect.height,
          };
          const scoreLabel = infiniteCanvas.createIcText(rect__scoreLabel.x, rect__scoreLabel.y, "" + score);     //SHU TODO: createIcLabel(trueRect, text)
          infiniteCanvas.addIcObject(scoreLabel);


        }

      }

      class GolfStepConfig {
        constructor(type, golfCourseName, par, componentSpecs, gmItemConfig) {
          this.type = type;

          this.golfCourseName = golfCourseName;
          this.par = par;

          this.componentSpecs = componentSpecs;
          this.gmItemConfig = gmItemConfig;
        }

        // static step_begin(golfCourseName) {
        //   const type = "begin";
        //   const stepConfig = new GolfStepConfig(type, golfCourseName);
        //   return stepConfig;
        // }

        // static step_end(golfCourseName) {
        //   const type = "end";
        //   const stepConfig = new GolfStepConfig(type, golfCourseName);
        //   return stepConfig
        // }

      }

      class GolfStep {

        constructor(infiniteCanvas, golfStepConfig, golfCourse, segue) {
          // logger.log("GolfStep::constructor", golfStepConfig, golfCourse, segue);

          this.infiniteCanvas = infiniteCanvas;
          // this.golfStepConfig = golfStepConfig;
          this.golfCourse = golfCourse;
          this.segue = segue;

          this.configure(golfStepConfig);

          this.invest(golfCourse);

          // this.possess(golfCourse);
        }

        configure(golfStepConfig) {
          this.par = golfStepConfig.par;
          this.challengeGMItemConfig = golfStepConfig.gmItemConfig;
        }

        addNewBall() {
          const step = this;
          const infiniteCanvas = this.infiniteCanvas;
          const golfCourse = this.golfCourse;


          const icObj__tee = golfCourse.components["tee"].icObj;
          const trueRect__ball = {
            x: icObj__tee.position.x,
            y: icObj__tee.position.y,
            width: 50,
            height: 50,
          };

          // const value = 0;
          //debug
          const mathNode__initial = step.challengeGMItemConfig.initial.content;
          // const value = mathNode__initial.value;

          // const icObj = infiniteCanvas.createIcBornAgainGreenMouseBox(trueRect__ball, mathNode__initial);
          const icObj = infiniteCanvas.createIcGreenMouseBox(trueRect__ball, mathNode__initial);
          // const icObj = infiniteCanvas.createIcMathNode(trueRect__ball.x, trueRect__ball.y, mathNode__initial);

          // const icObj = infiniteCanvas.createIcMathNode(trueRect__ball.x, trueRect__ball.y, mathNode__initial);

          infiniteCanvas.addIcObject(icObj);

          //"exo curse"
          const rep_free__ball = infiniteCanvas.getRepresented(icObj.id).r_free();
          Hooker.installHooks(rep_free__ball, "die");
          rep_free__ball.did["die"].on(() => {
            // logger.log("did die");

            rep_free__ball.parts.facade.im_dying_now      = true;
            rep_free__ball.parts.contactArea.im_dying_now = true;

            step.addNewBall();
          });

          step.rep_free__ball = rep_free__ball;
        }

        

        invest(golfCourse) {

          const step = this;

          //furnish: add objects
          {
            const infiniteCanvas = this.infiniteCanvas;

            //add label/value: score
            function addLabel_score() {
              const rect__score = golfCourse.rect;
              rect__score.width = 300;
              rect__score.height = 150;

              const string__score = "score:";
              const value__score = 0;

              const icObj__score = infiniteCanvas.createIcLabelValue(rect__score, string__score, value__score);
              icObj__score.zIndex = 200;

              infiniteCanvas.addIcObject(icObj__score);

              const rep_free__score_valueLabel = infiniteCanvas.getRepresented(icObj__score.id).r_free();
              step.rep_free__score_valueLabel = rep_free__score_valueLabel;
              step.rep_free__score_value = rep_free__score_valueLabel.parts["value"];
            }
            addLabel_score();

            //add label/value: par
            function addLabelValue_par() {
              const rect__par = {
                x: step.rep_free__score_valueLabel.position.x,
                y: step.rep_free__score_valueLabel.position.y + 120,
                width: 300,
                height: 150,
              };

              const string__par = "par:";
              const value__par = step.par;

              const icObj__par = infiniteCanvas.createIcLabelValue(rect__par, string__par, value__par);
              icObj__par.zIndex = 201;

              infiniteCanvas.addIcObject(icObj__par);

              const rep_free__par_valueLabel = infiniteCanvas.getRepresented(icObj__par.id).r_free();
              step.rep_free__par_valueLabel = rep_free__par_valueLabel;
              step.rep_free__par_value = rep_free__par_valueLabel.parts["value"];

              setTimeout(() => {
                step.rep_free__par_value.position = {
                  x: step.rep_free__score_value.position.x,
                  y: step.rep_free__par_value.position.y,
                };
              }, 20);   //SHU TODO: remove this ugliness
            }
            addLabelValue_par();



            //add button: restart

            //add ball:
            step.addNewBall();
          }


          //invest: "this is mine now"
          {
            // step.rep_free__ball = golfCourse.components["ball"].icObj;

            // this.rep_free__ball = golfCourse.components["ball"].icObj;
            step.rep_free__hole = golfCourse.components["hole"].icObj;
          }


          //employ: now you do X

          //operators
          {
            const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_operator");
            const arr_rep_free__operator = arr_gm_operator.map((gm_operator, i) => {
              const icObj__rep_free = gm_operator.icObj;
              return icObj__rep_free;
            });
            const arr_gmItem_operator = step.challengeGMItemConfig.operators;

            const arr_zipped = Utils.zip(arr_rep_free__operator, arr_gmItem_operator);

            arr_zipped.forEach(([rep_free__operator, gmItem_operator], i) => {


              //touchSlot
              const rep_free__touchSlot = rep_free__operator.parts["touchSlot"];

              const mathNodeTransformationFunc = gmItem_operator.content;
              const icObjTransformationFunc = (icObj) => {
                // logger.log("icObjTransformationFunc", icObj);
                var outIcObj;



                outIcObj = icObj.clone();
                // logger.log("outIcObj", outIcObj);

                if (outIcObj.mathNode) {
                  delete outIcObj.mathNode;     //SHU666: true sadness
                }



                if (icObj.cType == "gm_box") {
                  // logger.log("gm_box");

                  const facade = icObj.parts.facade;
                  logger.log("logGolf", 'icObj.cType == "gm_box"', "facade:", facade);
                  outIcObj.parts.facade.mathNode = mathNodeTransformationFunc(facade.mathNode);
                }

                // if(icObj.mathNode != null) {
                //   // logger.log("icObj.mathNode", icObj.mathNode);
                //   outIcObj.mathNode = mathNodeTransformationFunc(icObj.mathNode);
                // }

                return outIcObj;
              };
              rep_free__touchSlot.touchSlotConfig.transformationFunc = icObjTransformationFunc;


              //facade
              const rep_free__facade = rep_free__operator.parts["facade"];
              rep_free__facade.text  = gmItem_operator.name;

              rep_free__facade.originX = "center";

            });
          }

        }

        possess(golfCourse) {
          this.initializeCompletionListeners();

          this.setupAttemptListeners(golfCourse);

          this.setupCompletionTrigger(golfCourse);
          this.addCompletionListener(golfCourse);
        }

        initializeCompletionListeners() {
          // this.nb_attempts = 0;
          this.arr_attempt = [];

          this.listeners_completed = [];

          this.onCompleted = (listener) => {
            this.listeners_completed.push(listener);
          };
          this.offCompleted = (listener) => {
            this.listeners_completed = Utils.arrayByRemovingElement(this.listeners_completed, listener);
          };
          this.nowCompleted = () => {
            this.listeners_completed.forEach((listener, i) => {
              listener(this);
            });
          };
        }

        setupAttemptListeners(golfCourse) {   //SHU: this is where BigBrother sneaked in from

          // const step = this;
          //
          // function waitForNewAttempt() {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   const createAttemptFunc = () => {
          //
          //       const attempt = new GolfStepAttempt();
          //
          //       step.arr_attempt.push(attempt);
          //
          //       ball__rep_free.offHold(createAttemptFunc);
          //   };
          //
          //   ball__rep_free.onHold(createAttemptFunc);
          // }
          //
          // //gm.onHold(create attempt)
          // {
          //   waitForNewAttempt();
          // }
          //
          // //gm.onTouched(add event to attempt)
          // {
          //
          // }
          //
          // //gm.onRelease(finalize attempt)
          // {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   ball__rep_free.onRelease(waitForNewAttempt);
          // }
          //
          // //create attempt
          //
          //
          //
          //
          //
          //
          // //course use listeners
          //
          // function listenToOperatorTouches(icObj__rep_free) {
          //
          //   const touchSlot__rep_free  = icObj__rep_free.parts["touchSlot"];
          //   // logger.log("touchSlot__rep_free", touchSlot__rep_free);
          //
          //   const touchSlotEngine = touchSlot__rep_free.engine;
          //
          //   Hooker.installHooks(touchSlotEngine.awoken, "touch");
          //   touchSlotEngine.awoken.did["touch"].on((...args) => {
          //     // logger.log("did touch", ...args);
          //
          //     // counter += 1
          //     const attempt = step.getCurrentAttempt();
          //     // logger.log("attempt", attempt);
          //     attempt.manoeuvre.nb_touched += 1;
          //
          //     //debug
          //     step.rep_free__score_value.text = "" + attempt.manoeuvre.nb_touched;
          //   });
          //
          // }
          //
          // const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_operator");
          //
          // arr_gm_operator.forEach((gm_operator, i) => {
          //   const icObj__rep_free = gm_operator.icObj;
          //   listenToOperatorTouches(icObj__rep_free);
          // });

        }

        setupCompletionTrigger(golfCourse) {

          const targetTouchSlot__rep_free = golfCourse.components["hole"].icObj;

          const touchSlot__rep_free = targetTouchSlot__rep_free.parts["touchSlot"];

          const touchSlotEngine = touchSlot__rep_free.dict_engine["touchSlot"].engine;

          Hooker.installHooks(touchSlotEngine.awoken, "touch");
          const listener_targetDidTouch = (...args) => {
            logger.log("listener_targetDidTouch", ...args);

            this.nowCompleted();
          };
          this.listener_targetDidTouch = listener_targetDidTouch;
          touchSlotEngine.awoken.did["touch"].on(listener_targetDidTouch);

        }

        addCompletionListener(golfCourse) {

          const step = this;

          this.listener_onCompleted = (golfStep) => {
            // console.log("step, onCompleted", golfStep);
            // logger.log("step, onCompleted", golfStep);

            /*
            const score = golfStep.arr_attempts.length;
            golfCourse.mutateIntoScoreLabel(score);
            */

            step.offCompleted(step.listener_onCompleted);
            step.end();

            // step.animate__showOrFade(false);

            step.segue.play(golfStep);
          };

          this.onCompleted(this.listener_onCompleted);
        }

        getCurrentAttempt() {
          return this.arr_attempt[this.arr_attempt.length - 1];
        }


      }

      class GolfStepAttempt {

        constructor() {
          this.evolution = new GolfStepAttemptEvolution();
          this.manoeuvre = new GolfStepAttemptManoeuvre();
        }

      }

      class GolfStepAttemptEvolution {

        constructor() {
          this.nb_touched = 0;
        }

      }

      class GolfStepAttemptManoeuvre {

        constructor() {
          this.nb_touched = 0;
        }

      }


      class GolfSegue {

        constructor(infiniteCanvas, golfSegueConfig, golfCourse_from, golfCourse_to) {
          this.infiniteCanvas = infiniteCanvas;

          this.golfSegueConfig = golfSegueConfig;
          this.configure(golfSegueConfig);

          this.golfCourse_from = golfCourse_from;
          this.golfCourse_to   = golfCourse_to;
        }

        configure(golfSegueConfig) {

        }

        play(step_from) {
          // logger.log("GolfSegue::play", step_from);

          const score = 12;
          // this.golfCourse_from.mutateIntoScoreLabel(score);

          this.golfCourse_from.fillHole();

          const position_to = {
            x: this.golfCourse_to.rect.x,
            y: this.golfCourse_to.rect.y,
          };
          this.infiniteCanvas.move_to_position(position_to);

          // this.infiniteCanvas.show_rect(this.golfCourse_to.rect);
          // const rect__makeshift = {
          //   x: this.golfCourse_to.rect.x + this.golfCourse_to.rect.width  / 2.0,
          //   y: this.golfCourse_to.rect.y - this.golfCourse_to.rect.height / 4.0,
          //   width: this.golfCourse_to.rect.x + this.golfCourse_to.rect.width / 1.0,
          //   height: this.golfCourse_to.rect.x + this.golfCourse_to.rect.height / 1.0,
          // };
          // this.infiniteCanvas.show_rect(rect__makeshift);

        }


      }
    </script>
    <script>
      // setTimeout(() => {    //SHU: wait for mathjax to finish loading
      //   // const golfGame1 = GolfGame1.defaultInstance(infiniteCanvas);
      //   // const golfGame1 = GolfGame1.debugInstance(infiniteCanvas);
      //   const golfGame1 = GolfGame1.seriousInstance(infiniteCanvas);        //golf
      // }, 1000);
      // globalsSingleton.functionCallsQueue.add(() => {
      //   const golfGame1 = GolfGame1.seriousInstance(infiniteCanvas);
      // });
    </script>



    <script>

      class GMABChallenge {
        constructor(a, b, arr_operators) {

        }

        isPossible() {

        }

        hasPeriodicSolution() {

        }

      }

      class GMABPath {
        constructor(a, b, st) {

        }

        isPeriodic() {

        }

        getLength() {

        }


      }

      class LasagnaTreeNursery {
        constructor(operators) {
          this.operators = operators;
        }

        treeOfDepth(root, depth) {    //mathNode, gmOperator, mathNode, ...

        }

      }

      class GMItem {
        constructor(type, content, name, description, specs = {}) {
          this.type = type;
          this.content = content;
          this.name = name;
          this.description = description;
          this.specs = specs;     //specific behavior (for example: does not accept symbolic input params)
        }

        clone() {
          var outItem;

          outItem = new GMItem();
          Object.assign(outItem, this);
          outItem.content = this.content.cloneDeep();

          return outItem;
        }

        static value(content, name, description, specs = {}) {
          const type = "value";
          const item = new GMItem(type, content, name, description, specs);
          return item;
        }

        static operator(content, name, description, specs = {}) {
          const type = "operator";
          const item = new GMItem(type, content, name, description, specs);
          return item;
        }

      }

      class GMOperatorGroup {

        constructor(arr_gm_operator) {

        }

      }

      class GMMaker {

        static createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, nb_iter, isShouldSimplify = true) {
          var outItem;

          const arr_index = [...new Array(nb_iter).keys()];

          const mathNode__initial = gmItem__initial.content;

          const mathNode__initial_clone = mathNode__initial.cloneDeep();
          mathNode__initial_clone.autoSimplify = mathNode__initial.autoSimplify;

          const mathNode__target = arr_index.reduce((acc, x) => {

            const node_a = acc;

            const gmItem_operator = Utils.randomElementInArray(arr_gmItem_operator);

            // const operatorNodeFactoryFunc = gmItem_operator.content;
            const operatorNodeFactoryFunc = gmItem_operator.specs.funcWrapper.func;

            function operateOn(mathNode) {
              var outMathNode;

              switch (mathNode.type) {
                case "RelationalNode":
                  {
                    outMathNode = mathNode.clone();
                    outMathNode.params = outMathNode.params.map((mathNode_child, i) => {
                      return operateOn(mathNode_child);
                    });
                  }
                  break;
                default:
                  {
                    logger.log("createGMItemTarget__x_to_expr", "operateOn", "mathNode:", mathNode);
                    outMathNode = operatorNodeFactoryFunc(mathNode);

                    if(isShouldSimplify) {
                      outMathNode = math.simplify(outMathNode);
                      // outMathNode = Simplifier.simplify(outMathNode);

                      // outMathNode = Simplifier.simplify_top_layer(outMathNode);
                      // outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);
                    }

                  }
                  break;
              }

              outMathNode.autoSimplify = mathNode.autoSimplify;
              outMathNode.isEquation   = mathNode.isEquation;

              return outMathNode;
            }

            const node_op = operateOn(node_a);

            return node_op;
          }, mathNode__initial_clone);

          outItem = GMItem.value(mathNode__target, "target", "");

          return outItem;
        }

        static createGMItemTarget__x_to_expr2(gmItem__initial, arr_gmItem_operator__mandatory, arr_gmItem_operator__filler, nb_iter__filler) {
          var outItem;

          const mathNode__initial       = gmItem__initial.content;
          const mathNode__initial_clone = mathNode__initial.cloneDeep();
          mathNode__initial_clone.autoSimplify = mathNode__initial.autoSimplify;

          const arr_mandat__shuffled = Utils.shuffle([...arr_gmItem_operator__mandatory]);

          const mathNode__target__mandat = arr_mandat__shuffled.reduce((acc, x) => {

            const node_a = acc;

            const gmItem_operator = x;

            // const operatorNodeFactoryFunc = gmItem_operator.content;
            const operatorNodeFactoryFunc = gmItem_operator.specs.funcWrapper.func;

            function operateOn(mathNode) {
              var outMathNode;

              switch(mathNode.type) {
                case "RelationalNode":
                  {
                    outMathNode = mathNode.clone();
                    outMathNode.params = outMathNode.params.map((mathNode_child, i) => {
                      return operateOn(mathNode_child);
                    });
                  }
                  break;
                default:
                  {
                    outMathNode = operatorNodeFactoryFunc(mathNode);

                    // outMathNode = math.simplify(outMathNode);
                    // outMathNode = Simplifier.simplify(outMathNode);

                    // outMathNode = Simplifier.simplify_top_layer(outMathNode);
                    // outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);
                  }
                  break;
              }

              outMathNode.autoSimplify = mathNode.autoSimplify;
              outMathNode.isEquation   = mathNode.isEquation;

              return outMathNode;
            }

            const node_op = operateOn(node_a);

            return node_op;
          }, mathNode__initial_clone);




          const arr_index = [...new Array(nb_iter__filler).keys()];

          const mathNode__target = arr_index.reduce((acc, x) => {

            const node_a = acc;

            const arr_gmItem_operator__filler__edu = arr_gmItem_operator__filler.filter((gmItem_operator) => {
              var outBool;
              if(gmItem_operator.specs.arr_order__edu != null) {
                outBool = gmItem_operator.specs.arr_order__edu.includes(x);
              } else {
                outBool = true;
              }
              return outBool;
            });
            const gmItem_operator = Utils.randomElementInArray(arr_gmItem_operator__filler__edu);
            
            // const operatorNodeFactoryFunc = gmItem_operator.content;
            const operatorNodeFactoryFunc = gmItem_operator.specs.funcWrapper.func;

            function operateOn(mathNode) {
              var outMathNode;

              switch(mathNode.type) {
                case "RelationalNode":
                  {
                    outMathNode = mathNode.clone();
                    outMathNode.params = outMathNode.params.map((mathNode_child, i) => {
                      return operateOn(mathNode_child);
                    });
                  }
                  break;
                default:
                  {
                    outMathNode = operatorNodeFactoryFunc(mathNode);

                    // outMathNode = math.simplify(outMathNode);
                    // outMathNode = Simplifier.simplify(outMathNode);

                    // outMathNode = Simplifier.simplify_top_layer(outMathNode);
                    // outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);
                  }
                  break;
              }

              outMathNode.autoSimplify = mathNode.autoSimplify;
              outMathNode.isEquation   = mathNode.isEquation;

              return outMathNode;
            }

            const node_op = operateOn(node_a);

            return node_op;
          }, mathNode__target__mandat);

          outItem = GMItem.value(mathNode__target, "target", "");

          return outItem;
        }


        // static createGMItemTarget__with_cfg(gmItem__initial, arr_gmItem_operator, nb_iter, cfg) {
        //   var outItem;

        //   const arr_index = [...new Array(nb_iter).keys()];

        //   const mathNode__initial = gmItem__initial.content;

        //   const mathNode__initial_clone = mathNode__initial.cloneDeep();
        //   mathNode__initial_clone.autoSimplify = mathNode__initial.autoSimplify;

        //   function generateMathNodeTarget(arr_index, mathNode__initial_clone) {
        //     return arr_index.reduce((acc, x) => {

        //       const node_a = acc;

        //       const gmItem_operator = Utils.randomElementInArray(arr_gmItem_operator);

        //       // const operatorNodeFactoryFunc = gmItem_operator.content;
        //       const operatorNodeFactoryFunc = gmItem_operator.specs.funcWrapper.func;

        //       function operateOn(mathNode) {
        //         var outMathNode;

        //         switch(mathNode.type) {
        //           case "RelationalNode":
        //             {
        //               outMathNode = mathNode.clone();
        //               outMathNode.params = outMathNode.params.map((mathNode_child, i) => {
        //                 return operateOn(mathNode_child);
        //               });
        //             }
        //             break;
        //           default:
        //             {
        //               outMathNode = operatorNodeFactoryFunc(mathNode);

        //               outMathNode = math.simplify(outMathNode);
        //               // outMathNode = Simplifier.simplify(outMathNode);

        //               // outMathNode = Simplifier.simplify_top_layer(outMathNode);
        //               // outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);
        //             }
        //             break;
        //         }

        //         outMathNode.autoSimplify = mathNode.autoSimplify;
        //         outMathNode.isEquation   = mathNode.isEquation;

        //         return outMathNode;
        //       }

        //       const node_op = operateOn(node_a);

        //       return node_op;
        //     }, mathNode__initial_clone);
        //   }

        //   var mathNode__target;
        //   if(cfg.isInteger) {
        //     var isFound = false;
        //     while(!isFound) {
        //       mathNode__target = generateMathNodeTarget(arr_index, mathNode__initial_clone);
        //       logger.log("mathNode__target", mathNode__target);
        //       const value = mathNode__target.evaluate();
        //       isFound = math.isInteger(value);
        //     }
        //   } else {
        //     mathNode__target = generateMathNodeTarget(arr_index, mathNode__initial_clone);
        //   }

        //   outItem = GMItem.value(mathNode__target, "target", "");

        //   return outItem;
        // }

        static createGMItemTarget__with_cfg(gmItem__initial, arr_gmItem_operator, nb_iter, cfg) {
          var outItem;

          const arr_index = [...new Array(nb_iter).keys()];

          const mathNode__initial = gmItem__initial.content;

          const mathNode__initial_clone = mathNode__initial.cloneDeep();
          mathNode__initial_clone.autoSimplify = mathNode__initial.autoSimplify;

          function generateMathNodeTarget(arr_index, mathNode__initial_clone) {
            return arr_index.reduce((acc, x) => {

              const node_a = acc;

              const gmItem_operator = Utils.randomElementInArray(arr_gmItem_operator);

              // const operatorNodeFactoryFunc = gmItem_operator.content;
              const operatorNodeFactoryFunc = gmItem_operator.specs.funcWrapper.func;

              function operateOn(mathNode) {
                var outMathNode;

                switch(mathNode.type) {
                  case "RelationalNode":
                    {
                      outMathNode = mathNode.clone();
                      outMathNode.params = outMathNode.params.map((mathNode_child, i) => {
                        return operateOn(mathNode_child);
                      });
                    }
                    break;
                  default:
                    {
                      outMathNode = operatorNodeFactoryFunc(mathNode);

                      outMathNode = math.simplify(outMathNode);
                      // outMathNode = Simplifier.simplify(outMathNode);

                      // outMathNode = Simplifier.simplify_top_layer(outMathNode);
                      // outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);
                    }
                    break;
                }

                outMathNode.autoSimplify = mathNode.autoSimplify;
                outMathNode.isEquation   = mathNode.isEquation;

                return outMathNode;
              }

              const node_op = operateOn(node_a);

              return node_op;
            }, mathNode__initial_clone);
          }

          var mathNode__target;
          if(cfg.isInteger) {
            var isFound = false;
            while(!isFound) {
              mathNode__target = generateMathNodeTarget(arr_index, mathNode__initial_clone);
              logger.log("mathNode__target", mathNode__target);
              const value = mathNode__target.evaluate();
              isFound = math.isInteger(value);
            }
          } else {
            mathNode__target = generateMathNodeTarget(arr_index, mathNode__initial_clone);
          }

          if(cfg.display != null && cfg.display == "decimal") {
            mathNode__target = new math.ConstantNode(mathNode__target.evaluate());
          }

          outItem = GMItem.value(mathNode__target, "target", "");

          return outItem;
        }


      }


    </script>


    <script>

      class GolfGame__Endless_Practice__Challenge {

        static createChallengeForRoute(route) {
          var outChallenge;

          const arr_component            = route.split("/");
          const [categ, ...arr_subroute] = arr_component;

          switch(categ) {
            
            case "math":
              {
                outChallenge = this.createChallengeForRoute__math(arr_subroute);
              }
              break;

            default:
              {
                throw new Error("createChallengeForRoute, Unsupported categ: " + categ);
              }
              break;
          }

          return outChallenge;
        }

        static createChallengeForRoute__math(arr_subroute) {
          var outChallenge; 

          const str__subroute = arr_subroute.join("/");

          switch(str__subroute) {

              //debug
            case "debug/1":
               {

                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance1(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };

               }
               break;
              
              //numer
            case "numer/n1_ten__0_to_HTU":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__0_to_HTU(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numer/n2_ten__0_to_HTU__missing100":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__0_to_HTU__missing100(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numer/n2b_ten__0_to_HTU__missing1000_10":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__0_to_HTU__missing1000_10(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numer/n3_ten__HTU_to_0":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__HTU_to_0(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numer/n4_ten__HTU_to_HTU":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__HTU_to_HTU(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numer/n5_ten__0_to_HTU__500":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__0_to_HTU__500(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numer/n6_ten__0_to_HTU__250":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__0_to_HTU__250(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numer/n7_dec__0_to_dec__1":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__0_to_dec__1(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numer/n8_dec__0_to_dec__1__shuffle":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__0_to_dec__1__shuffle(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numer/n9_dec__0_to_dec__0001":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__0_to_dec__0001(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numer/n10_ten__0_to_HTU_scarce":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_only2();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__0_to_HTU_scarce(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numer/n10b_dec__0_to_dec_scarce":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_only2();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__0_to_dec_scarce(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numer/n11_ten__0_to_HTU_scarce_step":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_only2();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__0_to_HTU_scarce_step(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numer/n11b_dec__0_to_dec_scarce_step":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_only2();
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__num__0_to_dec_scarce_step(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

              //calculation
            case "calcu/ca1_add_mult":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__calcu__ca1_add_mult(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "calcu/ca2_add_mult_div":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__calcu__ca2_add_mult_div(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "calcu/ca3_add_mult_div_sub":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__calcu__ca3_add_mult_div_sub(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

              case "calcu/ca10_add_mult_div_sub_monomaniac":
                {
                  const golfCourseConfig  = GolfCourseConfig.template_challenge_with_refresh();
  
                  const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__calcu__ca10_add_mult_div_sub_monomaniac(infiniteCanvas, golfCourse, stepGeneratorFunc);
  
                  outChallenge = {
                    golfCourseConfig:  golfCourseConfig,
                    stepGeneratorFunc: stepGeneratorFunc,
                  };
                }
                break;

              case "calcu/ca11_op4_monomaniac":
                {
                  const golfCourseConfig  = GolfCourseConfig.template_challenge_with_refresh();
  
                  const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__calcu__ca11_op4_monomaniac(infiniteCanvas, golfCourse, stepGeneratorFunc);
  
                  outChallenge = {
                    golfCourseConfig:  golfCourseConfig,
                    stepGeneratorFunc: stepGeneratorFunc,
                  };
                }
                break;

              case "calcu/ca20_op4_bimaniac":
                {
                  const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();
  
                  const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__calcu__ca20_op4_bimaniac(infiniteCanvas, golfCourse, stepGeneratorFunc);
  
                  outChallenge = {
                    golfCourseConfig:  golfCourseConfig,
                    stepGeneratorFunc: stepGeneratorFunc,
                  };
                }
                break;



              case "calcu/ca50_symb_op4_monomaniac":
                {
                  const golfCourseConfig  = GolfCourseConfig.template_challenge_with_refresh();
  
                  const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__calcu__ca50_symb_op4_monomaniac(infiniteCanvas, golfCourse, stepGeneratorFunc);
  
                  outChallenge = {
                    golfCourseConfig:  golfCourseConfig,
                    stepGeneratorFunc: stepGeneratorFunc,
                  };
                }
                break;

              case "calcu/ca60_symb_op4_bimaniac":
                {
                  const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();
  
                  const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__calcu__ca60_symb_op4_bimaniac(infiniteCanvas, golfCourse, stepGeneratorFunc);
  
                  outChallenge = {
                    golfCourseConfig:  golfCourseConfig,
                    stepGeneratorFunc: stepGeneratorFunc,
                  };
                }
                break;
            

            
              //negat
            case "negat/n0_matrix__nice":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_only2();
                golfCourseConfig.components.bg.config.fill = "rgb(150,150,150)";

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n0_matrix__nice(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "negat/n5_grayed_B":
              {
                const color__negat     = "rgb(150,150,150)";
                const golfCourseConfig = GolfCourseConfig.template_challenge_with_grayed(2, color__negat);

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n5_grayed_B(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "negat/n5_grayed_R":
              {
                const color__negat     = "rgb(150,150,150)";
                const golfCourseConfig = GolfCourseConfig.template_challenge_with_grayed(2, color__negat);
                
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n5_grayed_R(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "negat/n5_grayed_L":
              {
                const color__negat     = "rgb(150,150,150)";
                const golfCourseConfig = GolfCourseConfig.template_challenge_with_grayed(2, color__negat);

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n5_grayed_L(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "negat/n54_below0_minus9":
              {
                const color__negat     = "rgb(150,150,150)";
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                golfCourseConfig.components.bg.config.fill = color__negat;

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n54_below0_minus9(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "negat/n55_below0_minus10":
              {
                const color__negat     = "rgb(150,150,150)";
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                golfCourseConfig.components.bg.config.fill = color__negat;

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n55_below0_minus10(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "negat/n56_below0_minus100":
              {
                const color__negat     = "rgb(150,150,150)";
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                golfCourseConfig.components.bg.config.fill = color__negat;

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n56_below0_minus100(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            // case "negat/n57_below0_minus1000":
            //   {
            //     const color__negat     = "rgb(150,150,150)";
            //     const golfCourseConfig  = GolfCourseConfig.template_challenge();
            //     golfCourseConfig.components.bg.config.fill = color__negat;

            //     const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n57_below0_minus1000(infiniteCanvas, golfCourse, stepGeneratorFunc);

            //     outChallenge = {
            //       golfCourseConfig:  golfCourseConfig,
            //       stepGeneratorFunc: stepGeneratorFunc,
            //     };
            //   }
            //   break;

            case "negat/n58_below0_minus01":
              {
                const color__negat     = "rgb(150,150,150)";
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                golfCourseConfig.components.bg.config.fill = color__negat;

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n58_below0_minus01(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "negat/n585_below0_minusX05":
              {
                const color__negat     = "rgb(150,150,150)";
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                golfCourseConfig.components.bg.config.fill = color__negat;

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n585_below0_minusX05(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "negat/n59_below0_minusX001":
              {
                const color__negat     = "rgb(150,150,150)";
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                golfCourseConfig.components.bg.config.fill = color__negat;

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n59_below0_minusX001(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "negat/n6_addB_subT_neg":
              {
                const color__negat     = "rgb(150,150,150)";
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();
                golfCourseConfig.components.bg.config.fill = color__negat;

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n6_addB_subT_neg(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "negat/n7_addB_subT_all":
              {
                const color__negat     = "rgb(150,150,150)";
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();
                golfCourseConfig.components.bg.config.fill = color__negat;

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n7_addB_subT_all(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "negat/n10__product":
              {
                const color__negat     = "rgb(150,150,150)";
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
                golfCourseConfig.components.bg.config.fill = color__negat;

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__negat__n10__product(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;


//           // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__frac_to_one(infiniteCanvas, golfCourse, stepGeneratorFunc);
//           // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__one_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc);
//           // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__frac_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc);
//           // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__frac_to_frac__decomp(infiniteCanvas, golfCourse, stepGeneratorFunc);
//           // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__frac_to_frac__decomp_simple(infiniteCanvas, golfCourse, stepGeneratorFunc);


//           // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__one_to_frac__decomp(infiniteCanvas, golfCourse, stepGeneratorFunc);
//           // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__one_to_frac__mixed(infiniteCanvas, golfCourse, stepGeneratorFunc);


                //frac
            case "frac/f1__one_to_frac":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__one_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "frac/f3__frac_to_one":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__frac_to_one(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "frac/f4__frac_to_frac_decomp_simple":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__frac_to_frac__decomp_simple(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "frac/f5__frac_to_frac_decomp":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__frac_to_frac__decomp(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "frac/f6__frac_to_frac":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__frac_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;




              //sqsqrtpow
            case "sqsqrtpow/p1__product_vpadiq":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__p1__product_vpadiq(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/p2__product_expadd":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__p2__product_expadd(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/p3__product_to_1":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__p3__product_to_1(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/p4__product_to_product__pos":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__p4__product_to_product__pos(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/p5__negat":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__p5__negat(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/p6__negat_expadd":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__p6__negat_expadd(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/p7__negat_to_1":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__p7__negat_to_1(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/p8__product_to_product__full":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__p8__product_to_product__full(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/p9__product__compositeops":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__p9__product__compositeops(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/p100__powop":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__p100__powop(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/dectosci1__HTU":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_only3();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__dectosci1__HTU(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/dectosci2__TUdc":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__dectosci2__TUdc(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/dectosci3__HTUd_duos":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__dectosci3__HTUd_duos(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/sci1__fixed_equal_sci":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_only2();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__sci1__fixed_equal_sci(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/sci1b__fixed_equal_sci":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__sci1b__fixed_equal_sci(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/sci1c__fixed_equal_sci":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_only2();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__sci1c__fixed_equal_sci(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/sci1d__fixed_equal_sci":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__sci1d__fixed_equal_sci(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "sqsqrtpow/sci2__sci_equal_fixed":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_only2();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__sqsqrtpow__sci2__sci_equal_fixed(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;


              //numexp
            case "numexp/ne1_numexp_writing_add_mult":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__numexp__ne1_numexp_writing_add_mult(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numexp/ne2_numexp_writing_op4":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__numexp__ne2_numexp_writing_op4(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numexp/ne3_numexp_writing_fat_to_fatter":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__numexp__ne3_numexp_writing_fat_to_fatter(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "numexp/ne10_numexp__mental_calculation":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__numexp__ne10_numexp__mental_calculation(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;


              //litexp
            case "litexp/l1_litexp_writing_op_seq__add_mult":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__litexp__l1_litexp_writing_op_seq__add_mult(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "litexp/l1_litexp_writing_op_seq__op4":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__litexp__l1_litexp_writing_op_seq__op4(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "litexp/l1_litexp_expr_to_x__add_mult":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__litexp__l1_litexp_expr_to_x__add_mult(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "litexp/l1_litexp_expr_to_x__op4":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__litexp__l1_litexp_expr_to_x__op4(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "litexp/l1plus_litexp_reduced_expr_to_x__op4":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__litexp__l1plus_litexp_reduced_expr_to_x__op4(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "litexp/l2_litexp_writing_2":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__litexp__l2_litexp_writing_2(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "litexp/l3_litexp_writing_3__v1":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__litexp__l3_litexp_writing_3__v1(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "litexp/l4_litexp_writing_sq_capped":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__litexp__l4_litexp_writing_sq_capped(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "litexp/l10_litexp_eval_x":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__litexp__l10_litexp_eval_x(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "litexp/l10b_litexp_eval_xneg":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__litexp__l10b_litexp_eval_xneg(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "litexp/l10c_litexp_eval_xdec":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__litexp__l10c_litexp_eval_xdec(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "litexp/l11_litexp_eval_xy":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__litexp__l11_litexp_eval_xy(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;


              //eq
            case "eq/eq1_add_near":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge({isEq: true});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__eq__eq1_add_near(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "eq/eq2_add_far":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge({isEq: true});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__eq__eq2_add_far(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "eq/eq3_add__side_explicit_with_number_symbol":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge({isEq: true});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__eq__eq3_add__side_explicit_with_number_symbol(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "eq/eq4_add__side_magic":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge({isEq: true});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__eq__eq4_add__side_magic(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "eq/eq5_mult":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders({isEq: true});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__eq__eq5_mult(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "eq/eq7_mult__side_magic":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_only2({isEq: true});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__eq__eq7_mult__side_magic(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "eq/eq8_left__side_magic":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge({isEq: true});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__eq__eq8_left__side_magic(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "eq/eq9_op4":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge({isEq: true});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__eq__eq9_op4(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "eq/eq10_magic4":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders({isEq: true});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__eq__eq10_magic4(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

              //CS
            case "cs/cs1_array_index_assignment":
              {
                //easy?

                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__cs__cs1_array_index_assignment(infiniteCanvas, golfCourse, stepGeneratorFunc);
      
                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };

              }
              break;

              //funcs
            case "funcs/f1_function_operators":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge({layout__op: "waveform"});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__funcs__f1_function_operators(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "funcs/f2_function_operators_2":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge({layout__op: "waveform"});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__funcs__f2_function_operators_2(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "funcs/f3a_function_composition_0":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders(/*{layout__op: "waveform"}*/);

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__funcs__f3a_function_composition_0(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "funcs/f3_function_composition":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge({layout__op: "waveform"});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__funcs__f3_function_composition(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "funcs/f4_function_composition":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge({layout__op: "waveform"});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__funcs__f4_function_composition(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "funcs/f4z_function_composition_expr":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders(/*{layout__op: "waveform"}*/);

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__funcs__f4z_function_composition_expr(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "funcs/f5_function_evaluation__bound_vs_free":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge({layout__op: "waveform"});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__funcs__f5_function_evaluation__bound_vs_free(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "funcs/f6_function_evaluation__bound_vs_free_2":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders({layout__op: "waveform"});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__funcs__f6_function_evaluation__bound_vs_free_2(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "funcs/f10_function_creation_via_composition":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge({layout__op: "waveform", arr_component__additional: ["pre_validation"]});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__funcs__f10_function_creation_via_composition(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "funcs/f20_function_evaluation__gm_grid":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders({layout__op: "waveform"});

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__funcs__f6_function_evaluation__bound_vs_free_2(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

              //complex numbers

            case "complex/cx0_addsub_pure":
            {
              const golfCourseConfig  = GolfCourseConfig.template_challenge();

              const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__complex__cx0_addsub_pure(infiniteCanvas, golfCourse, stepGeneratorFunc);

              outChallenge = {
                golfCourseConfig:  golfCourseConfig,
                stepGeneratorFunc: stepGeneratorFunc,
              };
            }
            break;

            case "complex/cx1_addsub_big_chunks":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__complex__cx1_addsub_big_chunks(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "complex/cx2_addsub_frac":
            {
              const golfCourseConfig  = GolfCourseConfig.template_challenge();

              const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__complex__cx2_addsub_frac(infiniteCanvas, golfCourse, stepGeneratorFunc);

              outChallenge = {
                golfCourseConfig:  golfCourseConfig,
                stepGeneratorFunc: stepGeneratorFunc,
              };
            }
            break;

            case "complex/cx3_addsub_frac_and_irrat":
            {
              const golfCourseConfig  = GolfCourseConfig.template_challenge();

              const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__complex__cx3_addsub_frac_and_irrat(infiniteCanvas, golfCourse, stepGeneratorFunc);

              outChallenge = {
                golfCourseConfig:  golfCourseConfig,
                stepGeneratorFunc: stepGeneratorFunc,
              };
            }
            break;

            case "complex/cx4_addsub_mult_re":
            {
              const golfCourseConfig  = GolfCourseConfig.template_challenge();

              const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__complex__cx4_addsub_mult_re(infiniteCanvas, golfCourse, stepGeneratorFunc);

              outChallenge = {
                golfCourseConfig:  golfCourseConfig,
                stepGeneratorFunc: stepGeneratorFunc,
              };
            }
            break;

            case "complex/cx5_addsub_mult_im":
            {
              const golfCourseConfig  = GolfCourseConfig.template_challenge();

              const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__complex__cx5_addsub_mult_im(infiniteCanvas, golfCourse, stepGeneratorFunc);

              outChallenge = {
                golfCourseConfig:  golfCourseConfig,
                stepGeneratorFunc: stepGeneratorFunc,
              };
            }
            break;

            case "complex/cx6_addsub_mult_re_im":
            {
              const golfCourseConfig  = GolfCourseConfig.template_challenge();

              const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__complex__cx6_addsub_mult_re_im(infiniteCanvas, golfCourse, stepGeneratorFunc);

              outChallenge = {
                golfCourseConfig:  golfCourseConfig,
                stepGeneratorFunc: stepGeneratorFunc,
              };
            }
            break;

            case "complex/cxin1_mult":
            {
              const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

              const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__complex__cxin1_mult(infiniteCanvas, golfCourse, stepGeneratorFunc);

              outChallenge = {
                golfCourseConfig:  golfCourseConfig,
                stepGeneratorFunc: stepGeneratorFunc,
              };
            }
            break;



            case "complex/cx10_modulus":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge();
  
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__complex__cx10_modulus(infiniteCanvas, golfCourse, stepGeneratorFunc);
  
                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;

            case "complex/cx11_modargconj":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();
  
                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__complex__cx11_modargconj(infiniteCanvas, golfCourse, stepGeneratorFunc);
  
                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            

              //internal
            case "internal/in001_add_tables__que":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders__5();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__internal__in001_add_tables__que(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "internal/in002_add_tables__ans":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__internal__in002_add_tables__ans(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;


            case "internal/in1_mult_tables__que":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__internal__in1_mult_tables__que(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "internal/in2_mult_tables__ans":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__internal__in2_mult_tables__ans(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;


              case "internal/in1w_mult_tables__que__written":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__internal__in1w_mult_tables__que__written(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;


              //X
            case "X/x1_tables_X_decimal__que1":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__X__x1_tables_X_decimal__que1(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "X/x2_tables_X_decimal__que2":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__X__x2_tables_X_decimal__que2(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;
            case "X/x3_tables_X_decimal__que3":
              {
                const golfCourseConfig  = GolfCourseConfig.template_challenge_with_placeholders__5();

                const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__X__x3_tables_X_decimal__que3(infiniteCanvas, golfCourse, stepGeneratorFunc);

                outChallenge = {
                  golfCourseConfig:  golfCourseConfig,
                  stepGeneratorFunc: stepGeneratorFunc,
                };
              }
              break;


            default:
              {
                throw new Error("createChallengeForRoute, Unsupported categ: " + categ);
              }
              break;
          }

          return outChallenge;
        }

      }





      class GolfGame__Endless_Practice {

        constructor(infiniteCanvas, cfg) {
          this.infiniteCanvas = infiniteCanvas;

          const golfCourseConfig  = cfg.challenge.golfCourseConfig;
          const stepGeneratorFunc = cfg.challenge.stepGeneratorFunc;


          const golfCourse = new GolfCourse(infiniteCanvas, golfCourseConfig);
          this.golfCourse  = golfCourse;

          //prepare golf course
          this.prepareGolfCourse(golfCourse);

          //create first step
          const step = stepGeneratorFunc(golfCourse);

          //start game
          step.start();
        }

        prepareGolfCourse(golfCourse) {
          logger.log("logGolfPractice", "prepareGolfCourse", golfCourse);

          const infiniteCanvas = this.infiniteCanvas;

          //clear
          //nothing to clear

          //add "Impossible" button
          // {
          //   const rect_rel__button = {
          //     l: 0.80,
          //     r: 0.90,
          //     t: 0.02,
          //     b: 0.08,
          //   };
          //   const trueRect__button = Geometry.rectForRectRel(rect_rel__button, golfCourse.rect);

          //   const icObj__button = infiniteCanvas.createIcButton(trueRect__button);
          //   infiniteCanvas.addIcObject(icObj__button);

          //   golfCourse.components["button_impossible"] = {
          //     icObj: icObj__button,
          //   };

          // }



          if (golfCourse.components["hole"]) {
            const icObj__hole = golfCourse.components["hole"].icObj;

            const icObj__facade    = icObj__hole.parts["facade"];
            const icObj__touchSlot = icObj__hole.parts["touchSlot"];

            // logger.log("icObj__facade", icObj__facade);
            // icObj__facade.originX = "right";
            // icObj__facade.fill = "blue";
            // logger.log("icObj__facade", icObj__facade);

            const rep_free__hole = infiniteCanvas.getRepresented(icObj__hole.id).r_free();
            const rep_free__facade = rep_free__hole.parts.facade;
            const rep_free__touchSlot = rep_free__hole.parts.touchSlot;

            rep_free__hole.compositeConfig[rep_free__facade.id].isMobile    = true;
            rep_free__hole.compositeConfig[rep_free__touchSlot.id].isMobile = true;


            rep_free__facade.originX = "right";
            rep_free__facade.position = {
              x: rep_free__facade.position.x,
              y: rep_free__facade.position.y - 150,
            };
            rep_free__facade.zIndex = 200;

            rep_free__touchSlot.position = {
              x: rep_free__touchSlot.position.x,
              y: rep_free__touchSlot.position.y + 100,
            };


            rep_free__hole.compositeConfig[rep_free__facade.id].isMobile    = false;
            rep_free__hole.compositeConfig[rep_free__touchSlot.id].isMobile = false;


          }

        }

        // static random_challengeMathNodeConfig() {
        //   logger.log("random_challengeMathNodeConfig");
        //
        //   const mathNode__initial = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
        //   mathNode__initial.autoSimplify = true;
        //
        //   const mathNode__target  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
        //
        //   // const min__nb_operators = 2;
        //   // const max__nb_operators = 5;
        //   // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
        //   const nb_operators = 4;
        //
        //   const arr_operatorNodeFunc = [...new Array(nb_operators).keys()].map(index => {
        //     const operatorNodeFunc = random_operatorNodeFactoryFunc_binary(["ConstantNode"]);
        //     return operatorNodeFunc;
        //   });
        //
        //   const mathNodeConfig = {
        //     initial: mathNode__initial,
        //     target : mathNode__target,
        //     operatorFuncs: arr_operatorNodeFunc,
        //   };
        //
        //   return mathNodeConfig;
        // }

        static random_challengeGMItemConfig(range_initial, range_target) {
          // logger.log("random_challengeGMItemConfig");

          // const mathNode__initial = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
          const mathNode__initial = random_constantNode(range_initial);
          mathNode__initial.autoSimplify = true;
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");

          // const mathNode__target  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
          const mathNode__target = random_constantNode(range_target);
          const gmItem__target   = GMItem.value(mathNode__target, "target", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: -10,
                  max: +10,
                },
              },
            };

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams);
            logger.log("logGolf", "random_challengeGMItemConfig", "operatorNodeFuncWrapper:", operatorNodeFuncWrapper);
            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const func_decorated = func;

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };


            // const gmItem__operator = GMItem.operator(func, name, "", specs);
            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator;
          });

          const gmItemConfig = {
            initial:   gmItem__initial,
            target:    gmItem__target,
            operators: arr_gmItem_operator,
          };

          return gmItemConfig;
        }

        static random_challengeGMItemConfig__x_to_expr() {
          // logger.log("random_challengeGMItemConfig__x_to_expr");

          const mathNode__initial = new math.SymbolNode("x");
          // mathNode__initial.autoSimplify = true;
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: -10,
                  max: +10,
                },
              },
            };

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams);
            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };


            const func_decorated = func;

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };


            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, 4);

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,
            operators: arr_gmItem_operator,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__x_to_expr__shuffled() {
          // logger.log("random_challengeGMItemConfig__x_to_expr__shuffled");

          const mathNode__initial = new math.SymbolNode("y");
          // mathNode__initial.autoSimplify = true;
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: -10,
                  max: +10,
                },
              },
              isShuffled: true,
            };

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams);
            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };


            const func_decorated = func;

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, 4);

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,
            operators: arr_gmItem_operator,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__expr_to_x() {
          // logger.log("random_challengeGMItemConfig__expr_to_x");

          const mathNode__target = new math.SymbolNode("x");
          // mathNode__initial.autoSimplify = true;
          const gmItem__target = GMItem.value(mathNode__target, "target", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: -10,
                  max: +10,
                },
              },
            };

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams);
            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const func_decorated = func;

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };
            
            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const depth__initial = 4;
          // const depth__initial    = 10;

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__target, arr_gmItem_operator, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const func_decorated = func;

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            // operators:  arr_gmItem_operator,
            operators: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        //fractions

        static random_challengeGMItemConfig__frac_to_one() {
          // logger.log("random_challengeGMItemConfig__frac_to_one");

          // const mathNode__target = new math.SymbolNode("x");
          const mathNode__target = new math.ConstantNode(1);
          // mathNode__initial.autoSimplify = true;
          const gmItem__target = GMItem.value(mathNode__target, "target", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const arr_op = [
              op_multiply,
              op_divide,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            // const func_decorated = function(mathNode_in) {
            //   logger.log("func_decorated, mathNode_in", mathNode_in);
            //   var outMathNode;
            //
            //   //legacy
            //   outMathNode = func(mathNode_in);
            //
            //   //decoration
            //   outMathNode = Simplifier.simplify_fraction(outMathNode);
            //   logger.log("func_decorated, outMathNode", outMathNode);
            //
            //
            //   return outMathNode;
            // };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };


            const func_decorated = func;

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const depth__initial = 4;
          // const depth__initial    = 10;

          const gmItem__initial_seed = gmItem__target.clone();
          gmItem__initial_seed.content.autoSimplify = true;
          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial_seed, arr_gmItem_operator, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };


            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            // operators:  arr_gmItem_operator,
            operators: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__one_to_frac() {
          // logger.log("random_challengeGMItemConfig__one_to_frac");

          const mathNode__initial = new math.ConstantNode(1);
          mathNode__initial.autoSimplify = true;
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const arr_op = [
              op_multiply,
              op_divide,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });


          const depth__target = 4;

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const mathNode__target = gmItem__target.content;
          mathNode__target.autoSimplify = true;


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__frac_to_frac() {
          // logger.log("random_challengeGMItemConfig__one_to_frac");

          const mathNode__one = new math.ConstantNode(1);
          mathNode__one.autoSimplify = true;
          const gmItem__one = GMItem.value(mathNode__one, "one", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const arr_op = [
              op_multiply,
              op_divide,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });


          const depth__initial = 4;

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__inverse, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;


          const depth__target = 4;

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const mathNode__target = gmItem__target.content;
          mathNode__target.autoSimplify = true;


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__frac_to_frac__decomp() {
          // logger.log("random_challengeGMItemConfig__one_to_frac");

          const mathNode__one = new math.ConstantNode(1);
          mathNode__one.autoSimplify = true;
          const gmItem__one = GMItem.value(mathNode__one, "one", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const arr_op = [
              op_multiply,
              op_divide,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });


          const depth__initial = 4;

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__inverse, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          gmItem__initial.content = Rewriter.decomposition_product_primes(mathNode__initial);
          mathNode__initial.autoSimplify = true;


          const depth__target = 4;

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const mathNode__target = gmItem__target.content;
          gmItem__target.content = Rewriter.decomposition_product_primes(mathNode__target);
          mathNode__target.autoSimplify = true;


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__frac_to_frac__decomp_simple() {
          // logger.log("random_challengeGMItemConfig__one_to_frac");

          const mathNode__one = new math.ConstantNode(1);
          mathNode__one.autoSimplify = true;
          const gmItem__one = GMItem.value(mathNode__one, "one", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                // range: {
                //   min: +1,
                //   max: +10,
                // },
                arr: [2, 3, 5, 7],
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const arr_op = [
              op_multiply,
              op_divide,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });


          const depth__initial = 4;

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__inverse, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          gmItem__initial.content = Rewriter.decomposition_product_primes(mathNode__initial);
          mathNode__initial.autoSimplify = true;


          const depth__target = 4;

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const mathNode__target = gmItem__target.content;
          gmItem__target.content = Rewriter.decomposition_product_primes(mathNode__target);
          mathNode__target.autoSimplify = true;


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__frac_to_frac__letters() {
          // logger.log("random_challengeGMItemConfig__one_to_frac");

          const mathNode__one = new math.ConstantNode(1);
          mathNode__one.autoSimplify = true;
          const gmItem__one = GMItem.value(mathNode__one, "one", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const arr_op = [
              op_multiply,
              op_divide,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_fraction(outMathNode);
              outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });


          const depth__initial = 4;

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__inverse, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          gmItem__initial.content = Rewriter.decomposition_product_primes(mathNode__initial);
          mathNode__initial.autoSimplify = true;


          const depth__target = 4;

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const mathNode__target = gmItem__target.content;
          gmItem__target.content = Rewriter.decomposition_product_primes(mathNode__target);
          mathNode__target.autoSimplify = true;


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__frac_add() {
          // logger.log("random_challengeGMItemConfig__one_to_frac");

          // const mathNode__one = new math.ConstantNode(1);
          // mathNode__one.autoSimplify = true;
          // const gmItem__one = GMItem.value(mathNode__one, "one", "");

          function createInitialGMItem(index) {

            const mathNode__numerator = new math.ConstantNode(1);
            const value__denominator = Utils.randomElementInArray([2, 3, 4, 5, 6, 7, 8, 9]);
            const mathNode__denominator = new math.ConstantNode(value__denominator);

            const mathNode__initial = new math.OperatorNode("/", "divide", [mathNode__numerator, mathNode__denominator]);

            const gmItem__initial = GMItem.value(mathNode__initial, "initial_" + index, "");
            gmItem__initial.content = Rewriter.decomposition_product_primes(mathNode__initial);
            gmItem__initial.content.autoSimplify = true;

            return gmItem__initial;
          }

          const nb_initial = 2;
          const arr_gmItem_initial = [...Array(nb_initial).keys()].map(createInitialGMItem);
          const arr_mathNode_initial = arr_gmItem_initial.map(gmItem => gmItem.content);

          const arr_factor = [2, 3, 5, 7];
          const arr_gmItem_operator = arr_factor.map(factor => {

            const op = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(factor);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_fraction(outMathNode);
              // outMathNode = Rewriter.decomposition_product_primes(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              // mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              // mathNode__new.isEquation = true;

              const facade__new = icObj.deepClone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const depth__target = 4;

          const mathNode__target = new math.OperatorNode("+", "add", arr_mathNode_initial);
          const gmItem__target = GMItem.value(mathNode__target, "target", "");
          // gmItem__target.content = Rewriter.decomposition_product_primes(mathNode__target);
          // mathNode__target.autoSimplify = true;


          const gmItemConfig = {
            initial: arr_gmItem_initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            // operators__inverse:  arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }

        //equations

        static random_challengeGMItemConfig__equation_1() {
          logger.log("random_challengeGMItemConfig__equation_1");

          const mathNode__left = new math.SymbolNode("x");

          // const mathNode__right  = new math.ConstantNode(3);
          const mathNode__right = random_terminal_mathNode_withType_inArr(["ConstantNode"]);

          const mathNode__target = new math.RelationalNode(["equal"], [mathNode__left, mathNode__right]);
          mathNode__target.isEquation = true;

          const gmItem__target = GMItem.value(mathNode__target, "target", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const op_add = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          const depth__initial = 4;
          // const depth__initial    = 10;

          const gmItem__initial_seed = gmItem__target.clone();
          gmItem__initial_seed.content.autoSimplify = true;
          gmItem__initial_seed.content.isEquation = true;

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial_seed, arr_gmItem_operator, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;

          logger.log("gmItem__initial", gmItem__initial);

          // const mathNode__initial = new math.ConstantNode(79);
          // const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");



          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_full(outMathNode);
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator__inverse,
            operators__inverse: arr_gmItem_operator,
          };

          return gmItemConfig;
        }



        //litexp writing

        static random_challengeGMItemConfig__litexp_writing_1() {
          logger.log("random_challengeGMItemConfig__litexp_writing_1");

          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_equation(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          const depth__target = 4;
          // const depth__target = 10;

          const mathNode__initial = new math.SymbolNode("x");
          const gmItem__initial = GMItem.value(mathNode__initial, "target", "");
          logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          // mathNode__target.autoSimplify = true;



          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_full(outMathNode);
              // outMathNode = Simplifier.simplify_equation(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator__inverse,
            operators__inverse: arr_gmItem_operator,
          };

          return gmItemConfig;
        }



        static random_challengeGMItemConfig__litexp_writing_2() {
          logger.log("random_challengeGMItemConfig__litexp_writing_2");

          const nb_operators = 4;

          const nb_operators__constant = 2;
          const arr_gmItem_operator__constant = [...new Array(nb_operators__constant).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__symbol = 2;
          const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["SymbolNode"],
                arr: ["x"],
              },
              premultiplier: {
                n_type: "integer",
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              // operatorNode: operatorNodeFuncWrapper.operatorNode,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];



          const depth__target = 4;
          // const depth__target = 10;

          const mathNode__initial = new math.SymbolNode("x");
          const gmItem__initial = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial: gmItem__initial,
            target:  gmItem__target,

            operators: arr_gmItem_operator__inverse,
            operators__inverse: arr_gmItem_operator,
          };

          return gmItemConfig;
        }



        static random_challengeGMItemConfig__litexp_writing_3() {
          logger.log("random_challengeGMItemConfig__litexp_writing_3");

          const nb_operators = 4;

          const nb_operators__constant = 2;
          const arr_gmItem_operator__constant = [...new Array(nb_operators__constant).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const op_add = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__symbol = 2;
          const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["SymbolNode"],
                arr: ["x"],
              },
              premultiplier: {
                n_type: "integer",
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide = Operator.divide();
            const op_add = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            // const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);
            //kill random
            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op.slice(index, index + 1));

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              // operatorNode: operatorNodeFuncWrapper.operatorNode,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];



          const depth__target = 4;
          // const depth__target = 10;

          const mathNode__x = new math.SymbolNode("x");
          const mathNode__0 = new math.ConstantNode(0);
          const mathNode__1 = new math.ConstantNode(1);
          const mathNode__2 = new math.ConstantNode(2);

          const mathNode__initial = Utils.randomElementInArray([mathNode__x, mathNode__0, mathNode__1]);
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          const mathNode__target__simplified = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = mathNode__target__simplified;

          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            operators__inverse: [],
          };

          return gmItemConfig;
        }



      }





      class GolfGameStep__Endless_Practice {

        constructor(infiniteCanvas, golfStepConfig, golfCourse, stepGeneratorFunc) {

          this.infiniteCanvas = infiniteCanvas;
          // this.golfStepConfig = golfStepConfig;
          this.golfCourse = golfCourse;

          this.stepGeneratorFunc = stepGeneratorFunc;

          this.configure(golfStepConfig);

        }

        // static easy_challenge(easy_challengeConfig) {
        //   const golfCourseConfig  = GolfCourseConfig.template_challenge();

        //   const stepGeneratorFunc = (golfCourse) => GolfGameStep__Endless_Practice.randomInstance__funcs__cs1_array_index_assignment(infiniteCanvas, golfCourse, stepGeneratorFunc);

        //   outChallenge = {
        //     golfCourseConfig:  golfCourseConfig,
        //     stepGeneratorFunc: stepGeneratorFunc,
        //   };
        // }

        static randomInstance1(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          // const game = this;
          // const challengeMathNodeConfig = GolfGame__Endless_Practice.random_challengeMathNodeConfig();
          // const stepConfig = {
          //   challengeMathNodeConfig: challengeMathNodeConfig,
          //   // game: game,
          // };

          const range_initial = { min:    0, max:  10, step: 1 };
          const range_target  = { min: -100, max: 100, step: 1 };

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig(range_initial, range_target);
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance2(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          // const game = this;
          // const challengeMathNodeConfig = GolfGame__Endless_Practice.random_challengeMathNodeConfig();
          // const stepConfig = {
          //   challengeMathNodeConfig: challengeMathNodeConfig,
          //   // game: game,
          // };

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__x_to_expr();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance3(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          // const game = this;
          // const challengeMathNodeConfig = GolfGame__Endless_Practice.random_challengeMathNodeConfig();
          // const stepConfig = {
          //   challengeMathNodeConfig: challengeMathNodeConfig,
          //   // game: game,
          // };

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__x_to_expr__shuffled();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance4(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          // const game = this;
          // const challengeMathNodeConfig = GolfGame__Endless_Practice.random_challengeMathNodeConfig();
          // const stepConfig = {
          //   challengeMathNodeConfig: challengeMathNodeConfig,
          //   // game: game,
          // };

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__expr_to_x();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        //fractions

        static randomInstance__frac_to_one(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_one();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static randomInstance__one_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__one_to_frac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static randomInstance__frac_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_frac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance__frac_to_frac__decomp(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_frac__decomp();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance__frac_to_frac__decomp_simple(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_frac__decomp_simple();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance__frac_to_frac__letters(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_frac__letters();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        // static randomInstance__frac_add(infiniteCanvas, golfCourse, stepGeneratorFunc) {
        //
        //   const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_add();
        //   const stepConfig = {
        //     challengeGMItemConfig: challengeGMItemConfig,
        //     challengeType: "frac_add",
        //   };
        //
        //   const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);
        //
        //   return step;
        // }


        static randomInstance__one_to_frac__decomp(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_frac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance__one_to_frac__mixed(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_frac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        //equations

        static randomInstance__equation_1(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__equation_1();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        //litexp

        static randomInstance__litexp_writing_1(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__litexp_writing_1();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance__litexp_writing_2(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__litexp_writing_2();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance__litexp_writing_3(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__litexp_writing_3();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }



        //numer
        static randomInstance__num__0_to_HTU(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__0_to_HTU();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__num__0_to_HTU() {
          logger.log("random_challengeGMItemConfig__num__0_to_HTU");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+1000,+100,+10,+1].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          // const nb_operators__symbol = 0;
          // const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {
          //
          //   const operatorParams = {
          //     node_b: {
          //       types: ["SymbolNode"],
          //       arr:["x"],
          //     },
          //     premultiplier: {
          //       n_type: "integer",
          //       range: {
          //         min: +1,
          //         max: +10,
          //       },
          //     },
          //   };
          //
          //   const op_multiply = Operator.multiply();
          //   const op_divide   = Operator.divide();
          //   const op_add      = Operator.fromOpString_binary("+");
          //   const op_subtract = Operator.fromOpString_binary("-");
          //
          //   const arr_op = [
          //     // op_multiply,
          //     // op_divide,
          //
          //     op_add,
          //     op_subtract,
          //   ];
          //
          //   const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);
          //
          //   const name = operatorNodeFuncWrapper.semantics.name;
          //
          //   const func = operatorNodeFuncWrapper.func;
          //   const func_decorated = function(mathNode_in) {
          //     logger.log("func_decorated, mathNode_in", mathNode_in);
          //     var outMathNode;
          //
          //     //legacy
          //     outMathNode = func(mathNode_in);
          //
          //     //decoration
          //     outMathNode = Simplifier.simplify_litexp_2(outMathNode);
          //     // logger.log("func_decorated, outMathNode", outMathNode);
          //
          //     return outMathNode;
          //   };
          //   // const func_decorated = func;
          //
          //   const specs = {
          //     funcWrapper:  operatorNodeFuncWrapper,
          //     // operatorNode: operatorNodeFuncWrapper.operatorNode,
          //   };
          //
          //   const transformationFunc = function(icObj) {
          //     var transformationOutput;
          //
          //     logger.log("transformationFunc", icObj);
          //
          //     const facade = icObj;
          //
          //     const mathNode__in  = facade.mathNode;
          //     mathNode__in.isEquation = false;
          //     const mathNode__new = func_decorated(mathNode__in);
          //     mathNode__new.isEquation = false;
          //
          //     const facade__new = icObj.clone();
          //     facade__new.mathNode = mathNode__new;
          //     transformationOutput = new TransformationOutput("mutated", facade__new, facade);
          //
          //     return transformationOutput;
          //   };
          //
          //   const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
          //   return gmItem__operator;
          // });
          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__num__0_to_HTU__missing100(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__0_to_HTU__missing100();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__num__0_to_HTU__missing100() {
          logger.log("random_challengeGMItemConfig__num__0_to_HTU__missing100");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+1000,+0,+10,+1].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          // const nb_operators__symbol = 0;
          // const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {
          //
          //   const operatorParams = {
          //     node_b: {
          //       types: ["SymbolNode"],
          //       arr:["x"],
          //     },
          //     premultiplier: {
          //       n_type: "integer",
          //       range: {
          //         min: +1,
          //         max: +10,
          //       },
          //     },
          //   };
          //
          //   const op_multiply = Operator.multiply();
          //   const op_divide   = Operator.divide();
          //   const op_add      = Operator.fromOpString_binary("+");
          //   const op_subtract = Operator.fromOpString_binary("-");
          //
          //   const arr_op = [
          //     // op_multiply,
          //     // op_divide,
          //
          //     op_add,
          //     op_subtract,
          //   ];
          //
          //   const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);
          //
          //   const name = operatorNodeFuncWrapper.semantics.name;
          //
          //   const func = operatorNodeFuncWrapper.func;
          //   const func_decorated = function(mathNode_in) {
          //     logger.log("func_decorated, mathNode_in", mathNode_in);
          //     var outMathNode;
          //
          //     //legacy
          //     outMathNode = func(mathNode_in);
          //
          //     //decoration
          //     outMathNode = Simplifier.simplify_litexp_2(outMathNode);
          //     // logger.log("func_decorated, outMathNode", outMathNode);
          //
          //     return outMathNode;
          //   };
          //   // const func_decorated = func;
          //
          //   const specs = {
          //     funcWrapper:  operatorNodeFuncWrapper,
          //     // operatorNode: operatorNodeFuncWrapper.operatorNode,
          //   };
          //
          //   const transformationFunc = function(icObj) {
          //     var transformationOutput;
          //
          //     logger.log("transformationFunc", icObj);
          //
          //     const facade = icObj;
          //
          //     const mathNode__in  = facade.mathNode;
          //     mathNode__in.isEquation = false;
          //     const mathNode__new = func_decorated(mathNode__in);
          //     mathNode__new.isEquation = false;
          //
          //     const facade__new = icObj.clone();
          //     facade__new.mathNode = mathNode__new;
          //     transformationOutput = new TransformationOutput("mutated", facade__new, facade);
          //
          //     return transformationOutput;
          //   };
          //
          //   const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
          //   return gmItem__operator;
          // });
          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          // const mathNode__target = gmItem__target.content;

          gmItem__target.content = new math.OperatorNode("+", "add", [gmItem__target.content, new math.ConstantNode(100)]);

          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(gmItem__target.content);


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__num__0_to_HTU__missing1000_10(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__0_to_HTU__missing1000_10();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__num__0_to_HTU__missing1000_10() {
          logger.log("random_challengeGMItemConfig__num__0_to_HTU__missing1000_10");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+0,+100,+0,+1].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              // logger.log("transformationFunc", icObj);

              const facade = icObj;
              // logger.log("facade", facade);

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();

              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("new", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          // const nb_operators__symbol = 0;
          // const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {
          //
          //   const operatorParams = {
          //     node_b: {
          //       types: ["SymbolNode"],
          //       arr:["x"],
          //     },
          //     premultiplier: {
          //       n_type: "integer",
          //       range: {
          //         min: +1,
          //         max: +10,
          //       },
          //     },
          //   };
          //
          //   const op_multiply = Operator.multiply();
          //   const op_divide   = Operator.divide();
          //   const op_add      = Operator.fromOpString_binary("+");
          //   const op_subtract = Operator.fromOpString_binary("-");
          //
          //   const arr_op = [
          //     // op_multiply,
          //     // op_divide,
          //
          //     op_add,
          //     op_subtract,
          //   ];
          //
          //   const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);
          //
          //   const name = operatorNodeFuncWrapper.semantics.name;
          //
          //   const func = operatorNodeFuncWrapper.func;
          //   const func_decorated = function(mathNode_in) {
          //     logger.log("func_decorated, mathNode_in", mathNode_in);
          //     var outMathNode;
          //
          //     //legacy
          //     outMathNode = func(mathNode_in);
          //
          //     //decoration
          //     outMathNode = Simplifier.simplify_litexp_2(outMathNode);
          //     // logger.log("func_decorated, outMathNode", outMathNode);
          //
          //     return outMathNode;
          //   };
          //   // const func_decorated = func;
          //
          //   const specs = {
          //     funcWrapper:  operatorNodeFuncWrapper,
          //     // operatorNode: operatorNodeFuncWrapper.operatorNode,
          //   };
          //
          //   const transformationFunc = function(icObj) {
          //     var transformationOutput;
          //
          //     logger.log("transformationFunc", icObj);
          //
          //     const facade = icObj;
          //
          //     const mathNode__in  = facade.mathNode;
          //     mathNode__in.isEquation = false;
          //     const mathNode__new = func_decorated(mathNode__in);
          //     mathNode__new.isEquation = false;
          //
          //     const facade__new = icObj.clone();
          //     facade__new.mathNode = mathNode__new;
          //     transformationOutput = new TransformationOutput("mutated", facade__new, facade);
          //
          //     return transformationOutput;
          //   };
          //
          //   const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
          //   return gmItem__operator;
          // });
          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          // const mathNode__target = gmItem__target.content;

          gmItem__target.content = new math.OperatorNode("+", "add", [gmItem__target.content, new math.ConstantNode(1010)]);

          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(gmItem__target.content);


          // const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {
          //
          //   const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
          //   // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);
          //
          //   const operator__inverse = operatorNodeFuncWrapper.semantics.operator;
          //
          //   const name = operatorNodeFuncWrapper.semantics.name;
          //   const func = operatorNodeFuncWrapper.func;
          //   const func_decorated = function(mathNode_in) {
          //     logger.log("func_decorated, mathNode_in", mathNode_in);
          //     var outMathNode;
          //
          //     //legacy
          //     outMathNode = func(mathNode_in);
          //
          //     //decoration
          //     outMathNode = Simplifier.simplify_litexp_2(outMathNode);
          //     // logger.log("func_decorated, outMathNode", outMathNode);
          //
          //     return outMathNode;
          //   };
          //
          //   const specs = {
          //     funcWrapper: operatorNodeFuncWrapper,
          //   };
          //
          //   const transformationFunc = function(icObj) {
          //     var transformationOutput;
          //
          //     logger.log("transformationFunc", icObj);
          //
          //     const facade = icObj;
          //
          //     const mathNode__in  = facade.mathNode;
          //     mathNode__in.isEquation = false;
          //     const mathNode__new = func_decorated(mathNode__in);
          //     mathNode__new.isEquation = false;
          //
          //     const facade__new = icObj.clone();
          //     facade__new.mathNode = mathNode__new;
          //     transformationOutput = new TransformationOutput("mutated", facade__new, facade);
          //
          //     return transformationOutput;
          //   };
          //
          //   const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);
          //
          //   return gmItem__operator__inverse;
          // });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__num__HTU_to_0(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__HTU_to_0();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__num__HTU_to_0() {
          logger.log("random_challengeGMItemConfig__num__HTU_to_0");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+1000,+100,+10,+1].map(number => {
            const op_sub = Operator.fromOpString_binary("-");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          // const nb_operators__symbol = 0;
          // const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {
          //
          //   const operatorParams = {
          //     node_b: {
          //       types: ["SymbolNode"],
          //       arr:["x"],
          //     },
          //     premultiplier: {
          //       n_type: "integer",
          //       range: {
          //         min: +1,
          //         max: +10,
          //       },
          //     },
          //   };
          //
          //   const op_multiply = Operator.multiply();
          //   const op_divide   = Operator.divide();
          //   const op_add      = Operator.fromOpString_binary("+");
          //   const op_subtract = Operator.fromOpString_binary("-");
          //
          //   const arr_op = [
          //     // op_multiply,
          //     // op_divide,
          //
          //     op_add,
          //     op_subtract,
          //   ];
          //
          //   const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);
          //
          //   const name = operatorNodeFuncWrapper.semantics.name;
          //
          //   const func = operatorNodeFuncWrapper.func;
          //   const func_decorated = function(mathNode_in) {
          //     logger.log("func_decorated, mathNode_in", mathNode_in);
          //     var outMathNode;
          //
          //     //legacy
          //     outMathNode = func(mathNode_in);
          //
          //     //decoration
          //     outMathNode = Simplifier.simplify_litexp_2(outMathNode);
          //     // logger.log("func_decorated, outMathNode", outMathNode);
          //
          //     return outMathNode;
          //   };
          //   // const func_decorated = func;
          //
          //   const specs = {
          //     funcWrapper:  operatorNodeFuncWrapper,
          //     // operatorNode: operatorNodeFuncWrapper.operatorNode,
          //   };
          //
          //   const transformationFunc = function(icObj) {
          //     var transformationOutput;
          //
          //     logger.log("transformationFunc", icObj);
          //
          //     const facade = icObj;
          //
          //     const mathNode__in  = facade.mathNode;
          //     mathNode__in.isEquation = false;
          //     const mathNode__new = func_decorated(mathNode__in);
          //     mathNode__new.isEquation = false;
          //
          //     const facade__new = icObj.clone();
          //     facade__new.mathNode = mathNode__new;
          //     transformationOutput = new TransformationOutput("mutated", facade__new, facade);
          //
          //     return transformationOutput;
          //   };
          //
          //   const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
          //   return gmItem__operator;
          // });
          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];





          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target    = 7;


          const mathNode__target = new math.ConstantNode(0);
          const gmItem__target   = GMItem.value(mathNode__target, "target", "");


          const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__target, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        static randomInstance__num__HTU_to_HTU(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__HTU_to_HTU();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__num__HTU_to_HTU() {
          logger.log("random_challengeGMItemConfig__num__HTU_to_HTU");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+1000,+100,+10,+1].map(number => {
            const op_sub = Operator.fromOpString_binary("-");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          // const nb_operators__symbol = 0;
          // const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {
          //
          //   const operatorParams = {
          //     node_b: {
          //       types: ["SymbolNode"],
          //       arr:["x"],
          //     },
          //     premultiplier: {
          //       n_type: "integer",
          //       range: {
          //         min: +1,
          //         max: +10,
          //       },
          //     },
          //   };
          //
          //   const op_multiply = Operator.multiply();
          //   const op_divide   = Operator.divide();
          //   const op_add      = Operator.fromOpString_binary("+");
          //   const op_subtract = Operator.fromOpString_binary("-");
          //
          //   const arr_op = [
          //     // op_multiply,
          //     // op_divide,
          //
          //     op_add,
          //     op_subtract,
          //   ];
          //
          //   const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);
          //
          //   const name = operatorNodeFuncWrapper.semantics.name;
          //
          //   const func = operatorNodeFuncWrapper.func;
          //   const func_decorated = function(mathNode_in) {
          //     logger.log("func_decorated, mathNode_in", mathNode_in);
          //     var outMathNode;
          //
          //     //legacy
          //     outMathNode = func(mathNode_in);
          //
          //     //decoration
          //     outMathNode = Simplifier.simplify_litexp_2(outMathNode);
          //     // logger.log("func_decorated, outMathNode", outMathNode);
          //
          //     return outMathNode;
          //   };
          //   // const func_decorated = func;
          //
          //   const specs = {
          //     funcWrapper:  operatorNodeFuncWrapper,
          //     // operatorNode: operatorNodeFuncWrapper.operatorNode,
          //   };
          //
          //   const transformationFunc = function(icObj) {
          //     var transformationOutput;
          //
          //     logger.log("transformationFunc", icObj);
          //
          //     const facade = icObj;
          //
          //     const mathNode__in  = facade.mathNode;
          //     mathNode__in.isEquation = false;
          //     const mathNode__new = func_decorated(mathNode__in);
          //     mathNode__new.isEquation = false;
          //
          //     const facade__new = icObj.clone();
          //     facade__new.mathNode = mathNode__new;
          //     transformationOutput = new TransformationOutput("mutated", facade__new, facade);
          //
          //     return transformationOutput;
          //   };
          //
          //   const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
          //   return gmItem__operator;
          // });
          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];





          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target    = 7;


          const mathNode__zero = new math.ConstantNode(0);
          const gmItem__zero   = GMItem.value(mathNode__zero, "zero", "");


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }

        static randomInstance__num__0_to_HTU__500(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__0_to_HTU__500();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__num__0_to_HTU__500() {
          logger.log("random_challengeGMItemConfig__num__0_to_HTU__500");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+500,+50,+5,+0.5].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          // const nb_operators__symbol = 0;
          // const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {
          //
          //   const operatorParams = {
          //     node_b: {
          //       types: ["SymbolNode"],
          //       arr:["x"],
          //     },
          //     premultiplier: {
          //       n_type: "integer",
          //       range: {
          //         min: +1,
          //         max: +10,
          //       },
          //     },
          //   };
          //
          //   const op_multiply = Operator.multiply();
          //   const op_divide   = Operator.divide();
          //   const op_add      = Operator.fromOpString_binary("+");
          //   const op_subtract = Operator.fromOpString_binary("-");
          //
          //   const arr_op = [
          //     // op_multiply,
          //     // op_divide,
          //
          //     op_add,
          //     op_subtract,
          //   ];
          //
          //   const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);
          //
          //   const name = operatorNodeFuncWrapper.semantics.name;
          //
          //   const func = operatorNodeFuncWrapper.func;
          //   const func_decorated = function(mathNode_in) {
          //     logger.log("func_decorated, mathNode_in", mathNode_in);
          //     var outMathNode;
          //
          //     //legacy
          //     outMathNode = func(mathNode_in);
          //
          //     //decoration
          //     outMathNode = Simplifier.simplify_litexp_2(outMathNode);
          //     // logger.log("func_decorated, outMathNode", outMathNode);
          //
          //     return outMathNode;
          //   };
          //   // const func_decorated = func;
          //
          //   const specs = {
          //     funcWrapper:  operatorNodeFuncWrapper,
          //     // operatorNode: operatorNodeFuncWrapper.operatorNode,
          //   };
          //
          //   const transformationFunc = function(icObj) {
          //     var transformationOutput;
          //
          //     logger.log("transformationFunc", icObj);
          //
          //     const facade = icObj;
          //
          //     const mathNode__in  = facade.mathNode;
          //     mathNode__in.isEquation = false;
          //     const mathNode__new = func_decorated(mathNode__in);
          //     mathNode__new.isEquation = false;
          //
          //     const facade__new = icObj.clone();
          //     facade__new.mathNode = mathNode__new;
          //     transformationOutput = new TransformationOutput("mutated", facade__new, facade);
          //
          //     return transformationOutput;
          //   };
          //
          //   const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
          //   return gmItem__operator;
          // });
          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];



          const depth__target    = 8;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const cfg__target = {
            isInteger: true,
          };
          const gmItem__target   = GMMaker.createGMItemTarget__with_cfg(gmItem__initial, arr_gmItem_operator, depth__target, cfg__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__num__0_to_HTU__250(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__0_to_HTU__250();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__num__0_to_HTU__250() {
          logger.log("random_challengeGMItemConfig__num__0_to_HTU__250");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+250,+25,+2.5,+0.25].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          // const nb_operators__symbol = 0;
          // const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {
          //
          //   const operatorParams = {
          //     node_b: {
          //       types: ["SymbolNode"],
          //       arr:["x"],
          //     },
          //     premultiplier: {
          //       n_type: "integer",
          //       range: {
          //         min: +1,
          //         max: +10,
          //       },
          //     },
          //   };
          //
          //   const op_multiply = Operator.multiply();
          //   const op_divide   = Operator.divide();
          //   const op_add      = Operator.fromOpString_binary("+");
          //   const op_subtract = Operator.fromOpString_binary("-");
          //
          //   const arr_op = [
          //     // op_multiply,
          //     // op_divide,
          //
          //     op_add,
          //     op_subtract,
          //   ];
          //
          //   const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);
          //
          //   const name = operatorNodeFuncWrapper.semantics.name;
          //
          //   const func = operatorNodeFuncWrapper.func;
          //   const func_decorated = function(mathNode_in) {
          //     logger.log("func_decorated, mathNode_in", mathNode_in);
          //     var outMathNode;
          //
          //     //legacy
          //     outMathNode = func(mathNode_in);
          //
          //     //decoration
          //     outMathNode = Simplifier.simplify_litexp_2(outMathNode);
          //     // logger.log("func_decorated, outMathNode", outMathNode);
          //
          //     return outMathNode;
          //   };
          //   // const func_decorated = func;
          //
          //   const specs = {
          //     funcWrapper:  operatorNodeFuncWrapper,
          //     // operatorNode: operatorNodeFuncWrapper.operatorNode,
          //   };
          //
          //   const transformationFunc = function(icObj) {
          //     var transformationOutput;
          //
          //     logger.log("transformationFunc", icObj);
          //
          //     const facade = icObj;
          //
          //     const mathNode__in  = facade.mathNode;
          //     mathNode__in.isEquation = false;
          //     const mathNode__new = func_decorated(mathNode__in);
          //     mathNode__new.isEquation = false;
          //
          //     const facade__new = icObj.clone();
          //     facade__new.mathNode = mathNode__new;
          //     transformationOutput = new TransformationOutput("mutated", facade__new, facade);
          //
          //     return transformationOutput;
          //   };
          //
          //   const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
          //   return gmItem__operator;
          // });
          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];



          const depth__target    = 10;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const cfg__target = {
            isInteger: true,
          };
          const gmItem__target   = GMMaker.createGMItemTarget__with_cfg(gmItem__initial, arr_gmItem_operator, depth__target, cfg__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__num__0_to_dec__1(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__0_to_dec__1();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__num__0_to_dec__1() {
          logger.log("random_challengeGMItemConfig__num__0_to_dec__1");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+10,+1,+0.1,+0.01].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          // const nb_operators__symbol = 0;
          // const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {
          //
          //   const operatorParams = {
          //     node_b: {
          //       types: ["SymbolNode"],
          //       arr:["x"],
          //     },
          //     premultiplier: {
          //       n_type: "integer",
          //       range: {
          //         min: +1,
          //         max: +10,
          //       },
          //     },
          //   };
          //
          //   const op_multiply = Operator.multiply();
          //   const op_divide   = Operator.divide();
          //   const op_add      = Operator.fromOpString_binary("+");
          //   const op_subtract = Operator.fromOpString_binary("-");
          //
          //   const arr_op = [
          //     // op_multiply,
          //     // op_divide,
          //
          //     op_add,
          //     op_subtract,
          //   ];
          //
          //   const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);
          //
          //   const name = operatorNodeFuncWrapper.semantics.name;
          //
          //   const func = operatorNodeFuncWrapper.func;
          //   const func_decorated = function(mathNode_in) {
          //     logger.log("func_decorated, mathNode_in", mathNode_in);
          //     var outMathNode;
          //
          //     //legacy
          //     outMathNode = func(mathNode_in);
          //
          //     //decoration
          //     outMathNode = Simplifier.simplify_litexp_2(outMathNode);
          //     // logger.log("func_decorated, outMathNode", outMathNode);
          //
          //     return outMathNode;
          //   };
          //   // const func_decorated = func;
          //
          //   const specs = {
          //     funcWrapper:  operatorNodeFuncWrapper,
          //     // operatorNode: operatorNodeFuncWrapper.operatorNode,
          //   };
          //
          //   const transformationFunc = function(icObj) {
          //     var transformationOutput;
          //
          //     logger.log("transformationFunc", icObj);
          //
          //     const facade = icObj;
          //
          //     const mathNode__in  = facade.mathNode;
          //     mathNode__in.isEquation = false;
          //     const mathNode__new = func_decorated(mathNode__in);
          //     mathNode__new.isEquation = false;
          //
          //     const facade__new = icObj.clone();
          //     facade__new.mathNode = mathNode__new;
          //     transformationOutput = new TransformationOutput("mutated", facade__new, facade);
          //
          //     return transformationOutput;
          //   };
          //
          //   const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
          //   return gmItem__operator;
          // });
          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];



          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const cfg__target = {
            isInteger: false,
            display: "decimal",
          };
          const gmItem__target   = GMMaker.createGMItemTarget__with_cfg(gmItem__initial, arr_gmItem_operator, depth__target, cfg__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        static randomInstance__num__0_to_dec__1__shuffle(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__0_to_dec__1__shuffle();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__num__0_to_dec__1__shuffle() {
          logger.log("random_challengeGMItemConfig__num__0_to_dec__1__shuffle");

          const nb_operators = 4;
          const nb_operators__constant = 4;

          const cfg__challenge = {
            is_shuffle_ops: true,
          };

          const arr_operatorNodeFuncWrapper = [+10,+1,+0.1,+0.01].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          if(cfg__challenge.is_shuffle_ops) {
            Utils.shuffle(arr_operatorNodeFuncWrapper);
          }

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];



          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const cfg__target = {
            isInteger: false,
            display: "decimal",
          };
          const gmItem__target   = GMMaker.createGMItemTarget__with_cfg(gmItem__initial, arr_gmItem_operator, depth__target, cfg__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_3(mathNode__target);




          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__num__0_to_dec__0001(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__0_to_dec__0001();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__num__0_to_dec__0001() {
          logger.log("random_challengeGMItemConfig__num__0_to_dec__0001");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = ["0.1","0.01","0.001","0.0001"].map((numberString) => {
            const op_add = Operator.fromOpString_binary("+");
            // const node_b = new math.ConstantNode(number);

            const bignumber__val = math.bignumber(numberString);
            const node_b = new FixedDecimalConstantNode(bignumber__val);

            // logger.log("node_b", node_b);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);

            const node__display = new math.OperatorNode("+", "add", [MathSingleton.node__empty, node_b]);
            operatorNodeFuncWrapper.display.node__display = node__display;

            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = new FixedDecimalConstantNode(outMathNode.evaluate());

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];



          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(math.bignumber(0));
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const cfg__target = {
            isInteger: false,
            display: "decimal",
          };
          const gmItem__target   = GMMaker.createGMItemTarget__with_cfg(gmItem__initial, arr_gmItem_operator, depth__target, cfg__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_3(mathNode__target);




          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        static randomInstance__num__0_to_HTU_scarce(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__0_to_HTU_scarce();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__num__0_to_HTU_scarce() {
          logger.log("random_challengeGMItemConfig__num__0_to_HTU_scarce");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const operatorNodeFuncWrapper__add = (() => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(1);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          })();

          const operatorNodeFuncWrapper__mult = (() => {
            const op_mult = Operator.multiply();
            const node_b = new math.ConstantNode(10);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          })();

          const arr_operatorNodeFuncWrapper = [operatorNodeFuncWrapper__add, operatorNodeFuncWrapper__mult];

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const value__target  = Math.floor(Math.random() * (999 - 0 + 1)) + 0;
          const mathNode__target = new math.ConstantNode(value__target);
          const gmItem__target = GMItem.value(mathNode__target, "target", "");
          // logger.log("gmItem__target", gmItem__target);

          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_3(gmItem__target.content);


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        static randomInstance__num__0_to_dec_scarce(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__0_to_dec_scarce();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__num__0_to_dec_scarce() {
          logger.log("random_challengeGMItemConfig__num__0_to_dec_scarce");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const operatorNodeFuncWrapper__add = (() => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(math.bignumber(+0.1));
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          })();

          const operatorNodeFuncWrapper__mult = (() => {
            const op_mult = Operator.multiply();
            const node_b = new math.ConstantNode(10);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          })();

          const arr_operatorNodeFuncWrapper = [operatorNodeFuncWrapper__add, operatorNodeFuncWrapper__mult];

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // outMathNode = math.simplify(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];
          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const value__target  = Math.floor(Math.random() * (99 - 0 + 1)) + Math.floor(Math.random() * 10) * 0.1;
          const mathNode__target = new math.ConstantNode(value__target);
          const gmItem__target = GMItem.value(mathNode__target, "target", "");
          // logger.log("gmItem__target", gmItem__target);

          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_3(gmItem__target.content);

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        static randomInstance__num__0_to_HTU_scarce_step(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__0_to_HTU_scarce_step();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__num__0_to_HTU_scarce_step() {
          logger.log("random_challengeGMItemConfig__num__0_to_HTU_scarce_step");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const operatorNodeFuncWrapper__add = (() => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(1);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          })();

          const operatorNodeFuncWrapper__mult = (() => {
            const op_mult = Operator.multiply();
            const node_b = new math.ConstantNode(1000);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          })();

          const arr_operatorNodeFuncWrapper = [operatorNodeFuncWrapper__add, operatorNodeFuncWrapper__mult];

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = math.simplify(outMathNode);
              outMathNode = new FixedDecimalConstantNode(math.bignumber(outMathNode.value));
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const value__target    = math.bignumber(Math.floor(Math.random() * 10) * 1e9 + Math.floor(Math.random() * 10) * 1e6 + Math.floor(Math.random() * 10) * 1e3 + Math.floor(Math.random() * 10) * 1);
          const mathNode__target = new FixedDecimalConstantNode(value__target);

          const gmItem__target = GMItem.value(mathNode__target, "target", "");
          // logger.log("gmItem__target", gmItem__target);

          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(gmItem__target.content);


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__num__0_to_dec_scarce_step(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__num__0_to_dec_scarce_step();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__num__0_to_dec_scarce_step() {
          logger.log("random_challengeGMItemConfig__num__0_to_dec_scarce_step");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const operatorNodeFuncWrapper__add = (() => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(1);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          })();

          const operatorNodeFuncWrapper__mult = (() => {
            const op_mult = Operator.multiply();
            const node_b = new math.ConstantNode(1e-3);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          })();

          const arr_operatorNodeFuncWrapper = [operatorNodeFuncWrapper__add, operatorNodeFuncWrapper__mult];

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = math.simplify(outMathNode);
              outMathNode = new FixedDecimalConstantNode(math.bignumber(outMathNode.value));
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          
          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          const value__target    = math.bignumber(Math.floor(Math.random() * 10) * 1e-9 + Math.floor(Math.random() * 10) * 1e-6 + Math.floor(Math.random() * 10) * 1e-3 + Math.floor(Math.random() * 10) * 1);
          const mathNode__target = new FixedDecimalConstantNode(value__target);

          const gmItem__target = GMItem.value(mathNode__target, "target", "");
          // logger.log("gmItem__target", gmItem__target);

          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(gmItem__target.content);


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        //calcu

        static randomInstance__calcu__ca1_add_mult(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__calcu__ca1_add_mult();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__calcu__ca1_add_mult() {
          logger.log("random_challengeGMItemConfig__calcu__ca1_add_mult");

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 2;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[2]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = random_constantNode({min: 2, max: 4, step: 1}).value;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          const mathNode__initial = random_constantNode({min: 2, max: 10, step: 1});
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__calcu__ca2_add_mult_div(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__calcu__ca2_add_mult_div();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__calcu__ca2_add_mult_div() {
          logger.log("random_challengeGMItemConfig__calcu__ca2_add_mult_div");

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 1;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +2,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__div = 1;
          const arr_gmItem_operator__div = [...new Array(nb_operators__div).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +2,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult, ...arr_gmItem_operator__div];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[2]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = random_constantNode({min: 3, max: 4, step: 1}).value;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          const mathNode__initial = random_constantNode({min: 2, max: 10, step: 1});
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }



        static randomInstance__calcu__ca10_add_mult_div_sub_monomaniac(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__calcu__ca10_add_mult_div_sub_monomaniac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__calcu__ca10_add_mult_div_sub_monomaniac() {
          logger.log("random_challengeGMItemConfig__calcu__ca10_add_mult_div_sub_monomaniac");

          const node_monomaniac = random_constantNode({min: 2, max: 10, step: 1});

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                // range: {
                //   min: +1,
                //   max: +10,
                // },
                arr: [node_monomaniac],
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 1;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                // range: {
                //   min: +2,
                //   max: +10,
                // },
                arr: [node_monomaniac],
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__div = 1;
          const arr_gmItem_operator__div = [...new Array(nb_operators__div).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                // range: {
                //   min: +2,
                //   max: +10,
                // },
                arr: [node_monomaniac],
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult, ...arr_gmItem_operator__div];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[2]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = random_constantNode({min: 3, max: 4, step: 1}).value;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = random_constantNode({min: 2, max: 10, step: 1});
          const mathNode__initial = node_monomaniac;
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }



        static randomInstance__calcu__ca11_op4_monomaniac(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__calcu__ca11_op4_monomaniac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__calcu__ca11_op4_monomaniac() {
          logger.log("random_challengeGMItemConfig__calcu__ca11_op4_monomaniac");

          const node_monomaniac = random_constantNode({min: 2, max: 10, step: 1});

          const op_multiply = Operator.multiply();
          const op_divide   = Operator.divide();
          const op_add      = Operator.fromOpString_binary("+");
          const op_subtract = Operator.fromOpString_binary("-");

          const arr_op = [
            op_add,
            op_subtract,
            op_multiply,
            op_divide,
          ];

          const arr_gmItem_operator__add = arr_op.map(op => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                // range: {
                //   min: +1,
                //   max: +10,
                // },
                arr: [node_monomaniac],
              },
            };

            const node_b = node_monomaniac;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 1;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                // range: {
                //   min: +2,
                //   max: +10,
                // },
                arr: [node_monomaniac],
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__div = 1;
          const arr_gmItem_operator__div = [...new Array(nb_operators__div).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                // range: {
                //   min: +2,
                //   max: +10,
                // },
                arr: [node_monomaniac],
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult, ...arr_gmItem_operator__div];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[2]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = random_constantNode({min: 3, max: 4, step: 1}).value;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = random_constantNode({min: 2, max: 10, step: 1});
          const mathNode__initial = node_monomaniac;
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__calcu__ca20_op4_bimaniac(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__calcu__ca20_op4_bimaniac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__calcu__ca20_op4_bimaniac() {
          logger.log("random_challengeGMItemConfig__calcu__ca20_op4_bimaniac");

          const range = {min: 1, max: 11};
          const arr_coprime = MathUtils.arr2_randomCoprimesInRange(range);

          const node_n = new math.ConstantNode(arr_coprime[0]);
          const node_p = new math.ConstantNode(arr_coprime[1]);

          const op_multiply = Operator.multiply();
          const op_divide   = Operator.divide();
          const op_add      = Operator.fromOpString_binary("+");
          const op_subtract = Operator.fromOpString_binary("-");

          const arr_op = [
            op_add,
            op_subtract,
            op_multiply,
            op_divide,
          ];

          const arr_gmItem_operator_n = arr_op.map(op => {

            // const operatorParams = {
            //   node_b: {
            //     types: ["ConstantNode"],
            //     // range: {
            //     //   min: +1,
            //     //   max: +10,
            //     // },
            //     arr: [node_monomaniac],
            //   },
            // };

            const node_b = node_n;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator_p = arr_op.map(op => {

            // const operatorParams = {
            //   node_b: {
            //     types: ["ConstantNode"],
            //     // range: {
            //     //   min: +1,
            //     //   max: +10,
            //     // },
            //     arr: [node_monomaniac],
            //   },
            // };

            const node_b = node_p;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator = [...arr_gmItem_operator_n, ...arr_gmItem_operator_p];


          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = random_constantNode({min: 3, max: 4, step: 1}).value;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = random_constantNode({min: 2, max: 10, step: 1});
          const mathNode__initial = Utils.randomElementInArray([node_n, node_p]);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator_n,
            operators__inverse:  arr_gmItem_operator_p,
          };

          return gmItemConfig;
        }



        static randomInstance__calcu__ca50_symb_op4_monomaniac(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__calcu__ca50_symb_op4_monomaniac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__calcu__ca50_symb_op4_monomaniac() {
          logger.log("random_challengeGMItemConfig__calcu__ca50_symb_op4_monomaniac");

          const node_monomaniac = new math.SymbolNode("n");

          const op_multiply = Operator.multiply();
          const op_divide   = Operator.divide();
          const op_add      = Operator.fromOpString_binary("+");
          const op_subtract = Operator.fromOpString_binary("-");

          const arr_op = [
            op_add,
            op_subtract,
            op_multiply,
            op_divide,
          ];

          const arr_gmItem_operator = arr_op.map(op => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                // range: {
                //   min: +1,
                //   max: +10,
                // },
                arr: [node_monomaniac],
              },
            };

            const node_b = node_monomaniac;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = random_constantNode({min: 3, max: 4, step: 1}).value;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = random_constantNode({min: 2, max: 10, step: 1});
          const mathNode__initial = node_monomaniac;
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__calcu__ca60_symb_op4_bimaniac(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__calcu__ca60_symb_op4_bimaniac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__calcu__ca60_symb_op4_bimaniac() {
          logger.log("random_challengeGMItemConfig__calcu__ca60_symb_op4_bimaniac");

          const node_n = new math.SymbolNode("n");
          const node_p = new math.SymbolNode("p");


          const op_multiply = Operator.multiply();
          const op_divide   = Operator.divide();
          const op_add      = Operator.fromOpString_binary("+");
          const op_subtract = Operator.fromOpString_binary("-");

          const arr_op = [
            op_add,
            op_subtract,
            op_multiply,
            op_divide,
          ];

          const arr_gmItem_operator_n = arr_op.map(op => {

            // const operatorParams = {
            //   node_b: {
            //     types: ["ConstantNode"],
            //     // range: {
            //     //   min: +1,
            //     //   max: +10,
            //     // },
            //     arr: [node_monomaniac],
            //   },
            // };

            const node_b = node_n;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator_p = arr_op.map(op => {

            // const operatorParams = {
            //   node_b: {
            //     types: ["ConstantNode"],
            //     // range: {
            //     //   min: +1,
            //     //   max: +10,
            //     // },
            //     arr: [node_monomaniac],
            //   },
            // };

            const node_b = node_p;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator = [...arr_gmItem_operator_n, ...arr_gmItem_operator_p];


          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = random_constantNode({min: 3, max: 4, step: 1}).value;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = random_constantNode({min: 2, max: 10, step: 1});
          const mathNode__initial = Utils.randomElementInArray([node_n, node_p]);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator_n,
            operators__inverse:  arr_gmItem_operator_p,
          };

          return gmItemConfig;
        }

        //negat

        static randomInstance__negat__n0_matrix__nice(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__negat__n0_matrix__nice();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__negat__n0_matrix__nice() {
          logger.log("random_challengeGMItemConfig__negat__n0_matrix__nice");

          const nb_operators = 2;

          const nb_operators__constant = 2;

          const arr_operatorNodeFuncWrapper = [+1, -1].map(number => {
            const op_sub = Operator.fromOpString_binary("+");
            var node_b;
            if(number == -1) {
              node_b = new math.ParenthesisNode(new SignedConstantNode(number, true));
            } else {
              node_b = new SignedConstantNode(number, true);
            }
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);

              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];





          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.value, true);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target = 7;


          const mathNode__zero = new math.ConstantNode(0);
          const gmItem__zero = GMItem.value(mathNode__zero, "zero", "");


          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new SignedConstantNode(gmItem__target.content, true);


          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          // gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);
          gmItem__initial.content = new SignedConstantNode(gmItem__initial.content, true);


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators: arr_gmItem_operator,
            operators__inverse: [],
          };

          return gmItemConfig;
        }

        static randomInstance__negat__n5_grayed_B(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__negat__n5_grayed_B();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__negat__n5_grayed_B() {
          logger.log("random_challengeGMItemConfig__negat__n5_grayed_B");

          const nb_operators = 2;

          const nb_operators__constant = 2;

          const arr_operatorNodeFuncWrapper = [+1, -1].map(number => {
            const op_sub = Operator.fromOpString_binary("+");
            var node_b;
            if(number == -1) {
              node_b = new math.ParenthesisNode(new SignedConstantNode(number, true));
            } else {
              node_b = new SignedConstantNode(number, true);
            }
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);

              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];





          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target = 7;


          const mathNode__zero = new math.ConstantNode(0);
          const gmItem__zero = GMItem.value(mathNode__zero, "zero", "");


          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new SignedConstantNode(gmItem__target.content, true);


          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          // gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);
          gmItem__initial.content = new SignedConstantNode(gmItem__initial.content, true);


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators:          arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static randomInstance__negat__n5_grayed_L(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__negat__n5_grayed_L();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__negat__n5_grayed_L() {
          logger.log("random_challengeGMItemConfig__negat__n5_grayed_L");

          const nb_operators = 2;

          const nb_operators__constant = 2;

          const arr_operatorNodeFuncWrapper = [+1, -1].map(number => {
            const op_sub = Operator.fromOpString_binary("+");
            var node_b;
            if(number == -1) {
              node_b = new math.ParenthesisNode(new SignedConstantNode(number, true));
            } else {
              node_b = new SignedConstantNode(number, true);
            }
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);

              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];





          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target = 7;


          const mathNode__zero = new math.ConstantNode(0);
          const gmItem__zero = GMItem.value(mathNode__zero, "zero", "");


          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new SignedConstantNode(gmItem__target.content, true);


          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          // gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);
          gmItem__initial.content = new SignedConstantNode(gmItem__initial.content, true);


          //setup grayed
          // arr_gmItem_operator
          arr_gmItem_operator[0].specs.isEnabled = false; 
          arr_gmItem_operator[1].specs.isEnabled = true;
          // arr_gmItem_operator__inverse
          arr_gmItem_operator__inverse[0].specs.isEnabled = false; 
          arr_gmItem_operator__inverse[1].specs.isEnabled = true;




          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators:          arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static randomInstance__negat__n5_grayed_R(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__negat__n5_grayed_R();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__negat__n5_grayed_R() {
          logger.log("random_challengeGMItemConfig__negat__n5_grayed_R");

          const nb_operators = 2;

          const nb_operators__constant = 2;

          const arr_operatorNodeFuncWrapper = [+1, -1].map(number => {
            const op_sub = Operator.fromOpString_binary("+");
            var node_b;
            if(number == -1) {
              node_b = new math.ParenthesisNode(new SignedConstantNode(number, true));
            } else {
              node_b = new SignedConstantNode(number, true);
            }
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);

              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];





          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target = 7;


          const mathNode__zero = new math.ConstantNode(0);
          const gmItem__zero = GMItem.value(mathNode__zero, "zero", "");


          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new SignedConstantNode(gmItem__target.content, true);


          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          // gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);
          gmItem__initial.content = new SignedConstantNode(gmItem__initial.content, true);


          //setup grayed
          // arr_gmItem_operator
          arr_gmItem_operator[0].specs.isEnabled = true; 
          arr_gmItem_operator[1].specs.isEnabled = false;
          // arr_gmItem_operator__inverse
          arr_gmItem_operator__inverse[0].specs.isEnabled = true; 
          arr_gmItem_operator__inverse[1].specs.isEnabled = false;




          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators:          arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }



        static randomInstance__negat__n54_below0_minus9(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__negat__n54_below0_minus9();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__negat__n54_below0_minus9() {
          logger.log("random_challengeGMItemConfig__negat__n54_below0_minus9");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_value__source = [...Array(9).keys()].map(index => -index);
          logger.log("arr_value__source", arr_value__source);
          const arr_value_b = MathUtils.randomCartArrFromArr(arr_value__source, 4,4);
          logger.log("arr_value_b", arr_value_b);


          const arr_operatorNodeFuncWrapper = arr_value_b.map(number => {
            const op_sub = Operator.fromOpString_binary("+");
            var node_b;
            if(number < 0) {
              node_b = new math.ParenthesisNode(new SignedConstantNode(number, true));
            } else {
              node_b = new SignedConstantNode(number, true);
            }
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);

              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];





          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target = math.randomInt(2, 5);


          const mathNode__zero = new math.ConstantNode(0);
          const gmItem__zero = GMItem.value(mathNode__zero, "zero", "");


          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new SignedConstantNode(gmItem__target.content, true);


          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          // gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);
          gmItem__initial.content = new SignedConstantNode(gmItem__initial.content, true);


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators:          arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }




        static randomInstance__negat__n55_below0_minus10(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__negat__n55_below0_minus10();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__negat__n55_below0_minus10() {
          logger.log("random_challengeGMItemConfig__negat__n55_below0_minus10");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_value__source = [...Array(9).keys()].map(index => -index);
          logger.log("arr_value__source", arr_value__source);
          const arr_value_b = [-10, ...MathUtils.randomCartArrFromArr(arr_value__source, 3,3)];
          logger.log("arr_value_b", arr_value_b);


          const arr_operatorNodeFuncWrapper = arr_value_b.map(number => {
            const op_sub = Operator.fromOpString_binary("+");
            var node_b;
            if(number < 0) {
              node_b = new math.ParenthesisNode(new SignedConstantNode(number, true));
            } else {
              node_b = new SignedConstantNode(number, true);
            }
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);

              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];

          const arr_gmItem_operator__10X   = [arr_gmItem_operator__constant[0]];
          const arr_gmItem_operator__other = arr_gmItem_operator__constant.slice(1,3+1);



          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });





          const mathNode__zero = new math.ConstantNode(0);
          const gmItem__zero = GMItem.value(mathNode__zero, "zero", "");


          // const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator, depth__target);
          // // logger.log("gmItem__target", gmItem__target);
          // const mathNode__target = gmItem__target.content;

          //***HORROR {

          const depth__target__10X   = math.randomInt(2, 7);
          const depth__target__other = math.randomInt(1, 3);
          const depth__target = depth__target__10X + depth__target__other;

          var gmItem__target;
          var mathNode__target;

          //use [- 10], [-100], [-1000], etc.
          gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__10X, depth__target__10X);
          mathNode__target = gmItem__target.content;

          //use other operators
          gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__target, arr_gmItem_operator__other, depth__target__other);
          mathNode__target = gmItem__target.content;

          //***HORROR }


          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new SignedConstantNode(gmItem__target.content, true);


          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          // gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);
          gmItem__initial.content = new SignedConstantNode(gmItem__initial.content, true);


          const gmItemConfig = {
            initial: gmItem__initial,
            target:  gmItem__target,

            operators:          arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static randomInstance__negat__n56_below0_minus100(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__negat__n56_below0_minus100();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__negat__n56_below0_minus100() {
          logger.log("random_challengeGMItemConfig__negat__n56_below0_minus100");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_value__source = [...Array(9).keys()].map(index => -index);
          logger.log("arr_value__source", arr_value__source);
          const arr_value_b = [-100,-10, ...MathUtils.randomCartArrFromArr(arr_value__source, 2,2)];
          logger.log("arr_value_b", arr_value_b);


          const arr_operatorNodeFuncWrapper = arr_value_b.map(number => {
            const op_sub = Operator.fromOpString_binary("+");
            var node_b;
            if(number < 0) {
              node_b = new math.ParenthesisNode(new SignedConstantNode(number, true));
            } else {
              node_b = new SignedConstantNode(number, true);
            }
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);

              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];

          const arr_gmItem_operator__10X   = arr_gmItem_operator__constant.slice(0,1+1);
          const arr_gmItem_operator__other = arr_gmItem_operator__constant.slice(1,3+1);



          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });





          const mathNode__zero = new math.ConstantNode(0);
          const gmItem__zero = GMItem.value(mathNode__zero, "zero", "");


          // const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator, depth__target);
          // // logger.log("gmItem__target", gmItem__target);
          // const mathNode__target = gmItem__target.content;

          //***HORROR {

          const depth__target__10X   = math.randomInt(2, 7);
          const depth__target__other = math.randomInt(1, 3);
          const depth__target = depth__target__10X + depth__target__other;

          var gmItem__target;
          var mathNode__target;

          //use [- 10], [-100], [-1000], etc.
          gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__10X, depth__target__10X);
          mathNode__target = gmItem__target.content;

          //use other operators
          gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__target, arr_gmItem_operator__other, depth__target__other);
          mathNode__target = gmItem__target.content;

          //***HORROR }


          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new SignedConstantNode(gmItem__target.content, true);


          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          // gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);
          gmItem__initial.content = new SignedConstantNode(gmItem__initial.content, true);


          const gmItemConfig = {
            initial: gmItem__initial,
            target:  gmItem__target,

            operators:          arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }




        static randomInstance__negat__n58_below0_minus01(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__negat__n58_below0_minus01();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__negat__n58_below0_minus01() {
          logger.log("random_challengeGMItemConfig__negat__n58_below0_minus01");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_value__source = [...Array(9).keys()].map(index => -index);
          logger.log("arr_value__source", arr_value__source);
          const arr_value_b = [-0.1, ...MathUtils.randomCartArrFromArr(arr_value__source, 3,3)];
          logger.log("arr_value_b", arr_value_b);


          const arr_operatorNodeFuncWrapper = arr_value_b.map(number => {
            const op_sub = Operator.fromOpString_binary("+");
            var node_b;
            if(number < 0) {
              node_b = new math.ParenthesisNode(new SignedFixedDecimalConstantNode(number, true));
            } else {
              node_b = new SignedFixedDecimalConstantNode(number, true);
            }
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              // outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);
              outMathNode = new SignedFixedDecimalConstantNode(outMathNode.evaluate({}));

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedFixedDecimalConstantNode(mathNode__new, true);

              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];

          const arr_gmItem_operator__10X   = arr_gmItem_operator__constant.slice(0,0+1);
          const arr_gmItem_operator__other = arr_gmItem_operator__constant.slice(0,3+1);



          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedFixedDecimalConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedFixedDecimalConstantNode(mathNode__new, true);
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });





          const mathNode__zero = new math.ConstantNode(0);
          const gmItem__zero = GMItem.value(mathNode__zero, "zero", "");


          // const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator, depth__target);
          // // logger.log("gmItem__target", gmItem__target);
          // const mathNode__target = gmItem__target.content;

          //***HORROR {

          const depth__target__10X   = math.randomInt(2, 7);
          const depth__target__other = math.randomInt(1, 3);
          const depth__target = depth__target__10X + depth__target__other;

          var gmItem__target;
          var mathNode__target;

          //use [- 10], [-100], [-1000], etc.
          gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__10X, depth__target__10X);
          mathNode__target = gmItem__target.content;

          //use other operators
          gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__target, arr_gmItem_operator__other, depth__target__other);
          mathNode__target = gmItem__target.content;

          //***HORROR }


          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new SignedFixedDecimalConstantNode(gmItem__target.content.evaluate({}), true);


          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          // gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);
          gmItem__initial.content = new SignedFixedDecimalConstantNode(gmItem__initial.content.evaluate({}), true);


          const gmItemConfig = {
            initial: gmItem__initial,
            target:  gmItem__target,

            operators:          arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static randomInstance__negat__n585_below0_minusX05(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__negat__n585_below0_minusX05();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__negat__n585_below0_minusX05() {
          logger.log("random_challengeGMItemConfig__negat__n585_below0_minusX05");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_value__source = [...Array(9).keys()].map(index => -index).map(val => val * 0.5);
          logger.log("arr_value__source", arr_value__source);
          const arr_value_b = MathUtils.randomCartArrFromArr(arr_value__source, 4,4);
          logger.log("arr_value_b", arr_value_b);


          const arr_operatorNodeFuncWrapper = arr_value_b.map(number => {
            const op_sub = Operator.fromOpString_binary("+");
            var node_b;
            if(number < 0) {
              node_b = new math.ParenthesisNode(new SignedFixedDecimalConstantNode(number, true));
            } else {
              node_b = new SignedFixedDecimalConstantNode(number, true);
            }
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              // outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);
              outMathNode = new SignedFixedDecimalConstantNode(outMathNode.evaluate({}));

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedFixedDecimalConstantNode(mathNode__new, true);

              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];

          const arr_gmItem_operator__10X   = arr_gmItem_operator__constant.slice(0,0+1);
          const arr_gmItem_operator__other = arr_gmItem_operator__constant.slice(0,3+1);



          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedFixedDecimalConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedFixedDecimalConstantNode(mathNode__new, true);
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });





          const mathNode__zero = new math.ConstantNode(0);
          const gmItem__zero = GMItem.value(mathNode__zero, "zero", "");


          // const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator, depth__target);
          // // logger.log("gmItem__target", gmItem__target);
          // const mathNode__target = gmItem__target.content;

          //***HORROR {

          const depth__target__10X   = math.randomInt(2, 7);
          const depth__target__other = math.randomInt(1, 3);
          const depth__target = depth__target__10X + depth__target__other;

          var gmItem__target;
          var mathNode__target;

          //use [- 10], [-100], [-1000], etc.
          gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__10X, depth__target__10X);
          mathNode__target = gmItem__target.content;

          //use other operators
          gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__target, arr_gmItem_operator__other, depth__target__other);
          mathNode__target = gmItem__target.content;

          //***HORROR }


          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new SignedFixedDecimalConstantNode(gmItem__target.content.evaluate({}), true);


          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          // gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);
          gmItem__initial.content = new SignedFixedDecimalConstantNode(gmItem__initial.content.evaluate({}), true);


          const gmItemConfig = {
            initial: gmItem__initial,
            target:  gmItem__target,

            operators:          arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }



        static randomInstance__negat__n59_below0_minusX001(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__negat__n59_below0_minusX001();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__negat__n59_below0_minusX001() {
          logger.log("random_challengeGMItemConfig__negat__n59_below0_minusX001");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_value__source = [...Array(9).keys()].map(index => -index).map(val => val * 0.01);
          logger.log("arr_value__source", arr_value__source);
          const arr_value_b = MathUtils.randomCartArrFromArr(arr_value__source, 4,4);
          logger.log("arr_value_b", arr_value_b);


          const arr_operatorNodeFuncWrapper = arr_value_b.map(number => {
            const op_sub = Operator.fromOpString_binary("+");
            var node_b;
            if(number < 0) {
              node_b = new math.ParenthesisNode(new SignedFixedDecimalConstantNode(number, true));
            } else {
              node_b = new SignedFixedDecimalConstantNode(number, true);
            }
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              // outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);
              outMathNode = new SignedFixedDecimalConstantNode(outMathNode.evaluate({}));

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedFixedDecimalConstantNode(mathNode__new, true);

              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];

          const arr_gmItem_operator__10X   = arr_gmItem_operator__constant.slice(0,0+1);
          const arr_gmItem_operator__other = arr_gmItem_operator__constant.slice(0,3+1);



          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedFixedDecimalConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedFixedDecimalConstantNode(mathNode__new, true);
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });





          const mathNode__zero = new math.ConstantNode(0);
          const gmItem__zero = GMItem.value(mathNode__zero, "zero", "");


          // const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator, depth__target);
          // // logger.log("gmItem__target", gmItem__target);
          // const mathNode__target = gmItem__target.content;

          //***HORROR {

          const depth__target__10X   = math.randomInt(2, 7);
          const depth__target__other = math.randomInt(1, 3);
          const depth__target = depth__target__10X + depth__target__other;

          var gmItem__target;
          var mathNode__target;

          //use [- 10], [-100], [-1000], etc.
          gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__10X, depth__target__10X);
          mathNode__target = gmItem__target.content;

          //use other operators
          gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__target, arr_gmItem_operator__other, depth__target__other);
          mathNode__target = gmItem__target.content;

          //***HORROR }


          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new SignedFixedDecimalConstantNode(gmItem__target.content.evaluate({}), true);


          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          // gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);
          gmItem__initial.content = new SignedFixedDecimalConstantNode(gmItem__initial.content.evaluate({}), true);


          const gmItemConfig = {
            initial: gmItem__initial,
            target:  gmItem__target,

            operators:          arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        




        static randomInstance__negat__n6_addB_subT_neg(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__negat__n6_addB_subT_neg();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__negat__n6_addB_subT_neg() {
          logger.log("random_challengeGMItemConfig__negat__n6_addB_subT_neg");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_value__source = [...Array(11).keys()].map(index => -index);
          logger.log("arr_value__source", arr_value__source);
          const arr_value_b = MathUtils.randomCartArrFromArr(arr_value__source, 4,4);
          logger.log("arr_value_b", arr_value_b);


          const arr_operatorNodeFuncWrapper = arr_value_b.map(number => {
            const op_sub = Operator.fromOpString_binary("+");
            var node_b;
            if(number < 0) {
              node_b = new math.ParenthesisNode(new SignedConstantNode(number, true));
            } else {
              node_b = new SignedConstantNode(number, true);
            }
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);

              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];





          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target = 7;


          const mathNode__zero = new math.ConstantNode(0);
          const gmItem__zero = GMItem.value(mathNode__zero, "zero", "");


          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new SignedConstantNode(gmItem__target.content, true);


          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          // gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);
          gmItem__initial.content = new SignedConstantNode(gmItem__initial.content, true);


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators:          arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static randomInstance__negat__n7_addB_subT_all(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__negat__n7_addB_subT_all();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__negat__n7_addB_subT_all() {
          logger.log("random_challengeGMItemConfig__negat__n7_addB_subT_all");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_value__source0 = [...Array(15).keys()].map(index => index + 1);
          const arr_value__source  = [...arr_value__source0.map(index => -index), 
                                      ...arr_value__source0.map(index => +index),
                                     ];
          logger.log("arr_value__source", arr_value__source);
          const arr_value_b = MathUtils.randomCartArrFromArr(arr_value__source, 4,4);
          logger.log("arr_value_b", arr_value_b);


          const arr_operatorNodeFuncWrapper = arr_value_b.map(number => {
            const op_sub = Operator.fromOpString_binary("+");
            var node_b;
            if(number < 0) {
              node_b = new math.ParenthesisNode(new SignedConstantNode(number, true));
            } else {
              node_b = new SignedConstantNode(number, true);
            }
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_sub, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);

              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];





          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function (mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new SignedConstantNode(outMathNode.evaluate({}), true);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function (icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              // facade__new.mathNode = mathNode__new;
              facade__new.mathNode = new SignedConstantNode(mathNode__new, true);
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target = 7;


          const mathNode__zero = new math.ConstantNode(0);
          const gmItem__zero = GMItem.value(mathNode__zero, "zero", "");


          const gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new SignedConstantNode(gmItem__target.content, true);


          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__zero, arr_gmItem_operator__inverse, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__initial = gmItem__initial.content;
          //simplify target
          // gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);
          gmItem__initial.content = new SignedConstantNode(gmItem__initial.content, true);


          const gmItemConfig = {
            initial: gmItem__initial,
            target: gmItem__target,

            operators:          arr_gmItem_operator,
            operators__inverse: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }

        static randomInstance__negat__n10__product(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__negat__n10__product();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__negat__n10__product() {
          logger.log("random_challengeGMItemConfig__negat__n10__product");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          // Rewriter.test_simplification_rules();

          const arr_operatorNodeFuncWrapper = [-2,-3,-5,-10].map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            var node_b;
            if(number < 0) {
              node_b = new math.ParenthesisNode(new SignedConstantNode(number, true));
            } else {
              node_b = new SignedConstantNode(number, true);
            }
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              outMathNode = math.simplify(outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant;


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_full(outMathNode);
              // outMathNode = Simplifier.simplify_equation(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target    = Utils.randomElementInArray__weighted([2,3,4],[0.42,0.35,0.23]);


          const mathNode__initial = new math.ConstantNode(1);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__constant, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            // operators__inverse:  arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }
        
        
        static randomInstance__sqsqrtpow__p1__product_vpadiq(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__p1__product_vpadiq();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__sqsqrtpow__p1__product_vpadiq() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__p1__product_vpadiq");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          // Rewriter.test_simplification_rules();

          const arr_operatorNodeFuncWrapper = [+2,+3,+5,+7].map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant;


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_full(outMathNode);
              // outMathNode = Simplifier.simplify_equation(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target    = 7;


          const mathNode__initial = new math.ConstantNode(1);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");


          const isShouldSimplify = false;
          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__constant, depth__target, isShouldSimplify);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            // operators__inverse:  arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }

        
        static randomInstance__sqsqrtpow__p2__product_expadd(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__p2__product_expadd();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__sqsqrtpow__p2__product_expadd() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__p2__product_expadd");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          // Rewriter.test_simplification_rules();

          const arr_operatorNodeFuncWrapper = [+2,+3,+5,+7].map(number => {
            const op_mult = Operator.fromOpString_binary("x");

            // const node_b = new math.ConstantNode(number);
            const exponent = Utils.randomElementInArray([2,3,4,5,6,7,8,9,10]);
            const node_b = new math.OperatorNode("^", "pow", [new math.ConstantNode(number), new math.ConstantNode(exponent)]);

            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant;


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_full(outMathNode);
              // outMathNode = Simplifier.simplify_equation(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target    = 7;


          const mathNode__initial = new math.ConstantNode(1);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");


          const isShouldSimplify = false;
          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__constant, depth__target, isShouldSimplify);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            // operators__inverse:  arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }

        static randomInstance__sqsqrtpow__p3__product_to_1(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__p3__product_to_1();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__sqsqrtpow__p3__product_to_1() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__p3__product_to_1");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+2,+3,+5,+7].map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant;


          // const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {
          const arr_gmItem_operator__inverse = [+2,+3,+5,+7].map(number => {

            // const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;

            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(number)]);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);

            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }
              }

              return outMathNode;
            };

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target    = 7;


          const mathNode__initial = new math.ConstantNode(1);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          const isShouldSimplify = false;
          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__constant, depth__target, isShouldSimplify);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__target,
            target :    gmItem__initial,

            operators:           arr_gmItem_operator__inverse,
            // operators__inverse:  arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static randomInstance__sqsqrtpow__p4__product_to_product__pos(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__p4__product_to_product__pos();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__sqsqrtpow__p4__product_to_product__pos() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__p4__product_to_product__pos");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+2,+3,+5,+7].map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant;


          // const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {
          const arr_gmItem_operator__inverse = [+2,+3,+5,+7].map(number => {

            // const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;

            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(number)]);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);

            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }
              }

              return outMathNode;
            };

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target    = 7;


          const mathNode__one = new math.ConstantNode(1);
          const gmItem__one   = GMItem.value(mathNode__one, "one", "");

          const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__constant, depth__target, false);
          const mathNode__initial = gmItem__initial.content;


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__constant, depth__target, false);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }

        static randomInstance__sqsqrtpow__p5__negat(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__p5__negat();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__sqsqrtpow__p5__negat() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__p5__negat");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+2,+3,+5,+7].map(number => {
            const op_mult = Operator.fromOpString_binary("/");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant;


          // const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {
          const arr_gmItem_operator__inverse = [+2,+3,+5,+7].map(number => {

            // const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;

            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(number)]);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);

            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }
              }

              return outMathNode;
            };

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target    = 7;


          const mathNode__one = new math.ConstantNode(1);
          const gmItem__one   = GMItem.value(mathNode__one, "one", "");

          // const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__constant, depth__target);
          // const mathNode__initial = gmItem__initial.content;


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__inverse, depth__target, false);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;

          function isSameExpression(mathNode_1, mathNode_2) {
            var outBool;

            function rewrite_mult(str_expr) {
              return str_expr.replaceAll("×", "*");
            }

            function rewrite_pow(str_expr)
            {
              const re = /\^\s(-?[0-9]+)/;
              const str = str_expr.replace(re, '^ ($1) ');
              return str;
            }

            var expr__mathNode_1 = mathNode_1.toString();
            logger.log("expr__mathNode_1", expr__mathNode_1);

            expr__mathNode_1 = rewrite_mult(expr__mathNode_1);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_1 = rewrite_pow(expr__mathNode_1);
            }, 10);

            var expr__mathNode_2 = mathNode_2.toString();
            logger.log("expr__mathNode_2", expr__mathNode_2);

            expr__mathNode_2 = rewrite_mult(expr__mathNode_2);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_2 = rewrite_pow(expr__mathNode_2);
            }, 10);

            const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
            logger.log("expr__equality", expr__equality);
            const algebrite_result = Algebrite.run(expr__equality);
            logger.log("algebrite_result", algebrite_result);


            outBool = (algebrite_result == true);

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__one,
            target :    gmItem__target,

            operators:           arr_gmItem_operator__inverse,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__sqsqrtpow__p6__negat_expadd(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__p6__negat_expadd();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__sqsqrtpow__p6__negat_expadd() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__p6__negat_expadd");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+2,+3,+5,+7].map(number => {
            const op_mult = Operator.fromOpString_binary("/");

            const exponent = Utils.randomElementInArray([2,3,4,5,6,7,8,9,10]);
            const node_b = new math.OperatorNode("^", "pow", [new math.ConstantNode(number), new math.ConstantNode(exponent)]);

            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant;


          // const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {
          const arr_gmItem_operator__inverse = [+2,+3,+5,+7].map(number => {

            // const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;

            const op_mult = Operator.fromOpString_binary("x");

            const exponent = Utils.randomElementInArray([2,3,4,5,6,7,8,9,10]);
            const node_c = new math.OperatorNode("^", "pow", [new math.ConstantNode(number), new math.ConstantNode(exponent)]);

            const node_b = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), node_c]);


            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);

            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }
              }

              return outMathNode;
            };

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target    = 7;


          const mathNode__one = new math.ConstantNode(1);
          const gmItem__one   = GMItem.value(mathNode__one, "one", "");

          // const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__constant, depth__target);
          // const mathNode__initial = gmItem__initial.content;


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__inverse, depth__target, false);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          function isSameExpression(mathNode_1, mathNode_2) {
            var outBool;

            function rewrite_mult(str_expr) {
              return str_expr.replaceAll("×", "*");
            }

            function rewrite_pow(str_expr)
            {
              const re = /\^\s(-?[0-9]+)/;
              const str = str_expr.replace(re, '^ ($1) ');
              return str;
            }

            var expr__mathNode_1 = mathNode_1.toString();
            logger.log("expr__mathNode_1", expr__mathNode_1);

            expr__mathNode_1 = rewrite_mult(expr__mathNode_1);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_1 = rewrite_pow(expr__mathNode_1);
            }, 10);

            var expr__mathNode_2 = mathNode_2.toString();
            logger.log("expr__mathNode_2", expr__mathNode_2);

            expr__mathNode_2 = rewrite_mult(expr__mathNode_2);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_2 = rewrite_pow(expr__mathNode_2);
            }, 10);

            const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
            logger.log("expr__equality", expr__equality);
            const algebrite_result = Algebrite.run(expr__equality);
            logger.log("algebrite_result", algebrite_result);


            outBool = (algebrite_result == true);

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          const gmItemConfig = {
            initial:    gmItem__one,
            target :    gmItem__target,

            operators:           arr_gmItem_operator__inverse,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        static randomInstance__sqsqrtpow__p7__negat_to_1(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__p7__negat_to_1();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

      
        static random_challengeGMItemConfig__sqsqrtpow__p7__negat_to_1() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__p7__negat_to_1");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+2,+3,+5,+7].map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant;


          // const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {
          const arr_gmItem_operator__inverse = [+2,+3,+5,+7].map(number => {

            // const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;

            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(number)]);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);

            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }
              }

              return outMathNode;
            };

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target    = 7;


          const mathNode__one = new math.ConstantNode(1);
          const gmItem__one   = GMItem.value(mathNode__one, "one", "");

          // const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__constant, depth__target);
          // const mathNode__initial = gmItem__initial.content;


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__inverse, depth__target, false);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          function isSameExpression(mathNode_1, mathNode_2) {
            var outBool;

            function rewrite_mult(str_expr) {
              return str_expr.replaceAll("×", "*");
            }

            function rewrite_pow(str_expr)
            {
              const re = /\^\s(-?[0-9]+)/;
              const str = str_expr.replace(re, '^ ($1) ');
              return str;
            }

            var expr__mathNode_1 = mathNode_1.toString();
            logger.log("expr__mathNode_1", expr__mathNode_1);

            expr__mathNode_1 = rewrite_mult(expr__mathNode_1);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_1 = rewrite_pow(expr__mathNode_1);
            }, 10);

            var expr__mathNode_2 = mathNode_2.toString();
            logger.log("expr__mathNode_2", expr__mathNode_2);

            expr__mathNode_2 = rewrite_mult(expr__mathNode_2);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_2 = rewrite_pow(expr__mathNode_2);
            }, 10);

            const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
            logger.log("expr__equality", expr__equality);
            const algebrite_result = Algebrite.run(expr__equality);
            logger.log("algebrite_result", algebrite_result);


            outBool = (algebrite_result == true);

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          const gmItemConfig = {
            initial:    gmItem__target,
            target :    gmItem__one,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__sqsqrtpow__p8__product_to_product__full(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__p8__product_to_product__full();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__sqsqrtpow__p8__product_to_product__full() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__p8__product_to_product__full");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+2,+3,+5,+7].map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant;


          // const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {
          const arr_gmItem_operator__inverse = [+2,+3,+5,+7].map(number => {

            // const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;

            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(number)]);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);

            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                if(outMathNode.fn == "multiply") {

                  const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                  if(isOneInArgs) {
                    outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                  } else {
                    outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
                    logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
                    outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
                    logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

                    // outMathNode = Rewriter.rewriteOperatorNode__mult__sortpow(outMathNode);
                    // logger.log("rewriteOperatorNode__mult__sortpow", outMathNode.toString());

                  }

                }
              }

              return outMathNode;
            };

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });


          const arr_gmItem_operator__all = [...arr_gmItem_operator, ...arr_gmItem_operator__inverse];

          const depth__target    = 7;


          const mathNode__one = new math.ConstantNode(1);
          const gmItem__one   = GMItem.value(mathNode__one, "one", "");

          const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__all, depth__target, false);
          const mathNode__initial = gmItem__initial.content;


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__all, depth__target, false);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);

          function isSameExpression(mathNode_1, mathNode_2) {
            var outBool;

            function rewrite_mult(str_expr) {
              return str_expr.replaceAll("×", "*");
            }

            function rewrite_pow(str_expr)
            {
              const re = /\^\s(-?[0-9]+)/;
              const str = str_expr.replace(re, '^ ($1) ');
              return str;
            }

            var expr__mathNode_1 = mathNode_1.toString();
            logger.log("expr__mathNode_1", expr__mathNode_1);

            expr__mathNode_1 = rewrite_mult(expr__mathNode_1);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_1 = rewrite_pow(expr__mathNode_1);
            }, 10);

            var expr__mathNode_2 = mathNode_2.toString();
            logger.log("expr__mathNode_2", expr__mathNode_2);

            expr__mathNode_2 = rewrite_mult(expr__mathNode_2);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_2 = rewrite_pow(expr__mathNode_2);
            }, 10);

            const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
            logger.log("expr__equality", expr__equality);
            const algebrite_result = Algebrite.run(expr__equality);
            logger.log("algebrite_result", algebrite_result);


            outBool = (algebrite_result == true);

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static randomInstance__sqsqrtpow__p9__product__compositeops(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__p9__product__compositeops();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__sqsqrtpow__p9__product__compositeops() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__p9__product__compositeops");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          function random_node__pow() {
            const value__base     = Utils.randomElementInArray([+2,+3,+5,+7]);
            const value__exponent = Utils.randomElementInArray([2,3,4,5,6,7,8,9,10]);
            const node__pow = new math.OperatorNode("^", "pow", [new math.ConstantNode(value__base), new math.ConstantNode(value__exponent)]);
            return node__pow;
          }

          const arr_operatorNodeFuncWrapper = [+2,+3,+5,+7].map(number => {
            const op_mult = Operator.fromOpString_binary("x");

            const node_d = random_node__pow();
            const node_e = random_node__pow();

            const node_composite = new math.OperatorNode("x", "multiply", [node_d, node_e]);
            const node_composite__paren = new math.ParenthesisNode(node_composite);

            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_composite__paren);

            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
              logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
              outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
              logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());


              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant;


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Rewriter.rewriteOperatorNode__mult__flatten(outMathNode);
              logger.log("rewriteOperatorNode__mult__flatten", outMathNode.toString());
              outMathNode = Rewriter.rewriteOperatorNode__mult__factorize_into_pow(outMathNode);
              logger.log("rewriteOperatorNode__mult__factorize_into_pow", outMathNode.toString());

              return outMathNode;
            };

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });


          const arr_gmItem_operator__all = [...arr_gmItem_operator, ...arr_gmItem_operator__inverse];

          const depth__target    = 7;


          const mathNode__one = new math.ConstantNode(1);
          const gmItem__one   = GMItem.value(mathNode__one, "one", "");

          const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__all, depth__target, false);
          const mathNode__initial = gmItem__initial.content;


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__all, depth__target, false);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);

          function isSameExpression(mathNode_1, mathNode_2) {
            var outBool;

            function rewrite_mult(str_expr) {
              return str_expr.replaceAll("×", "*");
            }

            function rewrite_pow(str_expr)
            {
              const re = /\^\s(-?[0-9]+)/;
              const str = str_expr.replace(re, '^ ($1) ');
              return str;
            }

            var expr__mathNode_1 = mathNode_1.toString();
            logger.log("expr__mathNode_1", expr__mathNode_1);

            expr__mathNode_1 = rewrite_mult(expr__mathNode_1);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_1 = rewrite_pow(expr__mathNode_1);
            }, 10);

            var expr__mathNode_2 = mathNode_2.toString();
            logger.log("expr__mathNode_2", expr__mathNode_2);

            expr__mathNode_2 = rewrite_mult(expr__mathNode_2);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_2 = rewrite_pow(expr__mathNode_2);
            }, 10);

            const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
            logger.log("expr__equality", expr__equality);
            const algebrite_result = Algebrite.run(expr__equality);
            logger.log("algebrite_result", algebrite_result);


            outBool = (algebrite_result == true);

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static randomInstance__sqsqrtpow__p100__powop(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__p100__powop();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__sqsqrtpow__p100__powop() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__p100__powop");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper__raw = [+2,+3,+5,+7].map(number => {
            const op_mult = Operator.fromOpString_binary("^");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper__for_op = arr_operatorNodeFuncWrapper__raw.map(operatorNodeFuncWrapper_in => {

            const operatorNodeFuncWrapper = cloneOperatorNodeFactoryFuncWrapper_binary(operatorNodeFuncWrapper_in);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              // logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              outMathNode = Rewriter.rewriteOperatorNode__pow__flatten(outMathNode);
              logger.log("rewriteOperatorNode__pow__flatten", outMathNode.toString());

              function rewrite_into_product(mathNode_in, nb_max_factors) {

                if(mathNode_in instanceof math.OperatorNode) {
                  if(mathNode_in.fn == "pow") {
                    const mathNode__base = mathNode_in.args[0];
                    const mathNode__exp  = mathNode_in.args[1];

                    if(mathNode__base instanceof math.ConstantNode && mathNode__exp instanceof math.ConstantNode) {
                      const value__exp = mathNode__exp.value;
                      logger.log("rewrite_into_product, value__exp", value__exp);
                      if(0 < value__exp && value__exp <= nb_max_factors) {
                        const arr_factor = [...Array(value__exp).keys()].map(index => new math.ConstantNode(mathNode__base));
                        const mathNode__mult = new math.OperatorNode("×", "multiply", arr_factor);

                        return mathNode__mult;
                      }
                    }

                  }
                }

                return mathNode_in;
              }

              const nb_max_factors = 10;
              outMathNode = rewrite_into_product(outMathNode, nb_max_factors);

              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper__for_target = arr_operatorNodeFuncWrapper__raw.map(operatorNodeFuncWrapper_in => {

            const operatorNodeFuncWrapper = cloneOperatorNodeFactoryFuncWrapper_binary(operatorNodeFuncWrapper_in);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              // logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              outMathNode = Rewriter.rewriteOperatorNode__pow__flatten(outMathNode);
              // logger.log("rewriteOperatorNode__pow__flatten", outMathNode.toString());

              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            return operatorNodeFuncWrapper;
          });


          function createGmItem__operator(operatorNodeFuncWrapper) {
            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              // const mathNode__new = func_decorated(mathNode__in);
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            function upgradeTex(tex) {
              var outTex;

              //beautify
              //"3 * x" -> "3x"
              //"3 * (" -> "3("
              function beautifyLitexp(str_in) {
                logger.log("logTex", "beautifyLitexp", str_in);

                const re = /([0-9]+)\\cdot (\w+)/;
                const str = str_in.replace(re, '$1$2');
                logger.log("beautified", str);

                return str;
              }

              outTex = beautifyLitexp(tex);

              outTex = outTex.replaceAll("\\cdot", "\\times");
              outTex = outTex.replaceAll("\\frac{ }", "÷");

              outTex = outTex.replace("{ }^", "\\wedge\\,");
              logger.log("logTex", "beautif, upgradedTex", outTex);

              return outTex;
            }
            specs.func__upgradeTex = upgradeTex;

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          }

          const arr_gmItem_operator__for_op     = arr_operatorNodeFuncWrapper__for_op.map(createGmItem__operator);
          const arr_gmItem_operator__for_target = arr_operatorNodeFuncWrapper__for_target.map(createGmItem__operator);


          const arr_gmItem_operator__inverse = arr_gmItem_operator__for_op.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_full(outMathNode);
              // outMathNode = Simplifier.simplify_equation(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const depth__target    = 3;


          const arr__initial      = [0,1,2,3,4,5,6,7,8,9,10,11,12,13];
          const value__initial    = Utils.randomElementInArray(arr__initial);
          const mathNode__initial = new math.ConstantNode(value__initial);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__for_target, depth__target, false);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);

          function isSameExpression(mathNode_1, mathNode_2) {
            var outBool;

            function rewrite_mult(str_expr) {
              return str_expr.replaceAll("×", "*");
            }

            function rewrite_pow(str_expr)
            {
              const re = /\^\s(-?[0-9]+)/;
              const str = str_expr.replace(re, '^ ($1) ');
              return str;
            }

            var expr__mathNode_1 = mathNode_1.toString();
            logger.log("expr__mathNode_1", expr__mathNode_1);

            expr__mathNode_1 = rewrite_mult(expr__mathNode_1);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_1 = rewrite_pow(expr__mathNode_1);
            }, 10);

            var expr__mathNode_2 = mathNode_2.toString();
            logger.log("expr__mathNode_2", expr__mathNode_2);

            expr__mathNode_2 = rewrite_mult(expr__mathNode_2);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_2 = rewrite_pow(expr__mathNode_2);
            }, 10);

            const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
            logger.log("expr__equality", expr__equality);
            const algebrite_result = Algebrite.run(expr__equality);
            logger.log("algebrite_result", algebrite_result);


            outBool = (algebrite_result == true);

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator__for_op,
            // operators__inverse:  arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        static randomInstance__sqsqrtpow__dectosci1__HTU(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__dectosci1__HTU();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__sqsqrtpow__dectosci1__HTU() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__dectosci1__HTU");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+100,+10,+1].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          const arr_gmItem_operator__symbol = [];
          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          // const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          function createMathNode__random_comb() {
            var outMathNode;

            const nb_component = 3;

            outMathNode = [...Array(nb_component).keys()].reverse().reduce((acc,index) => {
              const value__digit  = Math.floor(Math.random() * 10);
              const value__powten = index;
              const mathNode__powten = new math.OperatorNode("^", "pow", [new math.ConstantNode(10), new math.ConstantNode(value__powten)]);
              const mathNode__sci    = new math.OperatorNode("*", "multiply", [new math.ConstantNode(value__digit),mathNode__powten]);

              if(acc == null) {
                acc = mathNode__sci;
              } else {
                acc = new math.OperatorNode("+", "add", [acc,mathNode__sci]);
              }
              return acc;
            }, null);

            return outMathNode;
          }

          const mathNode__target = createMathNode__random_comb();
          const gmItem__target   = GMItem.value(mathNode__target, "target", "");
          // logger.log("gmItem__target", gmItem__target);

          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(gmItem__target.content);

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__sqsqrtpow__dectosci2__TUdc(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__dectosci2__TUdc();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__sqsqrtpow__dectosci2__TUdc() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__dectosci2__TUdc");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+10,+1,+0.1,+0.01].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          const arr_gmItem_operator__symbol = [];
          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          // const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          function createMathNode__random_comb() {
            var outMathNode;

            const nb_component = 4;

            outMathNode = [...Array(nb_component).keys()].reverse().reduce((acc,index) => {
              const value__digit  = Math.floor(Math.random() * 10);
              const value__powten = index - 2;
              const mathNode__powten = new math.OperatorNode("^", "pow", [new math.ConstantNode(10), new math.ConstantNode(value__powten)]);
              const mathNode__sci = new math.OperatorNode("*", "multiply", [new math.ConstantNode(value__digit),mathNode__powten]);

              if(acc == null) {
                acc = mathNode__sci;
              } else {
                acc = new math.OperatorNode("+", "add", [acc,mathNode__sci]);
              }
              return acc;
            }, null);

            return outMathNode;
          }

          const mathNode__target = createMathNode__random_comb();
          const gmItem__target   = GMItem.value(mathNode__target, "target", "");
          // logger.log("gmItem__target", gmItem__target);

          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(gmItem__target.content);


          function isSameExpression(mathNode_1, mathNode_2) {
            var outBool;

            function rewrite_mult(str_expr) {
              return str_expr.replaceAll("×", "*");
            }

            function rewrite_pow(str_expr)
            {
              const re = /\^\s(-?[0-9]+)/;
              const str = str_expr.replace(re, '^ ($1) ');
              return str;
            }

            var expr__mathNode_1 = mathNode_1.toString();
            logger.log("expr__mathNode_1", expr__mathNode_1);

            expr__mathNode_1 = rewrite_mult(expr__mathNode_1);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_1 = rewrite_pow(expr__mathNode_1);
            }, 10);

            var expr__mathNode_2 = mathNode_2.toString();
            logger.log("expr__mathNode_2", expr__mathNode_2);

            expr__mathNode_2 = rewrite_mult(expr__mathNode_2);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_2 = rewrite_pow(expr__mathNode_2);
            }, 10);

            const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
            logger.log("expr__equality", expr__equality);
            const algebrite_result = Algebrite.run(expr__equality);
            logger.log("algebrite_result", algebrite_result);


            outBool = (algebrite_result == true);

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__sqsqrtpow__dectosci3__HTUd_duos(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__dectosci3__HTUd_duos();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__sqsqrtpow__dectosci3__HTUd_duos() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__dectosci3__HTUd_duos");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+100,+10,+1,+0.1].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          const arr_gmItem_operator__symbol = [];
          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          // const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          function createMathNode__random_comb() {
            var outMathNode;

            const nb_components   = 4;
            const nb_in_partition = 2;

            outMathNode = Utils.partition([...Array(nb_components).keys()].reverse(), nb_in_partition).reduce((acc,arr_comp) => {
              const value__powten = arr_comp[0] - 1;

              const str__value     = [...Array(nb_in_partition).keys()].reduce((acc, index) => {
                if(acc == "") {
                  const value__digit = 1 + Math.floor(Math.random() * 9);
                  const str__digit   = "" + value__digit;
                  acc = acc + str__digit;
                } else {
                  const value__digit = Math.floor(Math.random() * 10);
                  const str__digit   = "" + value__digit;
                  acc = acc + "." + str__digit;
                }
                return acc;
              }, "");

              const mathNode__value = math.parse(str__value);

              const mathNode__powten = new math.OperatorNode("^", "pow", [new math.ConstantNode(10), new math.ConstantNode(value__powten)]);
              const mathNode__sci = new math.OperatorNode("*", "multiply", [mathNode__value,mathNode__powten]);

              if(acc == null) {
                acc = mathNode__sci;
              } else {
                acc = new math.OperatorNode("+", "add", [acc,mathNode__sci]);
              }
              return acc;
            }, null);

            return outMathNode;
          }

          const mathNode__target = createMathNode__random_comb();
          const gmItem__target   = GMItem.value(mathNode__target, "target", "");
          // logger.log("gmItem__target", gmItem__target);

          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(gmItem__target.content);

          function isSameExpression(mathNode_1, mathNode_2) {
            var outBool;

            function rewrite_mult(str_expr) {
              return str_expr.replaceAll("×", "*");
            }

            function rewrite_pow(str_expr)
            {
              const re = /\^\s(-?[0-9]+)/;
              const str = str_expr.replace(re, '^ ($1) ');
              return str;
            }

            var expr__mathNode_1 = mathNode_1.toString();
            logger.log("expr__mathNode_1", expr__mathNode_1);

            expr__mathNode_1 = rewrite_mult(expr__mathNode_1);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_1 = rewrite_pow(expr__mathNode_1);
            }, 10);

            var expr__mathNode_2 = mathNode_2.toString();
            logger.log("expr__mathNode_2", expr__mathNode_2);

            expr__mathNode_2 = rewrite_mult(expr__mathNode_2);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_2 = rewrite_pow(expr__mathNode_2);
            }, 10);

            const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
            logger.log("expr__equality", expr__equality);
            const algebrite_result = Algebrite.run(expr__equality);
            logger.log("algebrite_result", algebrite_result);


            outBool = (algebrite_result == true);

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__sqsqrtpow__sci1__fixed_equal_sci(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__sci1__fixed_equal_sci();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__sqsqrtpow__sci1__fixed_equal_sci() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__sci1__fixed_equal_sci");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const operatorNodeFuncWrapper__add = (() => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(math.bignumber(+1.0));
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          })();

          const operatorNodeFuncWrapper__mult = (() => {
            const op_mult = Operator.multiply();
            const node_b = new math.ConstantNode(math.bignumber(10));
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          })();

          const arr_operatorNodeFuncWrapper = [operatorNodeFuncWrapper__add, operatorNodeFuncWrapper__mult];

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);


              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // outMathNode = math.simplify(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new FixedDecimalConstantNode(math.bignumber(outMathNode.evaluate({})));

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];
          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          function createMathNode__random_sci() {

            const nb_decimals = Math.floor(Math.random() * 3);
            const str__mantissa = [...Array(1 + nb_decimals)].reduce((acc, x, index) => {

              var value__digit;
              if(index == 0) {
                value__digit = 1 + Math.floor(Math.random() * 8);
              } else {
                value__digit = Math.floor(Math.random() * 9);
              }

              var str__digit   = "" + value__digit;

              if(index == 0) {
                str__digit += ".";
              }

              return acc + str__digit;
            }, "");

            const mathNode__mantissa = math.parse(str__mantissa);

            const value__powten = nb_decimals + Math.floor(Math.random() * 7);
            const mathNode__powten = new math.OperatorNode("^", "pow", [new math.ConstantNode(10), new math.ConstantNode(value__powten)]);

            const mathNode__sci = new math.OperatorNode("*", "multiply", [mathNode__mantissa,mathNode__powten]);
            return mathNode__sci;
          }

          const mathNode__target = createMathNode__random_sci();
          const gmItem__target   = GMItem.value(mathNode__target, "target", "");
          // logger.log("gmItem__target", gmItem__target);

          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(gmItem__target.content);

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        static randomInstance__sqsqrtpow__sci1b__fixed_equal_sci(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__sci1b__fixed_equal_sci();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__sqsqrtpow__sci1b__fixed_equal_sci() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__sci1b__fixed_equal_sci");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const operatorNodeFuncWrapper__add0 = (() => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(math.bignumber(+1.0));
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          })();

          const operatorNodeFuncWrapper__add1 = (() => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(math.bignumber(+0.1));
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          })();

          const operatorNodeFuncWrapper__add2 = (() => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(math.bignumber(+0.01));
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          })();

          const operatorNodeFuncWrapper__mult = (() => {
            const op_mult = Operator.multiply();
            const node_b = new math.ConstantNode(math.bignumber(10));
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          })();

          const arr_operatorNodeFuncWrapper = [operatorNodeFuncWrapper__add0,
            operatorNodeFuncWrapper__add1,
            operatorNodeFuncWrapper__add2,
            operatorNodeFuncWrapper__mult];

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);


              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // outMathNode = math.simplify(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new FixedDecimalConstantNode(math.bignumber(outMathNode.evaluate({})));

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];
          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          function createMathNode__random_sci() {

            const nb_decimals = Math.floor(Math.random() * 3);
            const str__mantissa = [...Array(1 + nb_decimals)].reduce((acc, x, index) => {

              var value__digit;
              if(index == 0) {
                value__digit = 1 + Math.floor(Math.random() * 8);
              } else {
                value__digit = Math.floor(Math.random() * 9);
              }

              var str__digit   = "" + value__digit;

              if(index == 0) {
                str__digit += ".";
              }

              return acc + str__digit;
            }, "");

            const mathNode__mantissa = math.parse(str__mantissa);

            const value__powten = nb_decimals + Math.floor(Math.random() * 7);
            const mathNode__powten = new math.OperatorNode("^", "pow", [new math.ConstantNode(10), new math.ConstantNode(value__powten)]);

            const mathNode__sci = new math.OperatorNode("*", "multiply", [mathNode__mantissa,mathNode__powten]);
            return mathNode__sci;
          }

          const mathNode__target = createMathNode__random_sci();
          const gmItem__target   = GMItem.value(mathNode__target, "target", "");
          // logger.log("gmItem__target", gmItem__target);

          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(gmItem__target.content);


          function isSameExpression(mathNode_1, mathNode_2) {
            var outBool;

            function rewrite_mult(str_expr) {
              return str_expr.replaceAll("×", "*");
            }

            function rewrite_pow(str_expr)
            {
              const re = /\^\s(-?[0-9]+)/;
              const str = str_expr.replace(re, '^ ($1) ');
              return str;
            }

            var expr__mathNode_1 = mathNode_1.toString();
            logger.log("expr__mathNode_1", expr__mathNode_1);

            expr__mathNode_1 = rewrite_mult(expr__mathNode_1);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_1 = rewrite_pow(expr__mathNode_1);
            }, 10);

            var expr__mathNode_2 = mathNode_2.toString();
            logger.log("expr__mathNode_2", expr__mathNode_2);

            expr__mathNode_2 = rewrite_mult(expr__mathNode_2);
            //killed by ugliness
            Utils.repeat(() => {
              expr__mathNode_2 = rewrite_pow(expr__mathNode_2);
            }, 10);

            const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
            logger.log("expr__equality", expr__equality);
            const algebrite_result = Algebrite.run(expr__equality);
            logger.log("algebrite_result", algebrite_result);


            outBool = (algebrite_result == true);

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__sqsqrtpow__sci1c__fixed_equal_sci(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__sci1c__fixed_equal_sci();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__sqsqrtpow__sci1c__fixed_equal_sci() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__sci1c__fixed_equal_sci");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const operatorNodeFuncWrapper__add = (() => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(+1.0);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          })();

          const operatorNodeFuncWrapper__mult = (() => {
            const op_mult = Operator.divide();
            const node_b = new math.ConstantNode(10);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          })();

          const arr_operatorNodeFuncWrapper = [operatorNodeFuncWrapper__add, operatorNodeFuncWrapper__mult];

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);


              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // outMathNode = math.simplify(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new FixedDecimalConstantNode(math.bignumber(outMathNode.evaluate({})));
              // outMathNode = new math.ConstantNode(outMathNode.evaluate({}));

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];
          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          function createMathNode__random_sci() {

            const nb_decimals = Math.floor(Math.random() * 3);
            const str__mantissa = [...Array(1 + nb_decimals)].reduce((acc, x, index) => {

              var value__digit;
              if(index == 0) {
                value__digit = 1 + Math.floor(Math.random() * 8);
              } else {
                value__digit = Math.floor(Math.random() * 9);
              }

              var str__digit   = "" + value__digit;

              if(index == 0) {
                str__digit += ".";
              }

              return acc + str__digit;
            }, "");

            const mathNode__mantissa = math.parse(str__mantissa);

            const value__powten = -(nb_decimals + Math.floor(Math.random() * 7));
            const mathNode__powten = new math.OperatorNode("^", "pow", [new math.ConstantNode(10), new math.ConstantNode(value__powten)]);

            const mathNode__sci = new math.OperatorNode("*", "multiply", [mathNode__mantissa,mathNode__powten]);
            return mathNode__sci;
          }

          const mathNode__target = createMathNode__random_sci();
          const gmItem__target   = GMItem.value(mathNode__target, "target", "");
          // logger.log("gmItem__target", gmItem__target);

          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(gmItem__target.content);

          function isSameExpression(mathNode_1, mathNode_2) {
            var outBool;

            const mathNode_equal = new math.RelationalNode(["equal"], [
              new math.ConstantNode(math.bignumber(mathNode_1.evaluate())),
              new math.ConstantNode(math.bignumber(mathNode_2.evaluate())),
            ]);

            outBool = mathNode_equal.evaluate({});

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        static randomInstance__sqsqrtpow__sci1d__fixed_equal_sci(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__sci1d__fixed_equal_sci();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__sqsqrtpow__sci1d__fixed_equal_sci() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__sci1d__fixed_equal_sci");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const operatorNodeFuncWrapper__add0 = (() => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(math.bignumber(+1.0));
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          })();

          const operatorNodeFuncWrapper__add1 = (() => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(math.bignumber(+0.1));
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          })();

          const operatorNodeFuncWrapper__add2 = (() => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(math.bignumber(+0.01));
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          })();

          const operatorNodeFuncWrapper__mult = (() => {
            const op_mult = Operator.divide();
            const node_b = new math.ConstantNode(math.bignumber(10));
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          })();

          const arr_operatorNodeFuncWrapper = [operatorNodeFuncWrapper__add0,
            operatorNodeFuncWrapper__add1,
            operatorNodeFuncWrapper__add2,
            operatorNodeFuncWrapper__mult];

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);


              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // outMathNode = math.simplify(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              outMathNode = new FixedDecimalConstantNode(math.bignumber(outMathNode.evaluate({})));

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];
          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          function createMathNode__random_sci() {

            const nb_decimals = Math.floor(Math.random() * 3);
            const str__mantissa = [...Array(1 + nb_decimals)].reduce((acc, x, index) => {

              var value__digit;
              if(index == 0) {
                value__digit = 1 + Math.floor(Math.random() * 8);
              } else {
                value__digit = Math.floor(Math.random() * 9);
              }

              var str__digit   = "" + value__digit;

              if(index == 0) {
                str__digit += ".";
              }

              return acc + str__digit;
            }, "");

            const mathNode__mantissa = math.parse(str__mantissa);

            const value__powten = -(nb_decimals + Math.floor(Math.random() * 7));
            const mathNode__powten = new math.OperatorNode("^", "pow", [new math.ConstantNode(10), new math.ConstantNode(value__powten)]);

            const mathNode__sci = new math.OperatorNode("*", "multiply", [mathNode__mantissa,mathNode__powten]);
            return mathNode__sci;
          }

          const mathNode__target = createMathNode__random_sci();
          const gmItem__target   = GMItem.value(mathNode__target, "target", "");
          // logger.log("gmItem__target", gmItem__target);

          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(gmItem__target.content);

          function isSameExpression(mathNode_1, mathNode_2) {
            var outBool;

            const mathNode_equal = new math.RelationalNode(["equal"], [
              new math.ConstantNode(math.bignumber(mathNode_1.evaluate())),
              new math.ConstantNode(math.bignumber(mathNode_2.evaluate())),
            ]);

            outBool = mathNode_equal.evaluate({});

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__sqsqrtpow__sci2__sci_equal_fixed(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__sqsqrtpow__sci2__sci_equal_fixed();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__sqsqrtpow__sci2__sci_equal_fixed() {
          logger.log("random_challengeGMItemConfig__sqsqrtpow__sci2__sci_equal_fixed");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const operatorNodeFuncWrapper__add = (() => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(1);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          })();

          const operatorNodeFuncWrapper__mult = (() => {
            const op_mult = Operator.multiply();
            const node_b = new math.ConstantNode(10);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          })();

          const arr_operatorNodeFuncWrapper = [operatorNodeFuncWrapper__add, operatorNodeFuncWrapper__mult];

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration

              function createMathNode__pow_ten(mathNode_in) {
                const value_in = math.bignumber(outMathNode.evaluate());
                // const value_in = outMathNode.evaluate();
                logger.log("createMathNode__pow_ten, value_in", value_in);

                const value__powten   = Math.floor(math.log10(value_in));
                logger.log("createMathNode__pow_ten, value__powten", value__powten);
                const mathNode__powten = new math.OperatorNode("^", "pow", [new math.ConstantNode(10), new math.ConstantNode(value__powten)]);

                const value__mantissa = value_in / math.pow(10,value__powten);
                logger.log("createMathNode__pow_ten, value__mantissa", value__mantissa);
                const mathNode__mantissa = new FixedDecimalConstantNode(math.bignumber(value__mantissa));

                const mathNode__sci = new math.OperatorNode("*", "multiply", [mathNode__mantissa,mathNode__powten]);

                return mathNode__sci;
              }

              outMathNode = createMathNode__pow_ten(outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__symbol = [];


          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          const depth__target    = 7;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");


          function createMathNode__random_sci() {

            const nb_decimals = Math.floor(Math.random() * 3);
            const str__mantissa = [...Array(1 + nb_decimals)].reduce((acc, x, index) => {

              var value__digit;
              if(index == 0) {
                value__digit = 1 + Math.floor(Math.random() * 8);
              } else {
                value__digit = Math.floor(Math.random() * 9);
              }

              var str__digit   = "" + value__digit;

              if(index == 0) {
                str__digit += ".";
              }

              return acc + str__digit;
            }, "");

            const mathNode__mantissa = math.parse(str__mantissa);

            const value__powten = nb_decimals + Math.floor(Math.random() * 7);
            const mathNode__powten = new math.OperatorNode("^", "pow", [new math.ConstantNode(10), new math.ConstantNode(value__powten)]);

            const mathNode__sci = new math.OperatorNode("*", "multiply", [mathNode__mantissa,mathNode__powten]);
            return mathNode__sci;
          }

          var mathNode__target = createMathNode__random_sci();
          mathNode__target     = new FixedDecimalConstantNode(math.bignumber(mathNode__target.evaluate()));



          // const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          // const value__target    = math.bignumber(Math.floor(Math.random() * 10) * 1e9 + Math.floor(Math.random() * 10) * 1e6 + Math.floor(Math.random() * 10) * 1e3 + Math.floor(Math.random() * 10) * 1);
          // const mathNode__target = new FixedDecimalConstantNode(value__target);

          const gmItem__target = GMItem.value(mathNode__target, "target", "");
          // logger.log("gmItem__target", gmItem__target);

          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(gmItem__target.content);

          function isSameExpression(mathNode_1, mathNode_2) {
            var outBool;

            const mathNode_equal = new math.RelationalNode(["equal"], [
              new math.ConstantNode(math.bignumber(mathNode_1.evaluate())),
              new math.ConstantNode(math.bignumber(mathNode_2.evaluate())),
            ]);

            outBool = mathNode_equal.evaluate({});

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }



        static randomInstance__numexp__ne1_numexp_writing_add_mult(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__numexp__ne1_numexp_writing_add_mult();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__numexp__ne1_numexp_writing_add_mult() {
          logger.log("random_challengeGMItemConfig__numexp__ne1_numexp_writing_add_mult");

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +0,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 2;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[2]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 4;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          const mathNode__initial = new math.ConstantNode(10);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__numexp__ne2_numexp_writing_op4(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__numexp__ne2_numexp_writing_op4();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__numexp__ne2_numexp_writing_op4() {
          logger.log("random_challengeGMItemConfig__numexp__ne2_numexp_writing_op4");

          const nb_operators = 4;

          const nb_operators__add = 1;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +0,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__subtract = 1;
          const arr_gmItem_operator__subtract = [...new Array(nb_operators__subtract).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +0,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              // op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 1;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__divide = 1;
          const arr_gmItem_operator__divide = [...new Array(nb_operators__divide).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);
            operatorNodeFuncWrapper.display = {};
            operatorNodeFuncWrapper.display.node__display = new math.OperatorNode("÷", "divide__div", [MathSingleton.node__empty, operatorNodeFuncWrapper.semantics.node_b]);
            operatorNodeFuncWrapper.display.node__display.isShouldReplaceFrac = true;

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add,...arr_gmItem_operator__subtract, ...arr_gmItem_operator__mult, ...arr_gmItem_operator__divide];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [Utils.randomElementInArray(arr_gmItem_operator_for_target.slice(0,2)), Utils.randomElementInArray(arr_gmItem_operator_for_target.slice(2,4))];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 4;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          const mathNode__initial = new math.ConstantNode(10);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__numexp__ne3_numexp_writing_fat_to_fatter(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__numexp__ne3_numexp_writing_fat_to_fatter();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__numexp__ne3_numexp_writing_fat_to_fatter() {
          logger.log("random_challengeGMItemConfig__numexp__ne3_numexp_writing_fat_to_fatter");

          const nb_operators = 4;

          const nb_operators__add = 1;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +0,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__subtract = 1;
          const arr_gmItem_operator__subtract = [...new Array(nb_operators__subtract).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +0,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              // op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 1;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__divide = 1;
          const arr_gmItem_operator__divide = [...new Array(nb_operators__divide).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);
            operatorNodeFuncWrapper.display = {};
            operatorNodeFuncWrapper.display.node__display = new math.OperatorNode("÷", "divide__div", [MathSingleton.node__empty, operatorNodeFuncWrapper.semantics.node_b]);
            operatorNodeFuncWrapper.display.node__display.isShouldReplaceFrac = true;

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add,...arr_gmItem_operator__subtract, ...arr_gmItem_operator__mult, ...arr_gmItem_operator__divide];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [Utils.randomElementInArray(arr_gmItem_operator_for_target.slice(0,2)), Utils.randomElementInArray(arr_gmItem_operator_for_target.slice(2,4))];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 4;
          const depth__filler = depth__target - arr_mandat.length;

          const mathNode__zero = new math.ConstantNode(10);
          const gmItem__zero   = GMItem.value(mathNode__zero, "zero", "");

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr2(gmItem__zero, arr_mandat, arr_gmItem_operator_for_target, depth__filler);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__numexp__ne10_numexp__mental_calculation(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__numexp__ne10_numexp__mental_calculation();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__numexp__ne10_numexp__mental_calculation() {
          logger.log("random_challengeGMItemConfig__numexp__ne10_numexp__mental_calculation");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper__mult = [+2,+3,+4,+5,+6,+7,+8,+9].map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__mult = arr_operatorNodeFuncWrapper__mult.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                if(isOneInArgs) {
                  outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          //input

          const arr_operatorNodeFuncWrapper__input = [+5,+3,+2,+1,+50,+30,+20,+10].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__input = arr_operatorNodeFuncWrapper__input.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              outMathNode = math.simplify(outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__input.slice(0,4);
          const arr_gmItem_operator_2 = arr_gmItem_operator__input.slice(4,8);






          const mathNode__initial = random_constantNode({min: 1, max: 11, step: 1});
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          //create target

          var isTargetMade = false;
          var gmItem__target;

          while(!isTargetMade) {
            var gmItem__target = makeTarget(gmItem__initial);
            const value__target = gmItem__target.content.evaluate({});
            isTargetMade = (13 <= value__target) && (value__target <= 120);
          }

          function makeTarget(gmItem__initial) {

            const nb_expr_making_operators = 4;

            const arr_gmItem_operator__add = [...new Array(1).keys()].map(index => {

              const operatorParams = {
                node_b: {
                  types: ["ConstantNode"],
                  range: {
                    min: +1,
                    max: +10,
                  },
                },
                isShuffled: true,
              };

              const op_multiply = Operator.multiply();
              const op_divide   = Operator.divide();
              const op_add      = Operator.fromOpString_binary("+");
              const op_subtract = Operator.fromOpString_binary("-");

              const arr_op = [
                // op_multiply,
                // op_divide,
                op_add,
                // op_subtract,
              ];

              const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

              const name = operatorNodeFuncWrapper.semantics.name;

              const func = operatorNodeFuncWrapper.func;
              const func_decorated = function(mathNode_in) {
                logger.log("func_decorated, mathNode_in", mathNode_in);
                var outMathNode;

                //legacy
                outMathNode = func(mathNode_in);

                //decoration
                // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
                // logger.log("func_decorated, outMathNode", outMathNode);

                return outMathNode;
              };
              // const func_decorated = func;

              const specs = {
                funcWrapper: operatorNodeFuncWrapper,
              };

              const transformationFunc = function(icObj) {
                var transformationOutput;

                logger.log("transformationFunc", icObj);

                const facade = icObj;

                const mathNode__in  = facade.mathNode;
                mathNode__in.isEquation = false;
                const mathNode__new = func_decorated(mathNode__in);
                mathNode__new.isEquation = false;

                const facade__new = icObj.clone();
                facade__new.mathNode = mathNode__new;
                transformationOutput = new TransformationOutput("mutated", facade__new, facade);

                return transformationOutput;
              };

              const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
              return gmItem__operator;
            });

            const arr_gmItem_operator__mult = [...new Array(1).keys()].map(index => {

              const operatorParams = {
                node_b: {
                  types: ["ConstantNode"],
                  range: {
                    min: +2,
                    max: +5,
                  },
                },
                isShuffled: true,
              };

              const op_multiply = Operator.multiply();
              const op_divide   = Operator.divide();
              const op_add      = Operator.fromOpString_binary("+");
              const op_subtract = Operator.fromOpString_binary("-");

              const arr_op = [
                op_multiply,
                // op_divide,
                // op_add,
                // op_subtract,
              ];

              const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

              const name = operatorNodeFuncWrapper.semantics.name;

              const func = operatorNodeFuncWrapper.func;
              const func_decorated = function(mathNode_in) {
                logger.log("func_decorated, mathNode_in", mathNode_in);
                var outMathNode;

                //legacy
                outMathNode = func(mathNode_in);

                //decoration
                // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
                // logger.log("func_decorated, outMathNode", outMathNode);

                return outMathNode;
              };
              // const func_decorated = func;

              const specs = {
                funcWrapper: operatorNodeFuncWrapper,
              };

              const transformationFunc = function(icObj) {
                var transformationOutput;

                logger.log("transformationFunc", icObj);

                const facade = icObj;

                const mathNode__in  = facade.mathNode;
                mathNode__in.isEquation = false;
                const mathNode__new = func_decorated(mathNode__in);
                mathNode__new.isEquation = false;

                const facade__new = icObj.clone();
                facade__new.mathNode = mathNode__new;
                transformationOutput = new TransformationOutput("mutated", facade__new, facade);

                return transformationOutput;
              };

              const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
              return gmItem__operator;
            });

            const arr_gmItem_operator__op3 = [...new Array(nb_expr_making_operators).keys()].map(index => {

              const operatorParams = {
                node_b: {
                  types: ["ConstantNode"],
                  range: {
                    min: +1,
                    max: +10,
                  },
                },
              };

              const op_multiply = Operator.multiply();
              const op_divide   = Operator.divide();
              const op_add      = Operator.fromOpString_binary("+");
              const op_subtract = Operator.fromOpString_binary("-");

              const arr_op = [
                op_multiply,
                // op_divide,
                op_add,
                op_subtract,
              ];

              const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

              const name = operatorNodeFuncWrapper.semantics.name;

              const func = operatorNodeFuncWrapper.func;
              const func_decorated = function(mathNode_in) {
                logger.log("func_decorated, mathNode_in", mathNode_in);
                var outMathNode;

                //legacy
                outMathNode = func(mathNode_in);

                //decoration
                // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
                // logger.log("func_decorated, outMathNode", outMathNode);

                return outMathNode;
              };
              // const func_decorated = func;

              const specs = {
                funcWrapper: operatorNodeFuncWrapper,
              };

              const transformationFunc = function(icObj) {
                var transformationOutput;

                logger.log("transformationFunc", icObj);

                const facade = icObj;

                const mathNode__in  = facade.mathNode;
                mathNode__in.isEquation = false;
                const mathNode__new = func_decorated(mathNode__in);
                mathNode__new.isEquation = false;

                const facade__new = icObj.clone();
                facade__new.mathNode = mathNode__new;
                transformationOutput = new TransformationOutput("mutated", facade__new, facade);

                return transformationOutput;
              };

              const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
              return gmItem__operator;
            });

            const arr_gmItem_operator__add_mult = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult];

            const arr_mandat = arr_gmItem_operator__add_mult;
            const arr_gmItem_operator_for_target = [...arr_gmItem_operator__add_mult, ...arr_gmItem_operator__op3];

            const depth__target = 4;
            const depth__filler = depth__target - arr_mandat.length;

            const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator__op3, depth__filler);

            return gmItem__target;

          }



          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator_2,
          };

          return gmItemConfig;
        }


        //litexp

        static randomInstance__litexp__l1_litexp_writing_op_seq__add_mult(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__litexp__l1_litexp_writing_op_seq__add_mult();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__litexp__l1_litexp_writing_op_seq__add_mult() {
          logger.log("random_challengeGMItemConfig__litexp__l1_litexp_writing_op_seq__add_mult");

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +0,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 2;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[2]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 4;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = new math.ConstantNode(10);

          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__litexp__l1_litexp_writing_op_seq__op4(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__litexp__l1_litexp_writing_op_seq__op4();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__litexp__l1_litexp_writing_op_seq__op4() {
          logger.log("random_challengeGMItemConfig__litexp__l1_litexp_writing_op_seq__op4");

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +0,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 2;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });





          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[2]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 4;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = new math.ConstantNode(10);

          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }

            //deshabillage
        
        static randomInstance__litexp__l1_litexp_expr_to_x__add_mult(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__litexp__l1_litexp_expr_to_x__add_mult();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__litexp__l1_litexp_expr_to_x__add_mult() {
          logger.log("random_challengeGMItemConfig__litexp__l1_litexp_expr_to_x__add_mult");

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +0,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 2;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[2]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 4;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = new math.ConstantNode(10);

          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });



          const arr_arr_gmItem_operator__dna_shuffled = Utils.shuffled_dna(arr_gmItem_operator, arr_gmItem_operator__inverse); 
          const arr_gmItem_operator__dna_shuffled_1 = arr_arr_gmItem_operator__dna_shuffled[0];
          const arr_gmItem_operator__dna_shuffled_2 = arr_arr_gmItem_operator__dna_shuffled[1];

          const gmItemConfig = {
            // initial:    gmItem__initial,
            // target :    gmItem__target,
            initial:    gmItem__target,
            target :    gmItem__initial,

            operators:           arr_gmItem_operator__dna_shuffled_1,
            operators__inverse:  arr_gmItem_operator__dna_shuffled_2,
          };

          return gmItemConfig;
        }


        static randomInstance__litexp__l1_litexp_expr_to_x__op4(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__litexp__l1_litexp_expr_to_x__op4();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__litexp__l1_litexp_expr_to_x__op4() {
          logger.log("random_challengeGMItemConfig__litexp__l1_litexp_expr_to_x__op4");

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +0,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 2;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });





          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[2]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 4;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = new math.ConstantNode(10);

          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const arr_arr_gmItem_operator__dna_shuffled = Utils.shuffled_dna(arr_gmItem_operator, arr_gmItem_operator__inverse); 
          const arr_gmItem_operator__dna_shuffled_1 = arr_arr_gmItem_operator__dna_shuffled[0];
          const arr_gmItem_operator__dna_shuffled_2 = arr_arr_gmItem_operator__dna_shuffled[1];

          const gmItemConfig = {
            // initial:    gmItem__initial,
            // target :    gmItem__target,
            initial:    gmItem__target,
            target :    gmItem__initial,

            operators:           arr_gmItem_operator__dna_shuffled_1,
            operators__inverse:  arr_gmItem_operator__dna_shuffled_2,
          };

          return gmItemConfig;
        }


        static randomInstance__litexp__l1plus_litexp_reduced_expr_to_x__op4(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__litexp__l1plus_litexp_reduced_expr_to_x__op4();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__litexp__l1plus_litexp_reduced_expr_to_x__op4() {
          logger.log("random_challengeGMItemConfig__litexp__l1plus_litexp_reduced_expr_to_x__op4");

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +0,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 2;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });





          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[2]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 4;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = new math.ConstantNode(10);

          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const arr_arr_gmItem_operator__dna_shuffled = Utils.shuffled_dna(arr_gmItem_operator, arr_gmItem_operator__inverse); 
          const arr_gmItem_operator__dna_shuffled_1 = arr_arr_gmItem_operator__dna_shuffled[0];
          const arr_gmItem_operator__dna_shuffled_2 = arr_arr_gmItem_operator__dna_shuffled[1];

          const gmItemConfig = {
            // initial:    gmItem__initial,
            // target :    gmItem__target,
            initial:    gmItem__target,
            target :    gmItem__initial,

            operators:           arr_gmItem_operator__dna_shuffled_1,
            operators__inverse:  arr_gmItem_operator__dna_shuffled_2,
          };

          return gmItemConfig;
        }



        static randomInstance__litexp__l2_litexp_writing_2(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__litexp__l2_litexp_writing_2();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__litexp__l2_litexp_writing_2() {
          logger.log("random_challengeGMItemConfig__litexp__l2_litexp_writing_2");

          const nb_operators = 4;

          const nb_operators__constant = 2;
          const arr_gmItem_operator__constant = [...new Array(nb_operators__constant).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__symbol = 2;
          const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["SymbolNode"],
                arr:["x"],
              },
              premultiplier: {
                n_type: "integer",
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper:  operatorNodeFuncWrapper,
              // operatorNode: operatorNodeFuncWrapper.operatorNode,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];



          const depth__target    = 4;
          // const depth__target = 10;

          const mathNode__initial = new math.SymbolNode("x");
          const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator__inverse,
            operators__inverse:  arr_gmItem_operator,
          };

          return gmItemConfig;
        }

        
        static randomInstance__litexp__l3_litexp_writing_3__v1(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__litexp__l3_litexp_writing_3__v1();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__litexp__l3_litexp_writing_3__v1() {
          logger.log("random_challengeGMItemConfig__litexp__l3_litexp_writing_3__v1");

          const nb_operators = 4;

          const nb_operators__constant = 2;
          const arr_gmItem_operator__constant = [...new Array(nb_operators__constant).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__symbol = 2;
          const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["SymbolNode"],
                arr:["x"],
              },
              premultiplier: {
                n_type: "integer",
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper:  operatorNodeFuncWrapper,
              // operatorNode: operatorNodeFuncWrapper.operatorNode,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];



          const depth__target    = 4;
          // const depth__target = 10;

          const mathNode__initial = new math.SymbolNode("x");
          const gmItem__initial   = GMItem.value(mathNode__initial, "target", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator__inverse,
            operators__inverse:  arr_gmItem_operator,
          };

          return gmItemConfig;
        }


        static randomInstance__litexp__l4_litexp_writing_sq_capped(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__litexp__l4_litexp_writing_sq_capped();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__litexp__l4_litexp_writing_sq_capped() {
          logger.log("random_challengeGMItemConfig__litexp__l4_litexp_writing_sq_capped");

          const nb_operators = 4;

          const nb_operators__constant = 2;
          const arr_gmItem_operator__constant = [...new Array(nb_operators__constant).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__symbol = 2;
          const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["SymbolNode"],
                arr:["x"],
              },
              premultiplier: {
                n_type: "integer",
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            // const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);
              //kill random
            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op.slice(index, index + 1));

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper:  operatorNodeFuncWrapper,
              // operatorNode: operatorNodeFuncWrapper.operatorNode,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];



          const depth__target    = 4;
          // const depth__target = 10;

          const mathNode__x = new math.SymbolNode("x");
          const mathNode__0 = new math.ConstantNode(0);
          const mathNode__1 = new math.ConstantNode(1);
          const mathNode__2 = new math.ConstantNode(2);

          const mathNode__initial = Utils.randomElementInArray([mathNode__x, mathNode__0, mathNode__1]);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          const mathNode__target__simplified = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = mathNode__target__simplified;

          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          function upgradeTex(tex) {
            var outTex;

            //beautify
            //"3 * x" -> "3x"
            //"3 * (" -> "3("
            function beautifyLitexp(str_in) {
              logger.log("logTex", "beautifyLitexp", str_in);

              const re = /([0-9]+)\\cdot (\w+)/;
              const str = str_in.replace(re, '$1$2');
              logger.log("logTex", "beautified", str);

              return str;
            }

            function beautifyLitexp_again(str_in) {
              logger.log("logTex", "beautifyLitexp_again", str_in);

              const re = /([0-9]+)\\cdot{ (\w+)}/;
              const str = str_in.replace(re, '$1$2');
              logger.log("logTex", "beautified_again", str);

              return str;
            }

            outTex = beautifyLitexp(tex);
            //horror
            [...Array(10).keys()].forEach(index => {
              outTex = beautifyLitexp_again(outTex);
            });

            outTex = outTex.replaceAll("\\cdot", "\\times");
            outTex = outTex.replaceAll("\\frac{ }", "÷");


            return outTex;
          }

          gmItem__initial.specs.func__upgradeTex = upgradeTex;
          gmItem__target.specs.func__upgradeTex  = upgradeTex;


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        static randomInstance__litexp__l10_litexp_eval_x(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__litexp__l10_litexp_eval_x();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__litexp__l10_litexp_eval_x() {
          logger.log("random_challengeGMItemConfig__litexp__l10_litexp_eval_x");

          const nb_operators = 4;

          const nb_operators__constant = 2;
          const arr_gmItem_operator__constant = [...new Array(nb_operators__constant).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__symbol = 2;
          const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["SymbolNode"],
                arr:["x"],
              },
              premultiplier: {
                n_type: "integer",
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper:  operatorNodeFuncWrapper,
              // operatorNode: operatorNodeFuncWrapper.operatorNode,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          function createOperatorNode(mathOperatorSymbol, mathOperatorFuncName, node_b, isShuffled) {
            var arr_child = [MathSingleton.node__empty, node_b];
            if(isShuffled) {
              Utils.shuffle(arr_child);
            }
            const operatorNode = new math.OperatorNode(mathOperatorSymbol, mathOperatorFuncName, arr_child);
            return operatorNode;
          }

          const isShuffled = false;

          const arr_number__distinct      = Utils.randomElementsInArray([0,1,2,3,4,5,6,7,8,9], 4, true);
          logger.log("arr_number__distinct", arr_number__distinct);
          const arr_gmItem_operator__eval = arr_number__distinct.map(number => {

            const func__eval = function(node_expr) {
              // logger.log("func__eval, node_expr", node_expr);
              // logger.log("func__eval, x is", number);
              const value = node_expr.evaluate({x: number});
              // logger.log("func__eval, value", value);
              const mathNode = new math.ConstantNode(value);
              return mathNode;
            };

            const op = Operator.eval();
            const operatorNodeFuncWrapper = createFuncWrapper(op, MathSingleton.node__empty, func__eval);


            const node_x     = new math.SymbolNode("x");
            const node_value = new math.ConstantNode(number);
            operatorNodeFuncWrapper.display.node__display = new math.AssignmentNode(node_x, node_value);
            logger.log("operatorNodeFuncWrapper.display.node__display", operatorNodeFuncWrapper.display.node__display);


            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            function upgradeTex(tex) {
              var outTex;

              outTex = tex.replaceAll("\\cdot", "");
              outTex = outTex.replaceAll(":=", "←");

              return outTex;
            }

            specs.func__upgradeTex = upgradeTex;

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });




          const depth__initial    = 4;

          const mathNode__x = new math.SymbolNode("x");
          const gmItem__x   = GMItem.value(mathNode__x, "x", "");

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__x, arr_gmItem_operator, depth__initial);
          // logger.log("gmItem__initial", gmItem__initial);
          const mathNode__initial = gmItem__initial.content;
          //simplify
          gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);



          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__eval, 1);
          const mathNode__target = gmItem__target.content;
          //simplify
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);






          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator__eval,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        static randomInstance__litexp__l10b_litexp_eval_xneg(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__litexp__l10b_litexp_eval_xneg();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__litexp__l10b_litexp_eval_xneg() {
          logger.log("random_challengeGMItemConfig__litexp__l10b_litexp_eval_xneg");

          const nb_operators = 4;

          const nb_operators__constant = 2;
          const arr_gmItem_operator__constant = [...new Array(nb_operators__constant).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__symbol = 2;
          const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["SymbolNode"],
                arr:["x"],
              },
              premultiplier: {
                n_type: "integer",
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper:  operatorNodeFuncWrapper,
              // operatorNode: operatorNodeFuncWrapper.operatorNode,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          function createOperatorNode(mathOperatorSymbol, mathOperatorFuncName, node_b, isShuffled) {
            var arr_child = [MathSingleton.node__empty, node_b];
            if(isShuffled) {
              Utils.shuffle(arr_child);
            }
            const operatorNode = new math.OperatorNode(mathOperatorSymbol, mathOperatorFuncName, arr_child);
            return operatorNode;
          }

          const isShuffled = false;

          const arr_number__distinct      = Utils.randomElementsInArray([0,-1,-2,-3,-4,-5,-6,-7,-8,-9], 4, true);
          logger.log("arr_number__distinct", arr_number__distinct);

          const arr_gmItem_operator__eval = arr_number__distinct.map(number => {

            const func__eval = function(node_expr) {
              // logger.log("func__eval, node_expr", node_expr);
              // logger.log("func__eval, x is", number);
              const value = node_expr.evaluate({x: number});
              // logger.log("func__eval, value", value);
              const mathNode = new math.ConstantNode(value);
              return mathNode;
            };

            const op = Operator.eval();
            const operatorNodeFuncWrapper = createFuncWrapper(op, MathSingleton.node__empty, func__eval);


            const node_x     = new math.SymbolNode("x");
            const node_value = new math.ConstantNode(number);
            operatorNodeFuncWrapper.display.node__display = new math.AssignmentNode(node_x, node_value);
            logger.log("operatorNodeFuncWrapper.display.node__display", operatorNodeFuncWrapper.display.node__display);


            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            function upgradeTex(tex) {
              var outTex;

              outTex = tex.replaceAll("\\cdot", "");
              outTex = outTex.replaceAll(":=", "←");

              return outTex;
            }

            specs.func__upgradeTex = upgradeTex;

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__eval__neg = arr_number__distinct.map(number => {

            const func__eval = function(node_expr) {
              // logger.log("func__eval, node_expr", node_expr);
              // logger.log("func__eval, x is", number);
              const value = node_expr.evaluate({x: -number});
              // logger.log("func__eval, value", value);
              const mathNode = new math.ConstantNode(value);
              return mathNode;
            };

            const op = Operator.eval();
            const operatorNodeFuncWrapper = createFuncWrapper(op, MathSingleton.node__empty, func__eval);


            const node_x     = new math.SymbolNode("x");
            const node_value = new math.ConstantNode(-number);
            operatorNodeFuncWrapper.display.node__display = new math.AssignmentNode(node_x, node_value);
            logger.log("operatorNodeFuncWrapper.display.node__display", operatorNodeFuncWrapper.display.node__display);


            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            function upgradeTex(tex) {
              var outTex;

              outTex = tex.replaceAll("\\cdot", "");
              outTex = outTex.replaceAll(":=", "←");

              return outTex;
            }

            specs.func__upgradeTex = upgradeTex;

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator__eval__full = [...arr_gmItem_operator__eval, ...arr_gmItem_operator__eval__neg];


          const depth__initial    = 4;

          const mathNode__x = new math.SymbolNode("x");
          const gmItem__x   = GMItem.value(mathNode__x, "x", "");

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__x, arr_gmItem_operator, depth__initial);
          // logger.log("gmItem__initial", gmItem__initial);
          const mathNode__initial = gmItem__initial.content;
          //simplify
          gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__eval__full, 1);
          const mathNode__target = gmItem__target.content;
          //simplify
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);






          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator__eval__neg,
            operators__inverse:  arr_gmItem_operator__eval,
          };

          return gmItemConfig;
        }


        static randomInstance__litexp__l10c_litexp_eval_xdec(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__litexp__l10c_litexp_eval_xdec();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__litexp__l10c_litexp_eval_xdec() {
          logger.log("random_challengeGMItemConfig__litexp__l10c_litexp_eval_xdec");

          const nb_operators = 4;

          const nb_operators__constant = 2;
          const arr_gmItem_operator__constant = [...new Array(nb_operators__constant).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__symbol = 2;
          const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["SymbolNode"],
                arr:["x"],
              },
              premultiplier: {
                n_type: "integer",
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper:  operatorNodeFuncWrapper,
              // operatorNode: operatorNodeFuncWrapper.operatorNode,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          function createOperatorNode(mathOperatorSymbol, mathOperatorFuncName, node_b, isShuffled) {
            var arr_child = [MathSingleton.node__empty, node_b];
            if(isShuffled) {
              Utils.shuffle(arr_child);
            }
            const operatorNode = new math.OperatorNode(mathOperatorSymbol, mathOperatorFuncName, arr_child);
            return operatorNode;
          }

          const isShuffled = false;

          const arr_number__distinct = Utils.randomElementsInArray([0,1,2,3,4,5,6,7,8,9], 4, true).map(number => {
            const value_dx   = Utils.randomElementInArray([0,1,2,3,4,5,6,7,8,9]);
            const number_dec = math.bignumber(number + 0.1 * value_dx);
            return number_dec;
          });
          logger.log("arr_number__distinct", arr_number__distinct);

          const arr_gmItem_operator__eval = arr_number__distinct.map(number => {

            const func__eval = function(node_expr) {
              // logger.log("func__eval, node_expr", node_expr);
              // logger.log("func__eval, x is", number);
              const value = node_expr.evaluate({x: number});
              // logger.log("func__eval, value", value);
              const mathNode = new FixedDecimalConstantNode(value);
              return mathNode;
            };

            const op = Operator.eval();
            const operatorNodeFuncWrapper = createFuncWrapper(op, MathSingleton.node__empty, func__eval);


            const node_x     = new math.SymbolNode("x");
            const node_value = new FixedDecimalConstantNode(number);
            operatorNodeFuncWrapper.display.node__display = new math.AssignmentNode(node_x, node_value);
            logger.log("operatorNodeFuncWrapper.display.node__display", operatorNodeFuncWrapper.display.node__display);


            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            function upgradeTex(tex) {
              var outTex;

              outTex = tex.replaceAll("\\cdot", "");
              outTex = outTex.replaceAll(":=", "←");
              outTex = outTex.replaceAll(".", "{,}");

              return outTex;
            }

            specs.func__upgradeTex = upgradeTex;

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });




          const depth__initial    = 4;

          const mathNode__x = new math.SymbolNode("x");
          const gmItem__x   = GMItem.value(mathNode__x, "x", "");

          const gmItem__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem__x, arr_gmItem_operator, depth__initial);
          // logger.log("gmItem__initial", gmItem__initial);
          const mathNode__initial = gmItem__initial.content;
          //simplify
          gmItem__initial.content = Simplifier.simplify_litexp_2(mathNode__initial);



          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__eval, 1);
          const mathNode__target = gmItem__target.content;
          //simplify
          // gmItem__target.content = math.simplify(mathNode__target);






          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator__eval,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__litexp__l11_litexp_eval_xy(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__litexp__l11_litexp_eval_xy();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__litexp__l11_litexp_eval_xy() {
          logger.log("random_challengeGMItemConfig__litexp__l11_litexp_eval_xy");

          const nb_operators = 4;

          const nb_operators__constant = 2;
          const arr_gmItem_operator__constant = [...new Array(nb_operators__constant).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__symbol = 2;
          const arr_gmItem_operator__symbol = [...new Array(nb_operators__symbol).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["SymbolNode"],
                arr:["x"],
              },
              premultiplier: {
                n_type: "integer",
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper:  operatorNodeFuncWrapper,
              // operatorNode: operatorNodeFuncWrapper.operatorNode,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator = [...arr_gmItem_operator__symbol, ...arr_gmItem_operator__constant];


          function createOperatorNode(mathOperatorSymbol, mathOperatorFuncName, node_b, isShuffled) {
            var arr_child = [MathSingleton.node__empty, node_b];
            if(isShuffled) {
              Utils.shuffle(arr_child);
            }
            const operatorNode = new math.OperatorNode(mathOperatorSymbol, mathOperatorFuncName, arr_child);
            return operatorNode;
          }

          const isShuffled = false;

          const arr_number__distinct      = Utils.randomElementsInArray([0,1,2,3,4,5,6,7,8,9], 4, true);
          logger.log("arr_number__distinct", arr_number__distinct);


          //debug
          // {
          //   const mathNode__xy = math.parse("3 - x + 4 * y");
          //   logger.log("mathNode__xy", mathNode__xy );
          //   logger.log("eval_x", mathNode__xy.evaluate({x: 10}) );
          // }


          const arr_gmItem_operator__eval__x = arr_number__distinct.map(number => {

            const func__eval = function(node_expr) {
              // logger.log("func__eval, node_expr", node_expr);
              // logger.log("func__eval, x is", number);

              const outMathNode = Rewriter.substitute(node_expr, (node) => {
                const isFound = node instanceof math.SymbolNode && node.name == "x";
                return isFound;
              }, (_) => {
                return new math.ConstantNode(number);
              });

              return outMathNode;
            };

            const op = Operator.eval();
            const operatorNodeFuncWrapper = createFuncWrapper(op, MathSingleton.node__empty, func__eval);


            const node_x     = new math.SymbolNode("x");
            const node_value = new math.ConstantNode(number);
            operatorNodeFuncWrapper.display.node__display = new math.AssignmentNode(node_x, node_value);
            logger.log("operatorNodeFuncWrapper.display.node__display", operatorNodeFuncWrapper.display.node__display);


            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            function upgradeTex(tex) {
              var outTex;

              outTex = tex.replaceAll("\\cdot", "");
              outTex = outTex.replaceAll(":=", "←");

              return outTex;
            }

            specs.func__upgradeTex = upgradeTex;

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator__eval__y = arr_number__distinct.map(number => {

            const func__eval = function(node_expr) {
              // logger.log("func__eval, node_expr", node_expr);
              // logger.log("func__eval, x is", number);

              const outMathNode = Rewriter.substitute(node_expr, (node) => {
                const isFound = node instanceof math.SymbolNode && node.name == "y";
                return isFound;
              }, (_) => {
                return new math.ConstantNode(number);
              });

              return outMathNode;
            };

            const op = Operator.eval();
            const operatorNodeFuncWrapper = createFuncWrapper(op, MathSingleton.node__empty, func__eval);


            const node_x     = new math.SymbolNode("y");
            const node_value = new math.ConstantNode(number);
            operatorNodeFuncWrapper.display.node__display = new math.AssignmentNode(node_x, node_value);
            logger.log("operatorNodeFuncWrapper.display.node__display", operatorNodeFuncWrapper.display.node__display);


            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            function upgradeTex(tex) {
              var outTex;

              outTex = tex.replaceAll("\\cdot", "");
              outTex = outTex.replaceAll(":=", "←");

              return outTex;
            }

            specs.func__upgradeTex = upgradeTex;

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          const depth__initial    = 4;

          const mathNode__x = new math.SymbolNode("x");
          const gmItem__x   = GMItem.value(mathNode__x, "x", "");

          const gmItem__expr_x   = GMMaker.createGMItemTarget__x_to_expr(gmItem__x, arr_gmItem_operator, depth__initial);
          const mathNode__expr_x = gmItem__expr_x.content;

          const mathNode__y = new math.SymbolNode("y");
          const gmItem__y   = GMItem.value(mathNode__y, "y", "");

          const gmItem__expr_y   = GMMaker.createGMItemTarget__x_to_expr(gmItem__y, arr_gmItem_operator, depth__initial);
          const mathNode__expr_y = gmItem__expr_y.content;

          const mathNode__expr_xy = new math.OperatorNode("+", "add", [mathNode__expr_x, mathNode__expr_y]);
          const gmItem__expr_xy   = GMItem.value(mathNode__expr_xy, "initial", "");
          gmItem__expr_xy.content = Simplifier.simplify_litexp_2(gmItem__expr_xy.content);


          var gmItem__target = gmItem__expr_xy;
          gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__target, arr_gmItem_operator__eval__x, 1);
          gmItem__target = GMMaker.createGMItemTarget__x_to_expr(gmItem__target, arr_gmItem_operator__eval__y, 1);

          const mathNode__target = gmItem__target.content;
          //simplify
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);






          const gmItemConfig = {
            initial:    gmItem__expr_xy,
            target :    gmItem__target,

            operators:           arr_gmItem_operator__eval__x,
            operators__inverse:  arr_gmItem_operator__eval__y,
          };

          return gmItemConfig;
        }


        static randomInstance__eq__eq1_add_near(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__eq__eq1_add_near();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__eq__eq1_add_near() {
          logger.log("random_challengeGMItemConfig__eq__eq1_add_near");

          const mathNode__left   = new math.SymbolNode("x");

          // const mathNode__right  = new math.ConstantNode(3);
          const mathNode__right  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);

          const mathNode__target = new math.RelationalNode(["equal"], [mathNode__left, mathNode__right]);
          mathNode__target.isEquation = true;

          const gmItem__target = GMItem.value(mathNode__target, "target", "");

          function isSameExpression(mathNode1, mathNode2) {
            var outBool;

            logger.log("isSameExpression", mathNode1, mathNode2);

            const isSameRightMember = mathNode1.params[1].value == mathNode2.params[1].value;
            outBool = isSameRightMember;

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;

          const mathNode__display__left  = new math.SymbolNode("x");
          const mathNode__display__right = new math.SymbolNode(" ?");
          gmItem__target.specs.node__display = new math.RelationalNode(["equal"], [mathNode__display__left, mathNode__display__right]);




          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_operatorNodeFuncWrapper__subtract = [5,1].map(number => {
            const op_add = Operator.fromOpString_binary("-");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper__add = [1,5].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper = [...arr_operatorNodeFuncWrapper__subtract, ...arr_operatorNodeFuncWrapper__add];

          function createGmItemOperator(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }

          const arr_gmItem_operator = arr_operatorNodeFuncWrapper.map(createGmItemOperator);

          // const depth__initial    = 7;
          // const depth__initial    = 10;

          const gmItem__initial_seed = gmItem__target.clone();
          // gmItem__initial_seed.content.autoSimplify = true;
          gmItem__initial_seed.content.isEquation   = true;



          /**/
          const number = 1 + Math.floor(Math.random() * 9);
          const node_b = new math.ConstantNode(number);

          const op_add      = Operator.fromOpString_binary("+");
          const op_subtract = Operator.fromOpString_binary("-");
          const op_initial_trans = Utils.randomElementInArray([op_add, op_subtract]);

          const operatorNodeFuncWrapper__initial_trans = operatorNodeFactoryFuncWrapper_binary(op_initial_trans, node_b);

          const arr_gmItem_operator__initial_trans = [createGmItemOperator(operatorNodeFuncWrapper__initial_trans)];
          /**/

          const depth__initial = 1;
          const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial_seed, arr_gmItem_operator__initial_trans, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;

          logger.log("gmItem__initial", gmItem__initial);

          // const mathNode__initial = new math.ConstantNode(79);
          // const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");



          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_full(outMathNode);
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial__display: gmItem__initial,

            initial:          gmItem__initial,
            target :          gmItem__target,

            operators:           arr_gmItem_operator__inverse,
            operators__inverse:  arr_gmItem_operator,
          };

          return gmItemConfig;
        }

        static randomInstance__eq__eq2_add_far(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__eq__eq2_add_far();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__eq__eq2_add_far() {
          logger.log("random_challengeGMItemConfig__eq__eq2_add_far");

          const mathNode__left   = new math.SymbolNode("x");

          // const mathNode__right  = new math.ConstantNode(3);
          const value__right     = Utils.randomElementInArray([-3,-2,-1,0,+1,+2,+3]);
          const mathNode__right  = new math.ConstantNode(value__right);

          const mathNode__target = new math.RelationalNode(["equal"], [mathNode__left, mathNode__right]);
          mathNode__target.isEquation = true;

          const gmItem__target = GMItem.value(mathNode__target, "target", "");

          function isSameExpression(mathNode1, mathNode2) {
            var outBool;

            logger.log("isSameExpression", mathNode1, mathNode2);

            const mathNode_equal = new math.RelationalNode(["equal"], [
              new math.ConstantNode(math.bignumber(mathNode1.params[1].evaluate())),
              new math.ConstantNode(math.bignumber(mathNode2.params[1].evaluate())),
            ]);

            outBool = mathNode_equal.evaluate({});

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;

          const mathNode__display__left  = new math.SymbolNode("x");
          const mathNode__display__right = new math.SymbolNode(" ?");
          gmItem__target.specs.node__display = new math.RelationalNode(["equal"], [mathNode__display__left, mathNode__display__right]);


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_operatorNodeFuncWrapper__subtract = [10,1].map(number => {
            const op_add = Operator.fromOpString_binary("-");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper__add = [1,10].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper = [...arr_operatorNodeFuncWrapper__subtract, ...arr_operatorNodeFuncWrapper__add];

          function createGmItemOperator(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }

          const arr_gmItem_operator = arr_operatorNodeFuncWrapper.map(createGmItemOperator);

          // const depth__initial    = 7;
          // const depth__initial    = 10;

          const gmItem__initial_seed = gmItem__target.clone();
          // gmItem__initial_seed.content.autoSimplify = true;
          gmItem__initial_seed.content.isEquation   = true;



          /**/
          const number = 24 + Math.floor(Math.random() * 50);
          const node_b = new math.ConstantNode(number);

          const op_add      = Operator.fromOpString_binary("+");
          const op_subtract = Operator.fromOpString_binary("-");
          const op_initial_trans = Utils.randomElementInArray([op_add, op_subtract]);

          const operatorNodeFuncWrapper__initial_trans = operatorNodeFactoryFuncWrapper_binary(op_initial_trans, node_b);

          const arr_gmItem_operator__initial_trans = [createGmItemOperator(operatorNodeFuncWrapper__initial_trans)];
          /**/

          const depth__initial = 1;
          const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial_seed, arr_gmItem_operator__initial_trans, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;

          logger.log("gmItem__initial", gmItem__initial);

          // const mathNode__initial = new math.ConstantNode(79);
          // const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");



          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_full(outMathNode);
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial__display: gmItem__initial,

            initial:          gmItem__initial,
            target :          gmItem__target,

            operators:           arr_gmItem_operator__inverse,
            operators__inverse:  arr_gmItem_operator,
          };

          return gmItemConfig;
        }


        static randomInstance__eq__eq3_add__side_explicit_with_number_symbol(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__eq__eq3_add__side_explicit_with_number_symbol();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__eq__eq3_add__side_explicit_with_number_symbol() {
          logger.log("random_challengeGMItemConfig__eq__eq3_add__side_explicit_with_number_symbol");

          const mathNode__left   = new math.SymbolNode("x");

          // const mathNode__right  = new math.ConstantNode(3);
          {
            const mathNode__right__symbol      = new math.SymbolNode("y");
            // const mathNode__right__tree        = new math.OperatorNode("+", "add", [new math.ConstantNode(12), mathNode__right__symbol]);
            const mathNode__right__tree        = mathNode__right__symbol;
            const mathNode__right__value       = random_terminal_mathNode_withType_inArr(["ConstantNode"]);


            const mathNode__right__assign      = new math.AssignmentNode(mathNode__right__symbol, mathNode__right__value);
            // const mathNode__right              = new math.OperatorNode("⇇", "assign_recur",[mathNode__right__tree,mathNode__right__assign]);
            // const mathNode__right              = new math.FunctionNode(new math.SymbolNode("assign_recur"),[mathNode__right__tree,mathNode__right__assign]);
            const mathNode__right              = math.assign_recur(mathNode__right__tree,mathNode__right__assign);
            mathNode__right.mathNode__litexp   = mathNode__right__tree;
            mathNode__right.mathNode__assign   = mathNode__right__assign;

            logger.log("mathNode__right", mathNode__right);
            logger.log("mathNode__right.evaluate()", mathNode__right.evaluate());
          }


          const mathNode__right       = random_terminal_mathNode_withType_inArr(["ConstantNode"]);


          const mathNode__target = new math.RelationalNode(["equal"], [mathNode__left, mathNode__right]);
          logger.log("mathNode__target", mathNode__target);
          mathNode__target.isEquation = true;

          const gmItem__target = GMItem.value(mathNode__target, "target", "");

          function isSameExpression(mathNode1, mathNode2) {
            var outBool;

            logger.log("isSameExpression", mathNode1, mathNode2);

            const mathNode_equal = new math.RelationalNode(["equal"], [
              new math.ConstantNode(math.bignumber(mathNode1.params[1].evaluate())),
              new math.ConstantNode(math.bignumber(mathNode2.params[1].evaluate())),
            ]);

            outBool = mathNode_equal.evaluate({});

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;

          const mathNode__display__left  = new math.SymbolNode("x");
          const mathNode__display__right = new math.SymbolNode(" ?");
          gmItem__target.specs.node__display = new math.RelationalNode(["equal"], [mathNode__display__left, mathNode__display__right]);


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_operatorNodeFuncWrapper__subtract = [5,1].map(number => {
            const op_add = Operator.fromOpString_binary("-");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper__add = [1,5].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper = [...arr_operatorNodeFuncWrapper__subtract, ...arr_operatorNodeFuncWrapper__add];

          function createGmItemOperator_for_initial_trans(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }

          function createGmItemOperator_for_op(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              // outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_equation(outMathNode);

              //simplify lhs, custom simplify rhs
              function custom_apply(mathNode_in, func) {
                var outMathNode;

                const mathNode_lhs_in = mathNode_in.params[0];
                // logger.log("func_decorated, mathNode_lhs_in", mathNode_lhs_in);

                const mathNode_rhs_in = mathNode_in.params[1];
                const mathNode_rhs_in__litexp = mathNode_rhs_in.mathNode__litexp;
                const mathNode_rhs_in__assign = mathNode_rhs_in.mathNode__assign;
                // logger.log("func_decorated, mathNode_rhs_in", mathNode_rhs_in);

                var mathNode_lhs_out = func(mathNode_lhs_in);
                mathNode_lhs_out     = Simplifier.simplify_litexp_2(mathNode_lhs_out);


                var mathNode_rhs_out = func(mathNode_rhs_in__litexp);
                const mathNode__litexp_out = Simplifier.simplify_litexp_2(mathNode_rhs_out);

                mathNode_rhs_out = math.assign_recur(mathNode__litexp_out,mathNode_rhs_in__assign);
                mathNode_rhs_out.mathNode__litexp = mathNode__litexp_out;
                mathNode_rhs_out.mathNode__assign = mathNode_rhs_in__assign;

                outMathNode = new math.RelationalNode(["equal"], [mathNode_lhs_out, mathNode_rhs_out]);
                outMathNode.isEquation = true;

                return outMathNode;
              }

              if(mathNode_in.isEquation) {
                outMathNode = custom_apply(mathNode_in, func);
                logger.log("func_decorated, outMathNode", outMathNode);
              } else {
                outMathNode = func(mathNode_in);
              }

              return outMathNode;
            };
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }

          const arr_gmItem_operator      = arr_operatorNodeFuncWrapper.map(createGmItemOperator_for_op);


          // const depth__initial    = 7;
          // const depth__initial    = 10;

          const gmItem__initial_seed = gmItem__target.clone();
          // gmItem__initial_seed.content.autoSimplify = true;
          gmItem__initial_seed.content.isEquation   = true;
          logger.log("gmItem__initial_seed.content", gmItem__initial_seed.content);



          /**/
          const number = 1 + Math.floor(Math.random() * 9);
          const node_b = new math.ConstantNode(number);

          const op_add      = Operator.fromOpString_binary("+");
          const op_subtract = Operator.fromOpString_binary("-");
          const op_initial_trans = Utils.randomElementInArray([op_add, op_subtract]);

          const operatorNodeFuncWrapper__initial_trans = operatorNodeFactoryFuncWrapper_binary(op_initial_trans, node_b);

          const arr_gmItem_operator__initial_trans = [createGmItemOperator_for_initial_trans(operatorNodeFuncWrapper__initial_trans)];
          /**/

          const depth__initial = 1;
          const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial_seed, arr_gmItem_operator__initial_trans, depth__initial);

          function symbolify(mathNode_in) {
            var outMathNode;

            function makeid(length) {
              var result           = '';
              var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
              var charactersLength = characters.length;
              for ( var i = 0; i < length; i++ ) {
                result += characters.charAt(Math.floor(Math.random() * charactersLength));
              }
              return result;
            }

            const str__symbol           = makeid(10);

            const mathNode__symbol      = new math.SymbolNode(str__symbol);
            // const mathNode__right__tree        = new math.OperatorNode("+", "add", [new math.ConstantNode(12), mathNode__right__symbol]);
            const mathNode__tree        = mathNode__symbol;
            const mathNode__value       = mathNode_in;


            const mathNode__assign      = new math.AssignmentNode(mathNode__symbol, mathNode__value);

            const mathNode              = math.assign_recur(mathNode__tree, mathNode__assign);
            mathNode.mathNode__litexp   = mathNode__tree;
            mathNode.mathNode__assign   = mathNode__assign;

            outMathNode = mathNode;

            return outMathNode;
          }

          const mathNode_initial                 = gmItem__initial.content;
          const mathNode_initial__rhs            = mathNode_initial.params[1];
          const mathNode_initial__rhs__protected = symbolify(mathNode_initial__rhs);

          gmItem__initial.content.params[1] = mathNode_initial__rhs__protected;

          logger.log("gmItem__initial", gmItem__initial);

          const gmItemConfig = {
            initial__display: gmItem__initial,

            initial:          gmItem__initial,
            target :          gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__eq__eq4_add__side_magic(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__eq__eq4_add__side_magic();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__eq__eq4_add__side_magic() {
          logger.log("random_challengeGMItemConfig__eq__eq4_add__side_magic");

          const nb_operators = 4;

          const arr_operatorNodeFuncWrapper__subtract = [5,1].map(number => {
            const op_add = Operator.fromOpString_binary("-");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper__add = [1,5].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });


          function createGmItemOperator_magic(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }


          const arr_str__magic = [
            "magic:lhs+",
            "magic:lhs-",
            "magic:rhs+",
            "magic:rhs-",
          ];

          const arr_gmItem_operator__magic = arr_str__magic.map(str_magic => {
            const op_magic                 = Operator.fromString_unary(str_magic);
            const operatorNodeFuncWrapper  = operatorNodeFactoryFuncWrapper_unary(op_magic);
            logger.log("logEq4", "operatorNodeFuncWrapper", operatorNodeFuncWrapper);
            const gmItem_operator          = createGmItemOperator_magic(operatorNodeFuncWrapper);
            
            const str__display  = Operator.displayStringForOp(op_magic);
            const node__display = new math.SymbolNode(str__display);
            gmItem_operator.specs.node__display = node__display;
            
            return gmItem_operator;
          });



          const arr_operatorNodeFuncWrapper = [...arr_operatorNodeFuncWrapper__subtract, ...arr_operatorNodeFuncWrapper__add];

          function createGmItemOperator_for_initial_trans(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }

          function createGmItemOperator_for_op(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              // outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_equation(outMathNode);

              //simplify lhs, custom simplify rhs
              function custom_apply(mathNode_in, func) {
                var outMathNode;

                const mathNode_lhs_in = mathNode_in.params[0];
                // logger.log("func_decorated, mathNode_lhs_in", mathNode_lhs_in);

                const mathNode_rhs_in = mathNode_in.params[1];
                const mathNode_rhs_in__litexp = mathNode_rhs_in.mathNode__litexp;
                const mathNode_rhs_in__assign = mathNode_rhs_in.mathNode__assign;
                // logger.log("func_decorated, mathNode_rhs_in", mathNode_rhs_in);

                var mathNode_lhs_out = func(mathNode_lhs_in);
                mathNode_lhs_out     = Simplifier.simplify_litexp_2(mathNode_lhs_out);


                var mathNode_rhs_out = func(mathNode_rhs_in__litexp);
                const mathNode__litexp_out = Simplifier.simplify_litexp_2(mathNode_rhs_out);

                mathNode_rhs_out = math.assign_recur(mathNode__litexp_out,mathNode_rhs_in__assign);
                mathNode_rhs_out.mathNode__litexp = mathNode__litexp_out;
                mathNode_rhs_out.mathNode__assign = mathNode_rhs_in__assign;

                outMathNode = new math.RelationalNode(["equal"], [mathNode_lhs_out, mathNode_rhs_out]);
                outMathNode.isEquation = true;

                return outMathNode;
              }

              if(mathNode_in.isEquation) {
                outMathNode = custom_apply(mathNode_in, func);
                logger.log("func_decorated, outMathNode", outMathNode);
              } else {
                outMathNode = func(mathNode_in);
              }

              return outMathNode;
            };
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }

          const arr_gmItem_operator      = arr_operatorNodeFuncWrapper.map(createGmItemOperator_for_op);



          const arr_shuffled__indexes = Utils.shuffle([0,1]);

          // const mathNode__left   = symbolify(new math.SymbolNode("x"));
          const mathNode__left   = new math.SymbolNode("x");
          const mathNode__right  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
          var arr_mathNode__target  = [mathNode__left, mathNode__right];
          arr_mathNode__target = Utils.shuffled_mimic(arr_mathNode__target, arr_shuffled__indexes);

          const mathNode__display__left  = new math.SymbolNode("x");
          const mathNode__display__right = new math.SymbolNode(" ?");
          var arr_mathNode__display = [mathNode__display__left, mathNode__display__right];
          arr_mathNode__display = Utils.shuffled_mimic(arr_mathNode__display, arr_shuffled__indexes);


          const mathNode__target = new math.RelationalNode(["equal"], arr_mathNode__target);
          logger.log("mathNode__target", mathNode__target);
          mathNode__target.isEquation = true;


          const gmItem__target   = GMItem.value(mathNode__target, "target", "");

          function isSameExpression(mathNode1, mathNode2) {
            var outBool;

            logger.log("isSameExpression", mathNode1, mathNode2);

            var arr_arr_mathNode__to_compare = Utils.zip(mathNode1.params, mathNode2.params);
            arr_arr_mathNode__to_compare     = Utils.shuffled_mimic(arr_arr_mathNode__to_compare, arr_shuffled__indexes);
            
            // const arr_mathNode__to_compare = arr_arr_mathNode__to_compare[1].map(mathNode => {
            //   return new math.ConstantNode(math.bignumber(mathNode.evaluate()));
            // });
            // logger.log("logEq4", "arr_mathNode__to_compare:", arr_mathNode__to_compare.toString());
            // const mathNode_equal = new math.RelationalNode(["equal"], arr_mathNode__to_compare);
            // outBool = mathNode_equal.evaluate({});

            logger.log("logEq4", "arr_arr_mathNode__to_compare[0][1]", arr_arr_mathNode__to_compare[0][1]);
            if(arr_arr_mathNode__to_compare[0][1] instanceof math.SymbolNode) {
              outBool = true;
            } else {
              outBool = false;
            }

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          gmItem__target.specs.node__display = new math.RelationalNode(["equal"], arr_mathNode__display);


          const gmItem__initial_seed = gmItem__target.clone();

          // gmItem__initial_seed.content.autoSimplify = true;
          gmItem__initial_seed.content.isEquation   = true;
          logger.log("gmItem__initial_seed.content", gmItem__initial_seed.content);



          /**/
          function generateRandom_gmItemOperator_for_initial_trans() {
            const number = 1 + Math.floor(Math.random() * 9);
            const node_b = new math.ConstantNode(number);

            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");
            const op_initial_trans = Utils.randomElementInArray([op_add, op_subtract]);

            const operatorNodeFuncWrapper__initial_trans = operatorNodeFactoryFuncWrapper_binary(op_initial_trans, node_b);

            const gmItem_operator__initial_trans = createGmItemOperator_for_initial_trans(operatorNodeFuncWrapper__initial_trans);
            return gmItem_operator__initial_trans;
          }
          /**/

          const arr_gmItem_operator__initial_trans = [...Array(10).keys()].map(generateRandom_gmItemOperator_for_initial_trans);

          const depth__initial = 1;

          const gmItem_lhs__pre     = GMItem.value(mathNode__left);
          const gmItem_rhs__pre     = GMItem.value(mathNode__right);

          const gmItem_lhs__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem_lhs__pre, arr_gmItem_operator__initial_trans, depth__initial, false);
          const gmItem_rhs__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem_rhs__pre, arr_gmItem_operator__initial_trans, depth__initial, true);


          

          function symbolify(mathNode_in) {
            var outMathNode;

            function makeid(length) {
              var result           = '';
              var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
              var charactersLength = characters.length;
              for ( var i = 0; i < length; i++ ) {
                result += characters.charAt(Math.floor(Math.random() * charactersLength));
              }
              return result;
            }

            const str__symbol           = makeid(10);

            const mathNode__symbol      = new math.SymbolNode(str__symbol);
            // const mathNode__right__tree        = new math.OperatorNode("+", "add", [new math.ConstantNode(12), mathNode__right__symbol]);
            const mathNode__tree        = mathNode__symbol;
            const mathNode__value       = mathNode_in;


            const mathNode__assign      = new math.AssignmentNode(mathNode__symbol, mathNode__value);

            const mathNode              = math.assign_recur(mathNode__tree, mathNode__assign);
            mathNode.mathNode__litexp   = mathNode__tree;
            mathNode.mathNode__assign   = mathNode__assign;

            outMathNode = mathNode;

            return outMathNode;
          }


          
          var arr_mathNode__initial = [gmItem_lhs__initial.content, gmItem_rhs__initial.content];
          arr_mathNode__initial = Utils.shuffled_mimic(arr_mathNode__initial, arr_shuffled__indexes);


          const mathNode__initial = new math.RelationalNode(["equal"], arr_mathNode__initial);
          const gmItem__initial   = GMItem.value(mathNode__initial);

          const mathNode_initial                 = gmItem__initial.content;
          const mathNode_initial__rhs            = mathNode_initial.params[1];
          const mathNode_initial__rhs__protected = symbolify(mathNode_initial__rhs);

          gmItem__initial.content.params[1] = mathNode_initial__rhs__protected;

          logger.log("gmItem__initial", gmItem__initial);


          const gmItemConfig = {
            initial__display: gmItem__initial,

            initial:          gmItem__initial,
            target :          gmItem__target,

            operators:           arr_gmItem_operator__magic,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        static randomInstance__eq__eq5_mult(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__eq__eq5_mult();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__eq__eq5_mult() {
          logger.log("random_challengeGMItemConfig__eq__eq5_mult");

          const mathNode__left   = new math.SymbolNode("x");

          // const mathNode__right  = new math.ConstantNode(3);
          const mathNode__right  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);

          const mathNode__target = new math.RelationalNode(["equal"], [mathNode__left, mathNode__right]);
          mathNode__target.isEquation = true;

          const gmItem__target = GMItem.value(mathNode__target, "target", "");

          function isSameExpression(mathNode1, mathNode2) {
            var outBool;

            logger.log("isSameExpression", mathNode1, mathNode2);

            const arr_shuffled__indexes = [0,1];

            var arr_arr_mathNode__to_compare = Utils.zip(mathNode1.params, mathNode2.params);
            arr_arr_mathNode__to_compare     = Utils.shuffled_mimic(arr_arr_mathNode__to_compare, arr_shuffled__indexes);
            
            logger.log("logEq4", "arr_arr_mathNode__to_compare[0][1]", arr_arr_mathNode__to_compare[0][1]);
            if(arr_arr_mathNode__to_compare[0][1] instanceof math.SymbolNode) {
              outBool = true;
            } else {
              outBool = false;
            }

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;

          const mathNode__display__left  = new math.SymbolNode("x");
          const mathNode__display__right = new math.SymbolNode(" ?");
          gmItem__target.specs.node__display = new math.RelationalNode(["equal"], [mathNode__display__left, mathNode__display__right]);



          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          // const arr_value = [...Array(9).keys()].map(index => index + 2);
          const arr_value = [2,3,5,10];

          const arr_operatorNodeFuncWrapper__multiply = arr_value.map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper__divide = arr_value.map(number => {
            const op_divide = Operator.fromOpString_binary("/");
            const node_b    = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_divide, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper = [...arr_operatorNodeFuncWrapper__divide, ...arr_operatorNodeFuncWrapper__multiply];

          function createGmItemOperator(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }

          const arr_gmItem_operator = arr_operatorNodeFuncWrapper.map(createGmItemOperator);

          // const depth__initial    = 7;
          // const depth__initial    = 10;

          const gmItem__initial_seed = gmItem__target.clone();
          // gmItem__initial_seed.content.autoSimplify = true;
          gmItem__initial_seed.content.isEquation   = true;



          /**/
          // const number = 1 + Math.floor(Math.random() * 9);
          // const node_b = new math.ConstantNode(number);
          //
          // const op_add      = Operator.fromOpString_binary("x");
          // const op_subtract = Operator.fromOpString_binary("/");
          // const op_initial_trans = Utils.randomElementInArray([op_add, op_subtract]);
          //
          // const operatorNodeFuncWrapper__initial_trans = operatorNodeFactoryFuncWrapper_binary(op_initial_trans, node_b);
          //
          // const arr_gmItem_operator__initial_trans = [createGmItemOperator(operatorNodeFuncWrapper__initial_trans)];
          /**/

          const arr_gmItem_operator__initial_trans = Utils.randomElementInArray([arr_gmItem_operator.slice(0,4), arr_gmItem_operator.slice(4,8)]);

          const depth__initial = 2;
          /*
          const depth__initial = 2;
          const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial_seed, arr_gmItem_operator__initial_trans, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;
          logger.log("gmItem__initial", gmItem__initial);
          */

          const gmItem_lhs__pre     = GMItem.value(mathNode__left);
          const gmItem_rhs__pre     = null;

          const gmItem_lhs__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem_lhs__pre, arr_gmItem_operator__initial_trans, depth__initial, false);
          const gmItem_rhs__initial = GMItem.value(new math.ConstantNode(Utils.randomElementInArray([0,1,2,3,4,5,6,7,8,9,10,11,12,20,30,40,50,100])));

          const mathNode__initial = new math.RelationalNode(["equal"], [gmItem_lhs__initial.content, gmItem_rhs__initial.content]);
          const gmItem__initial   = GMItem.value(mathNode__initial);


          const gmItemConfig = {
            initial__display: gmItem__initial,

            initial:          gmItem__initial,
            target :          gmItem__target,

            operators:           arr_gmItem_operator.slice(0,4),
            operators__inverse:  arr_gmItem_operator.slice(4,8),
          };

          return gmItemConfig;
        }


        static randomInstance__eq__eq7_mult__side_magic(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__eq__eq7_mult__side_magic();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__eq__eq7_mult__side_magic() {
          logger.log("random_challengeGMItemConfig__eq__eq7_mult__side_magic");

          const nb_operators = 4;

          const arr_value_2to10 = [...Array(9).keys()].map(index => index + 2);

          const arr_operatorNodeFuncWrapper__multiply = arr_value_2to10.map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper__divide = arr_value_2to10.map(number => {
            const op_divide = Operator.fromOpString_binary("/");
            const node_b    = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_divide, node_b);
            return operatorNodeFuncWrapper;
          });

          function createGmItemOperator_magic(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }


          const arr_str__magic = [
            "magic:lhsx",
            "magic:lhs/",
          ];

          const arr_gmItem_operator__magic = arr_str__magic.map(str_magic => {
            const op_magic__lhs                = Operator.fromString_unary(str_magic);
            const operatorNodeFuncWrapper__lhs = operatorNodeFactoryFuncWrapper_unary(op_magic__lhs);
            const gmItem_operator__lhs         = createGmItemOperator_magic(operatorNodeFuncWrapper__lhs);
            return gmItem_operator__lhs;
          });



          const arr_operatorNodeFuncWrapper = [...arr_operatorNodeFuncWrapper__divide, ...arr_operatorNodeFuncWrapper__multiply];

          function createGmItemOperator_for_initial_trans(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }

          function createGmItemOperator_for_op(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              // outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_equation(outMathNode);

              //simplify lhs, custom simplify rhs
              function custom_apply(mathNode_in, func) {
                var outMathNode;

                const mathNode_lhs_in = mathNode_in.params[0];
                // logger.log("func_decorated, mathNode_lhs_in", mathNode_lhs_in);

                const mathNode_rhs_in = mathNode_in.params[1];
                const mathNode_rhs_in__litexp = mathNode_rhs_in.mathNode__litexp;
                const mathNode_rhs_in__assign = mathNode_rhs_in.mathNode__assign;
                // logger.log("func_decorated, mathNode_rhs_in", mathNode_rhs_in);

                var mathNode_lhs_out = func(mathNode_lhs_in);
                mathNode_lhs_out     = Simplifier.simplify_litexp_2(mathNode_lhs_out);


                var mathNode_rhs_out = func(mathNode_rhs_in__litexp);
                const mathNode__litexp_out = Simplifier.simplify_litexp_2(mathNode_rhs_out);

                mathNode_rhs_out = math.assign_recur(mathNode__litexp_out,mathNode_rhs_in__assign);
                mathNode_rhs_out.mathNode__litexp = mathNode__litexp_out;
                mathNode_rhs_out.mathNode__assign = mathNode_rhs_in__assign;

                outMathNode = new math.RelationalNode(["equal"], [mathNode_lhs_out, mathNode_rhs_out]);
                outMathNode.isEquation = true;

                return outMathNode;
              }

              if(mathNode_in.isEquation) {
                outMathNode = custom_apply(mathNode_in, func);
                logger.log("func_decorated, outMathNode", outMathNode);
              } else {
                outMathNode = func(mathNode_in);
              }

              return outMathNode;
            };
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }

          const arr_gmItem_operator      = arr_operatorNodeFuncWrapper.map(createGmItemOperator_for_op);




          // const mathNode__left   = symbolify(new math.SymbolNode("x"));
          const mathNode__left   = new math.SymbolNode("x");
          const mathNode__right  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);


          const mathNode__target = new math.RelationalNode(["equal"], [mathNode__left, mathNode__right]);
          logger.log("mathNode__target", mathNode__target);
          mathNode__target.isEquation = true;

          const gmItem__target   = GMItem.value(mathNode__target, "target", "");

          function isSameExpression(mathNode1, mathNode2) {
            var outBool;

            logger.log("isSameExpression", mathNode1, mathNode2);

            const arr_shuffled__indexes = [0,1];

            var arr_arr_mathNode__to_compare = Utils.zip(mathNode1.params, mathNode2.params);
            arr_arr_mathNode__to_compare     = Utils.shuffled_mimic(arr_arr_mathNode__to_compare, arr_shuffled__indexes);
            
            logger.log("logEq4", "arr_arr_mathNode__to_compare[0][1]", arr_arr_mathNode__to_compare[0][1]);
            if(arr_arr_mathNode__to_compare[0][1] instanceof math.SymbolNode) {
              outBool = true;
            } else {
              outBool = false;
            }

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;

          const mathNode__display__left  = new math.SymbolNode("x");
          const mathNode__display__right = new math.SymbolNode(" ?");
          gmItem__target.specs.node__display = new math.RelationalNode(["equal"], [mathNode__display__left, mathNode__display__right]);



          const gmItem__initial_seed = gmItem__target.clone();

          // gmItem__initial_seed.content.autoSimplify = true;
          gmItem__initial_seed.content.isEquation   = true;
          logger.log("gmItem__initial_seed.content", gmItem__initial_seed.content);



          /**/
          function generateRandom_gmItemOperator_for_initial_trans() {
            const number = 1 + Math.floor(Math.random() * 9);
            const node_b = new math.ConstantNode(number);

            const op_mult      = Operator.fromOpString_binary("x");
            const op_divide    = Operator.fromOpString_binary("/");
            const op_initial_trans = Utils.randomElementInArray([op_mult, op_divide]);

            const operatorNodeFuncWrapper__initial_trans = operatorNodeFactoryFuncWrapper_binary(op_initial_trans, node_b);

            const gmItem_operator__initial_trans = createGmItemOperator_for_initial_trans(operatorNodeFuncWrapper__initial_trans);
            return gmItem_operator__initial_trans;
          }
          /**/

          const arr_gmItem_operator__initial_trans = [...Array(1).keys()].map(generateRandom_gmItemOperator_for_initial_trans);

          const depth__initial = 1;

          const gmItem_lhs__pre     = GMItem.value(mathNode__left);
          // const gmItem_rhs__pre     = GMItem.value(mathNode__right);

          const gmItem_lhs__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem_lhs__pre, arr_gmItem_operator__initial_trans, depth__initial, false);
          const gmItem_rhs__initial = GMItem.value(new math.ConstantNode(Utils.randomElementInArray([0,1,2,3,4,5,6,7,8,9,10,11,12,20,30,40,50,100])));

          const mathNode__initial = new math.RelationalNode(["equal"], [gmItem_lhs__initial.content, gmItem_rhs__initial.content]);
          const gmItem__initial   = GMItem.value(mathNode__initial);

          function symbolify(mathNode_in) {
            var outMathNode;

            function makeid(length) {
              var result           = '';
              var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
              var charactersLength = characters.length;
              for ( var i = 0; i < length; i++ ) {
                result += characters.charAt(Math.floor(Math.random() * charactersLength));
              }
              return result;
            }

            const str__symbol           = makeid(10);

            const mathNode__symbol      = new math.SymbolNode(str__symbol);
            // const mathNode__right__tree        = new math.OperatorNode("+", "add", [new math.ConstantNode(12), mathNode__right__symbol]);
            const mathNode__tree        = mathNode__symbol;
            const mathNode__value       = mathNode_in;


            const mathNode__assign      = new math.AssignmentNode(mathNode__symbol, mathNode__value);

            const mathNode              = math.assign_recur(mathNode__tree, mathNode__assign);
            mathNode.mathNode__litexp   = mathNode__tree;
            mathNode.mathNode__assign   = mathNode__assign;

            outMathNode = mathNode;

            return outMathNode;
          }

          const mathNode_initial                 = gmItem__initial.content;
          const mathNode_initial__rhs            = mathNode_initial.params[1];
          const mathNode_initial__rhs__protected = symbolify(mathNode_initial__rhs);

          gmItem__initial.content.params[1] = mathNode_initial__rhs__protected;

          logger.log("gmItem__initial", gmItem__initial);


          const gmItemConfig = {
            initial__display: gmItem__initial,

            initial:          gmItem__initial,
            target :          gmItem__target,

            operators:           arr_gmItem_operator__magic,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__eq__eq8_left__side_magic(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__eq__eq8_left__side_magic();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__eq__eq8_left__side_magic() {
          logger.log("random_challengeGMItemConfig__eq__eq8_left__side_magic");

          const nb_operators = 4;

          const arr_value_1to9  = [...Array(9).keys()].map(index => index + 1);
          const arr_value_2to10 = [...Array(9).keys()].map(index => index + 2);

          const arr_operatorNodeFuncWrapper__add = arr_value_1to9.map(number => {
            const op = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper__subtract = arr_value_1to9.map(number => {
            const op = Operator.fromOpString_binary("-");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper__multiply = arr_value_2to10.map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper__divide = arr_value_2to10.map(number => {
            const op_divide = Operator.fromOpString_binary("/");
            const node_b    = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_divide, node_b);
            return operatorNodeFuncWrapper;
          });


          function createGmItemOperator_magic(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }


          const arr_str__magic = [
            "magic:lhs+",
            "magic:lhs-",
            "magic:lhsx",
            "magic:lhs/",
          ];

          const arr_gmItem_operator__magic = arr_str__magic.map(str_magic => {
            const op_magic__lhs                = Operator.fromString_unary(str_magic);
            const operatorNodeFuncWrapper__lhs = operatorNodeFactoryFuncWrapper_unary(op_magic__lhs);
            const gmItem_operator__lhs         = createGmItemOperator_magic(operatorNodeFuncWrapper__lhs);
            return gmItem_operator__lhs;
          });



          const arr_operatorNodeFuncWrapper = [
            ...arr_operatorNodeFuncWrapper__add,
            ...arr_operatorNodeFuncWrapper__subtract,
            ...arr_operatorNodeFuncWrapper__multiply,
            ...arr_operatorNodeFuncWrapper__divide,
          ];

          function createGmItemOperator_for_initial_trans(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }

          function createGmItemOperator_for_op(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              // outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_equation(outMathNode);

              //simplify lhs, custom simplify rhs
              function custom_apply(mathNode_in, func) {
                var outMathNode;

                const mathNode_lhs_in = mathNode_in.params[0];
                // logger.log("func_decorated, mathNode_lhs_in", mathNode_lhs_in);

                const mathNode_rhs_in = mathNode_in.params[1];
                const mathNode_rhs_in__litexp = mathNode_rhs_in.mathNode__litexp;
                const mathNode_rhs_in__assign = mathNode_rhs_in.mathNode__assign;
                // logger.log("func_decorated, mathNode_rhs_in", mathNode_rhs_in);

                var mathNode_lhs_out = func(mathNode_lhs_in);
                mathNode_lhs_out     = Simplifier.simplify_litexp_2(mathNode_lhs_out);


                var mathNode_rhs_out = func(mathNode_rhs_in__litexp);
                const mathNode__litexp_out = Simplifier.simplify_litexp_2(mathNode_rhs_out);

                mathNode_rhs_out = math.assign_recur(mathNode__litexp_out,mathNode_rhs_in__assign);
                mathNode_rhs_out.mathNode__litexp = mathNode__litexp_out;
                mathNode_rhs_out.mathNode__assign = mathNode_rhs_in__assign;

                outMathNode = new math.RelationalNode(["equal"], [mathNode_lhs_out, mathNode_rhs_out]);
                outMathNode.isEquation = true;

                return outMathNode;
              }

              if(mathNode_in.isEquation) {
                outMathNode = custom_apply(mathNode_in, func);
                logger.log("func_decorated, outMathNode", outMathNode);
              } else {
                outMathNode = func(mathNode_in);
              }

              return outMathNode;
            };
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }

          const arr_gmItem_operator      = arr_operatorNodeFuncWrapper.map(createGmItemOperator_for_op);




          // const mathNode__left   = symbolify(new math.SymbolNode("x"));
          const mathNode__left   = new math.SymbolNode("x");

          const mathNode__right  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);



          const mathNode__target = new math.RelationalNode(["equal"], [mathNode__left, mathNode__right]);
          logger.log("mathNode__target", mathNode__target);
          mathNode__target.isEquation = true;

          const gmItem__target   = GMItem.value(mathNode__target, "target", "");

          function isSameExpression(mathNode1, mathNode2) {
            var outBool;

            logger.log("isSameExpression", mathNode1, mathNode2);

            const arr_shuffled__indexes = [0,1];

            var arr_arr_mathNode__to_compare = Utils.zip(mathNode1.params, mathNode2.params);
            arr_arr_mathNode__to_compare     = Utils.shuffled_mimic(arr_arr_mathNode__to_compare, arr_shuffled__indexes);
            
            logger.log("logEq4", "arr_arr_mathNode__to_compare[0][1]", arr_arr_mathNode__to_compare[0][1]);
            if(arr_arr_mathNode__to_compare[0][1] instanceof math.SymbolNode) {
              outBool = true;
            } else {
              outBool = false;
            }

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;

          const mathNode__display__left  = new math.SymbolNode("x");
          const mathNode__display__right = new math.SymbolNode(" ?");
          gmItem__target.specs.node__display = new math.RelationalNode(["equal"], [mathNode__display__left, mathNode__display__right]);


          const gmItem__initial_seed = gmItem__target.clone();

          // gmItem__initial_seed.content.autoSimplify = true;
          gmItem__initial_seed.content.isEquation   = true;
          logger.log("gmItem__initial_seed.content", gmItem__initial_seed.content);



          /**/
          function create_arr_gmItemOperator_for_initial_trans() {

            const node_b_1to9  = new math.ConstantNode(1 + Math.floor(Math.random() * 9));
            const node_b_2to10 = new math.ConstantNode(2 + Math.floor(Math.random() * 8));

            const op_add      = Operator.fromOpString_binary("+");
            const op_sub      = Operator.fromOpString_binary("-");

            const op_mult     = Operator.fromOpString_binary("x");
            const op_divide   = Operator.fromOpString_binary("/");

            const op_offset = Utils.randomElementInArray([op_add, op_sub])
            const op_scale  = Utils.randomElementInArray([op_mult, op_divide]);

            const arr_op_initial_trans = [
              {
                op:     op_offset,
                node_b: node_b_1to9,
              },
              {
                op:     op_scale,
                node_b: node_b_2to10,
              }
            ];

            return arr_op_initial_trans.map(obj => {
              const operatorNodeFuncWrapper__initial_trans = operatorNodeFactoryFuncWrapper_binary(obj.op, obj.node_b);
              const gmItem_operator__initial_trans = createGmItemOperator_for_initial_trans(operatorNodeFuncWrapper__initial_trans);
              return gmItem_operator__initial_trans;
            });

          }
          /**/

          const arr_gmItem_operator__initial_trans = create_arr_gmItemOperator_for_initial_trans();

          const depth__initial = 2;

          const gmItem_lhs__pre     = GMItem.value(mathNode__left);
          // const gmItem_rhs__pre     = GMItem.value(mathNode__right);

          const gmItem_lhs__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem_lhs__pre, arr_gmItem_operator__initial_trans, depth__initial, false);
          const gmItem_rhs__initial = GMItem.value(new math.ConstantNode(Utils.randomElementInArray([0,1,2,3,4,5,6,7,8,9,10,11,12,20,30,40,50,100])));

          const mathNode__initial = new math.RelationalNode(["equal"], [gmItem_lhs__initial.content, gmItem_rhs__initial.content]);
          const gmItem__initial   = GMItem.value(mathNode__initial);

          function symbolify(mathNode_in) {
            var outMathNode;

            function makeid(length) {
              var result           = '';
              var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
              var charactersLength = characters.length;
              for ( var i = 0; i < length; i++ ) {
                result += characters.charAt(Math.floor(Math.random() * charactersLength));
              }
              return result;
            }

            const str__symbol           = makeid(10);

            const mathNode__symbol      = new math.SymbolNode(str__symbol);
            // const mathNode__right__tree        = new math.OperatorNode("+", "add", [new math.ConstantNode(12), mathNode__right__symbol]);
            const mathNode__tree        = mathNode__symbol;
            const mathNode__value       = mathNode_in;


            const mathNode__assign      = new math.AssignmentNode(mathNode__symbol, mathNode__value);

            const mathNode              = math.assign_recur(mathNode__tree, mathNode__assign);
            mathNode.mathNode__litexp   = mathNode__tree;
            mathNode.mathNode__assign   = mathNode__assign;

            outMathNode = mathNode;

            return outMathNode;
          }

          const mathNode_initial                 = gmItem__initial.content;
          const mathNode_initial__rhs            = mathNode_initial.params[1];
          const mathNode_initial__rhs__protected = symbolify(mathNode_initial__rhs);

          gmItem__initial.content.params[1] = mathNode_initial__rhs__protected;

          logger.log("gmItem__initial", gmItem__initial);


          const gmItemConfig = {
            initial__display: gmItem__initial,

            initial:          gmItem__initial,
            target :          gmItem__target,

            operators:           arr_gmItem_operator__magic,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__eq__eq9_op4(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__eq__eq9_op4();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__eq__eq9_op4() {
          logger.log("random_challengeGMItemConfig__eq__eq9_op4");

          const mathNode__left   = new math.SymbolNode("x");

          // const mathNode__right  = new math.ConstantNode(3);
          const mathNode__right  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);

          const mathNode__target = new math.RelationalNode(["equal"], [mathNode__left, mathNode__right]);
          mathNode__target.isEquation = true;

          const gmItem__target = GMItem.value(mathNode__target, "target", "");

          function isSameExpression(mathNode1, mathNode2) {
            var outBool;

            logger.log("isSameExpression", mathNode1, mathNode2);

            const arr_shuffled__indexes = [0,1];

            var arr_arr_mathNode__to_compare = Utils.zip(mathNode1.params, mathNode2.params);
            arr_arr_mathNode__to_compare     = Utils.shuffled_mimic(arr_arr_mathNode__to_compare, arr_shuffled__indexes);
            
            logger.log("logEq4", "arr_arr_mathNode__to_compare[0][1]", arr_arr_mathNode__to_compare[0][1]);
            if(arr_arr_mathNode__to_compare[0][1] instanceof math.SymbolNode) {
              outBool = true;
            } else {
              outBool = false;
            }

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;

          const mathNode__display__left  = new math.SymbolNode("x");
          const mathNode__display__right = new math.SymbolNode(" ?");
          gmItem__target.specs.node__display = new math.RelationalNode(["equal"], [mathNode__display__left, mathNode__display__right]);


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          const depth__initial    = 4;
          // const depth__initial    = 10;

          const gmItem__initial_seed = gmItem__target.clone();
          gmItem__initial_seed.content.autoSimplify = true;
          gmItem__initial_seed.content.isEquation   = true;

          const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial_seed, arr_gmItem_operator, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;

          logger.log("gmItem__initial", gmItem__initial);

          // const mathNode__initial = new math.ConstantNode(79);
          // const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");



          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_full(outMathNode);
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator__inverse = GMItem.operator(transformationFunc, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial__display: null,

            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator__inverse,
            operators__inverse:  arr_gmItem_operator,
          };

          return gmItemConfig;
        }



        static randomInstance__eq__eq10_magic4(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__eq__eq10_magic4();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__eq__eq10_magic4() {
          logger.log("random_challengeGMItemConfig__eq__eq4_add__side_magic");


          function createGmItemOperator_magic(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }


          const arr_str__magic__lhs = [
            "magic:lhs+",
            "magic:lhs-",
            "magic:lhsx",
            "magic:lhs/",
          ];

          const arr_gmItem_operator__magic__lhs = arr_str__magic__lhs.map(str_magic => {
            const op_magic                 = Operator.fromString_unary(str_magic);
            const operatorNodeFuncWrapper  = operatorNodeFactoryFuncWrapper_unary(op_magic);
            logger.log("logEq4", "operatorNodeFuncWrapper", operatorNodeFuncWrapper);
            const gmItem_operator          = createGmItemOperator_magic(operatorNodeFuncWrapper);
            
            const str__display  = Operator.displayStringForOp(op_magic);
            const node__display = new math.SymbolNode(str__display);
            gmItem_operator.specs.node__display = node__display;
            
            return gmItem_operator;
          });

          const arr_str__magic__rhs = [
            "magic:rhs+",
            "magic:rhs-",
            "magic:rhsx",
            "magic:rhs/",
          ];

          const arr_gmItem_operator__magic__rhs = arr_str__magic__rhs.map(str_magic => {
            const op_magic                 = Operator.fromString_unary(str_magic);
            const operatorNodeFuncWrapper  = operatorNodeFactoryFuncWrapper_unary(op_magic);
            logger.log("logEq4", "operatorNodeFuncWrapper", operatorNodeFuncWrapper);
            const gmItem_operator          = createGmItemOperator_magic(operatorNodeFuncWrapper);
            
            const str__display  = Operator.displayStringForOp(op_magic);
            const node__display = new math.SymbolNode(str__display);
            gmItem_operator.specs.node__display = node__display;
            
            return gmItem_operator;
          });



  



          const arr_shuffled__indexes = Utils.shuffle([0,1]);

          // const mathNode__left   = symbolify(new math.SymbolNode("x"));
          const mathNode__left   = new math.SymbolNode("x");
          const mathNode__right  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
          var arr_mathNode__target  = [mathNode__left, mathNode__right];
          arr_mathNode__target = Utils.shuffled_mimic(arr_mathNode__target, arr_shuffled__indexes);

          const mathNode__display__left  = new math.SymbolNode("x");
          const mathNode__display__right = new math.SymbolNode(" ?");
          var arr_mathNode__display = [mathNode__display__left, mathNode__display__right];
          arr_mathNode__display = Utils.shuffled_mimic(arr_mathNode__display, arr_shuffled__indexes);


          const mathNode__target = new math.RelationalNode(["equal"], arr_mathNode__target);
          logger.log("mathNode__target", mathNode__target);
          mathNode__target.isEquation = true;


          const gmItem__target   = GMItem.value(mathNode__target, "target", "");

          function isSameExpression(mathNode1, mathNode2) {
            var outBool;

            logger.log("isSameExpression", mathNode1, mathNode2);

            var arr_arr_mathNode__to_compare = Utils.zip(mathNode1.params, mathNode2.params);
            arr_arr_mathNode__to_compare     = Utils.shuffled_mimic(arr_arr_mathNode__to_compare, arr_shuffled__indexes);
            
            // const arr_mathNode__to_compare = arr_arr_mathNode__to_compare[1].map(mathNode => {
            //   return new math.ConstantNode(math.bignumber(mathNode.evaluate()));
            // });
            // logger.log("logEq4", "arr_mathNode__to_compare:", arr_mathNode__to_compare.toString());
            // const mathNode_equal = new math.RelationalNode(["equal"], arr_mathNode__to_compare);
            // outBool = mathNode_equal.evaluate({});

            logger.log("logEq4", "arr_arr_mathNode__to_compare[0][1]", arr_arr_mathNode__to_compare[0][1]);
            if(arr_arr_mathNode__to_compare[0][1] instanceof math.SymbolNode) {
              outBool = true;
            } else {
              outBool = false;
            }

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          gmItem__target.specs.node__display = new math.RelationalNode(["equal"], arr_mathNode__display);


          const gmItem__initial_seed = gmItem__target.clone();

          // gmItem__initial_seed.content.autoSimplify = true;
          gmItem__initial_seed.content.isEquation   = true;
          logger.log("gmItem__initial_seed.content", gmItem__initial_seed.content);


          function createGmItemOperator_for_initial_trans(operatorNodeFuncWrapper) {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_equation(outMathNode);
              logger.log("func_decorated, outMathNode", outMathNode);


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = true;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = true;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;

          }


          /**/
          function generateRandom_gmItemOperator_for_initial_trans() {
            const number = 1 + Math.floor(Math.random() * 9);
            const node_b = new math.ConstantNode(number);

            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");
            const op_multiply = Operator.fromOpString_binary("x");
            const op_divide   = Operator.fromOpString_binary("/");
            const op_initial_trans = Utils.randomElementInArray([op_add, op_subtract, op_multiply, op_divide]);

            const operatorNodeFuncWrapper__initial_trans = operatorNodeFactoryFuncWrapper_binary(op_initial_trans, node_b);

            const gmItem_operator__initial_trans = createGmItemOperator_for_initial_trans(operatorNodeFuncWrapper__initial_trans);
            return gmItem_operator__initial_trans;
          }
          /**/

          const arr_gmItem_operator__initial_trans = [...Array(10).keys()].map(generateRandom_gmItemOperator_for_initial_trans);

          const depth__initial = 3;

          const gmItem_lhs__pre     = GMItem.value(mathNode__left);
          const gmItem_rhs__pre     = GMItem.value(mathNode__right);

          const gmItem_lhs__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem_lhs__pre, arr_gmItem_operator__initial_trans, depth__initial, false);
          const gmItem_rhs__initial = GMMaker.createGMItemTarget__x_to_expr(gmItem_rhs__pre, arr_gmItem_operator__initial_trans, depth__initial, true);




          function symbolify(mathNode_in) {
            var outMathNode;

            function makeid(length) {
              var result           = '';
              var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
              var charactersLength = characters.length;
              for ( var i = 0; i < length; i++ ) {
                result += characters.charAt(Math.floor(Math.random() * charactersLength));
              }
              return result;
            }

            const str__symbol           = makeid(10);

            const mathNode__symbol      = new math.SymbolNode(str__symbol);
            // const mathNode__right__tree        = new math.OperatorNode("+", "add", [new math.ConstantNode(12), mathNode__right__symbol]);
            const mathNode__tree        = mathNode__symbol;
            const mathNode__value       = mathNode_in;


            const mathNode__assign      = new math.AssignmentNode(mathNode__symbol, mathNode__value);

            const mathNode              = math.assign_recur(mathNode__tree, mathNode__assign);
            mathNode.mathNode__litexp   = mathNode__tree;
            mathNode.mathNode__assign   = mathNode__assign;

            outMathNode = mathNode;

            return outMathNode;
          }



          var arr_mathNode__initial = [gmItem_lhs__initial.content, gmItem_rhs__initial.content];
          arr_mathNode__initial = Utils.shuffled_mimic(arr_mathNode__initial, arr_shuffled__indexes);


          const mathNode__initial = new math.RelationalNode(["equal"], arr_mathNode__initial);
          const gmItem__initial   = GMItem.value(mathNode__initial);

          const mathNode_initial                 = gmItem__initial.content;
          const mathNode_initial__rhs            = mathNode_initial.params[1];
          const mathNode_initial__rhs__protected = symbolify(mathNode_initial__rhs);

          gmItem__initial.content.params[1] = mathNode_initial__rhs__protected;

          logger.log("gmItem__initial", gmItem__initial);


          const gmItemConfig = {
            initial__display: gmItem__initial,

            initial:          gmItem__initial,
            target :          gmItem__target,

            operators:           arr_gmItem_operator__magic__lhs,
            operators__inverse:  arr_gmItem_operator__magic__rhs,
          };

          return gmItemConfig;
        }



        static randomInstance__cs__cs1_array_index_assignment__visual(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__cs__cs1_array_index_assignment__visual();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__cs__cs1_array_index_assignment__visual() {
          logger.log("random_challengeGMItemConfig__cs__cs1_array_index_assignment__visual");

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +0,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const node__symbol = new math.SymbolNode("x");
            // logger.log("log1", "node__symbol", node__symbol);
            var node__expr   = func(node__symbol);
            node__expr = Simplifier.simplify_litexp_2(node__expr);
            // const node__expr   = new math.OperatorNode(op_add.op, op_add.name, [node__symbol, operatorNodeFuncWrapper.semantics.node_b]);
            // const displayNode  = new math.FunctionAssignmentNode("f", [node__symbol.name], node__expr);
            const node__display  = new MyFunctionAssignmentNode("f", [node__symbol.name], node__expr);
            operatorNodeFuncWrapper.display = {
              node__display: node__display,
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 2;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const node__symbol = new math.SymbolNode("x");
            // logger.log("log1", "node__symbol", node__symbol);
            var node__expr   = func(node__symbol);
            node__expr = Simplifier.simplify_litexp_2(node__expr);
            // const node__expr   = new math.OperatorNode(op_add.op, op_add.name, [node__symbol, operatorNodeFuncWrapper.semantics.node_b]);
            // const displayNode  = new math.FunctionAssignmentNode("f", [node__symbol.name], node__expr);
            const node__display  = new MyFunctionAssignmentNode("f", [node__symbol.name], node__expr);
            operatorNodeFuncWrapper.display = {
              node__display: node__display,
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult];

          const arr_gmItem_operator_for_target = arr_gmItem_operator;


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 1;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          const mathNode__initial = new math.ConstantNode(10);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }



        static randomInstance__funcs__f1_function_operators(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__funcs__f1_function_operators();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__funcs__f1_function_operators() {
          logger.log("random_challengeGMItemConfig__funcs__f1_function_operators");

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +0,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const node__symbol = new math.SymbolNode("x");
            // logger.log("log1", "node__symbol", node__symbol);
            var node__expr   = func(node__symbol);
            node__expr = Simplifier.simplify_litexp_2(node__expr);
            // const node__expr   = new math.OperatorNode(op_add.op, op_add.name, [node__symbol, operatorNodeFuncWrapper.semantics.node_b]);
            // const displayNode  = new math.FunctionAssignmentNode("f", [node__symbol.name], node__expr);
            const node__display  = new MyFunctionAssignmentNode("f", [node__symbol.name], node__expr);
            operatorNodeFuncWrapper.display = {
              node__display: node__display,
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 2;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              // op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              // outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const node__symbol = new math.SymbolNode("x");
            // logger.log("log1", "node__symbol", node__symbol);
            var node__expr   = func(node__symbol);
            node__expr = Simplifier.simplify_litexp_2(node__expr);
            // const node__expr   = new math.OperatorNode(op_add.op, op_add.name, [node__symbol, operatorNodeFuncWrapper.semantics.node_b]);
            // const displayNode  = new math.FunctionAssignmentNode("f", [node__symbol.name], node__expr);
            const node__display  = new MyFunctionAssignmentNode("f", [node__symbol.name], node__expr);
            operatorNodeFuncWrapper.display = {
              node__display: node__display,
            };

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult];

          const arr_gmItem_operator_for_target = arr_gmItem_operator;


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 1;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          const mathNode__initial = new math.ConstantNode(10);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }



        static randomInstance__funcs__f2_function_operators_2(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__funcs__f2_function_operators_2();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__funcs__f2_function_operators_2() {
          logger.log("random_challengeGMItemConfig__funcs__f2_function_operators_2");

          const nb_operators = 4;

          const arr_gmItem_operator__function = [...new Array(nb_operators).keys()].map(index => {

            function createAnonFunctionObjectNode() {

              const mathNode__symbol = Utils.randomElementInArray([
                new math.SymbolNode("x"),
                new math.SymbolNode("y"),
                new math.SymbolNode("t"),
                new math.SymbolNode("a"),
                new math.SymbolNode("u"),
              ]);

              const mathNode__arr_bound_var = new math.ArrayNode([mathNode__symbol]);

              const a = random_constantNode({min: 0, max: 10, step: 1});
              const b = random_constantNode({min: 0, max: 10, step: 1});

              const str__symbol   = mathNode__symbol.name;

              const str__expr_raw       = "" + a + "*" + str__symbol + "+" + b;
              const str__expr__refined  = Algebrite.run(str__expr_raw);

              var mathNode__expr = math.parse(str__expr__refined);

              //SHU: "3+2a" -> "2a+3" (y'a de la discrimination dans les symboles)
              //x, y et t sont privilégiés par rapport aux autres symboles
              const mathNode__expr__no_discr = Rewriter.rewriteSumWithSymbolsFirst(mathNode__expr);
              logger.log("logExpr", "mathNode__expr__no_discr:", mathNode__expr__no_discr.toString());

              mathNode__expr = mathNode__expr__no_discr;

              const mathNode__anonFunction = new math.ObjectNode({
                type: new math.SymbolNode("anonFunction"),

                mathNode__arr_bound_var: mathNode__arr_bound_var,
                expr:          mathNode__expr,
              });

              return mathNode__anonFunction;
            }

            function createFunc(mathNode__anonFunction) {
  
              function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                var outMathNode;
      
                switch(objectNode__anonFunction.properties.type.name) {
                  case "anonFunction":
                    {
                      const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                      const mathNode__expr          = objectNode__anonFunction.properties["expr"];

                      // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                      // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);

                      var nb__var_in = arrayNode__operand.items.length;

                      const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                        const name = x.name;
                        // acc[name]  = arrayNode__operand.items[index];
                        acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                        return acc;
                      }, {});
                      logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);


                      //substitute as many bound vars as possible
                      outMathNode = mathNode__expr.transform(function (node, path, parent) {
                        var outNode2; 
            
                        var node__subst;
                        if (node.isSymbolNode && (node.name in dict__betaRed)) {
                          node__subst = dict__betaRed[node.name];
                          if(node__subst != null) {
                            outNode2 = node__subst.cloneDeep();
                          } else {
                            outNode2 = node;
                          }
                        }
                        else {
                          outNode2 = node;
                        }
                        logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
            
                        return outNode2;
                      });
                    }
                    break;
                  default:
                    {
                      throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                      outMathNode = arrayNode__operand;
                    }
                    break;
                }
      
                return outMathNode;
              }
  
  
              const func = function(mathNode__in) {
                var outMathNode;

                var arrayNode__in;
                if(mathNode__in instanceof math.ArrayNode) {
                  arrayNode__in = mathNode__in;
                } else {
                  arrayNode__in = new math.ArrayNode([mathNode__in]);
                }
                const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                logger.log("logAnon", "mathNode__new:", mathNode__new);
                logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());

                outMathNode = mathNode__new;
                
                // try {
                //   const value = mathNode__new.evaluate();
                //   const mathNode__new__evaluated = new math.ConstantNode(value);
                // } catch(e) {
                //   logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                // }

                const autoSimplify = mathNode__in.autoSimplify;
                if(autoSimplify) {
                  outMathNode = math.simplify(outMathNode);
                  outMathNode.autoSimplify = autoSimplify;
                }

                return outMathNode;
              };

              return func;
            }

            const mathNode__anonFunction  = createAnonFunctionObjectNode();
            const func                    = createFunc(mathNode__anonFunction);

            const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
            const mathNode__expr  = mathNode__anonFunction.properties["expr"];
            const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);

            const specs = {
              funcWrapper: {
                func: func,
                display:{
                  node__display: node__display,
                }
              },
              quickFix__smallerFacades : true,
            };

            function func_decorated(mathNode__in) {
              return func(mathNode__in);
            }

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__function];

          const arr_gmItem_operator_for_target = arr_gmItem_operator;


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 1;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          const mathNode__initial = random_constantNode({min: -1, max: 10, step: 1});
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__funcs__f2c_function_operators_3(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__funcs__f2c_function_operators_3();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__funcs__f2c_function_operators_3() {
          logger.log("random_challengeGMItemConfig__funcs__f2c_function_operators_3");

          const nb_operators = 4;

          const arr_gmItem_operator__function = [...new Array(nb_operators).keys()].map(index => {

            function createAnonFunctionObjectNode() {

              const mathNode__symbol = Utils.randomElementInArray([
                new math.SymbolNode("x"),
                new math.SymbolNode("y"),
                new math.SymbolNode("t"),
                new math.SymbolNode("a"),
                new math.SymbolNode("u"),
              ]);

              const mathNode__arr_bound_var = new math.ArrayNode([mathNode__symbol]);

              const a = random_constantNode({min: 0, max: 10, step: 1});
              const b = random_constantNode({min: 0, max: 10, step: 1});

              const str__symbol   = mathNode__symbol.name;

              const str__expr_raw       = "" + a + "*" + str__symbol + "+" + b;
              const str__expr__refined  = Algebrite.run(str__expr_raw);

              var mathNode__expr = math.parse(str__expr__refined);

              //SHU: "3+2a" -> "2a+3" (y'a de la discrimination dans les symboles)
              //x, y et t sont privilégiés par rapport aux autres symboles
              const mathNode__expr__no_discr = Rewriter.rewriteSumWithSymbolsFirst(mathNode__expr);
              logger.log("logExpr", "mathNode__expr__no_discr:", mathNode__expr__no_discr.toString());

              mathNode__expr = mathNode__expr__no_discr;

              const mathNode__anonFunction = new math.ObjectNode({
                type: new math.SymbolNode("anonFunction"),

                mathNode__arr_bound_var: mathNode__arr_bound_var,
                expr:          mathNode__expr,
              });

              return mathNode__anonFunction;
            }

            function createFunc(mathNode__anonFunction) {

              function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                var outMathNode;

                switch(objectNode__anonFunction.properties.type.name) {
                  case "anonFunction":
                    {
                      const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                      const mathNode__expr          = objectNode__anonFunction.properties["expr"];

                      // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                      // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);

                      var nb__var_in = arrayNode__operand.items.length;

                      const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                        const name = x.name;
                        // acc[name]  = arrayNode__operand.items[index];
                        acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                        return acc;
                      }, {});
                      logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);


                      //substitute as many bound vars as possible
                      outMathNode = mathNode__expr.transform(function (node, path, parent) {
                        var outNode2; 
            
                        var node__subst;
                        if (node.isSymbolNode && (node.name in dict__betaRed)) {
                          node__subst = dict__betaRed[node.name];
                          if(node__subst != null) {
                            outNode2 = node__subst.cloneDeep();
                          } else {
                            outNode2 = node;
                          }
                        }
                        else {
                          outNode2 = node;
                        }
                        logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
            
                        return outNode2;
                      });
                    }
                    break;
                  default:
                    {
                      throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                      outMathNode = arrayNode__operand;
                    }
                    break;
                }

                return outMathNode;
              }


              const func = function(mathNode__in) {
                var outMathNode;

                var arrayNode__in;
                if(mathNode__in instanceof math.ArrayNode) {
                  arrayNode__in = mathNode__in;
                } else {
                  arrayNode__in = new math.ArrayNode([mathNode__in]);
                }
                const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                logger.log("logAnon", "mathNode__new:", mathNode__new);
                logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());

                outMathNode = mathNode__new;
                
                // try {
                //   const value = mathNode__new.evaluate();
                //   const mathNode__new__evaluated = new math.ConstantNode(value);
                // } catch(e) {
                //   logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                // }

                const autoSimplify = mathNode__in.autoSimplify;
                if(autoSimplify) {
                  outMathNode = math.simplify(outMathNode);
                  outMathNode.autoSimplify = autoSimplify;
                }

                return outMathNode;
              };

              return func;
            }

            const mathNode__anonFunction  = createAnonFunctionObjectNode();
            const func                    = createFunc(mathNode__anonFunction);

            const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
            const mathNode__expr  = mathNode__anonFunction.properties["expr"];
            const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);

            const specs = {
              funcWrapper: {
                func: func,
                display:{
                  node__display: node__display,
                }
              },
              quickFix__smallerFacades : true,
            };

            function func_decorated(mathNode__in) {
              return func(mathNode__in);
            }

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__function];

          const arr_gmItem_operator_for_target = arr_gmItem_operator;


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 1;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          const mathNode__initial = random_constantNode({min: -1, max: 10, step: 1});
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }



        static randomInstance__funcs__f3a_function_composition_0(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__funcs__f3a_function_composition_0();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__funcs__f3a_function_composition_0() {
          logger.log("random_challengeGMItemConfig__funcs__f3a_function_composition_0");

          const nb_operators__mult = 4;

          const arr_value_a = MathUtils.randomCartArrFromArr([2,3,4,5,6,7,8,9,10], nb_operators__mult, nb_operators__mult, nb_operators__mult, false);

          const arr_gmItem_operator__function__mult = arr_value_a.map((value_a, index) => {

            function createAnonFunctionObjectNode() {

              const mathNode__symbol = Utils.randomElementInArray([
                new math.SymbolNode("x"),
              ]);

              const mathNode__arr_bound_var = new math.ArrayNode([mathNode__symbol]);

              const a = random_constantNode({min: 2, max: 10, step: 1});

              const str__symbol = mathNode__symbol.name;
              const str__expr_raw      = "" + value_a + "*" + str__symbol;
              const str__expr__refined = Algebrite.run(str__expr_raw);
              var mathNode__expr = math.parse(str__expr__refined);

              const mathNode__expr__no_discr = Rewriter.rewriteSumWithSymbolsFirst(mathNode__expr);
              mathNode__expr = mathNode__expr__no_discr;

              const mathNode__anonFunction = new math.ObjectNode({
                type: new math.SymbolNode("anonFunction"),

                mathNode__arr_bound_var: mathNode__arr_bound_var,
                expr:          mathNode__expr,
              });

              return mathNode__anonFunction;
            }

            function createFunc(mathNode__anonFunction) {

              function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                var outMathNode;

                switch(objectNode__anonFunction.properties.type.name) {
                  case "anonFunction":
                    {
                      const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                      const mathNode__expr          = objectNode__anonFunction.properties["expr"];

                      // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                      // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);

                      var nb__var_in = arrayNode__operand.items.length;

                      const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                        const name = x.name;
                        // acc[name]  = arrayNode__operand.items[index];
                        acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                        return acc;
                      }, {});
                      logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);


                      //substitute as many bound vars as possible
                      outMathNode = mathNode__expr.transform(function (node, path, parent) {
                        var outNode2; 
            
                        var node__subst;
                        if (node.isSymbolNode && (node.name in dict__betaRed)) {
                          node__subst = dict__betaRed[node.name];
                          if(node__subst != null) {
                            outNode2 = node__subst.cloneDeep();
                          } else {
                            outNode2 = node;
                          }
                        }
                        else {
                          outNode2 = node;
                        }
                        logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
            
                        return outNode2;
                      });
                    }
                    break;
                  default:
                    {
                      throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                      outMathNode = arrayNode__operand;
                    }
                    break;
                }

                return outMathNode;
              }


              const func = function(mathNode__in) {
                var outMathNode;

                var arrayNode__in;
                if(mathNode__in instanceof math.ArrayNode) {
                  arrayNode__in = mathNode__in;
                } else {
                  arrayNode__in = new math.ArrayNode([mathNode__in]);
                }
                const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                logger.log("logAnon", "mathNode__new:", mathNode__new);
                logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());

                outMathNode = mathNode__new;
                
                // try {
                //   const value = mathNode__new.evaluate();
                //   const mathNode__new__evaluated = new math.ConstantNode(value);
                // } catch(e) {
                //   logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                // }

                const autoSimplify = mathNode__in.autoSimplify;
                if(autoSimplify) {
                  outMathNode = math.simplify(outMathNode);
                  outMathNode.autoSimplify = autoSimplify;
                }

                return outMathNode;
              };

              return func;
            }

            const mathNode__anonFunction  = createAnonFunctionObjectNode();
            const func                    = createFunc(mathNode__anonFunction);

            const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
            const mathNode__expr  = mathNode__anonFunction.properties["expr"];
            const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);

            const specs = {
              funcWrapper: {
                func: func,
                display:{
                  node__display: node__display,
                }
              },
              quickFix__smallerFacades : true,
              arr_order__edu: [0,1],
            };

            function func_decorated(mathNode__in) {
              return func(mathNode__in);
            }

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });
          // logger.log("logF3", "arr_gmItem_operator__function__bound:", arr_gmItem_operator__function__bound);


          

          const nb_operators__add = 4;

          const arr_value_b = MathUtils.randomCartArrFromArr([1,2,3,4,5,6,7,8,9,10], nb_operators__add, nb_operators__add, nb_operators__add, false);
          logger.log("logRandom", "arr_value_b:", arr_value_b);

          const arr_gmItem_operator__function__add = arr_value_b.map((value_b, index) => {

            function createAnonFunctionObjectNode() {

              const arr_mathNode__symbol = [
                new math.SymbolNode("x"),
              ];

              const mathNode__symbol__in = arr_mathNode__symbol[0];

              const mathNode__arr_bound_var = new math.ArrayNode([mathNode__symbol__in]);

              // const b = random_constantNode({min: 1, max: 10, step: 1});

              const str__expr_raw      = mathNode__symbol__in.name + "+" + value_b;
              const str__expr__refined = Algebrite.run(str__expr_raw);
              var mathNode__expr = math.parse(str__expr__refined);

              const mathNode__expr__no_discr = Rewriter.rewriteSumWithSymbolsFirst(mathNode__expr);
              mathNode__expr = mathNode__expr__no_discr;

              const mathNode__anonFunction = new math.ObjectNode({
                type: new math.SymbolNode("anonFunction"),

                mathNode__arr_bound_var: mathNode__arr_bound_var,
                expr:          mathNode__expr,
              });

              return mathNode__anonFunction;
            }

            function createFunc(mathNode__anonFunction) {

              function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                var outMathNode;

                switch(objectNode__anonFunction.properties.type.name) {
                  case "anonFunction":
                    {
                      const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                      const mathNode__expr          = objectNode__anonFunction.properties["expr"];

                      // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                      // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);

                      var nb__var_in = arrayNode__operand.items.length;

                      const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                        const name = x.name;
                        // acc[name]  = arrayNode__operand.items[index];
                        acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                        return acc;
                      }, {});
                      logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);


                      //substitute as many bound vars as possible
                      outMathNode = mathNode__expr.transform(function (node, path, parent) {
                        var outNode2; 
            
                        var node__subst;
                        if (node.isSymbolNode && (node.name in dict__betaRed)) {
                          node__subst = dict__betaRed[node.name];
                          if(node__subst != null) {
                            outNode2 = node__subst.cloneDeep();
                          } else {
                            outNode2 = node;
                          }
                        }
                        else {
                          outNode2 = node;
                        }
                        logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
            
                        return outNode2;
                      });
                    }
                    break;
                  default:
                    {
                      throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                      outMathNode = arrayNode__operand;
                    }
                    break;
                }

                return outMathNode;
              }


              const func = function(mathNode__in) {
                var outMathNode;

                var arrayNode__in;
                if(mathNode__in instanceof math.ArrayNode) {
                  arrayNode__in = mathNode__in;
                } else {
                  arrayNode__in = new math.ArrayNode([mathNode__in]);
                }
                const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                logger.log("logAnon", "mathNode__new:", mathNode__new);
                logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());

                outMathNode = mathNode__new;
                
                // try {
                //   const value = mathNode__new.evaluate();
                //   const mathNode__new__evaluated = new math.ConstantNode(value);
                // } catch(e) {
                //   logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                // }

                const autoSimplify = mathNode__in.autoSimplify;
                if(autoSimplify) {
                  outMathNode = math.simplify(outMathNode);
                  outMathNode.autoSimplify = autoSimplify;
                }

                return outMathNode;
              };

              return func;
            }

            const mathNode__anonFunction  = createAnonFunctionObjectNode();
            const func                    = createFunc(mathNode__anonFunction);

            const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
            const mathNode__expr  = mathNode__anonFunction.properties["expr"];
            const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);

            const specs = {
              funcWrapper: {
                func: func,
                display:{
                  node__display: node__display,
                }
              },
              quickFix__smallerFacades : true,
              arr_order__edu: [0],
            };

            function func_decorated(mathNode__in) {
              return func(mathNode__in);
            }

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator            = Utils.shuffled([...arr_gmItem_operator__function__mult, ...arr_gmItem_operator__function__add]);

          const arr_gmItem_operator_for_target = arr_gmItem_operator;


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 2;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = new math.ConstantNode(10);
          const mathNode__initial = Utils.randomElementInArray([
            new math.SymbolNode("x"),
            new math.SymbolNode("y"),
            new math.ConstantNode(-1),
            new math.ConstantNode(1),
            new math.ConstantNode(2),
            new math.ConstantNode(5),
            new math.ConstantNode(10),
          ]);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const arr_gmItem_operator_1 = arr_gmItem_operator.slice(0,4);
          const arr_gmItem_operator_2 = arr_gmItem_operator.slice(4,8);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator__function__mult,
            operators__inverse:  arr_gmItem_operator__function__add,
          };

          return gmItemConfig;
        }




        static randomInstance__funcs__f3_function_composition(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__funcs__f3_function_composition();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__funcs__f3_function_composition() {
          logger.log("random_challengeGMItemConfig__funcs__f3_function_composition");

          const nb_operators = 4;

          const arr_gmItem_operator__function = [...new Array(nb_operators).keys()].map(index => {

            function createAnonFunctionObjectNode() {

              const mathNode__symbol = Utils.randomElementInArray([
                new math.SymbolNode("x"),
              ]);

              const mathNode__arr_bound_var = new math.ArrayNode([mathNode__symbol]);

              const a = random_constantNode({min: 0, max: 5, step: 1});
              const b = random_constantNode({min: 0, max: 5, step: 1});

              const str__symbol = mathNode__symbol.name;

              var str__expr_raw = "" + a + "*" + str__symbol + "+" + b;
              var mathNode__expr;
              if( (a.value == 0) && (math.pickRandom([0,1]) == 1) ) {
                //sometimes, display "0x + b" for students to get that "x↦0x + b" acts the same as "x↦b"
                mathNode__expr = math.parse(str__expr_raw);
              } else {
                const str__expr__refined  = Algebrite.run(str__expr_raw);
                mathNode__expr = math.parse(str__expr__refined);
              }

              const mathNode__expr__no_discr = Rewriter.rewriteSumWithSymbolsFirst(mathNode__expr);
              mathNode__expr = mathNode__expr__no_discr;

              const mathNode__anonFunction = new math.ObjectNode({
                type: new math.SymbolNode("anonFunction"),

                mathNode__arr_bound_var: mathNode__arr_bound_var,
                expr:          mathNode__expr,
              });

              return mathNode__anonFunction;
            }

            function createFunc(mathNode__anonFunction) {
  
              function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                var outMathNode;
      
                switch(objectNode__anonFunction.properties.type.name) {
                  case "anonFunction":
                    {
                      const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                      const mathNode__expr          = objectNode__anonFunction.properties["expr"];

                      // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                      // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);

                      var nb__var_in = arrayNode__operand.items.length;

                      const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                        const name = x.name;
                        // acc[name]  = arrayNode__operand.items[index];
                        acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                        return acc;
                      }, {});
                      logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);


                      //substitute as many bound vars as possible
                      outMathNode = mathNode__expr.transform(function (node, path, parent) {
                        var outNode2; 
            
                        var node__subst;
                        if (node.isSymbolNode && (node.name in dict__betaRed)) {
                          node__subst = dict__betaRed[node.name];
                          if(node__subst != null) {
                            outNode2 = node__subst.cloneDeep();
                          } else {
                            outNode2 = node;
                          }
                        }
                        else {
                          outNode2 = node;
                        }
                        logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
            
                        return outNode2;
                      });
                    }
                    break;
                  default:
                    {
                      throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                      outMathNode = arrayNode__operand;
                    }
                    break;
                }
      
                return outMathNode;
              }
  
  
              const func = function(mathNode__in) {
                var outMathNode;

                var arrayNode__in;
                if(mathNode__in instanceof math.ArrayNode) {
                  arrayNode__in = mathNode__in;
                } else {
                  arrayNode__in = new math.ArrayNode([mathNode__in]);
                }
                const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                logger.log("logAnon", "mathNode__new:", mathNode__new);
                logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());

                outMathNode = mathNode__new;
                
                // try {
                //   const value = mathNode__new.evaluate();
                //   const mathNode__new__evaluated = new math.ConstantNode(value);
                // } catch(e) {
                //   logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                // }

                const autoSimplify = mathNode__in.autoSimplify;
                if(autoSimplify) {
                  outMathNode = math.simplify(outMathNode);
                  outMathNode.autoSimplify = autoSimplify;
                }

                return outMathNode;
              };

              return func;
            }

            const mathNode__anonFunction  = createAnonFunctionObjectNode();
            const func                    = createFunc(mathNode__anonFunction);

            const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
            const mathNode__expr  = mathNode__anonFunction.properties["expr"];
            const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);

            const specs = {
              funcWrapper: {
                func: func,
                display:{
                  node__display: node__display,
                }
              },
              quickFix__smallerFacades : true,
            };

            function func_decorated(mathNode__in) {
              return func(mathNode__in);
            }

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });
          logger.log("logF3", "arr_gmItem_operator__function:", arr_gmItem_operator__function);

          const arr_gmItem_operator            = [...arr_gmItem_operator__function];

          const arr_gmItem_operator_for_target = arr_gmItem_operator;


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 2;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = new math.ConstantNode(10);
          const mathNode__initial = Utils.randomElementInArray([
            new math.SymbolNode("x"),
            new math.ConstantNode(0),
            new math.ConstantNode(1),
            new math.ConstantNode(5),
          ]);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__funcs__f4_function_composition(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__funcs__f4_function_composition();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__funcs__f4_function_composition() {
          logger.log("random_challengeGMItemConfig__funcs__f4_function_composition");

          const nb_operators = 4;

          const arr_gmItem_operator__function = [...new Array(nb_operators).keys()].map(index => {

            function createAnonFunctionObjectNode() {

              const mathNode__symbol = Utils.randomElementInArray([
                new math.SymbolNode("x"),
                new math.SymbolNode("y"),
                new math.SymbolNode("t"),
                new math.SymbolNode("a"),
                new math.SymbolNode("u"),
              ]);

              const mathNode__arr_bound_var = new math.ArrayNode([mathNode__symbol]);

              const a = random_constantNode({min: 0, max: 10, step: 1});
              const b = random_constantNode({min: 0, max: 10, step: 1});

              const str__symbol = mathNode__symbol.name;
              const str__expr_raw      = "" + a + "*" + str__symbol + "+" + b;
              const str__expr__refined = Algebrite.run(str__expr_raw);
              var mathNode__expr = math.parse(str__expr__refined);

              const mathNode__expr__no_discr = Rewriter.rewriteSumWithSymbolsFirst(mathNode__expr);
              mathNode__expr = mathNode__expr__no_discr;

              const mathNode__anonFunction = new math.ObjectNode({
                type: new math.SymbolNode("anonFunction"),

                mathNode__arr_bound_var: mathNode__arr_bound_var,
                expr:          mathNode__expr,
              });

              return mathNode__anonFunction;
            }

            function createFunc(mathNode__anonFunction) {
  
              function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                var outMathNode;
      
                switch(objectNode__anonFunction.properties.type.name) {
                  case "anonFunction":
                    {
                      const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                      const mathNode__expr          = objectNode__anonFunction.properties["expr"];

                      // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                      // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);

                      var nb__var_in = arrayNode__operand.items.length;

                      const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                        const name = x.name;
                        // acc[name]  = arrayNode__operand.items[index];
                        acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                        return acc;
                      }, {});
                      logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);


                      //substitute as many bound vars as possible
                      outMathNode = mathNode__expr.transform(function (node, path, parent) {
                        var outNode2; 
            
                        var node__subst;
                        if (node.isSymbolNode && (node.name in dict__betaRed)) {
                          node__subst = dict__betaRed[node.name];
                          if(node__subst != null) {
                            outNode2 = node__subst.cloneDeep();
                          } else {
                            outNode2 = node;
                          }
                        }
                        else {
                          outNode2 = node;
                        }
                        logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
            
                        return outNode2;
                      });
                    }
                    break;
                  default:
                    {
                      throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                      outMathNode = arrayNode__operand;
                    }
                    break;
                }
      
                return outMathNode;
              }
  
  
              const func = function(mathNode__in) {
                var outMathNode;

                var arrayNode__in;
                if(mathNode__in instanceof math.ArrayNode) {
                  arrayNode__in = mathNode__in;
                } else {
                  arrayNode__in = new math.ArrayNode([mathNode__in]);
                }
                const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                logger.log("logAnon", "mathNode__new:", mathNode__new);
                logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());

                outMathNode = mathNode__new;
                
                // try {
                //   const value = mathNode__new.evaluate();
                //   const mathNode__new__evaluated = new math.ConstantNode(value);
                // } catch(e) {
                //   logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                // }

                const autoSimplify = mathNode__in.autoSimplify;
                if(autoSimplify) {
                  outMathNode = math.simplify(outMathNode);
                  outMathNode.autoSimplify = autoSimplify;
                }

                return outMathNode;
              };

              return func;
            }

            const mathNode__anonFunction  = createAnonFunctionObjectNode();
            const func                    = createFunc(mathNode__anonFunction);

            const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
            const mathNode__expr  = mathNode__anonFunction.properties["expr"];
            const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);

            const specs = {
              funcWrapper: {
                func: func,
                display:{
                  node__display: node__display,
                }
              },
              quickFix__smallerFacades : true,
            };

            function func_decorated(mathNode__in) {
              return func(mathNode__in);
            }

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });
          logger.log("logF3", "arr_gmItem_operator__function:", arr_gmItem_operator__function);

          const arr_gmItem_operator            = [...arr_gmItem_operator__function];

          const arr_gmItem_operator_for_target = arr_gmItem_operator;


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 2;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = new math.ConstantNode(10);
          const mathNode__initial = Utils.randomElementInArray([
            new math.SymbolNode("x"),
            new math.SymbolNode("y"),
            new math.ConstantNode(0),
            new math.ConstantNode(1),
            new math.ConstantNode(2),
            new math.ConstantNode(5),
            new math.ConstantNode(10),
          ]);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }



        static randomInstance__funcs__f4z_function_composition_expr(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__funcs__f4z_function_composition_expr();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__funcs__f4z_function_composition_expr() {
          logger.log("random_challengeGMItemConfig__funcs__f4z_function_composition_expr");

          function createArr_gmItem_operator__function(str__op_symbol, arr_value_b, nb_operators) {

            const arr_gmItem_operator__function = arr_value_b.map((value_b, index) => {

              function createAnonFunctionObjectNode() {
  
                const arr_mathNode__symbol = [
                  new math.SymbolNode("x"),
                ];
  
                const mathNode__symbol__in = arr_mathNode__symbol[0];
  
                const mathNode__arr_bound_var = new math.ArrayNode([mathNode__symbol__in]);
  
                // const b = random_constantNode({min: 1, max: 10, step: 1});
  
                const str__expr_raw      = mathNode__symbol__in.name + str__op_symbol + value_b;
                const str__expr__refined = Algebrite.run(str__expr_raw);
                var mathNode__expr = math.parse(str__expr__refined);
  
                const mathNode__expr__no_discr = Rewriter.rewriteSumWithSymbolsFirst(mathNode__expr);
                mathNode__expr = mathNode__expr__no_discr;
  
                const mathNode__anonFunction = new math.ObjectNode({
                  type: new math.SymbolNode("anonFunction"),
  
                  mathNode__arr_bound_var: mathNode__arr_bound_var,
                  expr:          mathNode__expr,
                });
  
                return mathNode__anonFunction;
              }
  
              function createFunc(mathNode__anonFunction) {
  
                function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                  var outMathNode;
  
                  switch(objectNode__anonFunction.properties.type.name) {
                    case "anonFunction":
                      {
                        const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                        const mathNode__expr          = objectNode__anonFunction.properties["expr"];
  
                        // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                        // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);
  
                        var nb__var_in = arrayNode__operand.items.length;
  
                        const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                          const name = x.name;
                          // acc[name]  = arrayNode__operand.items[index];
                          acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                          return acc;
                        }, {});
                        logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);
  
  
                        //substitute as many bound vars as possible
                        outMathNode = mathNode__expr.transform(function (node, path, parent) {
                          var outNode2; 
              
                          var node__subst;
                          if (node.isSymbolNode && (node.name in dict__betaRed)) {
                            node__subst = dict__betaRed[node.name];
                            if(node__subst != null) {
                              outNode2 = node__subst.cloneDeep();
                            } else {
                              outNode2 = node;
                            }
                          }
                          else {
                            outNode2 = node;
                          }
                          logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
              
                          return outNode2;
                        });
                      }
                      break;
                    default:
                      {
                        throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                        outMathNode = arrayNode__operand;
                      }
                      break;
                  }
  
                  return outMathNode;
                }
  
  
                const func = function(mathNode__in) {
                  var outMathNode;
  
                  var arrayNode__in;
                  if(mathNode__in instanceof math.ArrayNode) {
                    arrayNode__in = mathNode__in;
                  } else {
                    arrayNode__in = new math.ArrayNode([mathNode__in]);
                  }
                  const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                  logger.log("logAnon", "mathNode__new:", mathNode__new);
                  logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());
  
                  outMathNode = mathNode__new;
                  
                  // try {
                  //   const value = mathNode__new.evaluate();
                  //   const mathNode__new__evaluated = new math.ConstantNode(value);
                  // } catch(e) {
                  //   logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                  // }
  
                  const autoSimplify = mathNode__in.autoSimplify;
                  if(autoSimplify) {
                    outMathNode = math.simplify(outMathNode);
                    outMathNode.autoSimplify = autoSimplify;
                  }
  
                  return outMathNode;
                };
  
                return func;
              }
  
              const mathNode__anonFunction  = createAnonFunctionObjectNode();
              const func                    = createFunc(mathNode__anonFunction);
  
              const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
              const mathNode__expr  = mathNode__anonFunction.properties["expr"];
              const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);
  
              const specs = {
                funcWrapper: {
                  func: func,
                  display:{
                    node__display: node__display,
                  }
                },
                quickFix__smallerFacades : true,
                // arr_order__edu: [0],
              };
  
              function func_decorated(mathNode__in) {
                return func(mathNode__in);
              }
  
              const transformationFunc = function(icObj) {
                var transformationOutput;
  
                logger.log("transformationFunc", icObj);
  
                const facade = icObj;
  
                const mathNode__in  = facade.mathNode;
                mathNode__in.isEquation = false;
                const mathNode__new = func_decorated(mathNode__in);
                mathNode__new.isEquation = false;
  
                const facade__new = icObj.clone();
                facade__new.mathNode = mathNode__new;
                transformationOutput = new TransformationOutput("mutated", facade__new, facade);
  
                return transformationOutput;
              };
  
              const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
              return gmItem__operator;
            });

            return arr_gmItem_operator__function;
          }
          
          const nb_operators__any  = 2;
          const nb_operators__add  = nb_operators__any;
          const nb_operators__sub  = nb_operators__any;
          const nb_operators__mult = nb_operators__any;
          const nb_operators__div  = nb_operators__any;
          const arr_gmItem_operator__function__add = createArr_gmItem_operator__function("+", 
            MathUtils.randomCartArrFromArr([1,2,3,4,5,6,7,8,9,10], nb_operators__add, nb_operators__add, nb_operators__add, false),
            nb_operators__add);
          const arr_gmItem_operator__function__sub = createArr_gmItem_operator__function("-", 
            MathUtils.randomCartArrFromArr([1,2,3,4,5,6,7,8,9,10], nb_operators__sub, nb_operators__sub, nb_operators__sub, false),
            nb_operators__sub);
          const arr_gmItem_operator__function__mult = createArr_gmItem_operator__function("*", 
            MathUtils.randomCartArrFromArr([2,3,4,5,6,7,8,9,10], nb_operators__mult, nb_operators__mult, nb_operators__mult, false),
            nb_operators__mult);
          const arr_gmItem_operator__function__div = createArr_gmItem_operator__function("/", 
            MathUtils.randomCartArrFromArr([2,3,4,5,6,7,8,9,10], nb_operators__div, nb_operators__div, nb_operators__div, false),
            nb_operators__div);

          const arr_gmItem_operator = Utils.shuffled([
            ...arr_gmItem_operator__function__mult, 
            ...arr_gmItem_operator__function__div,
            ...arr_gmItem_operator__function__add,
            ...arr_gmItem_operator__function__sub,
          ]);

          const arr_gmItem_operator_for_target = arr_gmItem_operator;


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 4;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = new math.ConstantNode(10);
          const mathNode__initial = Utils.randomElementInArray([
            new math.SymbolNode("x"),
            new math.SymbolNode("y"),
            new math.SymbolNode("z"),
            new math.SymbolNode("a"),
            new math.SymbolNode("b"),
            new math.SymbolNode("c"),
            new math.SymbolNode("d"),
          ]);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);



          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           [...arr_gmItem_operator__function__mult, ...arr_gmItem_operator__function__div],
            operators__inverse:  [...arr_gmItem_operator__function__add,  ...arr_gmItem_operator__function__sub],
          };

          return gmItemConfig;
        }




        static randomInstance__funcs__f5_function_evaluation__bound_vs_free(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__funcs__f5_function_evaluation__bound_vs_free();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__funcs__f5_function_evaluation__bound_vs_free() {
          logger.log("random_challengeGMItemConfig__funcs__f5_function_evaluation__bound_vs_free");

          const nb_operators__bound = 2;

          const arr_gmItem_operator__function__bound = [...new Array(nb_operators__bound).keys()].map(index => {

            function createAnonFunctionObjectNode() {

              const mathNode__symbol = Utils.randomElementInArray([
                new math.SymbolNode("x"),
                new math.SymbolNode("y"),
                new math.SymbolNode("t"),
                new math.SymbolNode("a"),
                new math.SymbolNode("u"),
              ]);

              const mathNode__arr_bound_var = new math.ArrayNode([mathNode__symbol]);

              const a = random_constantNode({min: 0, max: 10, step: 1});
              const b = random_constantNode({min: 0, max: 10, step: 1});

              const str__symbol = mathNode__symbol.name;
              const str__expr_raw      = "" + a + "*" + str__symbol + "+" + b;
              const str__expr__refined = Algebrite.run(str__expr_raw);
              var mathNode__expr = math.parse(str__expr__refined);

              const mathNode__expr__no_discr = Rewriter.rewriteSumWithSymbolsFirst(mathNode__expr);
              mathNode__expr = mathNode__expr__no_discr;

              const mathNode__anonFunction = new math.ObjectNode({
                type: new math.SymbolNode("anonFunction"),

                mathNode__arr_bound_var: mathNode__arr_bound_var,
                expr:          mathNode__expr,
              });

              return mathNode__anonFunction;
            }

            function createFunc(mathNode__anonFunction) {

              function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                var outMathNode;

                switch(objectNode__anonFunction.properties.type.name) {
                  case "anonFunction":
                    {
                      const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                      const mathNode__expr          = objectNode__anonFunction.properties["expr"];

                      // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                      // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);

                      var nb__var_in = arrayNode__operand.items.length;

                      const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                        const name = x.name;
                        // acc[name]  = arrayNode__operand.items[index];
                        acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                        return acc;
                      }, {});
                      logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);


                      //substitute as many bound vars as possible
                      outMathNode = mathNode__expr.transform(function (node, path, parent) {
                        var outNode2; 
            
                        var node__subst;
                        if (node.isSymbolNode && (node.name in dict__betaRed)) {
                          node__subst = dict__betaRed[node.name];
                          if(node__subst != null) {
                            outNode2 = node__subst.cloneDeep();
                          } else {
                            outNode2 = node;
                          }
                        }
                        else {
                          outNode2 = node;
                        }
                        logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
            
                        return outNode2;
                      });
                    }
                    break;
                  default:
                    {
                      throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                      outMathNode = arrayNode__operand;
                    }
                    break;
                }

                return outMathNode;
              }


              const func = function(mathNode__in) {
                var outMathNode;

                var arrayNode__in;
                if(mathNode__in instanceof math.ArrayNode) {
                  arrayNode__in = mathNode__in;
                } else {
                  arrayNode__in = new math.ArrayNode([mathNode__in]);
                }
                const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                logger.log("logAnon", "mathNode__new:", mathNode__new);
                logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());

                outMathNode = mathNode__new;
                
                // try {
                //   const value = mathNode__new.evaluate();
                //   const mathNode__new__evaluated = new math.ConstantNode(value);
                // } catch(e) {
                //   logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                // }

                const autoSimplify = mathNode__in.autoSimplify;
                if(autoSimplify) {
                  outMathNode = math.simplify(outMathNode);
                  outMathNode.autoSimplify = autoSimplify;
                }

                return outMathNode;
              };

              return func;
            }

            const mathNode__anonFunction  = createAnonFunctionObjectNode();
            const func                    = createFunc(mathNode__anonFunction);

            const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
            const mathNode__expr  = mathNode__anonFunction.properties["expr"];
            const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);

            const specs = {
              funcWrapper: {
                func: func,
                display:{
                  node__display: node__display,
                }
              },
              quickFix__smallerFacades : true,
              arr_order__edu: [0,1],
            };

            function func_decorated(mathNode__in) {
              return func(mathNode__in);
            }

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });
          // logger.log("logF3", "arr_gmItem_operator__function__bound:", arr_gmItem_operator__function__bound);

          const nb_operators__free = 2;

          const arr_gmItem_operator__function__free = [...new Array(nb_operators__free).keys()].map(index => {

            function createAnonFunctionObjectNode() {

              const arr_mathNode__symbol = [
                new math.SymbolNode("x"),
                new math.SymbolNode("y"),
                new math.SymbolNode("t"),
                new math.SymbolNode("a"),
                new math.SymbolNode("u"),
              ];

              const [mathNode__symbol__in, mathNode__symbol__out] = Utils.randomElementsInArray(arr_mathNode__symbol, 2, true);
              logger.log("logPick", "mathNode__symbol__in:",  mathNode__symbol__in);
              logger.log("logPick", "mathNode__symbol__out:", mathNode__symbol__out);

              const str__symbol__in  = mathNode__symbol__in.name;
              const str__symbol__out = mathNode__symbol__out.name;


              const mathNode__arr_bound_var = new math.ArrayNode([mathNode__symbol__in]);

              const a = random_constantNode({min: 0, max: 10, step: 1});
              const b = random_constantNode({min: 0, max: 10, step: 1});

              const str__expr_raw      = "" + a + "*" + str__symbol__out + "+" + b;
              const str__expr__refined = Algebrite.run(str__expr_raw);
              var mathNode__expr = math.parse(str__expr__refined);

              const mathNode__expr__no_discr = Rewriter.rewriteSumWithSymbolsFirst(mathNode__expr);
              mathNode__expr = mathNode__expr__no_discr;

              const mathNode__anonFunction = new math.ObjectNode({
                type: new math.SymbolNode("anonFunction"),

                mathNode__arr_bound_var: mathNode__arr_bound_var,
                expr:          mathNode__expr,
              });

              return mathNode__anonFunction;
            }

            function createFunc(mathNode__anonFunction) {

              function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                var outMathNode;

                switch(objectNode__anonFunction.properties.type.name) {
                  case "anonFunction":
                    {
                      const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                      const mathNode__expr          = objectNode__anonFunction.properties["expr"];

                      // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                      // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);

                      var nb__var_in = arrayNode__operand.items.length;

                      const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                        const name = x.name;
                        // acc[name]  = arrayNode__operand.items[index];
                        acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                        return acc;
                      }, {});
                      logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);


                      //substitute as many bound vars as possible
                      outMathNode = mathNode__expr.transform(function (node, path, parent) {
                        var outNode2; 
            
                        var node__subst;
                        if (node.isSymbolNode && (node.name in dict__betaRed)) {
                          node__subst = dict__betaRed[node.name];
                          if(node__subst != null) {
                            outNode2 = node__subst.cloneDeep();
                          } else {
                            outNode2 = node;
                          }
                        }
                        else {
                          outNode2 = node;
                        }
                        logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
            
                        return outNode2;
                      });
                    }
                    break;
                  default:
                    {
                      throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                      outMathNode = arrayNode__operand;
                    }
                    break;
                }

                return outMathNode;
              }


              const func = function(mathNode__in) {
                var outMathNode;

                var arrayNode__in;
                if(mathNode__in instanceof math.ArrayNode) {
                  arrayNode__in = mathNode__in;
                } else {
                  arrayNode__in = new math.ArrayNode([mathNode__in]);
                }
                const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                logger.log("logAnon", "mathNode__new:", mathNode__new);
                logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());

                outMathNode = mathNode__new;
                
                // try {
                //   const value = mathNode__new.evaluate();
                //   const mathNode__new__evaluated = new math.ConstantNode(value);
                // } catch(e) {
                //   logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                // }

                const autoSimplify = mathNode__in.autoSimplify;
                if(autoSimplify) {
                  outMathNode = math.simplify(outMathNode);
                  outMathNode.autoSimplify = autoSimplify;
                }

                return outMathNode;
              };

              return func;
            }

            const mathNode__anonFunction  = createAnonFunctionObjectNode();
            const func                    = createFunc(mathNode__anonFunction);

            const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
            const mathNode__expr  = mathNode__anonFunction.properties["expr"];
            const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);

            const specs = {
              funcWrapper: {
                func: func,
                display:{
                  node__display: node__display,
                }
              },
              quickFix__smallerFacades : true,
              arr_order__edu: [0],
            };

            function func_decorated(mathNode__in) {
              return func(mathNode__in);
            }

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator            = Utils.shuffled([...arr_gmItem_operator__function__bound, ...arr_gmItem_operator__function__free]);

          const arr_gmItem_operator_for_target = arr_gmItem_operator;


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 2;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = new math.ConstantNode(10);
          const mathNode__initial = Utils.randomElementInArray([
            new math.SymbolNode("x"),
            new math.SymbolNode("y"),
            new math.ConstantNode(0),
            new math.ConstantNode(1),
            new math.ConstantNode(2),
            new math.ConstantNode(5),
            new math.ConstantNode(10),
          ]);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        static randomInstance__funcs__f6_function_evaluation__bound_vs_free_2(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__funcs__f6_function_evaluation__bound_vs_free_2();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static random_challengeGMItemConfig__funcs__f6_function_evaluation__bound_vs_free_2() {
          logger.log("random_challengeGMItemConfig__funcs__f6_function_evaluation__bound_vs_free_2");

          const nb_operators__bound = 4;

          const arr_gmItem_operator__function__bound = [...new Array(nb_operators__bound).keys()].map(index => {

            function createAnonFunctionObjectNode() {

              const mathNode__symbol = Utils.randomElementInArray([
                new math.SymbolNode("x"),
                new math.SymbolNode("y"),
                new math.SymbolNode("t"),
                new math.SymbolNode("a"),
                new math.SymbolNode("u"),
                new math.SymbolNode("s"),
              ]);

              const mathNode__arr_bound_var = new math.ArrayNode([mathNode__symbol]);

              const a = random_constantNode({min: 0, max: 10, step: 1});
              const b = random_constantNode({min: 0, max: 10, step: 1});

              const str__symbol = mathNode__symbol.name;
              const str__expr_raw      = "" + a + "*" + str__symbol + "+" + b;
              const str__expr__refined = Algebrite.run(str__expr_raw);
              var mathNode__expr = math.parse(str__expr__refined);

              const mathNode__expr__no_discr = Rewriter.rewriteSumWithSymbolsFirst(mathNode__expr);
              mathNode__expr = mathNode__expr__no_discr;

              const mathNode__anonFunction = new math.ObjectNode({
                type: new math.SymbolNode("anonFunction"),

                mathNode__arr_bound_var: mathNode__arr_bound_var,
                expr:          mathNode__expr,
              });

              return mathNode__anonFunction;
            }

            function createFunc(mathNode__anonFunction) {

              function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                var outMathNode;

                switch(objectNode__anonFunction.properties.type.name) {
                  case "anonFunction":
                    {
                      const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                      const mathNode__expr          = objectNode__anonFunction.properties["expr"];

                      // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                      // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);

                      var nb__var_in = arrayNode__operand.items.length;

                      const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                        const name = x.name;
                        // acc[name]  = arrayNode__operand.items[index];
                        acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                        return acc;
                      }, {});
                      logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);


                      //substitute as many bound vars as possible
                      outMathNode = mathNode__expr.transform(function (node, path, parent) {
                        var outNode2; 
            
                        var node__subst;
                        if (node.isSymbolNode && (node.name in dict__betaRed)) {
                          node__subst = dict__betaRed[node.name];
                          if(node__subst != null) {
                            outNode2 = node__subst.cloneDeep();
                          } else {
                            outNode2 = node;
                          }
                        }
                        else {
                          outNode2 = node;
                        }
                        logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
            
                        return outNode2;
                      });
                    }
                    break;
                  default:
                    {
                      throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                      outMathNode = arrayNode__operand;
                    }
                    break;
                }

                return outMathNode;
              }


              const func = function(mathNode__in) {
                var outMathNode;

                var arrayNode__in;
                if(mathNode__in instanceof math.ArrayNode) {
                  arrayNode__in = mathNode__in;
                } else {
                  arrayNode__in = new math.ArrayNode([mathNode__in]);
                }
                const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                logger.log("logAnon", "mathNode__new:", mathNode__new);
                logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());

                outMathNode = mathNode__new;
                
                // try {
                //   const value = mathNode__new.evaluate();
                //   const mathNode__new__evaluated = new math.ConstantNode(value);
                // } catch(e) {
                //   logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                // }

                const autoSimplify = mathNode__in.autoSimplify;
                if(autoSimplify) {
                  outMathNode = math.simplify(outMathNode);
                  outMathNode.autoSimplify = autoSimplify;
                }

                return outMathNode;
              };

              return func;
            }

            const mathNode__anonFunction  = createAnonFunctionObjectNode();
            const func                    = createFunc(mathNode__anonFunction);

            const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
            const mathNode__expr  = mathNode__anonFunction.properties["expr"];
            const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);

            const specs = {
              funcWrapper: {
                func: func,
                display:{
                  node__display: node__display,
                }
              },
              quickFix__smallerFacades : true,
              arr_order__edu: [0,1],
            };

            function func_decorated(mathNode__in) {
              return func(mathNode__in);
            }

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });
          // logger.log("logF3", "arr_gmItem_operator__function__bound:", arr_gmItem_operator__function__bound);

          const nb_operators__free = 4;

          const arr_gmItem_operator__function__free = [...new Array(nb_operators__free).keys()].map(index => {

            function createAnonFunctionObjectNode() {

              const arr_mathNode__symbol = [
                new math.SymbolNode("x"),
                new math.SymbolNode("y"),
                new math.SymbolNode("t"),
                new math.SymbolNode("a"),
                new math.SymbolNode("u"),
                new math.SymbolNode("s"),
              ];

              const [mathNode__symbol__in, mathNode__symbol__out] = Utils.randomElementsInArray(arr_mathNode__symbol, 2, true);
              logger.log("logPick", "mathNode__symbol__in:",  mathNode__symbol__in);
              logger.log("logPick", "mathNode__symbol__out:", mathNode__symbol__out);

              const str__symbol__in  = mathNode__symbol__in.name;
              const str__symbol__out = mathNode__symbol__out.name;


              const mathNode__arr_bound_var = new math.ArrayNode([mathNode__symbol__in]);

              const a = random_constantNode({min: 0, max: 10, step: 1});
              const b = random_constantNode({min: 0, max: 10, step: 1});

              const str__expr_raw      = "" + a + "*" + str__symbol__out + "+" + b;
              const str__expr__refined = Algebrite.run(str__expr_raw);
              var mathNode__expr = math.parse(str__expr__refined);

              const mathNode__expr__no_discr = Rewriter.rewriteSumWithSymbolsFirst(mathNode__expr);
              mathNode__expr = mathNode__expr__no_discr;

              const mathNode__anonFunction = new math.ObjectNode({
                type: new math.SymbolNode("anonFunction"),

                mathNode__arr_bound_var: mathNode__arr_bound_var,
                expr:          mathNode__expr,
              });

              return mathNode__anonFunction;
            }

            function createFunc(mathNode__anonFunction) {

              function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                var outMathNode;

                switch(objectNode__anonFunction.properties.type.name) {
                  case "anonFunction":
                    {
                      const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                      const mathNode__expr          = objectNode__anonFunction.properties["expr"];

                      // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                      // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);

                      var nb__var_in = arrayNode__operand.items.length;

                      const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                        const name = x.name;
                        // acc[name]  = arrayNode__operand.items[index];
                        acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                        return acc;
                      }, {});
                      logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);


                      //substitute as many bound vars as possible
                      outMathNode = mathNode__expr.transform(function (node, path, parent) {
                        var outNode2; 
            
                        var node__subst;
                        if (node.isSymbolNode && (node.name in dict__betaRed)) {
                          node__subst = dict__betaRed[node.name];
                          if(node__subst != null) {
                            outNode2 = node__subst.cloneDeep();
                          } else {
                            outNode2 = node;
                          }
                        }
                        else {
                          outNode2 = node;
                        }
                        logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
            
                        return outNode2;
                      });
                    }
                    break;
                  default:
                    {
                      throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                      outMathNode = arrayNode__operand;
                    }
                    break;
                }

                return outMathNode;
              }


              const func = function(mathNode__in) {
                var outMathNode;

                var arrayNode__in;
                if(mathNode__in instanceof math.ArrayNode) {
                  arrayNode__in = mathNode__in;
                } else {
                  arrayNode__in = new math.ArrayNode([mathNode__in]);
                }
                const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                logger.log("logAnon", "mathNode__new:", mathNode__new);
                logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());

                outMathNode = mathNode__new;
                
                // try {
                //   const value = mathNode__new.evaluate();
                //   const mathNode__new__evaluated = new math.ConstantNode(value);
                // } catch(e) {
                //   logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                // }

                const autoSimplify = mathNode__in.autoSimplify;
                if(autoSimplify) {
                  outMathNode = math.simplify(outMathNode);
                  outMathNode.autoSimplify = autoSimplify;
                }

                return outMathNode;
              };

              return func;
            }

            const mathNode__anonFunction  = createAnonFunctionObjectNode();
            const func                    = createFunc(mathNode__anonFunction);

            const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
            const mathNode__expr  = mathNode__anonFunction.properties["expr"];
            const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);

            const specs = {
              funcWrapper: {
                func: func,
                display:{
                  node__display: node__display,
                }
              },
              quickFix__smallerFacades : true,
              arr_order__edu: [0],
            };

            function func_decorated(mathNode__in) {
              return func(mathNode__in);
            }

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator            = Utils.shuffled([...arr_gmItem_operator__function__bound, ...arr_gmItem_operator__function__free]);

          const arr_gmItem_operator_for_target = arr_gmItem_operator;


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 2;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = new math.ConstantNode(10);
          const mathNode__initial = Utils.randomElementInArray([
            new math.SymbolNode("x"),
            new math.SymbolNode("y"),
            new math.ConstantNode(0),
            new math.ConstantNode(1),
            new math.ConstantNode(2),
            new math.ConstantNode(5),
            new math.ConstantNode(10),
          ]);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const arr_gmItem_operator_1 = arr_gmItem_operator.slice(0,4);
          const arr_gmItem_operator_2 = arr_gmItem_operator.slice(4,8);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator_1,
            operators__inverse:  arr_gmItem_operator_2,
          };

          return gmItemConfig;
        }


        static randomInstance__funcs__f10_function_creation_via_composition(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__funcs__f10_function_creation_via_composition();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__funcs__f10_function_creation_via_composition() {
          logger.log("random_challengeGMItemConfig__funcs__f10_function_creation_via_composition");

          const nb_operators__mult = 4;

          const arr_value_a = MathUtils.randomCartArrFromArr([2,3,4,5,6,7,8,9,10], nb_operators__mult, nb_operators__mult, nb_operators__mult, false);

          const arr_gmItem_operator__function__mult = arr_value_a.map((value_a, index) => {

            function createAnonFunctionObjectNode() {

              const mathNode__symbol = Utils.randomElementInArray([
                new math.SymbolNode("x"),
              ]);

              const mathNode__arr_bound_var = new math.ArrayNode([mathNode__symbol]);

              const a = random_constantNode({min: 2, max: 10, step: 1});

              const str__symbol = mathNode__symbol.name;
              const str__expr_raw      = "" + value_a + "*" + str__symbol;
              const str__expr__refined = Algebrite.run(str__expr_raw);
              var mathNode__expr = math.parse(str__expr__refined);

              const mathNode__expr__no_discr = Rewriter.rewriteSumWithSymbolsFirst(mathNode__expr);
              mathNode__expr = mathNode__expr__no_discr;

              const mathNode__anonFunction = new math.ObjectNode({
                type: new math.SymbolNode("anonFunction"),

                mathNode__arr_bound_var: mathNode__arr_bound_var,
                expr:          mathNode__expr,
              });

              return mathNode__anonFunction;
            }

            function createFunc(mathNode__anonFunction) {

              function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                var outMathNode;

                switch(objectNode__anonFunction.properties.type.name) {
                  case "anonFunction":
                    {
                      const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                      const mathNode__expr          = objectNode__anonFunction.properties["expr"];

                      // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                      // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);

                      var nb__var_in = arrayNode__operand.items.length;

                      const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                        const name = x.name;
                        // acc[name]  = arrayNode__operand.items[index];
                        acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                        return acc;
                      }, {});
                      logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);


                      //substitute as many bound vars as possible
                      outMathNode = mathNode__expr.transform(function (node, path, parent) {
                        var outNode2; 
            
                        var node__subst;
                        if (node.isSymbolNode && (node.name in dict__betaRed)) {
                          node__subst = dict__betaRed[node.name];
                          if(node__subst != null) {
                            outNode2 = node__subst.cloneDeep();
                          } else {
                            outNode2 = node;
                          }
                        }
                        else {
                          outNode2 = node;
                        }
                        logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
            
                        return outNode2;
                      });
                    }
                    break;
                  default:
                    {
                      throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                      outMathNode = arrayNode__operand;
                    }
                    break;
                }

                return outMathNode;
              }


              const func = function(mathNode__in) {
                var outMathNode;

                var arrayNode__in;
                if(mathNode__in instanceof math.ArrayNode) {
                  arrayNode__in = mathNode__in;
                } else {
                  arrayNode__in = new math.ArrayNode([mathNode__in]);
                }
                const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                logger.log("logAnon", "mathNode__new:", mathNode__new);
                logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());

                outMathNode = mathNode__new;
                
                // try {
                //   const value = mathNode__new.evaluate();
                //   const mathNode__new__evaluated = new math.ConstantNode(value);
                // } catch(e) {
                //   logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                // }

                const autoSimplify = mathNode__in.autoSimplify;
                if(autoSimplify) {
                  outMathNode = math.simplify(outMathNode);
                  outMathNode.autoSimplify = autoSimplify;
                }

                return outMathNode;
              };

              return func;
            }

            const mathNode__anonFunction  = createAnonFunctionObjectNode();
            const func                    = createFunc(mathNode__anonFunction);

            const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
            const mathNode__expr  = mathNode__anonFunction.properties["expr"];
            const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);

            const specs = {
              funcWrapper: {
                func: func,
                display:{
                  node__display: node__display,
                }
              },
              quickFix__smallerFacades : true,
              arr_order__edu: [0,1],
            };

            function func_decorated(mathNode__in) {
              return func(mathNode__in);
            }

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });
          // logger.log("logF3", "arr_gmItem_operator__function__bound:", arr_gmItem_operator__function__bound);


          

          const nb_operators__add = 4;

          const arr_value_b = MathUtils.randomCartArrFromArr([1,2,3,4,5,6,7,8,9,10], nb_operators__add, nb_operators__add, nb_operators__add, false);
          logger.log("logRandom", "arr_value_b:", arr_value_b);

          const arr_gmItem_operator__function__add = arr_value_b.map((value_b, index) => {

            function createAnonFunctionObjectNode() {

              const arr_mathNode__symbol = [
                new math.SymbolNode("x"),
              ];

              const mathNode__symbol__in = arr_mathNode__symbol[0];

              const mathNode__arr_bound_var = new math.ArrayNode([mathNode__symbol__in]);

              // const b = random_constantNode({min: 1, max: 10, step: 1});

              const str__expr_raw      = mathNode__symbol__in.name + "+" + value_b;
              const str__expr__refined = Algebrite.run(str__expr_raw);
              var mathNode__expr = math.parse(str__expr__refined);

              const mathNode__expr__no_discr = Rewriter.rewriteSumWithSymbolsFirst(mathNode__expr);
              mathNode__expr = mathNode__expr__no_discr;

              const mathNode__anonFunction = new math.ObjectNode({
                type: new math.SymbolNode("anonFunction"),

                mathNode__arr_bound_var: mathNode__arr_bound_var,
                expr:          mathNode__expr,
              });

              return mathNode__anonFunction;
            }

            function createFunc(mathNode__anonFunction) {

              function betaReduce(arrayNode__operand, objectNode__anonFunction) {
                var outMathNode;

                switch(objectNode__anonFunction.properties.type.name) {
                  case "anonFunction":
                    {
                      const mathNode__arr_bound_var = objectNode__anonFunction.properties["mathNode__arr_bound_var"];
                      const mathNode__expr          = objectNode__anonFunction.properties["expr"];

                      // logger.log("logAnon", "betaReduce", "mathNode__arr_bound_var:", mathNode__arr_bound_var);
                      // logger.log("logAnon", "betaReduce", "mathNode__expr:", mathNode__expr);

                      var nb__var_in = arrayNode__operand.items.length;

                      const dict__betaRed = mathNode__arr_bound_var.items.slice(0,nb__var_in).reduce((acc, x, index) => {
                        const name = x.name;
                        // acc[name]  = arrayNode__operand.items[index];
                        acc[name]  = new math.ParenthesisNode(arrayNode__operand.items[index]);
                        return acc;
                      }, {});
                      logger.log("logAnon", "betaReduce", "dict__betaRed:", dict__betaRed);


                      //substitute as many bound vars as possible
                      outMathNode = mathNode__expr.transform(function (node, path, parent) {
                        var outNode2; 
            
                        var node__subst;
                        if (node.isSymbolNode && (node.name in dict__betaRed)) {
                          node__subst = dict__betaRed[node.name];
                          if(node__subst != null) {
                            outNode2 = node__subst.cloneDeep();
                          } else {
                            outNode2 = node;
                          }
                        }
                        else {
                          outNode2 = node;
                        }
                        logger.log("logAnon", "betaReduce", "outNode2:", outNode2);
            
                        return outNode2;
                      });
                    }
                    break;
                  default:
                    {
                      throw new Error("Unsupported type for objectNode__anonFunction:", objectNode__anonFunction.properties.type.name);
                      outMathNode = arrayNode__operand;
                    }
                    break;
                }

                return outMathNode;
              }


              const func = function(mathNode__in) {
                var outMathNode;

                var arrayNode__in;
                if(mathNode__in instanceof math.ArrayNode) {
                  arrayNode__in = mathNode__in;
                } else {
                  arrayNode__in = new math.ArrayNode([mathNode__in]);
                }
                const mathNode__new = betaReduce(arrayNode__in, mathNode__anonFunction);
                logger.log("logAnon", "mathNode__new:", mathNode__new);
                logger.log("logAnon", "mathNode__new.toTex():", mathNode__new.toTex());

                outMathNode = mathNode__new;
                
                // try {
                //   const value = mathNode__new.evaluate();
                //   const mathNode__new__evaluated = new math.ConstantNode(value);
                // } catch(e) {
                //   logger.log("logAnon", "mathNode__new.evaluate(), error:", e);
                // }

                const autoSimplify = mathNode__in.autoSimplify;
                if(autoSimplify) {
                  outMathNode = math.simplify(outMathNode);
                  outMathNode.autoSimplify = autoSimplify;
                }

                return outMathNode;
              };

              return func;
            }

            const mathNode__anonFunction  = createAnonFunctionObjectNode();
            const func                    = createFunc(mathNode__anonFunction);

            const arr_str__symbol = mathNode__anonFunction.properties["mathNode__arr_bound_var"].items.map(x => x.name);
            const mathNode__expr  = mathNode__anonFunction.properties["expr"];
            const node__display   = new MyFunctionAssignmentNode("f", arr_str__symbol, mathNode__expr);

            const specs = {
              funcWrapper: {
                func: func,
                display:{
                  node__display: node__display,
                }
              },
              quickFix__smallerFacades : true,
              arr_order__edu: [0],
            };

            function func_decorated(mathNode__in) {
              return func(mathNode__in);
            }

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator            = Utils.shuffled([...arr_gmItem_operator__function__mult, ...arr_gmItem_operator__function__add]);

          const arr_gmItem_operator_for_target = arr_gmItem_operator;


          const arr_mandat = [];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 2;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          // const mathNode__initial = new math.ConstantNode(10);
          const mathNode__initial = Utils.randomElementInArray([
            new math.SymbolNode("x"),
            new math.SymbolNode("y"),
            new math.ConstantNode(-1),
            new math.ConstantNode(1),
            new math.ConstantNode(2),
            new math.ConstantNode(5),
            new math.ConstantNode(10),
          ]);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const arr_gmItem_operator_1 = arr_gmItem_operator.slice(0,4);
          const arr_gmItem_operator_2 = arr_gmItem_operator.slice(4,8);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator__function__mult,
            operators__inverse:  arr_gmItem_operator__function__add,
          };

          return gmItemConfig;
        }






        //complex numbers

        static randomInstance__complex__cx0_addsub_pure(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__complex__cx0_addsub_pure();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__complex__cx0_addsub_pure() {
          logger.log("random_challengeGMItemConfig__complex__cx0_addsub_pure");

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +10,
                },

                range__im: {
                  min: +0,
                  max: +0,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 2;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +0,
                },

                range__im: {
                  min: +0,
                  max: +10,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[2]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 5;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          const mathNode__initial = new math.ConstantNode(10);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }



        static randomInstance__complex__cx1_addsub_big_chunks(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__complex__cx1_addsub_big_chunks();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__complex__cx1_addsub_big_chunks() {
          logger.log("random_challengeGMItemConfig__complex__cx1_addsub_big_chunks");

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +0,
                },

                range__im: {
                  min: +0,
                  max: +10,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              // op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 2;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +10,
                },

                range__im: {
                  min: +0,
                  max: +10,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              // op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[2]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 4;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          const mathNode__initial = new math.ConstantNode(10);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__complex__cx2_addsub_frac(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__complex__cx2_addsub_frac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__complex__cx2_addsub_frac() {
          logger.log("random_challengeGMItemConfig__complex__cx2_addsub_frac");

          const nb_operators = 4;

          const nb_operators__add = 2;
          const arr_gmItem_operator__add = [...new Array(nb_operators__add).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +1,
                  max: +1,
                },

                range__im: {
                  min: +0,
                  max: +0,
                },
                
              },
              premultiplier: {
                n_type: "frac",
                range__num: {
                  min: +1,
                  max: +10,
                },
                range__den: {
                  min: +1,
                  max: +5,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__mult = 2;
          const arr_gmItem_operator__mult = [...new Array(nb_operators__mult).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +0,
                },

                range__im: {
                  min: +1,
                  max: +1,
                },
                
              },
              premultiplier: {
                n_type: "frac",
                range__num: {
                  min: +1,
                  max: +10,
                },
                range__den: {
                  min: +1,
                  max: +5,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__add, ...arr_gmItem_operator__mult];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[2]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 5;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          const mathNode__initial = new math.ConstantNode(10);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }



        static randomInstance__complex__cx4_addsub_mult_re(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__complex__cx4_addsub_mult_re();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__complex__cx4_addsub_mult_re() {
          logger.log("random_challengeGMItemConfig__complex__cx4_addsub_mult_re");

          const nb_operators = 4;

          const nb_operators__addre = 1;
          const arr_gmItem_operator__addre = [...new Array(nb_operators__addre).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +10,
                },

                range__im: {
                  min: +0,
                  max: +0,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(new math.ParenthesisNode(mathNode_in));

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__addki = 1;
          const arr_gmItem_operator__addki = [...new Array(nb_operators__addki).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +0,
                },

                range__im: {
                  min: +0,
                  max: +10,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(new math.ParenthesisNode(mathNode_in));

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__multre = 2;
          const arr_gmItem_operator__multre = [...new Array(nb_operators__multre).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +3,
                  max: +7,
                },

                range__im: {
                  min: +0,
                  max: +0,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              //op_divide,

              //op_add,
              //op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(new math.ParenthesisNode(mathNode_in));

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__addre, ...arr_gmItem_operator__addki, ...arr_gmItem_operator__multre];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[1]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 5;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          //const mathNode__initial = new math.ConstantNode(10);
          const mathNode__initial = new math.ConstantNode(math.complex(1,3));

          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__complex__cx5_addsub_mult_im(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__complex__cx5_addsub_mult_im();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__complex__cx5_addsub_mult_im() {
          logger.log("random_challengeGMItemConfig__complex__cx5_addsub_mult_im");

          const nb_operators = 4;

          const nb_operators__addre = 1;
          const arr_gmItem_operator__addre = [...new Array(nb_operators__addre).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +10,
                },

                range__im: {
                  min: +0,
                  max: +0,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__addki = 1;
          const arr_gmItem_operator__addki = [...new Array(nb_operators__addki).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +0,
                },

                range__im: {
                  min: +0,
                  max: +10,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__multim = 2;
          const arr_gmItem_operator__multim = [...new Array(nb_operators__multim).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +0,
                },

                range__im: {
                  min: +1,
                  max: +6,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              //op_add,
              //op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              //outMathNode = func(mathNode_in);
              outMathNode = func(new math.ParenthesisNode(mathNode_in));

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_gmItem_operator            = [...arr_gmItem_operator__addre, ...arr_gmItem_operator__addki, ...arr_gmItem_operator__multim];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;

              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[1]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 5;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          //const mathNode__initial = new math.ConstantNode(10);
          const mathNode__initial = new math.ConstantNode(math.complex(1,3));

          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }


        static randomInstance__complex__cx6_addsub_mult_re_im(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__complex__cx6_addsub_mult_re_im();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__complex__cx6_addsub_mult_re_im() {
          logger.log("random_challengeGMItemConfig__complex__cx6_addsub_mult_re_im");

          const nb_operators = 4;

          const nb_operators__addre = 1;
          const arr_gmItem_operator__addre = [...new Array(nb_operators__addre).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +10,
                },

                range__im: {
                  min: +0,
                  max: +0,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(new math.ParenthesisNode(mathNode_in));

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__addki = 1;
          const arr_gmItem_operator__addki = [...new Array(nb_operators__addki).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +0,
                },

                range__im: {
                  min: +0,
                  max: +10,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(new math.ParenthesisNode(mathNode_in));

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const nb_operators__multre = 1;
          const arr_gmItem_operator__multre = [...new Array(nb_operators__multre).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +3,
                  max: +7,
                },

                range__im: {
                  min: +0,
                  max: +0,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              //op_add,
              //op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(new math.ParenthesisNode(mathNode_in));

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__multim = 1;
          const arr_gmItem_operator__multim = [...new Array(nb_operators__multim).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +0,
                },

                range__im: {
                  min: +2,
                  max: +5,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              op_multiply,
              // op_divide,

              //op_add,
              //op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              //outMathNode = func(mathNode_in);
              outMathNode = func(new math.ParenthesisNode(mathNode_in));

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          const arr_gmItem_operator            = [...arr_gmItem_operator__addre, ...arr_gmItem_operator__addki, ...arr_gmItem_operator__multre, ...arr_gmItem_operator__multim];

          const arr_gmItem_operator_for_target = arr_gmItem_operator.map(gmItem_operator => {
            const funcWrapper_in = gmItem_operator.specs.funcWrapper;
            const isShuffled = true;
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(funcWrapper_in.semantics.operator, funcWrapper_in.semantics.node_b, isShuffled);



            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = operatorNodeFuncWrapper.func(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const name = operatorNodeFuncWrapper.semantics.name;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });


          const arr_mandat = [arr_gmItem_operator_for_target[0], arr_gmItem_operator_for_target[1]];
          logger.log("arr_mandat", arr_mandat);
          const arr_filler = arr_gmItem_operator_for_target;

          const depth__target = 5;
          const depth__filler = depth__target - arr_mandat.length;
          // const depth__target = 10;

          // const mathNode__initial = new math.SymbolNode("x");
          //const mathNode__initial = new math.ConstantNode(10);
          const mathNode__initial = new math.ConstantNode(math.complex(1,3));

          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");
          // logger.log("gmItem__initial", gmItem__initial);

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr2(gmItem__initial, arr_mandat, arr_gmItem_operator_for_target, depth__filler);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);




          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }




        static randomInstance__complex__cxin1_mult(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__complex__cxin1_mult();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__complex__cxin1_mult() {
          logger.log("random_challengeGMItemConfig__complex__cxin1_mult");

          const arr_arr_number_primordial = Utils.cartesianProduct([+1,+2,+3,+4,+5,+6,+7,+8,+9], [+1, -1]);
          const arr_arr_arr_complex       = Utils.cartesianProduct(arr_arr_number_primordial, arr_arr_number_primordial);
          const arr_number = arr_arr_arr_complex.map(([[value_re, sign_re], [value_im, sign_im]]) => {
            return math.complex(value_re * sign_re, value_im * sign_im);
          });

          const arr_operatorNodeFuncWrapper__mult = arr_number.map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ParenthesisNode(new math.ConstantNode(number));
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__mult = arr_operatorNodeFuncWrapper__mult.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                if(isOneInArgs) {
                  outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          //input

          const arr_arr_op__primordial = Utils.cartesianProduct(["+","-"], [1,5]);
          logger.log("logComplex", "arr_arr_op__primordial", arr_arr_op__primordial);

          const arr_operatorNodeFuncWrapper__input_re = arr_arr_op__primordial.map(([op_symbol, number]) => {
            const op_add = Operator.fromOpString_binary(op_symbol);
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper__input_im = arr_arr_op__primordial.map(([op_symbol, number]) => {
            const op_add = Operator.fromOpString_binary(op_symbol);
            const node_b = new math.ConstantNode(math.complex(0,number));
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_operatorNodeFuncWrapper__input = [...arr_operatorNodeFuncWrapper__input_re, ...arr_operatorNodeFuncWrapper__input_im];

          const arr_gmItem_operator__input = arr_operatorNodeFuncWrapper__input.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              outMathNode = math.simplify(outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__input.slice(0,4);
          const arr_gmItem_operator_2 = arr_gmItem_operator__input.slice(4,8);


          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");



          const depth__target    = 2;

          const mathNode__one = new math.ConstantNode(1);
          const gmItem__one   = GMItem.value(mathNode__one, "one", "");

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__mult, depth__target, false);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator_2,
          };

          return gmItemConfig;
        }



        static randomInstance__complex__cx10_modulus(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__complex__cx10_modulus();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__complex__cx10_modulus() {
          logger.log("random_challengeGMItemConfig__complex__cx10_modulus");

          // const arr_arr_number_primordial = Utils.cartesianProduct([+1,+2,+3,+4,+5,+6,+7,+8,+9], [+1, -1]);
          // const arr_arr_arr_complex       = Utils.cartesianProduct(arr_arr_number_primordial, arr_arr_number_primordial);
          // const arr_number = arr_arr_arr_complex.map(([[value_re, sign_re], [value_im, sign_im]]) => {
          //   return math.complex(value_re * sign_re, value_im * sign_im);
          // });

          // const arr_operatorNodeFuncWrapper__add = arr_number.map(number => {
          //   const op_mult = Operator.fromOpString_binary("x");
          //   const node_b = new math.ParenthesisNode(new math.ConstantNode(number));
          //   const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
          //   return operatorNodeFuncWrapper;
          // });

          const nb_operators__add__re = 2;
          const arr_gmItem_operator__add__re = [...new Array(nb_operators__add__re).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +10,
                },

                range__im: {
                  min: +0,
                  max: +0,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__add__im = 1;
          const arr_gmItem_operator__add__im = [...new Array(nb_operators__add__im).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +0,
                },

                range__im: {
                  min: +0,
                  max: +10,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_2(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          // const arr_gmItem_operator__mult = arr_operatorNodeFuncWrapper__mult.map(operatorNodeFuncWrapper => {

          //   const name = operatorNodeFuncWrapper.semantics.name;

          //   const func = operatorNodeFuncWrapper.func;
          //   const func_decorated = function(mathNode_in) {
          //     logger.log("func_decorated, mathNode_in", mathNode_in);
          //     var outMathNode;

          //     //legacy
          //     outMathNode = func(mathNode_in);

          //     //la speciale tables
          //     if(outMathNode instanceof math.OperatorNode) {
          //       logger.log("la speciale tables", mathNode_in);

          //       const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

          //       if(isOneInArgs) {
          //         outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
          //       }

          //     }


          //     return outMathNode;
          //   };
          //   // const func_decorated = func;

          //   //bwerk
          //   operatorNodeFuncWrapper.func = func_decorated;

          //   const specs = {
          //     funcWrapper: operatorNodeFuncWrapper,
          //   };

          //   const transformationFunc = function(icObj) {
          //     var transformationOutput;

          //     logger.log("transformationFunc", icObj);

          //     const facade = icObj;

          //     const mathNode__in  = facade.mathNode;
          //     mathNode__in.isEquation = false;
          //     const mathNode__new = func_decorated(mathNode__in);
          //     mathNode__new.isEquation = false;

          //     const facade__new = icObj.clone();
          //     facade__new.mathNode = mathNode__new;
          //     transformationOutput = new TransformationOutput("mutated", facade__new, facade);

          //     return transformationOutput;
          //   };

          //   const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
          //   return gmItem__operator;
          // });

          function createGmItem_operator_fromIcGmOperatorConfig(config__icGMOperator) {
            const name = config__icGMOperator.name;
            const transformationFunc = config__icGMOperator.transformationFunc;

            const transformationFunc__mathNode = config__icGMOperator.transformationFunc__mathNode;
            const func = transformationFunc__mathNode;
            const funcWrapper = {
              semantics: {},
              display: {
                node__display: config__icGMOperator.node__display,
              },
              func: func,
              inverse: null,
            };

            const specs = {
              funcWrapper: funcWrapper,
            };
            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          }

          const config__icGMOperator = infiniteCanvas.createConfig__icGMOperator_withType("complex::modulus");
          const gmItem_operator__modulus = createGmItem_operator_fromIcGmOperatorConfig(config__icGMOperator);

          const arr_gmItem_operator = [...arr_gmItem_operator__add__re, ...arr_gmItem_operator__add__im, gmItem_operator__modulus];


          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");



          const depth__target    = 2;

          const mathNode__one = new math.ConstantNode(1);
          const gmItem__one   = GMItem.value(mathNode__one, "one", "");

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator, depth__target, false);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  [],
          };

          return gmItemConfig;
        }

        static easy__createChallengeGMItemConfig(config__easy__challengeGMItemConfig) {

          const dict__ = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator.slice(0,4),
            operators__inverse:  arr_gmItem_operator.slice(4,8),
          };


        }


        static randomInstance__complex__cx11_modargconj(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__complex__cx11_modargconj();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__complex__cx11_modargconj() {
          logger.log("random_challengeGMItemConfig__complex__cx11_modargconj");

          const nb_operators__add__re = 2;
          const arr_gmItem_operator__add__re = [...new Array(nb_operators__add__re).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +10,
                },

                range__im: {
                  min: +0,
                  max: +0,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const nb_operators__add__im = 2;
          const arr_gmItem_operator__add__im = [...new Array(nb_operators__add__im).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                isComplex: true,

                range__re: {
                  min: +0,
                  max: +0,
                },

                range__im: {
                  min: +0,
                  max: +10,
                },
                
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const op_add      = Operator.fromOpString_binary("+");
            const op_subtract = Operator.fromOpString_binary("-");

            const arr_op = [
              // op_multiply,
              // op_divide,

              op_add,
              op_subtract,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //decoration
              outMathNode = Simplifier.simplify_litexp_3(outMathNode);
              // logger.log("func_decorated, outMathNode", outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
              quickFix__smallerFacades : true,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          // const arr_gmItem_operator__mult = arr_operatorNodeFuncWrapper__mult.map(operatorNodeFuncWrapper => {

          //   const name = operatorNodeFuncWrapper.semantics.name;

          //   const func = operatorNodeFuncWrapper.func;
          //   const func_decorated = function(mathNode_in) {
          //     logger.log("func_decorated, mathNode_in", mathNode_in);
          //     var outMathNode;

          //     //legacy
          //     outMathNode = func(mathNode_in);

          //     //la speciale tables
          //     if(outMathNode instanceof math.OperatorNode) {
          //       logger.log("la speciale tables", mathNode_in);

          //       const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

          //       if(isOneInArgs) {
          //         outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
          //       }

          //     }


          //     return outMathNode;
          //   };
          //   // const func_decorated = func;

          //   //bwerk
          //   operatorNodeFuncWrapper.func = func_decorated;

          //   const specs = {
          //     funcWrapper: operatorNodeFuncWrapper,
          //   };

          //   const transformationFunc = function(icObj) {
          //     var transformationOutput;

          //     logger.log("transformationFunc", icObj);

          //     const facade = icObj;

          //     const mathNode__in  = facade.mathNode;
          //     mathNode__in.isEquation = false;
          //     const mathNode__new = func_decorated(mathNode__in);
          //     mathNode__new.isEquation = false;

          //     const facade__new = icObj.clone();
          //     facade__new.mathNode = mathNode__new;
          //     transformationOutput = new TransformationOutput("mutated", facade__new, facade);

          //     return transformationOutput;
          //   };

          //   const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
          //   return gmItem__operator;
          // });

          function createGmItem_operator_fromIcGmOperatorConfig(config__icGMOperator) {
            const name = config__icGMOperator.name;
            const transformationFunc = config__icGMOperator.transformationFunc;

            const transformationFunc__mathNode = config__icGMOperator.transformationFunc__mathNode;
            const func = transformationFunc__mathNode;
            const funcWrapper = {
              semantics: {},
              display: {
                node__display: config__icGMOperator.node__display,
              },
              func: func,
              inverse: null,
            };

            const specs = {
              funcWrapper: funcWrapper,
            };
            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          }

          const arr_gmOperatorType = [
            "complex::modulus",
            "complex::modulus",
            "complex::argument",
            "complex::conjugate",
          ];
          const arr_gmItem_operator__modargconj = arr_gmOperatorType.map((gmOperatorType) => {
            const config__icGMOperator = infiniteCanvas.createConfig__icGMOperator_withType(gmOperatorType);
            const gmItem_operator = createGmItem_operator_fromIcGmOperatorConfig(config__icGMOperator);
            return gmItem_operator;
          })

          const arr_gmItem_operator = [...arr_gmItem_operator__add__re, ...arr_gmItem_operator__add__im, ...arr_gmItem_operator__modargconj];


          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");



          const depth__target = 4;

          const mathNode__one = new math.ConstantNode(1);
          const gmItem__one   = GMItem.value(mathNode__one, "one", "");

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator, depth__target, false);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_3(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator.slice(0,4),
            operators__inverse:  arr_gmItem_operator.slice(4,8),
          };

          return gmItemConfig;
        }



        //internal

          //add

        static randomInstance__internal__in001_add_tables__que(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__internal__in001_add_tables__que();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__internal__in001_add_tables__que() {
          logger.log("random_challengeGMItemConfig__internal__in001_add_tables__que");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+0,+1,+2,+3,+4,+5,+6,+7,+8,+9].map(number => {
            const op_mult = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 0)].length == 1);

                if(isOneInArgs) {
                  outMathNode = outMathNode.args.find(mathNode => mathNode.value != 0);
                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant.slice(0,5);
          const arr_gmItem_operator_2 = arr_gmItem_operator__constant.slice(5,10);




          const depth__target    = 1;


          // const mathNode__initial = new math.ConstantNode(0);
          const mathNode__initial = random_constantNode({ min: 1, max: 10, step: 1 });
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__constant, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator_2,
          };

          return gmItemConfig;
        }


        static randomInstance__internal__in002_add_tables__ans(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__internal__in002_add_tables__ans();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__internal__in002_add_tables__ans() {
          logger.log("random_challengeGMItemConfig__internal__in002_add_tables__ans");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper__add = [+0,+1,+2,+3,+4,+5,+6,+7,+8,+9].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__add = arr_operatorNodeFuncWrapper__add.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              // //la speciale tables
              // if(outMathNode instanceof math.OperatorNode) {
              //   logger.log("la speciale tables", mathNode_in);

              //   const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

              //   if(isOneInArgs) {
              //     outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
              //   }

              // }


              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          //input

          const arr_operatorNodeFuncWrapper__input = [+5,+3,+2,+1,+50,+30,+20,+10].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__input = arr_operatorNodeFuncWrapper__input.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              outMathNode = math.simplify(outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__input.slice(0,4);
          const arr_gmItem_operator_2 = arr_gmItem_operator__input.slice(4,8);



          // const depth__target    = 2;
          const depth__target    = 1;


          // const mathNode__initial = new math.ConstantNode(0);
          const mathNode__initial = random_constantNode({ min: 1, max: 10, step: 1 });
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__add, depth__target, false);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator_2,
          };

          return gmItemConfig;
        }

          //mult

        static randomInstance__internal__in1_mult_tables__que(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__internal__in1_mult_tables__que();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__internal__in1_mult_tables__que() {
          logger.log("random_challengeGMItemConfig__internal__in1_mult_tables__que");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+2,+3,+4,+5,+6,+7,+8,+9].map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                if(isOneInArgs) {
                  outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant.slice(0,4);
          const arr_gmItem_operator_2 = arr_gmItem_operator__constant.slice(4,8);




          const depth__target    = 2;


          const mathNode__initial = new math.ConstantNode(1);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__constant, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator_2,
          };

          return gmItemConfig;
        }


        static randomInstance__internal__in2_mult_tables__ans(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__internal__in2_mult_tables__ans();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__internal__in2_mult_tables__ans() {
          logger.log("random_challengeGMItemConfig__internal__in2_mult_tables__ans");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper__mult = [+2,+3,+4,+5,+6,+7,+8,+9].map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__mult = arr_operatorNodeFuncWrapper__mult.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                if(isOneInArgs) {
                  outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            //bwerk
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });



          //input

          const arr_operatorNodeFuncWrapper__input = [+5,+3,+2,+1,+50,+30,+20,+10].map(number => {
            const op_add = Operator.fromOpString_binary("+");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_add, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__input = arr_operatorNodeFuncWrapper__input.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              outMathNode = math.simplify(outMathNode);

              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__input.slice(0,4);
          const arr_gmItem_operator_2 = arr_gmItem_operator__input.slice(4,8);


          const mathNode__initial = new math.ConstantNode(0);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");



          const depth__target    = 2;

          const mathNode__one = new math.ConstantNode(1);
          const gmItem__one   = GMItem.value(mathNode__one, "one", "");

          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__one, arr_gmItem_operator__mult, depth__target, false);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator_2,
          };

          return gmItemConfig;
        }





        static randomInstance__internal__in1w_mult_tables__que__written(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__internal__in1w_mult_tables__que__written();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__internal__in1w_mult_tables__que__written() {
          logger.log("random_challengeGMItemConfig__internal__in1w_mult_tables__que__written");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+2,+3,+4,+5,+6,+7,+8,+9].map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);
            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);

            const node__display = new math.OperatorNode("x", "multiply", [MathSingleton.node__empty, new math.SymbolNode(writtenNumber(node_b.value))]);
            operatorNodeFuncWrapper.display.node__display = node__display;

            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                if(isOneInArgs) {
                  outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                }

              }


              return outMathNode;
            };
            // const func_decorated = func;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant.slice(0,4);
          const arr_gmItem_operator_2 = arr_gmItem_operator__constant.slice(4,8);




          const depth__target    = 2;


          const mathNode__initial = new math.ConstantNode(1);
          const gmItem__initial   = GMItem.value(mathNode__initial, "initial", "");


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__constant, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator_2,
          };

          return gmItemConfig;
        }









        static randomInstance__X__x1_tables_X_decimal__que1(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__X__x1_tables_X_decimal__que1();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__X__x1_tables_X_decimal__que1() {
          logger.log("random_challengeGMItemConfig__X__x1_tables_X_decimal__que1");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          const arr_operatorNodeFuncWrapper = [+20,+30,+40,+50,+60,+70,+80,+90].map(number => {
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);
            // const node_b = new FixedDecimalConstantNode(math.bignumber(node_b__c.evaluate({})));

            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                if(isOneInArgs) {
                  outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                }

              }


              return outMathNode;
            };
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant.slice(0,4);
          const arr_gmItem_operator_2 = arr_gmItem_operator__constant.slice(4,8);




          const depth__target    = 2;


          const mathNode__initial_one = new math.ConstantNode(1);
          // const mathNode__initial_fx  = new FixedDecimalConstantNode(math.bignumber(mathNode__initial_one.evaluate({})));

          const gmItem__initial   = GMItem.value(mathNode__initial_one, "initial", "");


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__constant, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator_2,
          };

          return gmItemConfig;
        }


        static randomInstance__X__x2_tables_X_decimal__que2(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__X__x2_tables_X_decimal__que2();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__X__x2_tables_X_decimal__que2() {
          logger.log("random_challengeGMItemConfig__X__x2_tables_X_decimal__que2");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          // const arr_operatorNodeFuncWrapper = [+2,+3,+4,+5,+6,+7,+8,+9].map(i => 0.1 * i).map(number => {   // /!\ NOT THE SAME OUTPUT
          const arr_operatorNodeFuncWrapper = [+0.2,+0.3,+0.4,+0.5,+0.6,+0.7,+0.8,+0.9].map(number => {        // /!\ NOT THE SAME OUTPUT
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);

            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                if(isOneInArgs) {
                  outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                }

              }


              return outMathNode;
            };
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant.slice(0,4);
          const arr_gmItem_operator_2 = arr_gmItem_operator__constant.slice(4,8);




          const depth__target    = 2;


          const mathNode__initial_one = new math.ConstantNode(1);
          const mathNode__initial_fx  = new FixedDecimalConstantNode(math.bignumber(mathNode__initial_one.evaluate({})));

          const gmItem__initial   = GMItem.value(mathNode__initial_fx, "initial", "");


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__constant, depth__target);
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new FixedDecimalConstantNode(math.bignumber(math.simplify(mathNode__target).evaluate({})));


          function isSameExpression(mathNode1, mathNode2) {
            var outBool;

            logger.log("isSameExpression", mathNode1, mathNode2);

            const mathNode_equal = new math.RelationalNode(["equal"], [
              new math.ConstantNode(math.bignumber(mathNode1.evaluate())),
              new math.ConstantNode(math.bignumber(mathNode2.evaluate())),
            ]);

            outBool = mathNode_equal.evaluate({});

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;


          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator_2,
          };

          return gmItemConfig;
        }

        static randomInstance__X__x3_tables_X_decimal__que3(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGameStep__Endless_Practice.random_challengeGMItemConfig__X__x3_tables_X_decimal__que3();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static random_challengeGMItemConfig__X__x3_tables_X_decimal__que3() {
          logger.log("random_challengeGMItemConfig__X__x3_tables_X_decimal__que3");

          const nb_operators = 4;

          const nb_operators__constant = 4;

          // const arr_operatorNodeFuncWrapper = [+2,+3,+4,+5,+6,+7,+8,+9].map(i => 0.1 * i).map(number => {   // /!\ NOT THE SAME OUTPUT
          const arr_operatorNodeFuncWrapper = [+2,+3,+4,+5, +0.1, +6,+7,+8,+9, +10].map(number => {        // /!\ NOT THE SAME OUTPUT
            const op_mult = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(number);

            const operatorNodeFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op_mult, node_b);
            return operatorNodeFuncWrapper;
          });

          const arr_gmItem_operator__constant = arr_operatorNodeFuncWrapper.map(operatorNodeFuncWrapper => {

            const name = operatorNodeFuncWrapper.semantics.name;

            const func = operatorNodeFuncWrapper.func;
            const func_decorated = function(mathNode_in) {
              logger.log("func_decorated, mathNode_in", mathNode_in);
              var outMathNode;

              //legacy
              outMathNode = func(mathNode_in);

              //la speciale tables
              if(outMathNode instanceof math.OperatorNode) {
                logger.log("la speciale tables", mathNode_in);

                const isOneInArgs = ([...outMathNode.args.filter(mathNode => mathNode.value == 1)].length == 1);

                if(isOneInArgs) {
                  outMathNode = outMathNode.args.find(mathNode => mathNode.value != 1);
                }

              }


              return outMathNode;
            };
            operatorNodeFuncWrapper.func = func_decorated;

            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const transformationFunc = function(icObj) {
              var transformationOutput;

              logger.log("transformationFunc", icObj);

              const facade = icObj;

              const mathNode__in  = facade.mathNode;
              mathNode__in.isEquation = false;
              const mathNode__new = func_decorated(mathNode__in);
              mathNode__new.isEquation = false;

              const facade__new = icObj.clone();
              facade__new.mathNode = mathNode__new;
              transformationOutput = new TransformationOutput("mutated", facade__new, facade);

              return transformationOutput;
            };

            const gmItem__operator = GMItem.operator(transformationFunc, name, "", specs);
            return gmItem__operator;
          });

          const arr_gmItem_operator   = arr_gmItem_operator__constant.slice(0,5);
          const arr_gmItem_operator_2 = arr_gmItem_operator__constant.slice(5,10);

          const arr_gmItem_operator__tables = [...arr_gmItem_operator__constant.slice(0,4), ...arr_gmItem_operator__constant.slice(5,9)];
          const arr_gmItem_operator__mult10 = arr_gmItem_operator__constant.slice(9,10);
          const arr_gmItem_operator__div10  = arr_gmItem_operator__constant.slice(4,5);




          const mathNode__initial_one = new math.ConstantNode(1);
          const mathNode__initial_fx  = new FixedDecimalConstantNode(math.bignumber(mathNode__initial_one.evaluate({})));

          const gmItem__initial   = GMItem.value(mathNode__initial_fx, "initial", "");


          const depth__target    = 2;
          var gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator__tables, depth__target);
          const depth_2 = Utils.randomElementInArray([1,2,3,4,5]);
          if(Utils.randomElementInArray([0,1]) == 1) {
            gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__target, arr_gmItem_operator__mult10, depth_2);
          } else {
            gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__target, arr_gmItem_operator__div10, depth_2);
          }
          // logger.log("gmItem__target", gmItem__target);
          const mathNode__target = gmItem__target.content;
          //simplify target
          // gmItem__target.content = Simplifier.simplify_litexp_2(mathNode__target);
          gmItem__target.content = new FixedDecimalConstantNode(math.bignumber(math.simplify(mathNode__target).evaluate({})));

          function isSameExpression(mathNode1, mathNode2) {
            var outBool;

            logger.log("isSameExpression", mathNode1, mathNode2);

            const mathNode_equal = new math.RelationalNode(["equal"], [
              new math.ConstantNode(math.bignumber(mathNode1.evaluate())),
              new math.ConstantNode(math.bignumber(mathNode2.evaluate())),
            ]);

            outBool = mathNode_equal.evaluate({});

            return outBool;
          }

          gmItem__target.specs.func__isSameExpression = isSameExpression;

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            operators:           arr_gmItem_operator,
            operators__inverse:  arr_gmItem_operator_2,
          };

          return gmItemConfig;
        }



        

        //////////
        //////////

        configure(golfStepConfig) {
          // this.par = golfStepConfig.par;
          this.nb_attempts = 0;

          // this.challengeMathNodeConfig = golfStepConfig.challengeMathNodeConfig;
          this.challengeGMItemConfig = golfStepConfig.challengeGMItemConfig;
          this.challengeType         = golfStepConfig.challengeType;
        }

        start() {
          const golfCourse        = this.golfCourse;
          const stepGeneratorFunc = this.stepGeneratorFunc;

          this.invest(golfCourse);

          this.possess(golfCourse);

          this.recurse(stepGeneratorFunc);

          
          //go to challenge pov:
          const rect__makeshift = {
            x:      golfCourse.rect.x      - golfCourse.rect.width  * 0.30,
            y:      golfCourse.rect.y      - golfCourse.rect.height * 0.15,
            width:  golfCourse.rect.width  + golfCourse.rect.width  * 0.60 / 1.0,
            height: golfCourse.rect.height + golfCourse.rect.height * 0.30 / 1.0,
          };

          const cfg_anim__easy = {
            duration: 1000,
          };
          this.infiniteCanvas.move_to_rect__animation(rect__makeshift, cfg_anim__easy);

        }

        end() {
          // this.golfCourse.fillHole();
          const step = this;
          const infiniteCanvas = this.infiniteCanvas;

          step.rep_free__hole.parts.touchSlot.fill = "yellow";

          //destroy ball
          //end curses
          // step.rep_free__ball.curse_bornAgain_end();
          // step.rep_free__ball.curse_greenMouse_end();
          step.rep_free__ball.parts.facade.curse_greenMouse_end();


          //remove "die" hooks listeners
          step.rep_free__ball.will["die"].listeners = [];

          //remove
          step.rep_free__ball.im_dying_now                   = true;
          step.rep_free__ball.parts.facade.im_dying_now      = true;
          step.rep_free__ball.parts.contactArea.im_dying_now = true;

          if(step.rep_free__banner!= null) {
            step.rep_free__banner.im_dying_now               = true;
          }


          // infiniteCanvas.removeRepresented(step.rep_free__ball.represented);

          //remove all listeners
          const touchSlot__rep_free = step.rep_free__hole.parts.touchSlot;
          const touchSlotEngine = touchSlot__rep_free.dict_engine["touchSlot"].engine;
          touchSlotEngine.awoken.did["touch"].off(this.listener_targetDidTouch);

        }

        animate__showOrFade(isShow) {

          const step = this;
          const golfCourse = this.golfCourse;

          //get all components
          // const arr_icObj__golfCourse = Object.values(golfCourse.components).map(component => component.icObj);
          // const arr_icObj__step       = [
          //   step.rep_free__ball,
          //   step.rep_free__hole,

          // ];
          // const arr_icObj = [...arr_icObj__golfCourse, ...arr_icObj__step];
          const arr_icObj             = Object.values(golfCourse.components).map(component => component.icObj);
          logger.log("logStep", "animate__showOrFade", "arr_icObj", arr_icObj);

          var function__showOrFade__all; 
          if(isShow) {
            
            function animate__show__icObj(icObj) {
              const animation = anime({
                targets: icObj,
      
                /*animated props*/
                opacity: 1.0,
                // opacity: icObj.opacity__isShow, 
                /*--------------*/
      
                direction: 'normal',
                easing: 'easeInOutSine',
                duration: 100,
      
                autoplay: true,
      
                update: (anim) => {
                  // logger.log("animate_step__show", "update");
      
                  // infiniteCanvas.redrawCanvasObject(rep_free);
                  infiniteCanvas.redrawCanvas(RedrawOccasion.animation_bounce);
                  // infiniteCanvas.redrawCanvas(RedrawOccasion.forceRedraw); //does not work
      
                },
      
              });
            }

            const function__show__all = function() {
              arr_icObj.forEach(icObj => {
                animate__show__icObj(icObj);
              });
            }
            function__showOrFade__all = function__show__all;
          } else {

            function animate__fade__icObj(icObj) {
              const animation = anime({
                targets: icObj,
      
                /*animated props*/
                opacity: 0.26,
                // opacity: icObj.opacity__isFade, 
                /*--------------*/
      
                direction: 'normal',
                easing: 'easeInOutSine',
                duration: 100,
      
                autoplay: true,
      
                update: (anim) => {
                  // logger.log("animate_step__show", "update");
      
                  // infiniteCanvas.redrawCanvasObject(rep_free);
                  infiniteCanvas.redrawCanvas(RedrawOccasion.animation_bounce);
                  // infiniteCanvas.redrawCanvas(RedrawOccasion.forceRedraw); //does not work
      
                },
      
              });
            }

            const function__fade__all = function() {
              arr_icObj.forEach(icObj => {
                animate__fade__icObj(icObj);
              });
            }
            function__showOrFade__all = function__fade__all;
          }

          function__showOrFade__all();
        }

        addNewBall() {
          const step = this;
          const infiniteCanvas = this.infiniteCanvas;
          const golfCourse     = this.golfCourse;


          const icObj__tee = golfCourse.components["tee"].icObj;
          const trueRect__ball = {
            x: icObj__tee.position.x,
            y: icObj__tee.position.y,
            width:  82,
            height: 82,
          };

          // const value = 0;
          //debug
          const mathNode__initial = step.challengeGMItemConfig.initial.content;
          // const value = mathNode__initial.value;

          // const icObj = infiniteCanvas.createIcBornAgainGreenMouseBox(trueRect__ball, mathNode__initial);
          const icObj = infiniteCanvas.createIcGreenMouseBox(trueRect__ball, mathNode__initial);
          // const icObj = infiniteCanvas.createIcMathNode(trueRect__ball.x, trueRect__ball.y, mathNode__initial);

          icObj.zIndex = 90;
          icObj.parts.facade.zIndex = 100;

          infiniteCanvas.addIcObject(icObj);

          const rep_free__ball = infiniteCanvas.getRepresented(icObj.id).r_free();
          Hooker.installHooks(rep_free__ball, "die");
          rep_free__ball.did["die"].on(() => {
            // logger.log("did die");

            rep_free__ball.parts.facade.im_dying_now = true;
            rep_free__ball.parts.contactArea.im_dying_now = true;

            step.addNewBall();
          });

          //force homeScale:1
          rep_free__ball.homeScale = {X: 1.0, Y: 1.0};

          //store ref
          step.rep_free__ball = rep_free__ball;
        }

        addBanner() {
          const step = this;
          const infiniteCanvas = this.infiniteCanvas;
          const golfCourse     = this.golfCourse;


          const icObj__banner = golfCourse.components["banner"].icObj;
          const trueRect__banner = {
            x:      icObj__banner.position.x,
            y:      icObj__banner.position.y,
            width:  50,
            height: 50,
          };
          icObj__banner.zIndex = -100;

          if(step.challengeGMItemConfig.initial__display != null) {

            const mathNode__initial__display = step.challengeGMItemConfig.initial__display.content;
            // const value = mathNode__initial.value;

            // const icObj = infiniteCanvas.createIcBornAgainGreenMouseBox(trueRect__ball, mathNode__initial);
            // const icObj = infiniteCanvas.createIcGreenMouseBanner(trueRect__banner, mathNode__initial__display);

            const icObj = infiniteCanvas.createIcMathNode(trueRect__banner.x, trueRect__banner.y, mathNode__initial__display);
            icObj.fill = "grey";
            icObj.canBeSelected = false;
            icObj.canBeHeld     = false;
            icObj.canBeMoved    = false;
            icObj.isTouchable   = false;


            // infiniteCanvas.onceOnAddRepresentedForIcObject(icObj, (icObj) => {
            //   const rep_free__banner = infiniteCanvas.getRepresented(icObj.id).r_free();
            //   step.rep_free__banner  = rep_free__banner;
            // });
            infiniteCanvas.addIcObject(icObj);

            const rep_free__banner = infiniteCanvas.getRepresented(icObj.id).r_free();

            //force homeScale:1
            rep_free__banner.homeScale = {X: 1.0, Y: 1.0};

            //store ref
            step.rep_free__banner  = rep_free__banner;
          }
          
        }

        addRefreshButton() {

        }

        invest(golfCourse) {

          const step = this;
          const infiniteCanvas = this.infiniteCanvas;

          //clear: remove objects



          //furnish: add objects
          {
            const infiniteCanvas = this.infiniteCanvas;

            //add label/value: score
            function addLabel_score() {
              const rect__score = golfCourse.rect;
              rect__score.width = 300;
              rect__score.height = 150;

              const string__score = "score:";
              const value__score = 0;

              const icObj__score = infiniteCanvas.createIcLabelValue(rect__score, string__score, value__score);
              icObj__score.zIndex = 200;

              infiniteCanvas.addIcObject(icObj__score);

              const rep_free__score_valueLabel = infiniteCanvas.getRepresented(icObj__score.id).r_free();
              step.rep_free__score_valueLabel = rep_free__score_valueLabel;
              step.rep_free__score_value = rep_free__score_valueLabel.parts["value"];
            }
            // addLabel_score();

            //add label/value: par
            function addLabelValue_par() {
              const rect__par = {
                x: step.rep_free__score_valueLabel.position.x,
                y: step.rep_free__score_valueLabel.position.y + 120,
                width: 300,
                height: 150,
              };

              const string__par = "par:";
              const value__par = step.par;

              const icObj__par = infiniteCanvas.createIcLabelValue(rect__par, string__par, value__par);
              icObj__par.zIndex = 201;

              infiniteCanvas.addIcObject(icObj__par);

              const rep_free__par_valueLabel = infiniteCanvas.getRepresented(icObj__par.id).r_free();
              step.rep_free__par_valueLabel = rep_free__par_valueLabel;
              step.rep_free__par_value = rep_free__par_valueLabel.parts["value"];

              setTimeout(() => {
                step.rep_free__par_value.position = {
                  x: step.rep_free__score_value.position.x,
                  y: step.rep_free__par_value.position.y,
                };
              }, 20);   //SHU TODO: remove this ugliness
            }
            // addLabelValue_par();


            //add ball:
            step.addNewBall();

            //add banner
            if(golfCourse.components["banner"] != null) {
              step.addBanner();
            }
            


            //configure button: refresh
            if(golfCourse.components["refresh"] != null) {
              const icButton__refresh = golfCourse.components["refresh"].icObj;
              logger.log("logGM", "icButton__refresh", icButton__refresh);

              const config__button = {
                buttonFunc: (scopeObj) => {

                  const step = scopeObj.engineCarrier.buttonConfig.step;

                  {
                    step.offCompleted(step.listener_onCompleted);
                    step.end();

                    step.animate__showOrFade(false);

                    step.segue.play(step);
                    // step.step_to.animate__showOrFade(true);
                  }

                },
                step: step,
              };

              icButton__refresh.buttonConfig = config__button;
            }



            //add button: impossible

          }


          //invest: "this is mine now"
          {
            // step.rep_free__ball = golfCourse.components["ball"].icObj;
            step.rep_free__hole = golfCourse.components["hole"].icObj;
          }


          //employ: now you do X
          //initial
          const mathNode__initial = step.challengeGMItemConfig.initial.content;
          step.rep_free__ball.mathNode = mathNode__initial;
          // logger.log("mathNode__initial", mathNode__initial);

          if(step.challengeGMItemConfig.initial__display != null) {
            const mathNode__initial__display = step.challengeGMItemConfig.initial__display.content;
            step.rep_free__banner.mathNode   = mathNode__initial__display;
          }


          //target
          {
            const mathNode__target          = step.challengeGMItemConfig.target.content;
            const func__isSameExpression_in = step.challengeGMItemConfig.target.specs.func__isSameExpression;

            step.rep_free__hole.parts.touchSlot.fill = "";

            //core
            if("core" in step.rep_free__hole.parts) {
              step.rep_free__hole.parts.core.mathNode = mathNode__target;
            }

            //facade
            /*
            // const mathNode__left  = new math.SymbolNode("x");
            // const mathNode__right = new math.SymbolNode(" ?");
            // step.rep_free__hole.parts.facade.mathNode = new math.RelationalNode(["equal"], [mathNode__left, mathNode__right]);
            */
            const node__display_in = step.challengeGMItemConfig.target.specs.node__display;
            if(node__display_in != null) {
              step.rep_free__hole.parts.facade.mathNode = node__display_in;
            } else {
              step.rep_free__hole.parts.facade.mathNode = mathNode__target;
            }

            step.rep_free__hole.parts.facade.originX = "center";


            //touchSlot
            const rep_free__touchSlot = step.rep_free__hole.parts.touchSlot;

            const canTouchFunc_geometryWise = function (above, below, context) {
              // const canTouchFunc = Touch.canTouch;

              const touch2Singleton = Touch2Singleton.sharedInstance();
              const canTouchFunc    = touch2Singleton.canTouch.bind(touch2Singleton);

              return canTouchFunc(above, below);
            };

            const canTouchFunc_valueWise = function (icObj) {
              logger.log("logeq1", "canTouchFunc_valueWise", icObj);

              var outBool;

              if (icObj.cType == "gm_box") {

                /* //equations
                // const mathNode__core = step.rep_free__hole.parts.core.mathNode;
                // const isSameRightMember = icObj.parts.facade.mathNode.params[1].value == mathNode__core.params[1].value;
                // outBool = isSameRightMember;
                */

                function isSameExpression__default(mathNode_1, mathNode_2) {
                  var outBool;

                  var expr__mathNode_1 = mathNode_1.toString();
                  expr__mathNode_1 = expr__mathNode_1.replaceAll("×", "*");
                  var expr__mathNode_2 = mathNode_2.toString();
                  expr__mathNode_2 = expr__mathNode_2.replaceAll("×", "*");

                  const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
                  logger.log("expr__equality", expr__equality);
                  const algebrite_result = Algebrite.run(expr__equality);

                  outBool = (algebrite_result == true);

                  return outBool;
                }

                var func__isSameExpression;
                if(func__isSameExpression_in != null) {
                  logger.log("logeq1", "func__isSameExpression_in", func__isSameExpression_in);
                  func__isSameExpression = func__isSameExpression_in;
                } else {
                  func__isSameExpression = isSameExpression__default;
                }
                

                if (icObj.parts.facade != null) {
                  logger.log("logeq1", "icObj.parts.facade != null");

                  const mathNode__icObj = icObj.parts.facade.mathNode;
                  logger.log("mathNode__icObj", mathNode__icObj);
                  
                  var mathNode__hole;
                  if("core" in step.rep_free__hole.parts) {
                    mathNode__hole = step.rep_free__hole.parts.core.mathNode;
                  } else {
                    mathNode__hole = step.rep_free__hole.parts.facade.mathNode;
                  }

                  const isSameExpression_ = func__isSameExpression(mathNode__icObj, mathNode__hole);
                  outBool = isSameExpression_;
                } else {
                  outBool = false;
                }

              } else {
                outBool = false;
              }

              return outBool;
            };

            const canTouchFuncs = {
              "geometry": canTouchFunc_geometryWise,
              "value":    canTouchFunc_valueWise,
            };

            const canTouchFunc_allWise = (above, below, context) => {
              return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
                const canTouch_xWise = canTouchFunc_xWise(above, below, context);
                logger.log("logeq1", "canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
                return acc && canTouch_xWise;
              }, true);
            };

            const canTouchFunc = canTouchFunc_allWise;

            logger.log("logeq1", "rep_free__touchSlot.touchSlotConfig.canTouchFunc = canTouchFunc;");
            rep_free__touchSlot.touchSlotConfig.canTouchFunc = canTouchFunc;

            const transformationFunc = function (icObj) {
              var transformationOutput;

              transformationOutput = new TransformationOutput("old", icObj, icObj);

              return transformationOutput;
            };
            rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc;
          }


          //operators
          {
            const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_operator");
            const arr_rep_free__operator = arr_gm_operator.map((gm_operator, i) => {
              const icObj__rep_free = gm_operator.icObj;
              return icObj__rep_free;
            });
            const arr_gmItem_operator = step.challengeGMItemConfig.operators;

            const arr_zipped = Utils.zip(arr_rep_free__operator, arr_gmItem_operator);

            arr_zipped.forEach(([rep_free__operator, gmItem_operator], i) => {
              logger.log("logGolf", "[rep_free__operator, gmItem_operator]", [rep_free__operator, gmItem_operator]);


              //touchSlot
              const rep_free__touchSlot = rep_free__operator.parts["touchSlot"];

              const transformationFunc = gmItem_operator.content;
              const transformationFunc__decorated = function (icObj) {
                var transformationOutput;

                const icObj__new = icObj.clone();
                // logger.log("outIcObj", outIcObj);

                // if(icObj__new.mathNode) {
                //   delete icObj__new.mathNode;     //SHU666: true sadness
                // }

                if (icObj.cType == "gm_box") {
                  // logger.log("gm_box");

                  const facade = icObj.parts.facade;
                  logger.log("logGolf", 'icObj.cType == "gm_box"', "facade:", facade);

                  // outIcObj.parts.facade.mathNode = mathNodeTransformationFunc(facade.mathNode);
                  const transformationOutput = transformationFunc(facade);
                  const facade__new = transformationOutput.value;
                  icObj__new.parts.facade.mathNode = facade__new.mathNode;
                }

                transformationOutput = new TransformationOutput("mutated", icObj__new, icObj);

                return transformationOutput;
              };
              rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc__decorated;

              //add animation_bounce
              const transformationFunc__without_animation_bounce = transformationFunc__decorated;
              const transformationFunc__decorated__animation_bounce = function (icObj_in) {
                var transformationOutput;
      
                transformationOutput = transformationFunc__without_animation_bounce(icObj_in);
                // logger.log("transformationOutput", transformationOutput);
      
                //touch animation
                // setTimeout(() => {
                  const icObj__result = transformationOutput.value;
      
                  const icObj__facade    = icObj__result.parts.facade;
                  const rep_free__facade = infiniteCanvas.getRepresented(icObj__facade.id).r_free();
      
                  infiniteCanvas.animate_bounce(rep_free__facade);
                // }, 1); 
      
                return transformationOutput;
              };
              rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc__decorated__animation_bounce;


              if("isEnabled" in gmItem_operator.specs) {
                rep_free__touchSlot.touchSlotConfig.isEnabled        = gmItem_operator.specs.isEnabled;
              }


              //facade
              const rep_free__facade = rep_free__operator.parts["facade"];
              // logger.log("rep_free__facade", rep_free__facade);
              
              var node__display;
              if(gmItem_operator.specs.funcWrapper.display != null && gmItem_operator.specs.funcWrapper.display.node__display != null) {
                node__display = gmItem_operator.specs.funcWrapper.display.node__display;
              } else {
                node__display = gmItem_operator.specs.funcWrapper.semantics.node__operatorNode;
              }
              rep_free__facade.mathNode = node__display;

              rep_free__facade.originX  = "center";

              if("isEnabled" in gmItem_operator.specs) {
                rep_free__facade.opacity = gmItem_operator.specs.isEnabled ? 1 : 0.4;
              }

              if("func__upgradeTex" in gmItem_operator.specs) {
                rep_free__facade.func__upgradeTex = gmItem_operator.specs.func__upgradeTex;
              }

              //smaller facades
              if("quickFix__smallerFacades" in gmItem_operator.specs) {
                rep_free__facade.homeScale = {
                  //X: rep_free__facade.homeScale.X * 1.4,
                  //Y: rep_free__facade.homeScale.Y * 1.4,
                  X: 1.4,
                  Y: 1.4,
                };
              }

            });

          }


          //operators__inverse
          {
            const arr_gm_operator__inverse = Object.values(golfCourse.components).filter(component => component.type == "placeholder");
            const arr_rep_free__operator__inverse = arr_gm_operator__inverse.map((gm_operator, i) => {
              const icObj__rep_free = gm_operator.icObj;
              return icObj__rep_free;
            });
            const arr_gmItem_operator__inverse = step.challengeGMItemConfig.operators__inverse;

            const arr_zipped = Utils.zip(arr_rep_free__operator__inverse, arr_gmItem_operator__inverse);

            arr_zipped.forEach(([rep_free__operator, gmItem_operator], i) => {


              //touchSlot
              const rep_free__touchSlot = rep_free__operator.parts["touchSlot"];

              const transformationFunc = gmItem_operator.content;
              const transformationFunc__decorated = function (icObj) {
                var transformationOutput;

                const icObj__new = icObj.clone();
                // logger.log("outIcObj", outIcObj);

                // if(icObj__new.mathNode) {
                //   delete icObj__new.mathNode;     //SHU666: true sadness
                // }

                if (icObj.cType == "gm_box") {
                  // logger.log("gm_box");

                  const facade = icObj.parts.facade;
                  // outIcObj.parts.facade.mathNode = mathNodeTransformationFunc(facade.mathNode);
                  const transformationOutput = transformationFunc(facade);
                  const facade__new = transformationOutput.value;
                  icObj__new.parts.facade.mathNode = facade__new.mathNode;
                }

                transformationOutput = new TransformationOutput("mutated", icObj__new, icObj);

                return transformationOutput;
              };
              rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc__decorated;


              //add animation_bounce
              const transformationFunc__without_animation_bounce = transformationFunc__decorated;
              const transformationFunc__decorated__animation_bounce = function (icObj_in) {
                var transformationOutput;
      
                transformationOutput = transformationFunc__without_animation_bounce(icObj_in);
                // logger.log("transformationOutput", transformationOutput);
      
                //touch animation
                // setTimeout(() => {
                  const icObj__result = transformationOutput.value;
      
                  const icObj__facade    = icObj__result.parts.facade;
                  const rep_free__facade = infiniteCanvas.getRepresented(icObj__facade.id).r_free();
      
                  infiniteCanvas.animate_bounce(rep_free__facade);
                // }, 1); 
      
                return transformationOutput;
              };
              rep_free__touchSlot.touchSlotConfig.transformationFunc = transformationFunc__decorated__animation_bounce;


              if("isEnabled" in gmItem_operator.specs) {
                rep_free__touchSlot.touchSlotConfig.isEnabled        = gmItem_operator.specs.isEnabled;
              }

              //facade
              const rep_free__facade = rep_free__operator.parts["facade"];

              var node__display;
              if(gmItem_operator.specs.funcWrapper.display != null && gmItem_operator.specs.funcWrapper.display.node__display != null) {
                node__display = gmItem_operator.specs.funcWrapper.display.node__display;
              } else {
                node__display = gmItem_operator.specs.funcWrapper.semantics.node__operatorNode;
              }
              rep_free__facade.mathNode = node__display;

              rep_free__facade.originX  = "center";

              if("isEnabled" in gmItem_operator.specs) {
                rep_free__facade.opacity = gmItem_operator.specs.isEnabled ? 1 : 0.4;
              }

              if("func__upgradeTex" in gmItem_operator.specs) {
                rep_free__facade.func__upgradeTex = gmItem_operator.specs.func__upgradeTex;
              }

              //smaller facades
              if("quickFix__smallerFacades" in gmItem_operator.specs) {
                rep_free__facade.homeScale = {
                  //X: rep_free__facade.homeScale.X * 1.4,
                  //Y: rep_free__facade.homeScale.Y * 1.4,
                  X: 1.4,
                  Y: 1.4,
                };
              }

            });
          }

          //refresh button
          if(step.challengeGMItemConfig.refresh_button != null) {
            const refresh_button = step.challengeGMItemConfig.refresh_button;
            refresh_button.onClick = () => {

            };
          }


          // step.infiniteCanvas.redrawCanvas(RedrawOccasion.forceRedraw);   //SHU666:pour éviter les bugs de non rafraîchissement des teXFObj //ce n'est pas la panacée
        }

        possess(golfCourse) {
          this.initializeCompletionListeners();

          this.setupAttemptListeners(golfCourse);

          this.setupCompletionTrigger(golfCourse);
          this.addCompletionListener(golfCourse);
        }

        recurse(stepGeneratorFunc) {
          const step = this;

          const segueConfig = {};
          const step_from = step;

          const golfCourse_to = step_from.golfCourse;

          const segue = new GolfGameSegue__Endless_Practice(infiniteCanvas, segueConfig, step_from, golfCourse_to, stepGeneratorFunc);

          this.segue = segue;
        }


        initializeCompletionListeners() {
          // this.nb_attempts = 0;
          this.arr_attempt = [];

          this.listeners_completed = [];

          this.onCompleted = (listener) => {
            this.listeners_completed.push(listener);
          };
          this.offCompleted = (listener) => {
            this.listeners_completed = Utils.arrayByRemovingElement(this.listeners_completed, listener);
          };
          this.nowCompleted = () => {
            this.listeners_completed.forEach((listener, i) => {
              listener(this);
            });
          };
        }

        setupAttemptListeners(golfCourse) {   //SHU: this is where BigBrother sneaked in from

          const step = this;

          // function waitForNewAttempt() {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   const createAttemptFunc = () => {
          //
          //       const attempt = new GolfStepAttempt();
          //
          //       step.arr_attempt.push(attempt);
          //
          //       ball__rep_free.offHold(createAttemptFunc);
          //   };
          //
          //   ball__rep_free.onHold(createAttemptFunc);
          // }
          //
          // //gm.onHold(create attempt)
          // {
          //   waitForNewAttempt();
          // }
          //
          // //gm.onTouched(add event to attempt)
          // {
          //
          // }
          //
          // //gm.onRelease(finalize attempt)
          // {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   ball__rep_free.onRelease(waitForNewAttempt);
          // }

          //create attempt






          //course use listeners

          function listenToOperatorTouches(icObj__rep_free) {

            const touchSlot__rep_free = icObj__rep_free.parts["touchSlot"];
            // logger.log("touchSlot__rep_free", touchSlot__rep_free);

            // const touchSlotEngine = touchSlot__rep_free.engine;
            const touchSlotEngine = touchSlot__rep_free.dict_engine["touchSlot"].engine;


            Hooker.installHooks(touchSlotEngine.awoken, "touch");
            touchSlotEngine.awoken.did["touch"].on((...args) => {
              // logger.log("did touch", ...args);

              // // counter += 1
              // const attempt = step.getCurrentAttempt();
              // logger.log("attempt", attempt);
              // attempt.manoeuvre.nb_touched += 1;
              //
              // //debug
              // step.rep_free__score_value.text = "" + attempt.manoeuvre.nb_touched;



              // const rep_free__curseFacade = step.rep_free__hole.parts.curseFacade;
              const rep_free__curseFacade = step.rep_free__hole.parts.curseFacade;
              if (rep_free__curseFacade != null) {
                const rep_free__facade = step.rep_free__hole.parts.facade;
                rep_free__facade.curse_metamorphosis.curseTrigger.impulse();
              }


            });

          }

          const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_operator");

          arr_gm_operator.forEach((gm_operator, i) => {
            const icObj__rep_free = gm_operator.icObj;
            listenToOperatorTouches(icObj__rep_free);
          });

        }

        setupCompletionTrigger(golfCourse) {

          const targetTouchSlot__rep_free = golfCourse.components["hole"].icObj;

          const touchSlot__rep_free = targetTouchSlot__rep_free.parts["touchSlot"];

          // const touchSlotEngine = touchSlot__rep_free.engine;
          const touchSlotEngine = touchSlot__rep_free.dict_engine["touchSlot"].engine;

          Hooker.installHooks(touchSlotEngine.awoken, "touch");
          const listener_targetDidTouch = (...args) => {
            // logger.log("did touch", ...args);

            this.nowCompleted();
          };
          this.listener_targetDidTouch = listener_targetDidTouch;
          touchSlotEngine.awoken.did["touch"].on(listener_targetDidTouch);

        }

        addCompletionListener(golfCourse) {

          const step = this;

          this.listener_onCompleted = (golfStep) => {
            // console.log("step, onCompleted", golfStep);
            // logger.log("step, onCompleted", golfStep);

            /*
            const score = golfStep.arr_attempts.length;
            golfCourse.mutateIntoScoreLabel(score);
            */

            step.offCompleted(step.listener_onCompleted);
            step.end();

            step.animate__showOrFade(false);

            step.segue.play(golfStep);
          };

          this.onCompleted(this.listener_onCompleted);
        }

        getCurrentAttempt() {
          return this.arr_attempt[this.arr_attempt.length - 1];
        }







      }

      class GolfGameSegue__Endless_Practice {

        constructor(infiniteCanvas, golfSegueConfig, step_from, golfCourse_to, /*step_to = null,*/ stepGeneratorFunc) {
          this.infiniteCanvas = infiniteCanvas;

          this.golfSegueConfig = golfSegueConfig;
          this.configure(golfSegueConfig);

          this.step_from = step_from;

          this.golfCourse_to = golfCourse_to;
          // this.step_to       = step_to;
          this.stepGeneratorFunc = stepGeneratorFunc;
        }

        configure(golfSegueConfig) {

        }

        play(step_from) {
          // logger.log("GolfSegue::play", step_from);

          const golfCourse_to = this.golfCourse_to;

          setTimeout(() => {

            // const position_to = {
            //   x: golfCourse_to.rect.x,
            //   y: golfCourse_to.rect.y,
            // };
            // this.infiniteCanvas.move_to_position(position_to);

            // this.infiniteCanvas.show_rect(golfCourse_to.rect);    //SHU TODO

            const rect__makeshift = {
              x:      this.golfCourse_to.rect.x - this.golfCourse_to.rect.width * 0.30,
              y:      this.golfCourse_to.rect.y - this.golfCourse_to.rect.height * 0.15,
              width:  this.golfCourse_to.rect.width + this.golfCourse_to.rect.width * 0.60 / 1.0,
              height: this.golfCourse_to.rect.height + this.golfCourse_to.rect.height * 0.30 / 1.0,
            };
            // this.infiniteCanvas.show_rect(rect__makeshift);

            const cfg_anim__easy = {
              duration: 500,
            };
            this.infiniteCanvas.move_to_rect__animation(rect__makeshift, cfg_anim__easy);


            if (this.step_to == null) {
              // const step = GolfGameStep__Endless_Practice.randomInstance1(infiniteCanvas, golfCourse_to);
              const step = this.stepGeneratorFunc(golfCourse_to);
              this.step_to = step;
            }
            this.step_to.start();

            this.step_to.animate__showOrFade(true);

          }, 500);

        }


      }


      class GolfGameStep__Endless_Practice__frac_add {

        constructor(infiniteCanvas, golfStepConfig, golfCourse, stepGeneratorFunc) {

          this.infiniteCanvas = infiniteCanvas;
          // this.golfStepConfig = golfStepConfig;
          this.golfCourse = golfCourse;

          this.stepGeneratorFunc = stepGeneratorFunc;

          this.configure(golfStepConfig);

        }

        static randomInstance__frac_add(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_add();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
            // challengeType: "frac_add",
          };

          const step = new GolfGameStep__Endless_Practice__frac_add(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }



        configure(golfStepConfig) {
          // this.par = golfStepConfig.par;
          this.nb_attempts = 0;

          // this.challengeMathNodeConfig = golfStepConfig.challengeMathNodeConfig;
          this.challengeGMItemConfig = golfStepConfig.challengeGMItemConfig;
          // this.challengeType = golfStepConfig.challengeType;
        }

        start() {
          const golfCourse = this.golfCourse;
          const stepGeneratorFunc = this.stepGeneratorFunc;

          this.invest(golfCourse);

          this.possess(golfCourse);

          this.recurse(stepGeneratorFunc);

          // this.infiniteCanvas.redrawCanvas(RedrawOccasion.forceRedraw);   //SHU666:pour éviter les bugs de non rafraîchissement des teXFObj //ce n'est pas la panacée
        }

        end() {
          // this.golfCourse.fillHole();
          const step = this;
          const infiniteCanvas = this.infiniteCanvas;

          step.rep_free__hole.parts.touchSlot.fill = "yellow";

          //destroy ball
          const arr_rep_free_ball = [
            step["rep_free__ball" + 0],
            step["rep_free__ball" + 1],
          ];

          arr_rep_free_ball.forEach((rep_free__ball, i) => {

            //end curses
            rep_free__ball.parts.facade.curse_greenMouse_end();

            //remove "die" hooks listeners
            rep_free__ball.will["die"].listeners = [];

            //remove
            rep_free__ball.im_dying_now                   = true;
            rep_free__ball.parts.facade.im_dying_now      = true;
            rep_free__ball.parts.contactArea.im_dying_now = true;
          });

          if(step.rep_free__banner != null) {
            step.rep_free__banner.im_dying_now            = true;
          }


          //remove all listeners
          const touchSlot__rep_free = step.rep_free__hole.parts.touchSlot;
          const touchSlotEngine = touchSlot__rep_free.dict_engine["touchSlot"].engine;
          touchSlotEngine.awoken.did["touch"].off(this.listener_targetDidTouch);

        }

        addNewBall(index) {
          const step = this;
          const infiniteCanvas = this.infiniteCanvas;
          const golfCourse = this.golfCourse;

          // logger.log("golfCourse.components", golfCourse.components);
          const name__tee = "tee" + (index + 1);
          const icObj__tee = golfCourse.components[name__tee].icObj;
          const trueRect__ball = {
            x: icObj__tee.position.x,
            y: icObj__tee.position.y,
            width: 50,
            height: 50,
          };

          // const value = 0;
          //debug
          const gmItem__initial = step.challengeGMItemConfig.initial[index];
          const mathNode__initial = gmItem__initial.content;
          // const value = mathNode__initial.value;

          // const icObj = infiniteCanvas.createIcBornAgainGreenMouseBox(trueRect__ball, mathNode__initial);
          const icObj = infiniteCanvas.createIcGreenMouseBox(trueRect__ball, mathNode__initial);

          // const icObj = infiniteCanvas.createIcMathNode(trueRect__ball.x, trueRect__ball.y, mathNode__initial);

          infiniteCanvas.addIcObject(icObj);

          const rep_free__ball = infiniteCanvas.getRepresented(icObj.id).r_free();
          Hooker.installHooks(rep_free__ball, "die");

          const bornAgainFunc = () => {
            logger.log("did die");

            rep_free__ball.parts.facade.im_dying_now = true;
            rep_free__ball.parts.contactArea.im_dying_now = true;

            step.addNewBall(index);
          };
          rep_free__ball.did["die"].on(bornAgainFunc);
          rep_free__ball.bornAgainFunc = bornAgainFunc;

          step["rep_free__ball" + index] = rep_free__ball;
        }

        invest(golfCourse) {

          const step = this;
          const infiniteCanvas = this.infiniteCanvas;

          //clear: remove objects



          //furnish: add objects
          {
            const infiniteCanvas = this.infiniteCanvas;

            //add label/value: score
            function addLabel_score() {
              const rect__score = golfCourse.rect;
              rect__score.width = 300;
              rect__score.height = 150;

              const string__score = "score:";
              const value__score = 0;

              const icObj__score = infiniteCanvas.createIcLabelValue(rect__score, string__score, value__score);
              icObj__score.zIndex = 200;

              infiniteCanvas.addIcObject(icObj__score);

              const rep_free__score_valueLabel = infiniteCanvas.getRepresented(icObj__score.id).r_free();
              step.rep_free__score_valueLabel = rep_free__score_valueLabel;
              step.rep_free__score_value = rep_free__score_valueLabel.parts["value"];
            }
            // addLabel_score();

            //add label/value: par
            function addLabelValue_par() {
              const rect__par = {
                x: step.rep_free__score_valueLabel.position.x,
                y: step.rep_free__score_valueLabel.position.y + 120,
                width: 300,
                height: 150,
              };

              const string__par = "par:";
              const value__par = step.par;

              const icObj__par = infiniteCanvas.createIcLabelValue(rect__par, string__par, value__par);
              icObj__par.zIndex = 201;

              infiniteCanvas.addIcObject(icObj__par);

              const rep_free__par_valueLabel = infiniteCanvas.getRepresented(icObj__par.id).r_free();
              step.rep_free__par_valueLabel = rep_free__par_valueLabel;
              step.rep_free__par_value = rep_free__par_valueLabel.parts["value"];

              setTimeout(() => {
                step.rep_free__par_value.position = {
                  x: step.rep_free__score_value.position.x,
                  y: step.rep_free__par_value.position.y,
                };
              }, 20);   //SHU TODO: remove this ugliness
            }
            // addLabelValue_par();


            //add balls:
            step.addNewBall(0);
            step.addNewBall(1);


            //add button: restart


            //add button: impossible

          }


          //invest: "this is mine now"
          {
            // step.rep_free__ball = golfCourse.components["ball"].icObj;
            step.rep_free__hole = golfCourse.components["hole"].icObj;
          }


          //employ: now you do X
          //initial
          const arr_initial = step.challengeGMItemConfig.initial;
          arr_initial.forEach((gmItem__initial, index) => {
            const mathNode__initial = gmItem__initial.content;
            // logger.log("mathNode__initial", mathNode__initial);
            step["rep_free__ball" + index].mathNode = mathNode__initial;
          });

          //target
          const mathNode__target = step.challengeGMItemConfig.target.content;
          step.rep_free__hole.parts.facade.mathNode = mathNode__target;
          step.rep_free__hole.parts.touchSlot.fill = "";


          //operators
          {
            const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_fractionOne_operator");
            const arr_rep_free__operator = arr_gm_operator.map((gm_operator, i) => {
              const icObj__rep_free = gm_operator.icObj;
              return icObj__rep_free;
            });
            const arr_gmItem_operator = step.challengeGMItemConfig.operators;

            const arr_zipped = Utils.zip(arr_rep_free__operator, arr_gmItem_operator);

            arr_zipped.forEach(([rep_free__operator, gmItem_operator], i) => {


              //touchSlot
              const rep_free__touchSlot = rep_free__operator.parts["touchSlot"];

              const mathNodeTransformationFunc = gmItem_operator.content;
              const icObjTransformationFunc = (icObj) => {
                // logger.log("icObjTransformationFunc", icObj);
                var outIcObj;



                outIcObj = icObj.clone();
                // logger.log("outIcObj", outIcObj);

                if (outIcObj.mathNode) {
                  delete outIcObj.mathNode;     //SHU666: true sadness
                }



                if (icObj.cType == "gm_box") {
                  // logger.log("gm_box");

                  const facade = icObj.parts.facade;
                  outIcObj.parts.facade.mathNode = mathNodeTransformationFunc(facade.mathNode);
                }

                // if(icObj.mathNode != null) {
                //   // logger.log("icObj.mathNode", icObj.mathNode);
                //   outIcObj.mathNode = mathNodeTransformationFunc(icObj.mathNode);
                // }

                return outIcObj;
              };
              rep_free__touchSlot.touchSlotConfig.transformationFunc = icObjTransformationFunc;


              //facade
              const rep_free__facade = rep_free__operator.parts["facade"];
              // rep_free__facade.text = gmItem_operator.name;
              rep_free__facade.mathNode = gmItem_operator.specs.funcWrapper.semantics.operatorNode;

              rep_free__facade.originX = "center";

            });
          }

          //conductive operator
          {
            // rep_free__ball.did["die"].on(bornAgainFunc);
            // rep_free__ball.bornAgainFunc = bornAgainFunc;

            const arr_component_conductive_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_conductive_operator");
            const component__conductive_operator = arr_component_conductive_operator.find(e => true);

            const rep_free__conductive_operator = component__conductive_operator.icObj;

            logger.log("rep_free__conductive_operator", rep_free__conductive_operator);

            const rep_free__dropTouchSlot = rep_free__conductive_operator.parts.platform.parts.dropTouchSlot;

            const transformationFunc__touch = rep_free__dropTouchSlot.touchSlotConfig.transformationFunc__touch;
            const transformationFunc__touch__decorated = (icObj) => {
              var transformationOutput;

              logger.log("rep_free__dropTouchSlot, touch__decorated", icObj);

              // const rep_free__ball = icObj;
              // const bornAgainFunc = rep_free__ball.bornAgainFunc;
              // rep_free__ball.did["die"].off(bornAgainFunc);

              transformationOutput = transformationFunc__touch(icObj);

              return transformationOutput;
            };
            rep_free__dropTouchSlot.touchSlotConfig.transformationFunc__touch = transformationFunc__touch__decorated;

            const transformationFunc__untouch = rep_free__dropTouchSlot.touchSlotConfig.transformationFunc__untouch;
            const transformationFunc__untouch__decorated = (icObj) => {
              var transformationOutput;

              logger.log("rep_free__dropTouchSlot, untouch__decorated", icObj);

              transformationOutput = transformationFunc__untouch(icObj);

              // const rep_free__ball = icObj;
              // const bornAgainFunc = rep_free__ball.bornAgainFunc;
              // rep_free__ball.did["die"].on(bornAgainFunc);

              return transformationOutput;
            };
            rep_free__dropTouchSlot.touchSlotConfig.transformationFunc__untouch = transformationFunc__untouch__decorated;


          }


        }

        possess(golfCourse) {
          this.initializeCompletionListeners();

          this.setupAttemptListeners(golfCourse);

          this.setupCompletionTrigger(golfCourse);
          this.addCompletionListener(golfCourse);
        }

        recurse(stepGeneratorFunc) {
          const step = this;

          const segueConfig = {};
          const step_from = step;

          const golfCourse_to = step_from.golfCourse;

          const segue = new GolfGameSegue__Endless_Practice(infiniteCanvas, segueConfig, step_from, golfCourse_to, stepGeneratorFunc);

          this.segue = segue;
        }


        initializeCompletionListeners() {
          // this.nb_attempts = 0;
          this.arr_attempt = [];

          this.listeners_completed = [];

          this.onCompleted = (listener) => {
            this.listeners_completed.push(listener);
          };
          this.offCompleted = (listener) => {
            this.listeners_completed = Utils.arrayByRemovingElement(this.listeners_completed, listener);
          };
          this.nowCompleted = () => {
            this.listeners_completed.forEach((listener, i) => {
              listener(this);
            });
          };
        }

        setupAttemptListeners(golfCourse) {   //SHU: this is where BigBrother sneaked in from

          const step = this;

          // function waitForNewAttempt() {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   const createAttemptFunc = () => {
          //
          //       const attempt = new GolfStepAttempt();
          //
          //       step.arr_attempt.push(attempt);
          //
          //       ball__rep_free.offHold(createAttemptFunc);
          //   };
          //
          //   ball__rep_free.onHold(createAttemptFunc);
          // }
          //
          // //gm.onHold(create attempt)
          // {
          //   waitForNewAttempt();
          // }
          //
          // //gm.onTouched(add event to attempt)
          // {
          //
          // }
          //
          // //gm.onRelease(finalize attempt)
          // {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   ball__rep_free.onRelease(waitForNewAttempt);
          // }

          //create attempt






          //course use listeners

          function listenToOperatorTouches(icObj__rep_free) {

            const touchSlot__rep_free = icObj__rep_free.parts["touchSlot"];
            // logger.log("touchSlot__rep_free", touchSlot__rep_free);

            const touchSlotEngine = touchSlot__rep_free.dict_engine["touchSlot"].engine;

            Hooker.installHooks(touchSlotEngine.awoken, "touch");
            touchSlotEngine.awoken.did["touch"].on((...args) => {
              // logger.log("did touch", ...args);

              // // counter += 1
              // const attempt = step.getCurrentAttempt();
              // logger.log("attempt", attempt);
              // attempt.manoeuvre.nb_touched += 1;
              //
              // //debug
              // step.rep_free__score_value.text = "" + attempt.manoeuvre.nb_touched;



              // const rep_free__curseFacade = step.rep_free__hole.parts.curseFacade;
              const rep_free__curseFacade = step.rep_free__hole.parts.curseFacade;
              if (rep_free__curseFacade != null) {
                const rep_free__facade = step.rep_free__hole.parts.facade;
                rep_free__facade.curse_metamorphosis.curseTrigger.impulse();
              }


            });

          }

          const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_operator");

          arr_gm_operator.forEach((gm_operator, i) => {
            const icObj__rep_free = gm_operator.icObj;
            listenToOperatorTouches(icObj__rep_free);
          });

        }

        setupCompletionTrigger(golfCourse) {

          const targetTouchSlot__rep_free = golfCourse.components["hole"].icObj;

          const touchSlot__rep_free = targetTouchSlot__rep_free.parts["touchSlot"];

          const touchSlotEngine = touchSlot__rep_free.dict_engine["touchSlot"].engine;

          Hooker.installHooks(touchSlotEngine.awoken, "touch");
          const listener_targetDidTouch = (...args) => {
            // logger.log("did touch", ...args);

            this.nowCompleted();
          };
          this.listener_targetDidTouch = listener_targetDidTouch;
          touchSlotEngine.awoken.did["touch"].on(listener_targetDidTouch);

        }

        addCompletionListener(golfCourse) {

          const step = this;

          this.listener_onCompleted = (golfStep) => {
            // console.log("step, onCompleted", golfStep);
            // logger.log("step, onCompleted", golfStep);

            /*
            const score = golfStep.arr_attempts.length;
            golfCourse.mutateIntoScoreLabel(score);
            */

            step.offCompleted(step.listener_onCompleted);
            step.end();

            step.animate__showOrFade(false);

            step.segue.play(golfStep);
          };

          this.onCompleted(this.listener_onCompleted);
        }

        getCurrentAttempt() {
          return this.arr_attempt[this.arr_attempt.length - 1];
        }







      }



    </script>
    <script>
      globalsSingleton.functionCallsQueue.add(() => {
        // logger.log("logGolf", "practice", "infiniteCanvas:", infiniteCanvas);
        try {
          const dict_query_var = globalsSingleton.dict_query_var;
          logger.log("logGolf", "practice", "dict_query_var:", dict_query_var);
          if("challenge" in dict_query_var) {
            const route     = dict_query_var["challenge"];
            logger.log("logGolf", "practice", "route:", route);

            const challenge = GolfGame__Endless_Practice__Challenge.createChallengeForRoute(route);
            const cfg = {
              route:     route,
              challenge: challenge,
            };
            const golfGame__endless_practice = new GolfGame__Endless_Practice(infiniteCanvas, cfg);
          }
          
        } catch(e) {
          logger.log("logError", e);
        }
        
      });
    </script>






    <script>
      class Keyboard_Rx {
        constructor() {
          this.rx_keyUp = new Subject();
          document.addEventListener('keyup', (e) => {
            this.rx_keyUp.next(e);
          });
        }
      }
    </script>
    <script>
      const keyboard_Rx = new Keyboard_Rx();
    </script>





    <script>

      class Atelier__X_X {

        constructor(infiniteCanvas) {
          this.infiniteCanvas = infiniteCanvas;

          //convenience
          this.trueRect1 = {
            x: 100,
            y: 100,
            width:  100,
            height: 100,
          }; 

          this.trueRect2 = {
            x: 800,
            y: 150,
            width:  100,
            height: 100,
          }; 

          this.trueRect3 = {
            x: 100,
            y: 800,
            width:  100,
            height: 100,
          }; 

          this.trueRect4 = {
            x: 800,
            y: 950,
            width:  100,
            height: 100,
          }; 

          // this.debug1();
          // this.debug2();

          // this.debug_countdown_1();

          // this.debug_colored_tex();

          // this.debug_rich_wedding();

          // this.debug_splitter_sptl();
          // this.debug_splitter_spf();

          // this.debug_composite_mutation();
          // this.debug_morpher();

          // this.debug_exoSkeleton();
          // this.debug_exoSkeleton2();

          // this.debug_octomouse();

          //--fractions--
          // this.debug_decomp_product_primes();
          // this.debug_inverse();
          // this.debug_simplify_singleoperatorize();
          // this.debug_simplify_topPriorityShell();

          // this.debug_dropTouchSlot();
          // this.debug_platform();
          // this.debug_conductive_operator();
          // this.debug_fractionOne_operator();
          // this.debug_fractionOne_operator__showcase();

          // this.debug_conductive_compositing();

          // this.debug__fraction_simplification__edudemo1();
          // this.debug__fraction_simplification__edudemo2();
          // this.debug_gmSafetyZone();

          // this.debug_number_reification();
          // this.debug_bloom();
          // this.debug_bloom__fraction_bar_bloom();


          // this.debug__tts();
          // this.debug__stt();


          // this.debug_simplify_litexp();

          // this.debug_edudemo_mario_and_mushrooms();    //mario
          // this.debug_clone();
          // this.debug_unitCloneScale();

          // this.debug_slice_image();

          // this.debug_recording();
          // this.debug_geminiShade();
          // this.debug_triggeredPathmade();
          // this.debug_compositeAsArgument();

          // this.debug_random();

          // this.debug_pathSeams();

          // this.debug_points();
          // this.debug_circles_ellipses_and_arcs();
          //this.debug_progress_marker();

          // this.debug_decomp_prime_disks();

          // this.debug_hexagon();
          // this.debug_hexagon_grid1();
          // this.debug_hexagon_grid2();
          // this.debug_hexagon_fun();

          // this.debug_povs();
          // this.debug_povs_2();
          // this.debug_povs_3();

          // this.debug_qrcode_1();
          // this.debug_qrcode_2();

          // this.debug_video();

          // this.debug_gemini();

          // this.debug_number_line();

          // this.debug_composite_of_composite();



          // this.debug_remoteControl();
          // this.debug_grid_maze();

          // this.debug_vibrating_segment();

          // this.debug_composite_segment();

          // this.debug_uniformSConveyor();


          // this.debug_workbench_image();

          // this.debug_zScroll_composite();
          
          //this.debug_zIndexFreeDrawing();

          // this.debug_fObjOverlapping();

          // this.debug_composite_contentAndParts();

          // this.debug_touch();

          // this.debug_decoration();

          // this.debug_zSegment();
          // this.debug_icPolygon();

          // this.debug_bigText();

          // this.debug_intersection();

          try {
            // this.debug_complexNumbers();

            // this.debug_coordSystem();

            // this.debug_gradient();
            // this.debug_gradient2();

            // this.debug_varSlot();

            // this.debug_anonymousFunction();

            // this.debug_apl();

            // this.debug_applicableOperator();

            // this.debug_anon5050Function();

            // this.debug_icArray();

            // this.debug_default_content();

            // this.debug_printPovRect();

            // this.debug_dive_op();
            // this.debug_innerCam();
            // this.debug_transportation();
            // this.debug_portal();

            // this.debug_curve3();
            // this.debug_zcurve3();

            // this.debug_awaiting_operator();
            // this.debug_sleepingArgs_operator();

            // this.debug_numberTyping(); 

            // this.debug_touchHook();

            // this.debug_buttonConfig();

            // this.debug_pyramidOfOperators();

            // this.debug_generator();

            // this.debug_operator_cloning();

            // this.debug_ghost();

            // this.debug_neveremptiness();
            // this.debug_nevercompleteness();

            // this.debug_ioPasteScroll();  // :(
            // this.debug_batchPasteScroll();

            // this.debug_stickerStroke();
            // this.debug_selection();

            // this.debug_freeDrawingApply();
            
            // this.debug_biPlatform();
            // this.debug_shiftPositionAndScale();

            // this.debug_fun();

          } catch(e) {
            logger.log("logError", e);
          }

          


          // this.debug_th();

          // this.debug_startingScreen();
        }


        //convenience methods

        spawnRectGrid(config__grid_in) {

          var config__grid;
          if(config__grid_in != null) {
            config__grid = config__grid_in;
          } else {
            const config__grid__default = {
              position: {
                x: 100,
                y: 100,
              },
              size__childRect: {
                width:  200,
                height: 200,
              },
              spacing: {
                X: 100,
                Y: 100,
              },
              nb_rows: 4,
              nb_cols: 4,
            };
            config__grid = config__grid__default;
          }

          function createRectWith_gridRowCol_and_zIndex(row, col, zIndex, config__grid) {
              const trueRect = {
                x:      config__grid.position.x + col * config__grid.size__childRect.width  + (col * config__grid.spacing.X),
                y:      config__grid.position.y + row * config__grid.size__childRect.height + (row * config__grid.spacing.Y),
                width:  config__grid.size__childRect.width,
                height: config__grid.size__childRect.height,
              };
              const icRect = infiniteCanvas.createIcRect(trueRect);

              icRect.zIndex = zIndex;
              icRect.fill = ColorUtils.randomColor();

              return icRect;
          }


          [...new Array(config__grid.nb_rows).keys()].forEach((row) => {
            [...new Array(config__grid.nb_cols).keys()].forEach((col) => {
              const zIndex = 1 + 4 * row + col; 
              const icRect = createRectWith_gridRowCol_and_zIndex(row, col, zIndex, config__grid);
              infiniteCanvas.addIcObject(icRect);
            })            
          });

        }




        debug1() {

          const infiniteCanvas = this.infiniteCanvas;

          //create targetTouchSlot
          const trueRect_2 = {
            x: 1000,
            y: 500,
            width: 100,
            height: 100,
          };
          const icTargetTouchSlot = infiniteCanvas.createIcGMTargetTouchSlot(trueRect_2, {targetValue: 12});
          infiniteCanvas.addIcObject(icTargetTouchSlot);


          //create var
          const trueRect_1 = {
            x: 500,
            y: 500,
            width: 100,
            height: 100,
          };
          const mathNode = new math.SymbolNode("x");
          const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
          icMathNode.isTouchable = true;
          infiniteCanvas.addIcObject(icMathNode);
        }

        debug2() {

          const infiniteCanvas = this.infiniteCanvas;

          //create icGreenMouseBox
          const trueRect_2 = {
            x: 1000,
            y: 500,
            width: 100,
            height: 100,
          };
          const icGreenMouseBox = infiniteCanvas.createIcGreenMouseBox(trueRect_2, new math.ConstantNode(12));
          // icGreenMouseBox.shouldAlsoRemoveChildren = true;
          infiniteCanvas.addIcObject(icGreenMouseBox);

          setTimeout(() => {
            const represented = infiniteCanvas.getRepresented(icGreenMouseBox.id);
            logger.log("represented", represented);
            represented.r_free().im_dying_now = true;
            represented.r_free().parts.facade.im_dying_now = true;
            represented.r_free().parts.contactArea.im_dying_now = true;
          }, 1000);

        }

        debug_countdown_1() {

          const infiniteCanvas = this.infiniteCanvas;

          //create icGreenMouseBox
          const trueRect = {
            x: 1000,
            y: 500,
            width: 100,
            height: 100,
          };
          // const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2, new math.ConstantNode(12));
          const mathNode = new math.ConstantNode(12);
          const icMathNode = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
          // infiniteCanvas.addIcObject(icMathNode);

          const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "0");
          // infiniteCanvas.addIcObject(icMathNode);

          const parts = {
            curseFacade: icText,
            mathNode: icMathNode,
          };

          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
          const icComposite = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);

          infiniteCanvas.addIcObject(icComposite);



          const facade_represented = infiniteCanvas.getRepresented(icMathNode.id);
          const facade_rep_free = facade_represented.r_free();

          // const countDownTrigger = infiniteCanvas.createCurseTrigger_countdown();
          infiniteCanvas.accurse__metamorphosis(facade_rep_free);

          const curseFunc = () => {
            logger.log("curseFunc, rep_free:", facade_rep_free);
            const mathNode = random_constantNode();
            facade_rep_free.mathNode = mathNode;
            facade_rep_free.curse_metamorphosis.reset();
          };
          facade_rep_free.curse_metamorphosis.curseFunc = curseFunc;



          facade_rep_free.curse_metamorphosis.start();


          //debug?
          // keyboard_Rx.rx_keyUp.subscribe({
          //   next: (e) => {
          //     logger.log("e",e);
          //
          //     switch(e.code) {
          //       case "Numpad1":
          //         facade_rep_free.curse_metamorphosis.curseTrigger.impulse();
          //         break;
          //     }
          //
          //   },
          // });






          const composite_represented = infiniteCanvas.getRepresented(icComposite.id);
          const composite_rep_free = composite_represented.r_free();
          const curseFacade_rep_free = composite_rep_free.parts.curseFacade;

          const curseTrigger = facade_rep_free.curse_metamorphosis.curseTrigger;
          logger.log("curseTrigger", curseTrigger);

          // Hooker.installHooks(curseTrigger, "impulse");
          // curseTrigger.did["impulse"].on(() => {
          // logger.log("did impulse");
          // const countDownEngine = curseTrigger.engine;
          // const counter         = countDownEngine.getCounter();
          // curseFacade_rep_free.text = "" + counter;
          // });


          // facade_rep_free.curse_metamorphosis.start();

          facade_rep_free.curse_metamorphosis.rx_countDownCounter.subscribe({
            next: (value) => {
              logger.log("rx_countDownCounter, next", value);
              logger.log("curseFacade_rep_free", curseFacade_rep_free);

              curseFacade_rep_free.text = "" + value;
              // facade_rep_free.mathNode = new math.ConstantNode(value);
            },
          });


        }


        debug_colored_tex() {

          const infiniteCanvas = this.infiniteCanvas;

          function addRichMathNode() {

            const trueRect = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(123456790);
            const richMathNode = new RichMathNode(mathNode);
            // richMathNode.rich.colorMode = "plain";
            richMathNode.rich.colorMode = "xylophone";
            // richMathNode.rich.colorMode = "evenodd";

            richMathNode.rich.color = "red";


            // const icMathNode = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
            // infiniteCanvas.addIcObject(icMathNode);

            // const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "0");

            // const richMathNodeConfig = {
            //   mathNode: mathNode,
            //   color: "blue",
            // };
            const icRichMathNode = infiniteCanvas.createIcRichMathNode(trueRect.x, trueRect.y, richMathNode);

            infiniteCanvas.addIcObject(icRichMathNode);
          }

          addRichMathNode();

        }

        debug_rich_wedding() {

          const infiniteCanvas = this.infiniteCanvas;

          function addRichMathNode(trueRect, value, colorMode) {

            const mathNode = new math.ConstantNode(value);
            const richMathNode = new RichMathNode(mathNode);
            // richMathNode.rich.colorMode = "plain";
            richMathNode.rich.colorMode = colorMode;
            // richMathNode.rich.colorMode = "evenodd";

            richMathNode.rich.color = "red";


            // const icMathNode = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
            // infiniteCanvas.addIcObject(icMathNode);

            // const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "0");

            // const richMathNodeConfig = {
            //   mathNode: mathNode,
            //   color: "blue",
            // };
            const icRichMathNode = infiniteCanvas.createIcRichMathNode(trueRect.x, trueRect.y, richMathNode);

            infiniteCanvas.addIcObject(icRichMathNode);
          }

          const trueRect_1 = {
            x: 1000,
            y: 500,
            width: 100,
            height: 100,
          };
          const trueRect_1bis = {
            x: trueRect_1.x,
            y: trueRect_1.y + 50,
            width: trueRect_1.width,
            height: trueRect_1.height,
          };
          const trueRect_2 = {
            x: 1500,
            y: 500,
            width: 100,
            height: 100,
          };

          addRichMathNode(trueRect_1, 10023456, "xylophone");
          addRichMathNode(trueRect_1bis, 10023456, "fullplain");

          // addRichMathNode(trueRect_2, 10023456, "plain");

          // addRichMathNode(trueRect_2,  51, "evenOdd");


        }

        debug_splitter_sptl() {

        }

        debug_splitter_spf() {

          //create splitter
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "split__top_layer");
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create joiner
          {
            const trueRect_2 = {
              x: 1300,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "join__top_layer");
            infiniteCanvas.addIcObject(gmOperator);
          }


          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const mathNode = random_onion_mathNode(3);
            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

        }

        debug_composite_mutation() {

          const infiniteCanvas = this.infiniteCanvas;

          //create composite
          const trueRect_0 = {
            x: 200,
            y: 200,
            width: 100,
            height: 100,
          };

          const parts = [];
          const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
          const icComposite = infiniteCanvas.createIcComposite(trueRect_0, parts, compositeConfig);
          infiniteCanvas.addIcObject(icComposite);

          const rep_free__composite = infiniteCanvas.getRepresented(icComposite.id).r_free();
          rep_free__composite.fill = "lightgrey";
          // rep_free.isSupervessel = true;
          logger.log("rep_free__composite.compositeConfig", rep_free__composite.compositeConfig);


          function addMathNode(rep_free__composite) {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const mathNode = new math.SymbolNode("12");
            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);

            const rep_free__mathNode = infiniteCanvas.getRepresented(icMathNode.id).r_free();

            // rep_free__composite.addPart(rep_free__mathNode);
            // rep_free__composite.engine.addPart(rep_free__mathNode);
            rep_free__composite.dict_engine["composite"].engine.awoken.addPart(rep_free__mathNode);      //SHU: un peu de vomi

            return rep_free__mathNode;
          }

          function addRect(rep_free__composite) {
            const trueRect = {
              x: 700,
              y: 700,
              width: 100,
              height: 100,
            };
            const icRect = infiniteCanvas.createIcRect(trueRect);
            infiniteCanvas.addIcObject(icRect);

            const rep_free__rect = infiniteCanvas.getRepresented(icRect.id).r_free();
            rep_free__rect.fill = "yellow";

            const miniDict = {
              [rep_free__rect.id]: rep_free__rect,
            };

            rep_free__composite.parts = Object.assign({}, rep_free__composite.parts, miniDict);
          }


          setTimeout(() => {

            const rep_free__mathNode = addMathNode(rep_free__composite);
            // addRect(rep_free__composite);

            setTimeout(() => {

              rep_free__composite.dict_engine["composite"].engine.awoken.removePart(rep_free__mathNode);

              setTimeout(() => {

                rep_free__composite.dict_engine["composite"].engine.awoken.addPart(rep_free__mathNode);

              }, 2000);

            }, 2000);

          }, 2000);

        }

        debug_morpher() {

          const infiniteCanvas = this.infiniteCanvas;

          // //create supervessel
          // {
          //   const trueRect_0 = {
          //     x: 200,
          //     y: 200,
          //     width: 100,
          //     height: 100,
          //   };
          //
          //   const parts           = [];
          //   const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
          //   const icComposite     = infiniteCanvas.createIcComposite(trueRect_0, parts, compositeConfig);
          //   infiniteCanvas.addIcObject(icComposite);
          //
          //   const rep_free = infiniteCanvas.getRepresented(icComposite.id).r_free();
          //   rep_free.fill = "lightgrey";
          //   rep_free.isSupervessel = true;
          // }



          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const mathNode = new math.ConstantNode(9);
            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create morpher
          {
            const trueRect_2 = {
              x: 1500,
              y: 100,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "morpher__math_to_text");
            infiniteCanvas.addIcObject(gmOperator);
          }
          {
            const trueRect_3 = {
              x: 1500,
              y: 600,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_3, "morpher__text_to_math");
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operators
          {
            const trueRect_2 = {
              x: 1500,
              y: 300,
              width: 100,
              height: 100,
            };
            const cfg__op = {
              text: "123",
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "t:append", cfg__op);
            infiniteCanvas.addIcObject(gmOperator);
          }
          {
            const trueRect_2 = {
              x: 1500,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"× 10"});
            infiniteCanvas.addIcObject(gmOperator);
          }
          {
            const trueRect_2 = {
              x: 1500,
              y: 1000,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "simplify:force");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_exoSkeleton() {

          const infiniteCanvas = this.infiniteCanvas;

          const trueRect_1 = {
            x: 500,
            y: 500,
            width: 100,
            height: 100,
          };
          // const icObj__heart = infiniteCanvas.createIcText(trueRect_1.x, trueRect_1.y, "heart");
          const icObj__heart = infiniteCanvas.createIcRect(trueRect_1);
          // infiniteCanvas.addIcObject(icText);


          const exoSkeletonConfig = {
            grab: {
              position_easy: "right",
            },
            contact: {
              position_easy: "bottom",
            },
            display: {
              position_easy: "center",
            },
            // heartArea:
          };

          const icExoSkeleton = infiniteCanvas.createIcExoSkeleton(icObj__heart, exoSkeletonConfig);
          infiniteCanvas.addIcObject(icExoSkeleton);


          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_fromText(trueRect_2, "+ 1");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_exoSkeleton2() {

          const infiniteCanvas = this.infiniteCanvas;

          const trueRect_1 = {
            x: 500,
            y: 500,
            width: 100,
            height: 100,
          };

          const icObj__member_1 = infiniteCanvas.createIcText(trueRect_1.x, trueRect_1.y, "2 + 2");
          // const icObj__equals   = infiniteCanvas.createIcText(trueRect_1.x, trueRect_1.y, "=");
          const icObj__member_2 = infiniteCanvas.createIcText(trueRect_1.x, trueRect_1.y, "5");

          const internalsObj = {
            "member_1": icObj__member_1,
            // "equals": icObj__center,
            "member_2": icObj__member_2,
          };
          // infiniteCanvas.addIcObject(icText);

          const exoSkeletonConfig = {
            internals: internalsObj,

            grab: {
              position_easy: "right_right",
            },

            member_1: {
              display: {
                position_easy: "left",
              },
              contact: {
                position_easy: "bottom_left",
              },
            },

            member_2: {
              display: {
                position_easy: "right",
              },
              contact: {
                position_easy: "bottom_right",
              },
            },


          };

          const icExoSkeleton = infiniteCanvas.createIcExoSkeleton(exoSkeletonConfig);
          infiniteCanvas.addIcObject(icExoSkeleton);


          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"+ 1"});
            infiniteCanvas.addIcObject(gmOperator);
          }

        }



        debug_octoMouse() {

        }


        debug_decomp_product_primes() {

          const infiniteCanvas = this.infiniteCanvas;

          //debug: multi factor
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            // const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(7), new math.ConstantNode(7), new math.ConstantNode(7)]);
            const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(120), new math.ConstantNode(7), new math.ConstantNode(7)]);


            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            const mathNode = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(8)]);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "decomposition__product_primes");
            infiniteCanvas.addIcObject(gmOperator);
          }


        }

        debug_inverse() {

          const infiniteCanvas = this.infiniteCanvas;

          //debug: multi factor
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            // const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(7), new math.ConstantNode(7), new math.ConstantNode(7)]);
            const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(120), new math.ConstantNode(7), new math.ConstantNode(7)]);


            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            const mathNode = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(8)]);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "inverse");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_simplify_singleoperatorize() {

          const infiniteCanvas = this.infiniteCanvas;

          //debug: multi factor
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            // const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(7), new math.ConstantNode(7), new math.ConstantNode(7)]);
            const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(120), new math.ConstantNode(7), new math.ConstantNode(7)]);


            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            const mathNode = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(8)]);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "singleOperatorize");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_simplify_topPriorityShell() {

          const infiniteCanvas = this.infiniteCanvas;

          //debug: multi factor
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            // const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(7), new math.ConstantNode(7), new math.ConstantNode(7)]);

            const mathNode_a = new math.ConstantNode(4);
            const mathNode_b = new math.ConstantNode(7);

            const mathNode = new math.OperatorNode("x", "multiply", [mathNode_a, mathNode_b, Inverser.inverse(mathNode_a), Inverser.inverse(mathNode_b)]);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "simplify__topPriorityShell");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_dropTouchSlot() {

          const infiniteCanvas = this.infiniteCanvas;

          //create platform
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 200,
              height: 200,
            };
            const icDropTouchSlot = infiniteCanvas.createIcDropTouchSlot(trueRect_2);
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icDropTouchSlot);
          }


          //mathNode1
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(4);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //mathNode2
          {
            const trueRect_2 = {
              x: 500,
              y: 700,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(7);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          // //create platform
          // {
          //   const trueRect_2 = {
          //     x: 1000,
          //     y: 1000,
          //     width: 200,
          //     height: 200,
          //   };
          //   const icDropTouchSlot = infiniteCanvas.createIcDropTouchSlot(trueRect_2);
          //   icDropTouchSlot.fill = "powderblue";
          //   // conductiveOperator.zIndex = -50;
          //   infiniteCanvas.addIcObject(icDropTouchSlot);
          // }

        }

        debug_platform() {

          const infiniteCanvas = this.infiniteCanvas;

          //create platform
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 200,
              height: 200,
            };
            const icPlatform = infiniteCanvas.createIcPlatform(trueRect_2);
            icPlatform.fill = "darkgray";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icPlatform);
          }

          //create platform2
          {
            const trueRect_2 = {
              x: 1000,
              y: 800,
              width: 200,
              height: 200,
            };
            const icPlatform = infiniteCanvas.createIcPlatform(trueRect_2);
            icPlatform.fill = "orange";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icPlatform);
          }



          //mathNode1
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(4);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //mathNode2
          {
            const trueRect_2 = {
              x: 500,
              y: 700,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(7);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //rect1
          {
            const trueRect_3 = {
              x: 200,
              y: 500,
              width: 100,
              height: 100,
            };

            const icRect = infiniteCanvas.createIcRect(trueRect_3);
            icRect.fill = "lime";
            icRect.isTouchable = true;
            infiniteCanvas.addIcObject(icRect);
          }




        }


        debug_conductive_operator() {

          const infiniteCanvas = this.infiniteCanvas;

          //create conductiveOperator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 200,
              height: 200,
            };
            const conductiveOperator = infiniteCanvas.createIcConductiveOperator(trueRect_2, "+");
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(conductiveOperator);
          }

          //create conductiveOperator2
          {
            const trueRect_2 = {
              x: 1000,
              y: 200,
              width: 200,
              height: 200,
            };
            const conductiveOperator = infiniteCanvas.createIcConductiveOperator(trueRect_2, "-");
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(conductiveOperator);
          }


          //mathNode1
          {
            const trueRect_1 = {
              x: 300,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(4);
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //mathNode2
          {
            const trueRect_2 = {
              x: 300,
              y: 700,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(7);
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //mathNode3
          {
            const trueRect_2 = {
              x: 600,
              y: 400,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("4/11");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //mathNode4
          {
            const trueRect_2 = {
              x: 600,
              y: 700,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("7/11");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //mathNode5
          {
            const trueRect_2 = {
              x: 600,
              y: 100,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("8/13");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


        }


        debug_fractionOne_operator() {

          const infiniteCanvas = this.infiniteCanvas;

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 200,
              height: 200,
            };
            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2);
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator2
          {
            const trueRect_2 = {
              x: 1000,
              y: 200,
              width: 200,
              height: 200,
            };

            const op = Operator.fromOpString_binary("/");
            const node_b = new math.ConstantNode(2);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }


          //mathNode1
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(4);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create conductiveOperator
          {
            const trueRect_2 = {
              x: 1500,
              y: 300,
              width: 200,
              height: 200,
            };
            const conductiveOperator = infiniteCanvas.createIcConductiveOperator(trueRect_2, "+");
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(conductiveOperator);
          }

        }

        debug_fractionOne_operator__showcase() {

          const infiniteCanvas = this.infiniteCanvas;

          // //create operator  [x1]
          // {
          //   const trueRect_2 = {
          //     x: 400,
          //     y: 700,
          //     width:  150,
          //     height: 150,
          //   };
          //
          //   const op     = Operator.fromOpString_binary("x");
          //   const node_b = new math.ConstantNode(2);
          //   const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);
          //
          //   const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
          //   icFractionOneOperator.fill = "ivory";
          //   // conductiveOperator.zIndex = -50;
          //   infiniteCanvas.addIcObject(icFractionOneOperator);
          // }

          //create operator  [x2 / x2]
          {
            const trueRect_2 = {
              x: 400,
              y: 700,
              width: 150,
              height: 150,
            };

            const op = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(2);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator  [/2 / /2]
          {
            const trueRect_2 = {
              x: 400,
              y: 100,
              width: 150,
              height: 150,
            };

            const op = Operator.fromOpString_binary("/");
            const node_b = new math.ConstantNode(2);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }


          //create operator  [x3 / x3]
          {
            const trueRect_2 = {
              x: 700,
              y: 700,
              width: 150,
              height: 150,
            };

            const op = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(3);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator  [/3 / /3]
          {
            const trueRect_2 = {
              x: 700,
              y: 100,
              width: 150,
              height: 150,
            };

            const op = Operator.fromOpString_binary("/");
            const node_b = new math.ConstantNode(3);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator  [x5 / x5]
          {
            const trueRect_2 = {
              x: 1000,
              y: 700,
              width: 150,
              height: 150,
            };

            const op = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(5);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator  [/5 / /5]
          {
            const trueRect_2 = {
              x: 1000,
              y: 100,
              width: 150,
              height: 150,
            };

            const op = Operator.fromOpString_binary("/");
            const node_b = new math.ConstantNode(5);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator  [x7 / x7]
          {
            const trueRect_2 = {
              x: 1300,
              y: 700,
              width: 150,
              height: 150,
            };

            const op = Operator.fromOpString_binary("x");
            const node_b = new math.ConstantNode(7);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }

          //create operator  [/7 / /7]
          {
            const trueRect_2 = {
              x: 1300,
              y: 100,
              width: 150,
              height: 150,
            };

            const op = Operator.fromOpString_binary("/");
            const node_b = new math.ConstantNode(7);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);

            const icFractionOneOperator = infiniteCanvas.createIcFractionOneOperator(trueRect_2, operatorNodeFactoryFuncWrapper);
            icFractionOneOperator.fill = "ivory";
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icFractionOneOperator);
          }



          //create conductiveOperator
          {
            const trueRect_2 = {
              x: 1500,
              y: 300,
              width: 300,
              height: 300,
            };
            const conductiveOperator = infiniteCanvas.createIcConductiveOperator(trueRect_2, "+");
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(conductiveOperator);
          }

          //create operator decomp:prpr
          {
            const trueRect_2 = {
              x: 2100,
              y: 300,
              width: 200,
              height: 200,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "decomposition__product_primes");
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create operator simplify_fraction
          {
            const trueRect_2 = {
              x: 2500,
              y: 650,
              width: 200,
              height: 200,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "simplify__fraction");
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }


          const arr_primes = [2, 3, 5, 7];

          const str__frac1 = "" + Utils.randomElementInArray(arr_primes) + "/" + Utils.randomElementInArray(arr_primes);
          const mathNode__frac1 = math.parse(str__frac1);

          const str__frac2 = "" + Utils.randomElementInArray(arr_primes) + "/" + Utils.randomElementInArray(arr_primes);
          const mathNode__frac2 = math.parse(str__frac2);

          //mathNode1
          {
            const trueRect_1 = {
              x: 100,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = mathNode__frac1.cloneDeep();

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //mathNode2
          {
            const trueRect_1 = {
              x: 100,
              y: 600,
              width: 100,
              height: 100,
            };

            const mathNode = mathNode__frac2.cloneDeep();

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }




          //mathNode1 display
          {

            {
              const trueRect_1 = {
                x: 1600,
                y: 1000,
                width: 100,
                height: 100,
              };

              const mathNode = mathNode__frac1.cloneDeep();

              const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
              icMathNode.isTouchable = true;
              infiniteCanvas.addIcObject(icMathNode);
            }

            {
              const trueRect_plus = {
                x: 1650,
                y: 1050,
                width: 100,
                height: 100,
              };

              const icText__plus = infiniteCanvas.createIcText(trueRect_plus.x, trueRect_plus.y, "+");
              infiniteCanvas.addIcObject(icText__plus);
            }

            {
              const trueRect_2 = {
                x: 1800,
                y: 1000,
                width: 100,
                height: 100,
              };

              const mathNode = mathNode__frac2.cloneDeep();

              const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
              icMathNode.isTouchable = true;
              infiniteCanvas.addIcObject(icMathNode);
            }

            {
              const trueRect_equals = {
                x: 1900,
                y: 1050,
                width: 100,
                height: 100,
              };

              const icText__equals = infiniteCanvas.createIcText(trueRect_equals.x, trueRect_equals.y, "=");
              infiniteCanvas.addIcObject(icText__equals);
            }



          }




        }


        debug_conductive_compositing() {


          //create conductiveCompositingOperator
          {
            const trueRect_2 = {
              x: 1000,
              y: 300,
              width: 200,
              height: 200,
            };
            const conductiveCompositingOperator = infiniteCanvas.createIcConductiveCompositingOperator(trueRect_2);
            infiniteCanvas.addIcObject(conductiveCompositingOperator);
          }




          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 700,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"+ 1"});
            gmOperator.isTouchable = false;
            Object.values(gmOperator.parts).forEach((icObj__part, i) => {
              logger.log("icObj__part:", icObj__part);
              icObj__part.isTouchable = false;
            });

            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1200,
              y: 700,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"x 2"});
            infiniteCanvas.addIcObject(gmOperator);
          }



          // //create conductiveOperator
          // {
          //   const trueRect_2 = {
          //     x: 1500,
          //     y: 300,
          //     width: 300,
          //     height: 300,
          //   };
          //   const conductiveOperator = infiniteCanvas.createIcConductiveOperator(trueRect_2, "+");
          //   // conductiveOperator.zIndex = -50;
          //   infiniteCanvas.addIcObject(conductiveOperator);
          // }



          //mathNode2
          {
            const trueRect_2 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(7);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }



        }






        debug__fraction_simplification__edudemo1() {

          //create operator decomp:prpr
          {
            const trueRect_2 = {
              x: 50,
              y: 200,
              width: 200,
              height: 200,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "decomposition__product_primes");

            infiniteCanvas.onceOnAddRepresentedForIcObject(icGMOperator, (icGMOperator) => {

              const rep_free__operator = infiniteCanvas.getRepresented(icGMOperator.id).r_free();
              const rep_free__facade = rep_free__operator.parts.facade;
              rep_free__facade.text = "Décomposer";

            });

            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create operator simplify_fraction
          {
            const trueRect_2 = {
              x: 1000,
              y: 200,
              width: 200,
              height: 200,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "simplify__fraction");

            infiniteCanvas.onceOnAddRepresentedForIcObject(icGMOperator, (icGMOperator) => {

              const rep_free__operator = infiniteCanvas.getRepresented(icGMOperator.id).r_free();
              const rep_free__facade = rep_free__operator.parts.facade;
              rep_free__facade.text = "Simplifier";

            });

            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }
        }


        debug__fraction_simplification__edudemo2() {

          {
            const trueRect_2 = {
              x: 300,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = new MySummerNode(1);
            logger.log("mathNode", mathNode);
            mathNode.isSlashed = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          {
            const trueRect_2 = {
              x: 300,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new MySummerNode(3);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2.x, trueRect_2.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }



          //create icTex with strikethrough
          {
            const trueRect_tex = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };

            const icTex = infiniteCanvas.createIcTex(trueRect_tex.x, trueRect_tex.y, "\\not {2}");

            infiniteCanvas.addIcObject(icTex);
          }

        }


        debug_gmSafetyZone() {

          const infiniteCanvas = this.infiniteCanvas;

          //create safetyZone
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 200,
              height: 200,
            };
            const icGMSafetyZone = infiniteCanvas.createIcGMSafetyZone(trueRect_2);
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMSafetyZone);
          }

          //create greenMouse
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(4);

            const icBornAgainGreenMouse = infiniteCanvas.createIcBornAgainGreenMouse(trueRect_1, mathNode);
            icBornAgainGreenMouse.isTouchable = true;
            infiniteCanvas.addIcObject(icBornAgainGreenMouse);
          }


        }

        debug_number_reification() {

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"+ 1"});
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"x 2"});
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create MNReictangle
          {
            const trueRect_2 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const mathNode = new math.ConstantNode(1);
            const mnReictangle = infiniteCanvas.createIcMNReictangle(trueRect_2.x, trueRect_2.y, mathNode);
            infiniteCanvas.addIcObject(mnReictangle);
          }

        }

        debug_bloom() {

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"+ 1"});
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"x 2"});
            infiniteCanvas.addIcObject(gmOperator);
          }


          //create bloom
          {
            // const mathNode = new math.ConstantNode(1);
            const mathNode = math.parse("1");
            mathNode.autoSimplify = true;

            const rxSubject = new Subject(mathNode);

            //create icMathNode
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);

            infiniteCanvas.onceOnAddRepresentedForIcObject(icMathNode, (icMathNode) => {

              const rep_free = infiniteCanvas.getRepresented(icMathNode.id).r_free();

              rep_free.onInnerUpdate((rep_free, propName, oldValue, newValue) => {
                logger.log("icMathNode, rep_free.onInnerUpdate", propName);

                if (propName == "mathNode") {
                  logger.log("icMathNode.onInnerUpdate, mathNode", propName, newValue);

                  const mathNode = newValue;
                  rxSubject.next(mathNode);
                }

              });

            });

            // infiniteCanvas.addIcObject(icMathNode);



            //create MNReictangle
            const trueRect_2 = {
              x: 500,
              y: 600,
              width: 100,
              height: 100,
            };
            const length_unit = 100;
            const icMNReictangle = infiniteCanvas.createIcMNReictangle(trueRect_2.x, trueRect_2.y, mathNode, length_unit);
            // icMNReictangle.isTouchable = true;
            icMNReictangle.fill = "orange";
            icMNReictangle.isSharpRect = true;

            // infiniteCanvas.addIcObject(icMNReictangle);


            const engine = new FacetEngine();
            const eType = "facet_mnrei_rectangle";
            const icEngined = infiniteCanvas.installEngineOnIcObj(icMNReictangle, eType, engine);

            // const rxSubject = new Subject(mathNode);
            icEngined.rxObservable = rxSubject.asObservable();
            icEngined.reactFunc = function (facet, nextObj) {
              logger.log("reactFunc", nextObj);
              facet.mathNode = nextObj.clone();
            };
            // infiniteCanvas.addIcObject(icEngined);



            //create MNReictangle
            const trueRect_3 = {
              x: 500,
              y: 630,
              width: 100,
              height: 100,
            };
            const icMNReictangle__unit = infiniteCanvas.createIcMNReictangle(trueRect_3.x, trueRect_3.y, mathNode, length_unit);
            // icMNReictangle.isTouchable = true;
            icMNReictangle__unit.fill = "black";
            icMNReictangle__unit.isSharpRect = true;



            //makeshift bloom
            const parts = {
              "mathNode": icMathNode,
              "reictangle": icEngined,
              "reictangle_unit": icMNReictangle__unit,
            };

            const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

            const icComposite = infiniteCanvas.createIcComposite(trueRect_1, parts, compositeConfig);
            icComposite.cType = "makeshiftBloom";
            icComposite.fill = "";

            infiniteCanvas.addIcObject(icComposite);

          }

        }

        debug_bloom__fraction_bar_bloom() {

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"+ 1"});
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"x 2"});
            infiniteCanvas.addIcObject(gmOperator);
          }


          //create bloom
          {
            // const mathNode = new math.ConstantNode(1);
            const mathNode = math.parse("1/7");
            mathNode.autoSimplify = true;

            const rxSubject = new Subject(mathNode);

            //create icMathNode
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);

            infiniteCanvas.onceOnAddRepresentedForIcObject(icMathNode, (icMathNode) => {

              const rep_free = infiniteCanvas.getRepresented(icMathNode.id).r_free();

              rep_free.onInnerUpdate((rep_free, propName, oldValue, newValue) => {
                logger.log("icMathNode, rep_free.onInnerUpdate", propName);

                if (propName == "mathNode") {
                  logger.log("icMathNode.onInnerUpdate, mathNode", propName, newValue);

                  const mathNode = newValue;
                  rxSubject.next(mathNode);
                }

              });

            });

            // infiniteCanvas.addIcObject(icMathNode);



            //create MNReictangle
            const trueRect_2 = {
              x: 454,
              y: 579,
              width: 100,
              height: 100,
            };
            const length_unit = 73;
            const icMNReictangle = infiniteCanvas.createIcMNReictangle(trueRect_2.x, trueRect_2.y, mathNode, length_unit);
            // icMNReictangle.isTouchable = true;
            icMNReictangle.fill = "orange";
            icMNReictangle.isSharpRect = true;

            // infiniteCanvas.addIcObject(icMNReictangle);


            const engine = new FacetEngine();
            const eType = "facet_mnrei_rectangle";
            const icEngined = infiniteCanvas.installEngineOnIcObj(icMNReictangle, eType, engine);

            // const rxSubject = new Subject(mathNode);
            icEngined.rxObservable = rxSubject.asObservable();
            icEngined.reactFunc = function (facet, nextObj) {
              logger.log("reactFunc", nextObj);
              facet.mathNode = nextObj.clone();
            };
            // infiniteCanvas.addIcObject(icEngined);



            //makeshift bloom
            const parts = {
              "mathNode": icMathNode,
              "reictangle": icMNReictangle,
            };

            const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

            const icComposite = infiniteCanvas.createIcComposite(trueRect_1, parts, compositeConfig);
            icComposite.cType = "makeshiftBloom";
            icComposite.fill = "";

            infiniteCanvas.addIcObject(icComposite);

          }

        }

        debug__tts() {

        }

        debug__stt() {
          var SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
          var recognition = new SpeechRecognition();

          recognition.continuous = true;

          recognition.onend = function () {
            recognition.start();
          }

          recognition.onresult = function (event) {
            var current = event.resultIndex;
            var transcript = event.results[current][0].transcript;
            speak(transcript)
          }

          recognition.start();
        }


        debug_simplify_litexp() {

          //create operator simplify_fraction
          {
            const trueRect_2 = {
              x: 2500,
              y: 650,
              width: 200,
              height: 200,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "simplify__topPriorityShell");
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //mathNode1
          {
            const trueRect_1 = {
              x: 100,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("(((x + 1) * 2) / 3) / 2");

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

        }


        debug_edudemo_mario_and_mushrooms() {

          //create image
          {
            const trueRect_2 = {
              x: 100,
              y: 300,
              width: 100,
              height: 100,
            };

            const img__file_p = FileIntegration.imageFromImgSrc_p("img/m&m/peach_detouree_cellshadee.png");
            const img_p = img__file_p;

            img_p.then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_2.x, trueRect_2.y, img);
              // icObj_front.scale.X = 1.5;
              // icObj_front.scale.Y = 1.5;

              icObj_front.isTouchable = false;

              infiniteCanvas.addIcObject(icObj_front);
            });
          }


          //create image
          {
            const trueRect_2 = {
              x: 300,
              y: 300,
              width: 100,
              height: 100,
            };

            const img__file_p = FileIntegration.imageFromImgSrc_p("img/m&m/mario_standing__boxed.png");
            const img_p = img__file_p;

            img_p.then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_2.x, trueRect_2.y, img);
              icObj_front.scale.X = 0.25;
              icObj_front.scale.Y = 0.25;

              icObj_front.isTouchable = false;

              infiniteCanvas.addIcObject(icObj_front);
            });
          }

          //create rect
          {
            const trueRect_2 = {
              x: 100,
              y: 800,
              width: 100,
              height: 100,
            };

            const icObj_front = infiniteCanvas.createIcRect(trueRect_2);
            icObj_front.isTouchable = false;
            icObj_front.fill = "lightgreen";

            infiniteCanvas.addIcObject(icObj_front);
          }


          //create x2 vert operator
          {
            const trueRect = {
              x: 500,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "vert",
              operation: "x 2",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create /2 vert operator
          {
            const trueRect = {
              x: 500,
              y: 300,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "vert",
              operation: "/ 2",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }


          //create x2 horiz operator
          {
            const trueRect = {
              x: 1300,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "horiz",
              operation: "x 2",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create /2 horiz operator
          {
            const trueRect = {
              x: 1300,
              y: 300,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "horiz",
              operation: "/ 2",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create /2 prop operator
          {
            const trueRect = {
              x: 1800,
              y: 300,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "prop",
              operation: "/ 2",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create x2 prop operator
          {
            const trueRect = {
              x: 1800,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "prop",
              operation: "x 2",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }



          //Thales
          //create x1.37 vert operator
          {
            const trueRect = {
              x: 500,
              y: 2500,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "vert",
              operation: "x 1.414",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create x1.37 horiz operator
          {
            const trueRect = {
              x: 1300,
              y: 2500,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "horiz",
              operation: "x 1.414",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:scale", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

        }

        debug_clone() {

          //create rect
          {
            const trueRect = {
              x: 100,
              y: 300,
              width: 100,
              height: 100,
            };
            const icObj = infiniteCanvas.createIcRect(trueRect);
            icObj.fill = "magenta";
            icObj.isTouchable = true;

            infiniteCanvas.addIcObject(icObj);
          }

          //create clone operator
          {
            const trueRect = {
              x: 500,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              nb_clones: 1,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:clone", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

        }

        debug_unitCloneScale() {

          //create image
          {
            const trueRect_2 = {
              x: -100,
              y: 300,
              width: 100,
              height: 100,
            };

            const img__file_p = FileIntegration.imageFromImgSrc_p("img/m&m/mario_standing__boxed.png");
            const img_p = img__file_p;

            img_p.then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_2.x, trueRect_2.y, img);
              icObj_front.isTouchable = true;

              infiniteCanvas.addIcObject(icObj_front);
            });
          }

          //create x3.77 horiz operator
          {
            const trueRect = {
              x: 500,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "horiz",
              operation: "x 3.77",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:ucscale", cfg);

            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create /3.77 horiz operator
          {
            const trueRect = {
              x: 500,
              y: 300,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "horiz",
              operation: "/ 3.77",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:ucscale", cfg);

            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }


          //create x(-1.59) vert operator
          {
            const trueRect = {
              x: 1300,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "vert",
              operation: "x (-1.59)",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:ucscale", cfg);
            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create /(-1.59) vert operator
          {
            const trueRect = {
              x: 1300,
              y: 300,
              width: 100,
              height: 100,
            };

            const cfg = {
              mode: "vert",
              operation: "/ (-1.59)",
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:ucscale", cfg);

            // conductiveOperator.zIndex = -50;
            infiniteCanvas.addIcObject(icGMOperator);
          }


        }


        debug_slice_image() {

          //create image
          {
            const trueRect_2 = {
              x: 0,
              y: 0,
              width: 200,
              height: 200,
            };

            const img__file_p = FileIntegration.imageFromImgSrc_p("img/monokuma.png");
            // const dataURL_p = img__file_p.then((img) => {
            //   return FileIntegration.dataUrlForImgViaCanvas2_p(img);
            // });
            // const img__data_p = dataURL_p.then((dataURL) => {
            //   return FileIntegration.imageFromImgSrc_p(dataURL);
            // });

            // const img_p = img__data_p;
            const img_p = img__file_p;

            img_p.then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_2.x, trueRect_2.y, img);
              // icMathNode.isTouchable = true;
              infiniteCanvas.addIcObject(icObj_front);
            });

          }

        }

        debug_recording() {

          //create text
          {
            const trueRect = {
              x: 100,
              y: 100,
              width: 100,
              height: 100,
            };

            const string__greeting = "123";
            const icObj = infiniteCanvas.createIcText(trueRect.x, trueRect.y, string__greeting);
            icObj.isTouchable = true;

            // infiniteCanvas.onceOnAddRepresentedForIcObject(icObj, (icObj) => {
            //   const rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();
            //   rep_free.id = 1000;
            // });

            infiniteCanvas.addIcObject(icObj);
          }

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("0");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 400,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("14");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("x");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 800,
              y: 200,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"+ 1"});
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 800,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"+ 10"});
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1500,
              y: 200,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"x 2"});
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1500,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"x (-1)"});
            infiniteCanvas.addIcObject(gmOperator);
          }


        }

        debug_geminiShade() {

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("0");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;

            infiniteCanvas.onceOnAddRepresentedForIcObject(icMathNode, (icMathNode) => {

              const represented = infiniteCanvas.getRepresented(icMathNode.id);
              const rep_official = represented.r_official();
              // const rep_free     = represented.r_free();

              //create gemini shade
              const icGeminiShade = infiniteCanvas.createIcGeminiShade(rep_official);
              icGeminiShade.position = {
                x: icGeminiShade.position.x + 100,
                y: icGeminiShade.position.y + 100,
              };

              infiniteCanvas.addIcObject(icGeminiShade);

            });


            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 800,
              y: 200,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"+ 1"});
            infiniteCanvas.addIcObject(gmOperator);
          }

          // //create operator
          // {
          //   const trueRect_2 = {
          //     x: 800,
          //     y: 800,
          //     width: 100,
          //     height: 100,
          //   };
          //   const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 10");
          //   infiniteCanvas.addIcObject(gmOperator);
          // }
          //
          // //create operator
          // {
          //   const trueRect_2 = {
          //     x: 1500,
          //     y: 200,
          //     width: 100,
          //     height: 100,
          //   };
          //   const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "x 2");
          //   infiniteCanvas.addIcObject(gmOperator);
          // }
          //
          // //create operator
          // {
          //   const trueRect_2 = {
          //     x: 1500,
          //     y: 800,
          //     width: 100,
          //     height: 100,
          //   };
          //   const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "x (-1)");
          //   infiniteCanvas.addIcObject(gmOperator);
          // }


        }

        debug_triggeredPathmade() {

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("1");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;

            infiniteCanvas.addIcObject(icMathNode);
          }

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 600,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("2");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;

            infiniteCanvas.addIcObject(icMathNode);
          }


          //create operator
          {
            const trueRect_2 = {
              x: 800,
              y: 200,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"+ 1"});
            infiniteCanvas.addIcObject(gmOperator);
          }

          //create operator
          {
            const trueRect_2 = {
              x: 1500,
              y: 600,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "from_string", {str__operator:"x 2"});
            infiniteCanvas.addIcObject(gmOperator);
          }

        }


        debug_compositeAsArgument() {

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 300,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("1");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;

            infiniteCanvas.addIcObject(icMathNode);
          }

          //create icMathNode
          {
            const trueRect_1 = {
              x: 300,
              y: 600,
              width: 100,
              height: 100,
            };

            const mathNode = math.parse("2");
            mathNode.autoSimplify = true;

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;

            infiniteCanvas.addIcObject(icMathNode);
          }


          //create clone operator
          {
            const trueRect = {
              x: 500,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              nb_clones: 1,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "o:clone", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create objectAtIndex operator
          {
            const trueRect = {
              x: 1000,
              y: 1000,
              width: 100,
              height: 100,
            };

            const cfg = {
              index: 1,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "c:objectAtIndex", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create vessel operator
          {
            const trueRect = {
              x: 1000,
              y: 200,
              width: 100,
              height: 100,
            };

            const fColor = new fabric.Color("crimson");
            fColor.setAlpha(0.666);
            const rgbaColorString = fColor.toRgba();

            const cfg = {
              rgbaColorString: rgbaColorString,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "vessel", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create unvessel operator
          {
            const trueRect = {
              x: 1000,
              y: 600,
              width: 100,
              height: 100,
            };

            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "unvessel");
            infiniteCanvas.addIcObject(icGMOperator);
          }

          // //create operator
          // {
          //   const trueRect_2 = {
          //     x: 800,
          //     y: 200,
          //     width: 100,
          //     height: 100,
          //   };
          //   const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 1");
          //   infiniteCanvas.addIcObject(gmOperator);
          // }
          //
          // //create operator
          // {
          //   const trueRect_2 = {
          //     x: 1500,
          //     y: 600,
          //     width: 100,
          //     height: 100,
          //   };
          //   const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "x 2");
          //   infiniteCanvas.addIcObject(gmOperator);
          // }

        }

        debug_random() {

          //create random operator
          {
            const trueRect = {
              x: 1000,
              y: 200,
              width: 100,
              height: 100,
            };

            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "random");
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create rand_int operator
          {
            const trueRect = {
              x: 1000,
              y: 600,
              width: 100,
              height: 100,
            };

            const cfg = {
              min: 1,
              max: 100,
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "rand_int", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create rand_inArr operator
          {
            const trueRect = {
              x: 1500,
              y: 400,
              width: 100,
              height: 100,
            };

            const cfg = {
              arr_value: [1, 1, 1, 2, 2, 2, 2, 2, 2, 3],
            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "rand_inArr", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }

          //create rand_inBag operator
          {
            const trueRect = {
              x: 1500,
              y: 800,
              width: 100,
              height: 100,
            };

            const cfg = {

            };
            const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect, "rand_inBag", cfg);
            infiniteCanvas.addIcObject(icGMOperator);
          }



        }

        debug_pathSeams() {


        }

        debug_points() {

          //create rect
          {
            const trueRect = {
              x: 0,
              y: 0,
              width: 300,
              height: 400,
            };

            const icRect = infiniteCanvas.createIcRect(trueRect);
            icRect.cornerStyle = '';
            // icRect.rx = 0;
            // icRect.ry = 0;
            icRect.fill = "grey";
            icRect.strokeWidth = 0.1;
            icRect.stroke = "yellow";

            infiniteCanvas.addIcObject(icRect);
          }

          //create points
          {
            const arr_coords = [[0, 0], [300, 0], [300, 400], [0, 400]];

            arr_coords.forEach((item, i) => {
              const x = item[0];
              const y = item[1];
              const point = Geometry.createPoint(x, y);

              const icPoint = infiniteCanvas.createIcPoint(point);
              icPoint.pointType = "rect";
              // icPoint.pointType = "cross";
              infiniteCanvas.addIcObject(icPoint);

              /*
              const trueRect = {
                x:      point.x,
                y:      point.y,

                //bad precision: something small seen from short range
                // width:  0.05,
                // height: 0.05,

                //good precision: something big seen from afar
                width:  100,
                height: 100,
              };
              const icRect = infiniteCanvas.createIcRect(trueRect);
              icRect.isUsingCenterPosition = true;
              icRect.fill = "magenta";
              icRect.homeScale.X = 100;
              icRect.homeScale.Y = 100;
              infiniteCanvas.addIcObject(icRect);
              */


            });

          }



        }


        debug_circles_ellipses_and_arcs() {

          //create circle
          // {
          //   const pointCenter = {
          //     x: 200,
          //     y: 200,
          //   };
          //
          //   const radius = 100;
          //
          //   const cfg = {
          //     stroke: "red",
          //     fillColor:   "blue",
          //   };
          //
          //   const icCircle = infiniteCanvas.createIcCircle(pointCenter, radius, cfg);
          //   infiniteCanvas.addIcObject(icCircle);
          // }

          //create ellipse
          {
            const trueRect = {
              x: 500,
              y: 500,
              width: 300,
              height: 100,
            };

            const cfg = {
              stroke: "magenta",
              fillColor: "cyan",
            };

            const icEllipse = infiniteCanvas.createIcEllipse(trueRect, cfg);
            infiniteCanvas.addIcObject(icEllipse);

            // //create point on ellipse
            // {
            //   const rect = {
            //     left:   trueRect.x,
            //     top:    trueRect.y,
            //     width:  trueRect.width,
            //     height: trueRect.height,
            //   };
            //   const pointCenter = Geometry.getCenterPoint(rect);
            //   const rx = trueRect.width/2;
            //   const ry = trueRect.height/2;
            //
            //   //debug
            //   // [...Array(10).keys()].forEach((item, i) => {
            //   //   const pointOnEllipse = Geometry.pointOnEllipse__angleInDegrees(pointCenter, rx, ry, 0 + i * 15);
            //   //
            //   //   {
            //   //     const icPoint = infiniteCanvas.createIcPoint(pointOnEllipse);
            //   //     icPoint.pointType = "cross";
            //   //     infiniteCanvas.addIcObject(icPoint);
            //   //   }
            //   //
            //   //   {
            //   //     const icPoint = infiniteCanvas.createIcPoint(pointOnEllipse);
            //   //     icPoint.pointType = "rect";
            //   //     infiniteCanvas.addIcObject(icPoint);
            //   //   }
            //   //
            //   // });
            //
            //
            //
            // }


          }

          //create rect
          {
            const trueRect = {
              x: 650,
              y: 550,
              width: 150,
              height: 1,
            };

            const icRect = infiniteCanvas.createIcRect(trueRect);
            icRect.cornerStyle = '';
            icRect.rx = 0;
            icRect.ry = 0;
            icRect.fill = "black";
            infiniteCanvas.addIcObject(icRect);
          }

          //create square
          {
            const trueRect = {
              x: 0,
              y: 0,
              width: 400,
              height: 400,
            };

            const icRect = infiniteCanvas.createIcRect(trueRect);
            icRect.cornerStyle = '';
            icRect.rx = 0;
            icRect.ry = 0;
            icRect.fill = "yellow";
            infiniteCanvas.addIcObject(icRect);
          }

          //create arc of square
          {
            const pointCenter = {
              x: 200,
              y: 200,
            };

            const radius = 200;
            const angleStart = 40;
            const angleEnd = 300;

            const cfg = {
              stroke: "grey",
              fillColor: "pink",
            };

            const icArcOfSquare = infiniteCanvas.createIcArcOfSquare(pointCenter, radius, angleStart, angleEnd, cfg);
            infiniteCanvas.addIcObject(icArcOfSquare);
          }


          //create arc of circle
          {
            const pointCenter = {
              x: 200,
              y: 200,
            };

            const radius = 200;
            const angleStart = 120;
            const angleEnd = 150;

            const cfg = {
              stroke: "red",
              fillColor: "",
            };

            const icCircle = infiniteCanvas.createIcArcOfCircle(pointCenter, radius, angleStart, angleEnd, cfg);
            infiniteCanvas.addIcObject(icCircle);
          }

          //create arc
          // {
          //   const trueRect = {
          //     x: 200,
          //     y: 200,
          //     width: 300,
          //     height: 300,
          //   };
          //
          //   const cfg = {
          //     angle1: 0,
          //     angle2: 180,
          //   };
          //
          //   const icArc = infiniteCanvas.createIcArc(trueRect, cfg);
          //   infiniteCanvas.addIcObject(icArc);
          // }

          // //create progress arc
          // const icProgressArc = infiniteCanvas.createIcProgressArc(trueRect, cfg);
          // infiniteCanvas.addIcObject(icProgressArc);
          //
          // //create segmented progress arc
          // const icSegmentedProgressArc = infiniteCanvas.createIcSegmentedProgressArc(trueRect, cfg);
          // infiniteCanvas.addIcObject(icSegmentedProgressArc);


        }

        debug_progress_marker() {

          //create crown
          // {
          //   const arr_point__crown = [
          //     Geometry.createPoint(  0, 100),
          //     Geometry.createPoint(100, 150),
          //     Geometry.createPoint(250,   0),
          //     Geometry.createPoint(400, 150),
          //     Geometry.createPoint(500, 100),
          //     Geometry.createPoint(400, 400),
          //     Geometry.createPoint(100, 400),
          //   ];
          //
          //   const cfg = {
          //     stroke: "grey",
          //     strokeWidth: 5,
          //
          //     fillColor:   "gold",
          //   };
          //
          //   const icPolygon = infiniteCanvas.createIcPolygon(arr_point__crown, cfg);
          //   infiniteCanvas.addIcObject(icPolygon);
          // }

          //create progress marker
          {
            const trueRect = {
              x: 400,
              y: 400,
              width: 200,
              height: 200,
            };

            const cfg = {
              levels: [
                {
                  color: "green",
                  nb_sectors: 7,
                },
                {
                  color: "blue",
                  nb_sectors: 8,
                },
                {
                  color: "red",
                  nb_sectors: 9,
                },
              ],
              // crown_symbol: null,
            };

            const progress = 0.30;

            const icProgressMarker = infiniteCanvas.createIcProgressMarker(trueRect, progress, cfg);
            infiniteCanvas.addIcObject(icProgressMarker);
          }

        }

        debug_decomp_prime_disks() {
          const pointCenter = Geometry.createPoint(200, 100);
          // const number = 20;
          const number = 11628;
          const icDecompPrimeDisk = infiniteCanvas.createIcProductOfPrimesDisk(pointCenter, number);
          infiniteCanvas.addIcObject(icDecompPrimeDisk);
        }


        debug_hexagon() {
          const pointTL = Geometry.createPoint(100, 100);
          const length = 100;
          const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length);
          infiniteCanvas.addIcObject(icHexagon);
        }

        debug_hexagon_grid1() {

          const length = 100;

          //hexagon1
          {
            const pointTL = Geometry.createPoint(0, 0);
            const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length);
            infiniteCanvas.addIcObject(icHexagon);
          }

          //hexagon2
          {
            const row = 0;
            const col = 2;
            const pointTL = Geometry.createPoint((col + 1.0) * length, row * length * math.sqrt(3) / 2.0);
            const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length);
            infiniteCanvas.addIcObject(icHexagon);
          }

          //hexagon3
          {
            const row = 1;
            const col = 1;
            const pointTL = Geometry.createPoint((col + 0.5) * length, row * length * math.sqrt(3) / 2.0);
            const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length);
            infiniteCanvas.addIcObject(icHexagon);
          }

        }

        debug_hexagon_grid2() {

          const arr_type = [
            "water",
            "sand",
            "soil",
            "mud",
            "grass",
            "tree__small",
            "tree__big",
          ];

          function easyConfig(type) {

            var fillColor;
            switch (type) {
              case "water":
                fillColor = "cyan";
                break;
              // case "water_deep":
              // fillColor = "blue";
              // break;
              case "sand":
                fillColor = "gold";
                break;
              case "tree__big":
                fillColor = "black";
                break;
              case "tree__small":
                fillColor = "gray";
                break;
              case "grass":
                fillColor = "green";
                break;
              case "soil":
                fillColor = "red";
                break;
              case "mud":
                fillColor = "brown";
                break;

              default:
                fillColor = "";
                break;
            }

            const cfg = {
              stroke: "white",
              fillColor: fillColor,
            };

            return cfg;
          }

          function easyHexagon(row, col, type) {
            const length = 50;

            const factor__col = (col % 2 == 0) ? (col + 1.0) : (col + 0.5);
            const x = 3 * col * length + ((row % 2 == 0) ? 0 : 1.5) * length;
            const y = row * length * math.sqrt(3) / 2.0;
            const pointTL = Geometry.createPoint(x, y);

            const cfg = easyConfig(type);

            const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length, cfg);
            return icHexagon;
          }

          const w = 10;
          const h = 10;

          const arr_x = [...Array(w).keys()];
          const arr_y = [...Array(h).keys()];

          const arr_hexagon = arr_x.map(x => {
            return arr_y.map(y => {
              const type = Utils.randomElementInArray(arr_type);
              const icHexagon = easyHexagon(x, y, type);
              return icHexagon;
            });
          }).flat();

          arr_hexagon.forEach((icHexagon, i) => {
            infiniteCanvas.addIcObject(icHexagon);
          });

        }

        debug_hexagon_fun() {

          function loadAssets_p() {
            const dict_image_path = {
              "water": "img/oyagame/water__ok.png",
              "sand": "img/oyagame/sand.png",
              "soil": "img/oyagame/soil.png",
              "mud": "img/oyagame/mud.png",
              "grass": "img/oyagame/grass.png",
              "tree__small": "img/oyagame/tree__small.png",
              "tree__big": "img/oyagame/tree__big.png",
            };

            var dict_image = {};
            const arr_p = Object.entries(dict_image_path).map(([type, image_path]) => {
              const img__file_p = FileIntegration.imageFromImgSrc_p(image_path);
              const img_p = img__file_p;

              return img_p.then(img => {
                dict_image[type] = img;
                logger.log("loaded image for" + " " + type);
              });
            });

            const assets_p = Promise.all(arr_p)
              .then(arr => {
                return dict_image;
              });

            return assets_p;
          }

          const arr_type = [
            "water",
            "sand",
            "soil",
            "mud",
            "grass",
            "tree__small",
            "tree__big",
          ];

          function easyConfig(type) {

            var fillColor;
            switch (type) {
              case "water":
                fillColor = "cyan";
                break;
              // case "water_deep":
              // fillColor = "blue";
              // break;
              case "sand":
                fillColor = "gold";
                break;
              case "tree__big":
                fillColor = "black";
                break;
              case "tree__small":
                fillColor = "gray";
                break;
              case "grass":
                fillColor = "green";
                break;
              case "soil":
                fillColor = "red";
                break;
              case "mud":
                fillColor = "brown";
                break;

              default:
                fillColor = "";
                break;
            }

            const cfg = {
              stroke: "white",
              fillColor: fillColor,
            };

            return cfg;
          }

          function easyHexagon(row, col, type, dict_image) {
            const length = 50;

            const factor__col = (col % 2 == 0) ? (col + 1.0) : (col + 0.5);
            const x = 3 * col * length + ((row % 2 == 0) ? 0 : 1.5) * length;
            const y = row * length * math.sqrt(3) / 2.0;
            const pointTL = Geometry.createPoint(x, y);

            const cfg = easyConfig(type);

            // const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length, cfg);
            // return icHexagon;

            const img = dict_image[type];
            const icImage = infiniteCanvas.createIcImage(pointTL.x, pointTL.y, img);
            const width__tile = 2 * length;
            const height__tile = math.sqrt(3) * length;
            icImage.width = width__tile;
            icImage.height = height__tile;
            icImage.force_width = true;
            icImage.force_height = true;

            // const img_clone = img.clone();
            // const icImage = infiniteCanvas.createIcImage(pointTL.x, pointTL.y, img_clone);
            return icImage;
          }

          function easyDictAbcHexagon() {

            const w = 10;
            const h = 10;

            function empty_dict(w, h) {
              const arr_x = [...Array(w).keys()];
              const arr_y = [...Array(h).keys()];

              const arr_entryX = arr_x.map(x => {
                const arr_entryY = arr_y.map(y => {
                  const entryY = [y, null];
                  return entryY;
                });
                const dict = Object.fromEntries(arr_entryY);
                const entryX = [x, dict];
                logger.log("entryX", entryX);
                return entryX;
              });
              logger.log("arr_entryX", arr_entryX);

              const dict = Object.fromEntries(arr_entryX);
              logger.log("dictXX", dict);
              return dict;
            }

            function arr_prob_gen(type) {

              const dict = {
                "water": [25, 25, 5, 25, 10, 5, 5],
                "sand": [25, 25, 5, 5, 5, 10, 25],
                "soil": [5, 5, 25, 25, 15, 15, 10],
                "mud": [15, 0, 15, 25, 15, 15, 15],
                "tree__big": [0, 0, 10, 10, 35, 25, 20],
                "tree__small": [0, 5, 10, 10, 25, 35, 15],
                "grass": [0, 5, 10, 15, 15, 20, 35],
              };

              var arr_prob = dict[type];
              arr_prob = arr_prob.map(x => x / 100.0);

              return arr_prob;
            }



            function easyType(arr_type__surrounding) {
              var outType;

              logger.log("arr_type__surrounding", arr_type__surrounding);

              outType = "sand";

              if (arr_type__surrounding.length == 0) {
                outType = Utils.randomElementInArray(arr_type);
              } else {
                const arr_arr_weight = arr_type__surrounding.map(type => arr_prob_gen(type));
                logger.log("arr_arr_weight", arr_arr_weight);
                var arr_weight = arr_arr_weight.reduce((acc, x) => {
                  if (acc != null) {
                    acc = x.map(function (e, i) {
                      const sum_ = acc[i] + x[i];
                      return sum_;
                    });
                  } else {
                    acc = x;
                  }
                  return acc;
                });
                arr_weight = arr_weight.map(sum_ => sum_ * 1.0 / arr_type__surrounding.length);

                outType = Utils.randomElementInArray__weighted(arr_type, arr_weight);
              }

              return outType;
            }

            const dict_abcHexagon = empty_dict(w, h);
            logger.log("empty_dict", dict_abcHexagon);

            //generation
            var x = 0;
            var y = 0;
            while (x < w) {
              while (y < h) {
                if (dict_abcHexagon[x][y] == null) {

                  const arr_abcHexagon__surrounding = [
                    dict_abcHexagon[x + 1] ? dict_abcHexagon[x + 1][y + 1] : null,
                    dict_abcHexagon[x] ? dict_abcHexagon[x][y + 2] : null,
                    dict_abcHexagon[x - 1] ? dict_abcHexagon[x - 1][y + 1] : null,
                    dict_abcHexagon[x - 1] ? dict_abcHexagon[x - 1][y - 1] : null,
                    dict_abcHexagon[x] ? dict_abcHexagon[x][y - 2] : null,
                    dict_abcHexagon[x + 1] ? dict_abcHexagon[x + 1][y - 1] : null,
                  ];
                  logger.log("arr_abcHexagon__surrounding", arr_abcHexagon__surrounding);
                  const arr_type__surrounding = arr_abcHexagon__surrounding.filter(abcHex => abcHex != null && abcHex != undefined).map(abcHex => abcHex.type);
                  const type = easyType(arr_type__surrounding);

                  const abcHexagon = {
                    row: x,
                    col: y,
                    type: type,
                  };

                  dict_abcHexagon[x][y] = abcHexagon;
                }
                y = y + 1;
              }
              x = x + 1;
              y = 0;
            }

            return dict_abcHexagon;
          }

          const dict_abcHexagon = easyDictAbcHexagon();
          logger.log("dict_abcHexagon", dict_abcHexagon);

          {
            const w = 10;
            const h = 10;

            const arr_x = [...Array(w).keys()];
            const arr_y = [...Array(h).keys()];

            function icHexagonFromAbcHexagon(abcHexagon, dict_image) {
              const row = abcHexagon.row;
              const col = abcHexagon.col;
              const type = abcHexagon.type;
              return easyHexagon(row, col, type, dict_image);
            }


            loadAssets_p().then(dict_image => {

              arr_x.forEach(x => {
                arr_y.forEach(y => {
                  const abcHexagon = dict_abcHexagon[x][y];
                  const icHexagon = icHexagonFromAbcHexagon(abcHexagon, dict_image);
                  infiniteCanvas.addIcObject(icHexagon);
                });
              });

            });





          }

        }


        debug_povs() {

          //show border rect for starting pov
          const rect__start = infiniteCanvas.getShownRect();
          const icRect__start = infiniteCanvas.createIcRect(rect__start);
          icRect__start.fill = "red";
          infiniteCanvas.addIcObject(icRect__start);

          {
            const rect__1 = {
              x: 2000,
              y: 2000,
              width: 50,
              height: 50,
            };

            const icRect__1 = infiniteCanvas.createIcRect(rect__1);
            icRect__1.fill = "blue";
            infiniteCanvas.addIcObject(icRect__1);


            //animate move to rect1/pov1
            const cfg_anim__easy = {
              duration: 3000,
            };
            infiniteCanvas.move_to_rect__animation(rect__1, cfg_anim__easy);

          }

          {
            const rect__2 = {
              x: -3000,
              y: 2000,
              width: 500,
              height: 500,
            };

            const icRect__2 = infiniteCanvas.createIcRect(rect__2);
            icRect__2.fill = "green";
            infiniteCanvas.addIcObject(icRect__2);


            //animate move to rect2/pov2
            const cfg_anim__easy = {
              duration: 2000,
            };

            setTimeout(() => {
              infiniteCanvas.move_to_rect__animation(rect__2, cfg_anim__easy);
            }, 5000);

            // setTimeout(() => {
            //   infiniteCanvas.move_to_rect__animation(rect__start, cfg_anim__easy);
            // }, 5000);

          }


        }

        debug_povs_2() {

          const trueRect__1 = {
              x: 2000,
              y: 2000,
              
              // width:  500,
              // height: 200,
              
              width:  200,
              height: 500,

              // width:  200,
              // height: 200,
            };
                    
          const trueRect__2 = {
            x: 200,
            y: 200,
            width:  100,
            height: 100,
          };

          function createPOVDuo(trueRect__pov, trueRect__gotopov) {

            //create povRect
            const icPOVRect = infiniteCanvas.createIcPOVRect(trueRect__pov);
            infiniteCanvas.addIcObject(icPOVRect);

            //create gotopov button
            const config__button = {
              buttonFunc: (scopeObj) => {
                const cfg_anim__easy = {
                  duration: 3000,
                };
                
                logger.log("logPov", "scopeObj", scopeObj);

                const id__povRect = scopeObj.engineCarrier.buttonConfig.id__povRect;
                logger.log("logPov", "id__povRect", id__povRect);

                const represented__povRect = scopeObj.infiniteCanvas.getRepresented(id__povRect);
                logger.log("logPov", "represented__povRect", represented__povRect);

                const rep_free__povRect    = represented__povRect.getRepresentation("free");

                // const trueRect2_pov  = icPOVRect.getTrueRect2();
                const trueRect2_pov  = rep_free__povRect.getTrueRect2();

                scopeObj.infiniteCanvas.move_to_rect__animation(trueRect2_pov, cfg_anim__easy);
              },
              id__povRect: icPOVRect.id,
            };
            const icButton = infiniteCanvas.createIcButton(trueRect__gotopov, config__button);
            infiniteCanvas.addIcObject(icButton);

          }

          
          const trueRect__3 = {
            x: trueRect__1.x + trueRect__1.width        + 200,
            y: trueRect__1.y + trueRect__1.height / 2.0 + 200,
            width:  100,
            height: 100,
          };
          const trueRect__4 = {
            x: -500,
            y: -200,
            width:  300,
            height: 100,
          };

          createPOVDuo(trueRect__1, trueRect__2);
          createPOVDuo(trueRect__4, trueRect__3);
        }


        debug_povs_3() {

          const trueRect__1 = {
              x: 2000,
              y: 2000,
              
              // width:  500,
              // height: 200,
              
              width:  800,
              height: 600,

              // width:  200,
              // height: 200,
          };
                    
          const icComposite = infiniteCanvas.createIcPOVRectStar(trueRect__1);
          infiniteCanvas.addNewIcObject(icComposite);
        }


        debug_qrcode_1() {

          const trueRect = {
            x: 500,
            y: 500,
            width: 100,
            height: 100,
          };


          {
            // const videoEl = document.getElementById('myVideo');
            const videoEl = document.createElement('video');
            videoEl.src = "http://html5demos.com/assets/dizzy.mp4";
            // document.getElementById('myCanvas').appendChild(webcamEl);
            videoEl.style.width = "100px";
            videoEl.style.height = "100px";
            // videoEl.style.display = "none";
            logger.log("log1", "videoEl", videoEl);

            const icVideo = infiniteCanvas.createIcVideo(trueRect.x, trueRect.y, videoEl);

            // const imgEl = document.getElementById("myImage");
            // const icVideo = infiniteCanvas.createIcVideo(trueRect.x, trueRect.y, imgEl);
            logger.log("log1", "icVideo", icVideo);

            infiniteCanvas.addIcObject(icVideo);


            // const canvas = fabricIntegration.fabricCanvas;
            // var video = new fabric.Image(videoEl, {
            //   left: 539,
            //   top: 328,
            //   angle: 94.5,
            //   originX: 'center',
            //   originY: 'center',
            //   objectCaching: false,
            // });
            // canvas.add(video);
            // video.moveTo(0); // move webcam element to back of zIndex stack
            // // video.getElement().play();
            // //
            // // fabric.util.requestAnimFrame(function render() {
            // //   canvas.renderAll();
            // //   fabric.util.requestAnimFrame(render);
            // // });


            // document.getElementById("myButton").addEventListener("click", e => {
            //   logger.log("log1", "myButton.onclick");
            //   videoEl.play();
            //
            //   const rep_free = infiniteCanvas.getRepresented(icVideo.id).r_free();
            //   const fVideo   = fabricIntegration.getFObjForIcObj(rep_free);
            //   // rep_free.position.x = 100;
            //   // rep_free.size.width  = 100;
            //   // rep_free.size.height = 100;
            //
            //   // rep_free.stroke = "yellow";
            //
            //   // rep_free.video = videoEl;
            //
            //   fabric.util.requestAnimFrame(function render() {
            //     fabricIntegration.fabricCanvas.requestRenderAll();
            //     fabric.util.requestAnimFrame(render);
            //   });

            // function playTrigger() {
            //   // if(v.paused || v.ended) return false;
            //   // vid.set('time', v.currentTime)
            //   // console.log('current time:', v.currentTime)
            //
            //   const rep_free = infiniteCanvas.getRepresented(icVideo.id).r_free();
            //   const fVideo   = fabricIntegration.getFObjForIcObj(rep_free);
            //
            //   // fVideo.element = document.getElementById('myImage');
            //   rep_free.src = "https://i.stack.imgur.com/8fooU.png";
            //
            //   // infiniteCanvas.updateScaleAndDOffset({
            //   //   X: infiniteCanvas.scale.X * (1.0 + 1e-10),
            //   //   Y: infiniteCanvas.scale.Y * (1.0 + 1e-10),
            //   // }, {dx: 0, dy: 0});
            //   // infiniteCanvas.redrawCanvas(RedrawOccasion.scaleChanged);
            //   // setTimeout(playTrigger,20);
            // }
            //
            // playTrigger();

          }

          {
            // function webcamStream_p() {
            //   return navigator.mediaDevices
            //   .getUserMedia({
            //     video: {
            //       facingMode: "user"
            //     },
            //     audio: false
            //   });
            // }
            //
            // webcamStream_p()
            // .then(function(stream) {
            //   // track = stream.getTracks()[0];
            //   logger.log("log1", "stream", stream);
            //
            //
            //   const webcamEl = document.getElementById('myVideo');
            //   // const webcamEl = document.createElement('video');
            //   // document.getElementById('myCanvas').appendChild(webcamEl);
            //   webcamEl.style.width  = "100px";
            //   webcamEl.style.height = "100px";
            //   webcamEl.style.display = "none";
            //   logger.log("log1", "webcamEl", webcamEl);
            //
            //   // webcamEl.srcObject = stream;
            //   // webcamEl.src = "http://tecfa.unige.ch/guides/html/html5-video/videos/state-of-wikipedia-480x272.mp4";
            //   webcamEl.play();
            //
            //
            //   const icVideo = infiniteCanvas.createIcVideo(trueRect.x, trueRect.y, webcamEl);
            //   logger.log("log1", "icVideo", icVideo);
            //
            //   infiniteCanvas.addIcObject(icVideo);
            //
            //   fabric.util.requestAnimFrame(function render() {
            //     fabricIntegration.fabricCanvas.renderAll();
            //     fabric.util.requestAnimFrame(render);
            //   });
            //
            //
            //   // infiniteCanvas.onceOnAddRepresentedForIcObject(icVideo, (icVideo) => {
            //   //
            //   //   setTimeout(function () {
            //   //
            //   //     logger.log("log1", "fabricIntegration.fObjForIcObj_dict", fabricIntegration.fObjForIcObj_dict);
            //   //
            //   //     const rep_free = infiniteCanvas.getRepresented(icVideo.id).r_free();
            //   //     const fVideo   = fabricIntegration.getFObjForIcObj(rep_free);
            //   //     logger.log("log1", "fVideo", fVideo);
            //   //     fVideo.getElement().play();
            //   //
            //   //     fabric.util.requestAnimFrame(function render() {
            //   //       fabricIntegration.fabricCanvas.renderAll();
            //   //       fabric.util.requestAnimFrame(render);
            //   //     });
            //   //
            //   //   }, 100);
            //   //
            //   // });
            //
            //
            //
            //   // const canvas = fabricIntegration.fabricCanvas;
            //   //
            //   // var webcam = new fabric.Image(webcamEl, {
            //   //   left: 539,
            //   //   top: 328,
            //   //   angle: 94.5,
            //   //   originX: 'center',
            //   //   originY: 'center',
            //   //   objectCaching: false,
            //   // });
            //   //
            //   // canvas.add(webcam);
            //   // webcam.moveTo(0); // move webcam element to back of zIndex stack
            //   // webcam.getElement().play();
            //   //
            //   // fabric.util.requestAnimFrame(function render() {
            //   //   canvas.renderAll();
            //   //   fabric.util.requestAnimFrame(render);
            //   // });
            //
            // })
            // .catch(function(error) {
            //   console.error("Oops. Something is broken.", error);
            // });
          }

        }

        debug_qrcode_2() {

          const trueRect_img = {
            x: 900,
            y: 760,
            width: 100,
            height: 100,
          };

          qrcodeImg_p("get100__[x 2]")
            .then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img);
              icObj_front.scale.X = 1.0;
              icObj_front.scale.Y = 1.0;
              // icObj_front.width  = trueRect_img.width;
              // icObj_front.height = trueRect_img.height;
              infiniteCanvas.addIcObject(icObj_front);
            });

          qrcodeImg_p("get100__[x 3]123456789123456789")
            .then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img);
              icObj_front.scale.X = 1.0;
              icObj_front.scale.Y = 1.0;
              // icObj_front.width  = trueRect_img.width;
              // icObj_front.height = trueRect_img.height;
              infiniteCanvas.addIcObject(icObj_front);
            });


          const trueRect_icEye = {
            x: 880,
            y: 740,
            width: 200,
            height: 200,
          };

          const icEye = infiniteCanvas.createIcEye(trueRect_icEye);
          infiniteCanvas.onceOnAddRepresentedForIcObject(icEye, (icEye) => {

            const rep_free = infiniteCanvas.getRepresented(icEye.id).r_free();

            function attemptDecoding() {
              logger.log("rep_free", rep_free);

              // const imageData = rep_free.imageData__captured;
              // ImageUtils.qrcode__decode_imageData(imageData);

              const img = rep_free.img__captured;
              ImageUtils.qrcode__decode_image_p(img)
                .then((result) => {
                  logger.log("result", result);
                  // document.getElementById('result').textContent = result.text
                }).catch((err) => {
                  console.error(err);
                  // document.getElementById('result').textContent = err
                });
            }

            function loopDecode() {

              setTimeout(function () {

                attemptDecoding();
                loopDecode();

              }, 3000);

            }

            loopDecode();

          });
          infiniteCanvas.addIcObject(icEye);


        }

        debug_video() {



        }


        // debug_gemini() {

        //   //debug
        //   const mathNode1 = new math.ConstantNode(5);
        //   mathNode1.value = 7;
        //   logger.log("mathNode1.value", mathNode1.value);

        //   const trueRect_mathNode1 = {
        //     x: 0,
        //     y: 0,
        //     width: 100,
        //     height: 100,
        //   };
        //   const icMathNode1 = infiniteCanvas.createIcMathNode(trueRect_mathNode1.x, trueRect_mathNode1.y, mathNode1);
        //   infiniteCanvas.addIcObject(icMathNode1);


        //   // const mathNode2 = new math.ConstantNode(10);

        //   // const geminiObject = new GeminiObject();
        //   logger.log("GeminiObject.createGemini", GeminiObject.createGemini);
        //   const gemini__mathNode1 = GeminiObject.createGemini(mathNode1);
        //   logger.log("gemini__mathNode1.value", gemini__mathNode1.value);

        //   logger.log("GeminiObject.createMiniGemini", GeminiObject.createMiniGemini);
        //   const miniGemini__mathNode1 = GeminiObject.createMiniGemini(mathNode1, {
        //     value: null,
        //   });
        //   logger.log("miniGemini__mathNode1.value", miniGemini__mathNode1.value);
        //   logger.log("miniGemini__mathNode1", miniGemini__mathNode1);



        //   mathNode1.value = 10;
        //   logger.log("mathNode1.value", mathNode1.value);
        //   logger.log("gemini__mathNode1.value", gemini__mathNode1.value);

        //   setTimeout(() => {
        //     gemini__mathNode1.value = 20;
        //     logger.log("gemini__mathNode1.value", gemini__mathNode1.value);
        //     logger.log("mathNode1.value", mathNode1.value);
        //   }, 5000);

        //   setTimeout(() => {

        //     const rep_free = infiniteCanvas.getRepresented(icMathNode1.id).r_free();
        //     const gemini__icMathNode_free = GeminiObject.createGemini(rep_free);

        //     gemini__icMathNode_free.mathNode = new math.ConstantNode(20);
        //     infiniteCanvas.addIcObject(gemini__icMathNode_free);
        //   }, 5000);




        // }


        debug_number_line() {

          //SLIDER

          const trueRect = {
            x: 200,
            y: 200,
            width: 800,
            height: 200,
          };

          const sliderConfig = {
            value__L: -100,
            value__R: +100,

            value: +27,
          };

          const icSlider = infiniteCanvas.createIcSlider(trueRect, sliderConfig);
          infiniteCanvas.addIcObject(icSlider);



          //ZONE

          const zoneConfig = {
            value__L: -20,
            value__R: +10,
          };
          const position__zone_L = icSlider.dict_engine["slider"].engine.awoken.positionForValue(zoneConfig.value__L);
          const position__zone_R = icSlider.dict_engine["slider"].engine.awoken.positionForValue(zoneConfig.value__R);

          const width__zone = position__zone_R.x - position__zone_L.x;
          const height__zone = 50;
          const trueRect__zone = {
            x: position__zone_L.x,
            y: position__zone_R.y - height__zone / 2.0,
            width: width__zone,
            height: height__zone,
          }
          const icRect__zone = infiniteCanvas.createIcRect(trueRect__zone);
          icRect__zone.fill = "yellow";
          icRect__zone.opacity = 0.35;
          infiniteCanvas.addIcObject(icRect__zone);



          //INPUT AREA
          {
            const mathNode1 = new math.ConstantNode(7);
            const trueRect_mathNode1 = {
              x: 0,
              y: 500,
              width: 100,
              height: 100,
            };
            const icMathNode1 = infiniteCanvas.createIcMathNode(trueRect_mathNode1.x, trueRect_mathNode1.y, mathNode1);
            infiniteCanvas.addIcObject(icMathNode1);


            const mathNode__op = new math.OperatorNode("+", "add", [MathSingleton.node__empty, MathSingleton.node__empty]);
            const trueRect_mathNode__op = {
              x: 150,
              y: 500,
              width: 100,
              height: 100,
            };
            const icMathNode__op = infiniteCanvas.createIcMathNode(trueRect_mathNode__op.x, trueRect_mathNode__op.y, mathNode__op);
            infiniteCanvas.addIcObject(icMathNode__op);


            const mathNode2 = new math.ConstantNode(7);
            const trueRect_mathNode2 = {
              x: 300,
              y: 500,
              width: 100,
              height: 100,
            };
            const icMathNode2 = infiniteCanvas.createIcMathNode(trueRect_mathNode2.x, trueRect_mathNode2.y, mathNode2);
            infiniteCanvas.addIcObject(icMathNode2);


            // const mathNode__eq = new math.RelationalNode(["equal"], [MathSingleton.node__empty, MathSingleton.node__empty]);
            // const trueRect_mathNode__eq = {
            //   x: 450,
            //   y: 500,
            //   width:  100,
            //   height: 100,
            // };
            // const icMathNode__eq = infiniteCanvas.createIcMathNode(trueRect_mathNode__eq.x, trueRect_mathNode__eq.y, mathNode__eq);
            // infiniteCanvas.addIcObject(icMathNode__eq);


            const mathNode__eq = new math.RelationalNode(["equal"], [MathSingleton.node__empty, MathSingleton.node__empty]);
            const trueRect_mathNode__eq = {
              x: 450,
              y: 500,
              width: 100,
              height: 100,
            };
            const icMathNode__eq = infiniteCanvas.createIcMathNode(trueRect_mathNode__eq.x, trueRect_mathNode__eq.y, mathNode__eq);
            infiniteCanvas.addIcObject(icMathNode__eq);

          }







          //REMOTE CONTROL
          /*
          const mathNodeRC = new math.ConstantNode(7);
          logger.log("mathNodeRC.value", mathNodeRC.value);

          const trueRect_mathNodeRC = {
            x: 500,
            y: 500,
            width:  100,
            height: 100,
          };
          const icMathNodeRC = infiniteCanvas.createIcMathNode(trueRect_mathNodeRC.x, trueRect_mathNodeRC.y, mathNodeRC);
          
          icMathNodeRC.scale__mixed = {
            X: 0.5,
            Y: 0.5,
          };
          const mixedScaleEngine__RC = new MixedScaleEngine();
          infiniteCanvas.installEngineOnIcObj(icMathNodeRC, "mixedScale", mixedScaleEngine__RC);
          
          infiniteCanvas.addIcObject(icMathNodeRC);


          

          //debug
          // infiniteCanvas.onceOnAddRepresentedForIcObject(icSlider, (icSlider) => {
            
          const rep_free__slider    = infiniteCanvas.getRepresented(icSlider.id).r_free();
          const rep_free__mathNodeRC = infiniteCanvas.getRepresented(icMathNodeRC.id).r_free();

          rep_free__mathNodeRC.onInnerUpdate((rep_free__mathNodeRC, propName, oldValue, newValue) => {
            logger.log("log3, rep_free__mathNodeRC.onInnerUpdate", "propName", propName);
            if(propName == "mathNode") {
              rep_free__slider.mathNode = newValue;
            }            
          });
          */


        }

        debug_composite_of_composite() {

          const trueRect = {
            x: 200,
            y: 200,
            width: 800,
            height: 200,
          };

          /*
          const icRect1 = infiniteCanvas.createIcRect(trueRect);
          const icRect2 = infiniteCanvas.createIcRect(trueRect);

          const parts__comp1 = {
            "rect1":  icRect1,
            "rect2":  icRect2,
          };
          const compositeConfig__comp1 = Compositer.defaultCompositeConfig(parts__comp1, false);
          // compositeConfig__knob[icMathNode__knob.id].isMobile = true;
          const trueRect__comp1 = {
            x:      trueRect.x,
            y:      trueRect.y,
            width:  100,
            height: 100,
          };
          logger.log("trueRect__comp1", trueRect__comp1);
          const icComp1 = infiniteCanvas.createIcComposite(trueRect__comp1, parts__comp1, compositeConfig__comp1);
          icComp1.cType = "comp1";

          infiniteCanvas.addIcObject(icComp1);




          const icRect3 = infiniteCanvas.createIcRect(trueRect);

          const parts__comp2 = {
            "rect3":  icRect3,
            "comp1":  icComp1,
          };
          const compositeConfig__comp2 = Compositer.defaultCompositeConfig(parts__comp2, false);
          // compositeConfig__knob[icMathNode__knob.id].isMobile = true;
          const trueRect__comp2 = {
            x:      trueRect.x,
            y:      trueRect.y,
            width:  100,
            height: 100,
          };
          logger.log("trueRect__comp2", trueRect__comp2);
          const icComp2 = infiniteCanvas.createIcComposite(trueRect__comp2, parts__comp2, compositeConfig__comp2);
          icComp2.cType = "comp_of_comp";

          infiniteCanvas.addIcObject(icComp2);
          */


          const pointL = {
            x: trueRect.x,
            y: trueRect.y,
          };

          const icPoint__knob = infiniteCanvas.createIcPoint(pointL);
          icPoint__knob.pointType = "circle";
          icPoint__knob.fill = "lime";
          // infiniteCanvas.addIcObject(icPoint__knob);

          const mathNode__knob = new math.ConstantNode(7);
          const icMathNode__knob = infiniteCanvas.createIcMathNode(icPoint__knob.position.x, icPoint__knob.position.y, mathNode__knob);

          icMathNode__knob.scale__mixed = {
            X: 0.5,
            Y: 0.5,
          };
          const mixedScaleEngine = new MixedScaleEngine();
          infiniteCanvas.installEngineOnIcObj(icMathNode__knob, "mixedScale", mixedScaleEngine);
          // infiniteCanvas.addIcObject(icMathNode__knob);

          const parts__knob = {
            "point": icPoint__knob,
            "mathNode": icMathNode__knob,
          };
          const compositeConfig__knob = Compositer.defaultCompositeConfig(parts__knob, false);
          // compositeConfig__knob[icMathNode__knob.id].isMobile = true;
          const trueRect__knob = {
            x: icPoint__knob.position.x,
            y: icPoint__knob.position.y,
            width: icPoint__knob.size.width,
            height: icPoint__knob.size.height,
          };
          logger.log("trueRect__knob", trueRect__knob);
          const icLabeledPoint__knob = infiniteCanvas.createIcComposite(trueRect__knob, parts__knob, compositeConfig__knob);
          icLabeledPoint__knob.cType = "labeledPoint";
          icLabeledPoint__knob.fill = "yellow";

          infiniteCanvas.addIcObject(icLabeledPoint__knob);



          // const icRect = infiniteCanvas.createIcRect(trueRect);

          // const parts__comp2 = {
          //   "rect":          icRect,
          //   "labeledPoint":  icLabeledPoint__knob,
          // };
          // const compositeConfig__comp2 = Compositer.defaultCompositeConfig(parts__comp2, false);
          // // compositeConfig__knob[icMathNode__knob.id].isMobile = true;
          // const trueRect__comp2 = {
          //   x:      trueRect.x,
          //   y:      trueRect.y,
          //   width:  100,
          //   height: 100,
          // };
          // logger.log("trueRect__comp2", trueRect__comp2);
          // const icComp2 = infiniteCanvas.createIcComposite(trueRect__comp2, parts__comp2, compositeConfig__comp2);
          // icComp2.cType = "comp_of_comp";
          // icComp2.fill = "red";

          // infiniteCanvas.addIcObject(icComp2);





        }

        debug_remoteControl() {

          // logger.log("navigator.getGamepads()", navigator.getGamepads());

          // setInterval(() => {
          //   const myGamepad = navigator.getGamepads()[0]; // use the first gamepad
          //   console.log(`Left stick at (${myGamepad.axes[0]}, ${myGamepad.axes[1]})` );
          //   console.log(`Right stick at (${myGamepad.axes[2]}, ${myGamepad.axes[3]})` );
          // }, 100) // print axes 10 times per second

          gameControl.on('connect', gamepad => {
            logger.log('A new gamepad was connected!');

            gamepad.on('button12', () => { keyboardIntegration.infiniteCanvas.operateOnSupervessel__moveStep(0, -1); });
            gamepad.on('button13', () => { keyboardIntegration.infiniteCanvas.operateOnSupervessel__moveStep(0, +1); });
            gamepad.on('button14', () => { keyboardIntegration.infiniteCanvas.operateOnSupervessel__moveStep(-1, 0); });
            gamepad.on('button15', () => { keyboardIntegration.infiniteCanvas.operateOnSupervessel__moveStep(+1, 0); });

            gamepad.after('button3', () => { logger.log('Button 3 was released'); });
            gamepad.after('button1', () => { logger.log('Button 1 was released'); });

          });

        }

        debug_grid_maze() {


        }


        debug_vibrating_segment() {

          const trueRect = {
            x: 200,
            y: 200,
            width: 800,
            height: 200,
          };

          const point__attach = {
            x: trueRect.x,
            y: trueRect.y,
          };

          const length__base = trueRect.width;

          const cfg = {

          };

          const icVS1 = infiniteCanvas.createIcVibratingSegment(point__attach, length__base, cfg);
          infiniteCanvas.addIcObject(icVS1);

        }

        debug_composite_segment() {

          const trueRect = {
            x: 200,
            y: 200,
            width: 800,
            height: 200,
          };

          const point__start = {
            x: trueRect.x,
            y: trueRect.y,
          };

          const point__end = {
            x: trueRect.x + trueRect.width,
            y: trueRect.y + trueRect.height,
          };

          const icCS1 = infiniteCanvas.createIcCompositeSegment(point__start, point__end);
          infiniteCanvas.addIcObject(icCS1);

        }

        debug_uniformSConveyor() {



        }


        debug_workbench_image() {

          //create workbench rect
          const trueRect_workbench = {
            x: 200,
            y: 200,
            width:  800,
            height: 600,
          };
          const icRect__workbench  = infiniteCanvas.createIcRect(trueRect_workbench);
          icRect__workbench.strokeWidth = 5;
          icRect__workbench.stroke = "purple";
          icRect__workbench.isSharpRect = true; 
          infiniteCanvas.addIcObject(icRect__workbench);

          //create save_as button
          const trueRect_button = {
            x: trueRect_workbench.x + trueRect_workbench.width  * 2./3,
            y: trueRect_workbench.y + trueRect_workbench.height * 4./3,
            width:  100,
            height: 100,
          };
          const config__button = {
            buttonFunc: (scopeObj) => {
              const id__rect_workbench = scopeObj.engineCarrier.buttonConfig.id__rect_workbench;
              logger.log("logPov", "id__rect_workbench", id__rect_workbench);

              const represented__rect_workbench = scopeObj.infiniteCanvas.getRepresented(id__rect_workbench);
              const rep_free__rect_workbench    = represented__rect_workbench.getRepresentation("free");

              //remove workbench border
              const strokeWidth_tmp = rep_free__rect_workbench.strokeWidth; 
              rep_free__rect_workbench.strokeWidth = 0;

              //capture area
              scopeObj.infiniteCanvas.exportCanvasRectContainingObj_asImg(rep_free__rect_workbench, "ic_workbench_image.png");

              //restore workbench border
              rep_free__rect_workbench.strokeWidth = strokeWidth_tmp;

            },
            id__rect_workbench: icRect__workbench.id,
          };
          const icButton = infiniteCanvas.createIcButton(trueRect_button, config__button);
          infiniteCanvas.addIcObject(icButton);

        }

        debug_zScroll_composite() {

          //create composite
          const grid_square_width  = 200;
          const grid_square_height = 200;

          function createRectWith_gridRowCol_and_zIndex(row, col, zIndex) {
              const trueRect = {
                x:      col * grid_square_width,
                y:      row * grid_square_height,
                width:  100,
                height: 100,
              };
              const icRect = infiniteCanvas.createIcRect(trueRect);

              icRect.zIndex = zIndex;
              icRect.fill = ColorUtils.randomColor();

              return icRect;
          }

          const arr_row = [...new Array(4).keys()];
          const arr_col = [...new Array(4).keys()];
          const arr_gridPos = Utils.cartesianProduct(arr_row, arr_col); 

          const arr_icRect = arr_gridPos.reduce((acc, [row, col]) => {
              const zIndex = 1 + 4 * row + col; 
              const icRect = createRectWith_gridRowCol_and_zIndex(row, col, zIndex);
              acc.push(icRect);
              return acc;
          }, []);

          const parts = Utils.dictFromArr(arr_icRect);
          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
          // compositeConfig__knob[icMathNode__knob.id].isMobile = true;
          const trueRect__composite = {
            x:      -100,
            y:      -100,
            width:    30,
            height:   30,
          };
          const icComposite = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig);
          icComposite.cType = "debug";

          infiniteCanvas.addIcObject(icComposite);
        }


        debug_zIndexFreeDrawing() {

          this.spawnRectGrid();


          inputProperties.setBrushZIndex(8);

        }


        debug_fObjOverlapping() {

        }

        debug_composite_contentAndParts() {

          function createComposite_withContentAndParts__debug(trueRect__composite) {

            //create composite
            const grid_square_width  = 200;
            const grid_square_height = 200;

            function createRectWith_gridRowCol_and_zIndex(row, col, zIndex) {
                const trueRect = {
                  x:      trueRect__composite.x + col * grid_square_width,
                  y:      trueRect__composite.y + row * grid_square_height,
                  width:  100,
                  height: 100,
                };
                const icRect = infiniteCanvas.createIcRect(trueRect);

                icRect.zIndex = zIndex;
                icRect.fill   = ColorUtils.randomColor();

                return icRect;
            }


            const content = createRectWith_gridRowCol_and_zIndex(2, 1, 50);

            const arr_row = [...new Array(1).keys()];
            const arr_col = [...new Array(2).keys()];
            const arr_gridPos = Utils.cartesianProduct(arr_row, arr_col); 

            const arr_icRect = arr_gridPos.reduce((acc, [row, col]) => {
                const zIndex = 1 + 4 * row + col; 
                const icRect = createRectWith_gridRowCol_and_zIndex(row, col, zIndex);
                acc.push(icRect);
                return acc;
            }, []);
            const parts           = Utils.dictFromArr(arr_icRect);
            const contentAndParts = Object.assign({"content": content}, parts);
            
            const compositeConfig = Compositer.defaultCompositeConfig(contentAndParts, false);
            // compositeConfig__knob[icMathNode__knob.id].isMobile = true;
            
            const icComposite = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig, content);
            icComposite.cType = "debug";

            infiniteCanvas.addIcObject(icComposite);

            return icComposite;
          }
          

          const trueRect__composite1 = {
            x:      -300,
            y:       200,
            width:    70,
            height:   70,
          };
          const composite1 = createComposite_withContentAndParts__debug(trueRect__composite1);

          const trueRect__composite2 = {
            x:       100,
            y:       200,
            width:    30,
            height:   30,
          };
          const composite2 = createComposite_withContentAndParts__debug(trueRect__composite2);

          const trueRect__composite3 = {
            x:       400,
            y:       200,
            width:    30,
            height:   30,
          };
          const composite3 = createComposite_withContentAndParts__debug(trueRect__composite3);

          const composite1__rep_free = infiniteCanvas.getRepresented(composite1.id).r_free();
          const composite2__rep_free = infiniteCanvas.getRepresented(composite2.id).r_free();
          const composite3__rep_free = infiniteCanvas.getRepresented(composite3.id).r_free();
          
          //add composite3 to composite2
          composite2__rep_free.dict_engine["composite"].engine.awoken.addPart(composite3__rep_free);

          //add composite2 to composite1
          composite1__rep_free.dict_engine["composite"].engine.awoken.addPart(composite2__rep_free);

        }


        debug_touch() {

          const trueRect_operator = {
            x: 800,
            y: 600,
            width:  100,
            height: 100,
          };
          const icGMOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_operator, "debug:random_color", {"stroke": "oh yes"});
          infiniteCanvas.addIcObject(icGMOperator);

        }

        debug_decoration() {

          class L9L {

            constructor(name, age) {
              this.name = name;
              this.age  = age;
            }

            bark() {
              return "woof";
            }

          }          

          try {

            const instance__raw = new L9L("Mitch", 100);
            logger.log("logDeco", "instance__raw", instance__raw);

            class L9LMore extends DecorationUtils.createDecoratorClass(L9L, {
              number: 50,

              bark() {
                return "yoyo";
              },

              meow() {
                return "pop";
              },

              yawn1() {
                return "ya" + this.yawn2();
              },

              yawn2() {
                return "wn";
              },

            }) {}
            logger.log("logDeco", L9LMore);

            const instance__new       = new L9LMore("Laura", 10, 666);
            logger.log("logDeco", "instance__new", instance__new);



            const instance__decorated = L9LMore.decorate(instance__raw, DecorationUtils.createInitializationDict({
              number: 35,
            }));

            logger.log("logDeco", "instance__raw",              instance__raw);
            logger.log("logDeco", "instance__raw.bark()",       instance__raw.bark());

            logger.log("logDeco", "instance__decorated",         instance__decorated);
            logger.log("logDeco", "instance__decorated.name",    instance__decorated.name);
            logger.log("logDeco", "instance__decorated.number",  instance__decorated.number);
            logger.log("logDeco", "instance__decorated.bark()",  instance__decorated.bark());
            logger.log("logDeco", "instance__decorated.meow()",  instance__decorated.meow());
            logger.log("logDeco", "instance__decorated.yawn1()", instance__decorated.yawn1());

            class L9LMoreAndMore extends DecorationUtils.createDecoratorClass(L9LMore, {
              password: "yadiyadiyada",

              bark() {
                return "0---0";
              },

              meow() {
                return this.bark();
              },

              pew() {
                return "pew pew";
              },

              yawn2() {
                return "WN!!!!!!!";
              },

            }) {}

            // const instance__decorated2 = L9LMoreAndMore.decorate(instance__decorated, DecorationUtils.createInitializationDict({
            //   password: "XXX", 
            //   name: "lol"
            // }));
            const instance__decorated2 = L9LMoreAndMore.decorate(instance__decorated);

            logger.log("logDeco", "instance__decorated2",           instance__decorated2);
            logger.log("logDeco", "instance__decorated2.name",      instance__decorated2.name);
            logger.log("logDeco", "instance__decorated2.number",    instance__decorated2.number);
            logger.log("logDeco", "instance__decorated2.password",  instance__decorated2.password);
            logger.log("logDeco", "instance__decorated2.bark()",    instance__decorated2.bark());
            logger.log("logDeco", "instance__decorated2.meow()",    instance__decorated2.meow());
            logger.log("logDeco", "instance__decorated2.yawn1()",   instance__decorated2.yawn1());

          } catch(e) {
            logger.log("logDeco", e);
          }

          
        }


        debug_zSegment() {

          // //same homeScale
          // {
          //   const p1 = {
          //     x: 1000,
          //     y: 200,
          //   };
          //   const r1 = 100;
          //   const c1 = infiniteCanvas.createIcCircle(p1, r1);
          //   c1.fill = "";
          //   infiniteCanvas.addIcObject(c1);
            

          //   const p2 = {
          //     x: 1500,
          //     y: 800,
          //   };
          //   const r2 = 400;
          //   const c2 = infiniteCanvas.createIcCircle(p2, r2);
          //   c2.fill = "";
          //   infiniteCanvas.addIcObject(c2);



          //   const arr__arr_point = Geometry.getArr_extangent_point__circleCircle(p1,r1,p2,r2);
          //   logger.log("logZSegment", "arr__arr_point", arr__arr_point);

            
          //   // arr__arr_point.forEach(([pE1, pE2]) => {
          //   //   logger.log("logZSegment", "[pE1,pE2]", [pE1,pE2]);
          //   //   const icSegment = infiniteCanvas.createIcSegment(pE1, pE2);
          //   //   infiniteCanvas.addIcObject(icSegment);
          //   // });

          //   const arr_point = [arr__arr_point[0][0], arr__arr_point[0][1], arr__arr_point[1][1], arr__arr_point[1][0]];
          //   const icPolygon = infiniteCanvas.createIcPolygon(arr_point);
          //   icPolygon.fill = "rgba(100,100,150,0.5)";
          //   infiniteCanvas.addIcObject(icPolygon);

          // }

          // //different homeScales
          // {
          //   const homeScale1 = {X: 1.5, Y: 1.5};
          //   const homeScale2 = {X: 0.5, Y: 0.5};

          //   const scale1 = {X: 10.7, Y: 10.7};
          //   const scale2 = {X: 0.8, Y: 0.8};

          //   const p1 = {
          //     x: 3000,
          //     y: 200,
          //   };
          //   const r1 = 100;
          //   const c1 = infiniteCanvas.createIcCircle(p1, r1);
          //   c1.fill = "";
          //   c1.homeScale = homeScale1;
          //   c1.scale     = scale1;
          //   infiniteCanvas.addIcObject(c1);
            

          //   const p2 = {
          //     x: 3500,
          //     y: 800,
          //   };
          //   const r2 = 400;
          //   const c2 = infiniteCanvas.createIcCircle(p2, r2);
          //   c2.fill = "";
          //   c2.homeScale = homeScale2;
          //   c2.scale     = scale2;
          //   infiniteCanvas.addIcObject(c2);


          //   const r1__screen = r1 * 1.0 / c1.homeScale.X * c1.scale.X;
          //   const r2__screen = r2 * 1.0 / c2.homeScale.X * c2.scale.X;
          //   const arr__arr_point = Geometry.getArr_extangent_point__circleCircle(p1,r1__screen,p2,r2__screen);
          //   logger.log("logZSegment", "arr__arr_point", arr__arr_point);

            
          //   // arr__arr_point.forEach(([pE1, pE2]) => {
          //   //   logger.log("logZSegment", "[pE1,pE2]", [pE1,pE2]);
          //   //   const icSegment = infiniteCanvas.createIcSegment(pE1, pE2);
          //   //   infiniteCanvas.addIcObject(icSegment);
          //   // });

          //   const arr_point = [arr__arr_point[0][0], arr__arr_point[0][1], arr__arr_point[1][1], arr__arr_point[1][0]];
          //   const icPolygon = infiniteCanvas.createIcPolygon(arr_point);
          //   icPolygon.fill = "rgba(100,100,150,0.5)";
          //   infiniteCanvas.addIcObject(icPolygon);

          // }

          //icObj
          {
            const p1 = {
              x: 0,
              y: 1500,
            };
            const r1 = 100;
            

            const p2 = {
              x: -500,
              y: 2300,
            };
            const r2 = 400;

            try {
              const icZSegment = infiniteCanvas.createIcZSegment(p1,r1,p2,r2);
              logger.log("logZSegment", "icZSegment", icZSegment);
              infiniteCanvas.addIcObject(icZSegment);

              const rep_free__zSegment      = infiniteCanvas.getRepresented(icZSegment.id).r_free();

              const rep_free__zPoint__start = rep_free__zSegment.parts.zPoint_start;
              rep_free__zSegment.compositeConfig[rep_free__zPoint__start.id].isMobile = true;

              // function step() {

              //   // const point_TL__1 = Geometry.createPoint(1000,0);
              //   // const point_BR__1 = Geometry.createPoint(1600,700);
              //   // const arr_point__polygon1 = [...Array(4).keys()].map(i => Geometry.createRandomPoint(point_TL__1, point_BR__1));

              //   // rep_free__icPolygon.arr_point = arr_point__polygon1;
              //   rep_free__zPoint__start.position = {
              //     x: rep_free__zPoint__start.position.x + 50,
              //     y: rep_free__zPoint__start.position.y + 30,
              //   };

              //   setTimeout(step, 3000);
              // }

              // step();

            } catch(e) {
              logger.log("logZSegment", "error:", e);
            }


          }

        }


        debug_icPolygon() {

          const point_TL__1 = Geometry.createPoint(1000,0);
          const point_BR__1 = Geometry.createPoint(1600,700);
          const arr_point__polygon1 = [...Array(4).keys()].map(i => Geometry.createRandomPoint(point_TL__1, point_BR__1));
          logger.log("logIcPolygon", "arr_point__polygon1", arr_point__polygon1);

          const icPolygon = infiniteCanvas.createIcPolygon(arr_point__polygon1);
          logger.log("logIcPolygon", "icPolygon", icPolygon);
          infiniteCanvas.addIcObject(icPolygon);

          const rep_free__icPolygon = infiniteCanvas.getRepresented(icPolygon.id).r_free();

          function step() {

            const point_TL__1 = Geometry.createPoint(1000,0);
            const point_BR__1 = Geometry.createPoint(1600,700);
            const arr_point__polygon1 = [...Array(4).keys()].map(i => Geometry.createRandomPoint(point_TL__1, point_BR__1));

            rep_free__icPolygon.arr_point = arr_point__polygon1;
            rep_free__icPolygon.position = {
              x: rep_free__icPolygon.position.x + 100,
              y: rep_free__icPolygon.position.y + 50,
            };

            setTimeout(step, 3000);
          }

          try {
            step(); 
          } catch(e) {
            logger.log("logIcPolygon", "error:", e);
          }

        }

        debug_bigText() {

          try {

            const nb_lines          = 1;
            const nb_chars_per_line = 100;

            [...Array(10).keys()].forEach((index) => {

              const str__bigText = [...Array(nb_lines).keys()].reduce((acc, index1) => {
                const str__line = [...Array(nb_chars_per_line).keys()].map(index2 => Utils.randomElementInArray("abcdefghijklmnopqrstuvwxyz")).join("");
                acc = acc.concat(str__line).concat("\n");
                return acc;
              }, "");
              logger.log("logBigText", "str__bigText:", str__bigText);

              // const svgEl = SvgHelper.fromString(str__bigText);
              // const svgEl = TexHelper.toSvgEl(str__bigText);
              // logger.log("logBigText", "svgEl:", svgEl);
              // const icSvg = infiniteCanvas.createIcSvg(400,400, svgEl);
              // infiniteCanvas.addIcObject(icSvg);

              const icTex = infiniteCanvas.createIcTex(400, 400, str__bigText);
              icTex.stroke = "black";
              infiniteCanvas.addIcObject(icTex);

            });
            
          } catch(err) {
            logger.log("logBigText", "err:", err);
          }
          
        }

        debug_intersection() {
          logger.log("logAtelier", "debug_intersection");

          const id__icRect__lab = 3;
          const rep_free__icRect__lab = infiniteCanvas.getRepresented(id__icRect__lab).r_free(); 
          
          try {

            const engine = new IntersectionEngine();
            const eType  = "intersection";
            const icEngined = infiniteCanvas.installEngineOnIcObj(rep_free__icRect__lab, eType, engine);

            
            //initialize (==hydrate)
            const scopeObj = icEngined.getScopeObj(icEngined);
            scopeObj.infiniteCanvas = infiniteCanvas;

            engine.initialize(scopeObj);
            logger.log("logAtelier", "engine.awoken.scopeObj.infiniteCanvas:", engine.awoken.scopeObj.infiniteCanvas);

            //start
            engine.awoken.start();


          } catch(e) {
            logger.log("logAtelier", "error:", e);
          }

        }

        debug_complexNumbers() {

          const mathNode__complex1 = new math.ConstantNode(math.complex(3,2));
          logger.log("logComplex", "mathNode__complex1:", mathNode__complex1);

          const mathNode__complex2 = new math.ConstantNode(math.complex(10,100));
          logger.log("logComplex", "mathNode__complex2:", mathNode__complex2);

          const mathNode__sum = new math.OperatorNode("+", "add", [mathNode__complex1, mathNode__complex2]);
          logger.log("logComplex", "mathNode__sum:", mathNode__sum.evaluate({}));


          //modulus
          const trueRect__cx_modulus = {
            x: 200,
            y: 600,
            width:  100,
            height: 100,
          };
          const operator__modulus   = infiniteCanvas.createIcGMOperator_withType(trueRect__cx_modulus, "complex::modulus", {simplify: true});
          infiniteCanvas.addIcObject(operator__modulus);

          //argument
          const trueRect__cx_argument = {
            x: 800,
            y: 600,
            width:  100,
            height: 100,
          };
          const operator__argument   = infiniteCanvas.createIcGMOperator_withType(trueRect__cx_argument, "complex::argument");
          infiniteCanvas.addIcObject(operator__argument);

          //conj
          const trueRect__cx_conjugate = {
            x: 800,
            y: 100,
            width:  100,
            height: 100,
          };
          const operator__conjugate   = infiniteCanvas.createIcGMOperator_withType(trueRect__cx_conjugate, "complex::conjugate");
          infiniteCanvas.addIcObject(operator__conjugate);
          
        }

        debug_coordSystem() {

          //create grid
          const trueRect__grid__container = {
            x:      100,
            y:      100,
            width:  500,
            height: 500,
          };

          const icGrid = infiniteCanvas.createIcGrid(trueRect__grid__container, 11, 11);
          
          infiniteCanvas.addIcObject(icGrid);
          
        }

        debug_gradient() {

          const trueRect__circle = {
            x:      300,
            y:      400,
            width:  1000,
            height: 1000,
          };

          const pointCenter = Geometry.getCenterPoint(Geometry.createLTRect(trueRect__circle));
          const strokeWidth = 0;
          const radius = trueRect__circle.width / 2 - strokeWidth / 2;

          const gradient__fade = new fabric.Gradient({
            type: 'radial',
            // gradientUnits: 'pixels', 
            // coords: { x1: 0, y1: 0, x2: 0, y2: circle.height },
            // coords: { r1: 0, 
            //           r2: trueRect__circle.width, 
            //           x1: trueRect__circle.x + trueRect__circle.width  / 2.0, 
            //           y1: trueRect__circle.y + trueRect__circle.height / 2.0 
            // },

            gradientUnits: 'percentage',
            // coords: { x1: 0, y1: 0, x2: 1, y2: 1 },
            coords: { r1: 0, r2: 0.5, x1: 0.5, y1: 0.5 , x2: 0.5, y2: 0.5 },

            colorStops:[
              { offset: 0, color: ColorUtils.rgbaColorString(50,60,70,1.0) },
              { offset: 1, color: ColorUtils.rgbaColorString(50,60,70,0.0) },
              // { offset: 1, color: ColorUtils.rgbaColorString(150,60,170,1.0) },
            ],
          });
  
          const cfg_circle = {
            strokeWidth: strokeWidth,
            // stroke: "grey",

            // fillColor: "",
            fillColor: gradient__fade,
          };
          const icCircle = infiniteCanvas.createIcCircle(pointCenter, radius, cfg_circle);

          infiniteCanvas.addIcObject(icCircle);





          const trueRect__rect = {
            x:      100,
            y:      100,
            width:  1000,
            height: 1000,
          };

          const gradient__rainbow = new fabric.Gradient({
            type: 'linear',
            // gradientUnits: 'pixels', 
            // coords: { x1: 0, y1: 0, x2: 0, y2: circle.height },
            gradientUnits: 'percentage',
            coords: { x1: 0, y1: 0, x2: 1, y2: 1 },
            colorStops:[
              { offset: 0,    color: 'red' },
              { offset: 0.3,  color: 'blue' },
              { offset: 0.7,  color: 'yellow' },
              { offset: 1,    color: 'pink' },
            ],
          });

          const icRect = infiniteCanvas.createIcRect(trueRect__rect);
          icRect.fill = gradient__rainbow;

          infiniteCanvas.addIcObject(icRect);


          //create composite
          // const parts = {
          //   "circle": icCircle,
          //   "rect":   icRect,
          // };
          // const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
          // const trueRect__composite = {
          //   x: trueRect__rect.x - 50,
          //   y: trueRect__rect.y - 50,
          //   width:  50,
          //   height: 50,
          // };
          // const icComposite = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig);

          // infiniteCanvas.addIcObject(icComposite);
          




          // //magic
          // setTimeout(() => {
          //   const fObj_circle = fabricIntegration.getFObjForIcObj(icCircle);
          //   fObj_circle.isClippingObject = true;
          //   fObj_circle.visible = false;
          //   // fabricIntegration.fabricCanvas.remove(fObj_circle);

          //   const fObj_rect   = fabricIntegration.getFObjForIcObj(icRect);
  
          //   fObj_rect.clipPath = fObj_circle;
    
          // }, 1000);


          
        }


        debug_gradient2() {

          const trueRect__circle = {
            x:      0,
            y:      0,
            width:  1000,
            height: 1000,
          };

          const pointCenter = Geometry.getCenterPoint(Geometry.createLTRect(trueRect__circle));
          const strokeWidth = 0;
          const radius = trueRect__circle.width / 2 - strokeWidth / 2;

          const gradient__fade = new fabric.Gradient({
            type: 'radial',
            // gradientUnits: 'pixels', 
            // coords: { x1: 0, y1: 0, x2: 0, y2: circle.height },
            // coords: { r1: 0, 
            //           r2: trueRect__circle.width, 
            //           x1: trueRect__circle.x + trueRect__circle.width  / 2.0, 
            //           y1: trueRect__circle.y + trueRect__circle.height / 2.0 
            // },

            gradientUnits: 'percentage',
            // coords: { x1: 0, y1: 0, x2: 1, y2: 1 },
            coords: { r1: 0, r2: 0.5, x1: 0.5, y1: 0.5 , x2: 0.5, y2: 0.5 },

            colorStops:[
              { offset: 0, color: ColorUtils.rgbaColorString(50,60,70,1.0) },
              // { offset: 1, color: ColorUtils.rgbaColorString(50,60,70,0.0) },
              { offset: 1, color: ColorUtils.rgbaColorString(150,60,170,1.0) },
            ],
          });

          const cfg_circle = {
            strokeWidth: strokeWidth,
            // stroke: "grey",

            // fillColor: "",
            fillColor: gradient__fade,
          };
          const icCircle = infiniteCanvas.createIcCircle(pointCenter, radius, cfg_circle);

          infiniteCanvas.addIcObject(icCircle);





          //create grid
          const trueRect__grid__container = {
            x:      100,
            y:      100,
            width:  1000,
            height: 1000,
          };

          const icGrid = infiniteCanvas.createIcGrid(trueRect__grid__container, 11, 11);
          
          infiniteCanvas.addIcObject(icGrid);


          //create composite
          // const parts = {
          //   "circle": icCircle,
          //   "grid":   icGrid,
          // };
          // const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
          // const trueRect__composite = {
          //   x: trueRect__rect.x - 50,
          //   y: trueRect__rect.y - 50,
          //   width:  50,
          //   height: 50,
          // };
          // const icComposite = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig);

          // infiniteCanvas.addIcObject(icComposite);





          //magic
          setTimeout(() => {
            const fObj_circle = fabricIntegration.getFObjForIcObj(icCircle);
            fObj_circle.isClippingObject = true;
            // fObj_circle.visible = false;
            // fabricIntegration.fabricCanvas.remove(fObj_circle);

            const fObj_grid   = fabricIntegration.getFObjForIcObj(icGrid);
            fObj_grid.clipPath = fObj_circle;

            const rep_free__grid = infiniteCanvas.getRepresented(icGrid.id).r_free();
            logger.log("logGradient", "rep_free__grid", rep_free__grid);

            Object.entries(rep_free__grid.parts).forEach(([partName, icObj__part]) => {
              const fObj__part    = fabricIntegration.getFObjForIcObj(icObj__part);
              fObj__part.clipPath = fObj_circle;
            });

          }, 1000);



        }


        debug_varSlot() {

          const trueRect__icText = {
            x: 100,
            y: 100,
            width:  100,
            height: 100,
          };

          const str__1 = "Coucou !";
          const icText = infiniteCanvas.createIcText(trueRect__icText.x, trueRect__icText.y, str__1);

          const trueRect = {
            x: 100,
            y: 100,
            width:  100,
            height: 100,
          };

          const icGMWell = infiniteCanvas.createIcGMWell(trueRect, icText);

          infiniteCanvas.addIcObject(icGMWell);
        }

        debug_anonymousFunction() {

          // const mathNode__expr  = math.parse("300a+20b+1");
          // logger.log("logAnon", "mathNode__expr", mathNode__expr);

          // const mathNode__scope = new math.ObjectNode({a: new math.ConstantNode(3), b: new math.ConstantNode(4)});
          // logger.log("logAnon", "mathNode__scope", mathNode__scope);


        }

        debug_functionPlot() {



        }


        debug_apl() {

          //iota
          const trueRect__iota = {
            x: 500,
            y: 600,
            width:  100,
            height: 100,
          };
          const operator_iota = infiniteCanvas.createIcGMOperator_withType(trueRect__iota, "apl::iota");

          infiniteCanvas.addIcObject(operator_iota);

          //rho
          const trueRect__rho = {
            x: 500,
            y: 600,
            width:  100,
            height: 100,
          };
          const operator_rho = infiniteCanvas.createIcGMOperator_withType(trueRect__rho, "apl::rho");

          infiniteCanvas.addIcObject(operator_rho);

        }



        debug_applicableOperator() {

          //[[5]]
          const trueRect__5 = {
            x: 100,
            y: 100,
            width:  100,
            height: 100,
          };
          const icMathNode__5 = infiniteCanvas.createIcMathNode(trueRect__5.x, trueRect__5.y, new math.ConstantNode(5));

          infiniteCanvas.addIcObject(icMathNode__5);

          //[[5]]
          const trueRect__6 = {
            x: 100,
            y: 300,
            width:  100,
            height: 100,
          };
          const icMathNode__6 = infiniteCanvas.createIcMathNode(trueRect__6.x, trueRect__6.y, new math.ConstantNode(6));

          infiniteCanvas.addIcObject(icMathNode__6);


          const mathNode__anonFunction = new math.ObjectNode({
            type: new math.SymbolNode("anonFunction"),

            mathNode__arr_bound_var: new math.ArrayNode([new math.SymbolNode("x")]),
            expr:          math.parse("x + 10"),
          });

          //(+ 10)
          const trueRect__appOp = {
            x: 500,
            y: 600,
            width:  100,
            height: 100,
          };
          const appOp__plus10 = infiniteCanvas.createIcGMApplicableOperator_withType(trueRect__appOp, "from_anonFunctionObjectNode", {mathNode__anonFunction: mathNode__anonFunction});

          infiniteCanvas.addIcObject(appOp__plus10);


          //[+ 10]
          const trueRect__op = {
            x: 800,
            y: 800,
            width:  100,
            height: 100,
          };
          const op__plus10 = infiniteCanvas.createIcGMOperator_withType(trueRect__op, "from_anonFunctionObjectNode", {mathNode__anonFunction: mathNode__anonFunction});

          infiniteCanvas.addIcObject(op__plus10);

        }

        debug_anon5050Function() {

          //[[a]]
          const trueRect__symbol = {
            x: 100,
            y: 100,
            width:  100,
            height: 100,
          };
          const icMathNode__symbol = infiniteCanvas.createIcMathNode(trueRect__symbol.x, trueRect__symbol.y, new math.SymbolNode("a"));

          infiniteCanvas.addIcObject(icMathNode__symbol);

          //[[11]]
          const trueRect__constant = {
            x: 100,
            y: 300,
            width:  100,
            height: 100,
          };
          const icMathNode__constant = infiniteCanvas.createIcMathNode(trueRect__constant.x, trueRect__constant.y, new math.ConstantNode(11));

          infiniteCanvas.addIcObject(icMathNode__constant);


          //[?+ 10:+ 20:+ 30]
          const arr_bound_var = [new math.SymbolNode("x")];
          const arr_expr      = [math.parse("x + 10"), math.parse("x + 20"), math.parse("x + 30")];
          const mathNode__anon5050Function = MyAnon5050FunctionObjectNode.createInstance(arr_bound_var, arr_expr);

          logger.log("logAnon5050", "mathNode__anon5050Function:", mathNode__anon5050Function);

          const trueRect__op = {
            x: 800,
            y: 800,
            width:  100,
            height: 100,
          };
          const op__plus10 = infiniteCanvas.createIcGMOperator_withType(trueRect__op, "from_anon5050FunctionObjectNode", {mathNode__anon5050Function: mathNode__anon5050Function});

          infiniteCanvas.addIcObject(op__plus10);

        }


        debug_icArray() {

          const arr_icMathNode = [...Array(6).keys()].map((index) => {

            const trueRect__constant = {
              x: 100,
              y: 300,
              width:  100,
              height: 100,
            };
            const icMathNode__constant = infiniteCanvas.createIcMathNode(trueRect__constant.x, trueRect__constant.y, new math.ConstantNode(index));

            return icMathNode__constant;
          });

          const trueRect__icArray = {
            x: 100,
            y: 300,
            width:  100,
            height: 100,
          };

          const icArray = infiniteCanvas.createIcArray(trueRect__icArray, arr_icMathNode);
          infiniteCanvas.addIcObject(icArray);



          const arr_icMathNode2 = [...Array(6).keys()].map((index) => {

            const trueRect__constant = {
              x: 100,
              y: 300,
              width:  100,
              height: 100,
            };
            const icMathNode__constant = infiniteCanvas.createIcMathNode(trueRect__constant.x, trueRect__constant.y, new math.ConstantNode(index+100));

            return icMathNode__constant;
          });

          const trueRect__icArray2 = {
            x: 100,
            y: 600,
            width:  100,
            height: 100,
          };

          const icArray2 = infiniteCanvas.createIcArray(trueRect__icArray2, arr_icMathNode2);
          infiniteCanvas.addIcObject(icArray2);



          //stray mathNodes
          const arr_icMathNode3 = [...Array(6).keys()].map((index) => {

            const trueRect__constant = {
              x: 800,
              y: 300 + 100 * index,
              width:  100,
              height: 100,
            };
            const icMathNode__constant = infiniteCanvas.createIcMathNode(trueRect__constant.x, trueRect__constant.y, new math.ConstantNode(index));

            return icMathNode__constant;
          });
          arr_icMathNode3.forEach(icObj => {
            infiniteCanvas.addIcObject(icObj);
          });

        }



        debug_default_content() {

          //icText
          {
            const trueRect__icText = {
              x: 100,
              y: 100,
              width:  100,
              height: 100,
            };
  
            const str__1 = "Coucou ! ziufhzeiufhizeufhzeieufhze \niuzeziefu hzefizue fhzeif \n uzhfiz eufhzeif uhezifuzefhizeufh \n ziufh iufez";
            const icText = infiniteCanvas.createIcText(trueRect__icText.x, trueRect__icText.y, str__1);
            infiniteCanvas.addIcObject(icText);
          }

          //icMathNode
          {
            const trueRect__constant = {
              x: 800,
              y: 700,
              width:  100,
              height: 100,
            };
            const icMathNode__constant = infiniteCanvas.createIcMathNode(trueRect__constant.x, trueRect__constant.y, new math.ConstantNode(123));
            infiniteCanvas.addIcObject(icMathNode__constant);
          }

          //icImage
          {
            const trueRect_img = {
              x: 300,
              y: 800,
              width: 100,
              height: 100,
            };

            const img__file_p = FileIntegration.imageFromImgSrc_p("img/ic_better_logo_simple_trans_2.png");
            const img_p = img__file_p;

            img_p.then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img);
              icObj_front.scale.X = 0.5;
              icObj_front.scale.Y = 0.5;
              // infiniteCanvas.addIcObject(icObj_front);

              const icRect = infiniteCanvas.createIcImage(trueRect_img, img);
              infiniteCanvas.addIcObject(icRect);
            });
          }

          // //icPatternImage
          // {
          //   const trueRect_img = {
          //     x: 300,
          //     y: 800,
          //     width: 100,
          //     height: 100,
          //   };

          //   const img__file_p = FileIntegration.imageFromImgSrc_p("img/ic_better_logo_simple_trans_2.png");
          //   const img_p = img__file_p;

          //   img_p.then(img => {
          //     const icObj_front = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img);
          //     icObj_front.scale.X = 0.5;
          //     icObj_front.scale.Y = 0.5;
          //     // infiniteCanvas.addIcObject(icObj_front);

          //     const icRect = infiniteCanvas.createIcPatternRectImage(trueRect_img, img);
          //     infiniteCanvas.addIcObject(icRect);
          //   });
          // }

        }


        debug_printPovRect() {

          const trueRect_printPovRect = {
            x: 0,
            y: 0,
            width:  1000,
            height: 1000,
          };

          const icPrintPovRect = infiniteCanvas.createIcPrintPOVRect(trueRect_printPovRect);
          infiniteCanvas.addIcObject(icPrintPovRect);

          //create save_as button
          const trueRect_button = {
            x: trueRect_printPovRect.x + trueRect_printPovRect.width  * 2./3,
            y: trueRect_printPovRect.y + trueRect_printPovRect.height * 4./3,
            width:  100,
            height: 100,
          };
          const config__button = {
            buttonFunc: (scopeObj) => {
              const id__printPovRect = scopeObj.engineCarrier.buttonConfig.id__printPovRect;
              logger.log("logPrintPovRect", "id__printPovRect", id__printPovRect);

              const rep_free__printPovRect = scopeObj.infiniteCanvas.getRepresented(id__printPovRect).r_free();

              // save_as_img(scopeObj.infiniteCanvas, rep_free__printPovRect);

              //remove workbench border
              const strokeWidth_tmp = rep_free__printPovRect.strokeWidth; 
              rep_free__printPovRect.strokeWidth = 0;

              //capture area
              infiniteCanvas.exportCanvasRectContainingObj_asImg(rep_free__printPovRect, "ic_printPOVRect.png");

              //restore workbench border
              rep_free__printPovRect.strokeWidth = strokeWidth_tmp;

            },
            id__printPovRect: icPrintPovRect.id,
          };
          const icButton = infiniteCanvas.createIcButton(trueRect_button, config__button);
          infiniteCanvas.addIcObject(icButton);



          function save_as_img(infiniteCanvas, rep_free__printPovRect) {

            //remove workbench border
            const strokeWidth_tmp = rep_free__printPovRect.strokeWidth; 
            rep_free__printPovRect.strokeWidth = 0;

            //capture area
            infiniteCanvas.exportCanvasRectContainingObj_asImg(rep_free__printPovRect, "ic_printPOVRect.png");

            //restore workbench border
            rep_free__printPovRect.strokeWidth = strokeWidth_tmp;

          }

          function save_as_txt() {

          }

          function save_as_epub() {

          }

          function save_as_pdf() {
            
          }

        }


        debug_dive_op() {

          const trueRect_diveOp = {
            x: 0,
            y: 0,
            width:  200,
            height: 200,
          };

          const icDiveOp = infiniteCanvas.createIcDiveOperator_withType(trueRect_diveOp, "custom", {
            //horror?
            name: "+ 1",
            transformationFunc: (icObj) => {
              const func = operatorNodeFactoryFuncWrapper_binary(Operator.fromOpString_binary("+"), new math.ConstantNode(1)).func;
              const mathNode__new = func(icObj.mathNode);
              
              icObj.mathNode = mathNode__new;
              return TransformationOutput("mutated", icObj, icObj);
            },
          });
          // const icDiveOp = infiniteCanvas.createIcDiveOperator_withType(trueRect_diveOp, "from_string", {str__operator:"× 10"});
          infiniteCanvas.addIcObject(icDiveOp);

        }

        debug_innerCam() {

          //content
          this.debug_default_content();


          //innerCam
          const trueRect__innerCam = {
            x:      500,
            y:      500,
            width:    300,
            height:   300,
          }
          const icInnerCam = infiniteCanvas.createIcInnerCam(trueRect__innerCam);

          infiniteCanvas.addIcObject(icInnerCam);
        }

        debug_transportation() {

          {
            //rect
            const trueRect__rect = {
              x:        600,
              y:        600,
              width:    100,
              height:   100,
            };
            const icRect = infiniteCanvas.createIcRect(trueRect__rect);
            icRect.fill    = "blue";
            icRect.opacity = 0.2;
            infiniteCanvas.addIcObject(icRect);

            //icMathNode
            const trueRect__constant = {
              x:  trueRect__rect.x + 200,
              y:  trueRect__rect.y + 50,
              width:  100,
              height: 100,
            };
            const icMathNode__constant = infiniteCanvas.createIcMathNode(trueRect__constant.x, trueRect__constant.y, new math.ConstantNode(1));
            infiniteCanvas.addIcObject(icMathNode__constant);
          }

          {
            //rect
            const trueRect__rect = {
              x:        6600,
              y:        6600,
              width:    100,
              height:   100,
            };
            const icRect = infiniteCanvas.createIcRect(trueRect__rect);
            icRect.fill    = "orange";
            icRect.opacity = 0.2;
            infiniteCanvas.addIcObject(icRect);

            //icMathNode
            const trueRect__constant = {
              x:  trueRect__rect.x + 200,
              y:  trueRect__rect.y + 50,
              width:  100,
              height: 100,
            };
            const icMathNode__constant = infiniteCanvas.createIcMathNode(trueRect__constant.x, trueRect__constant.y, new math.ConstantNode(2));
            infiniteCanvas.addIcObject(icMathNode__constant);
          }


          {
            //icText
            const trueRect1 = {
              x:        1600,
              y:        1600,
              width:    100,
              height:   100,
            };
            const icText1 = infiniteCanvas.createIcText(trueRect1.x, trueRect1.y, "abc");
            icText1.textColor    = "blue";

            //icText
            const trueRect2 = {
              x:        5600,
              y:        5600,
              width:    10,
              height:   10,
            };
            const icText2 = infiniteCanvas.createIcText(trueRect2.x, trueRect2.y, "abc123456789");
            icText2.textColor = "orange";
            icText2.homeScale = {
              X: 70,
              Y: 70,
            };

            const trueRect__composite = {
              x:      1200,
              y:      1400,
              width:   150,
              height:   50,
            };

            const parts = {
              "text1": icText1,
              "text2": icText2,
            };

            const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

            const icComposite = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig);

            infiniteCanvas.addIcObject(icComposite);
          }

        }

        debug_portal() {

          // //rect
          // const trueRect__rect1 = {
          //   x:        600,
          //   y:        600,
          //   width:    100,
          //   height:   100,
          // };
          // const icRect1 = infiniteCanvas.createIcRect(trueRect__rect1);
          // icRect1.fill    = "blue";
          // icRect1.opacity = 0.2;
          // infiniteCanvas.addIcObject(icRect1);

          // const trueRect__rect2 = {
          //   x:        610,
          //   y:        610,
          //   width:    20,
          //   height:   20,
          // };
          // const icRect2 = infiniteCanvas.createIcRect(trueRect__rect2);
          // icRect2.fill    = "orange";
          // icRect2.opacity = 0.3;
          // infiniteCanvas.addIcObject(icRect2);


          // //diveOp
          // const trueRect_diveOp = {
          //   x: 0,
          //   y: 0,
          //   width:  200,
          //   height: 200,
          // };

          // const icDiveOp = infiniteCanvas.createIcDiveOperator_withType(trueRect_diveOp, "custom", {
          //   //horror?
          //   name: "entrance",
          //   transformationFunc: (icObj) => {
          //     logger.log("LogPortal", "transformationFunc", "this:", this);

          //     const rep_free__diveOp = infiniteCanvas.getRepresented(icDiveOp.id).r_free();
          //     const rep_free__rect1  = infiniteCanvas.getRepresented(icRect1.id).r_free();

          //     const pov__in   = infiniteCanvas.getCurrentPov();
          //     logger.log("LogPortal", "transformationFunc", "pov__in:", pov__in);
              
          //     const pov__out = infiniteCanvas.getPov2WrtIcObj2_sameWayAsPov1WrtIcObj1(rep_free__rect1, pov__in, rep_free__diveOp);
          //     logger.log("LogPortal", "transformationFunc", "pov__out:", pov__out);

          //     infiniteCanvas.set_pov(pov__out);


          //     const transformationOutput = new TransformationOutput("mutated", icObj, icObj);
          //     return transformationOutput;
          //   },
          // });
          // // const icDiveOp = infiniteCanvas.createIcDiveOperator_withType(trueRect_diveOp, "from_string", {str__operator:"× 10"});
          // infiniteCanvas.addIcObject(icDiveOp);

          //portal
          {
            const trueRect__rect1 = {
              x:        1000,
              y:        1000,
              width:    100,
              height:   100,
            };
            const trueRect__rect2 = {
              x:        600,
              y:        100,
              width:    50,
              height:   50,
            };
  
            const icPortal = infiniteCanvas.createIcPortal(trueRect__rect1, trueRect__rect2);
  
            infiniteCanvas.addIcObject(icPortal);
          }

          //portal
          {
            const trueRect__rect3 = {
              x:        605,
              y:        115,
              width:    10,
              height:   10,
            };
            const trueRect__rect4 = {
              x:        800,
              y:        800,
              width:    400,
              height:   400,
            };
  
            const icPortal = infiniteCanvas.createIcPortal(trueRect__rect3, trueRect__rect4);
            icPortal.parts.rect__in.opacity  = 0.5;
            icPortal.parts.rect__out.opacity = 0.5;
  
            infiniteCanvas.addIcObject(icPortal);
          }

          //innerCamPortal
          {
            const trueRect__rect1 = {
              x:        0,
              y:        0,
              width:    100,
              height:   100,
            };
            const trueRect__rect2 = {
              x:        -500,
              y:        -500,
              width:    50,
              height:   50,
            };
  
            // const icInnerCamPortal = infiniteCanvas.createIcInnerCamPortal(trueRect__rect1, trueRect__rect2);
  
            // infiniteCanvas.addIcObject(icInnerCamPortal);
          }


        }


        debug_curve3() {

          const point1 = {x: 100, y: 100};
          const point2 = {x: 500, y: 200};
          const point3 = {x: 100, y: 900};

          const arr_point = [point1, point2, point3];

          const icCurve3 = infiniteCanvas.createIcCurve3(...arr_point);
          infiniteCanvas.addIcObject(icCurve3);

          // arr_point.forEach((point) => {
          //   const icPoint = infiniteCanvas.createIcPoint(point);
          //   icPoint.fill = "yellow";
            
          //   infiniteCanvas.addIcObject(icPoint);
          // });

        
          // const icCompositeCurve3 = infiniteCanvas.createIcCompositeCurve3(...arr_point);
          // infiniteCanvas.addIcObject(icCompositeCurve3);

        }

        debug_zcurve3() {

          const point1 = {x: -100, y: 100};
          const point2 = {x: 900, y: 200};
          // const point3 = {x: 300, y: 900};
          const point3 = {x: -600, y: 500};


          const arr_point  = [point1, point2, point3];
          const arr_radius = [100,350,150];

          // //debug
          // Utils.zip(arr_point, arr_radius).forEach(([pointCenter, radius]) => {
          //   const point__up = {
          //     x: pointCenter.x,
          //     y: pointCenter.y - radius,
          //   };
          //   const icPoint = infiniteCanvas.createIcPoint(point__up);
          //   infiniteCanvas.addIcObject(icPoint);
          // });

          const arr_icCircle = Utils.zip(arr_point, arr_radius).map(([pointCenter, radius]) => {

            const cfg_circle__bg = {
              strokeWidth: 2,
              stroke: "grey",
              fillColor: ColorUtils.randomColor(),
            };

            const icCircle = infiniteCanvas.createIcCircle(pointCenter, radius, cfg_circle__bg);

            return icCircle;
          });

          arr_icCircle.forEach((icCircle) => {
            infiniteCanvas.addIcObject(icCircle);
          });

          const icCurve3__mid = infiniteCanvas.createIcCurve3(...arr_point);
          infiniteCanvas.addIcObject(icCurve3__mid);

          const arr_point__curve_mid = Geometry.getArrPoint_curve_easy(arr_point);

          //func_amplitude
          // {
            // function func_amplitude__up(progress) {
            //   return 50*progress*progress + 5;
            // }

            function func_amplitude__up(progress) {
              var amp__raw;
              if(progress<0.5) {
                amp__raw = (arr_radius[1] - arr_radius[0]) * (2 * (progress - 0.0)) + arr_radius[0]; 
              } else {
                amp__raw = (arr_radius[2] - arr_radius[1]) * (2 * (progress - 0.5)) + arr_radius[1]; 
              }
              logger.log("logCurve", "amp__raw:", amp__raw);
              return amp__raw;
            }

            // function func_amplitude__up(progress) {
            //   return 50;
            // }

            function func_amplitude__down(progress) {
              return -0.1*func_amplitude__up(progress);
            }

            // const arr_point__curve_mid   = Geometry.getArrPoint_curve_easy(arr_point);

            const arr_point__curve3_up   = Geometry.createArrPoint_carriedFunc(arr_point__curve_mid, func_amplitude__up);
            // logger.log("logCurve3", "arr_point__curve3_up:", arr_point__curve3_up);
            const arr_point__curve3_down = Geometry.createArrPoint_carriedFunc(arr_point__curve_mid, func_amplitude__down);

            arr_point__curve3_up.forEach((point) => {
              const icPoint = infiniteCanvas.createIcPoint(point);
              icPoint.fill = "blue";
              
              infiniteCanvas.addIcObject(icPoint);
            });

            arr_point__curve3_down.forEach((point) => {
              const icPoint = infiniteCanvas.createIcPoint(point);
              icPoint.fill = "orange";
              
              infiniteCanvas.addIcObject(icPoint);
            });

          // }

          //curve3__up and curve3__down
          {
            function func_amplitude__up(progress) {
              var amp__raw;
              if(progress<0.5) {
                amp__raw = (arr_radius[1] - arr_radius[0]) * (2 * (progress - 0.0)) + arr_radius[0]; 
              } else {
                amp__raw = (arr_radius[2] - arr_radius[1]) * (2 * (progress - 0.5)) + arr_radius[1]; 
              }
              logger.log("logCurve", "amp__raw:", amp__raw);
              return amp__raw;
            }

            function func_amplitude__down(progress) {
              return -func_amplitude__up(progress);
            }

            const arr_point__curve3_up   = Geometry.createArrPoint_carriedFunc(arr_point__curve_mid, func_amplitude__up);
            // logger.log("logCurve3", "arr_point__curve3_up:", arr_point__curve3_up);
            const arr_point__curve3_down = Geometry.createArrPoint_carriedFunc(arr_point__curve_mid, func_amplitude__down);

            const index__half = math.floor(arr_point__curve_mid.length / 2.0);

            const arr_point__up   = [
              arr_point__curve3_up[0],
              arr_point__curve3_up[index__half],
              arr_point__curve3_up.slice(-1)[0],
            ];
            
            const arr_point__down = [
              arr_point__curve3_down[0],
              arr_point__curve3_down[index__half],
              arr_point__curve3_down.slice(-1)[0],
            ];

            const icCurve3__up = infiniteCanvas.createIcCurve3(...arr_point__up);
            infiniteCanvas.addIcObject(icCurve3__up);

            const icCurve3__down = infiniteCanvas.createIcCurve3(...arr_point__down);
            infiniteCanvas.addIcObject(icCurve3__down);




            //attempt in mixing the 2 approaches
            // const arr_point__curve3_down2 = Geometry.getArrPoint_curve_easy(arr_point__down);

            // const arr_point__curve3_down3 = Utils.zip(arr_point__curve3_down2, arr_point__curve3_down).map(([point_down2, point_down]) => {
            //   return Geometry.pointOnSegment__progress(point_down2, point_down, 0.1);
            // });

            // arr_point__curve3_down3.forEach((point) => {
            //   const icPoint = infiniteCanvas.createIcPoint(point);
            //   icPoint.fill = "cyan";
              
            //   infiniteCanvas.addIcObject(icPoint);
            // });
            
          }

          //path of circles
          // {
          //   const nb_skipped_circles = 2;
          //   var counter__skip = 0;

          //   arr_point__curve_mid.forEach((point__curve_mid, index) => {
          //     const progress = index / arr_point__curve_mid.length;
              
          //     function func_radius(progress) {
          //       var outRadius;
          //       if(progress<0.5) {
          //         outRadius = (arr_radius[1] - arr_radius[0]) * (2 * (progress - 0.0)) + arr_radius[0]; 
          //       } else {
          //         outRadius = (arr_radius[2] - arr_radius[1]) * (2 * (progress - 0.5)) + arr_radius[1]; 
          //       }
          //       logger.log("logCurve", "outRadius:", outRadius);
          //       return outRadius;
          //     }

          //     if(counter__skip == 0) {

          //       const cfg_circle__bg = {
          //         strokeWidth: 2,
          //         stroke: "grey",
          //         // fillColor: ColorUtils.randomColor(),
          //         fillColor: "black",
          //       };

          //       const pointCenter = point__curve_mid;
          //       const radius = func_radius(progress); 
    
          //       const icCircle = infiniteCanvas.createIcCircle(pointCenter, radius, cfg_circle__bg);

          //       infiniteCanvas.addIcObject(icCircle);
          //     }
          //     counter__skip = (counter__skip + 1) % nb_skipped_circles;

          //   });
          // }


          // const icPath = infiniteCanvas.createIcPath(arr_point);


          // const icZCurve3 = 

        }


        //debug_awaiting_operator() {
        //
        //  const config__op = infiniteCanvas.createConfig__icGMOperator_withType("math::plus");
        //
        //  const icAwaitingOp__plus = infiniteCanvas.createIcAwaitingOperator_from_opConfig(trueRect, config__op);
        //
        //}

        debug_sleepingArgs_operator() {

          function icObjTransformationFunc(icObj) {
            var transformationOutput;

            const arr_arg__sleeping      = infiniteCanvas.getArr_icObj("free").filter((icObj) => icObj.isSleeping);

            if(arr_arg__sleeping.length == 0) {
            // if(arr_arg__sleeping.length < 2) {

              icObj.isSleeping = true;

            } else {

              const arr_mathNode__sleeping = arr_arg__sleeping.map((icMathNode) => icMathNode.mathNode);

              function createMathNode__result_sum(arr_mathNode) {
  
                const arr_value  = arr_mathNode.map((mathNode) => mathNode.value);
                const value__sum = math.sum(arr_value);
  
                const mathNode__new = new math.ConstantNode(value__sum);
                return mathNode__new;
              }            
  
              icObj.mathNode = createMathNode__result_sum([icObj.mathNode, ...arr_mathNode__sleeping]);

              //consume all sleeping args 
              arr_arg__sleeping.forEach((icObj__sleeping) => {
                icObj__sleeping.im_dying_now = true;
              });

            }

            transformationOutput = new TransformationOutput("mutated", icObj, icObj);

            return transformationOutput;
          }

          const config__op = {
            name: "zZz(2) +",
            facade: null,
            transformationFunc: icObjTransformationFunc,
          };

          const trueRect = {
            x:      800,
            y:      800,
            width:  200,
            height: 200,
          };

          const icSleepingArgsOp = infiniteCanvas.createIcGMOperator_withConfig(trueRect, config__op);
          infiniteCanvas.addIcObject(icSleepingArgsOp);

          [
            {x: 100, y: 100},
            {x: 100, y: 400},
            {x: 100, y: 700},
          ].forEach((position) => {
            const mathNode   = random_constantNode();
            const icMathNode = infiniteCanvas.createIcMathNode(position.x, position.y, mathNode);
            infiniteCanvas.addIcObject(icMathNode);
          });

        }


        debug_numberTyping() {

          // const icNumberTypingOp = infiniteCanvas.createIcGMOperator_withConfig(trueRect, config__op);
          // infiniteCanvas.addIcObject(icSleepingArgsOp);

        }


        debug_touchHook() {

          const mathNode__anonFunction = new math.ObjectNode({
            type: new math.SymbolNode("anonFunction"),

            mathNode__arr_bound_var: new math.ArrayNode([new math.SymbolNode("x")]),
            expr:          math.parse("x + 10"),
          });

          //[+ 10]
          const trueRect__op = {
            x: 200,
            y: 200,
            width:  100,
            height: 100,
          };
          const op__plus10 = infiniteCanvas.createIcGMOperator_withType(trueRect__op, "from_anonFunctionObjectNode", {mathNode__anonFunction: mathNode__anonFunction});

          infiniteCanvas.addIcObject(op__plus10);


          infiniteCanvas.onSpecificIcObjUpdate(op__plus10, function(icObj, updateDict) {
            // logger.log("onSpecificIcObjUpdate", "id:", op__plus10.id, "updateDict:", updateDict);

            if("isDidApply" in updateDict && updateDict["isDidApply"].new == true) {
              logger.log("isDidApply spike");

              

            }

          });


          // const trueRect__hook = {
          //   x: 500,
          //   y: 500,
          //   width:  100,
          //   height: 100,
          // };
          // const op__hook = infiniteCanvas.createIcTouchHook(trueRect__op);
          // infiniteCanvas.addIcObject(op__hook);


          //icMathNode
          const trueRect__constant = {
            x:  900,
            y:  50,
            width:  100,
            height: 100,
          };
          const icMathNode__constant = infiniteCanvas.createIcMathNode(trueRect__constant.x, trueRect__constant.y, new math.ConstantNode(1));
          infiniteCanvas.addIcObject(icMathNode__constant);


          const trueRect__pokeSlot = {
            x:  900,
            y:  400,
            width:  100,
            height: 100,
          };
          const pokeSlotConfig = {
            transformationFunc: (icObj) => {
              icObj.stroke = ColorUtils.randomColor();
              // icObj.fill = ColorUtils.randomColor();

              const rep_free__poked = infiniteCanvas.getRepresented(icObj.id).r_free();
              infiniteCanvas.animate_bounce(rep_free__poked);

              return new TransformationOutput("mutated", icObj, icObj);
            },
            isEnabled: true,
          }; 
          const icPokeSlot = infiniteCanvas.createIcPokeSlot(trueRect__pokeSlot, pokeSlotConfig);
          const transformationFunc = icPokeSlot.pokeSlotConfig.transformationFunc;
          //debug
          // const transformationFunc__decorated = function(icObj) {
          //   var transformationOutput;

          //   transformationOutput = transformationFunc(icObj);

          //   const rep_free__pokeSlot = infiniteCanvas.getRepresented(icPokeSlot.id).r_free();
          //   infiniteCanvas.animate_bounce(rep_free__pokeSlot);

          //   return transformationOutput;
          // };
          // icPokeSlot.pokeSlotConfig.transformationFunc = transformationFunc__decorated;
          infiniteCanvas.addIcObject(icPokeSlot);

        }


        debug_buttonConfig() {

          //create icRect1
          const trueRect__rect1 = {
            x:        600,
            y:        600,
            width:    300,
            height:   300,
          };
          const icRect1 = infiniteCanvas.createIcRect(trueRect__rect1);
          icRect1.fill    = "blue";
          icRect1.opacity = 0.2;
          infiniteCanvas.addIcObject(icRect1);

          //create icRect2
          const trueRect__rect2 = {
            x:        1000,
            y:        1000,
            width:    300,
            height:   300,
          };
          const icRect2 = infiniteCanvas.createIcRect(trueRect__rect2);
          icRect2.fill    = "orange";
          icRect2.opacity = 0.2;
          infiniteCanvas.addIcObject(icRect2);

          //create button
          const trueRect_button = {
            x: 100,
            y: 100,
            width:  100,
            height: 100,
          };
          const config__button = {
            buttonFunc: (scopeObj) => {
              const id__icRect1 = scopeObj.engineCarrier.buttonConfig.id__icRect1;

              const rep_free__rect1 = scopeObj.infiniteCanvas.getRepresented(id__icRect1).r_free();

              rep_free__rect1.fill = "yellow";
            },
            id__icRect1: icRect1.id,
          };
          const icButton = infiniteCanvas.createIcButton(trueRect_button, config__button);
          infiniteCanvas.addIcObject(icButton);

          //hot editing of buttonConfig
          setTimeout(() => {

            const config__button = {
              buttonFunc: (scopeObj) => {
                const id__icRect2 = scopeObj.engineCarrier.buttonConfig.id__icRect2;
  
                const rep_free__rect2 = scopeObj.infiniteCanvas.getRepresented(id__icRect2).r_free();
  
                rep_free__rect2.fill = ColorUtils.randomColor();
              },
              id__icRect2: icRect2.id,
            };

            const rep_free__button = infiniteCanvas.getRepresented(icButton.id).r_free();
            rep_free__button.buttonConfig = config__button; 
            
          }, 3000);

        }

        debug_pyramidOfOperators() {

        }


        debug_generator() {
          //[[5]]
          const trueRect__5 = {
            x: 100,
            y: 100,
            width:  100,
            height: 100,
          };
          const icMathNode__5 = infiniteCanvas.createIcMathNode(trueRect__5.x, trueRect__5.y, new math.ConstantNode(5));

          //[[6]]
          const trueRect__6 = {
            x: 100,
            y: 300,
            width:  100,
            height: 100,
          };
          const icMathNode__6 = infiniteCanvas.createIcMathNode(trueRect__6.x, trueRect__6.y, new math.ConstantNode(6));

          //(spawn(5))
          const trueRect__appOp_5 = {
            x: 500,
            y: 600,
            width:  100,
            height: 100,
          };
          const appOp__spawn5 = infiniteCanvas.createIcGMApplicableOperator_withType(trueRect__appOp_5, "spawner", {
            str__spawned: icMathNode__5.mathNode.toString(),
            icObj_sample: icMathNode__5,
          });

          infiniteCanvas.addIcObject(appOp__spawn5);

          //(spawn(6))
          const trueRect__appOp_6 = {
            x: 850,
            y: 600,
            width:  100,
            height: 100,
          };
          const appOp__spawn6 = infiniteCanvas.createIcGMApplicableOperator_withType(trueRect__appOp_6, "spawner", {
            str__spawned: icMathNode__6.mathNode.toString(),
            icObj_sample: icMathNode__6,
          });

          infiniteCanvas.addIcObject(appOp__spawn6);





          //[[+ 10]]
          const mathNode__anonFunction = new math.ObjectNode({
            type: new math.SymbolNode("anonFunction"),

            mathNode__arr_bound_var: new math.ArrayNode([new math.SymbolNode("x")]),
            expr:                    math.parse("x + 10"),
          });

          //[+ 10]
          const trueRect__op__plus10 = {
            x: 800,
            y: 800,
            width:  100,
            height: 100,
          };
          const op__plus10 = infiniteCanvas.createIcGMOperator_withType(trueRect__op__plus10, "from_anonFunctionObjectNode", {mathNode__anonFunction: mathNode__anonFunction});

          //(spawn([+ 10]))
          const trueRect__appOp_spawn_plus10 = {
            x: 500,
            y: 1000,
            width:  100,
            height: 100,
          };
          const appOp_spawn_plus10 = infiniteCanvas.createIcGMApplicableOperator_withType(trueRect__appOp_spawn_plus10, "spawner", {
            str__spawned: "[+ 10]",
            icObj_sample: op__plus10,
          });

          infiniteCanvas.addIcObject(appOp_spawn_plus10);

        }

        debug_operator_cloning() {

          const atelier = this;

          //create debug operator
          const gmOperator__debug = infiniteCanvas.createIcGMOperator_withType(atelier.trueRect1, "debug", {"stroke": "oh yes"});
          infiniteCanvas.addIcObject(gmOperator__debug);

          //create [+ 2] operator
          const gmOperator__plus2 = infiniteCanvas.createIcGMOperator_withType(atelier.trueRect2, "from_string", {str__operator:"+ 2"});
          infiniteCanvas.addIcObject(gmOperator__plus2);
        }

        debug_ghost() {

          //[[5]]
          const trueRect__mathNode = {
            x: 100,
            y: 100,
            width:  100,
            height: 100,
          };
          const icMathNode = infiniteCanvas.createIcMathNode(trueRect__mathNode.x, trueRect__mathNode.y, new math.ConstantNode(5));


          infiniteCanvas.onceOnAddRepresentedForIcObject(icMathNode, (icMathNode) => {

            const rep_free__mathNode = infiniteCanvas.getRepresented(icMathNode.id).r_free();

            // infiniteCanvas.onScreenPovChange((pov__screen, updatesDict) => {
            infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
              logger.log("logGhost", "infiniteCanvas.scale.X:", infiniteCanvas.scale.X);

              const pov__screen = infiniteCanvas.getCurrentPov();

              //compute "ghost" distance
              const trueRect__mathNode  = rep_free__mathNode.getTrueRect2();
              const trueRect__screenPov = pov__screen.getTrueRect2();
              
              const trueArea__mathNode  = trueRect__mathNode.width  * trueRect__mathNode.height; 
              const trueArea__screenPov = trueRect__screenPov.width * trueRect__screenPov.height;

              function ghostDistanceMiniDict(trueArea__icObj, trueArea__screenPov) {
                const [trueArea__min, trueArea__max] = math.sort([trueArea__icObj, trueArea__screenPov]);

                const distance = trueArea__max / trueArea__min - 1;

                const distance__bounded = math.max(distance, 1e-20);

                const miniDict = {
                  ghostDistance:     distance__bounded,
                  isPovInsideGhost: (trueArea__min == trueArea__screenPov),
                };

                return miniDict;
              }

              function ghostOpacity(ghostDistanceMiniDict, ghostConfigDict_in = null) {
                var outOpacity;

                var ghostConfigDict;
                if(ghostConfigDict_in != null) {
                  ghostConfigDict = ghostConfigDict_in;
                } else {
                  ghostConfigDict = {
                    ghostDistance__fullOpacity__povIsOutsideGhost: 10.0,
                    ghostDistance__fullOpacity__povIsInsideGhost:  0.1,
                  };
                }

                const ghostDistance = ghostDistanceMiniDict.ghostDistance;

                var ghostDistance__fullOpacity;
                if(ghostDistanceMiniDict.isPovInsideGhost) {
                  ghostDistance__fullOpacity = ghostConfigDict.ghostDistance__fullOpacity__povIsInsideGhost;
                } else {
                  ghostDistance__fullOpacity = ghostConfigDict.ghostDistance__fullOpacity__povIsOutsideGhost;
                }

                const opacity__ghost__raw = math.min(1.0 / ghostDistance, 1.0);
                logger.log("logGhost", "opacity__ghost__raw:", opacity__ghost__raw);

                const opacity__ghost__refined = math.min(ghostDistance__fullOpacity / ghostDistance, 1.0);
                logger.log("logGhost", "opacity__ghost__refined:", opacity__ghost__refined);
                
                const func__easing            = anime.easing("easeOutExpo", 1.0);
                // const func__easing            = anime.easing("linear", 1.0);
                const opacity__ghost__eased = func__easing(opacity__ghost__refined);
                logger.log("logGhost", "opacity__ghost__eased:", opacity__ghost__eased);

                // outOpacity = opacity__ghost__raw;
                // outOpacity = opacity__ghost__refined;
                outOpacity = opacity__ghost__eased;

                return outOpacity;
              }

              const ghostDistance__fullOpacity__povIsOutsideGhost = 30.0;
              const ghostDistance__fullOpacity__povIsInsideGhost  = 0.03;
              // const ghostDistance__fullOpacity__povIsInsideGhost  = math.Infinity;
              const ghostConfigDict = {
                ghostDistance__fullOpacity__povIsOutsideGhost: ghostDistance__fullOpacity__povIsOutsideGhost,
                ghostDistance__fullOpacity__povIsInsideGhost:  ghostDistance__fullOpacity__povIsInsideGhost,
              };

              const ghostDistanceMiniDict_ = ghostDistanceMiniDict(trueArea__mathNode, trueArea__screenPov);
              const ghostDistance_         = ghostDistanceMiniDict_.ghostDistance;
              const ghostOpacity_          = ghostOpacity(ghostDistanceMiniDict_, ghostConfigDict);

              //debug
              // rep_free__mathNode.mathNode = new math.ConstantNode(ghostDistance_); 

              //ghost effect
              rep_free__mathNode.opacity = ghostOpacity_;

            });

          });


          infiniteCanvas.addIcObject(icMathNode);

          // //debug: hot editing of icMathNode.mathNode
          // setTimeout(() => {

          //   const rep_free__mathNode = infiniteCanvas.getRepresented(icMathNode.id).r_free();
          //   rep_free__mathNode.mathNode = new math.ConstantNode(3017); 
            
          // }, 3000);

          

        }

        debug_neveremptiness() {

          this.spawnRectGrid();

          infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
            logger.log("logNeveremptiness", "infiniteCanvas.scale.X:", infiniteCanvas.scale.X);


            const screenSize__pixel = infiniteCanvas.getScreenSize__forScreenPixel();
            logger.log("logNeveremptiness", "screenSize__pixel:", screenSize__pixel);

            const trueSize__pixel = infiniteCanvas.getTrueSize__forScreenPixel();
            logger.log("logNeveremptiness", "trueSize__pixel:", trueSize__pixel);



            const isEmptyScreenPov_ = infiniteCanvas.isEmptyScreenPov();
            logger.log("logNeveremptiness", "isEmptyScreenPov_:", isEmptyScreenPov_);

            const isEmptyScreenPov__noticeablyWise_ = infiniteCanvas.isEmptyScreenPov__noticeablyWise();
            logger.log("logNeveremptiness", "isEmptyScreenPov__noticeablyWise_:", isEmptyScreenPov__noticeablyWise_);

            //debug 1
            // if(isEmptyScreenPov__noticeablyWise_) {
            //   const pov__screen         = infiniteCanvas.getCurrentPov();
            //   const trueRect__screenPov = pov__screen.getTrueRect2();
            //   const position__screenPov__center = Geometry.getCenterPoint(Geometry.createLTRect(trueRect__screenPov)); 

            //   const icText = infiniteCanvas.createIcText(position__screenPov__center.x, position__screenPov__center.y, "neveremptiness");
            //   icText.isUsingCenterPosition = true; 

            //   infiniteCanvas.addIcObject(icText);
            // }

            //debug 2
            if(isEmptyScreenPov__noticeablyWise_) {
              // const pov__initial = infiniteCanvas.getPov__initial();
              // infiniteCanvas.move_to_pov__animation(pov_initial);

              const trueRect__initial = {
                x: -500,
                y: -500,
                width: 1920,
                height: 1080,
              };

              const cfg_anim__easy = {
                duration: 10,
              };

              infiniteCanvas.move_to_rect__animation(trueRect__initial, cfg_anim__easy);
            }


          });
          

        }

        debug_nevercompleteness() {

          this.spawnRectGrid();

          infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
            logger.log("logNevercompleteness", "infiniteCanvas.scale.X:", infiniteCanvas.scale.X);


            const screenSize__pixel = infiniteCanvas.getScreenSize__forScreenPixel();
            logger.log("logNevercompleteness", "screenSize__pixel:", screenSize__pixel);

            const trueSize__pixel__screen = infiniteCanvas.getTrueSize__forScreenPixel();
            logger.log("logNevercompleteness", "trueSize__pixel__screen:", trueSize__pixel__screen);


            //debug
            // const icObj__eminent = infiniteCanvas.getIcObj__eminentObject();
            // logger.log("logNevercompleteness", "icObj__eminent:", icObj__eminent);

            // if(icObj__eminent != null) {
            //   const trueSize__pixel__eminentObject = infiniteCanvas.getTrueSize__forObjectPixel(icObj__eminent);
            //   logger.log("logNevercompleteness", "trueSize__pixel__eminentObject:", trueSize__pixel__eminentObject);
            // }


            // const isCompleteScreenPov_ = infiniteCanvas.isCompleteScreenPov();
            // logger.log("logNevercompleteness", "isCompleteScreenPov_:", isCompleteScreenPov_);

            const icObj__completenessObject = infiniteCanvas.getIcObj__completenessObject();
            logger.log("logNevercompleteness", "icObj__completenessObject:", icObj__completenessObject);

            const isCompleteScreenPov__noticeablyWise_ = infiniteCanvas.isCompleteScreenPov__noticeablyWise();
            logger.log("logNevercompleteness", "isCompleteScreenPov__noticeablyWise_:", isCompleteScreenPov__noticeablyWise_);

            //debug 1
            if(isCompleteScreenPov__noticeablyWise_) {
              const pov__screen         = infiniteCanvas.getCurrentPov();
              const trueRect__screenPov = pov__screen.getTrueRect2();
              const position__screenPov__center = Geometry.getCenterPoint(Geometry.createLTRect(trueRect__screenPov)); 

              const icText = infiniteCanvas.createIcText(position__screenPov__center.x, position__screenPov__center.y, "nevercompleteness");
              icText.isUsingCenterPosition = true;
              icText.zIndex = 300; 

              infiniteCanvas.addIcObject(icText);
            }

            //debug 2
            // if(isCompleteScreenPov__noticeablyWise_) {
            //   // const pov__initial = infiniteCanvas.getPov__initial();
            //   // infiniteCanvas.move_to_pov__animation(pov_initial);

            //   const trueRect__initial = {
            //     x: -500,
            //     y: -500,
            //     width: 1920,
            //     height: 1080,
            //   };

            //   const cfg_anim__easy = {
            //     duration: 10,
            //   };

            //   infiniteCanvas.move_to_rect__animation(trueRect__initial, cfg_anim__easy);
            // }


          });
          

        }

        debug_ioPasteScroll() {
          this.spawnRectGrid();
          



        }


        debug_batchPasteScroll() {


        }


        debug_stickerStroke() {
          this.spawnRectGrid();


        }

        debug_selection() {

          const config__gridBig = {
            position: {
              x: 100,
              y: 100,
            },
            size__childRect: {
              width:  200,
              height: 200,
            },
            spacing: {
              X: 100,
              Y: 100,
            },
            nb_rows: 4,
            nb_cols: 4,
          };
          this.spawnRectGrid(config__gridBig);
          const config__gridSmall = {
            position: {
              x: 310,
              y: 100,
            },
            size__childRect: {
              width:  2,
              height: 2,
            },
            spacing: {
              X: 1,
              Y: 1,
            },
            nb_rows: 4,
            nb_cols: 4,
          };
          this.spawnRectGrid(config__gridSmall);

          logger.log("logSelection", "fabricIntegration.fabricCanvas:", fabricIntegration.fabricCanvas);
          // fabricIntegration.fabricCanvas.selectionLineWidth = 20.0;

          


        }


        debug_freeDrawingApply() {
          this.spawnRectGrid();



        }

        debug_biPlatform() {

          //spawn a platform with something already on its terrace
          {
            const trueRect__platform = {
              x:      -1000,
              y:      100,
              width:  500,
              height: 225,
            };
            
            const mathNode1    = new math.ConstantNode(4);
            // const icMathNode1  = infiniteCanvas.createIcMathNode(trueRect__platform.x, trueRect__platform.y, mathNode1);
            const icMathNode1  = infiniteCanvas.createIcMathNode(trueRect__platform.x + 40, trueRect__platform.y + 40, mathNode1); //SHU: mathNode's size is 0 so to intersect terrace, we offset a little bit
            icMathNode1.zIndex = 1000;

            const parts__terrace = {
              "icMathNode1": icMathNode1,
            };

            const icPlatform = infiniteCanvas.createIcPlatform(trueRect__platform, parts__terrace);

            const homeScale_dst = {
              X: 5,
              Y: 5,
            };
            CompositeUtils.shiftToPositionAndScale2(icPlatform, icPlatform.position, homeScale_dst);

            //spawn platform
            infiniteCanvas.addIcObject(icPlatform);
          }


          //spawn a biPlatform with something already on its terraces
          function create_sample_biPlatform(trueRect__biPlatform)
          {
            const mathNode1    = random_constantNode();
            const icMathNode1  = infiniteCanvas.createIcMathNode(0, 0, mathNode1); //its position will be set by biPlatform
            icMathNode1.zIndex = 1000;
  
            const mathNode2    = random_constantNode();
            const icMathNode2  = infiniteCanvas.createIcMathNode(0, 0, mathNode2); //its position will be set by biPlatform
            icMathNode2.zIndex = 1000;
  
            const icBiPlatform = infiniteCanvas.createIcBiPlatform(trueRect__biPlatform, {mn1: icMathNode1}, {mn2: icMathNode2});
            // icBiPlatform.zIndex = 500;
              
            return icBiPlatform; 
          }

          const trueRect__biPlatform1 = {
            x:      100,
            y:      100,
            width:  500,
            height: 225,
          };
          const icBiPlatform1 = create_sample_biPlatform(trueRect__biPlatform1);
          // infiniteCanvas.addIcObject(icBiPlatform1);   //this breaks biPlatform3 (can't untouch, "double parent", ...)

          const trueRect__biPlatform2 = {
            x:      1000,
            y:      100,
            width:  500,
            height: 225,
          };
          const icBiPlatform2 = create_sample_biPlatform(trueRect__biPlatform2);
          // infiniteCanvas.addIcObject(icBiPlatform2);   //this breaks biPlatform3 (can't untouch, "double parent", ...)

          const trueRect__biPlatform3 = {
            x:      1000,
            y:      1000,
            width:  500,
            height: 225,
          };
          // const icBiPlatform3 = infiniteCanvas.createIcBiPlatform(trueRect__biPlatform3, {}, {});
          
          // CompositeUtils.shiftToPositionAndScale2(icBiPlatform1, icBiPlatform3.parts.platform1.position, icBiPlatform1.homeScale);
          // CompositeUtils.shiftToPositionAndScale2(icBiPlatform2, icBiPlatform3.parts.platform2.position, icBiPlatform2.homeScale);
          const icBiPlatform3 = infiniteCanvas.createIcBiPlatform(trueRect__biPlatform3, {icBiPlatform1: icBiPlatform1}, {icBiPlatform2: icBiPlatform2});
          icBiPlatform3.zIndex = -2;


          infiniteCanvas.addIcObject(icBiPlatform3);

        }

        debug_shiftPositionAndScale() {

          function randomRectRel() {
            return {
              l: math.random() * 0.4,
              t: math.random() * 0.4,
              r: 1 - (math.random() * 0.4),
              b: 1 - (math.random() * 0.4),
            };
          }

          function randomTrueRectInTrueRect(trueRect__container) {
            const rectRel = randomRectRel();
            const trueRect__random = Geometry.rectForRectRel(rectRel, trueRect__container);
            return trueRect__random;
          }

          // function create_sampleIcRectInTrueRect(trueRect__container) {

          //   const trueRect__random = randomTrueRectInTrueRect(trueRect__container);
          //   return create_sampleIcRect(trueRect__random);
          // }

          function create_sampleIcRect(trueRect) {

            const icRect = infiniteCanvas.createIcRect(trueRect);

            // icRect.zIndex = zIndex;
            icRect.fill    = ColorUtils.randomColor();
            icRect.opacity = 0.5;

            return icRect;
          }

          function create_sampleComposite(trueRect__composite, arr_icObj, isMobileParts) {
            const parts = Object.fromEntries(Object.entries(arr_icObj).map(([k,v]) => {
              return ["obj_" + k, v];
            }));
            const compositeConfig = Compositer.defaultCompositeConfig(parts, isMobileParts, false);
            
            const icComposite = infiniteCanvas.createIcComposite(trueRect__composite, parts, compositeConfig);
            icComposite.zIndex = -100;

            return icComposite;
          }

          function createArrArr__trueRect(trueRect__composite1, trueRect__composite2) {
            const arr_trueRect1 = [...Array(3).keys()].map((index) => randomTrueRectInTrueRect(trueRect__composite1));
            const arr_trueRect2 = arr_trueRect1.map((trueRect) => {
              const trueRect__offsetted = {
                x:      trueRect.x    + (trueRect__composite2.x - trueRect__composite1.x),
                y:      trueRect.y    + (trueRect__composite2.y - trueRect__composite1.y),
                width:  trueRect.width,
                height: trueRect.height,
              };
              return trueRect__offsetted;
            });

            return [arr_trueRect1, arr_trueRect2];
          }

          const trueRect__composite1 = {
            x:      100,
            y:      100,
            width:  500,
            height: 200,
          };

          const trueRect__composite2 = {
            x:      800,
            y:      100,
            width:  trueRect__composite1.width,
            height: trueRect__composite1.height,
          };

          const homeScale_dst = {
            X: 1.7,
            Y: 1.7,
          };

          const [arr_trueRect1,  arr_trueRect2]  = createArrArr__trueRect(trueRect__composite1, trueRect__composite2);
          const [arr_trueRect1A, arr_trueRect2A] = createArrArr__trueRect(arr_trueRect1[2], arr_trueRect2[2]);

          {
            const arr_icRect1 = arr_trueRect1.slice(0,-1).map((trueRect) => create_sampleIcRect(trueRect));

            const trueRect__composite1A = arr_trueRect1[arr_trueRect1.length - 1];
            const arr_icRect1A = arr_trueRect1A.map((trueRect) => create_sampleIcRect(trueRect));
            
            const icComposite1A = create_sampleComposite(trueRect__composite1A, arr_icRect1A, false);

            const icComposite1 =  create_sampleComposite(trueRect__composite1, [...arr_icRect1, icComposite1A], true);

            //update scale without using the compositeEngine
            // CompositeUtils.shiftToPositionAndScale(icComposite1, icComposite1.position, homeScale_dst);
            CompositeUtils.shiftToPositionAndScale2(icComposite1, icComposite1.position, homeScale_dst);


            infiniteCanvas.addIcObject(icComposite1);
          }
          
          {
            const arr_icRect2 = arr_trueRect2.slice(0,-1).map((trueRect) => create_sampleIcRect(trueRect));

            const trueRect__composite2A = arr_trueRect2[arr_trueRect2.length - 1];
            const arr_icRect2A = arr_trueRect2A.map((trueRect) => create_sampleIcRect(trueRect));
            
            const icComposite2A = create_sampleComposite(trueRect__composite2A, arr_icRect2A, false);

            const icComposite2 =  create_sampleComposite(trueRect__composite2, [...arr_icRect2, icComposite2A], true);


            infiniteCanvas.onceOnAddRepresentedForIcObject(icComposite2, (icComposite2) => {
  
              setTimeout(() => {
  
                const rep_free__composite2 = infiniteCanvas.getRepresented(icComposite2.id).r_free();
  
                rep_free__composite2.homeScale = homeScale_dst;  //handled by compositeEngine
  
              }, 2000);
            });

            infiniteCanvas.addIcObject(icComposite2);

          }

        }


        debug_fun() {

          const config__gridBig = {
            position: {
              x: 100,
              y: 100,
            },
            size__childRect: {
              width:  200,
              height: 200,
            },
            spacing: {
              X: 100,
              Y: 100,
            },
            nb_rows: 20,
            nb_cols: 20,
          };
          this.spawnRectGrid(config__gridBig);

        }




        debug_th() {
          infiniteCanvas.manageLoadInfinishute(infinishute_th_nostalgie);
        }


        debug_startingScreen() {

          //create text
          {
            const trueRect = {
              x: 100,
              y: 100,
              width: 100,
              height: 100,
            };

            const string__greeting = "Salut user, ça va ?";
            const icObj = infiniteCanvas.createIcText(trueRect.x, trueRect.y, string__greeting);

            // infiniteCanvas.onceOnAddRepresentedForIcObject(icObj, (icObj) => {
            //   const rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();
            //   rep_free.id = 1000;
            // });

            infiniteCanvas.addIcObject(icObj);
          }

          //create text
          {
            const trueRect = {
              x: 100,
              y: 300,
              width: 100,
              height: 100,
            };

            const string__directions = "Load \n /saves/infinishute_tutorial.json \n for tutorial \n (Press L)";
            const icObj = infiniteCanvas.createIcText(trueRect.x, trueRect.y, string__directions);

            // infiniteCanvas.onceOnAddRepresentedForIcObject(icObj, (icObj) => {
            //   const rep_free = infiniteCanvas.getRepresented(icObj.id).r_free();
            //   rep_free.id = 1001;
            // });

            infiniteCanvas.addIcObject(icObj);
          }

          //create text 2
          {
            const trueRect = {
              x: 900,
              y: 760,
              width: 100,
              height: 100,
            };

            const string__clear = "Press K to clear canvas";
            const icObj = infiniteCanvas.createIcText(trueRect.x, trueRect.y, string__clear);
            icObj.fontSize = 30;
            icObj.opacity = 0.5;

            infiniteCanvas.addIcObject(icObj);
          }

          //load logo
          {
            //image
            {
              const trueRect_img = {
                x: 900,
                y: 42,
                width: 100,
                height: 100,
              };

              // const file = new File("saves/last/infinishute_ic3.json");
              // Promise.resolve(file)
              // .then(FileIntegration.createJson_p)
              // .then(infinishute => {
              //   infiniteCanvas.manageLoadInfinishute(infinishute);
              // });

              const img__file_p = FileIntegration.imageFromImgSrc_p("img/ic_better_logo_simple_trans_2.png");
              const img_p = img__file_p;

              img_p.then(img => {
                const icObj_front = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img);
                icObj_front.scale.X = 0.5;
                icObj_front.scale.Y = 0.5;
                infiniteCanvas.addIcObject(icObj_front);
              });
            }

            //text
            {
              const trueRect_txt = {
                x: 900,
                y: 300,
                width: 100,
                height: 100,
              };

              const string__logo = "infiniteCanvas";
              const icObj = infiniteCanvas.createIcText(trueRect_txt.x, trueRect_txt.y, string__logo);
              icObj.scale.X = 0.8;
              icObj.scale.Y = 0.8;
              infiniteCanvas.addIcObject(icObj);
            }

          }

        }


      }

    </script>
    <script>
      // setTimeout(() => {    //SHU: wait for mathjax to finish loading
      //  const atelier__X_X = new Atelier__X_X(infiniteCanvas);          //atelier
      // }, 1000);
      globalsSingleton.functionCallsQueue.add(() => {
        const atelier__X_X = new Atelier__X_X(infiniteCanvas);          //atelier
      });
    </script>









    <script>

      const HexType = [
        "blank",


        "water",
        "sand",
        "soil",
        "mud",
        "grass",
        "tree__small",
        "tree__big",
      ];

      class HexCoordinates {    //hexagonal axial coordinates

        constructor(x, z) {
          this.x = x;
          this.z = z;
        }

        static fromOffsetCoordinates(x, z) {
          // return new HexCoordinates(x - z/2, z);
          return new HexCoordinates(x, z - ((x % 2 == 0) ? x / 2 : (x - 1) / 2));
        }

        getY() {
          return -this.x - this.z;
        }

        distanceTo(other) {
          const x = this.x;
          const y = this.getY();
          const z = this.z;

          const other_y = other.getY();

          const distance =
            ((x < other.x ? other.x - x : x - other.x) +
              (y < other_y ? other_y - y : y - other_y) +
              (z < other.z ? other.z - z : z - other.z)) / 2;
          return distance;
        }

        toString() {
          return "" + this.x + "," + this.z;
        }

      }

      class HexCell {

        constructor(x, y, type = "blank") {

          //squareXY-based coordinates
          this.x = x;
          this.y = y;
          // this.coords_squareXY = new HexCoordinates(x,y);

          //offset coordinates
          this.coords_offset = new HexCoordinates(2 * x + ((y % 2 == 0) ? 0 : 1), (y - ((y % 2 == 0) ? 0 : 1)) / 2);
          //axial  coordinates
          this.coords_axial = HexCoordinates.fromOffsetCoordinates(this.coords_offset.x, this.coords_offset.z);

          this.type = type;

          //flemme
          this.elevation = 0;


          //rx
          this.rx_subject = new Rx.Subject();
          this.rx_observable = this.rx_subject.asObservable();
        }

        setType2(type) {
          this.type = type;
          this.rx_subject.next(this);
        }

        clone_deep() {
          var outCell;

          outCell = new HexCell(this.x, this.y, this.type);

          return outCell;
        }

        static fromAxialCoords(x, z, type = "blank") {
          const x_sq = (x % 2 == 0) ? x / 2 : (x - 1) / 2;
          const y_sq = 2 * z + x;
          return new HexCell(x_sq, y_sq, type);
        }

      }

      class ProtoCell {

        constructor(cell) {
          this.cell = cell;

          this.elevation = 0;
        }

        x() {
          return this.cell.x;
        }

        y() {
          return this.cell.y;
        }

        getPreparedCell() {
          var outCell;

          outCell = this.cell.clone_deep();
          outCell.type = HexMapGenerator.typeForElevation(this.elevation);

          return outCell;
        }

      }

      class PathElement {

        constructor(elt, from) {
          this.elt = elt;
          this.from = from;
        }

      }

      class SearchElement {

        constructor(pathElt, distance_traveled, heuristic_remaining) {
          this.pathElt = pathElt;

          this.distance_traveled = distance_traveled;    //exactly       traveled
          this.heuristic_remaining = heuristic_remaining;  //estimation of remaining
        }

        getPriority() {
          return this.distance_traveled + this.heuristic_remaining;
        }

      }

      class HexMap {

        constructor(type_map) {
          this.type_map = type_map;

          //init
          this.dict_landTypeShare = HexMap.dictLandTypeShareForMapType(this.type_map);
          // logger.log("this.dict_landTypeShare", this.dict_landTypeShare);
          this.average_elevation = HexMap.computeAverageElevation(this.dict_landTypeShare);
        }

        static dictLandTypeShareForMapType(type_map) {
          var outDict;

          switch (type_map) {
            case "forest":
              outDict = {
                "water": 10,
                "sand": 0,
                "soil": 5,
                "mud": 10,
                "grass": 5,
                "tree__small": 30,
                "tree__big": 40,
              };
              break;

            case "river":
              outDict = {
                "water": 60,
                "sand": 10,
                "soil": 0,
                "mud": 10,
                "grass": 0,
                "tree__small": 0,
                "tree__big": 20,
              };
              break;
            case "clear":
            case "village":
            case "fruitland":
            default:
              outDict = {
                "water": 20,
                "sand": 10,
                "soil": 10,
                "mud": 10,
                "grass": 10,
                "tree__small": 20,
                "tree__big": 20,
              };
              break;
          }

          return outDict;
        }

        static elevationForTypeLand(type_land) {
          const arr_type__practical = HexType.slice(0);
          return arr_type__practical.indexOf(type_land);
        }

        static computeAverageElevation(dictLandTypeShare) {
          return Object.entries(dictLandTypeShare).reduce((acc, [type_land, share_land]) => {
            const elevation_type_land = HexMap.elevationForTypeLand(type_land);
            return acc + elevation_type_land * (share_land / 100.0);
          }, 0);
        }

      }

      class HexMapGenerator {

        constructor(grid) {
          this.grid = grid;
        }

        generateMap() {

          //--fill with stuff--
          this.createLand();
        }

        // raiseTerrain(chunkSize) {
        //
        //   // for (var i = 0; i < chunkSize; i++) {
        //   //   this.grid.getRandomCell().type = "grass";
        //   //   // this.grid.getRandomCell().typeIndex = 1;
        //   // }
        //
        //   // {
        //   //   //get cells with same z
        //   //   this.grid.cells.filter(hexCell_i => {
        //   //     // return hexCell_i.coords_offset.z == 10;
        //   //     return hexCell_i.coords_axial.z == 10;
        //   //   }).forEach((hexCell_near, i) => {
        //   //     hexCell_near.type = "sand";
        //   //   });
        //   // }
        //   //
        //   // {
        //   //   //get cells with same x
        //   //   this.grid.cells.filter(hexCell_i => {
        //   //     // return hexCell_i.coords_offset.x == 3;
        //   //     return hexCell_i.coords_axial.x == 3;
        //   //   }).forEach((hexCell_near, i) => {
        //   //     hexCell_near.type = "mud";
        //   //   });
        //   // }
        //
        //   // {
        //   //   //drop of land
        //   //   const hexCell_r = this.grid.getRandomCell();
        //   //   hexCell_r.type = "water";
        //   //
        //   //   this.grid.cells.filter(hexCell_i => {
        //   //     const distance = hexCell_i.coords_axial.distanceTo(hexCell_r.coords_axial);
        //   //     logger.log("distance", distance);
        //   //     return distance == 1;
        //   //   }).forEach((hexCell_near, i) => {
        //   //     hexCell_near.type = "tree__big";
        //   //   });
        //   //
        //   //   this.grid.getCellsAtAxialDistance(hexCell_r, 4)
        //   //   .forEach((hexCell) => {
        //   //     hexCell.type = "grass";
        //   //   });
        //   //
        //   // }
        //
        //   // {
        //   //   //drop of land
        //   //   const hexCell_r = this.grid.getRandomCell();
        //   //   hexCell_r.type = "sand";
        //   //
        //   //   const hexCell_NE = this.grid.getNeighborAtDirection(hexCell_r, "NE");
        //   //   if(hexCell_NE != null) {
        //   //     hexCell_NE.type = "grass";
        //   //   }
        //   //
        //   // }
        //
        //   /*
        //   function typeForDirection(direction) {
        //     var outType;
        //
        //     switch(direction) {
        //       case "N":
        //         outType = "sand";
        //         break;
        //       case "NE":
        //         outType = "soil";
        //         break;
        //       case "SE":
        //         outType = "mud";
        //         break;
        //       case "S":
        //         outType = "grass";
        //         break;
        //       case "SO":
        //         outType = "tree__small";
        //         break;
        //       case "NO":
        //         outType = "tree__big";
        //         break;
        //       default:
        //         throw new Error("unsupported direction: " + direction);
        //         break;
        //     }
        //
        //     return outType;
        //   }
        //
        //   function typeForNeighborIndex(nIndex) {
        //     const dict_type = {
        //       0: "sand",
        //       1: "soil",
        //       2: "mud",
        //       3: "grass",
        //       4: "tree__small",
        //       5: "tree__big",
        //     };
        //     return dict_type[nIndex];
        //   }
        //
        //   {
        //     //drop of land
        //     const hexCell_r = this.grid.getCellAtPos(5,5);
        //     hexCell_r.type = "water";
        //
        //     ["N", "NE", "SE", "S", "SO", "NO"].map(direction => {
        //       const hexCell_neighbor = this.grid.getNeighborAtDirection(hexCell_r, direction);
        //       return [direction, hexCell_neighbor];
        //     })
        //     .forEach(([direction, hexCell]) => {
        //       const type = typeForDirection(direction);
        //       hexCell.type = type;
        //     });
        //
        //   }
        //
        //   {
        //     //drop of land
        //     const hexCell_r = this.grid.getRandomCell();
        //     hexCell_r.type = "water";
        //
        //     Object.entries(this.grid.getDictNeighbor(hexCell_r))
        //     .forEach(([nIndex, hexCell]) => {
        //       const type = typeForNeighborIndex(nIndex);
        //       hexCell.type = type;
        //     });
        //   }
        //   */
        //
        //
        //   /*
        //   {
        //     //find path between cells
        //     const hexCell_from = this.grid.getRandomCell();
        //     logger.log("hexCell_from", [hexCell_from.x, hexCell_from.y]);
        //     hexCell_from.type  = "water";
        //     const hexCell_to   = this.grid.getRandomCell();
        //     logger.log("hexCell_to", [hexCell_to.x, hexCell_to.y]);
        //     hexCell_to.type    = "sand";
        //
        //     // const arr_path = this.grid.findShortestPath(hexCell_from, hexCell_to);
        //     // const arr_path = this.grid.findShortestPath__withHeuristic(hexCell_from, hexCell_to);
        //     const arr_path = this.grid.findShortestPath__withHeuristic__withPQ(hexCell_from, hexCell_to);
        //     logger.log("arr_path", arr_path);
        //     arr_path.slice(1,-1).forEach((hexCell, i) => {
        //       logger.log("hexCell", [hexCell.x, hexCell.y]);
        //       hexCell.type = "mud";
        //     });
        //   }
        //   */
        //
        //   /*
        //   [...Array(5).keys()].forEach((i) => {
        //     const hexCell_r = this.grid.getRandomCell();
        //     hexCell_r.type  = "grass";
        //     // const arr_chunk = this.grid.findAChunk__withHeuristic__withPQ(hexCell_r, 10);
        //     const arr_chunk = this.grid.findAChunk__withHeuristic__withPQ(hexCell_r, 30);
        //
        //     arr_chunk.forEach((hexCell, i) => {
        //       // logger.log("hexCell", [hexCell.x, hexCell.y]);
        //       hexCell.type = "mud";
        //     });
        //   });
        //   */
        //
        // }

        static typeForElevation(elevation_in) {
          var outType;

          const arr_type__practical = HexType.slice(0);
          const nb_type__practical = arr_type__practical.length;

          const elevation = math.min(elevation_in, nb_type__practical - 1);

          outType = arr_type__practical[elevation];

          return outType;
        }

        createLand() {

          const nb_cells = this.grid.cells.length;
          const type_map = "forest";
          // const type_map = "river";
          // const type_map = "clear";

          const hexMap = new HexMap(type_map);
          const dict_landTypeShare = hexMap.dict_landTypeShare;
          const average_elevation = hexMap.average_elevation;

          const share_drop = 10;
          const percentage_drop = share_drop / 100.0;
          const size_drop = math.floor(percentage_drop * nb_cells);

          const nb_drop = math.floor(average_elevation / percentage_drop);
          this.elevateUsingDrops(nb_drop, size_drop);

          this.diffuseToMatchShares(dict_landTypeShare);

          this.cleanOutArtefacts();
        }

        elevateUsingDrops(nb_drop, size_drop) {

          //drops
          [...Array(nb_drop).keys()].forEach((i) => {
            const hexCell_r = HexGridUtils.getRandomCell(this.grid);
            const arr_chunk = HexGridUtils.findAChunk__withHeuristic__withPQ(this.grid, hexCell_r, size_drop);
            arr_chunk.forEach((hexCell, i) => {
              hexCell.elevation += 1;
            });
          });

          //assign types
          this.grid.cells.forEach((cell, i) => {
            cell.type = HexMapGenerator.typeForElevation(cell.elevation);
          });

        }

        diffuseToMatchShares(dict_landTypeShare) {

          const nb_cells = this.grid.cells.length;
          logger.log("nb_cells", nb_cells);

          //sort shares
          const arr_entry_share__sorted = Object.entries(dict_landTypeShare).toSorted(([k1, v1], [k2, v2]) => {
            return v1 < v2;
          });

          arr_entry_share__sorted.slice(0, -1).forEach(([type, share], i) => {

            //determine nb of cells to paint
            const nb_cells_of_type__target = math.floor(share / 100.0 * nb_cells);
            logger.log("nb_cells_of_type__target", type, nb_cells_of_type__target);
            // if(nb_cells_of_type__target > 0) {

            var nb_cells_of_type__current = this.grid.cells.filter(cell => cell.type == type).length;
            // logger.log("nb_cells_of_type__current", nb_cells_of_type__current);

            if (nb_cells_of_type__current < nb_cells_of_type__target) {

              while (nb_cells_of_type__current < nb_cells_of_type__target) {
                //inject a cell of type
                logger.log("inject a cell of type", type);

                var cell_injection;

                //get a cell in which to inject type
                // const cell_of_type = this.grid.cells.find(cell => cell.type == type);
                const cell_of_type = Utils.randomElementInArray([...this.grid.cells.filter(cell => cell.type == type)]);
                if (cell_of_type != null) {
                  const arr_outerShell = HexGridUtils.findOuterShell_of_area_with_type(this.grid, cell_of_type);
                  // logger.log("arr_outerShell", arr_outerShell);

                  //filter out types that already have correct number of cells
                  const arr_type__too_many = arr_entry_share__sorted.filter(([type, share]) => {
                    const nb_current = this.grid.cells.filter(cell => cell.type == type).length;
                    const nb_target = math.floor(share / 100.0 * nb_cells);
                    return nb_current > nb_target;
                  }).map(([type, share]) => type);

                  const arr_outerShell__filtered = arr_outerShell.filter(cell_outerShell => {
                    return arr_type__too_many.includes(cell_outerShell.type);
                  });

                  if (arr_outerShell__filtered.length > 0) {
                    cell_injection = Utils.randomElementInArray(arr_outerShell__filtered);
                  } else {
                    cell_injection = HexGridUtils.getRandomCell(this.grid);
                    while (!arr_type__too_many.includes(cell_injection.type)) {
                      cell_injection = HexGridUtils.getRandomCell(this.grid);
                    }
                  }

                } else {
                  cell_injection = HexGridUtils.getRandomCell(this.grid);
                  while (!arr_type__too_many.includes(cell_injection.type)) {
                    cell_injection = HexGridUtils.getRandomCell(this.grid);
                  }
                }

                //change type
                cell_injection.type = type;

                nb_cells_of_type__current = this.grid.cells.filter(cell => cell.type == type).length;
                logger.log("nb_cells_of_type__current", nb_cells_of_type__current);
              }

            } else {

              while (nb_cells_of_type__current > nb_cells_of_type__target) {
                //remove a cell of type
                logger.log("remove a cell of type", type);

                //get a cell in which to change type
                // const cell_of_type = this.grid.cells.find(cell => cell.type == type);
                const cell_of_type = Utils.randomElementInArray([...this.grid.cells.filter(cell => cell.type == type)]);

                //change type
                const entry__next = arr_entry_share__sorted[i + 1];
                const type__next = entry__next[0];
                cell_of_type.type = type__next;

                nb_cells_of_type__current = this.grid.cells.filter(cell => cell.type == type).length;
                logger.log("nb_cells_of_type__current", nb_cells_of_type__current);
              }

            }

            // }

          });

          //color blank cells with major type
          const entry__last = arr_entry_share__sorted[arr_entry_share__sorted.length - 1];
          const type__last = entry__last[0];
          this.grid.cells.filter(cell => cell.type == "blank").forEach((cell_blank, i) => {
            cell_blank.type = type__last;
          });



          //debug
          const dict_nb_cell_for_type = Object.fromEntries(arr_entry_share__sorted.map(([type, share]) => {
            const nb_cells_for_type = this.grid.cells.filter(cell => cell.type == type).length;
            const nb_cells_of_type__target = math.floor(share / 100.0 * nb_cells);
            return [type, {
              target: nb_cells_of_type__target,
              actual: nb_cells_for_type,
            }];
          }));
          logger.log("dict_nb_cell_for_type", dict_nb_cell_for_type);

        }

        cleanOutArtefacts() {

        }

      }

      class HexGrid_Rect {

        constructor(w, h) {
          this.w = w;
          this.h = h;
          this.cells = [];

          this.initialize();
        }

        initialize() {
          const nb_cells = this.w * this.h;
          this.cells = [...Array(nb_cells).keys()].map(i => {
            const y = math.floor(i / this.w);
            const x = i - y * this.w;
            const hexCell = new HexCell(x, y, "blank");
            return hexCell;
          })
        }

        getCellAtIndex(i) {
          var outCell = null;
          if (0 <= i && i < this.cells.length) {
            outCell = this.cells[i];
          }
          return outCell;
        }

        getCellAtPos(x, y) {
          var outCell = null;

          const is_invalid_x = (x < 0 || x >= this.w);
          const is_invalid_y = (y < 0 || y >= this.h);
          const is_invalid_xy = is_invalid_x || is_invalid_y;
          if (!is_invalid_xy) {
            outCell = this.getCellAtIndex(x + y * this.w);
          }

          return outCell;
        }

      }

      class HexGrid_Hex {

        constructor(l) {
          this.l = l;
          this.cells = [];

          this.initialize();
        }

        initialize() {

          if (this.l == 0) {
            this.cells = [];
            return;
          }

          if (this.l == 1) {
            const cell__center = new HexCell(0, 0);
            this.cells = [cell__center];
            return;
          }

          function arrCoordsAxialNeighbors(x, z) {
            return [
              new HexCoordinates(x, z - 1),
              new HexCoordinates(x + 1, z - 1),
              new HexCoordinates(x + 1, z),
              new HexCoordinates(x, z + 1),
              new HexCoordinates(x - 1, z + 1),
              new HexCoordinates(x - 1, z),
            ];
          }

          const cell__center = new HexCell(0, 0);
          const dict_cells = [...Array(this.l - 1).keys()].reduce((acc, i) => {

            const dict_current = acc.dict;
            const arr_frontier = acc.frontier;
            logger.log("arr_frontier.length", arr_frontier.length);

            //create outerShell cells
            return arr_frontier.reduce((acc2, cell_frontier) => {
              const x = cell_frontier.coords_axial.x;
              const z = cell_frontier.coords_axial.z;
              const arr_coords_neighbor = arrCoordsAxialNeighbors(x, z);
              const arr_coords_neighbor_fresh = arr_coords_neighbor.filter(coords => {
                const string_coords = coords.toString();
                // logger.log("string_coords", string_coords);
                const isAlreadyInDict = (dict_current[string_coords] != null);
                // logger.log("isAlreadyInDict", isAlreadyInDict);
                return !isAlreadyInDict;
              });
              // logger.log("___");

              const arr_cell_neighbor_fresh = arr_coords_neighbor_fresh.map((coords_axial, i) => {
                return HexCell.fromAxialCoords(coords_axial.x, coords_axial.z);
              });

              const dict_fresh = Object.fromEntries(arr_cell_neighbor_fresh.map(cell => {
                const string_coords = cell.coords_axial.toString();
                return [string_coords, cell];
              }));

              const arr_frontier_out = acc2.frontier.concat(arr_cell_neighbor_fresh);
              const dict_out = Object.assign(acc2.dict, dict_fresh);

              return {
                dict: dict_out,
                frontier: arr_frontier_out,
              };

            }, {
              dict: acc.dict,
              frontier: [],
            });

          }, {
            dict: {
              [cell__center.coords_axial.toString()]: cell__center,
            },
            frontier: [cell__center],
          }).dict;

          this.cells = Object.values(dict_cells);
        }

        getCellAtIndex(i) {
          var outCell = null;
          if (0 <= i && i < this.cells.length) {
            outCell = this.cells[i];
          }
          return outCell;
        }

        getCellAtPos(x, y) {
          var outCell = null;

          outCell = this.cells.find(cell => (cell.x == x && cell.y == y));  //moche mais fu

          return outCell;
        }

      }

      class HexGrid_fromHexGridSeed {

        constructor(grid_seed, n) {
          this.grid_seed = grid_seed;
          this.n = n;

          this.cells = [];

          this.initialize();
        }

        initialize() {
          const nb_cells = this.w * this.h;
          this.cells = [...Array(nb_cells).keys()].map(i => {
            const y = math.floor(i / this.w);
            const x = i - y * this.w;
            const hexCell = new HexCell(x, y, "blank");
            return hexCell;
          });
        }

        getCellAtIndex(i) {
          var outCell = null;
          if (0 <= i && i < this.cells.length) {
            outCell = this.cells[i];
          }
          return outCell;
        }

        getCellAtPos(x, y) {
          var outCell = null;

          const is_invalid_x = (x < 0 || x >= this.w);
          const is_invalid_y = (y < 0 || y >= this.h);
          const is_invalid_xy = is_invalid_x || is_invalid_y;
          if (!is_invalid_xy) {
            outCell = this.getCellAtIndex(x + y * this.w);
          }

          return outCell;
        }

      }

      class HexGridUtils {

        static getRandomCell(grid) {
          return Utils.randomElementInArray(grid.cells);
        }


        //cell neighbors

        static getNeighborAtDirection(grid, hexCell, direction) {

          const is_y_even = (hexCell.y % 2 == 0);
          const dx_y_evenodd = is_y_even ? -1 : 0;

          const dict_xy = {
            N: { x: 0, y: -2 },
            NE: { x: 1 + dx_y_evenodd, y: -1 },
            SE: { x: 1 + dx_y_evenodd, y: 1 },
            S: { x: 0, y: 2 },
            SO: { x: 0 + dx_y_evenodd, y: 1 },
            NO: { x: 0 + dx_y_evenodd, y: -1 },
          };

          const dxdy = dict_xy[direction];
          const x = hexCell.x + dxdy.x;
          const y = hexCell.y + dxdy.y;

          return grid.getCellAtPos(x, y);
        }

        static getNeighborAtIndex(grid, hexCell, index) {

          const is_y_even = (hexCell.y % 2 == 0);
          const dx_y_evenodd = is_y_even ? -1 : 0;

          const dict_xy = {
            0: { x: 0, y: -2 },
            1: { x: 1 + dx_y_evenodd, y: -1 },
            2: { x: 1 + dx_y_evenodd, y: 1 },
            3: { x: 0, y: 2 },
            4: { x: 0 + dx_y_evenodd, y: 1 },
            5: { x: 0 + dx_y_evenodd, y: -1 },
          };

          const dxdy = dict_xy[index];
          const x = hexCell.x + dxdy.x;
          const y = hexCell.y + dxdy.y;

          return grid.getCellAtPos(x, y);
        }

        static getDictNeighbor(grid, hexCell) {
          const arr_entry = [...Array(6).keys()].map(index => {
            const hexCell_neighbor = this.getNeighborAtIndex(grid, hexCell, index);
            return [index, hexCell_neighbor];
          }).filter(([index, hexCell]) => {
            return hexCell != null;
          });
          const dict_neighbor = Object.fromEntries(arr_entry);
          return dict_neighbor;
        }

        static getNeighborAtIndex__alternative_order(grid, hexCell, index) {

          const is_y_even = (hexCell.y % 2 == 0);
          const dx_y_evenodd = is_y_even ? -1 : 0;

          const dict_xy = {
            0: { x: 1 + dx_y_evenodd, y: 1 },
            1: { x: 1 + dx_y_evenodd, y: -1 },
            2: { x: 0, y: 2 },
            3: { x: 0, y: -2 },
            4: { x: 0 + dx_y_evenodd, y: 1 },
            5: { x: 0 + dx_y_evenodd, y: -1 },
          };

          const dxdy = dict_xy[index];
          const x = hexCell.x + dxdy.x;
          const y = hexCell.y + dxdy.y;

          return grid.getCellAtPos(x, y);
        }

        static getDictNeighbor__alternative_order(grid, hexCell) {
          const arr_entry = [...Array(6).keys()].map(index => {
            const hexCell_neighbor = this.getNeighborAtIndex__alternative_order(grid, hexCell, index);
            return [index, hexCell_neighbor];
          }).filter(([index, hexCell]) => {
            return hexCell != null;
          });
          const dict_neighbor = Object.fromEntries(arr_entry);
          return dict_neighbor;
        }


        //distances

        static getDistance__axial(hexCell_from, hexCell_to) {
          return hexCell_from.coords_axial.distanceTo(hexCell_to.coords_axial);
        }

        static getCellsAtAxialDistance(grid, hexCell_c, distance_axial) {

          const dict_cellsAtDistance = grid.cells.map((hexCell_i, i) => {
            const distance = this.getDistance__axial(hexCell_i, hexCell_c);
            const miniDict = {
              i: i,
              hexCell: hexCell_i,
              distance: distance,
            };
            return miniDict;
          }).reduce((acc, x) => {
            if (acc[x.distance] == null) {
              acc[x.distance] = [];
            }
            acc[x.distance].push(x.hexCell);
            return acc;
          }, {});
          // logger.log("dict_cellsAtDistance", dict_cellsAtDistance);

          const arr_cell = dict_cellsAtDistance[distance_axial];
          return arr_cell;
        }


        static getArrDistanceTo__axial(grid, hexCell) {
          const arr_distance = grid.cells.map(hexCell_i => {
            return this.getDistance__axial(hexCell, hexCell_i);
          });
          return arr_distance;
        }

        static getArrDistanceTo__pathfinding(grid, hexCell) {
          const arr_distance = grid.cells.map(hexCell_i => {
            return hexCell.findShortestPathTo(hexCell_i).length;
          });
          return arr_distance;
        }

        static findShortestPathDistance(grid, cell_from, cell_to) {
          return (this.findShortestPath(grid, cell_from, cell_to).length - 1);
        }

        static findShortestPath(grid, cell_from, cell_to) {
          var outArr;

          const is_same_x = (cell_from.x == cell_to.x);
          const is_same_y = (cell_from.y == cell_to.y);
          const is_same_xy = is_same_x && is_same_y;
          if (is_same_xy) {
            return [];
          }

          const queue_frontier = new Queue();

          const pathElt_from = new PathElement(cell_from, null);
          queue_frontier.enqueue(pathElt_from);

          var isReached = false;
          while (!isReached) {
            const pathElt_current = queue_frontier.dequeue();
            const cell_current = pathElt_current.elt;
            const arr_cell_neighbor = Object.values(this.getDictNeighbor(grid, cell_current));

            isReached = arr_cell_neighbor.includes(cell_to);
            if (isReached) {
              //we have found a path
              const pathElt_to = new PathElement(cell_to, pathElt_current);

              //let's rebuild the path
              outArr = this.rebuildPath(pathElt_to);

            } else {
              //continue searching
              const arr_pathElt = arr_cell_neighbor.map(cell => {
                return new PathElement(cell, pathElt_current);
              });

              // queue_frontier.enqueue(...arr_pathElt);    //not working
              arr_pathElt.forEach((pathElt, i) => {
                const arr_cell_frontier = queue_frontier.getArr().map(pathElt => pathElt.elt);
                const is_already_in_queue = arr_cell_frontier.includes(pathElt.elt);
                if (!is_already_in_queue) {
                  queue_frontier.enqueue(pathElt);
                }
              });

              // logger.log("queue_frontier.getLength()", queue_frontier.getLength());
            }
          }

          return outArr;
        }

        static rebuildPath(pathElt_to) {
          var outArr;

          const arrPath_backwards = [];
          arrPath_backwards.push(pathElt_to.elt);

          var pathElt_w = pathElt_to;
          while (pathElt_w.from != null) {
            const pathElt_from = pathElt_w.from;
            arrPath_backwards.push(pathElt_from.elt);

            pathElt_w = pathElt_from;
          }

          outArr = [...arrPath_backwards].reverse();

          return outArr;
        }



        static findShortestPath__withHeuristic(grid, cell_from, cell_to) {
          var outArr;

          const is_same_x = (cell_from.x == cell_to.x);
          const is_same_y = (cell_from.y == cell_to.y);
          const is_same_xy = is_same_x && is_same_y;
          if (is_same_xy) {
            return [];
          }

          // const queue_frontier = new Queue();
          var queue_frontier = [];

          const pathElt_from = new PathElement(cell_from, null);
          const searchElt_from = new SearchElement(pathElt_from, 0, -1);
          queue_frontier.push(searchElt_from);

          var isReached = false;
          var distance_traveled = 0;
          while (!isReached) {
            const dequeued = queue_frontier[0];
            queue_frontier = queue_frontier.slice(1);

            const searchElt_current = dequeued;

            const pathElt_current = searchElt_current.pathElt;
            const cell_current = pathElt_current.elt;
            const arr_cell_neighbor = Object.values(this.getDictNeighbor(grid, cell_current));

            isReached = arr_cell_neighbor.includes(cell_to);
            if (isReached) {
              //we have found a path
              const pathElt_to = new PathElement(cell_to, pathElt_current);

              //let's rebuild the path
              outArr = this.rebuildPath(pathElt_to);

            } else {
              //continue searching
              distance_traveled += 1;

              const arr_searchElt = arr_cell_neighbor.map(cell => {
                const heuristic_remaining = this.getDistance__axial(cell, cell_to);
                const pathElt = new PathElement(cell, pathElt_current);
                const searchElt = new SearchElement(pathElt, distance_traveled, heuristic_remaining);
                return searchElt;
              });

              arr_searchElt.forEach((searchElt, i) => {
                const arr_cell_frontier = queue_frontier.map(searchElt => searchElt.pathElt.elt);
                const is_already_in_queue = arr_cell_frontier.includes(searchElt.pathElt.elt);
                if (!is_already_in_queue) {
                  queue_frontier.push(searchElt);
                }
              });

              //sort frontier using priority
              queue_frontier.sort((searchElt1, searchElt2) => {
                return searchElt1.getPriority() < searchElt2.getPriority();
              });

            }
          }

          return outArr;
        }

        static findShortestPath__withHeuristic__withPQ(cell_from, cell_to) {
          var outArr;

          const is_same_x = (cell_from.x == cell_to.x);
          const is_same_y = (cell_from.y == cell_to.y);
          const is_same_xy = is_same_x && is_same_y;
          if (is_same_xy) {
            return [];
          }

          // const queue_frontier = new Queue();
          var pqueue_frontier = new PriorityQueue();

          const pathElt_from = new PathElement(cell_from, null);
          const searchElt_from = new SearchElement(pathElt_from, 0, -1);
          const pqe_from = new PriorityQueueElement(searchElt_from, searchElt_from.getPriority());
          pqueue_frontier.enqueue(pqe_from);

          var isReached = false;
          var distance_traveled = 0;
          while (!isReached) {
            const pqe_dequeued = pqueue_frontier.dequeue();
            const searchElt_current = pqe_dequeued.payload;
            const pathElt_current = searchElt_current.pathElt;
            const cell_current = pathElt_current.elt;
            // const arr_cell_neighbor = Object.values(this.getDictNeighbor(grid, cell_current));
            // const arr_cell_neighbor = Utils.shuffle(Object.values(this.getDictNeighbor(grid, cell_current)));
            const arr_cell_neighbor = Object.values(this.getDictNeighbor__alternative_order(grid, cell_current));

            isReached = arr_cell_neighbor.includes(cell_to);
            if (isReached) {
              //we have found a path
              const pathElt_to = new PathElement(cell_to, pathElt_current);

              //let's rebuild the path
              outArr = this.rebuildPath(pathElt_to);

            } else {
              //continue searching
              distance_traveled += 1;

              const arr_pqe_neighbor = arr_cell_neighbor.map(cell => {
                const heuristic_remaining = this.getDistance__axial(cell, cell_to);
                const pathElt = new PathElement(cell, pathElt_current);
                const searchElt = new SearchElement(pathElt, distance_traveled, heuristic_remaining);
                const pqe = new PriorityQueueElement(searchElt, searchElt.getPriority());
                return pqe;
              });

              arr_pqe_neighbor.forEach((pqe_neighbor, i) => {
                const cell_neighbor = pqe_neighbor.payload.pathElt.elt;

                const arr_pqe_frontier = pqueue_frontier.arr_priority
                  .filter(priority => priority != null)
                  .reduce((acc, priority_i) => {
                    const arr_priority_i = pqueue_frontier.dict_pqe[priority_i];
                    return acc.concat(arr_priority_i);
                  }, []);
                // logger.log("pqueue_frontier.arr_priority", pqueue_frontier.arr_priority);
                // logger.log("arr_pqe_frontier", arr_pqe_frontier);
                const arr_cell_frontier = arr_pqe_frontier.map(pqe => pqe.payload.pathElt.elt);
                // logger.log("arr_cell_frontier", arr_cell_frontier);

                const is_already_in_queue = arr_cell_frontier.includes(cell_neighbor);

                if (!is_already_in_queue) {
                  //add to frontier
                  pqueue_frontier.enqueue(pqe_neighbor);
                }
                /*
                else {
                  logger.log("is_already_in_queue");

                  //get corresponding existing pqe
                  const pqe_existing = arr_pqe_frontier.find(pqe_frontier => {   //on refait un petit tour pour le plaisir
                    const cell_frontier = pqe_frontier.payload.pathElt.elt;
                    return (cell_frontier == cell_neighbor);
                  });
                  logger.log("pqe_existing.priority", pqe_existing.priority);
                  logger.log("pqe_neighbor.priority", pqe_neighbor.priority);

                  //update priority if better
                  if(pqe_existing.priority > pqe_neighbor.priority) {
                    logger.log("found better");

                    pqueue_frontier.remove(pqe_existing);
                    pqueue_frontier.enqueue(pqe_neighbor);
                  }

                }
                */

              });

            }
          }

          return outArr;
        }


        static findShortestPath__withHeuristic__andObstacles(cell_from, cell_to) {
          var outArr;


          return outArr;
        }



        static findAChunk__withHeuristic__withPQ(grid, cell_from, nb_cells) {
          var outArr;

          const dict_chunk = {};

          // const queue_frontier = new Queue();
          var pqueue_frontier = new PriorityQueue();

          const pathElt_from = new PathElement(cell_from, null);
          const searchElt_from = new SearchElement(pathElt_from, 0, -1);
          const pqe_from = new PriorityQueueElement(searchElt_from, searchElt_from.getPriority());
          pqueue_frontier.enqueue(pqe_from);

          var isEnough = false;
          var distance_traveled = 0;
          while (!isEnough) {

            const arr_chunk = Object.values(dict_chunk);
            isEnough = (arr_chunk.length >= nb_cells);
            if (isEnough) {

              //let's crop the correct number of cells
              outArr = arr_chunk.slice(0, nb_cells);

            } else {
              //continue searching
              distance_traveled += 1;

              const pqe_dequeued = pqueue_frontier.dequeue();
              // logger.log("pqe_dequeued.priority", pqe_dequeued.priority);
              const searchElt_current = pqe_dequeued.payload;
              const pathElt_current = searchElt_current.pathElt;
              const cell_current = pathElt_current.elt;
              const arr_cell_neighbor = Utils.shuffle(Object.values(this.getDictNeighbor(grid, cell_current)));

              arr_cell_neighbor.forEach((cell_neighbor, i) => {

                // const heuristic_remaining = 0;
                const heuristic_remaining = math.randomInt(0, 50);

                const pathElt_neighbor = new PathElement(cell_neighbor, pathElt_current);
                const searchElt_neighbor = new SearchElement(pathElt_neighbor, distance_traveled, heuristic_remaining);
                const pqe_neighbor = new PriorityQueueElement(searchElt_neighbor, searchElt_neighbor.getPriority());

                const string_xy = cell_neighbor.x + "," + cell_neighbor.y;
                const is_already_in_queue = dict_chunk[string_xy] != null;

                if (!is_already_in_queue) {
                  dict_chunk[string_xy] = cell_neighbor;
                  //add to frontier
                  pqueue_frontier.enqueue(pqe_neighbor);
                }

              });

            }
          }

          return outArr;
        }

        static findABChunk__withHeuristic__withPQ(cell_from, cell_to, nb_cells) {
          var outArr;

          return outArr;
        }

        static isContiguous(grid, arr_cell) {

        }

        static sortedClockwise(arr_cell) {

        }

        static findShellCell(grid, arr_cell) {
          var outCell;

          var isFound = false;
          var index = 0;
          while (!isFound) {

            isFound = null;
            if (isFound) {
              outCell = null;
            }

          }

          return outCell;
        }

        static findShellsDict(grid, arr_shell) {

        }

        static findAllInShell(grid, arr_shell) {
          const isContiguous = this.isContiguous(arr_shell);

          if (!isContiguous) {
            throw new Error("arr_shell is not contiguous");
          }

          const dict_shells = this.findShellsDict(grid, arr_shell);

        }

        static findInnerShell(grid, arr_cell_seed) {
          return arr_cell_seed.filter(cell => {
            const isInnerShellCell = (Object.values(this.getDictNeighbor(grid, cell)).length < 6);
            return isInnerShellCell;
          });
        }

        static findOuterShell(grid, arr_cell_seed) {

          const arr_innerShell = this.findInnerShell(grid, arr_cell_seed);



          // arr_cell_neighbor.forEach((cell_neighbor, i) => {
          //
          //   // const heuristic_remaining = 0;
          //   const heuristic_remaining = math.randomInt(0, 50);
          //
          //   const pathElt_neighbor      = new PathElement(cell_neighbor, pathElt_current);
          //   const searchElt_neighbor    = new SearchElement(pathElt_neighbor, distance_traveled, heuristic_remaining);
          //   const pqe_neighbor          = new PriorityQueueElement(searchElt_neighbor, searchElt_neighbor.getPriority());
          //
          //   const string_xy           = cell_neighbor.x + "," + cell_neighbor.y;
          //   const is_already_in_queue = dict_chunk[string_xy] != null;
          //
          //   if(!is_already_in_queue) {
          //     dict_chunk[string_xy] = cell_neighbor;
          //     //add to frontier
          //     pqueue_frontier.enqueue(pqe_neighbor);
          //   }

        }



        static findShellChunk(grid, arr_cell_seed, nb_shell_layers) {
          return [...Array(nb_shell_layers).keys()].reduce((acc, i) => {
            const arr_outerShell = this.findOuterShell(grid, acc);
            return acc.concat(arr_outerShell);
          }, [...arr_cell_seed]);
        }

        static findArea_with_element_of_type(grid, cell_from) {
          var outArr;

          const type__target = cell_from.type;

          const dict_chunk = {};

          const string_xy = cell_from.x + "," + cell_from.y;
          dict_chunk[string_xy] = cell_from;

          // const queue_frontier = new Queue();
          var pqueue_frontier = new PriorityQueue();

          const pathElt_from = new PathElement(cell_from, null);
          const searchElt_from = new SearchElement(pathElt_from, 0, -1);
          const pqe_from = new PriorityQueueElement(searchElt_from, searchElt_from.getPriority());
          pqueue_frontier.enqueue(pqe_from);

          var isFull = false;
          var distance_traveled = 0;
          while (!isFull) {

            //continue searching
            distance_traveled += 1;

            const pqe_dequeued = pqueue_frontier.dequeue();
            // logger.log("pqe_dequeued.priority", pqe_dequeued.priority);
            const searchElt_current = pqe_dequeued.payload;
            const pathElt_current = searchElt_current.pathElt;
            const cell_current = pathElt_current.elt;
            const arr_cell_neighbor = Utils.shuffle(Object.values(this.getDictNeighbor(grid, cell_current)));

            arr_cell_neighbor.forEach((cell_neighbor, i) => {

              // const heuristic_remaining = 0;
              const heuristic_remaining = math.randomInt(0, 50);

              const pathElt_neighbor = new PathElement(cell_neighbor, pathElt_current);
              const searchElt_neighbor = new SearchElement(pathElt_neighbor, distance_traveled, heuristic_remaining);
              const pqe_neighbor = new PriorityQueueElement(searchElt_neighbor, searchElt_neighbor.getPriority());

              const isValidType = (cell_neighbor.type == type__target);
              // logger.log("isValidType", isValidType);

              if (isValidType) {

                const string_xy = cell_neighbor.x + "," + cell_neighbor.y;
                const is_already_in_queue = dict_chunk[string_xy] != null;

                if (!is_already_in_queue) {
                  dict_chunk[string_xy] = cell_neighbor;
                  //add to frontier
                  pqueue_frontier.enqueue(pqe_neighbor);
                }

              }

            });

            isFull = pqueue_frontier.isEmpty();
          }

          const arr_chunk = Object.values(dict_chunk);
          outArr = arr_chunk;

          return outArr;
        }

        static findOuterShell_of_area_with_type(grid, cell_of_type) {

          const arr_area = this.findArea_with_element_of_type(grid, cell_of_type);
          // logger.log("arr_area.length", arr_area.length);

          const dict_outerShell = arr_area.reduce((acc, cell_area) => {
            const arr_cell_neighbor = Object.values(this.getDictNeighbor(grid, cell_area));
            // logger.log("arr_cell_neighbor", arr_cell_neighbor);
            arr_cell_neighbor.forEach((cell_neighbor, i) => {
              const isOuterCell = (cell_neighbor.type != cell_area.type);
              // logger.log("isOuterCell", isOuterCell);
              if (isOuterCell) {
                const string_xy = cell_neighbor.x + "," + cell_neighbor.y;
                if (!acc[string_xy]) {
                  acc[string_xy] = cell_neighbor;
                }
              }
            });
            return acc;
          }, {});

          const arr_outerShell = Object.values(dict_outerShell);

          return arr_outerShell;
        }

      }

      class Bridge__Crossroads {

        constructor() {
          this.dict_crossroads = {};
        }

        crossroadsObj(id_any) {
          return this.dict_crossroads[id_any];
        }

        add(crossroadsObj) {
          crossroadsObj.getRoads().forEach((road, i) => {
            const identified = crossroadsObj.identifiedForRoad(road);
            const id_ = identified.id();
            // logger.log("setting", id_);
            this.dict_crossroads[id_] = crossroadsObj;
          });
        }

        remove(crossroadsObj) {
          crossroadsObj.getRoads().forEach((road, i) => {
            const identified = crossroadsObj.identifiedForRoad(road);
            const id_ = identified.id();
            delete this.dict_crossroads[id_];
          });
        }

      }

      class Identified {
        constructor(obj, func_id) {
          this.obj = obj;
          this.func_id = func_id;
        }

        id() {
          return this.func_id(this.obj);
        }
      }

      class CrossroadsObj {

        constructor(dict_identified) {
          this.dict_identified = dict_identified;
        }

        getRoads() {
          return Object.keys(this.dict_identified);
        }

        identifiedForRoad(road) {
          return this.dict_identified[road];
        }

        objectForRoad(road) {
          return this.identifiedForRoad(road).obj;
        }

      }

      class OyaGame {

        /* still_river

          hexCoordinates:
            square-xy-based
            offset
            axial

          0 raccourcis clavier pour spawn
              joueurs
              animaux
              symboles (croix, triangle de danger)

          0 pour faire plus vrai:
              les maps d'évènements sont spawnées après que le MJ a zoomé
              le MJ peut ensuite les effacer si ça fait ramer la page

          0 missing assets:
              river Oyapock (story map)

          22 décembre 2021:
            ANNIV LOIC
            plusieurs façons de générer:
              proche en proche probabiliste
              placer des fils au fur et à mesure
              placer des fractales au fur et à mesure
              faire des patates, avec des patates dedans

              grossir des zones en "consommant la frontière"

            0 path between 2 selected cells

            0 définir la "distance de traversée" pour passer d'une cellule d'un type X à une cellule d'un type Y
                espace dual

            0 afficher tous les chemins les plus courts différents

          23 décembre 2021:
            1 A*
              0 sorted list
              0 priority queue:
                change neighbor priority if a shorter route has been found

          26 décembre 2021:
            0 creating a terrain chunk can be done via:
                moving out of a center cell
                moving in to a destination center cell (like the end of a pathfinding)

            0X avoid repainting (==overlapping) what has already been painted
              => actually it is another key element of terrain generation

          27 décembre 2021:
            =>=> GENERATION PAR TACHES ! et contrôle au fur et à mesure
              "créer de l'existant" (==premier(s) jet(s)) pour ensuite le retravailler

            0 essayer sans overlap et avec des gouttes de plus en plus petites (share wrt remaining)

            0 Hexagonal map !
                et la route vers le fractal
                0 faire simple

            0 any shape map

            0 paint/drip

          28 décembre 2021:
            0 corriger le premier jet

          29 décembre 2021:
            0 fill tool
              0 event: cell selected : get "HexModel" object
                => Bridge__Crossroads
                => Reactive bridge

                0 remove biobj when removing cell
              0 highlight selection
              0 area of type

          11 janvier 2022:
            1 retour sur la génération retravaillée
              1 il faut ne pas toucher à nouveau aux types que l'on a ajustés
                => outerShell().filter(ne garder que les types qui ont des cellules en trop)
                   random(grid.cells.filter(ne garder que les types qui ont des cellules en trop))
              |-> l'algorithme a pour effet de "rejeter la boue sur les côtés"...
                    (les types avec des petites parts de marché sont relégués à la périphérie)
              0? trouver une autre façon de rétablir les pourcentages
          13 janvier 2022:
              => 1 utiliser random(arr.filter()) à la place de arr.find()

              0 utiliser une hierarchie de mutabilité
                0 ou utiliser un système de poussée: si sand devient water alors un des voisins de sand devient sand

            0 endless loop when share tree__big too small ( "river" map  usecase)
                while() loops are kind of evil...

          19 janvier 2022:
            LOIC:
            0 ligne de commande pour muter une cellule avec son identifiant
            0 carte de l'Oyapock : possibilité de zoomer et respecter les cours d'eau et l'élévation


        */

        constructor() {

          this.arr_map_types = [
            "forest",
            "river",
            "clear",
            "village",
            "fruitland",
          ];

          this.w = 14;
          this.h = 28;

          // this.hexGrid      = new HexGrid_Rect(this.w,this.h);
          this.hexGrid = new HexGrid_Hex(this.w);

          this.mapGenerator = new HexMapGenerator(this.hexGrid);

          this.bridge = new Bridge__Crossroads();

          this.initialize();
        }

        initialize() {
          this.mapGenerator.generateMap();

          //bind to events
          infiniteCanvas.rx_icEvent_observable.subscribe({
            next: (value) => {
              console.log("rx_icEvent_subject", "next", value);

              const icEvent = value;

              const id_icObj = icEvent.data.id;
              const crossroadsObj = this.bridge.crossroadsObj(id_icObj);
              const hexCell = crossroadsObj.objectForRoad("hexCell");

              // hexCell.type = "sand";
              hexCell.setType2("sand");

            },
          });

          this.loadAssets_p()
            .then(dict_image => {

              this.dict_image = dict_image;

              this.render(dict_image);
            });
        }

        loadAssets_p() {
          const dict_image_path = {
            "water": "img/oyagame/water__ok.png",
            "sand": "img/oyagame/sand.png",
            "soil": "img/oyagame/soil.png",
            "mud": "img/oyagame/mud.png",
            "grass": "img/oyagame/grass.png",
            "tree__small": "img/oyagame/tree__small.png",
            "tree__big": "img/oyagame/tree__big.png",
          };

          var dict_image = {};
          const arr_p = Object.entries(dict_image_path).map(([type, image_path]) => {
            const img__file_p = FileIntegration.imageFromImgSrc_p(image_path);
            const img_p = img__file_p;

            return img_p.then(img => {
              dict_image[type] = img;
              logger.log("loaded image for" + " " + type);
            });
          });

          const assets_p = Promise.all(arr_p)
            .then(arr => {
              return dict_image;
            });

          return assets_p;
        }

        render(dict_image) {

          this.hexGrid.cells.map(hexCell => {

            const icHexagon = this.createIcObjectForHexCell(hexCell, dict_image);

            //bridge
            const crossroadsObj = new CrossroadsObj({
              "hexCell": new Identified(hexCell, this.id_hexCell),
              "icObj": new Identified(icHexagon, this.id_icObj),
            });
            this.bridge.add(crossroadsObj);

            //bind
            hexCell.rx_observable.subscribe({
              next: (value) => {
                logger.log("hexCell.rx_observable", "next", value);
                this.updateIcObj(icHexagon, hexCell);
              },
            })

            infiniteCanvas.addIcObject(icHexagon);
          });

        }

        id_hexCell(hexCell) {
          return hexCell.coords_axial.toString();
        }

        id_icObj(icObj) {
          return icObj.id;
        }

        hexCellForIcObj(icObj) {
          const id = this.id_icObj(icObj);
          logger.log("id", id);
          const crossroadsObj = this.bridge.crossroadsObj(id);
          return crossroadsObj.objectForRoad("hexCell");
        }

        icObjForHexCell(hexCell) {
          const id = this.id_hexCell(hexCell);
          logger.log("id", id);
          const crossroadsObj = this.bridge.crossroadsObj(id);
          return crossroadsObj.objectForRoad("icObj");
        }



        easyConfig(type) {

          var fillColor;
          switch (type) {
            case "blank":
              fillColor = "white";
              break;


            case "water":
              fillColor = "cyan";
              break;
            // case "water_deep":
            // fillColor = "blue";
            // break;
            case "sand":
              fillColor = "gold";
              break;
            case "tree__big":
              fillColor = "black";
              break;
            case "tree__small":
              fillColor = "gray";
              break;
            case "grass":
              fillColor = "green";
              break;
            case "soil":
              fillColor = "red";
              break;
            case "mud":
              fillColor = "brown";
              break;

            default:
              fillColor = "";
              break;
          }

          const cfg = {
            stroke: "white",
            fillColor: fillColor,
          };

          return cfg;
        }

        createIcObjectForHexCell(hexCell, dict_image) {
          var outIcObj;

          // const length = 50;
          const length = 20;

          const row = hexCell.y;
          const col = hexCell.x;

          const factor__col = (col % 2 == 0) ? (col + 1.0) : (col + 0.5);
          const x = 3 * col * length + ((row % 2 == 0) ? 0 : 1.5) * length;
          const y = row * length * math.sqrt(3) / 2.0;
          const pointTL = Geometry.createPoint(x, y);


          const type = hexCell.type;
          const cfg = this.easyConfig(type);

          switch (type) {
            case "blank":
              {
                const icHexagon = infiniteCanvas.createIcHexagon(pointTL, length, cfg);
                outIcObj = icHexagon;
              }
              break;
            default:
              // throw new Error("unsupported type:" + type);
              {
                const img = dict_image[type];
                const icImage = infiniteCanvas.createIcImage(pointTL.x, pointTL.y, img);
                // const img_clone = img.clone();
                // const icImage = infiniteCanvas.createIcImage(pointTL.x, pointTL.y, img_clone);
                const width__tile = 2 * length;
                const height__tile = math.sqrt(3) * length;
                icImage.width = width__tile;
                icImage.height = height__tile;
                icImage.force_width = true;
                icImage.force_height = true;

                outIcObj = icImage;
              }
              break;
            // break;
          }

          return outIcObj;
        }

        updateIcObj(icObj, hexCell) {
          // icObj.strokeWidth = 5;
          // icObj.stroke = "cyan";

          const type = hexCell.type;
          const img = this.dict_image[type];

          //get free rep
          const represented = infiniteCanvas.getRepresented(icObj.id);
          const rep_free = represented.r_free();

          rep_free.img = img;
        }

      }

    </script>
    <script>
      // globalsSingleton.functionCallsQueue.add(() => {
      //   const oyagame = new OyaGame();
      // });
    </script>




    <script>
      class GET100_Game {

        constructor(infiniteCanvas) {
          this.infiniteCanvas = infiniteCanvas;

          const value__initial = 0;
          const value__target = 100;

          //model
          this.gameState = new GET100_GameState(value__initial, value__target);
          this.rx_subject__gameState = new Subject();
          this.rx_observable__gameState = this.rx_subject__gameState.asObservable();

          this.gameInput = new GET100_GameInput();

          this.cardCollection = new GET100_CardCollection();
          Object.defineProperty(this, "dict_card", {
            get() {
              return this.cardCollection.dict_card;
            }
          });
          Object.defineProperty(this, "arr_card", {
            get() {
              return this.cardCollection.arr_card;
            }
          });

          //view
          this.dict_view = {};
          this.bindToIc__state_and_input(infiniteCanvas);
          // this.bindToIc__cards(infiniteCanvas);


          //"outer" view
          this.bindToIc__webcam(infiniteCanvas);
          // this.managePrintedCards();


          this.start();
        }



        bindToIc__state_and_input(infiniteCanvas) {
          const game = this;

          //spawn
          const ic__gameState = GET100_Game.ic__gameState(infiniteCanvas, this.gameState);
          infiniteCanvas.onceOnAddRepresentedForIcObject(ic__gameState, (ic__gameState) => {
            const rep_free = infiniteCanvas.getRepresented(ic__gameState.id).r_free();
            rep_free.position = {
              x: 50,
              y: 0,
            };
          });
          infiniteCanvas.addIcObject(ic__gameState);
          this.dict_view["gameState"] = ic__gameState;




          const ic__gameInput = this.ic__gameInput(infiniteCanvas, this.gameInput);
          infiniteCanvas.onceOnAddRepresentedForIcObject(ic__gameInput, (ic__gameInput) => {
            const rep_free = infiniteCanvas.getRepresented(ic__gameInput.id).r_free();
            rep_free.position = {
              x: 50,
              y: 400,
            };
          });
          infiniteCanvas.addIcObject(ic__gameInput);
          this.dict_view["gameInput"] = ic__gameInput;



          function func_validInput() {
            func_gameInputColorBlink("lime", 300);
          }
          this.dict_view["func_validInput"] = func_validInput;

          function func_invalidInput() {
            func_gameInputColorBlink("red", 300);
          }
          this.dict_view["func_invalidInput"] = func_invalidInput;


          function func_gameInputColorBlink(colorName, duration_in_milliseconds) {
            const rep_free = infiniteCanvas.getRepresented(ic__gameInput.id).r_free();
            const fColor__fill = new fabric.Color(colorName);
            fColor__fill.setAlpha(0.5);
            rep_free.fill = fColor__fill.toRgba();
            setTimeout(function () {
              rep_free.fill = "transparent";
            }, duration_in_milliseconds);
          }


          //--control--

          //forward gameState updates
          this.rx_observable__gameState.subscribe({
            next: (gameState) => {
              logger.log("rx_observable__gameState", "next", gameState.value__current);

              const rep_free = infiniteCanvas.getRepresented(ic__gameState.id).r_free();
              rep_free.parts.icMathNode__current.mathNode = new math.ConstantNode(gameState.value__current);
              rep_free.parts.icMathNode__target.mathNode = new math.ConstantNode(gameState.value__target);

            },
          });


        }

        bindToIc__cards(infiniteCanvas) {
          const game = this;


          const ic__dict_card = {};
          this.arr_card.forEach((card, i) => {
            const ic__card = GET100_Game.ic__card(infiniteCanvas, card);
            infiniteCanvas.addIcObject(ic__card);

            const identifier = card.getIdentifier();
            ic__dict_card[identifier] = ic__card;
          });
          this.dict_view["dict_card"] = ic__dict_card;


          //--control--

          //hooks
          Hooker.installHooks(GET100_Game, "manageGameAction__playCard");      //SHU: I tried to install hooks on instance but it did not work... (does it really matter ?)
          GET100_Game.did["manageGameAction__playCard"].on((game, card) => {
            logger.log("did playCard", game, card);

            //destroy view
            const identifier = card.getIdentifier();
            const ic__card = game.dict_view.dict_card[identifier];
            const rep_free = infiniteCanvas.getRepresented(ic__card.id).r_free();
            infiniteCanvas.killComposite(rep_free);

            //destroy model
            const opSimpleName = card.get100Operator.getSimpleName();
            const index_card = card.index;
            delete game.dict_card[opSimpleName][index_card];
          });


        }

        bindToIc__webcam(infiniteCanvas) {
          const game = this;

          //spawn
          GET100_Game.ic__webcam_p(infiniteCanvas).then(ic__webcam => {

            infiniteCanvas.onceOnAddRepresentedForIcObject(ic__webcam, (ic__webcam) => {
              const rep_free = infiniteCanvas.getRepresented(ic__webcam.id).r_free();
              rep_free.position = {
                x: 50,
                y: 400,
              };
              // rep_free.scale.X = 0.31;
              // rep_free.scale.Y = 0.31;
              rep_free.scale.X = 0.62;
              rep_free.scale.Y = 0.62;
              // rep_free.scale.X = 1;
              // rep_free.scale.Y = 1;
            });
            infiniteCanvas.addIcObject(ic__webcam);
            this.dict_view["webcam"] = ic__webcam;

          });
        }

        static ic__gameState(infiniteCanvas, gameState) {

          const icComposite = GET100_Game.ic_template__gameState(infiniteCanvas);

          //invest
          const value__current = gameState.value__current;
          const mathNode__current = new math.ConstantNode(value__current);
          icComposite.parts.icMathNode__current.mathNode = mathNode__current;

          const value__target = gameState.value__target;
          const mathNode__target = new math.ConstantNode(value__target);
          icComposite.parts.icMathNode__target.mathNode = mathNode__target;

          return icComposite;
        }

        static ic_template__gameState(infiniteCanvas) {
          var outIcObj;

          const trueRect_background = {
            x: 0,
            y: 0,
            width: 200,
            height: 400,
          };
          const icRect = infiniteCanvas.createIcRect(trueRect_background);
          icRect.fill = "blanchedalmond";

          //current
          //label: current
          const trueRect_label__current = {
            x: 5,
            y: 5,
            width: 100,
            height: 100,
          };
          const icLabel__current = infiniteCanvas.createIcText(trueRect_label__current.x, trueRect_label__current.y, "current:");

          //mathNode: current
          const trueRect_mathNode__current = {
            x: 50,
            y: 100,
            width: 100,
            height: 100,
          };
          const mathNode__current = new math.ConstantNode(0);
          const icMathNode__current = infiniteCanvas.createIcMathNode(trueRect_mathNode__current.x, trueRect_mathNode__current.y, mathNode__current);

          //target
          //label: target
          const trueRect_label__target = {
            x: 5,
            y: 205,
            width: 100,
            height: 100,
          };
          const icLabel__target = infiniteCanvas.createIcText(trueRect_label__target.x, trueRect_label__target.y, "target:");

          //mathNode: target
          const trueRect_mathNode__target = {
            x: 50,
            y: 300,
            width: 100,
            height: 100,
          };
          const mathNode__target = new math.ConstantNode(100);
          const icMathNode__target = infiniteCanvas.createIcMathNode(trueRect_mathNode__target.x, trueRect_mathNode__target.y, mathNode__target);




          //composite
          const parts = {
            "bg": icRect,

            "icLabel__current": icLabel__current,
            "icMathNode__current": icMathNode__current,

            "icLabel__target": icLabel__target,
            "icMathNode__target": icMathNode__target,
          };

          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);


          const trueRect_composite = {
            x: 0,
            y: 0,
            width: 200,
            height: 400,
          };

          const icComposite = infiniteCanvas.createIcComposite(trueRect_composite, parts, compositeConfig);
          icComposite.cType = "GET100_GameState";
          icComposite.fill = "";

          outIcObj = icComposite;

          return outIcObj;
        }

        ic__gameInput(infiniteCanvas, gameInput) {
          const game = this;

          const trueRect_icEye = {
            x: 50,
            y: 200,
            width: 300,
            height: 300,
          };

          const icEye = infiniteCanvas.createIcEye(trueRect_icEye);
          icEye.zIndex = 100;

          infiniteCanvas.onceOnAddRepresentedForIcObject(icEye, (icEye) => {

            const rep_free = infiniteCanvas.getRepresented(icEye.id).r_free();

            function attemptDecoding() {

              const img = rep_free.img__captured;

              if (img != null) {
                ImageUtils.qrcode__decode_image_p(img)
                  .then((result) => {
                    logger.log("result", result);
                    if (result != null) {
                      // const str__result = result.text;
                      const str__result = result;

                      const rawInput = str__result;
                      game.manageGameInput__rawInput(rawInput);
                    }
                  }).catch((err) => {
                    // console.error(err);
                  });
              }

            }

            function loopDecode() {

              setTimeout(function () {

                attemptDecoding();
                loopDecode();

              }, 300);

            }

            loopDecode();

          });

          return icEye;
        }

        static ic__card(infiniteCanvas, card) {

          //card template
          const icCard = GET100_Game.ic_template__card(infiniteCanvas);

          //invest
          infiniteCanvas.onceOnAddRepresentedForIcObject(icCard, (icCard) => {

            const rep_free__composite = infiniteCanvas.getRepresented(icCard.id).r_free();

            //qrcode img
            qrcodeImg_p(card.getIdentifier())
              .then(img => {
                rep_free__composite.parts.image.img = img;
              });

            //operator
            rep_free__composite.parts.label__operator.text = card.get100Operator.getSimpleName();

          });

          return icCard;
        }

        static ic_template__card(infiniteCanvas) {
          var outIcObj;

          const trueRect_background = {
            x: 0,
            y: 0,
            width: 250,
            height: 350,
          };
          const icRect = infiniteCanvas.createIcRect(trueRect_background);
          icRect.fill = "grey";

          //img
          const trueRect_img = {
            x: 75,
            y: 75,
            width: 100,
            height: 100,
          };
          const icImage = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, null);

          //operator
          const trueRect_operator = {
            x: 75,
            y: 200,
            width: 100,
            height: 100,
          };
          // const icGMOperator = infiniteCanvas.createIcGMOperator(trueRect_operator, "x 2");
          const icLabel__operator = infiniteCanvas.createIcText(trueRect_operator.x, trueRect_operator.y, "");



          //composite
          const parts = {
            "bg": icRect,
            "image": icImage,
            // "gmOperator": icGMOperator,
            "label__operator": icLabel__operator,
          };

          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);


          const trueRect_composite = {
            x: 500,
            y: 0,
            width: 250,
            height: 350,
          };

          const icComposite = infiniteCanvas.createIcComposite(trueRect_composite, parts, compositeConfig);
          icComposite.cType = "GET100_Card";
          icComposite.fill = "";

          outIcObj = icComposite;

          return outIcObj;
        }

        static ic__webcam_p(infiniteCanvas) {
          const trueRect_webcam = {
            x: 0,
            y: 0,
            width: 200,
            height: 200,
          };
          var out_p = FileIntegration.videoFromWebcam_p()
            .then(video => {
              const left = trueRect_webcam.x;
              const top = trueRect_webcam.y;

              const icVideo = infiniteCanvas.createIcVideo(left, top, video);
              return icVideo;
            });
          return out_p;
        }



        start() {
          const game = this;

          this.gameInput.rx_observable__gameInput.subscribe({
            next: (card) => {
              GET100_Game.manageGameAction__playCard(game, card);
            },
          });

          this.rx_observable__gameState.subscribe({
            next: (gameState) => {
              const value__current = gameState.value__current;
              if (value__current == gameState.value__target) {
                gameState.value__target = 100 - value__current;

                //notify update
                game.rx_subject__gameState.next(game.gameState);   //SHU: un peu cracra
              }
            },
          });

        }


        manageGameInput__rawInput(rawInput) {
          const card = this.cardCollection.getCardWithIdentifier(rawInput);
          if (card != null) {
            this.gameInput.rx_subject__gameInput.next(card);
          } else {
            throw new Error("no card found for input: " + rawInput);
          }
        }


        static manageGameAction__playCard(game, card) {
          logger.log("manageGameAction__playCard", game, card);

          //green blink
          game.dict_view.func_validInput();


          const value__current = game.gameState.value__current;
          const mathNode__current = new math.ConstantNode(value__current);
          mathNode__current.autoSimplify = true;

          const get100Operator = card.get100Operator;
          const func = get100Operator.operatorNodeFactoryFuncWrapper.func;
          const mathNode__result = func(mathNode__current);

          game.gameState.value__current = mathNode__result.value;

          //notify update
          game.rx_subject__gameState.next(game.gameState);
        }

      }

      class GET100_GameState {

        constructor(value__initial, value__target) {
          this.value__initial = value__initial;
          this.value__current = this.value__initial;

          this.value__target = value__target;
        }

      }

      class GET100_GameInput {

        constructor() {
          this.rx_subject__gameInput = new Subject();
          this.rx_observable__gameInput = this.rx_subject__gameInput.asObservable();
        }

      }

      class GET100_Operator {

        constructor(operatorNodeFactoryFuncWrapper) {
          this.operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper;
        }

        getSimpleName() {
          return GET100_Operator.operatorSimpleName(this.operatorNodeFactoryFuncWrapper);
        }

        static operatorSimpleName(operatorNodeFactoryFuncWrapper) {
          return operatorNodeFactoryFuncWrapper.semantics.name;
        }

      }

      class GET100_Card {

        constructor(get100Operator, index) {
          this.get100Operator = get100Operator;
          this.index = index;
        }

        getIdentifier() {
          const str__id = "GET100__" + this.get100Operator.getSimpleName();
          const str__index = "#" + this.index;
          const str__full = str__id + "" + str__index;
          return str__full;
        }

      }

      class GET100_CardCollection {

        constructor() {
          const arr_operator = this.createArrOperator();  //may contain an operator multiple times

          this.dict_card = this.createDictCard(arr_operator); //example of use: dict.operator[opSimpleName].arr_instance[2]
          this.arr_card = this.createArrCard(this.dict_card);
        }

        createDictCard(arr_operator) {
          var outDict;

          outDict = arr_operator.reduce((acc, op) => {
            const str__opSimpleName = op.getSimpleName();

            if (acc[str__opSimpleName] == null) {
              acc[str__opSimpleName] = {};
            }

            const index_card = [...Object.values(acc[str__opSimpleName])].length;
            const card = new GET100_Card(op, index_card);
            acc[str__opSimpleName][index_card] = card;

            return acc;
          }, {});

          return outDict;
        }

        createArrCard(dict_card) {
          var outArr;

          const arr_card = [...Object.values(dict_card)].reduce((acc, x) => {
            return acc.concat([...Object.values(x)]);
          }, []);

          const arr_card__shuffled = Utils.shuffle([...arr_card]);
          outArr = arr_card__shuffled;
          return outArr;
        }

        createArrOperator() {
          var outArr;

          const arr_operatorNodeFactoryFuncWrapper = this.createArrOperatorNodeFactoryFuncWrapper();

          outArr = arr_operatorNodeFactoryFuncWrapper.map(operatorNodeFactoryFuncWrapper => {
            return new GET100_Operator(operatorNodeFactoryFuncWrapper);
          });

          return outArr;
        }

        createArrOperatorNodeFactoryFuncWrapper() {
          var outArr;

          // const arr_opSymbol = ["+", "-", "x", "/"];
          // const arr_opSymbol = ["+", "x"];
          // const arr_value_b  = [0,1,2,3,4,5,6,7,8,9];

          // const arr_opSymbol = ["+", "+"];
          // const arr_value_b  = [0,1,2,3,0,1,2,3];

          // const arr_opSymbol = ["+"];
          // const arr_value_b  = [100];
          // const arr_opSymbol_valueb =  [["+", 100]];

          const arr_add = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15].map(value_b => ["+", value_b]);
          // const arr_add      = [0,1,2,3,4,5,6,7,8,9,10].map(value_b => ["+", value_b]);
          const arr_subtract = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(value_b => ["-", value_b]);
          const arr_multiply = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(value_b => ["x", value_b]);
          const arr_divide = [1, 2, 3, 4, 5, 6, 7, 8, 9].map(value_b => ["/", value_b]);

          const arr_opSymbol_valueb = [...arr_add,
          ...arr_add,
          ...arr_subtract,
          ...arr_subtract,
          ...arr_multiply,
          ...arr_divide];

          // const arr_opSymbol_valueb =  [...arr_add];

          outArr = arr_opSymbol_valueb.map(([string__opSymbol, value_b]) => {
            const op = Operator.fromOpString_binary(string__opSymbol);
            const node_b = new math.ConstantNode(value_b);
            const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);
            return operatorNodeFactoryFuncWrapper;
          });

          return outArr;
        }

        getCardWithIdentifier(identifier__card) {
          logger.log("getCardWithIdentifier", identifier__card);

          //parsing
          const arr_elt = identifier__card.split("#");
          const index = arr_elt[1];
          // logger.log("index", index);

          const opSimpleName = arr_elt[0].split("__")[1];
          // logger.log("opSimpleName", opSimpleName);

          const card = this.dict_card[opSimpleName][index];
          // logger.log("card", card);

          return card;
        }

      }


      class GET100_PrintableCardSheet {

        constructor(infiniteCanvas, arr_card, nb_row, nb_col) {
          logger.log("arr_card", arr_card);

          this.infiniteCanvas = infiniteCanvas;
          this.arr_card = arr_card;

          this.nb_col = nb_row;
          this.nb_row = nb_col;

          this.width = 2100;
          this.height = 2970;


          this.arr_rect_front = this.createArrRect_front();
          this.arr_rect_back = this.createArrRect_back();

        }

        export() {

        }


        getCardX(index_col) {
          return index_col * this.getCardWidth();
        }

        getCardX__mirrored(index_col) {
          return ((this.nb_col - 1) - index_col) * this.getCardWidth();
        }

        getCardY(index_row) {
          return index_row * this.getCardHeight();
        }

        getCardWidth() {
          return this.width / this.nb_col;
        }

        getCardHeight() {
          return this.height / this.nb_row;
        }



        createArrRect_front() {
          //create card rects array
          const arr_index_row = [...Array(this.nb_row).keys()];
          const arr_index_col = [...Array(this.nb_col).keys()];

          return arr_index_row.map(index_row => {
            return arr_index_col.map(index_col => {
              const rect_card = {
                x: this.getCardX(index_col),
                y: this.getCardY(index_row),
                width: this.getCardWidth(),
                height: this.getCardHeight(),
              };
              return rect_card;
            });
          }).flat();
        }

        createArrRect_back() {
          //create card rects array
          const arr_index_row = [...Array(this.nb_row).keys()];
          const arr_index_col = [...Array(this.nb_col).keys()];

          return arr_index_row.map(index_row => {
            return arr_index_col.map(index_col => {
              const rect_card = {
                x: this.getCardX__mirrored(index_col),
                y: this.getCardY(index_row),
                width: this.getCardWidth(),
                height: this.getCardHeight(),
              };
              return rect_card;
            });
          }).flat();
        }

        //front

        ic__page_front() {
          var outIcObj;

          const infiniteCanvas = this.infiniteCanvas;
          const arr_card = this.arr_card;


          const trueRect_background = {
            x: 0,
            y: 0,
            width: this.width,
            height: this.height,
          };
          const icRect = infiniteCanvas.createIcRect(trueRect_background);
          icRect.fill = "white";
          icRect.rx = 0;
          icRect.ry = 0;
          icRect.zIndex = -10;

          //cards
          const arr_card_icPrintableCardFront = arr_card.map((card, i) => {
            const trueRect_card = this.arr_rect_front[i];
            logger.log("trueRect_card", trueRect_card);

            const icPrintableCardFront = GET100_PrintableCardSheet.ic__printableCard_front(infiniteCanvas, card, trueRect_card);
            return [card, icPrintableCardFront];
          });


          //composite
          //parts
          const parts = {
            "bg": icRect,
          };
          const dict_card = arr_card_icPrintableCardFront.reduce((acc, [card, icPrintableCardFront]) => {
            const identifier = card.getIdentifier();
            acc[identifier] = icPrintableCardFront;
            return acc;
          }, {});
          Object.assign(parts, dict_card);


          //SHU: since icPrintableCardFront is a composite, we need to add it to ic before creating mother composite
          //this is a lasting temporary workaround
          infiniteCanvas.addIcObject(icRect);
          arr_card_icPrintableCardFront.forEach(([card, icPrintableCardFront], i) => {
            infiniteCanvas.addIcObject(icPrintableCardFront);
          });


          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);


          const trueRect_composite = trueRect_background;
          const icComposite = infiniteCanvas.createIcComposite(trueRect_composite, parts, compositeConfig);
          icComposite.cType = "GET100_PrintableCardSheet_front";
          icComposite.fill = "";

          outIcObj = icComposite;

          return outIcObj;
        }

        static ic__printableCard_front(infiniteCanvas, card, trueRect_card) {
          logger.log("ic__printableCard_front", card, trueRect_card);

          //card template
          const icPrintableCard_front = GET100_PrintableCardSheet.ic_template__printableCard_front(infiniteCanvas, trueRect_card);


          //enrich
          const icCard_spec = {
            card: card,
          };
          Object.assign(icPrintableCard_front, icCard_spec);


          //invest

          //position
          infiniteCanvas.onceOnAddRepresentedForIcObject(icPrintableCard_front, (icPrintableCard_front) => {

            const rep_free__composite = infiniteCanvas.getRepresented(icPrintableCard_front.id).r_free();
            rep_free__composite.position = {
              x: trueRect_card.x,
              y: trueRect_card.y,
            };

          });


          //content
          infiniteCanvas.onceOnAddRepresentedForIcObject(icPrintableCard_front, (icPrintableCard_front) => {

            const rep_free__composite = infiniteCanvas.getRepresented(icPrintableCard_front.id).r_free();

            //operator
            rep_free__composite.parts.label__operator.text = card.get100Operator.getSimpleName();

          });

          return icPrintableCard_front;
        }

        static ic_template__printableCard_front(infiniteCanvas, trueRect_card) {
          var outIcObj;

          const trueRect_background = {
            x: 0,
            y: 0,
            width: trueRect_card.width,
            height: trueRect_card.height,
          };
          const icRect = infiniteCanvas.createIcRect(trueRect_background);
          icRect.fill = "white";
          icRect.strokeWidth = 2;
          icRect.stroke = "black";


          //img
          // const trueRect_img = {
          //   x: 75,
          //   y: 75,
          //   width:  100,
          //   height: 100,
          // };
          // const icImage = infiniteCanvas.createIcImage(trueRect_img.x,trueRect_img.y,null);

          //operator
          const trueRect_operator = {
            x: trueRect_background.width * 0.15,
            y: trueRect_background.height * 0.15,
            width: 100,
            height: 100,
          };
          // const icGMOperator = infiniteCanvas.createIcGMOperator(trueRect_operator, "x 2");
          const icLabel__operator = infiniteCanvas.createIcText(trueRect_operator.x, trueRect_operator.y, "");



          //composite
          const parts = {
            "bg": icRect,
            // "image":      icImage,
            // "gmOperator": icGMOperator,
            "label__operator": icLabel__operator,
          };

          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);


          const trueRect_composite = trueRect_background;
          const icComposite = infiniteCanvas.createIcComposite(trueRect_composite, parts, compositeConfig);
          icComposite.cType = "GET100_PrintableCard_front";
          icComposite.fill = "";

          outIcObj = icComposite;

          return outIcObj;
        }





        //back

        ic__page_back() {
          var outIcObj;

          const infiniteCanvas = this.infiniteCanvas;
          const arr_card = this.arr_card;


          const trueRect_background = {
            x: 0,
            y: 0,
            width: this.width,
            height: this.height,
          };
          const icRect = infiniteCanvas.createIcRect(trueRect_background);
          icRect.fill = "white";
          icRect.rx = 0;
          icRect.ry = 0;
          icRect.zIndex = -10;

          //cards
          const arr_card_icPrintableCardBack = arr_card.map((card, i) => {
            const trueRect_card = this.arr_rect_back[i];
            logger.log("trueRect_card", trueRect_card);

            const icPrintableCardBack = GET100_PrintableCardSheet.ic__printableCard_back(infiniteCanvas, card, trueRect_card);
            return [card, icPrintableCardBack];
          });


          //composite
          //parts
          const parts = {
            "bg": icRect,
          };
          const dict_card = arr_card_icPrintableCardBack.reduce((acc, [card, icPrintableCardBack]) => {
            const identifier = card.getIdentifier();
            acc[identifier] = icPrintableCardBack;
            return acc;
          }, {});
          Object.assign(parts, dict_card);


          //SHU: since icPrintableCardFront is a composite, we need to add it to ic before creating mother composite
          //this is a lasting temporary workaround
          infiniteCanvas.addIcObject(icRect);
          arr_card_icPrintableCardBack.forEach(([card, icPrintableCardBack], i) => {
            infiniteCanvas.addIcObject(icPrintableCardBack);
          });


          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);


          const trueRect_composite = trueRect_background;
          const icComposite = infiniteCanvas.createIcComposite(trueRect_composite, parts, compositeConfig);
          icComposite.cType = "GET100_PrintableCardSheet_front";
          icComposite.fill = "";

          outIcObj = icComposite;

          return outIcObj;
        }

        static ic__printableCard_back(infiniteCanvas, card, trueRect_card) {
          logger.log("ic__printableCard_back", card, trueRect_card);

          //card template
          const icPrintableCard_back = GET100_PrintableCardSheet.ic_template__printableCard_back(infiniteCanvas, trueRect_card);


          //enrich
          const icCard_spec = {
            card: card,
          };
          Object.assign(icPrintableCard_back, icCard_spec);


          //invest

          //position
          infiniteCanvas.onceOnAddRepresentedForIcObject(icPrintableCard_back, (icPrintableCard_back) => {

            const rep_free__composite = infiniteCanvas.getRepresented(icPrintableCard_back.id).r_free();
            rep_free__composite.position = {
              x: trueRect_card.x,
              y: trueRect_card.y,
            };

          });


          //content
          infiniteCanvas.onceOnAddRepresentedForIcObject(icPrintableCard_back, (icPrintableCard_back) => {

            const rep_free__composite = infiniteCanvas.getRepresented(icPrintableCard_back.id).r_free();

            //img
            qrcodeImg_p(card.getIdentifier())
              .then(img => {
                logger.log("qrcodeImg_p", "img", img);
                // img.width  = 100;
                // img.height = 100;

                // rep_free__composite.parts.image.force_width  = true;
                // rep_free__composite.parts.image.force_height = true;
                rep_free__composite.parts.image.img = img;

                rep_free__composite.parts.image.scale.X = 3;
                rep_free__composite.parts.image.scale.Y = 3;

              });

          });

          return icPrintableCard_back;
        }

        static ic_template__printableCard_back(infiniteCanvas, trueRect_card) {
          var outIcObj;

          const trueRect_background = {
            x: 0,
            y: 0,
            width: trueRect_card.width,
            height: trueRect_card.height,
          };
          const icRect = infiniteCanvas.createIcRect(trueRect_background);
          icRect.fill = "white";
          icRect.strokeWidth = 2;
          icRect.stroke = "black";


          //img
          const trueRect_img = {
            x: trueRect_background.width * 0.15,
            y: trueRect_background.height * 0.15,
            width: trueRect_background.width * 0.66,
            height: trueRect_background.width * 0.66,
          };
          const icImage = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, null);

          //operator
          // const trueRect_operator = {
          //   x: trueRect_background.width  * 0.15,
          //   y: trueRect_background.height * 0.15,
          //   width: 100,
          //   height: 100,
          // };
          // // const icGMOperator = infiniteCanvas.createIcGMOperator(trueRect_operator, "x 2");
          // const icLabel__operator = infiniteCanvas.createIcText(trueRect_operator.x, trueRect_operator.y, "");



          //composite
          const parts = {
            "bg": icRect,
            "image": icImage,
            // "gmOperator": icGMOperator,
            // "label__operator": icLabel__operator,
          };

          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);


          const trueRect_composite = trueRect_background;
          const icComposite = infiniteCanvas.createIcComposite(trueRect_composite, parts, compositeConfig);
          icComposite.cType = "GET100_PrintableCard_back";
          icComposite.fill = "";

          outIcObj = icComposite;

          return outIcObj;
        }


      }

      class GET100_PrintableCardCollection {

        constructor(cardCollection, nb_row__page, nb_col__page) {

          this.cardCollection = cardCollection;

          this.nb_row__page = nb_row__page;
          this.nb_col__page = nb_col__page;
          this.nb_card__page = nb_row__page * nb_col__page;

        }

        spawn_to_ic() {

          const nb_row = this.nb_row__page;
          const nb_col = this.nb_col__page;

          const arr_partition = Utils.partitionArray(this.cardCollection.arr_card, this.nb_card__page);
          arr_partition.forEach((arr_card, i) => {
            const printableCardSheet = new GET100_PrintableCardSheet(infiniteCanvas, arr_card, nb_row, nb_col);

            const trueRect_page_front = {
              x: (2 * i) * (printableCardSheet.width + 50),
              y: i * (printableCardSheet.height + 50),
              width: printableCardSheet.width,
              height: printableCardSheet.height,
            };

            const icPage_front = printableCardSheet.ic__page_front();
            infiniteCanvas.onceOnAddRepresentedForIcObject(icPage_front, (icPage_front) => {

              const rep_free__composite = infiniteCanvas.getRepresented(icPage_front.id).r_free();
              rep_free__composite.position = {
                x: trueRect_page_front.x,
                y: trueRect_page_front.y,
              };

            });
            infiniteCanvas.addIcObject(icPage_front);

            const trueRect_page_back = {
              x: (2 * i + 1) * (printableCardSheet.width + 50),
              y: i * (printableCardSheet.height + 50),
              width: printableCardSheet.width,
              height: printableCardSheet.height,
            };

            const icPage_back = printableCardSheet.ic__page_back();
            infiniteCanvas.onceOnAddRepresentedForIcObject(icPage_back, (icPage_back) => {

              const rep_free__composite = infiniteCanvas.getRepresented(icPage_back.id).r_free();
              rep_free__composite.position = {
                x: trueRect_page_back.x,
                y: trueRect_page_back.y,
              };

            });
            infiniteCanvas.addIcObject(icPage_back);


            //save as img
            setTimeout(function () {
              //print pages
              // infiniteCanvas.exportCanvasRectContainingObj_asImg(icPage_front);
              // infiniteCanvas.exportCanvasRectContainingObj_asImg(icPage_back);

              //print cards
              function getDictIcCardFromIcPage(icPage) {
                const dict_card = Object.assign({}, icPage.parts);
                delete dict_card["bg"];
                return dict_card;
              }


              // logger.log("log7, icPage_front", icPage_front);
              const dict_card__front = getDictIcCardFromIcPage(icPage_front);
              const arr_card__front = Object.values(dict_card__front);

              //debug
              // const icObj__card = arr_card__front.find(e => true);
              // logger.log("log7, icObj__card", icObj__card);
              // infiniteCanvas.exportCanvasRectContainingObj_asImg(icObj__card);

              arr_card__front.forEach((icObj__card) => {
                const card = icObj__card.card;
                logger.log("log7", "card", card);
                const id_card = card.getIdentifier();
                // infiniteCanvas.exportCanvasRectContainingObj_asImg(icObj__card, id_card);

                const dataUrl__card = infiniteCanvas.dataUrl_for_canvasRectContainingObj(icObj__card, id_card);
                const base64__card = FileIntegration.base64_for_dataUrl(dataUrl__card);


                const jsZip = new JSZip();
                jsZip.file("Hello.txt", "Hello World\n");

                var folder__img = jsZip.folder("images");
                folder__img.file("card.png", base64__card, { base64: true });

                jsZip.generateAsync({ type: "blob" })
                  .then(function (content) {
                    // see FileSaver.js
                    saveAs(content, "example.zip");
                  });

              });

            }, 6000 + i * 3000);

          });

        }
      }


      class GET100__Atelier {

        constructor() {

        }

        static spawn_virtual_card() {
          //debug
          const trueRect_img = {
            x: 0,
            y: 0,
            width: 100,
            height: 100,
          };
          qrcodeImg_p("GET100__+ 2#0")
            .then(img => {
              const icObj_front = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img);
              icObj_front.scale.X = 1.0;
              icObj_front.scale.Y = 1.0;
              icObj_front.zIndex = 100;
              // icObj_front.width  = trueRect_img.width;
              // icObj_front.height = trueRect_img.height;
              infiniteCanvas.addIcObject(icObj_front);
            });

        }

        static debug_filters() {

          setTimeout(function () {

            const icEye = infiniteCanvas.getAllRepresentedWithType("eye")[0].r_official();
            logger.log("log2", "icEye", icEye);
            const rep_free__eye = infiniteCanvas.getRepresented(icEye.id).r_free();
            const img__captured = rep_free__eye.img__captured;

            const arr_brightness = [...Array(11).keys()].map(index => index * 0.1);
            const arr_contrast   = [...Array(11).keys()].map(index => index * 0.1);

            arr_brightness.forEach((value__brightness, i) => {
              arr_contrast.forEach((value__contrast, j) => {
                // logger.log("log2", "value__brightness", value__brightness, "value__contrast", value__contrast);
                const img__filtered_p = ImageUtils.image_filtered_p(img__captured, value__brightness, value__contrast);

                img__filtered_p.then(img__filtered => {
                  logger.log("log2", "img__filtered", img__filtered);

                  const trueRect_img = {
                    x: i * 100,
                    y: j * 100,
                    width: 100,
                    height: 100,
                  };

                  const icObj_img = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img__filtered);
                  infiniteCanvas.onceOnAddRepresentedForIcObject(icObj_img, (icObj_img) => {
                    logger.log("log2", "icObj_img", icObj_img.position.x, icObj_img.size.width);

                    const rep_free = infiniteCanvas.getRepresented(icObj_img.id).r_free();
                    rep_free.position = {
                      x: trueRect_img.x,
                      y: trueRect_img.y,
                    };

                  });
                  infiniteCanvas.addIcObject(icObj_img);

                });

              });
            });

          }, 6000);

        }

        static debug_filters_2() {

          setTimeout(function () {

            const icEye = infiniteCanvas.getAllRepresentedWithType("eye")[0].r_official();
            logger.log("log2", "icEye", icEye);
            const rep_free__eye = infiniteCanvas.getRepresented(icEye.id).r_free();
            const img__captured = rep_free__eye.img__captured;

            const value__brightness = 0.3;
            const value__contrast = 0.3;

            const img__filtered_p = ImageUtils.image_filtered_p(img__captured, value__brightness, value__contrast);

            img__filtered_p.then(img__filtered => {
              logger.log("log2", "img__filtered", img__filtered);

              const trueRect_img = {
                x: 100,
                y: 100,
                width: 100,
                height: 100,
              };

              const icObj_img = infiniteCanvas.createIcImage(trueRect_img.x, trueRect_img.y, img__filtered);
              infiniteCanvas.onceOnAddRepresentedForIcObject(icObj_img, (icObj_img) => {
                logger.log("log2", "icObj_img", icObj_img.position.x, icObj_img.size.width);

                const rep_free = infiniteCanvas.getRepresented(icObj_img.id).r_free();
                rep_free.position = {
                  x: trueRect_img.x,
                  y: trueRect_img.y,
                };

              });
              infiniteCanvas.addIcObject(icObj_img);

            });

          }, 6000);

        }

      }

    </script>
    <script>
    //launch game
    // const game__GET100 = new GET100_Game(infiniteCanvas);

    //to print cards //SHU888
    // const cardCollection          = new GET100_CardCollection();
    // const printableCardCollection = new GET100_PrintableCardCollection(cardCollection,4,4);
    // printableCardCollection.spawn_to_ic();

    //debug
    // GET100__Atelier.spawn_virtual_card();
    // GET100__Atelier.debug_filters();
    // GET100__Atelier.debug_filters_2();
    </script>





    <script>

      class TargetM100100Game {



      }




    </script>
    <script>
      //launch game
      // const game__targetM100100 = new TargetM100100Game(infiniteCanvas);

    </script>







    <!-- 3DRoom -->
    
    <script src="./lib/3D/three.bundle.min.js"        type="text/javascript"></script>
    <script src="./lib/3D/three-laser-pointer.min.js" type="text/javascript"></script>

    <script>
      class ICControls {

        constructor(infiniteCanvas, keyboardIntegration, mouseIntegration) {
          this.infiniteCanvas      = infiniteCanvas;
          this.keyboardIntegration = keyboardIntegration;
          this.mouseIntegration    = mouseIntegration;
        }

        setActive(isActive_in) {
          logger.log("logControls", "ICControls::setActive()");

          const keyboardIntegration = this.keyboardIntegration;
          if(isActive_in) {
            keyboardIntegration.configureKeyDownToggles();
            keyboardIntegration.configureKeyDownTimeouts();
            keyboardIntegration.configureKeyUpABToggles();
            keyboardIntegration.configureKeyUpTriggers();

            mouseIntegration.configureKeyDownToggles();
            // mouseIntegration.configureKeyDownTriggers();

          } else {
            // keyboardIntegration.configureKeyDownToggles();
            // keyboardIntegration.configureKeyDownTimeouts();
            // keyboardIntegration.configureKeyUpABToggles();
          }
        }

        on() {
          logger.log("logControls", "ICControls::on()");
          this.setActive(true);
        }

        off() {
          this.setActive(false);
        }
      }

      const iC_controls = new ICControls(infiniteCanvas, keyboardIntegration, mouseIntegration);
      infiniteCanvas.iC_controls = iC_controls; 

    </script>
    <script>
      function func_3DRoom() {
        let camera, scene, renderer, controls;
        let canvas__renderer;

        const arr_object = [];    //"physics objs"
        let raycaster;

        let moveForward  = false;
        let moveBackward = false;
        let moveLeft     = false;
        let moveRight    = false;
        let canJump      = false;

        let prevTime    = performance.now();
        const velocity  = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const vertex    = new THREE.Vector3();
        const color     = new THREE.Color();


        const size__room = {  //size's x, y, z are width, height, depth.
          x:  35,
          y:  35,
          z:  55,
        };
        const size__wall = {
          width:  size__room.z,
          height: size__room.x,
        };

        let room;
        let mesh__wall;
        let laser;

        let isLaserPointingIC;
        let isCanCapture;
        let isCapturedByIC = false;

        let onKeyDown;
        let onKeyUp;
        let onMouseUp;

        let onKeyUp__escape;


        init();
        animate();

        function init() {

          scene = new THREE.Scene();
          scene.background = new THREE.Color( 0xffffff );
          scene.fog = new THREE.Fog( 0xffffff, 0, 750 );




          camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
          camera.position.y = 10;
          // camera.position.z = 60;
          // camera.position.x = 30;
      

          //debug
          // document.addEventListener( 'mousemove', (event) => {

          //   let pointer = new THREE.Vector2();
          //   // calculate pointer position in normalized device coordinates
          //   // (-1 to +1) for both components
          //   pointer.x = + ( event.clientX / window.innerWidth  ) * 2 - 1;
          //   pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
          //   logger.log("pointer:", pointer);



          //   camera.updateMatrixWorld();
          //   // logger.log("camera:", camera);
          //   const raycaster    = new THREE.Raycaster();
          //   raycaster.setFromCamera(pointer, camera);

          //   // {            
          //   //   const vect3__origin = (new THREE.Vector3( 0, 0,    0 )).applyMatrix4( camera.matrixWorld );
          //   //   const vect3__far    = (new THREE.Vector3( 0, 0, -1e4 )).applyMatrix4( camera.matrixWorld );

          //   //   const vect3__direction = (new THREE.Vector3()).subVectors(vect3__far, vect3__origin).normalize();
          //   //   raycaster.set(vect3__origin, vect3__direction);
          //   // }


          //   mesh__wall.updateMatrixWorld();

          //   const arr_obj = scene.children.filter(obj => (obj != laser));
          //   // logger.log("arr_obj:", arr_obj);

          //   // const arr_intersected = raycaster.intersectObjects(arr_obj, true);
          //   const arr_intersected = raycaster.intersectObject(mesh__wall, true);

          //   logger.log("arr_intersected:", arr_intersected);
          // });




          const light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 2.5 );
          light.position.set( 0.5, 1, 0.75 );
          scene.add( light );


          //controls
          controls = new THREE.PointerLockControls( camera, document.body );

          const onClick = function () {

            if(!isCapturedByIC) {
              controls.lock();

              document.addEventListener( 'keydown', onKeyDown );
              document.addEventListener( 'keyup',   onKeyUp   );
              document.addEventListener( 'mouseup', onMouseUp );

              // window.removeEventListener( 'click',  onClick);
            }

          };
          window.addEventListener( 'click',  onClick);

          // const blocker      = document.getElementById( 'blocker' );
          // const instructions = document.getElementById( 'instructions' );

          // instructions.addEventListener( 'click', function () {

          //   controls.lock();

          // } );

          // controls.addEventListener( 'lock', function () {

          //   instructions.style.display = 'none';
          //   blocker.style.display = 'none';

          // } );

          // controls.addEventListener( 'unlock', function () {

          //   blocker.style.display = 'block';
          //   instructions.style.display = '';

          // } );

          scene.add( controls.getObject() );

          onKeyDown = function ( event ) {

            switch ( event.code ) {

              case 'ArrowUp':
              case 'KeyW':
                moveForward = true;
                break;

              case 'ArrowLeft':
              case 'KeyA':
                moveLeft = true;
                break;

              case 'ArrowDown':
              case 'KeyS':
                moveBackward = true;
                break;

              case 'ArrowRight':
              case 'KeyD':
                moveRight = true;
                break;

              case 'Space':
                if ( canJump === true ) velocity.y += 350;
                canJump = false;
                break;

              case 'KeyQ':
                {
                  const factor = 0.9;
                  const matrix3__scale = new THREE.Matrix3();
                  matrix3__scale.fromArray([factor,0,0,0,factor,0,0,0,factor]);
                  // scene
                  const arr_scaled = scene.children.filter((obj3D) => (obj3D != camera) && (obj3D != laser) );
                  arr_scaled.forEach((obj3D) => {
                    obj3D.scale.applyMatrix3(matrix3__scale);
                  });

                  // scene.update

                  // camera.near  = camera.near * factor;
                  // camera.far   = camera.far  * factor;
                  // camera.fov   = camera.fov  * factor;
                  // camera.updateProjectionMatrix(); 
                }
                break;
              case 'KeyE':
                {
                  const factor = 10.0/9.0;
                  const matrix3__scale = new THREE.Matrix3();
                  matrix3__scale.fromArray([factor,0,0,0,factor,0,0,0,factor]);
                  // scene
                  const arr_scaled = scene.children.filter((obj3D) => (obj3D != camera) && (obj3D != laser) );
                  arr_scaled.forEach((obj3D) => {
                    obj3D.scale.applyMatrix3(matrix3__scale);
                  });

                  // camera.near  = camera.near * factor;
                  // camera.far   = camera.far  * factor;
                  // camera.fov   = camera.fov  * factor;
                  // camera.updateProjectionMatrix();
                }
                break;

            }

          };

          onKeyUp = function ( event ) {

            switch ( event.code ) {

              case 'ArrowUp':
              case 'KeyW':
                moveForward = false;
                break;

              case 'ArrowLeft':
              case 'KeyA':
                moveLeft = false;
                break;

              case 'ArrowDown':
              case 'KeyS':
                moveBackward = false;
                break;

              case 'ArrowRight':
              case 'KeyD':
                moveRight = false;
                break;

            }

          };

          // document.addEventListener( 'keydown', onKeyDown );
          // document.addEventListener( 'keyup',   onKeyUp   );


          onMouseUp = function ( event ) {
            if(isCanCapture) {
              console.log("captureNow");
              capture();
            }
          };
          // document.addEventListener( 'mouseup', onMouseUp );


          //laser
          laser = new Laser({color: 0xff0000});
          scene.add(laser);





          raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );






          

          scene.add( new THREE.AmbientLight( 0x444444 ) );

          
          //room
          const geom__room = new THREE.BoxGeometry(size__room.x,size__room.y,size__room.z);
          const mat__room  = new THREE.MeshNormalMaterial({
              side: THREE.DoubleSide, // fix #3 - can do this to make room walls visible from both sides.
              // side: THREE.BackSide,

              transparent: true,
              opacity: 0.7,
          });
          room = new THREE.Mesh(geom__room, mat__room);
          console.log("room:", room);
          // room.rotation.set(-Math.PI/3, 0.3, -0.3 );
          
          // const boundingBox__room = new THREE.Box3().setFromObject(room);
          // const size__room = boundingBox__room.getSize(); //size's x, y, z are width, height, depth.

          room.position.y = room.position.y + size__room.y / 2.0;

          scene.add(room);
            
          // {
          //   var geom__edges = new THREE.EdgesGeometry( geom__room );
          //   var geom__line  = new LineSegmentsGeometry().fromEdgesGeometry( geom__edges );

          //   const mat__line = new LineMaterial( {
          //     color: 0x4080ff,
          //     linewidth: 5,
          //   } );

          //   wireframe = new Wireframe( geom__line, mat__line );
          //   wireframe.computeLineDistances();
          //   wireframe.scale.set( 1, 1, 1 );
          //   scene.add( wireframe );
          // }




          // floor

          let geom__floor = new THREE.PlaneGeometry( 2000, 3000, 100, 100 );
          geom__floor.rotateX( - Math.PI / 2 );


          // const mat__floor = new THREE.MeshBasicMaterial( { vertexColors: true } );
          const mat__floor = new THREE.MeshLambertMaterial({
              side: THREE.DoubleSide // fix #3 - can do this to make room walls visible from both sides.
              // side: THREE.FrontSide,
          });

          const floor = new THREE.Mesh( geom__floor, mat__floor );
          scene.add( floor );



          // objects

            //box in room
          const geom__box = new THREE.BoxGeometry( 6, 6, 6 );
          const mat__box  = new THREE.MeshNormalMaterial({
              side: THREE.FrontSide,
          });
          const box = new THREE.Mesh( geom__box, mat__box );
          console.log("box:", box);
          box.position.y = box.position.y + 3;
          scene.add( box );
          arr_object.push( box );



            //canvas on wall
          const canvas__wall  = document.getElementById("myCanvas");
          const texture__wall = new THREE.CanvasTexture(canvas__wall);
          // Setting magFilter and minFilter to THREE.NearestFilter
          // console.log(texture__wall.magFilter); // 1006 ( THREE.LinearFilter - r146 )
          // console.log(texture__wall.minFilter); // 1008 ( THREE.LinearMipmapLinearFilter - r146 )
          // console.log(THREE.NearestFilter); // 1003 ( r146 )
          texture__wall.magFilter = THREE.NearestFilter;
          texture__wall.minFilter = THREE.NearestFilter;

          const geom__wall = new THREE.PlaneGeometry(size__wall.width, size__wall.height);
          const mat__wall  = new THREE.MeshBasicMaterial({ 
            map: texture__wall,
            side: THREE.DoubleSide,

            // transparent: true,
            opacity: 0.7,
          });
          // const mat__wall = new THREE.MeshLambertMaterial({
          //   emissive:    new THREE.Color(0xffffff),
          //   emissiveMap: texture__wall
          // });
          mesh__wall = new THREE.Mesh(geom__wall, mat__wall);

          mesh__wall.position.y = mesh__wall.position.y + size__room.y / 2.0;
          mesh__wall.position.x = mesh__wall.position.x - size__room.x / 2.0 + 0.1;

          // mesh__wall.rotation.set(-Math.PI/2, 0, -0.1 );
          
          mesh__wall.rotateY(Math.PI/2);


          scene.add(mesh__wall);
          console.log("mesh__wall:", mesh__wall);



          canvas__renderer = document.getElementById("rendererCanvas");
          renderer = new THREE.WebGLRenderer( { 
            canvas: canvas__renderer, 
            antialias: true, 
          });
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight );
          document.body.appendChild( renderer.domElement );

          //

          window.addEventListener( 'resize', onWindowResize );

        }

        function onWindowResize() {

          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();

          renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function animate() {

          // checkCanCapture();

          requestAnimationFrame( animate );

          const time = performance.now();

          if ( controls.isLocked === true ) {

            raycaster.ray.origin.copy( controls.getObject().position );
            raycaster.ray.origin.y -= 10;

            const intersections = raycaster.intersectObjects( arr_object, false );

            const onObject = intersections.length > 0;

            const delta = ( time - prevTime ) / 1000;

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

            direction.z = Number( moveForward ) - Number( moveBackward );
            direction.x = Number( moveRight ) - Number( moveLeft );
            direction.normalize(); // this ensures consistent movements in all directions

            if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
            if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

            if ( onObject === true ) {

              velocity.y = Math.max( 0, velocity.y );
              canJump = true;

            }

            controls.moveRight( - velocity.x * delta );
            controls.moveForward( - velocity.z * delta );

            controls.getObject().position.y += ( velocity.y * delta ); // new behavior

            if ( controls.getObject().position.y < 10 ) {

              velocity.y = 0;
              controls.getObject().position.y = 10;

              canJump = true;

            }

          }

          {
            // laser.point(pLocal);
            isCanCapture = checkCanCapture_withLaser();
            if(isCanCapture) {
              const rgb__green = 0x00ff00;
              laser.setColor(rgb__green);
            } else {
              const rgb__red = 0xff0000;
              laser.setColor(rgb__red);
            }
          }



          prevTime = time;

          renderer.render( scene, camera );

        }

        // function checkCanCapture() {
        //   const arr_intersected = raycaster.intersectObjects( scene.children, true );
        //   console.log("arr_intersected:", arr_intersected[0]);
          
        //   // const arr_3dObj = arr_intersected.map(intersected => intersected.object);
        //   const distance = arr_intersected.filter(x => (x.object == mesh__wall))?.[0]?.distance;
        //   if(distance != null) {
        //     console.log("distance:", distance);
        //   }
        // }

        function checkCanCapture_withLaser() {
          var outBool = false;

          laser.setSource(new THREE.Vector3(3, -4, -2), camera);

          var pLocal = new THREE.Vector3( 0, 0, -1e4 );
          var pWorld = pLocal.applyMatrix4( camera.matrixWorld );

          const arr_mesh = [mesh__wall];
          laser.pointWithRaytrace(pLocal, arr_mesh, null, 1);
          
          const arr_hit = laser.getMeshesHit();
          // console.log("arr_hit:", arr_hit);

          isLaserPointingIC = arr_hit.includes(mesh__wall);
          // console.log("isLaserPointingIC:", isLaserPointingIC);

          if(isLaserPointingIC) {
            const arr_point = laser.getPoints();
            // console.log("arr_point:", arr_point);

            if(arr_point.length >= 2) {
              const vect3__origin    = arr_point[0];
              // console.log("vect3__origin:", vect3__origin);

              const vect3__direction = (new THREE.Vector3()).subVectors(arr_point[1], arr_point[0]).normalize();
              // console.log("vect3__direction:", vect3__direction);

              const distance_max = 30;
              const raycaster    = new THREE.Raycaster(vect3__origin, vect3__direction, 0, distance_max);
              
              const arr_intersected = raycaster.intersectObject(mesh__wall, true);
              
              const isCanCapture = (arr_intersected.length > 0);
              outBool = isCanCapture;
            }

          }
              
          return outBool;
        }





        function capture() {
          isCapturedByIC = true;

          //kill pointerLock controls
          document.removeEventListener( 'keydown', onKeyDown );
          document.removeEventListener( 'keyup',   onKeyUp   );
          document.removeEventListener( 'mouseup', onMouseUp );

          //add escape shortcut
          document.addEventListener( 'keyup', onKeyUp__escape );



          //translate mousePointer to iC
          const container = canvas__renderer;

          // const canvas    = document.getElementById("myCanvas");
          const canvas    = fabricIntegration.fabricCanvas;

          container.addEventListener("mousemove",  onMouseEvt, false);
          container.addEventListener("mousedown",  onMouseEvt, false);
          container.addEventListener("mouseup",    onMouseEvt, false);

          container.addEventListener("wheel",      onMouseEvt, false);

          function onMouseEvt(event) {
            logger.log("log3DRoom", "onMouseEvt:", event);

            event.preventDefault();
            const uv = getUVOnCanvas(event);
            if(uv != null) {
              const size__canvas = {
                width:  canvas.width  * window.devicePixelRatio, 
                height: canvas.height * window.devicePixelRatio,
              };
              logger.log("log3DRoom", "size__canvas:", size__canvas);
              const positionOnCanvas = {
                x: uv.x * size__canvas.width,
                y: uv.y * size__canvas.height,
              };
              logger.log("log3DRoom", "positionOnCanvas:", positionOnCanvas);

              // const _offset = {
              //   x: canvas._offset.left,
              //   y: canvas._offset.top,
              // };
              const simEvt = new MouseEvent(event.type, Object.assign({},event,{
                clientX:  positionOnCanvas.x,
                clientY:  positionOnCanvas.y,

                x:        positionOnCanvas.x,
                y:        positionOnCanvas.y,
              }));
              

              if(event.type != "wheel") {
                canvas.upperCanvasEl.dispatchEvent(simEvt);
              } else {
                const container__dispatch = document.getElementsByClassName("canvas-container")[0];
                container__dispatch.dispatchEvent(simEvt);
              }

            }

            // canvas.upperCanvasEl.dispatchEvent(event);

            // if (event && event.originalEvent) {
            //   var oe = event.originalEvent;
            //   const event__clone = new oe.constructor(oe.type, oe);
            //   canvas.upperCanvasEl.dispatchEvent(event__clone);
            //   // canvas.dispatchEvent(event__clone);
            // }

            mesh__wall.material.map.needsUpdate = true;
          }

          



          //activate iC controls
          infiniteCanvas.iC_controls.on();

          controls.unlock();



          //debug
          FileIntegration.loadInfinishute_p()
          //debug
          .then(infinishute => {
            console.log("loaded infinishute", infinishute);
            return infinishute;
          })
          .then(infinishute => {
            infiniteCanvas.manageLoadInfinishute(infinishute);
            mesh__wall.material.map.needsUpdate = true;
          });

        }

        function decapture() {
          controls.lock();
          document.addEventListener( 'keydown', onKeyDown );
          document.addEventListener( 'keyup',   onKeyUp   );
          document.addEventListener( 'mouseup', onMouseUp );

          document.removeEventListener( 'keyup', onKeyUp__escape );

          infiniteCanvas.iC_controls.off();

          isCapturedByIC = false;
        }

        onKeyUp__escape = function ( event ) {

          switch ( event.code ) {

            case 'Escape':
            {
              if ( isCapturedByIC === true ) {
                event.preventDefault();
                decapture();
              };
            }
            break;

          }

        };



        /**
        * Three.js Helper functions
        */
        function getUVOnCanvas(event) {
          var outVec2;
          
          let pointer = new THREE.Vector2();
          // calculate pointer position in normalized device coordinates
        	// (-1 to +1) for both components
          pointer.x = + ( event.clientX / window.innerWidth  ) * 2 - 1;
        	pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
          // logger.log("pointer:", pointer);


          camera.updateMatrixWorld();
          // logger.log("camera:", camera);
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(pointer, camera);

          // mesh__wall.updateMatrixWorld();
          const arr_intersected = raycaster.intersectObject(mesh__wall, true);
          // logger.log("arr_intersected:", arr_intersected);

          if (arr_intersected.length > 0 && arr_intersected[0].uv) {
            var uv = arr_intersected[0].uv;
            // console.log('arr_intersected[0].uv: ', arr_intersected[0].uv);
            // console.log('uv: ', uv);
           
            arr_intersected[0].object.material.map.transformUv(uv);
          
            outVec2 = uv;
          }

          return outVec2;
        }




        fabricIntegration.fabricCanvas.on('after:render', function () {
          mesh__wall.material.map.needsUpdate = true;
        });


      }






      function loadScript(str__path) {
        const script = document.createElement('script');
        script.type  = 'text/javascript';
        script.src   = str__path;

        const body = document.getElementsByTagName('head')[0];
        body.appendChild(script);
      }

      function setup2D() {
        infiniteCanvas.iC_controls.on();
      }

      function setup3D() {

        const container__2D = document.getElementById("container__for_canvases");
        container__2D.style.display = "none";  /* for 3DRoom to display properly */


        // loadScript("./lib/3D/three.bundle.min.js");          //SHU: not working
        // loadScript("./lib/3D/three-laser-pointer.min.js");   //SHU: not working

        const body = document.getElementsByTagName('body')[0];

        // //add <style>
        // const str__css = '#rendererCanvas {     \
        //   position: absolute;                   \
        //   left: 0;                              \
        //   top:  0;                              \
        //   border: 0px solid green;              \
        //   width:  100%;                         \
        //   height: 100%;                         \
        // }';
        // const el__style = document.createElement('style');
        // el__style.styleSheet.cssText = str__css;
        // body.appendChild(el__style);

        //add <canvas>
        const canvas__renderer = document.createElement("canvas");
        canvas__renderer.id = "rendererCanvas";

        canvas__renderer.style.position = "absolute";
        canvas__renderer.style.left     = "0";
        canvas__renderer.style.top      = "0";
        canvas__renderer.style.border   = "0px solid green";
        canvas__renderer.style.width    = "100%";
        canvas__renderer.style.height   = "100%";

        body.appendChild(canvas__renderer);


        globalsSingleton.functionCallsQueue.add(() => {
          try {
            func_3DRoom();
          } catch(e) {
            logger.log("log3D", "error:", e);
          }
        });
      }

      try {

        const dict_query_var = globalsSingleton.dict_query_var;
        logger.log("log3D", "dict_query_var:", dict_query_var);
        if("worldType" in dict_query_var) {
          const type__world = dict_query_var["worldType"];
          if(type__world == "3D") {
            setup3D();
          } else {
            setup2D();
          }
        } else {
          setup2D();
        }

      } catch(e) {
        logger.log("log3D", "error: ", e);
      }
      


    </script>



    <script>
      //start the sequence
      globalsSingleton.functionCallsQueue.next();
    </script>


</body>

</html>