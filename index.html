<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Canvas</title>

    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;

            /* Prevent document pinch-zoom & touch-hold-to-highlight */
            touch-action: none;

            -webkit-touch-callout: none;
            /* iOS Safari */
            -webkit-user-select: none;
            /* Safari */
            -khtml-user-select: none;
            /* Konqueror HTML */
            -moz-user-select: none;
            /* Old versions of Firefox */
            -ms-user-select: none;
            /* Internet Explorer/Edge */
            user-select: none;
            /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
        }
    </style>

</head>

<body>

    <!-- utils -->
    <script>

        class Utils {

          static arrayByRemovingElement(src_arr, elt) {

            const index = src_arr.indexOf(elt);

            return this.arrayByRemovingElementAtIndex(src_arr, index);
          }

          static arrayByRemovingElementAtIndex(src_arr, index) {

            const arr = [...src_arr]; //create shallow copy of src_arr

            const arr_removed = arr.splice(index, 1);   //starting at index, remove 1 element
            const arr_new     = arr;                    //array is mutated in place

            return arr;
          }

          static randomElementInArray(arr) {
            const elt = arr[Math.floor(Math.random() * arr.length)];

            // "~~" for a closest "int"
            // const elt = arr[~~(arr.length * Math.random())];

            // "|" for a kinda "int div"
            // const elt = arr[arr.length * Math.random() | 0];

            return elt;
          }

          static early_break_reduce(arr, reduce_callback, initial, checkStopFunc) {
            const x = [...arr]                         // create copy of "array" for iterating
                      .reduce((acc, x, i, arr) => {
                         if (checkStopFunc(acc, x, i, arr)) {
                           arr.splice(1);     // eject early by mutating iterated copy
                           return acc;
                         }
                         return reduce_callback(acc, x, i, arr);
                      }, initial);
            return x;
          }


          /**
           * Shuffles array in place.
           * @param {Array} a items An array containing the items.
           */
          static shuffle(a) {
              var j, x, i;
              for (i = a.length - 1; i > 0; i--) {
                  j = Math.floor(Math.random() * (i + 1));
                  x = a[i];
                  a[i] = a[j];
                  a[j] = x;
              }
              return a;
          }


        }


        class Color {
          static randomColor() {
              var r = 255*Math.random()|0,
                  g = 255*Math.random()|0,
                  b = 255*Math.random()|0;
              return 'rgb(' + r + ',' + g + ',' + b + ')';
          }
        }


        class Logger {

          constructor() {
            this.initialize();

            // this.hush(this);
          }

          initialize() {
            this.invest(console);
            this.hush(console);
          }

          invest(obj) {
            this.log   = obj.log;
            this.trace = obj.trace;
          }

          hush(obj) {
            obj.log   = function() {};
            obj.trace = function() {};
          }


        }

        const logger = new Logger();

    </script>
    <!-- <script>
      //debug
      const arr_test = [1,2,3,4,5,6];
      const s = Utils.early_break_reduce(arr_test, (acc,x,i,arr) => {
        logger.log("x", x);
        return acc + x;
      }, 0, (acc, x, i, arr) => {
        return i > 2;
      });
      logger.log("s", s);
    </script> -->



    <!-- <script src='lib/base64.js' type='text/javascript'></script> -->

    <!-- UI -->
    <script src='lib/fabric.min.js'      type='text/javascript'></script>
    <script src='lib/anime.min.js'       type='text/javascript'></script>

      <!-- MathJax -->
    <script>
      //setup
      MathJax = {
        loader: {
          load: ['[tex]/color']
        },
        tex: {
          packages: {'[+]': ['color']},
        },
        startup: {
          ready: () => {
            logger.log('MathJax is loaded, but not yet initialized');
            MathJax.startup.defaultReady();
            logger.log('MathJax is initialized, and the initial typeset is queued');

            const mathJaxContainer_svg = MathJax.tex2svg("{\\color(red) 13}");
            logger.log("mathJaxContainer_svg", mathJaxContainer_svg);
          },
        },
      };

      // MathJax = {
      //   tex: {
      //     autoload: {
      //       color: ['color', 'definecolor', 'textcolor', 'colorbox', 'fcolorbox'],
      //     },
      //   },
      // };
    </script>
    <!-- <script src='lib/mathjax.tex-mml-chtml.js' type='text/javascript'></script> -->
    <script src='lib/mathjax.tex-svg.js' type='text/javascript'></script>
    <script>
      //test
      logger.log("MathJax", MathJax);
      logger.log("MathJax.tex2svg", MathJax.tex2svg);
      // MathJax.tex2svg("{\\color(red) 13}");
    </script>

    <script>
      //integration
      class TexHelper {
        static toSvgEl(tex, color = "red") {
          const mathJaxContainer_svg = MathJax.tex2svg(tex);

          const htmlCollection = mathJaxContainer_svg.children;
          const svgEl = htmlCollection.item(0);
          console.log("svgEl", svgEl);

          svgEl.style.color = color;
          // svgEl.style.color2 = "blue";

          return svgEl;
        }
      }

      class SvgHelper {
        static toDataURL(svgEl) {
          var outDataUrl;

          // const svgSource = svgEl.outerHTML;

          const serializer = new XMLSerializer();
          const svgSource  = serializer.serializeToString(svgEl);

          // svgSource = svgSource.replaceAll('http://', 'https://');
          console.log("svgSource", svgSource);

          const dataUrl   = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svgSource)));

          outDataUrl = dataUrl;

          return outDataUrl;
        }
      }
    </script>
    <!-- <script>
      //discovery
      console.log("MathJax", MathJax);
      // const mathJaxContainer_svg = MathJax.tex2svg('\\frac{1}{x^2-1}', {display: true});
      const mathJaxContainer_svg = MathJax.tex2svg('\\frac{1}{x^2-1}');
      console.log("mathJaxContainer_svg", mathJaxContainer_svg);
    </script> -->

    <!-- <script src='lib/countdown.min.js' type='text/javascript'></script> -->
    <!-- <script>
      //discovery
      var timerId =
        countdown(
          new Date(),
          function(ts) {
            console.log("countdown::ts", ts);
            if(ts.value > 3000) {
              stop();
            }
          },
          countdown.HOURS|countdown.MINUTES|countdown.SECONDS);
      console.log("countdown::timerId", timerId);

      function stop() {
        clearInterval(timerId);
      }
    </script> -->
    <script src='lib/html2canvas.min.js' type='text/javascript'></script>
    <!-- <div id="lolilol" style="width: 100px; height: 100px; background-color:yellow">123456789</div>
    <script>
      //discovery
      html2canvas(document.getElementById("lolilol")).then(function(canvas) {
        // document.body.appendChild(canvas);
        console.log("html2canvas, canvas", canvas);
      });
    </script> -->
    <link rel="stylesheet" href="lib/mathquill/mathquill.css"/>
    <script src='lib/mathquill/jquery-3.5.1.min.js' type='text/javascript'></script>
    <script src='lib/mathquill/mathquill.min.js' type='text/javascript'></script>
    <script>
      const MQ = MathQuill.getInterface(2);
      console.log("MQ", MQ);

      function createMathField() {
        var outMathField;

        const span = document.createElement("span");

        if(span.style == null) {span.style = {};}
        span.style.backgroundColor = "yellow";
        // span.style.width  = "100px";
        // span.style.height = "100px";
        span.style.color = "purple";


        span.style.textAlign     = "center";
        span.style.verticalAlign = "middle";

        const mathField = MQ.MathField(span, {
          handlers: {
            edit: function() {
              var tex = mathField.latex(); // Get entered math in LaTeX format
              console.log("tex", tex);
            }
          }
        });
        console.log("mathField", mathField);

        outMathField = mathField;

        return outMathField;
      }

    </script>


    <!-- <p><span id="answer">x=</span></p>
    <script>
      var answerSpan = document.getElementById('answer');
      var answerMathField = MQ.MathField(answerSpan, {
        handlers: {
          edit: function() {
            var enteredMath = answerMathField.latex(); // Get entered math in LaTeX format
            // checkAnswer(enteredMath);
            console.log("enteredMath", enteredMath);
          }
        }
      });
    </script> -->


    <!-- Maths -->
    <script src='lib/decimal.min.js' type='text/javascript'></script>

    <script src='lib/math.js' type='text/javascript'></script>
    <!-- <script src='lib/algebra-0.2.6.min.js' type='text/javascript'></script> -->
    <!-- <script>

      //discovery
      {
        // const chain = math.chain(1);
        //OR
        const chain = math.chain();
        chain.value = 1;
        console.log("debug::chain, initial", chain);

        const step1 = chain.add(8);
        const r1    = step1.done();
        // const r1 = chain.valueOf();
        console.log("debug::chain, r1", r1);

        const step2 = step1.multiply(100);
        const r2    = step2.done();
        console.log("debug::chain, r2", r2);

        console.log("debug::chain is not mutated in place");     //which is nice and not surprising from a functional programming pov
        console.log("debug::chain.done()", chain.done());
      }

      //chaining on expression
      /*
      { //SHU: THE DREAM
        const math_with_algebra = math.create(math.all);
        math_with_algebra.import(algebra, {wrap: true, silent: true});
        // math_with_algebra.import(algebra, {override: true, wrap: true, silent: true});

        const chain = math_with_algebra.chain();

        // const expr   = new algebra.Expression("x");
        const expr   = new math_with_algebra.Expression("x");
        // const expr = "x";

        console.log("expr", expr);
        chain.value = expr;                                             //SHU TODO: make this possible
        console.log("debug::chain, initial", chain);

        // const step1 = chain.add(8);                                      //SHU: en fait c'est peut-être juste un problème de coercion.
        const step1 = chain.add(new math_with_algebra.Expression(8));    //SHU: Ah non. Dommage.

        const r1    = step1.done();
        // const r1 = chain.valueOf();
        console.log("debug::chain, r1", r1);

        const step2 = chain.multiply(100);
        const r2    = step2.done();
        console.log("debug::chain, r2", r2);
      }
      */

      /*
      { //SHU: THE WORKAROUND
        var expr   = new algebra.Expression("x");
        expr = expr.multiply(2);
        expr = expr.multiply("x");
        expr = expr.multiply(new algebra.Expression("x"));
        expr = expr.add("y");
        expr = expr.add(new algebra.Fraction(1, 3));
        expr = expr.add("y");                                       //SHU: oh, no. There is automatic reducing.
        console.log("expr", expr.toString());

        //Simplification
        //All expression operations accept a simplify argument that will yield an unsimplified expression when set to false.
        //You can then get a simplified expression with Expression.simplify.

        var expr   = new algebra.Expression("x");
        expr = expr.multiply(2,false);
        expr = expr.multiply("x",false);
        expr = expr.multiply(new algebra.Expression("x"),false);
        expr = expr.add("y",false);
        expr = expr.add(new algebra.Fraction(1, 3),false);
        expr = expr.add(new algebra.Expression("y"),false);
        console.log("expr", expr.toString());                       //SHU: unsimplified expression terms order is wrong
        expr = expr.simplify();                                     //SHU TODO: show correct terms order
        console.log("expr", expr.toString());
      }
      */

    </script> -->

    <!-- <script src='lib/math-expressions.js' type='text/javascript'></script> -->
    <!-- <script src='lib/math-expressions_umd.js' type='text/javascript'></script> -->
    <script src='lib/math-expressions.browserified.bundle.js' type='text/javascript'></script>
    <script>
      const MathExpression = Bundle_ME.MathExpression;
    </script>
    <!-- <script>
      //discovery
      const mathExpression1      = MathExpression.fromText("sin^2 (x^3)");
      const tex__mathExpression1 = mathExpression1.tex();
      console.log("MathExpression, tex__mathExpression1", tex__mathExpression1);

      const mathExpression2       = MathExpression.fromTex("5 \\times 3");
      const text__mathExpression2 = mathExpression2.toString();
      console.log("MathExpression, text__mathExpression2", text__mathExpression2);
    </script> -->



    <script src='lib/ngraph.graph.min.js' type='text/javascript'></script>
    <!-- <script>
      //discovery
      const g = createGraph();

      g.addNode('hello');
      g.addNode('world');
      //Now graph g contains two nodes: hello and world. You can also use addLink() method to grow a graph. Calling this method with nodes which are not present in the graph creates them:

      g.addLink('space', 'bar'); // now graph 'g' has two new nodes: 'space' and 'bar'
      //If nodes already present in the graph 'addLink()' makes them connected:

      // Only a link between 'hello' and 'world' is created. No new nodes.
      g.addLink('hello', 'world');

      console.log("g", g);
    </script> -->


    <script src='lib/algebrite.bundle-for-browser.js' type='text/javascript'></script>
    <script>

      //discovery
      const equality_1 = Algebrite.run('x + y + x == y + 2x');
      logger.log("equality_1", equality_1);

      const equality_2 = Algebrite.run('4(x + y) - x == 4y + 3x');
      logger.log("equality_2", equality_2);


      const equality_3 = Algebrite.run('4z(x + y) - zx == 4yz + 3xz');    //SHU: software is dumb and intelligent: a priori, xz != zx ( or maybe it's something else ... )
      logger.log("equality_3", equality_3);

      const equality_4 = Algebrite.run('4z(x + y) - zx == 4zy + 3zx');
      logger.log("equality_4", equality_4);

    </script>

      <!-- custom maths stuff -->
    <script>

      const dict_opConfig = {
        1: {
          minus: {
            arity: 1,
            symbol: "-",
            name: "unaryMinus",
            precedence: 6,
          },
          inverse: {
            arity: 1,
            symbol: "/",
            name: "inverse",
            precedence: "?",
          },
        },
        2: {
          plus: {
            arity: 2,
            symbol: "+",
            // name: "plus",
            name: "add",
            precedence: 9,

            inverse: "minus",
          },
          minus: {
            arity: 2,
            symbol: "-",
            // name: "minus",
            name: "subtract",
            precedence: 9,

            inverse: "plus",
          },
          multiply: {
            arity: 2,
            symbol: "×",

            name: "multiply",
            precedence: 8,

            inverse: "divide",
          },
          divide: {
            arity: 2,
            symbol: "/",
            name: "divide",
            precedence: 8,

            inverse: "multiply",
          },
          // pow: {
          //   op: "^",
          //   name: "pow",
          // },
        },
        n : {
          plus: {
            arity: "n",
            symbol: "+",
            // name: "plus",
            name: "add",
            precedence: 9,

            inverse: "minus",
          },
          multiply: {
            arity: "n",
            symbol: "×",
            name: "multiply",
            precedence: 8,

            inverse: "divide",
          },
        },
      };


      // (...) [...] {...}		            1
      // x(...) x[...] obj.prop :		    2
      // '		                            3
      // !		                            4
      // ^, .^		                        5
      // +, -, ~, not		                6
      // See section below		            7
      // *, /, .*, ./, %, mod		        8
      // +, -		                        9
      // :		                           10
      // to, in		                     11
      // <<, >>, >>>		                 12
      // Err :501		                   13
      // &		                           14
      // ^|		                         15
      // |		                           16
      // and		                         17
      // xor		                         18
      // or		                         19
      // ?, :		                       20
      // =		                           21
      // ,		                           22
      // ;		                           23
      // \n, ;		                       24
      const precedenceDict = {
          "unaryPlus":  6,
          "unaryMinus": 6,

          "multiply": 8,
          "divide":   8,

          "add":      9,
          "subtract": 9,
      };


      class Operator {

        constructor(arity, easyName, symbol, name, inverseName = null) {
          this.arity    = arity;
          this.easyName = easyName;

          this.op       = symbol;
          this.symbol   = symbol;

          this.name     = name;

          this.inverseName  = inverseName;
        }

        static fromConfig(opConfig) {
          const op = new Operator(opConfig.arity, "lolilol", opConfig.symbol, opConfig.name, opConfig.inverse);
          return op;
        }

        static randomInstance(arity) {

          const arr_opConfig = Object.values(dict_opConfig[arity]);
          const opConfig__random = Utils.randomElementInArray(arr_opConfig);

          const op__random = Operator.fromConfig(opConfig__random);
          return op__random;
        }


        inverse() {   //what did you expect ?
          const arity       = this.arity;
          const inverseName = this.inverseName;

          const opConfig__inverse = dict_opConfig[arity][inverseName];

          const op__inverse = Operator.fromConfig(opConfig__inverse);
          return op__inverse;
        }


        static multiply() {
          var outOp;

          const opConfig = dict_opConfig[2]["multiply"];
          outOp = Operator.fromConfig(opConfig);

          return outOp;
        }

        static divide() {
          var outOp;

          const opConfig = dict_opConfig[2]["divide"];
          outOp = Operator.fromConfig(opConfig);

          return outOp;
        }


      }

      class Operation {

        constructor(operator, arr_rest) {

        }



      }





      function random_op(arity) {
        const op = Operator.randomInstance(arity);
        return op;
      }
      // console.log("random_op", random_op(2));

      function random_number(range) {
        const span   = range.max - range.min;
        const number = Math.floor(range.min + Math.random() * span);
        return number;
      }

      const arr_symbols = ["x", "y"];
      // const arr_symbols = ["x", "y", "z", "t", "a", "b"];

      function random_symbol() {
        const symbol = Utils.randomElementInArray(arr_symbols);
        return symbol;
      }

      function arityForArr(arr) {
        var outArity;

        switch(arr.length) {
          // case 0:
          //   outArity = 0;     //everything or nothing
          // break;
          case 1:
            outArity = 1;
          break;
          case 2:
            outArity = 2;
          break;
          default:
            outArity = "n";
            break;
        }

        return outArity;
      }

      //////////////////////

      function random_constantNode(range = {min: 0, max: 100, step: 1}) {
        const number = random_number(range);
        const constantNode = new math.ConstantNode(number);
        return constantNode;
      }

      function random_symbolNode() {
        const symbol = random_symbol();
        const symbolNode = new math.SymbolNode(symbol);
        return symbolNode;
      }

      function random_terminal_mathNode_withType(type) {
        var outMathNode;

        switch(type) {
          case "ConstantNode":
          outMathNode = random_constantNode();
          break;
          case "SymbolNode":
          outMathNode = random_symbolNode();
          break;
          // case "operator":
          // break;
        }

        return outMathNode;
      }

      function random_terminal_mathNode_withType_inArr(arr_type) {
        const type = Utils.randomElementInArray(arr_type);
        const mathNode = random_terminal_mathNode_withType(type);
        return mathNode;
      }

      function random_terminal_mathNode_withType_inArr_and_isEnvelopped(arr_type, isEnvelopped) {

        var mathNode = random_terminal_mathNode_withType_inArr(arr_type);
        if(isEnvelopped) {
          mathNode = new math.ParenthesisNode(mathNode);
        }

        return mathNode;
      }

      function random_operatorNode(/*arity,*/ arr_node) {
        const arity = arityForArr(arr_node);
        const op = random_op(arity);
        const operatorNode = new math.OperatorNode(op.op, op.name, arr_node);
        return operatorNode;
      }

      function random_operatorNodeFactoryFunc_binary(arr_type) {
        var outFunc;

        const arity = 2
        const op    = random_op(arity);

        const node_b = random_terminal_mathNode_withType_inArr(arr_type);

        outFunc = (node_a) => {
          const arr_node = [node_a, node_b];
          const operatorNode = new math.OperatorNode(op.op, op.name, arr_node);
          return operatorNode;
        };

        return outFunc;
      }

      function createMathNodeTransformationFunc_binary(mathOperatorSymbol_in, mathOperatorFuncName_in, node_b_in, isShuffled = false) {
        return (node_a) => {
          var outNode;

          const mathOperatorSymbol      = mathOperatorSymbol_in;
          const mathOperatorFuncName    = mathOperatorFuncName_in;
          const node_b                  = node_b_in;

          function standardOperation(node_in) {
            var outNode;

            // const node_b        = new math.ConstantNode(mathValue);

            var arr_child = [node_in, node_b];
            // logger.log("arr_child, before", arr_child);
            if(isShuffled) {
              switch(mathOperatorFuncName) {
                case "add":
                case "multiply":
                  {
                    const shuffle = arr =>
                      [...arr].reduceRight((res,_,__,s) =>
                        (res.push(s.splice(0|Math.random()*s.length,1)[0]), res),[]);

                    arr_child = shuffle(arr_child);
                    // logger.log("arr_child, after", arr_child);
                  }
                  break;
                default:
                  //do nothing
                  break;
              }
            }

            const node_operator = new math.OperatorNode(mathOperatorSymbol, mathOperatorFuncName, arr_child);

            const node_unsimplified = node_operator;

            if(node_in.autoSimplify) {
              // const node_simplified = math.simplify(node_unsimplified);
              const node_simplified = Simplifier.simplify_top_layer(node_unsimplified);
              outNode = node_simplified;
            } else {
              outNode = node_unsimplified;
            }

            outNode.autoSimplify = node_in.autoSimplify;

            return outNode;
          }

          // logger.log("node_a", node_a);
          if(node_a.isEquation) {
            console.log("node_a", node_a);
            const node_left     = standardOperation(node_a.params[0]);
            const node_right    = standardOperation(node_a.params[1]);
            const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
            node_equation.isEquation = true;

            outNode = node_equation;
          } else {
            outNode = standardOperation(node_a);
          }

          // outNode.autoSimplify = node_a.autoSimplify;

          return outNode;
        };
      };

      function random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op = null) {
        var outFuncWrapper;

        const arr_type__node_b = operatorParams.node_b.types;
        const range__node_b    = operatorParams.node_b.range;

        const isShuffled       = (operatorParams.isShuffled != null) ? operatorParams.isShuffled : false;


        const arity = 2
        var op;
        if(arr_op != null) {
          op = Utils.randomElementInArray(arr_op);
        } else {
          op = random_op(arity);
        }

        var node_b = random_terminal_mathNode_withType_inArr(arr_type__node_b);
        // logger.log("random_operatorNodeFactoryFuncWrapper_binary, node_b", node_b);
        if(node_b.type == "ConstantNode") {

          function randomValue() {
            return math.randomInt(range__node_b.min, range__node_b.max);
          }

          var value = randomValue();
          // logger.log("value:", value);
          if(op.name == "divide") {
            while(value == 0) {
              value = randomValue();
            }
          }


          node_b = new math.ConstantNode(value);

          if(node_b.value < 0) {
            node_b = new math.ParenthesisNode(node_b);
          }

        }

        const func = createMathNodeTransformationFunc_binary(op.op, op.name, node_b, isShuffled);

        const op__inverse   = op.inverse();
        const func__inverse = createMathNodeTransformationFunc_binary(op__inverse.op, op__inverse.name, node_b, isShuffled);

        function createFuncWrapper(op, node_b, func) {

          const simpleName = op.op + " " + node_b.toString();

          const funcWrapper = {
            semantics: {
              operator: op,
              node_b:   node_b.cloneDeep(),
              name:     simpleName,
            },
            func: func,
            inverse: null,  //set later
          };

          return funcWrapper;
        }

        const funcWrapper          = createFuncWrapper(op, node_b, func);
        const funcWrapper__inverse = createFuncWrapper(op__inverse, node_b, func__inverse);
        funcWrapper.inverse = funcWrapper__inverse;

        outFuncWrapper = funcWrapper;

        return outFuncWrapper;
      }


      function random_operatorNode_debug() {
        const arr_nodes = [
          random_symbolNode(),
          random_constantNode(),
        ];
        const operatorNode = random_operatorNode(arr_nodes);
        return operatorNode;
      }
      console.log("random_operatorNode_debug", random_operatorNode_debug());



      function random_operatorNode_binary_withDepth(depth) {
        if(depth < 2) {
          throw new Error("operatorNode is has min depth: 2");
        } else if (depth == 2) {
          const arr_node = [0,1].map(index => random_terminal_mathNode_withType_inArr(["ConstantNode", "SymbolNode"]));
          const operatorNode = random_operatorNode(arr_node);
          return operatorNode;
        } else {
          const arr_node = [0,1].map(index => random_operatorNode_binary_withDepth(depth-1));
          const operatorNode = random_operatorNode(arr_node);
          return operatorNode;
        }
      }

      function random_mathNode_withDepth(depth) {
        var outMathNode;

        if (depth < 1) {
          throw new Error("mathNode is has min depth: 1");
        } else if (depth == 1) {
          const terminalNode = random_terminal_mathNode_withType_inArr(["ConstantNode", "SymbolNode"]);
          outMathNode = terminalNode;
        } else {
          const operatorNode = random_operatorNode_binary_withDepth(depth);
          outMathNode = operatorNode;
        }

        return outMathNode;
      }
      console.log("random_mathNode_withDepth", random_mathNode_withDepth(4));





      //only n symbols

      function getNbSymbolNodes(mathNode) {
        var outInt = 0;

        switch(mathNode.type) {
          case "SymbolNode":
            outInt = 1;
            break;
          case "OperatorNode":
            outInt = operator.params.reduce((acc, x) => acc + getNbSymbolNodes(x), 0);
        }

        return outInt;
      }

      function arr_terminalTypes_for_nbSymbols(nb_symbols) {
        const arr_terminalTypes = ["ConstantNode"];
        if(nb_symbols > 0) {
          arr_terminalTypes.push("SymbolNode");
        }
        return arr_terminalTypes;
      }

      function random_reduceObj__operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols) {   //SHU: it's nb_symbols_remaining
        var outObj;
        var outNode;
        var outNbSymbols;

        const depth_min = 2;

        if(depth < depth_min) {
          throw new Error("operatorNode is has min depth: 2");
        };

        var nb_symbols_curr = nb_symbols;
        if (depth == 2) {

          const arity = 2;
          const arr_nodeIndex = [...new Array(arity).keys()];

          const reducedObj2 = arr_nodeIndex.reduce((acc2, nodeIndex) => {
            const arr_terminalTypes = arr_terminalTypes_for_nbSymbols(acc2.nb_symbols);
            const mathNode = random_terminal_mathNode_withType_inArr(arr_terminalTypes);

            if(mathNode.type == "SymbolNode") {
              acc2.nb_symbols -= 1;
            }

            acc2.arr_mathNode.push(mathNode);

            return acc2;
          }, {
            nb_symbols: nb_symbols_curr,
            arr_mathNode: [],
          });

          outNbSymbols       = reducedObj2.nb_symbols;

          const operatorNode = random_operatorNode(reducedObj2.arr_mathNode);
          outNode            = operatorNode;
        } else {

          const arity = 2;
          const arr_nodeIndex = [...new Array(arity).keys()];

          const reducedObj2 = arr_nodeIndex.reduce((acc2, nodeIndex) => {
            const reducedObj_ = random_reduceObj__operatorNode_binary_withDepth_and_nbSymbols(depth-1, acc2.nb_symbols);

            acc2.nb_symbols = reducedObj_.nb_symbols;

            const mathNode = reducedObj_.mathNode;
            acc2.arr_mathNode.push(mathNode);

            return acc2;
          }, {
            nb_symbols: nb_symbols_curr,
            arr_mathNode: [],
          });

          outNbSymbols       = reducedObj2.nb_symbols;

          const operatorNode = random_operatorNode(reducedObj2.arr_mathNode);
          outNode            = operatorNode;
        }

        outObj = {
          nb_symbols: outNbSymbols,
          mathNode:   outNode,
        };
        console.log("depth", depth, "outNbSymbols", outNbSymbols);

        return outObj;
      }

      function random_operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols = 1) {
        const reduceObj = random_reduceObj__operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols);
        return reduceObj.mathNode;
      }

      function random_mathNode_withDepth_and_nbSymbols(depth, nb_symbols = 1) {
        var outMathNode;

        if (depth < 1) {
          throw new Error("mathNode is has min depth: 1");
        } else if (depth == 1) {
          const terminalNode = random_terminal_mathNode_withType_inArr(["ConstantNode", "SymbolNode"]);
          outMathNode = terminalNode;
        } else {
          const operatorNode = random_operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols);
          outMathNode = operatorNode;
        }

        return outMathNode;
      }

      function random_onion_mathNode(depth, isWithExplicitationParentheses = true, isWithRandomParentheses = false) {
        var outMathNode;

        if (depth < 1) {
          throw new Error("mathNode is has min depth: 1");
        } else if (depth == 1) {

          const random_boolean = Math.random() < 0.5;
          const isEnvelopped = random_boolean;

          const terminalNode = random_terminal_mathNode_withType_inArr_and_isEnvelopped(["SymbolNode"], isEnvelopped);

          outMathNode = terminalNode;
        } else {
          const innerOnionNode = random_onion_mathNode(depth-1, isWithExplicitationParentheses);

          const layerTerminalNode = random_terminal_mathNode_withType_inArr(["ConstantNode"]);

          const layerNode = random_operatorNode([innerOnionNode, layerTerminalNode]);
          console.log("layerNode", layerNode);

          outMathNode = layerNode;

          if(isWithExplicitationParentheses) {
            if(innerOnionNode.type == "OperatorNode") {
              console.log("innerOnionNode", innerOnionNode);

              const opFuncName__innerOnionNode = innerOnionNode.fn;
              const opFuncName__layerNode      = layerNode.fn;

              const precedence__innerOnionNode = precedenceDict[opFuncName__innerOnionNode];
              const precedence__layerNode      = precedenceDict[opFuncName__layerNode];

              const isSamePrecedence = (precedence__innerOnionNode == precedence__layerNode);

              if(isSamePrecedence) {
                var enveloppedInnerOnionNode;
                if(innerOnionNode.type == "ParenthesisNode") {    //already envelopped
                  enveloppedInnerOnionNode = innerOnionNode;
                } else {
                  enveloppedInnerOnionNode = new math.ParenthesisNode(innerOnionNode);
                }

                const layerNode_explicit = new math.OperatorNode(layerNode.op, layerNode.fn, [enveloppedInnerOnionNode, layerTerminalNode]);

                outMathNode = layerNode_explicit;
              }

            }

          }

        }

        return outMathNode;
      }

      // //debug
      // {
      //   const debugNode = random_mathNode_withDepth_and_nbSymbols(4, 2);
      //   console.log("debugNode(4,2)", debugNode);
      //   console.log("getDepth(debugNode)", getDepth(debugNode));
      // }





      function random_operatorNode_consumePool(pool) {

      }





      /*UTILS*/

      function getDepth(mathNode) {
        var outInt;

        switch(mathNode.type) {
          case "OperatorNode":
            {
              const arr_child_node       = mathNode.args;
              const arr_child_node_depth = arr_child_node.map(node => getDepth(node));
              const max_child_depth = Math.max(...arr_child_node_depth);
              outInt = 1 + max_child_depth;
            }
            break;
          default:
            outInt = 1;
            break;
        }

        console.log("outInt", outInt);
        return outInt;
      }

      function getArr_all_leaves__node(mathNode) {
        var outArray;

        switch(mathNode.type) {
          case "OperatorNode":
            {
              const depth = getDepth(mathNode);
              if(depth == 2) {
                const arr_child = mathNode.args;
                outArray = arr_child;
              } else {
                outArray = mathNode.args.reduce((acc, child) => {
                  const arr_grandChild = child.args;

                  var arr_grandChild_sorted_by_decreasing_depth = arr_grandChild.slice();
                  arr_grandChild_sorted_by_decreasing_depth.sort(function(a, b) {
                    const depth_a = getDepth(a);
                    const depth_b = getDepth(b);

                    if (depth_a > depth_b) {
                      return 1;
                    }
                    if (depth_a < depth_b) {
                      return -1;
                    }
                    return 0;
                  });

                  arr_grandChild_sorted_by_decreasing_depth.forEach((grandChild, i) => {
                    const arr_sub = getArr_all_leaves__node(grandChild);
                    console.log("arr_sub", arr_sub);
                    acc.push(...arr_sub);
                  });

                  return acc;

                }, []);
              }
            }
            break;
          default:
            outArray = [mathNode];
            break;
        }

        return outArray;
      }

      function getArr_all_leaves__treeObj(mathNode, parentPath = []) {
        var outArray;

        switch(mathNode.type) {
          case "OperatorNode":
            {
              const depth = getDepth(mathNode);
              if(depth == 2) {
                const arr_child = mathNode.args;
                outArray = arr_child.map((child, childIndex) => {
                  const treeObj = {
                    node: child,
                    path: parentPath.concat([childIndex]),
                  };
                  return treeObj;
                });
              } else {
                outArray = mathNode.args.reduce((acc, child, childIndex) => {
                  const arr_grandChild = child.args;

                  var arr_grandChild_sorted_by_decreasing_depth = arr_grandChild.slice();
                  arr_grandChild_sorted_by_decreasing_depth.sort(function(a, b) {
                    const depth_a = getDepth(a);
                    const depth_b = getDepth(b);

                    if (depth_a > depth_b) {
                      return 1;
                    }
                    if (depth_a < depth_b) {
                      return -1;
                    }
                    return 0;
                  });

                  arr_grandChild_sorted_by_decreasing_depth.forEach((grandChild, grandChildIndex) => {
                    const path = parentPath.concat([childIndex, grandChildIndex]);
                    const arr_sub = getArr_all_leaves__treeObj(grandChild, path);
                    console.log("arr_sub", arr_sub);
                    acc.push(...arr_sub);
                  });

                  return acc;

                }, []);
              }
            }
            break;
          default:
            const treeObj = {
              node: mathNode,
              path: parentPath/*.concat([0])*/,
            };
            outArray = [treeObj];
            break;
        }

        return outArray;
      }

      function getArr_all_nodes_at_depth(mathNode, depth) {
        var outArray;

        if(depth < 1) {
          throw new Error("depth must be > 1");
        } else if(depth == 1) {
          outArray = [mathNode];
        } else {
          const arr_child = mathNode.args;

          outArray = arr_child.reduce((acc, child) => {
            const arr_nodes__one_deeper = getArr_all_nodes_at_depth(child, depth - 1);

            acc.push(...arr_nodes__one_deeper);

            return acc;
          }, []);
        }

        return outArray;
      }

      function getArr_deep_first__treeObj(mathNode, parentPath = []) {
        var outArray;

        const depth = getDepth(mathNode);
        const arr_depth__increasing = [...new Array(depth).keys()].map(i => i + 1);
        const arr_depth__decreasing = arr_depth__increasing.slice().reverse();

        outArray = arr_depth__decreasing.reduce((acc, depth) => {

          const arr_all_treeObj_at_depth = getArr_all_treeObj_at_depth(mathNode, depth, parentPath);
          acc.push(...arr_all_treeObj_at_depth);

          return acc;
        }, []);

        return outArray;
      }

      function getArr_all_treeObj_at_depth(mathNode, depth, parentPath = []) {
        var outArray;

        if(depth < 1) {
          throw new Error("depth must be > 1");
        } else if(depth == 1) {
          const treeObj = {
            node: mathNode,
            path: parentPath,
          };
          outArray = [treeObj];
        } else {
          var arr_child = mathNode.args;

          if(arr_child == null) {
            arr_child = [];
          }

          outArray = arr_child.reduce((acc, child, childIndex) => {
            const child_path = parentPath.concat(childIndex);
            const arr_treeObj__one_deeper = getArr_all_treeObj_at_depth(child, depth - 1, child_path);

            acc.push(...arr_treeObj__one_deeper);

            return acc;
          }, []);

        }

        return outArray;
      }


      function getArr_deep_first__treeObj(mathNode, parentPath = []) {
        var outArray;

        const depth = getDepth(mathNode);
        const arr_depth__increasing = [...new Array(depth).keys()].map(i => i + 1);
        const arr_depth__decreasing = arr_depth__increasing.slice().reverse();

        outArray = arr_depth__decreasing.reduce((acc, depth) => {

          const arr_all_treeObj_at_depth = getArr_all_treeObj_at_depth(mathNode, depth);
          acc.push(...arr_all_treeObj_at_depth);

          return acc;
        }, []);

        return outArray;
      }





      function operatorNodeBySettingNodeAtPath(operatorNode_in, node_l, path) {
        var outOperatorNode;

        const operatorNode_cloned = operatorNode_in.clone();
        // const operatorNode_cloned = operatorNode_in.cloneDeep();

        //get target inner parentNode
        const path__all_but_last = path.slice(0, -1);
        const targetParentNode = path__all_but_last.reduce((acc, x) => {
          return acc.args[x];
        }, operatorNode_cloned);

        //mutate target inner parentNode
        const path__last = path[path.length -1];
        targetParentNode.args[path__last] = node_l;

        outOperatorNode = operatorNode_cloned;

        return outOperatorNode;
      }

      // //debug
      // {
      //   const debugNode = random_mathNode_withDepth_and_nbSymbols(4, 2);
      //   console.log("debugNode(4,2)", debugNode);
      //   console.log("getDepth(debugNode)", getDepth(debugNode));
      //   console.log("getArr_all_leaves__node(debugNode)", getArr_all_leaves__node(debugNode));
      // }

    </script>
    <script>
      /*
      class InverseNode extends math.Node {   //ClassicInverseNode
        constructor(node_in) {

        }
      }
      math.InverseNode = InverseNode;                 //SHU: pas obligé mais pourquoi pas
      */

      class Inverser {
        static inverse(mathNode) {
          var outMathNode;

          switch(mathNode.type) {
            case "ConstantNode":
            case "SymbolNode":
            {
              const mathNode_ONE = new math.ConstantNode(1);
              const mathNode_clone = mathNode.cloneDeep();
              outMathNode = new math.OperatorNode("/", "divide", [mathNode_ONE, mathNode_clone]);
            }
            break;

            case "OperatorNode":
            {
              const operatorNode = mathNode;
              switch(operatorNode.fn) {
                case "divide":
                {
                  const mathNode_firstArg = operatorNode.args[0];
                  if(mathNode_firstArg.type == "ConstantNode" && mathNode_firstArg.value == 1) {
                    //'simplification'
                    const mathNode_secondArg_clone = operatorNode.args[1].cloneDeep();
                    outMathNode = mathNode_secondArg_clone;
                  } else {
                    const mathNode_clone = mathNode.cloneDeep();
                    mathNode_clone.args = mathNode_clone.args.slice().reverse();
                    outMathNode = mathNode_clone;
                  }
                }
                break;
                default:
                {
                  const mathNode_ONE = new math.ConstantNode(1);
                  const mathNode_clone = mathNode.cloneDeep();
                  outMathNode = new math.OperatorNode("/", "divide", [mathNode_ONE, mathNode_clone]);
                }
                break;
              }
            }
            break;
            case "ParenthesisNode":
              throw new Error("unsupported type: " + mathNode.type);
              break;


            //maybe one day
            case "BlockNode":
            case "ObjectNode":
            case "ConditionalNode":
            case "FunctionNode":
              throw new Error("unsupported type: " + mathNode.type);
              break;

            case "ArrayNode":
            case "AssignmentNode":
            case "FunctionAssignmentNode":
            case "RelationalNode":
              throw new Error("unsupported type: " + mathNode.type);
              break;

            default:
              throw new Error("unsupported type: " + mathNode.type);
              break;
          }

          return outMathNode;
        }
      }

      /*
      class GeneralInverseOperatorDuo extends math.OperatorNode {
        constructor(, )
      }
      math.GeneralInverseNode = GeneralInverseNode;


      class GeneralInverseNode extends math.OperatorNode {
        constructor(operatorDuo, node) {

        }
      }
      math.GeneralInverseNode = GeneralInverseNode;
      */


      class Simplifier {

        constructor() {

        }

        static simplify_top_layer(node_in) {
          var outNode;

          if(node_in.type == "OperatorNode") {

            const depth = getDepth(node_in);

            if(depth > 2) {
              console.log("___st A");

              //'outermost first' simplify

              const operator__layerN          = node_in;
              const arr_child__layerN         = operator__layerN.args;
              var terminal__layerN          = arr_child__layerN.filter(child => Simplifier.isTerminalType(child)).find(e => true);
              terminal__layerN = Simplifier.getTerminalMathNode(terminal__layerN);

              const operator__layerN_minus_1      = arr_child__layerN.filter(child => (child.type == "OperatorNode") ).find(e => true);
              const arr_child__layerN_minus_1     = operator__layerN_minus_1.args;
              // const terminal__layerN_minus_1      = arr_child__layerN_minus_1.filter(child => isTerminalType(child)).find(e => true);
              var arr_terminal__layerN_minus_1  = arr_child__layerN_minus_1.filter(child => Simplifier.isTerminalType(child));
              arr_terminal__layerN_minus_1 = arr_terminal__layerN_minus_1.map(mathNode => Simplifier.getTerminalMathNode(mathNode));

              const sameTerminal = arr_terminal__layerN_minus_1.find(term__layerN_minus_1 => Simplifier.isSameTerminal(terminal__layerN, term__layerN_minus_1));
              if(!sameTerminal) {
                return node_in;
              }

              const isInverseOperators_ = Simplifier.isInverseOperators(operator__layerN_minus_1, operator__layerN);
              console.log("isInverseOperators_", isInverseOperators_);
              if(!isInverseOperators_) {
                return node_in;
              }

              const node__layerN_minus_2      = arr_child__layerN_minus_1.filter(child => child != sameTerminal).find(e => true);

              //remove parentheses if any
              // if(node__layerN_minus_2.type == "ParenthesisNode") {
              //   const contentNode = node__layerN_minus_2.content;
              //   outNode = contentNode;
              // } else {
              //   outNode = node__layerN_minus_2;
              // }

              outNode = node__layerN_minus_2;

            } else {
              console.log("___st B");

              //simple simplify

              const node_unsimplified = node_in;

              const node_simplified = math.simplify(node_unsimplified);
              node_simplified.isSimplified = true;

              outNode = node_simplified;

            }

          } else {
            console.log("___st C");
            logger.log("node_in", node_in);

            //simple simplify

            const node_unsimplified = node_in;

            const node_simplified = math.simplify(node_unsimplified);   //SHU: boom
            node_simplified.isSimplified = true;

            outNode = node_simplified;

          }

          outNode.autoSimplify = node_in.autoSimplify;

          return outNode;
        }

        static isOne(mathNode) {
          return Simplifier.isOne_strict(mathNode) || Simplifier.isOne_wide(mathNode);
        }

        static isOne_strict(mathNode) {
          return (mathNode.type == "ConstantNode") && (mathNode.value == 1);
        }

        static isOne_wide(mathNode) {
          // return (mathNode.type == "ConstantNode") && (mathNode.value == 1);
          return false;
        }

        static simplify_singleOperatorize_topPriorityShell(mathNode, operatorFn = "multiply") {
          var outMathNode;

          switch(mathNode.type) {
            case "OperatorNode":
            {
              const operatorNode = mathNode;

              if(operatorFn == "multiply") {
                switch(operatorNode.fn) {
                  case "multiply":
                  {
                    //1. transform children
                    const arr_child = operatorNode.args.map(mathNode_child => Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_child, operatorFn));

                    //2. merge (~aggregate, ~flatten)
                    const arr_child2 = arr_child.reduce((acc, x) => {

                      switch(x.type) {
                        case "OperatorNode":
                        {
                          switch(operatorNode.fn) {
                            case "multiply":
                            {
                              acc.push(...x.args);
                            }
                            break;
                            default:
                              acc.push(x);
                              break;
                          }
                        }
                        break;
                        default:
                          acc.push(x);
                        break;
                      }

                      return acc;
                    }, []);

                    //3. filter out ONEs
                    const arr_child3 = arr_child2.filter(mathNode => {
                      const isOne = Simplifier.isOne(mathNode);
                      return !isOne;
                    });

                    if(arr_child3.length > 1) {
                      outMathNode = new math.OperatorNode("x", "multiply", arr_child3);
                    } else {
                      outMathNode = arr_child3.find(e => true);
                    }

                  }
                  break;
                  case "divide":
                  {
                    // const mathNode_firstArg = operatorNode.args[0];
                    // if(mathNode_firstArg.type == "ConstantNode" && mathNode_firstArg.value == 1) {
                    //   //'simplification'
                    //   const mathNode_secondArg_clone = operatorNode.args[1].cloneDeep();
                    //   outMathNode = mathNode_secondArg_clone;
                    // } else {
                    //   const mathNode_clone = mathNode.cloneDeep();
                    //   mathNode_clone.args = mathNode_clone.args.slice().reverse();
                    //   outMathNode = mathNode_clone;
                    // }


                    //1. transform children
                      //transform numerator   (left side)
                    const mathNode_numerator               = operatorNode.args[0];
                    const mathNode_numerator_transformed   = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_numerator, operatorFn);
                      //transform denominator (right side)
                    const mathNode_denominator             = operatorNode.args[1];
                    const mathNode_denominator_transformed = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_denominator, operatorFn);

                    //2.transform into multiplication
                    var arr_mathNode_denominator;
                    switch(mathNode_denominator_transformed.type) {
                      case "OperatorNode":
                      {
                        const operatorNode = mathNode_denominator_transformed;
                        switch(operatorNode.fn) {
                          case "multiply":
                          {
                            arr_mathNode_denominator = operatorNode.args;
                          }
                          break;
                          default:
                          {
                            arr_mathNode_denominator = [mathNode_denominator_transformed];
                          }
                          break;
                        }
                      }
                      break;
                      default:
                      {
                        arr_mathNode_denominator = [mathNode_denominator_transformed];
                      }
                      break;
                    }

                    const arr_factor = [mathNode_numerator_transformed, ...arr_mathNode_denominator.map(Inverser.inverse)];

                    outMathNode = new math.OperatorNode("x", "multiply", arr_factor);

                  }
                  break;
                  default:
                    outMathNode = mathNode;
                    break;
                }
              } else {
                throw new Error("unsupported operatorFn: " + operatorFn);
              }

            }
            break;
            case "ParenthesisNode":
            {
              const parenthesisNode = mathNode;
              //check content
              const mathNode__content = parenthesisNode.content;
              outMathNode = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode__content, operatorFn);
            }
            break;
            default:
              outMathNode = mathNode;
              break;
          }

          return outMathNode;
        }

        static simplify_top_priorityShell(node_in) {
          var outNode;

          const mathNode = node_in;

          switch(node_in.type) {
            case "OperatorNode":
            {
              // const depth = getDepth(node_in);
              // if(depth > 2) {

                //1. singleOperatorize
                const node_singleOperatorized = Simplifier.simplify_singleOperatorize_topPriorityShell(node_in);
                logger.log("node_singleOperatorized", node_singleOperatorized);

                //2. look for inverse matches : plus and minus
                const arr_mathNode_factor_all = node_singleOperatorized.args;
                logger.log("arr_mathNode_factor_all", arr_mathNode_factor_all);

                const obj_factors = arr_mathNode_factor_all.reduce((acc, mathNode_factor) => {

                  var value;
                  var multiplicity;

                  const isInverse = (mathNode_factor.type == "OperatorNode") && (mathNode_factor.fn == "divide");
                  if(isInverse) {
                    const mathNode_inverse = mathNode_factor;
                    const mathNode_denominator = mathNode_inverse.args[1];
                    const mathNode_averse = mathNode_denominator;
                    value = mathNode_averse.value;
                    multiplicity = -1;
                  } else {
                    const mathNode_averse = mathNode_factor;
                    value = mathNode_averse.value;
                    multiplicity = +1;
                  }

                  if(acc[value] == null) {
                    acc[value] = 0;
                  }

                  acc[value] += multiplicity;

                  return acc;
                }, {});
                logger.log("obj_factors", obj_factors);   //SHU: acc[value] stringifies value

                const arr_mathNode_factor_simplified = Object.entries(obj_factors)
                                              .filter(([valueStr, multiplicity]) => multiplicity != 0)
                                              .map(([valueStr, multiplicity]) => {
                                                var outArr;

                                                const value = Number(valueStr);

                                                if(multiplicity > 0) {
                                                  outArr = [...Array(multiplicity).keys()].map(index => {
                                                    const mathNode_averse = new math.ConstantNode(value);
                                                    return mathNode_averse;
                                                  });
                                                } else {
                                                  outArr = [...Array(multiplicity).keys()].map(index => {
                                                    const mathNode_averse = new math.ConstantNode(value);
                                                    const mathNode_inverse = Inverser.inverse(mathNode_averse);
                                                    return mathNode_inverse;
                                                  });
                                                }

                                                return outArr;
                                              })
                                              .flat();

                logger.log("arr_mathNode_factor_simplified", arr_mathNode_factor_simplified);


                const nb_factors = arr_mathNode_factor_simplified.length;
                if(nb_factors == 0) {
                  outNode = new math.ConstantNode(1);
                } else if(nb_factors == 1) {
                  const mathNode_a = arr_mathNode_factor_simplified.find(e => true);
                  outNode = mathNode_a;
                } else {
                  outNode = new math.OperatorNode("x", "multiply", arr_mathNode_factor_simplified);
                }

              // } else {
              //   // throw new Error("depth <= 2");
              //   outNode = node_in;
              // }
            }
            break;
            case "ParenthesisNode":
            {
              const parenthesisNode = mathNode;
              const contentNode = parenthesisNode.content;
              outNode = simplify_top_priority_shell(contentNode);
            }
            break;
            default:
              outNode = mathNode;
              break;
          }

          outNode.autoSimplify = node_in.autoSimplify;

          return outNode;
        }

        static simplify_full() {

        }

        static isTerminalType(mathNode) {
          var outBool;

          const type = mathNode.type;

          switch(type) {
            case "ConstantNode":
            case "SymbolNode":
              outBool = true;
              break;
            case "ParenthesisNode":
              {
                //check content
                const mathNode__content = mathNode.content;
                outBool = isTerminalType(mathNode__content);
              }
              break;
            default:
              outBool = false;
              break;
          }

          return outBool;
        }

        static getTerminalMathNode(mathNode) {
          var outMathNode;

          const type = mathNode.type;

          switch(type) {
            case "ConstantNode":
            case "SymbolNode":
              outMathNode = mathNode;
              break;
            case "ParenthesisNode":
              {
                //check content
                const mathNode__content = mathNode.content;
                outMathNode = getTerminalMathNode(mathNode__content);
              }
              break;
            default:
              // outMathNode = null;
              throw new Error("no terminal node to fetch");
              break;
          }

          return outMathNode;
        }

        static isSameTerminal(termNode1, termNode2) {
          var outBool;

          function isSameTerminalType(termNode1, termNode2) {
            return (termNode1.type == termNode2.type);
          }

          const isSameTerminalType_ = isSameTerminalType(termNode1, termNode2);
          console.log("isSameTerminalType_", isSameTerminalType_);

          if(!isSameTerminalType_) {
            return false;                 //j'aime pas trop ça mais bon...
          }

          function isSameTerminalContent(termNode1, termNode2) {
            console.log("isSameTerminal", termNode1, termNode2);
            var outBool;

            switch(termNode1.type) {
              case "SymbolNode":
                outBool = (termNode1.name == termNode2.name);
              break;
              case "ConstantNode":
                outBool = (termNode1.value == termNode2.value);
              break;
              default:
                throw new Error("unsupported type", termNode1.type);
                break;
            }

            return outBool;
          }

          outBool = isSameTerminalContent(termNode1, termNode2);

          return outBool;
        }

        static isInverseOperators(opNode1, opNode2) {
          console.log("isInverseOperators", opNode1, opNode2);
          var outBool;

          const set_opFunc = new Set([opNode1.fn, opNode2.fn]);
          console.log("set_opFunc", set_opFunc);

          /*Set utils*/
          function eqSet(as, bs) {
              return as.size === bs.size && all(isIn(bs), as);
          }

          function all(pred, as) {
              for (var a of as) if (!pred(a)) return false;
              return true;
          }

          function isIn(as) {
              return function (a) {
                  return as.has(a);
              };
          }
          /**/



          const arr_set_inverse = [
            new Set(["multiply", "divide"]),
            new Set(["add", "subtract"]),
          ];

          outBool = arr_set_inverse.reduce((acc, x) => {
            if(eqSet(set_opFunc, x)) {
              acc = true;
            }
            return acc;
          }, false);

          return outBool;
        }

      }





    </script>
    <script>
      class Rewriter {

        constructor() {

        }

        static decomposition_product_primes(mathNode) {
          var outNode;

          switch(mathNode.type) {
            case "ConstantNode":
              const value = mathNode.value;
              const arr_values = MathUtils.primeFactorization(value);

              // const joinreduce = function(joinFunc, )
              const value_first  = arr_values[0];
              const arr_butfirst = arr_values.slice(1);
              const mathNode_initial = new math.ConstantNode(value_first);
              outNode = arr_butfirst.reduce((acc, x) => {
                const mathNode_arg2 = new math.ConstantNode(x);
                return new math.OperatorNode("×lol×", "multiply", [acc, mathNode_arg2]);
              }, mathNode_initial);

              break;
            case "OperatorNode":
              const operatorNode = mathNode;
              logger.log("operatorNode", operatorNode);
              // switch(operatorNode.op) {
              //   case "/":
              //   break;
              // }
              outNode = new math.OperatorNode(operatorNode.op, operatorNode.fn, operatorNode.args.map(Rewriter.decomposition_product_primes));
              break;
            default:
              throw new Error("unsupported type: " + mathNode.type);
              break;
          }

          return outNode;
        }


      }
    </script>



    <script>
      class Splitter {

        constructor() {

        }

        static split_top_layer(mathNode) {
          var outArr;

          switch(mathNode.type) {
            case "OperatorNode":
              {
                const arr_args = mathNode.args;

                // const operatorNode__nude = mathNode.clone();
                // operatorNode__nude.args = [];
                //
                // outArr = [...arr_args, operatorNode__nude];

                const symbolNode__operator = new math.SymbolNode(mathNode.op);
                outArr = [symbolNode__operator, ...arr_args];
              }
              break;
            case "ParenthesisNode":
              {
                const symbolNode__operator = new math.SymbolNode("()");
                outArr = [symbolNode__operator, mathNode.content];

                // const symbolNode__operatorOpen  = new math.SymbolNode("(");
                // const symbolNode__operatorClose = new math.SymbolNode(")");
                // outArr = [symbolNode__operatorOpen, mathNode.content, symbolNode__operatorClose];
              }
              break;
            default:
              outArr = [mathNode];
              break;
          }

          return outArr;
        }

        static split_full(mathNode) {
          var outArr;

          const arr_components = Splitter.split_top_layer(mathNode);
          if(arr_components.length > 1) {
            outArr = arr_components.reduce((acc, x) => {
              const arr_mathNode = Splitter.split_full(x);
              acc.push(...arr_mathNode);
              return acc;
            }, []);
          } else {
            outArr = arr_components;
          }

          return outArr;
        }

        static geometry__fireworks(center, nb_sparks) {
          var outGeometryObj;


          return outGeometryObj;
        }

      }
    </script>
    <script>
      class Joiner {
        constructor() {

        }

        /**
        *   create a mathNode using all mathNodes in arr_mathNode
        */
        static random_join(arr_mathNode) {
          var outMathNode;

          const nb_max_try = 1000;

          var found = false;
          var nb_try = 0;
          //ugly brute            //SHU: sometimes, one can be proud of one's hideousness
          while(!found && nb_try < nb_max_try) {
            try {
              const join_workz = Joiner.random_join_workz(arr_mathNode, true);
              outMathNode = join_workz.output;
              found = true;
            }
            catch(e) {
              logger.log(e);
              found = false;
            }
            nb_try += 1;
          }

          if(!found) {
            outMathNode = new math.SymbolNode("error");
          }

          // logger.log("outMathNode", outMathNode);

          return outMathNode;
        }

        // static random_join_workz(arr_mathNode, isExhaustive = false) {
        //   logger.log("random_join_workz", arr_mathNode);
        //   var outWorkz;
        //
        //   outWorkz = {
        //     output:   null,
        //     arr_rest: [],
        //   };
        //
        //   var isTerminal;
        //   if(isExhaustive) {
        //     const isOneNodeArray = (arr_mathNode.length == 1);
        //     isTerminal = isOneNodeArray;
        //   } else {
        //     //randomly terminal
        //     const random_boolean = Math.random() < 0.5;
        //     isTerminal = random_boolean;
        //   }
        //
        //
        //   if(isTerminal) {
        //     //get a terminal node
        //     const arr_terminalNode     = arr_mathNode.filter(mathNode => {
        //       const isConstantNode       = (mathNode.type == "ConstantNode");
        //       const isTerminalSymbolNode = (mathNode.type == "SymbolNode") && (Joiner.filter_operatorSymbols([mathNode]).length == 0);
        //       return isConstantNode || isTerminalSymbolNode;
        //     });
        //     Utils.shuffle(arr_terminalNode);
        //
        //     const terminalNode = arr_terminalNode.find(e => true);
        //
        //     outWorkz.output   = terminalNode;
        //     outWorkz.arr_rest = arr_mathNode.filter(mathNode => mathNode != terminalNode);
        //
        //   } else {
        //     //1. get an operator
        //     const arr_symbolNode       = Joiner.filter_operatorSymbols(arr_mathNode);
        //     Utils.shuffle(arr_symbolNode);
        //
        //     const symbolNode__operator = arr_symbolNode.find(e => true);
        //     logger.log("symbolNode__operator", symbolNode__operator);
        //
        //     const arr_mathNode_rest    = arr_mathNode.filter(mathNode => mathNode != symbolNode__operator);
        //
        //     //2. get operands
        //     const nb_operands = 2;
        //     const obj_operands = [...new Array(nb_operands).keys()].reduce((acc, x, index) => {
        //       const arr_component__before = acc.arr_component;
        //
        //       const isExhaustive = (index == (nb_operands - 1));
        //       const join_workz = Joiner.random_join_workz(arr_component__before, isExhaustive);
        //
        //       acc.arr_component = join_workz.arr_rest;
        //       const mathNode__operand = join_workz.output;
        //       acc.arr_out.push(mathNode__operand);
        //
        //       return acc;
        //     }, {
        //       arr_component: arr_mathNode_rest,
        //       arr_out: [],
        //     });
        //
        //     const operatorNode = Joiner.operatorNodeForOperatorSymbolNode(symbolNode__operator);
        //     operatorNode.args = obj_operands.arr_out;
        //     logger.log("operatorNode")
        //
        //     outWorkz.output   = operatorNode;
        //     outWorkz.arr_rest = obj_operands.arr_component;
        //   }
        //
        //   return outWorkz;
        // }

        static random_join_workz(arr_mathNode, isExhaustive = false) {
          logger.log("random_join_workz", arr_mathNode);
          var outWorkz;

          outWorkz = {
            output:   null,
            arr_rest: [],
          };

          var isTerminal;
          if(isExhaustive) {
            const isOneNodeArray = (arr_mathNode.length == 1);
            isTerminal = isOneNodeArray;
          } else {
            //randomly terminal
            const random_boolean = Math.random() < 0.5;
            isTerminal = random_boolean;
          }


          if(isTerminal) {
            //get a terminal node
            const arr_terminalNode     = arr_mathNode.filter(mathNode => {
              const isConstantNode       = (mathNode.type == "ConstantNode");
              const isTerminalSymbolNode = (mathNode.type == "SymbolNode") && (Joiner.filter_operatorSymbols([mathNode]).length == 0);
              return isConstantNode || isTerminalSymbolNode;
            });
            Utils.shuffle(arr_terminalNode);

            const terminalNode = arr_terminalNode.find(e => true);

            outWorkz.output   = terminalNode;
            outWorkz.arr_rest = arr_mathNode.filter(mathNode => mathNode != terminalNode);

          } else {
            //1. get an operator
            const arr_symbolNode       = Joiner.filter_operatorSymbols(arr_mathNode);
            Utils.shuffle(arr_symbolNode);

            const symbolNode__operator = arr_symbolNode.find(e => true);
            logger.log("symbolNode__operator", symbolNode__operator);

            const arr_mathNode_rest    = arr_mathNode.filter(mathNode => mathNode != symbolNode__operator);

            const specializedNode = Joiner.specializedNodeForSymbolNode(symbolNode__operator);

            //2. get operands
            const nb_operands = Joiner.arityForSymbolNode(symbolNode__operator);
            const obj_operands = [...new Array(nb_operands).keys()].reduce((acc, x, index) => {
              const arr_component__before = acc.arr_component;

              const isExhaustive = (index == (nb_operands - 1));
              const join_workz = Joiner.random_join_workz(arr_component__before, isExhaustive);

              acc.arr_component = join_workz.arr_rest;
              const mathNode__operand = join_workz.output;
              acc.arr_out.push(mathNode__operand);

              return acc;
            }, {
              arr_component: arr_mathNode_rest,
              arr_out: [],
            });

            const arr_operands = obj_operands.arr_out;

            switch(specializedNode.type) {
              case "ParenthesisNode":
                const parenthesisNode = specializedNode;
                const contentNode = arr_operands.find(e => true);
                parenthesisNode.content = contentNode;
                break;
              case "OperatorNode":
                const operatorNode = specializedNode;
                operatorNode.args = arr_operands;
                break;
              default:
                throw new Error("unsupported specializedNode type : " + specializedNode.type);
                break;
            }

            logger.log("operatorNode")

            outWorkz.output   = specializedNode;
            outWorkz.arr_rest = obj_operands.arr_component;
          }

          return outWorkz;
        }


        static filter_operatorSymbols(arr_mathNode) {
          var outArr;

          function isOperatorSymbolNode(symbolNode) {
            var outBool;

            switch(symbolNode.name) {
              case "+":
              case "-":
              case "×":
              case "/":
                outBool = true;
                break;

              case "()":
                outBool = true;
                break;

              default:
                outBool = false;
                break;
            }

            return outBool;
          }

          outArr = arr_mathNode
                   .filter(mathNode => (mathNode.type == "SymbolNode"))
                   .filter(isOperatorSymbolNode);

          return outArr;
        }

        static operatorNodeForOperatorSymbolNode(symbolNode) {
          var outOperatorNode;

          const op = symbolNode.name;

          var funcName;
          switch(op) {
            case "+":
              funcName = "add";
              break;
            case "-":
              funcName = "subtract";
              break;
            case "×":
              funcName = "multiply";
              break;
            case "/":
              funcName = "divide";
              break;
            default:
              throw new Error("unsupported op symbol : " + op);
            break;
          }

          outOperatorNode = new math.OperatorNode(op, funcName, []);

          return outOperatorNode;
        }

        static specializedNodeForSymbolNode(symbolNode) {
          var outSpecializedNode;

          const op = symbolNode.name;

          var funcName;
          switch(op) {
            case "+":
              funcName = "add";
              outSpecializedNode = new math.OperatorNode(op, funcName, []);
              break;
            case "-":
              funcName = "subtract";
              outSpecializedNode = new math.OperatorNode(op, funcName, []);
              break;
            case "×":
              funcName = "multiply";
              outSpecializedNode = new math.OperatorNode(op, funcName, []);
              break;
            case "/":
              funcName = "divide";
              outSpecializedNode = new math.OperatorNode(op, funcName, []);
              break;

            case "()":
              const mathNode__placeholder = new math.SymbolNode("placeholder");
              outSpecializedNode = new math.ParenthesisNode(mathNode__placeholder);   //SHU: ni propre, ni sale. Juste un peu dérangeant.
              break;

            default:
              throw new Error("unsupported op symbol : " + op);
            break;
          }

          return outSpecializedNode;
        }

        static arityForSymbolNode(symbolNode) {
          var outInt;

          const op = symbolNode.name;

          var funcName;
          switch(op) {
            case "+":
            case "-":
            case "×":
            case "/":
              outInt = 2;
              break;
            case "()":
              outInt = 1;
              break;
            default:
              throw new Error("unsupported op symbol : " + op);
            break;
          }

          return outInt;
        }

      }
    </script>
    <script>
      class MathUtils {

        static primeFactorization(number, result) {
          var result = (result || []);
          var root = Math.sqrt(number);
          var x = 2;

          if (number % x) {
            x = 3;

            while ((number % x) && ((x = (x + 2)) < root)) {}
          }

          x = (x <= root) ? x : number;

          result.push(x);

          return (x === number) ? result : MathUtils.primeFactorization((number / x), result);
        }

      }
    </script>




    <!-- icObj transformation stuff -->
    <script>
      class Combiner {
        constructor() {

        }

        static combine(arr_icObj) {
          var outIcObj;


          return outIcObj;
        }

      }
    </script>
    <script>
      class TransformationOutput {

        constructor(type, value, from) {
          this.type  = type;
          this.value = value;
          this.from  = from;
        }

      }
    </script>
    <script>

      class RichMathNode {

        constructor(mathNode) {
          this.mathNode = mathNode;
          this.rich     = {};
        }

        configure(config) {
          this.rich.colorMode = config.colorMode;
          this.rich.color     = config.color;
        }

        toTex() {
          var outString;

          const colorMode = this.rich.colorMode;

          switch(colorMode) {
            case "xylophone":
              {
                if(this.mathNode.type == "ConstantNode") {
                  const positionalNumber = new PositionalNumber(this.mathNode.value);
                  outString = positionalNumber.toTex("xylophone");
                } else {
                  throw new Error("colorMode:xylophone only compatible with ConstantNode");
                }
              }
              break;
              case "fullplain":
                {
                  const color = this.rich.color;
                  if(this.mathNode.type == "ConstantNode") {
                    const positionalNumber = new PositionalNumber(this.mathNode.value);
                    outString = positionalNumber.toTex(color);
                  } else {
                    throw new Error("colorMode:xylophone only compatible with ConstantNode");
                  }
                }
                break;
            case "evenodd":
              {
                const color__even = "#FFFFFF";
                const color__odd  = "#000000";

                var color;
                if(this.rich.isEven) {
                  color = color__even;
                } else {
                  color = color__odd;
                }

                const tex__mathNode = this.mathNode.toTex();
                outString = TexEnricher.color(tex__mathNode, color);
              }
              break;
            case "plain":
              {
                const tex__mathNode = this.mathNode.toTex();

                //color
                if(this.rich.color != null) {
                  const color = this.rich.color;
                  outString = TexEnricher.color(tex__mathNode, color);
                } else {
                  throw new Error("no color specified for colorMode: " + colorMode);
                }

              }
              break;
            default:
              {
                const tex__mathNode = this.mathNode.toTex();
                outString = tex__mathNode;
              }
              // throw new Error("unknown colorMode: " + colorMode);
              break;
          }

          return outString;
        }

        clone() {
          return;
        }

      }

      class TexEnricher {

        static color(tex_in, color_in) {
          var outString;

          outString = "{\\color{" + color_in + "} " + tex_in + " }";

          return outString;
        }

        // static font(tex_in, font_in) {
        //   var outString;
        //
        //   outString = "{\\fontfamily{pag}\\selectfont " + tex_in  + "}";
        //
        //   return outString;
        // }

      }

      // class UnfoldedNumber {
      class PositionalNumber {

        constructor(number, base = 10) {
          this.arr_digit = ("" + number).split("").map(digitStr => parseInt(digitStr));
          this.base      = base;
        }

        toTex(color) {
          var outString;

          outString = this.arr_digit.reduce((acc, x) => {
            acc += PositionalNumber.texForDigit(x, color);
            return acc;
          }, "");

          return outString;
        }

        static texForDigit(digit, color_in) {

          var outString;

          outString = "" + digit;

          var color = color_in;
          if(color == "xylophone") {


            if(digit == 0) {
              // outString = "{\\fbox {}}";
              // outString = "{\\fbox {?}}";
              // outString = "\\enspace";

              // outString = "{\\mbox {0}}";

              // outString = "▢";
              // outString = "▫";
              // outString = "☐";
              // outString = "𖡄";
              outString = "?";


              ///not working
              // outString = "{\\fbox {\\hspace{1cm}} }";

            } else {
              color = PositionalNumber.colorForDigit(digit);
            }

            outString = TexEnricher.color(outString, color);

          } else {
            outString = TexEnricher.color(outString, color);
          }

          return outString;
        }

        static colorForDigit(digit) {
          var outColor = null;

          switch(digit) {
            case 0:
              outColor = "#000000";
              break;

            case 1:
              outColor = "#FF7F0E";
              break;
            case 2:
              outColor = "#2CA02C";
              break;
            case 3:
              outColor = "#D62728";
              break;
            case 4:
              outColor = "#9467BD";
              break;
            case 5:
              outColor = "#8C564B";
              break;
            case 6:
              outColor = "#E377C2";
              break;
            case 7:
              outColor = "#7F7F7F";
              break;
            case 8:
              outColor = "#BCBD22";
              break;
            case 9:
              outColor = "#17BECF";
              break;

            //SHU TODO: colors or patterns for those:
            case 10:  //A
              outColor = "#000000";
              break;
            case 11:  //B
              outColor = "#000000";
              break;
            case 12:  //C
              outColor = "#000000";
              break;
            case 13:  //D
              outColor = "#000000";
              break;
            case 14:  //E
              outColor = "#000000";
              break;
            case 15:  //F
              outColor = "#000000";
              break;

            default:
              throw new Error("unsupported digit: " + digit);
          }

          return outColor;
        }



      }

    </script>






    <!-- UX -->
    <script type="text/javascript" src="lib/rxjs.umd.min.js"></script> <!-- for easy inner/outer copy|paste -->
    <script>
      const Rx = rxjs;
      const Rx_operators = rxjs.operators;

      const Subject       = Rx.Subject;
      const ReplaySubject = Rx.ReplaySubject;
    </script>
    <!-- <script>
      //discovery
      const rx_debug__subject    = new Subject();
      const rx_debug__observable = rx_debug__subject.asObservable();
      const rx_debug__sub        = rx_debug__observable.subscribe({
        next: (value) => {
          console.log("value", value);
        },
      });
      rx_debug__subject.next(10);
      rx_debug__subject.next(100);
      rx_debug__subject.next(1000);
    </script> -->
    <script>//for easy html element observation

      function mutationCallback__debug(mutationsList, observer) {
          console.log(mutationsList);
          console.log(observer);
          for (const mutation of mutationsList) {
              if (mutation.type === 'childList') {
                  console.log('A child node has been added or removed.');
              } else if (mutation.type === 'attributes') {
                  console.log('The ' + mutation.attributeName + ' attribute was modified.');
              } else {
                  console.log('mutation.type: ' + mutation.type);
                  console.log('New value ' + JSON.stringify(mutation.target.data));
              }
          }
      }

      function createHtmlEltObserver(htmlElt) {

        // Observation medium
        const rx_subject__mutation = new Subject();

        function mutationCallback(mutationsList, observer) {
            console.log(mutationsList);
            console.log(observer);

            const mutation     = mutationsList.find(e => true);

            switch(mutation.type) {
              case "childList":
                rx_subject__mutation.next(htmlElt);
                break;
              case "attributes":
                // /!\ .attr() != .prop()
                break;
              default:
                console.log('mutation.type: ' + mutation.type);
                console.log('New value ' + JSON.stringify(mutation.target.data));
                break;
            }

            // rx_subject__mutation.next(htmlElt);
        }

        // Create an observer instance linked to the callback function
        const observer = new MutationObserver(mutationCallback);
        observer.rx_observable__mutation = rx_subject__mutation.asObservable();

        // What to observe
        const mutationConfig = { attributes: true, childList: true, subtree: true, characterData: true };

        // Start observation
        observer.observe(htmlElt, mutationConfig);

        return observer;
      }

    </script>
    <!-- <script>
      //discovery

      document.addEventListener("DOMContentLoaded", function () {
        const htmlElt = document.getElementById("debug_nbObjects");
        const observer = createObserver(htmlElt);

        setTimeout(() => {
          htmlElt.innerHTML = 123456;
        }, 5000);

      });

    </script> -->



    <!-- information -->
    <!-- <script type="text/javascript" src="lib/serialize-javascript.browserified.main.js"></script> -->
    <script type="text/javascript" src="lib/serialize-javascript.browserified.bundle.js"></script>
    <script>
      // console.log("Bundle_SJ", Bundle_SJ);
      const serialize   = Bundle_SJ.serialize;
      const deserialize = Bundle_SJ.deserialize;
    </script>
    <!-- <script>
      //discovery
      const sj__obj = {
        myFunc: (x) => x + 1,
      };
      const sj__serialized = serialize(sj__obj);
      console.log("serialize-javascript::sj__serialized", sj__serialized);
      const sj__deserialized = deserialize(sj__serialized);
      console.log("serialize-javascript::sj__deserialized", sj__deserialized);
      const sj__myFunc_result = sj__deserialized.myFunc(0);
      console.log("serialize-javascript::sj__myFunc_result", sj__myFunc_result);
    </script> -->




    <canvas id="myCanvas">Your browser does not support HTML5 canvas</canvas>
    <script>
      const canvas = document.getElementById("myCanvas");
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
    </script>


    <!-- debug -->
    <div id="debug_container" style="position:absolute; left:0; top: 0; font-size: 60px; pointer-events: none;">
      <div>
        <div style="display: inline-block;">current scale: </div>
        <div style="display: inline-block;"id="debug_scale"></div>
      </div>
      <div>
        <div style="display: inline-block;">offset: </div>
        <div style="display: inline-block;" id="debug_offset"></div>
      </div>
      <div>
        <div style="display: inline-block;">nb objects: </div>
        <div style="display: inline-block;" id="debug_nbObjects"></div>
      </div>
      <div>
        <div style="display: inline-block;">current object rect: </div>
        <div style="display: inline-block;" id="debug_currObjRect"></div>
      </div>
      <div>
        <div style="display: inline-block;">activeColor: </div>
        <div style="display: inline-block;" id="debug_activeColor">"   "</div>
      </div>
    </div>

    <script>
      class Debug {
        constructor (eltsDict) {
          this.eltsDict = eltsDict;

          this.eltsDict["container"].style.visibility = "hidden";
        }

        setScale(scale) {
          this.eltsDict["scale"].innerHTML = JSON.stringify(scale);
        }
        setOffset(offset) {
          this.eltsDict["offset"].innerHTML = JSON.stringify(offset);
        }
        setNbObjects(nb_objects) {
          this.eltsDict["nb_objects"].innerHTML = nb_objects;
        }
        setCurrentObjectRect(current_object_rect) {
          this.eltsDict["current_object_rect"].innerHTML = JSON.stringify(current_object_rect);
        }

        setActiveColor(color) {
          this.eltsDict["active_color"].style.backgroundColor = color;
        }

      }

      const debugEltsDict = {
        container:            document.getElementById("debug_container"),

        scale:                document.getElementById("debug_scale"),
        offset:               document.getElementById("debug_offset"),
        nb_objects:           document.getElementById("debug_nbObjects"),
        current_object_rect:  document.getElementById("debug_currObjRect"),

        active_color:         document.getElementById("debug_activeColor"),
      };
      const debug = new Debug(debugEltsDict);

    </script>




    <script>

/**** model  ****/

    const RedrawOccasion = {
      // "forceRedraw"   : 0,
      "forceRedraw"   : "forceRedraw",


      // "offsetChanged" : 10,
      "offsetChanged"       : "offsetChanged",
      // "scaleChanged"  : 11,
      "scaleChanged"        : "scaleChanged",
      "orientationChanged"  : "orientationChanged",


      // "objectAdded"   : 20,
      "objectAdded"     : "objectAdded",
      "pureObjectAdded" : "pureObjectAdded",

      "objectRemoved"     : "objectRemoved",



      // "windowResize"  : 100,
      "windowResize"  : "windowResize",
    };


    class InfiniteCanvas {

      constructor(canvas, inputProperties) {

        this.canvas          = canvas;
        this.inputProperties = inputProperties;

          //--properties

        this.coords_initial = {
          scale: {
            X:1,
            Y:1,
          },
          offset: {
            dx: 0,
            dy: 0,
          },
          orientation: 0,
        };

        // coordinates of our cursor
        this.cursor = {
          x: 0,
          y: 0,
        };
        this.previousCursor = Object.assign({}, this.cursor);


        // distance from origin
        this.offset         = Object.assign({}, this.coords_initial.offset);
        this.previousOffset = Object.assign({}, this.offset);
        this.dOffset = {
          dx: 0,
          dy: 0,
        };

        // zoom amount
        this.scale = Object.assign({}, this.coords_initial.scale);

        this.orientation = this.coords_initial.orientation;

        this.didUpdateListeners = [];


          //--objects

        this.icObjects = {
          any: [],
        };
        this.didAddObjectListeners = [];

        this.pure_icObjects = {
          any: [],
        };
        this.didAddPureObjectListeners = [];

        this.creationManagers = {};



        this.represented = {};
        this.didAddRepresentedListeners    = [];
        this.didRemoveRepresentedListeners = [];

        this.representations = {};
        this.didAddRepresentationListeners = [];


        this.didUpdateListenersDict = {
          // "objectAdded": [],
          "scaleChanged": [],
        };

        this.requestSyncWithIcObjListeners = [];

        this.icObjListeners = [];


        this.redrawCanvasListeners = [];
        this.setupRedrawConditions();

        this.counter = 0;


        this.configureInitialIcObjects();

        this.isZIndexEditing = false;


          //--track changes

        // this.lastChangeTimestamp = null;
        this.changed            = false;



        var mySaveTimeout = null;

        const infiniteCanvas = this;
        window.addEventListener("beforeunload", (e) => {
          console.log("beforeunload", e);

          if(infiniteCanvas.changed /*&& !infiniteCanvas.leaveWithoutSaving*/) {

            const infiniteCanvas = this;
            const infinishute_p  = this.createInfinishute_p();

            function userStaysOnPage() {
              infiniteCanvas.manageSaveInfinishute_p_2(infinishute_p);
            }

            setTimeout(function() {                   //the nested setTimeout is the working way :)
              mySaveTimeout = setTimeout( () => {
                userStaysOnPage();
              }, 100 );
            },1);

          }

        });

        window.addEventListener('unload', function onUnload(e) {
          console.log("onUnload", e);
          clearTimeout(mySaveTimeout);
        });

      }

      setChanged(changed) {
              //uncomment for promptWhenUnsavedChanges
        // this.changed = changed;
        this.changed = false;


        if(this.changed) {
          window.onbeforeunload = () => {
            return "You have unsaved changes;";
          };

        } else {
          window.onbeforeunload = null;
        }

      }

      //properties

      update(propName, newValue) {
        const oldValue = this[propName];
        this[propName] = newValue;
        this.didUpdate(propName, oldValue, newValue);
      }

      didUpdate(propName, oldValue, newValue) {
        this.didUpdateListeners.forEach((listener, i) => {
          listener(this, propName, oldValue, newValue);
        });
      }


      //objects
        //creation

      generateIcObjectId() {
        const id = this.counter;
        this.counter += 1;
        return id;
      }

      createIcObject(type, position, size, homeScale) {

        const id = this.generateIcObjectId();

        const icObj = new IcObject(id, type, position, size, homeScale);
        return icObj;

        // return this.createRepresentedIcObject(icObj);
      }

      createRepresentedIcObject(icObj) {

        const icObj__represented  = RepresentedFactory.initial(icObj);
        const icObj__rep_official = icObj__represented.r_official();

        const icObj__rep_free     = icObj__represented.createNewRepresentationWithName("free");
        icObj__rep_free.addInteraction_hold();

        if(icObj.type == "composite") {

          icObj__represented.parts  = {};
          icObj__rep_official.parts = {};
          icObj__rep_free.parts     = {};

          // icObj__represented.compositeConfig  = {};
          // icObj__rep_official.compositeConfig = {};
          // icObj__rep_free.compositeConfig     = {};


          // const parts = icObj.compositeConfig.parts;
          const parts = icObj.parts;

          Object.entries(parts)
                .forEach(([partName, part_icObj], i) => {

                  const id_icObj = part_icObj.id;
                  const represented_check = this.getRepresented(id_icObj);
                  if(represented_check != null) {
                    console.log("represented already added");

                    // if(part_icObj.isMobile) {
                      const part__represented  = represented_check;
                      const part__rep_official = part__represented.r_official();
                      const part__rep_free     = part__represented.r_free();
                      // if(part__rep_free.holdListeners == null) {
                      //   part__rep_free.addInteraction_hold();
                      // }
                    // }

                    icObj__represented.parts[partName]  = part__represented;
                    icObj__rep_official.parts[partName] = part__rep_official;
                    icObj__rep_free.parts[partName]     = part__rep_free;
                    // icObj__represented.compositeConfig.parts[partName]  = part__represented;
                    // icObj__rep_official.compositeConfig.parts[partName] = part__rep_official;
                    // icObj__rep_free.compositeConfig.parts[partName]     = part__rep_free;

                  } else {

                    const part__represented  = this.createRepresentedIcObject(part_icObj);
                    const part__rep_official = part__represented.r_official();
                    const part__rep_free     = part__represented.createNewRepresentationWithName("free");
                    if(part__rep_free.nowHeld == null) {
                      part__rep_free.addInteraction_hold();
                    }

                    icObj__represented.parts[partName]  = part__represented;
                    icObj__rep_official.parts[partName] = part__rep_official;
                    icObj__rep_free.parts[partName]     = part__rep_free;

                  }

                });
        }

        return icObj__represented;
      }

      tetherIcObject(represented) {
        // logger.log("tetherIcObject", represented.r_official().id);

        const infiniteCanvas = this;

        // icObj.didUpdateListeners.push((icObj, requestCanvasRedraw) => {
        //   infiniteCanvas.manageIcObjUpdate(icObj, requestCanvasRedraw);
        // });

        //report updates
        const rep_official = represented.r_official();
        rep_official.onOuterUpdate((rep_official, updateDict) => {
          // console.log("rep_official", "onOuterUpdate", rep_official);
          infiniteCanvas.icObjDidUpdate(rep_official, updateDict);
        });

        //await object death
        const death_handler = (rep_official_incoming, outerUpdatesDict) => {
          // logger.log("death_handler", rep_official_incoming, outerUpdatesDict);

          const isDead = (outerUpdatesDict["im_dead_now"] != null) && (outerUpdatesDict["im_dead_now"].new == true);
          if(isDead) {
            const represented = rep_official_incoming.represented;
            // logger.log("isDead", represented.r_official().id);

            if(represented.r_official() != null) {  //SHU666: deeper into sadness
              var shouldAlsoRemoveChildren = represented.r_official().shouldAlsoRemoveChildren ? represented.r_official().shouldAlsoRemoveChildren : false;

              infiniteCanvas.removeRepresented(represented, shouldAlsoRemoveChildren);

              infiniteCanvas.offIcObjUpdate(death_handler);
            }

          }
        };
        infiniteCanvas.onIcObjUpdate(death_handler);


        //official rep follows free rep
        const rep_free     = represented.r_free();
        rep_official.follow(rep_free);

      }

      untetherIcObject(represented) {
        const infiniteCanvas = this;

        const rep_official = represented.r_official();
        rep_official.offAllOuterUpdates();

        const rep_free = represented.r_free();
        rep_official.unfollow(rep_free);
      }



      introduceToExistingObjects(represented) {

        //introduce object to existing touchSlots
        this.introduceToExistingType_touchSlot(represented);


        if(represented.r_official().type == "touchSlot") {
          //introduce touchslot to existing objects

          const touchSlot    = represented.r_official();
          const id_touchSlot = touchSlot.id;

          const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());

          arr_official.forEach((rep_official, i) => {
            rep_official.touchStateDict[id_touchSlot] = TouchState.Untouched;
          });

        }

      }

      introduceToExistingType_touchSlot(represented) {

        const rep_official__incoming = represented.r_official();

        const existing_type = "touchSlot";

        const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
        const arr_official_exisitingType = arr_official.filter(rep => (rep.type == existing_type));
        arr_official_exisitingType.forEach((rep, i) => {

          const id_touchSlot = rep.id;

          if(rep_official__incoming.touchStateDict[id_touchSlot] == null) {
            rep_official__incoming.touchStateDict[id_touchSlot] = TouchState.Untouched;
          }
          //SHU TODO: check if touches

        });

      }

      extroduceFromExistingObjects(represented) {
        console.log("extroduceFromExistingObjects", represented);

      }




      getRepresented(id) {
        return this.represented[id];
      }

      getAllRepresentedWithType(type) {
        const arr_represented = Object.values(this.represented).filter(represented => {
          const rep_official = represented.r_official();
          const isRequestedType = (rep_official.type == type);
          return isRequestedType;
        });
        return arr_represented;
      }


      createIcRect_withLTWH(left, top, width, height) {

        const type      = "rect";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;
      }

      createIcRect_withLTRB(left, top, right, bottom) {
        const width  = right - left;
        const height = bottom - top;
        const icRect = this.createRect_withLTWH(left, top, width, height);

        return icRect;
      }

      createIcRect(trueRect) {

        const type      = "rect";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;
      }

      createIcPoint(point) {

        const type      = "point";
        const position  = Geometry.createPoint(point.x, point.y);
        const size      = Geometry.createSize(0, 0);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icPoint_spec = {
          "color"   : "blue",
          "name"    : "A",
        };

        const icPoint = Object.assign(icObj, icPoint_spec);

        return icPoint;

      }

      createIcCircle(left, top, width, height, fillColor = '') {

        const type      = "circle";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const radius = width / 2;

        const icCircle_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,

          radius   : radius,

          "stroke" : "blue",
          "fill"   : fillColor,
        };

        const icCircle = Object.assign(icObj, icCircle_spec);

        return icCircle;
      }


      createIcText(left, top, text) {

        const type      = "text";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(0, 0);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        // const text     = "icText";
        const fontSize = 100;

        const icText_spec = {
          text:      text,
          textColor: "black",
          fontSize:  fontSize,
        };

        const icText = Object.assign(icObj, icText_spec);

        icText.addInteraction_edit();

        return icText;
      }

      createIcImage(left, top, img) {
        const type      = "image";
        const position  = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size      = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icImage_spec = {
          img : img,
        };

        const icImage = Object.assign(icObj, icImage_spec);

        return icImage;
      }

      createIcFreeDrawing_from_freeDrawingFObj(fObj) {
        console.log("createIcFreeDrawing_from_freeDrawingFObj", fObj);
        console.log("createIcFreeDrawing_from_freeDrawingFObj", fObj.constructor.name);


        const type      = "freeDrawing";


        const trueRect  = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size     = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        const exoObject = Object.assign({}, fObj);
        exoObject.icObj = null; // remove circular dependency

        const icFreeDrawing_spec = {
          // path: fObj.path,

          exoObject: exoObject,
        };

        const icFreeDrawing = Object.assign(icObj, icFreeDrawing_spec);

        return icFreeDrawing;
      }

      createIcSvg(left, top, svgEl) {
        const type      = "svg";
        const position  = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size      = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSvg_spec = {
          svg : svgEl,
        };

        var icSvg = Object.assign(icObj, icSvg_spec);

        const color_property = {
          get color() {
            return icSvg.svg.style.color;
          },
          set color(value) {
              icSvg.svg.style.color = value;
          },
        };

        icSvg = Object.assign(icSvg, color_property);

        return icSvg;
      }

      createIcTex(left, top, tex) {
        const type      = "tex";
        const position  = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size      = Geometry.createSize(500, 500);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icTex_spec = {
          tex: tex,
        };

        const icTex = Object.assign(icObj, icTex_spec);

        //debug
        // const infiniteCanvas = this;
        // setTimeout(() => {
        //   const tex = '\\frac{50}{50x^2-50}';
        //
        //   const represented = infiniteCanvas.getRepresented(icObj.id);
        //   // const rep_official = represented.r_official();
        //   // rep_official.tex = tex;
        //   const rep_free = represented.r_free();
        //   rep_free.tex = tex;
        //
        // }, 5000);

        return icTex;
      }

      createIcMathNode(left, top, mathNode) {
        console.log("createIcMathNode", left, top, mathNode);


        const type      = "mathNode";
        const position  = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size      = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icMathNode_spec = {
          mathNode: mathNode,
        };

        const icMathNode = Object.assign(icObj, icMathNode_spec);
        icMathNode.isTouchable = true;


        //edition
        const infiniteCanvas = this;

        icMathNode.edit = {};
        icMathNode.edit.start = function() {
          console.log("icMathNode.edit.start");

          //mathQuill
          {
            //create mathField
            const mathField = createMathField();

            //add mathField root HTML element to canvasContainer
            const elt = mathField.el();
            console.log("elt", elt);

            if(elt.style == null) {elt.style = {};}
            elt.style.position = "absolute";

            const canvasContainer = infiniteCanvas.canvas.parentElement;
            canvasContainer.appendChild(elt);    //SHU: move this to fabricIntegration

            mathField.reflow();


            // //update position
            // function updatePosition() {
            //   const represented = infiniteCanvas.getRepresented(icMathNode.id);
            //   // console.log("represented", represented);
            //   const rep_free = represented.r_free();
            //
            //   const position_screen = rep_free.getScreenPositionWithoutOffset();
            //   console.log("position_screen", position_screen);
            //
            //   const style = {
            //     left: position_screen.x + 'px',
            //     top:  position_screen.y + 'px',
            //   };
            //
            //   const elt = mathField.el();
            //   // elt.style = Object.assign(elt.style, style);
            //   elt.style.left = style.left;
            //   elt.style.top  = style.top;
            //
            //   mathField.reflow();
            // }
            //
            // updatePosition();


            //update rect
            function updateRect() {
              const represented = infiniteCanvas.getRepresented(icMathNode.id);
              const rep_free    = represented.r_free();

              const screenRect = rep_free.getScreenRect();
              console.log("screenRect", screenRect);

              const style = {
                left:   screenRect.left   + 'px',
                top:    screenRect.top    + 'px',
                width:  screenRect.width  + 'px',
                height: screenRect.height + 'px',
              };

              const elt = mathField.el();
              // elt.style = Object.assign(elt.style, style);
              elt.style.left   = style.left;
              elt.style.top    = style.top;
              elt.style.width  = style.width;
              elt.style.height = style.height;

              mathField.reflow();
            }

            updateRect();


            //update tex
            function updateTex() {
              const represented = infiniteCanvas.getRepresented(icMathNode.id);
              const rep_free    = represented.r_free();

              const tex = rep_free.mathNode.toTex();
              mathField.latex(tex);
            }

            updateTex();

            //bind position
            {

            }



            //track end of mathField edition
            // mathField.upOutOf({
            //   const represented = infiniteCanvas.getRepresented(icMathNode.id);
            //   const rep_free    = represented.r_free();
            //
            //   rep_free.edit.stop(mathField);
            // })
            // mathField.el().onfocusout(() => {
            //   stopEditing(mathField);
            // });
            const eventListener = () => {
              stopEditing(mathField);
            };
            mathField.el().addEventListener("focusout", eventListener);

            function stopEditing(mathField) {
                const represented = infiniteCanvas.getRepresented(icMathNode.id);
                const rep_free    = represented.r_free();

                rep_free.edit.stop(mathField);
            }


            //focus mathField
            mathField.focus();

          }


        };

        icMathNode.edit.stop = function(mathField) {
          console.log("icMathNode.edit.stop", mathField);

          //mathQuill
          {

            //transfer tex
            {
              const tex = mathField.latex();
              console.log("tex", tex);

              const represented = infiniteCanvas.getRepresented(icMathNode.id);
              const rep_free    = represented.r_free();

              //this is where fun starts
              function mathFieldTex_to_mathNode(tex) {
                var outMathNode;

                // outMathNode = math.parse(tex);
                const mathExpression = MathExpression.fromLatex(tex);
                const text           = mathExpression.toString();
                console.log("text", text);
                outMathNode = math.parse(text);

                //don't parse "=" into ":="

                //upgrade to gmOperator when writing "x50"

                return outMathNode;
              }

              rep_free.mathNode = mathFieldTex_to_mathNode(tex);
            }

            //remove all listeners
            // mathField.el().removeEventListener("focusout", eventListener);
            $(mathField.el()).off();

            //remove mathField elt from canvasContainer
            mathField.el().remove();

            //destroy mathField
            mathField.revert();
          }


        };



        return icMathNode;
      }

      createIcRichMathNode(left, top, richMathNode) {
        console.log("createIcRichMathNode", left, top, richMathNode);

        const type      = "richMathNode";
        const position  = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size      = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRichMathNode_spec = {
          richMathNode: richMathNode,
        };

        const icRichMathNode = Object.assign(icObj, icRichMathNode_spec);


        return icRichMathNode;
      }


      // createIcAsText_mathNode(left, top, text, ) {
      //
      //   const type      = "as_text__mathNode";
      //   const position  = Geometry.createPoint(left, top);
      //   const size      = Geometry.createSize(0, 0);
      //   const homeScale = Object.assign({}, this.scale);
      //
      //   const icObj = this.createIcObject(type, position, size, homeScale);
      //
      //
      //   // const text     = "icText";
      //   const fontSize = 100;
      //
      //   const icText_spec = {
      //     text:      text,
      //     textColor: "black",
      //     fontSize:  fontSize,
      //   };
      //
      //   const icText = Object.assign(icObj, icText_spec);
      //
      //   return icText;
      // }
      //
      // createIcAsY(left, top, type_y, type_x, func_YtoX) {
      //
      // }
      //
      // createIcEditingAsY(left, top, type_y, type_x, func_YtoX) {
      //
      // }


      createIcHtmlElt(left, top, html_elt) {
        console.log("createIcHtmlElt", left, top, html_elt);
        const infiniteCanvas = this;

        const type      = "htmlElt";
        const position  = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size      = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icHtmlElt_spec = {
          htmlElt: html_elt,
        };

        const icHtmlElt = Object.assign(icObj, icHtmlElt_spec);



        const htmlEltObserver = createHtmlEltObserver(html_elt);
        htmlEltObserver.rx_observable__mutation.subscribe({
          next: (html_elt_mutated) => {

            const represented  = infiniteCanvas.getRepresented(icHtmlElt.id);
            const rep_free     = represented.getRepresentation("free");

            rep_free.htmlElt = html_elt_mutated;

          },
        });

        html_elt.innerHTML = "1";
        // html_elt.text = "1";


        //debug
        setTimeout(() => {
          html_elt.innerHTML += "[]";
          // html_elt.text += "[]";
        }, 5000);

        // setInterval(() => {
        //   html_elt.innerHTML += "[]";
        //   // html_elt.text += "[]";
        // }, 2000);


        return icHtmlElt;
      }




      createIcGroupWithChildIcObjects(arr_icObjs) {
        console.log("createIcGroupWithChildIcObjects", arr_icObjs);

        const type      = "group";

        const trueRect  = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size     = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icGroup_spec = {
          children: children,
        };

        const icGroup = Object.assign(icObj, icGroup_spec);

        return icGroup;
      }

      createIcGroup_from_groupFObj(fObj) {
        console.log("createIcGroup_from_groupFObj", fObj);

        const type      = "group";

        const trueRect  = this.toTrueRect(fObj);
        const position  = Geometry.getPointTL(trueRect);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const fChildren  = fObj.getObjects();
        const icChildren = fChildren.map(fObj => {
          const icObj = fObj.icObj;

          //?add position wrt group
          return icObj;
        });

        const icGroup_spec = {
          children: icChildren,
        };

        const icGroup = Object.assign(icObj, icGroup_spec);

        return icGroup;
      }

      createIcActiveSelection_from_activeSelectionFObj(fObj) {
        console.log("createIcActiveSelection_from_activeSelectionFObj", fObj);

        const type      = "activeSelection";

        const trueRect  = this.toTrueRect(fObj);
        const position  = Geometry.getPointTL(trueRect);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const fChildren  = fObj.getObjects();
        const icChildren = fChildren.map(fObj => {
          const icObj = fObj.icObj;

          //add position wrt group

        });

        const icActiveSelection_spec = {
          children: icChildren,
        };

        const icActiveSelection = Object.assign(icObj, icActiveSelection_spec);

        return icActiveSelection;

      }




      createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive) {

        const type      = "toggleRect";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icToggleRect_spec = {
          activeCfg:   activeCfg,
          inactiveCfg: inactiveCfg,

          isActive:    isActive,
        };

        const icToggleRect = Object.assign(icObj, icToggleRect_spec);

        return icToggleRect;

      }



      createIcSnapSlot(trueRect, snapSlotConfig_in = null) {
        console.log("createIcSnapSlot");

        const infiniteCanvas = this;

        const type      = "snapSlot";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        var snapSlotConfig = snapSlotConfig_in;
        if(snapSlotConfig == null) {
          // console.log("snapEngine == null");
          snapSlotConfig = Snap.defaultSnapSlotConfig();
        }

        const icSnapSlot_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 3,

          snapSlotConfig: snapSlotConfig,
        };

        const icSnapSlot = Object.assign(icObj, icSnapSlot_spec);



        const engine = new SnapSlotEngine();
        const eType  = "snapSlot";

        const icEngined = infiniteCanvas.createIcEngined(icSnapSlot, eType, engine);


        return icEngined;
      }



      createIcLine_start() {
        // console.log("createIcLine_start");

        //check
        {
          const creationManager_line = this.creationManagers["line"];
          if(creationManager_line != null) {
            throw new Error("createIcLine_start, creationManager_line != null");
          }
        }

        // this.creationManagers["line"] = new LineCreationManager();
        this.creationManagers["line"] = {};
        const creationManager_line = this.creationManagers["line"];

        const true_cursor = this.getTrueCursor();

        creationManager_line.point_start = Object.assign({}, true_cursor);
      }

      createIcLine_end() {
        // console.log("createIcLine_end");

        //check
        {
          const creationManager_line = this.creationManagers["line"];
          if(creationManager_line == null) {
            throw new Error("createIcLine_end, creationManager_line == null");
          }
        }

        const creationManager_line = this.creationManagers["line"];

        const true_cursor = this.getTrueCursor();

        creationManager_line.point_end = Object.assign({}, true_cursor);

        // this.createIcLine(creationManager_line.point_start, creationManager_line.point_end);
        const icSegment = this.createIcSegment(creationManager_line.point_start, creationManager_line.point_end);
        this.addIcObject(icSegment);

        delete this.creationManagers["line"];
      }

      createIcLine(startPoint, endPoint) {

        const type      = "line";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;

      }

      createIcSegment(point_start, point_end) {
        // console.log("createIcSegment", point_start, point_end);

        const type      = "segment";
        const position  = null;
        const size      = null;
        const homeScale = "none";

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSegment_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
          point_start: point_start,
          point_end: point_end,
        };

        const icSegment = Object.assign(icObj, icSegment_spec);

        return icSegment;
      }


      // createIcSparkle(trueRect, img, sparkleConfig) {
      createIcSparkle(truePoint, img, sparkleConfig) {
        // console.log("createIcSparkle", truePoint, sparkleConfig);

        const type     = "sparkle";

        // const position = Geometry.getPointTL(trueRect);
        // const size     = Geometry.createSize(trueRect.width, trueRect.height);
        // const center = Geometry.getCenterPoint(trueRect);
        const position = {
          x: truePoint.x,
          y: truePoint.y,
        };
        const size     = Geometry.createSize(img.width, img.height);

        const homeScale = {
          // X: this.scale.X * 10,
          // Y: this.scale.Y * 10,
          X: this.scale.X,
          Y: this.scale.Y,
        };

        const icObj = this.createIcObject(type, position, size, homeScale);



        const icSparkle_spec = {
          isUsingCenterPosition: true,
          // center: center,

          homeScale_max: 10000,
          homeScale_min: 0,

          img: img,

          isSnappable: false,
        };

        const icSparkle = Object.assign(icObj, icSparkle_spec);

        return icSparkle;
      }

      debug_sparkleAnims(isAnimPaused) {
        console.log("debug_sparkleAnims(", isAnimPaused, ")");

        const arr_sparkles = Object.values(this.represented)
                                   .map(represented => {
                                     // return represented.r_official();
                                     return represented.r_free();
                                   })
                                   .filter(rep => {
                                     const isSparkle = (rep.type == "sparkle");
                                     return isSparkle;
                                   });

        arr_sparkles.forEach((rep, i) => {
          rep.isAnimPaused = isAnimPaused;

          const animation = rep.animation;
          const progress  = animation.progress / 100.0;
          console.log("debug_sparkleAnims: progress", progress);

          if(isAnimPaused) {
            animation.pause();
          } else {
            animation.play();
          }
        });
      }




      createIcTouchSlot(trueRect, touchSlotConfig) {
        console.log("createIcTouchSlot", trueRect, touchSlotConfig);

        const infiniteCanvas = this;

        const type      = "touchSlot";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icTouchSlot_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 3,

          touchSlotConfig: touchSlotConfig,
        };

        const icTouchSlot = Object.assign(icObj, icTouchSlot_spec);


        const engine = new TouchSlotEngine();
        const eType  = "touchSlot";

        const icEngined = infiniteCanvas.createIcEngined(icTouchSlot, eType, engine);

        //debug: hot-mutating touchSlotConfig
        // setTimeout(() => {
        //
        //   const represented = infiniteCanvas.getRepresented(icEngined.id);
        //   const rep_free    = represented.r_free();
        //
        //   rep_free.touchSlotConfig = {
        //     transformationFunc: (icObj) => {
        //       icObj.fill = "orange";
        //     },
        //   };
        //
        // }, 10000);

        return icEngined;
      }






      // createIcComposite(parts, engine) {
      createIcComposite_debug(trueRect) {
        console.log("createIcComposite_debug", trueRect);


        function createPartsDict() {
          // const part1_trueRect = trueRect;
          const part1_trueRect = {
            x:      trueRect.x + 400,
            y:      trueRect.y + 50,
            width:  trueRect.width,
            height: trueRect.height,
          };
          const part1_icObj    = infiniteCanvas.createIcRect(part1_trueRect);
          part1_icObj.fill     = "cyan";

          // const part2_trueRect = {
          //   x:      trueRect.x + 400,
          //   y:      trueRect.y + 50,
          //   width:  trueRect.width,
          //   height: trueRect.height,
          // };
          const part2_trueRect = part1_trueRect;
          const part2_icObj    = infiniteCanvas.createIcRect(part2_trueRect);
          part2_icObj.fill     = "orange";

          const part3_trueRect = part1_trueRect;
          const part3_icObj    = infiniteCanvas.createIcRect(part2_trueRect);
          part3_icObj.fill     = "magenta";

          const partsDict = {
            "part1": part1_icObj,
            "part2": part2_icObj,
            "part3": part3_icObj,
          };

          return partsDict;
        }

        const parts = createPartsDict();

        const compositeConfig = Object.entries(parts).reduce((acc, [partName, part], index) => {
          const isMobile = (index != 0);
          // acc[partName] = {
          acc[part.id] = {
            isMobile: isMobile,
          };
          return acc;
        }, {});

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);

        return icComposite;
      }


      createIcComposite(trueRect, parts, compositeConfig) {
        console.log("createIcComposite", trueRect);

        const infiniteCanvas = this;

        const type      = "composite";

        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);
        const icObj = this.createIcObject(type, position, size, homeScale);


        const icComposite_spec = {
          isSnappable: false,

          // stroke: "red",
          // strokeWidth: 4,

          fill: "pink",

          parts:           parts,
          compositeConfig: compositeConfig,
        };

        const icComposite = Object.assign(icObj, icComposite_spec);

        const engine = new CompositeEngine();
        const eType  = "composite";

        const icEngined = infiniteCanvas.createIcEngined(icComposite, eType, engine);


        return icComposite;
      }




      createIcTag(left, top, text) {

        const type      = "tag";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(0, 0);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        // const text     = "icText";
        const fontSize = 100;

        const icTag_spec = {
          text:      text,
          textColor: "black",
          fontSize:  fontSize,
        };

        const icTag = Object.assign(icObj, icTag_spec);

        return icTag;
      }

      createIcLabelValue(trueRect, text, value) {
        console.log("createIcLabelValue", trueRect, text, value);

        const infiniteCanvas = this;

        const icObj__label = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        icObj__label.fill  = "";

        const icObj__value = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "" + value);
        icObj__value.fill  = "";

        const parts = {
          "label": icObj__label,
          "value": icObj__value,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "labelValue";
        icComposite.fill  = "";



        //put value on right side of label
        // infiniteCanvas.onceOnAddRepresentedForIcObject(icComposite, (icComposite) => {
          // logger.log("infiniteCanvas.onceOnAddRepresentedForIcObject", icComposite);
        setTimeout(() => {

          const labelValue__represented = infiniteCanvas.getRepresented(icComposite.id);
          const labelValue__rep_free    = labelValue__represented.r_free();


          const label__rep_free = labelValue__rep_free.parts["label"];
          const value__rep_free = labelValue__rep_free.parts["value"];
          // logger.log("label__rep_free", label__rep_free);
          // logger.log("value__rep_free", value__rep_free);


          labelValue__rep_free.compositeConfig[value__rep_free.id].isMobile = true;

          const spacing = 50;
          value__rep_free.position = {
            x: label__rep_free.position.x + label__rep_free.size.width + spacing,
            y: value__rep_free.position.y,
          };

          labelValue__rep_free.compositeConfig[value__rep_free.id].isMobile = false;


        // });
        }, 10);   //SHU TODO: remove this ugliness


        return icComposite;
      }


      createIcButton(trueRect, buttonConfig_in) {
        console.log("createIcButton", trueRect, buttonConfig_in);

        const infiniteCanvas = this;

        const type      = "button";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        var buttonConfig;
        if(buttonConfig_in == null) {
          buttonConfig = {
            buttonFunc: (scopeObj) => {
              console.log("buttonFunc", scopeObj);
              const button = scopeObj.engineCarrier;
              button.fill = Color.randomColor();
            },
          };
        }

        const icButton_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 1,
          fill: "lightgray",

          buttonConfig: buttonConfig,
        };

        const icButton = Object.assign(icObj, icButton_spec);


        const engine = new ButtonEngine();
        const eType  = "button";

        const icEngined = infiniteCanvas.createIcEngined(icButton, eType, engine);

        return icEngined;
      }

      createIcClickWell(trueRect, value_in = -48) {
        console.log("createIcClickWell", trueRect);

        const infiniteCanvas = this;

        // const type      = "clickWell";
        const type      = "button";

        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const buttonFunc = (scopeObj) => {
          console.log("buttonFunc", scopeObj);
          const button = scopeObj.engineCarrier;
          button.fill  = Color.randomColor();

          //create/add new spawn
          const infiniteCanvas = scopeObj.infiniteCanvas;

          const trueRect = {
            x:      button.position.x,
            y:      button.position.y,
            width:  button.size.width,
            height: button.size.height,
          };

          // const spawn = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "spawn");
          // const spawn = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "12");

          const mathNode        = new math.ConstantNode(value_in);
          mathNode.autoSimplify = true;
          const spawn = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);


          infiniteCanvas.addIcObject(spawn);


          //set spawn as active object
          const spawn__represented = infiniteCanvas.getRepresented(spawn.id);
          const spawn__rep_free    = spawn__represented.r_free();

          infiniteCanvas.setActiveObject(spawn__rep_free);
        };

        const buttonConfig = {
          buttonFunc: buttonFunc,
        };


        const icButton_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 1,
          fill: "lightgray",

          buttonConfig: buttonConfig,
        };

        const icButton = Object.assign(icObj, icButton_spec);


        const engine = new ButtonEngine();
        const eType  = "button";

        const icEngined = infiniteCanvas.createIcEngined(icButton, eType, engine);

        return icEngined;
      }

      setActiveObject(icObj) {
        icObj.im_active_now = true;
      }


      createIcGMClickWell(trueRect, value_in = -48) {
        console.log("createIcClickWell", trueRect);

        const infiniteCanvas = this;

        // const type      = "clickWell";
        const type      = "button";

        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const buttonFunc = (scopeObj) => {
          console.log("buttonFunc", scopeObj);
          const button = scopeObj.engineCarrier;
          button.fill  = Color.randomColor();

          //create/add new spawn
          const infiniteCanvas = scopeObj.infiniteCanvas;

          const spawn = infiniteCanvas.createIcGreenMouse(trueRect, value_in);

          infiniteCanvas.addIcObject(spawn);
        };

        const buttonConfig = {
          buttonFunc: buttonFunc,
        };


        const icButton_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 1,
          fill: "lightgray",

          buttonConfig: buttonConfig,
        };

        const icButton = Object.assign(icObj, icButton_spec);


        const engine = new ButtonEngine();
        const eType  = "button";

        const icEngined = infiniteCanvas.createIcEngined(icButton, eType, engine);

        return icEngined;
      }


      createIcGreenMouse(trueRect, value_in = 1) {
        console.log("createIcGreenMouse", trueRect);

        const infiniteCanvas = this;

        // const type      = "greenMouse";


        const mathNode        = new math.ConstantNode(value_in);
        mathNode.autoSimplify = true;
        const spawn = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);



        infiniteCanvas.onceOnAddRepresentedForIcObject(spawn, (spawn) => {

          //set spawn as active object
          const spawn__represented = infiniteCanvas.getRepresented(spawn.id);
          const spawn__rep_free    = spawn__represented.r_free();

          //greenMouseify
          infiniteCanvas.greenMouseify(spawn__rep_free);
          spawn__rep_free.onHold(() => {
            spawn__rep_free.curse_greenMouse_start();
          })

        });


        return spawn;
      }


      createIcBornAgainGreenMouse(trueRect, mathNode_in = new math.ConstantNode(1)) {
        console.log("createIcBornAgainGreenMouse", trueRect);

        const infiniteCanvas = this;

        // const type      = "bornAgainGreenMouse";


        const mathNode        = mathNode_in;
        // mathNode.autoSimplify = true;

        const spawn = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        spawn.isTouchable = true;


        infiniteCanvas.onceOnAddRepresentedForIcObject(spawn, (spawn) => {

          //set spawn as active object
          const spawn__represented = infiniteCanvas.getRepresented(spawn.id);
          const spawn__rep_free    = spawn__represented.r_free();

          //greenMouseify
          infiniteCanvas.greenMouseify(spawn__rep_free);
          spawn__rep_free.onHold(() => {
            spawn__rep_free.curse_greenMouse_start();
          });

          //bornAgainify
          infiniteCanvas.bornAgainify(spawn__rep_free);
          //spawn__rep_free.onHold(() => {
            spawn__rep_free.curse_bornAgain_start();
          //});

        });



        return spawn;
      }


      createIcGreenMouseBox(trueRect, mathNode_in = new math.ConstantNode(1)) {
        console.log("createIcBornAgainGreenMouseBox", trueRect);

        const infiniteCanvas = this;

        // const type      = "bornAgainGreenMouse";


        const mathNode        = mathNode_in;
        // mathNode.autoSimplify = true;


        const facade      = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        const contactArea = infiniteCanvas.createIcRect(trueRect);
        contactArea.fill = "lightblue";

        const parts = {
          contactArea: contactArea,
          facade:      facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_box";

        const greenMouseBox = icComposite;
        greenMouseBox.isTouchable = true;
        // greenMouseBox.canBeHeld   = true;


        infiniteCanvas.onceOnAddRepresentedForIcObject(greenMouseBox, (greenMouseBox) => {

          //set spawn as active object
          const greenMouseBox__represented = infiniteCanvas.getRepresented(greenMouseBox.id);
          const greenMouseBox__rep_free    = greenMouseBox__represented.r_free();

          //greenMouseify
          const facade__rep_free    = greenMouseBox__rep_free.parts.facade;

          greenMouseBox__rep_free.die = () => {
            greenMouseBox__rep_free.im_dying_now = true;
          };

          infiniteCanvas.greenMouseify(facade__rep_free);
            //rewrite greenMouse.die
          facade__rep_free.die = () => {
            // logger.log("greenMouse, die (override)");
            greenMouseBox__rep_free.die();
          };

          facade__rep_free.onHold(() => {
            // logger.log("greenMouseBox__rep_free", "curse_greenMouse_start");
            facade__rep_free.curse_greenMouse_start();
          });

        });

        return greenMouseBox;
      }

      createIcBornAgainGreenMouseBox(trueRect, mathNode_in = new math.ConstantNode(1)) {
        console.log("createIcBornAgainGreenMouseBox", trueRect);

        const infiniteCanvas = this;

        // const type      = "bornAgainGreenMouse";


        const mathNode        = mathNode_in;
        // mathNode.autoSimplify = true;


        const facade      = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        const contactArea = infiniteCanvas.createIcRect(trueRect);
        contactArea.fill = "lightblue";

        const parts = {
          contactArea: contactArea,
          facade:      facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_box";

        const greenMouseBox = icComposite;
        greenMouseBox.isTouchable = true;


        infiniteCanvas.onceOnAddRepresentedForIcObject(greenMouseBox, (greenMouseBox) => {

          //set spawn as active object
          const greenMouseBox__represented = infiniteCanvas.getRepresented(greenMouseBox.id);
          const greenMouseBox__rep_free    = greenMouseBox__represented.r_free();

          //greenMouseify
          infiniteCanvas.greenMouseify(greenMouseBox__rep_free);
          greenMouseBox__rep_free.onHold(() => {
            greenMouseBox__rep_free.curse_greenMouse_start();
          });

          //bornAgainify
          infiniteCanvas.bornAgainify(greenMouseBox__rep_free);
          //spawn__rep_free.onHold(() => {
            greenMouseBox__rep_free.curse_bornAgain_start();
          //});

        });



        return greenMouseBox;
      }



      createIcExoSkeleton(/*icObj__heart,*/ exoSkeletonConfig) {
        console.log("createIcExoSkeleton", /*icObj__heart,*/ exoSkeletonConfig);

        const infiniteCanvas = this;

        function easyTrueRectWithTrueRect(trueRect, position_easy) {
          var outTrueRect;

          const trueRect_clone = Object.assign({}, trueRect);
          switch(position_easy) {
            case "left":
              outTrueRect = trueRect_clone;
              outTrueRect.x = outTrueRect.x - outTrueRect.width;
              break;
            case "right":
              outTrueRect = trueRect_clone;
              outTrueRect.x = outTrueRect.x + outTrueRect.width;
              break;
            case "top":
              outTrueRect = trueRect_clone;
              outTrueRect.y = outTrueRect.y - outTrueRect.height;
              break;
            case "bottom":
              outTrueRect = trueRect_clone;
              outTrueRect.y = outTrueRect.y + outTrueRect.height;
              break;
            case "center":
              outTrueRect = trueRect_clone;
              break;
            default:
              throw new Error("Unsupported position_easy: " + position_easy);
              break;
          }

          return outTrueRect;
        }

        const trueRect__heart = {
          x:      icObj__heart.position.x,
          y:      icObj__heart.position.y,
          width:  icObj__heart.size.width,
          height: icObj__heart.size.height,
        };


        const icObj__display = icObj__heart.deepClone();
        icObj__display.stroke      = "red";
        icObj__display.strokeWidth = 5;



        const icObj__grab   = infiniteCanvas.createIcRect(trueRect__heart);
        icObj__grab.fill = "green";
        const trueRect__grab = easyTrueRectWithTrueRect(trueRect__heart, exoSkeletonConfig.grab.position_easy);
        icObj__grab.position = {
          x: trueRect__grab.x,
          y: trueRect__grab.y,
        };

        const icObj__contact = infiniteCanvas.createIcRect(trueRect__heart);
        icObj__contact.fill  = "lightblue";
        const trueRect__contact = easyTrueRectWithTrueRect(trueRect__heart, exoSkeletonConfig.contact.position_easy);
        icObj__contact.position = {
          x: trueRect__contact.x,
          y: trueRect__contact.y,
        };

        const parts = {
          heart:      icObj__heart,

          display:    icObj__display,
          grab:       icObj__grab,
          contact:    icObj__contact,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect__heart, parts, compositeConfig);
        icComposite.cType = "exoSkeleton";

        return icComposite;
      }








      createIcWell(trueRect) {
        console.log("createIcWell", trueRect);

        const startingValue = 1;

        const canSnapFunc  = (above, below) => {
          var outBool;

          const canSnapFunc_geometryWise = (above, below) => {
            // return Snap.canSnap(above, below);
            return Snap.canSnap_noSize(above, below);
          };

          // const canSnapFunc_valueWise    = (above, below) => (above.value == targetValue);
          // const canSnapFunc_valueWise    = (above, below) => {
          //   const value = parseInt(above.text,10);
          //   const isValueValid = (value == targetValue);
          //   return isValueValid;
          // };

          const canSnapFuncs = {
            "geometry": canSnapFunc_geometryWise,
            // "value":    canSnapFunc_valueWise,
          };

          const canSnapFunc_allWise = (above, below) => Object.entries(canSnapFuncs).reduce((acc, [canSnapFunc_xWiseName, canSnapFunc_xWise]) => {
            const canSnap_xWise = canSnapFunc_xWise(above,below);
            console.log("canSnap_xWise", canSnapFunc_xWiseName, canSnap_xWise);
            return acc && canSnap_xWise;
          }, true);

          const canSnap_allWise = canSnapFunc_allWise(above, below);
          console.log("canSnap_allWise", canSnap_allWise);

          outBool = canSnap_allWise;

          return outBool;
        };
        const canUnsnapFunc  = (above, below) => {
          return Snap.canUnsnap(above, below);
        };
        // const snapMutationFunc  = (above, below) => {   //SHU TODO: toSnapState mutations: toPresnapped, toSnapped, toUnsnapped
        //   //how rep_snapped  will differ from rep_official
        //   //how snappedState will differ from rep_official
        // };
        const snapSlotConfig = {
          canSnapFunc  : canSnapFunc,
          canUnsnapFunc: canUnsnapFunc,
        };

        const snapSlot     = infiniteCanvas.createIcSnapSlot(trueRect, snapSlotConfig);
        snapSlot.fill      = "lightblue";
        snapSlot.isMobile  = false;

        const text          = startingValue.toString(10);
        const stem          = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        stem.textColor       = "blue";
        stem.backgroundColor = "";
        stem.isMobile       = true;
        stem.isTouchable    = true;

        const parts = {
          // "snapSlot": snapSlot,
          "stem":     stem,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "well";

        // icComposite.isTouchable = false;


        // snapEngine.will['unsnap'].on((snapSlot, icObj) => {
        //   console.log("well, snapEngine.will['unsnap']", snapSlot, icObj);
        //
        //   const cloned = icObj.deepClone();
        //   cloned.snapState = SnapState.Unsnapped;
        //   cloned.position = Object.assign({}, snapSlot.position);
        //   infiniteCanvas.addIcObject(cloned);
        //
        //   // snapEngine.clonedObj = cloned;
        // });


        // infiniteCanvas.onceOnAddRepresentedForIcObject(stem, (stem) => {
        //
        //   //get free rep
        //   const represented = infiniteCanvas.getRepresented(stem.id);
        //   console.log("represented", represented);
        //   const rep_free = represented.r_free();
        //
        //   infiniteCanvas.greenMouseify(rep_free);
        //
        //   rep_free.curse_greenMouse_start();
        // });


        return icComposite;
      }






      greenMouseify(rep) {
        console.log("greenMouseify", rep);

        rep.die = () => {
          // logger.log("greenMouse, die");
          rep.im_dying_now = true;
        };

        rep.curse_greenMouse_do = (icObj) => {
          console.log("curse_greenMouse_do");
          rep.curse_greenMouse_end();
          rep.die();
        };

        rep.curse_greenMouse_start = () => {
          rep.onRelease(rep.curse_greenMouse_do);
        };

        rep.curse_greenMouse_end = () => {
          rep.offRelease(rep.curse_greenMouse_do);
        };

        // rep.curse_greenMouse_start = () => {
        //   if(rep.cType == "gm_box") {
        //     rep.parts.facade.onRelease(rep.curse_greenMouse_do);
        //   } else {
        //     rep.onRelease(rep.curse_greenMouse_do);
        //   }
        // };
        //
        // rep.curse_greenMouse_end = () => {
        //   if(rep.cType == "gm_box") {
        //     rep.parts.facade.offRelease(rep.curse_greenMouse_do);
        //   } else {
        //     rep.offRelease(rep.curse_greenMouse_do);
        //   }
        // };

      }


      bornAgainify(rep) {
        console.log("bornAgainify", rep);

        const infiniteCanvas = this;

        if(rep.die == null) {
          throw new Error("Can't resurrect what doesn't die");
        }
        Hooker.installHooks(rep, "die");

        if(rep.number_replica == null) {
          rep.number_replica = 0;
        }

        const stem = rep.clone();
        // stem.mathNode = rep.mathNode.cloneDeep();

        rep.prepareForResurrection = () => {

        };

        rep.resurrect = () => {
          console.log("resurrect");

          //born again
          const resurrected = stem.clone();
          // logger.log("resurrected", resurrected);
          resurrected.mathNode = stem.mathNode;

          const id_resurrected = this.generateIcObjectId();
          resurrected.id       = id_resurrected;

          resurrected.number_replica = stem.number_replica + 1;

          infiniteCanvas.addIcObject(resurrected);


          //cursed again
            //SHU TODO: better management of curses
          const spawn__represented = infiniteCanvas.getRepresented(resurrected.id);
          const spawn__rep_free    = spawn__represented.r_free();

            //greenMouseify
          infiniteCanvas.greenMouseify(spawn__rep_free);
          spawn__rep_free.onHold(() => {
            spawn__rep_free.curse_greenMouse_start();
          })

            //bornAgainify
          infiniteCanvas.bornAgainify(spawn__rep_free);
          spawn__rep_free.curse_bornAgain_start();

        };

        rep.curse_bornAgain_start = () => {
          rep.will["die"].on(rep.prepareForResurrection);
          rep.did["die"].on(rep.resurrect);
        };

        rep.curse_bornAgain_end = () => {
          rep.did["die"].off(rep.resurrect);
        };



        //not that easy to die
        // Object.defineProperty(rep, 'im_dying_now', {
        //   get() { return false; },
        //   set(newValue) { rep.lolilol = newValue; },
        //   enumerable: true,
        //   configurable: true
        // });

      }

      // createCurseTrigger_countdown() {
      //
      //   const curseTrigger = new CurseTrigger_countdown();
      //
      //   return curseTrigger;
      // }

      createCurse_metamorphosis(curseTrigger) {
        logger.log("createCurse_metamorphosis", curseTrigger);


        // const facade_represented = infiniteCanvas.getRepresented(facade.id);
        // const facade_rep_free    = facade_represented.r_free();
        //
        // const mathNode = new math.ConstantNode(stepIndex);
        // facade_rep_free.mathNode = mathNode;

        const curseFunc = (rep_free) => {
          // logger.log("curseFunc, rep_free:", rep_free);
          const mathNode = random_constantNode();
          rep_free.mathNode = mathNode;
        };

        const curse_metamorphosis = this.createCurse(curseTrigger);
        // logger.log("curse_metamorphosis.curseTrigger", curse_metamorphosis.curseTrigger);

        curse_metamorphosis.curseFunc           = curseFunc;
        curse_metamorphosis.rx_countDownCounter = curseTrigger.engine.rx_countDownCounter;

        return curse_metamorphosis;
      }

      createCurse(curseTrigger) {
        // logger.log("createCurse", curseTrigger);

        const curse = new Curse(curseTrigger);

        return curse;
      }

      accurse__metamorphosis(rep_free) {
        const infiniteCanvas = this;

        const curseTrigger_countdown = new CurseTrigger_countdown();
        const curse_metamorphosis = this.createCurse_metamorphosis(curseTrigger_countdown);

        curse_metamorphosis.reset = function() {
          const curseTrigger_countdown = new CurseTrigger_countdown();
          curseTrigger_countdown.curse = curse_metamorphosis;

          curse_metamorphosis.curseTrigger        = curseTrigger_countdown;
          curse_metamorphosis.rx_countDownCounter = curseTrigger_countdown.engine.rx_countDownCounter;


          // infiniteCanvas.accurse__metamorphosis(rep_free);   //SHU: does not work
        };

        rep_free.curse_metamorphosis = curse_metamorphosis;
      }




      createIcGreenMouseWell(trueRect) {

      }

      mutateGreenMouseWell__addReactivePart(icGreenMouseWell) {

      }

      createIcGMOperator(trueRect, operatorString_in = null) {
        console.log("createIcGMOperator", trueRect);

        var operatorConfig;
        if(operatorString_in == null) {
          const rank     = this.getNextTouchSlotRank();
          operatorConfig = GMOperatorMama.operatorConfigForRank(rank);
        } else {
          const text_in = operatorString_in;
          const transformationFunc = (new GMOperatorTextChangeEngine()).transformationFuncForText(text_in);

          operatorConfig = new OperatorConfig(text_in, transformationFunc);
        }

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot    = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill     = "";
        // touchSlot.isMobile = false;

        const text         = operatorConfig.name;
        const facade       = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade":    facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_operator";

        // icComposite.isTouchable = false;

        return icComposite;
      }

      createIcGMOperator_withType(trueRect, gmOperatorType) {
        console.log("createIcGMOperator_withType", trueRect, gmOperatorType);

        function operatorConfigForType(gmOperatorType) {

          var operatorConfig = {
            name: "",
            transformationFunc: null,
          };

          switch(gmOperatorType) {
            case "simplify":
            {
              operatorConfig.name = "s";
              const transformationFunc = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  const node_unsimplified = node_in;

                  const node_simplified = math.simplify(node_unsimplified);
                  outNode = node_simplified;

                  outNode.autoSimplify = node_in.autoSimplify;

                  return outNode;
                }

                if(node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left     = standardOperation(node_a.params[0]);
                  const node_right    = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                return outNode;
              };
              operatorConfig.transformationFunc = transformationFunc;
            }
            break;
            case "simplify__step_by_step":
            {
              operatorConfig.name = "st";
              const transformationFunc = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  if(node_in.type == "OperatorNode") {

                    const depth = getDepth(node_in);

                    if(depth > 2) {
                      console.log("___st A");

                      //'innermost first' simplify

                      const arr_deep_first__treeObj  = getArr_deep_first__treeObj(node_in);
                      console.log("arr_deep_first__treeObj", arr_deep_first__treeObj);

                      const arr_deep_first__treeObj__operatorNode  = arr_deep_first__treeObj.filter(treeObj => (treeObj.node.type == "OperatorNode"));

                      const treeObj_operatorNode__first_unsimplified = arr_deep_first__treeObj__operatorNode.find(treeObj => !treeObj.node.isSimplified);

                      const node_unsimplified       = treeObj_operatorNode__first_unsimplified.node;
                      console.log("node_unsimplified", node_unsimplified);
                      const path__node_unsimplified = treeObj_operatorNode__first_unsimplified.path;

                      const node_simplified = math.simplify(node_unsimplified);
                      node_simplified.isSimplified = true;
                      console.log("node_simplified", node_simplified);

                      const node_mutated = operatorNodeBySettingNodeAtPath(node_in, node_simplified, path__node_unsimplified);

                      outNode = node_mutated;

                    } else {
                      console.log("___st B");

                      //simple simplify

                      const node_unsimplified = node_in;

                      const node_simplified = math.simplify(node_unsimplified);
                      node_simplified.isSimplified = true;

                      outNode = node_simplified;

                    }

                  } else {
                    console.log("___st C");

                    //simple simplify

                    const node_unsimplified = node_in;

                    const node_simplified = math.simplify(node_unsimplified);
                    node_simplified.isSimplified = true;

                    outNode = node_simplified;

                  }

                  outNode.autoSimplify = node_in.autoSimplify;

                  return outNode;
                }

                if(node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left     = standardOperation(node_a.params[0]);
                  const node_right    = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                return outNode;
              };
              operatorConfig.transformationFunc = transformationFunc;
            }
            break;


            case "simplify__top_layer":
            {
              operatorConfig.name = "stl";
              const transformationFunc = (node_a) => {
                var outNode;

                // function standardOperation(node_in) {
                //   var outNode;
                //
                //   if(node_in.type == "OperatorNode") {
                //
                //     const depth = getDepth(node_in);
                //
                //     if(depth > 2) {
                //       console.log("___st A");
                //
                //       //'outermost first' simplify
                //
                //       function isTerminalType(mathNode) {
                //         const type = mathNode.type;
                //         return ( (type == "ConstantNode") || (type == "SymbolNode") );
                //       }
                //
                //       const operator__layerN          = node_in;
                //       const arr_child__layerN         = operator__layerN.args;
                //       const terminal__layerN          = arr_child__layerN.filter(child => isTerminalType(child)).find(e => true);
                //
                //       const operator__layerN_minus_1      = arr_child__layerN.filter(child => (child.type == "OperatorNode") ).find(e => true);
                //       const arr_child__layerN_minus_1     = operator__layerN_minus_1.args;
                //       // const terminal__layerN_minus_1      = arr_child__layerN_minus_1.filter(child => isTerminalType(child)).find(e => true);
                //       const arr_terminal__layerN_minus_1  = arr_child__layerN_minus_1.filter(child => isTerminalType(child));
                //
                //       function isSameTerminal(termNode1, termNode2) {
                //         var outBool;
                //
                //         function isSameTerminalType(termNode1, termNode2) {
                //           return (termNode1.type == termNode2.type);
                //         }
                //
                //         const isSameTerminalType_ = isSameTerminalType(termNode1, termNode2);
                //         console.log("isSameTerminalType_", isSameTerminalType_);
                //
                //         if(!isSameTerminalType_) {
                //           return false;                 //j'aime pas trop ça mais bon...
                //         }
                //
                //         function isSameTerminalContent(termNode1, termNode2) {
                //           console.log("isSameTerminal", termNode1, termNode2);
                //           var outBool;
                //
                //           switch(termNode1.type) {
                //             case "SymbolNode":
                //               outBool = (termNode1.name == termNode2.name);
                //             break;
                //             case "ConstantNode":
                //               outBool = (termNode1.value == termNode2.value);
                //             break;
                //             default:
                //               throw new Error("unsupported type", termNode1.type);
                //               break;
                //           }
                //
                //           return outBool;
                //         }
                //
                //         outBool = isSameTerminalContent(termNode1, termNode2);
                //
                //         return outBool;
                //       }
                //
                //       const sameTerminal = arr_terminal__layerN_minus_1.find(term__layerN_minus_1 => isSameTerminal(terminal__layerN, term__layerN_minus_1));
                //       if(!sameTerminal) {
                //         return node_in;
                //       }
                //
                //       function isInverseOperators(opNode1, opNode2) {
                //         console.log("isInverseOperators", opNode1, opNode2);
                //         var outBool;
                //
                //         const set_opFunc = new Set([opNode1.fn, opNode2.fn]);
                //         console.log("set_opFunc", set_opFunc);
                //
                //         /*Set utils*/
                //         function eqSet(as, bs) {
                //             return as.size === bs.size && all(isIn(bs), as);
                //         }
                //
                //         function all(pred, as) {
                //             for (var a of as) if (!pred(a)) return false;
                //             return true;
                //         }
                //
                //         function isIn(as) {
                //             return function (a) {
                //                 return as.has(a);
                //             };
                //         }
                //         /**/
                //
                //
                //
                //         const arr_set_inverse = [
                //           new Set(["multiply", "divide"]),
                //           new Set(["add", "subtract"]),
                //         ];
                //
                //         outBool = arr_set_inverse.reduce((acc, x) => {
                //           if(eqSet(set_opFunc, x)) {
                //             acc = true;
                //           }
                //           return acc;
                //         }, false);
                //
                //         return outBool;
                //       }
                //
                //       const isInverseOperators_ = isInverseOperators(operator__layerN_minus_1, operator__layerN);
                //       console.log("isInverseOperators_", isInverseOperators_);
                //       if(!isInverseOperators_) {
                //         return node_in;
                //       }
                //
                //       const node__layerN_minus_2      = arr_child__layerN_minus_1.filter(child => child != sameTerminal).find(e => true);
                //
                //       //remove parentheses if any
                //       // if(node__layerN_minus_2.type == "ParenthesisNode") {
                //       //   const contentNode = node__layerN_minus_2.content;
                //       //   outNode = contentNode;
                //       // } else {
                //       //   outNode = node__layerN_minus_2;
                //       // }
                //
                //       outNode = node__layerN_minus_2;
                //
                //     } else {
                //       console.log("___st B");
                //
                //       //simple simplify
                //
                //       const node_unsimplified = node_in;
                //
                //       const node_simplified = math.simplify(node_unsimplified);
                //       node_simplified.isSimplified = true;
                //
                //       outNode = node_simplified;
                //
                //     }
                //
                //   } else {
                //     console.log("___st C");
                //     console.log("node_in", node_in);
                //
                //     //simple simplify
                //
                //     const node_unsimplified = node_in;
                //
                //     const node_simplified = math.simplify(node_unsimplified);   //SHU: boom
                //     node_simplified.isSimplified = true;
                //
                //     outNode = node_simplified;
                //
                //   }
                //
                //   outNode.autoSimplify = node_in.autoSimplify;
                //
                //   return outNode;
                // }

                const operation = Simplifier.simplify_top_layer;

                if(node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left     = operation(node_a.params[0]);
                  const node_right    = operation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = operation(node_a);
                }

                return outNode;
              };

              const icObjTransformationFunc = (icObj) => {
                var outIcObj;

                outIcObj = icObj.clone();

                // logger.log("icObj.mathNode", icObj.mathNode);
                outIcObj.mathNode = transformationFunc(icObj.mathNode);

                return outIcObj;
              };

              operatorConfig.transformationFunc = icObjTransformationFunc;
            }
            break;

            case "simplify__remove_parentheses":
            {
              operatorConfig.name = "srp";
              const transformationFunc = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  if(node_in.type == "ParenthesisNode") {
                    const contentNode = node_in.content;
                    outNode = contentNode;
                  } else {
                    outNode = node_in;
                  }

                  outNode.autoSimplify = node_in.autoSimplify;

                  return outNode;
                }

                if(node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left     = standardOperation(node_a.params[0]);
                  const node_right    = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                return outNode;
              };
              operatorConfig.transformationFunc = transformationFunc;
            }
            break;



            case "split__top_layer":
            {
              operatorConfig.name = "sptl";
              const transformationFunc = (node_a) => {
                var outArr;

                const operation = Splitter.split_top_layer;

                if(node_a.isEquation) {
                  // console.log("node_a", node_a);
                  // const node_left     = operation(node_a.params[0]);
                  // const node_right    = operation(node_a.params[1]);
                  // const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  // node_equation.isEquation = true;
                  //
                  // outNode = node_equation;
                  throw new Error("unsupported (yet): split equation");
                } else {
                  outArr = operation(node_a);
                }

                return outArr;
              };

              const icObjTransformationFunc = (icObj) => {
                var outIcObj;

                logger.log("icObj.mathNode", icObj.mathNode);
                const arr_mathNodes = transformationFunc(icObj.mathNode);
                logger.log("arr_mathNodes", arr_mathNodes);

                const trueRect = {
                  x:      icObj.position.x,
                  y:      icObj.position.y,
                  width:  icObj.size.width,
                  height: icObj.size.height,
                };

                const arr_icMathNode = arr_mathNodes.map((mathNode, index) => {
                  const icMathNode = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
                  return icMathNode;
                })

                const parts           = arr_icMathNode;
                const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
                const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);

                const icObj__new = icComposite;

                //debug
                // const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "new_object");
                // // const icObj__new = icText;
                // const parts           = [icText];
                // const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
                // const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
                // const icObj__new = icComposite;


                // outIcObj = icComposite;
                // return outIcObj;
                const transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                return transformationOutput;
              };

              operatorConfig.transformationFunc = icObjTransformationFunc;
            }
            break;


            case "morpher__math_to_text":
            {
              operatorConfig.name = "morph: m→t";

              const icObjTransformationFunc = (icObj) => {
                var transformationOutput;

                if(icObj.type == "mathNode") {
                  const x = icObj.position.x;
                  const y = icObj.position.y;
                  const str = icObj.mathNode.toString();
                  const icObj__new = infiniteCanvas.createIcText(x,y,str);
                  transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                } else {
                  logger.log("icObj.type:", icObj.type);
                  transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                }

                return transformationOutput;
              };

              operatorConfig.transformationFunc = icObjTransformationFunc;
            }
            break;

            case "morpher__text_to_math":
            {
              operatorConfig.name = "morph: t→m";

              const icObjTransformationFunc = (icObj) => {
                var transformationOutput;

                if(icObj.type == "text") {
                  const x = icObj.position.x;
                  const y = icObj.position.y;
                  const mathNode = math.parse(icObj.text);
                  const icObj__new = infiniteCanvas.createIcMathNode(x,y,mathNode);
                  transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                } else {
                  logger.log("icObj.type:", icObj.type);
                  transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                }

                return transformationOutput;
              };

              operatorConfig.transformationFunc = icObjTransformationFunc;
            }
            break;

            case "decomposition__product_primes":
            {
              operatorConfig.name = "decomp:prpr";

              const icObjTransformationFunc = (icObj) => {
                var transformationOutput;

                if(icObj.type == "mathNode") {
                  const x = icObj.position.x;
                  const y = icObj.position.y;
                  const mathNode = icObj.mathNode;
                  const mathNode_new = Rewriter.decomposition_product_primes(mathNode);

                  const icObj__new = infiniteCanvas.createIcMathNode(x,y,mathNode_new);
                  transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                } else {
                  logger.log("icObj.type:", icObj.type);
                  transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                }

                return transformationOutput;
              };

              operatorConfig.transformationFunc = icObjTransformationFunc;
            }
            break;


            case "inverse":
            {
              operatorConfig.name = "inverse";

              const icObjTransformationFunc = (icObj) => {
                var transformationOutput;

                if(icObj.type == "mathNode") {
                  const x = icObj.position.x;
                  const y = icObj.position.y;
                  const mathNode = icObj.mathNode;
                  const mathNode_new = Inverser.inverse(mathNode);

                  const icObj__new = infiniteCanvas.createIcMathNode(x,y,mathNode_new);
                  transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                } else {
                  logger.log("icObj.type:", icObj.type);
                  transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                }

                return transformationOutput;
              };

              operatorConfig.transformationFunc = icObjTransformationFunc;
            }
            break;

            case "singleOperatorize":
            {
              operatorConfig.name = "s:singleOperatorize";

              const icObjTransformationFunc = (icObj) => {
                var transformationOutput;

                if(icObj.type == "mathNode") {
                  const x = icObj.position.x;
                  const y = icObj.position.y;
                  const mathNode = icObj.mathNode;
                  const mathNode_new = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode);

                  const icObj__new = infiniteCanvas.createIcMathNode(x,y,mathNode_new);
                  transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                } else {
                  logger.log("icObj.type:", icObj.type);
                  transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                }

                return transformationOutput;
              };

              operatorConfig.transformationFunc = icObjTransformationFunc;
            }
            break;

            case "simplify__topPriorityShell":
            {
              operatorConfig.name = "s:tpsh";

              const icObjTransformationFunc = (icObj) => {
                var transformationOutput;

                if(icObj.type == "mathNode") {
                  const x = icObj.position.x;
                  const y = icObj.position.y;
                  const mathNode = icObj.mathNode;
                  const mathNode_new = Simplifier.simplify_top_priorityShell(mathNode);

                  const icObj__new = infiniteCanvas.createIcMathNode(x,y,mathNode_new);
                  transformationOutput = new TransformationOutput("new", icObj__new, icObj);
                } else {
                  logger.log("icObj.type:", icObj.type);
                  transformationOutput = new TransformationOutput("mutated", icObj, icObj);
                }

                return transformationOutput;
              };

              operatorConfig.transformationFunc = icObjTransformationFunc;
            }
            break;




          }

          return operatorConfig;
        }


        const operatorConfig = operatorConfigForType(gmOperatorType);

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot    = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill     = "";
        // touchSlot.isMobile = false;

        const text         = operatorConfig.name;
        const facade       = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isMobile    = false;
        // facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade":    facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_operator";

        // icComposite.isTouchable = false;

        return icComposite;
      }

      createIcGMOperator_editable(trueRect, text_in) {
        console.log("createIcGMOperator", trueRect, text_in);

        const transformationFunc = (new GMOperatorTextChangeEngine()).transformationFuncForText(text_in);

        const operatorConfig = {
          name: text_in,
          transformationFunc: transformationFunc,
        };

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot    = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill     = "";

        const text             = operatorConfig.name;
        const facade           = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        // facade.isTouchable     = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade":    facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_operator";

        // icComposite.isTouchable = false;


        const engineCarrier = icComposite;
        const engine        = new GMOperatorTextChangeEngine();
        const eType         = "gmOperator_editable";

        const icEngined = infiniteCanvas.createIcEngined(engineCarrier, eType, engine);


        return icEngined;
      }




      createIcGMTargetSlot(trueRect) {
        console.log("createIcGMTargetSlot", trueRect);

        const targetValue = -48;

        const text          = targetValue.toString(10);
        const backade       = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        backade.backgroundColor = "grey";
        backade.isMobile    = false;
        // backade.isTouchable = false;

        const canSnapFunc  = (above, below) => {
          var outBool;

          const canSnapFunc_geometryWise = (above, below) => {
            // return Snap.canSnap(above, below);
            return Snap.canSnap_noSize(above, below);
          };

          // const canSnapFunc_valueWise    = (above, below) => (above.value == targetValue);
          const canSnapFunc_valueWise    = (above, below) => {
            const value = parseInt(above.text,10);
            const isValueValid = (value == targetValue);
            return isValueValid;
          };

          const canSnapFuncs = {
            "geometry": canSnapFunc_geometryWise,
            "value":    canSnapFunc_valueWise,
          };

          const canSnapFunc_allWise = (above, below) => Object.entries(canSnapFuncs).reduce((acc, [canSnapFunc_xWiseName, canSnapFunc_xWise]) => {
            const canSnap_xWise = canSnapFunc_xWise(above,below);
            console.log("canSnap_xWise", canSnapFunc_xWiseName, canSnap_xWise);
            return acc && canSnap_xWise;
          }, true);

          const canSnap_allWise = canSnapFunc_allWise(above, below);
          console.log("canSnap_allWise", canSnap_allWise);

          outBool = canSnap_allWise;

          return outBool;
        };
        const canUnsnapFunc  = (above, below) => {
          return Snap.canUnsnap(above, below);
        };
        // const snapMutationFunc  = (above, below) => {   //SHU TODO: toSnapState mutations: toPresnapped, toSnapped, toUnsnapped
        //   //how rep_snapped  will differ from rep_official
        //   //how snappedState will differ from rep_official
        // };
        const snapSlotConfig = {
          canSnapFunc  : canSnapFunc,
          canUnsnapFunc: canUnsnapFunc,
        };

        const snapSlot     = infiniteCanvas.createIcSnapSlot(trueRect, snapSlotConfig);
        snapSlot.fill      = "";
        snapSlot.isMobile  = false;


        const parts = {
          "backade":  backade,
          "snapSlot": snapSlot,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_targetSlot";

        // icComposite.isTouchable = false;


        return icComposite;
      }


      createIcGMTargetTouchSlot(trueRect, targetValue_in) {
        console.log("createIcGMTargetTouchSlot", trueRect);

        var targetValue = targetValue_in;
        if(targetValue == null) {
          targetValue = -48;
        }


        const canTouchFunc_geometryWise = (above, below, context) => {
          return Touch.canTouch(above, below);
        };

        // const canTouchFunc_valueWise = (above, below) => {
        //   const value = parseInt(above.text,10);
        //   const isValueValid = (value == targetValue);
        //   return isValueValid;
        // };

        const canTouchFunc_valueWise = (above, below, context) => {
          logger.log("canTouchFunc_valueWise", above, below, context);
          var outBool;

          // const touchSlot = below;
          const facade    = context.facade;

          var mathNode__above;
          // const mathNode__above = above.mathNode;
          // const mathNode__above = above.parts.facade.mathNode;
          if(above.mathNode != null) {
            mathNode__above = above.mathNode;
          } else if(above.parts.facade.mathNode != null) {
            mathNode__above = above.parts.facade.mathNode;
          } else {
            throw new Error("unsupported situation: canTouchFunc_valueWise");
          }
          logger.log("mathNode__above", mathNode__above);
          const mathNode__below = facade.mathNode;
          logger.log("mathNode__below", mathNode__below);

          function isSameValue(mathNode_1, mathNode_2) {
            var outBool;

            function isContainingSymbolNode(mathNode) {
              var outBool;

              switch(mathNode.type) {
                case "OperatorNode":
                  const operatorNode = mathNode;
                  outBool = Utils.early_break_reduce(operatorNode.args, (acc,x,i,arr) => {
                    // logger.log("early_break_reduce", x.x);

                    const isChildContainingSymbolNode = isContainingSymbolNode(x);

                    return acc || isChildContainingSymbolNode;
                  }, true, (acc, x, i, arr) => {
                    return (acc == true);
                  });
                  break;
                case "ParenthesisNode":
                  const parenthesisNode = mathNode;
                  outBool = isContainingSymbolNode(parenthesisNode.content);
                  break;
                case "SymbolNode":
                  outBool = true;
                  break;
                default:
                  outBool = false;
                  break;
                }

              return outBool;
            }

            const isSymbolNode_in_either = isContainingSymbolNode(mathNode_1) || isContainingSymbolNode(mathNode_2);
            if(isSymbolNode_in_either) {

              function evaluateMathNode(mathNode, dict_subst) {
                return mathNode.evaluate(dict_subst);
              }

              function evaluation_grid(mathNode_1, mathNode_2) {
                var outBool;

                const arr_dict_subst = [
                  {
                    x: 0,
                  },
                  {
                    x: 1,
                  },
                  {
                    x: -1,
                  },
                ];

                //early break reduce
                outBool = Utils.early_break_reduce(arr_dict_subst, (acc,x,i,arr) => {
                  // logger.log("early_break_reduce", x.x);

                  const ev_1 = evaluateMathNode(mathNode_1, x);
                  const ev_2 = evaluateMathNode(mathNode_2, x);

                  const isEqual_ev = (ev_1 == ev_2);

                  return acc && isEqual_ev;
                }, true, (acc, x, i, arr) => {
                  return (acc == false);
                });

                return outBool;
              }

              outBool = evaluation_grid(mathNode_1, mathNode_2);
              if(outBool) {
                return outBool;
              }



              const expr__mathNode_1 = mathNode_1.toString();
              const expr__mathNode_2 = mathNode_2.toString();

              const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
              const algebrite_result = Algebrite.run(expr__equality);

              outBool = (algebrite_result == true);

            } else {

              const relationalNode = new math.RelationalNode(['equal'], [mathNode__above, mathNode__below]);
              // logger.log("relationalNode", relationalNode);

              outBool = relationalNode.evaluate();
            }

            return outBool;
          }


          const isSameValue_ = isSameValue(mathNode__above, mathNode__below);
          console.log("isSameValue_", isSameValue_);


          outBool = isSameValue_;

          return outBool;
        };


        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value":    canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above,below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;

        const transformationFunc = (icObj) => {
          var outIcObj;

          console.log("yey");

          outIcObj = icObj.clone();

          outIcObj.fill = "yellow";
          outIcObj.color = "white";

          // outIcObj.im_dying_now = true;


          // icObj.text = "touched";
          // icObj.text += " : yey!";

          // icObj.mathNode = icObj.mathNode;            //SHU: oh my god.  "Ok."
          // icObj.mathNode = new math.ConstantNode("Super!");


          return outIcObj;
        };

        const touchSlotConfig = {
          canTouchFunc:       canTouchFunc,
          transformationFunc: transformationFunc,
          context: {},
        };

        const touchSlot    = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill     = "";


        // const text             = targetValue.toString(10);
        // const facade           = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        // facade.backgroundColor = "orange";
        // facade.isTouchable     = false;

        const mathNode         = new math.ConstantNode(targetValue);
        const facade           = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        facade.backgroundColor = "orange";
        // facade.isTouchable     = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade":    facade,
        };


        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_targetTouchSlot";

        // icComposite.isTouchable = false;


        //enrich touchSlotConfig.context
        infiniteCanvas.onceOnAddRepresentedForIcObject(facade, (facade) => {
          const facade__represented  = infiniteCanvas.getRepresented(facade.id);
          // const facade__rep_free     = facade__represented.r_free();
          const facade__rep_official = facade__represented.r_official();

          touchSlotConfig.context.facade = facade__rep_official;
        });


        /*
        // const touchSlotEngine = touchSlot.engine;
        // console.log("touchSlot", touchSlot);
        // Hooker.installHooks(touchSlotEngine, "touch");
        // touchSlotEngine.did["touch"].on((...args) => {
        //   console.log("did touch", ...args);
        //
        //   infiniteCanvas.addNewCircle();
        // });
        infiniteCanvas.onceOnAddRepresentedForIcObject(touchSlot, (touchSlot) => {
          const touchSlot__represented  = infiniteCanvas.getRepresented(touchSlot.id);
          const touchSlot__rep_free     = touchSlot__represented.r_free();

          const touchSlotEngine = touchSlot__rep_free.engine;
          // Hooker.installHooks(touchSlotEngine, "touch");
          // touchSlotEngine.did["touch"].on((...args) => {

          Hooker.installHooks(touchSlotEngine.awoken, "touch");
          touchSlotEngine.awoken.did["touch"].on((...args) => {
            console.log("did touch", ...args);

            infiniteCanvas.addNewCircle();

            const context = touchSlot__rep_free.touchSlotConfig.context;
            const facade__rep_official  = context.facade;                 //SHU: this is context so it is official rep

            const facade__represented = facade__rep_official.represented;
            const facade__rep_free    = facade__represented.r_free();

            // facade__rep_free.text = "Super!";
            // facade__rep_free.mathNode = new math.ConstantNode("Super!");
            facade__rep_free.mathNode = new math.ConstantNode(10000000);

            facade__rep_free.fill     = "darkblue";
            facade__rep_free.stroke   = "yellow";

            //debug
            facade__rep_free.position = {
              x: facade__rep_free.position.x + 100,
              y: facade__rep_free.position.y - 50,
            };

          });
        });
        */

        return icComposite;
      }


      createIcGMBoxTargetTouchSlot(trueRect, targetMathNode) {
        console.log("createIcGMBoxTargetTouchSlot", trueRect, targetMathNode);


        const canTouchFunc_geometryWise = (above, below, context) => {
          // logger.log("canTouchFunc_geometryWise", above);

          // if(above.parts != null && above.parts.contactArea != null) {
            const contactArea = above.parts.contactArea;
            return Touch.canTouch(contactArea, below);
          // } else {
          //   return Touch.canTouch(above, below);                    //SHU: _temporary_ support for simple objects
          // }
        };

        const canTouchFunc_valueWise = (above, below, context) => {
          // logger.log("canTouchFunc_valueWise", above, below, context);
          var outBool;

          // const touchSlot = below;
          const facade    = context.facade;

          const mathNode__above = above.parts.facade.mathNode;
          console.log("mathNode__above", mathNode__above);
          const mathNode__below = facade.mathNode;
          console.log("mathNode__below", mathNode__below);

          function isSameValue(mathNode_1, mathNode_2) {
            var outBool;

            function isContainingSymbolNode(mathNode) {
              var outBool;

              const arr_symbolNode = mathNode.filter(function (node) { return node.isSymbolNode; });

              outBool = (arr_symbolNode.length > 0);

              return outBool;
            }

            const isSymbolNode_in_either = isContainingSymbolNode(mathNode_1) || isContainingSymbolNode(mathNode_2);
            if(isSymbolNode_in_either) {

              function evaluateMathNode(mathNode, dict_subst) {
                return mathNode.evaluate(dict_subst);
              }

              function evaluation_grid(mathNode_1, mathNode_2) {
                var outBool;

                const arr_dict_subst = [
                  {
                    x: 0,
                  },
                  {
                    x: 1,
                  },
                  {
                    x: -1,
                  },
                ];

                //early break reduce
                outBool = Utils.early_break_reduce(arr_test, (acc,x,i,arr) => {
                  // logger.log("early_break_reduce", x.x);

                  const ev_1 = evaluateMathNode(mathNode_1, x);
                  const ev_2 = evaluateMathNode(mathNode_2, x);

                  const isEqual_ev = (ev_1 == ev_2);

                  return acc && isEqual_ev;
                }, true, (acc, x, i, arr) => {
                  return (acc == false);
                });

                return outBool;
              }

              outBool = evaluation_grid(mathNode_1, mathNode_2);
              if(outBool) {
                return outBool;
              }



              const expr__mathNode_1 = mathNode_1.toString();
              const expr__mathNode_2 = mathNode_2.toString();

              const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
              const algebrite_result = Algebrite.run(expr__equality);

              outBool = (algebrite_result == true);

            } else {

              const relationalNode = new math.RelationalNode(['equal'], [mathNode__above, mathNode__below]);
              // logger.log("relationalNode", relationalNode);

              outBool = relationalNode.evaluate();
            }

            return outBool;
          }


          const isSameValue_ = isSameValue(mathNode__above, mathNode__below);
          console.log("isSameValue_", isSameValue_);


          outBool = isSameValue_;

          return outBool;
        };


        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value":    canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above,below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;

        const transformationFunc = (icObj) => {
          var outIcObj;

          logger.log("icGMBox original transformation func");

          return outIcObj;
        };

        const touchSlotConfig = {
          canTouchFunc:       canTouchFunc,
          transformationFunc: transformationFunc,
          context: {},
        };

        const touchSlot    = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill     = "";



        const facade           = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, targetMathNode);
        facade.backgroundColor = "orange";
        // facade.isTouchable     = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade":    facade,
        };


        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_boxTargetTouchSlot";

        // icComposite.isTouchable = false;


        //enrich touchSlotConfig.context
        infiniteCanvas.onceOnAddRepresentedForIcObject(facade, (facade) => {
          const facade__represented  = infiniteCanvas.getRepresented(facade.id);
          // const facade__rep_free     = facade__represented.r_free();
          const facade__rep_official = facade__represented.r_official();

          touchSlotConfig.context.facade = facade__rep_official;
        });

        return icComposite;
      }


      createIcGMBlob(trueRect, targetMathNode) {
        console.log("createIcGMBlob", trueRect, targetMathNode);

        const canTouchFunc_geometryWise = (above, below, context) => {
          const contactArea = above.parts.contactArea;
          return Touch.canTouch(contactArea, below);
        };

        const canTouchFunc_valueWise = (above, below, context) => {
          // logger.log("canTouchFunc_valueWise", above, below, context);
          var outBool;

          // const touchSlot = below;
          const facade    = context.facade;

          const mathNode__above = above.parts.facade.mathNode;
          console.log("mathNode__above", mathNode__above);
          const mathNode__below = facade.mathNode;
          console.log("mathNode__below", mathNode__below);

          function isSameValue(mathNode_1, mathNode_2) {
            var outBool;

            function isContainingSymbolNode(mathNode) {
              var outBool;

              const arr_symbolNode = mathNode.filter(function (node) { return node.isSymbolNode; });

              outBool = (arr_symbolNode.length > 0);

              return outBool;
            }

            const isSymbolNode_in_either = isContainingSymbolNode(mathNode_1) || isContainingSymbolNode(mathNode_2);
            if(isSymbolNode_in_either) {

              function evaluateMathNode(mathNode, dict_subst) {
                // logger.log("evaluateMathNode, mathNode", mathNode);
                // logger.log("evaluateMathNode, dict_subst", dict_subst);
                return mathNode.evaluate(dict_subst);
              }

              function evaluation_grid(mathNode_1, mathNode_2) {
                var outBool;

                const arr_dict_subst = [
                  {
                    x: 0,
                  },
                  {
                    x: 1,
                  },
                  {
                    x: -1,
                  },
                ];

                //early break reduce
                outBool = Utils.early_break_reduce(arr_dict_subst, (acc,x,i,arr) => {
                  // logger.log("early_break_reduce", x.x);

                  const ev_1 = evaluateMathNode(mathNode_1, x);
                  const ev_2 = evaluateMathNode(mathNode_2, x);

                  const isEqual_ev = (ev_1 == ev_2);

                  return acc && isEqual_ev;
                }, true, (acc, x, i, arr) => {
                  return (acc == false);
                });

                return outBool;
              }

              outBool = evaluation_grid(mathNode_1, mathNode_2);
              if(outBool) {
                return outBool;
              }


              const expr__mathNode_1 = mathNode_1.toString();
              const expr__mathNode_2 = mathNode_2.toString();

              const expr__equality = expr__mathNode_1 + " == " + expr__mathNode_2;
              const algebrite_result = Algebrite.run(expr__equality);

              outBool = (algebrite_result == true);

            } else {

              const relationalNode = new math.RelationalNode(['equal'], [mathNode__above, mathNode__below]);
              // logger.log("relationalNode", relationalNode);

              outBool = relationalNode.evaluate();
            }

            return outBool;
          }


          const isSameValue_ = isSameValue(mathNode__above, mathNode__below);
          console.log("isSameValue_", isSameValue_);


          outBool = isSameValue_;

          return outBool;
        };


        const canTouchFuncs = {
          "geometry": canTouchFunc_geometryWise,
          "value":    canTouchFunc_valueWise,
        };

        const canTouchFunc_allWise = (above, below, context) => {
          return Object.entries(canTouchFuncs).reduce((acc, [canTouchFunc_xWiseName, canTouchFunc_xWise]) => {
            const canTouch_xWise = canTouchFunc_xWise(above,below, context);
            console.log("canTouch_xWise", canTouchFunc_xWiseName, canTouch_xWise);
            return acc && canTouch_xWise;
          }, true);
        };

        const canTouchFunc = canTouchFunc_allWise;

        const transformationFunc = (icObj) => {
          var outIcObj;

          // logger.log("icGMBox original transformation func");

          return outIcObj;
        };

        const touchSlotConfig = {
          canTouchFunc:       canTouchFunc,
          transformationFunc: transformationFunc,
          context: {},
        };

        const touchSlot    = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill     = "";



        const facade           = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, targetMathNode);
        facade.backgroundColor = "orange";
        // facade.isTouchable     = false;

        const curseFacade = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "0");

        const parts = {
          "touchSlot": touchSlot,
          "facade":    facade,

          "curseFacade" : curseFacade,
        };


        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_blobTarget";

        // icComposite.isTouchable = false;


        //enrich touchSlotConfig.context
        infiniteCanvas.onceOnAddRepresentedForIcObject(facade, (facade) => {
          const facade__represented  = infiniteCanvas.getRepresented(facade.id);
          // const facade__rep_free     = facade__represented.r_free();
          const facade__rep_official = facade__represented.r_official();

          touchSlotConfig.context.facade = facade__rep_official;
        });



        //curse: metamorphosis
        infiniteCanvas.onceOnAddRepresentedForIcObject(icComposite, (icComposite) => {

          const composite_represented = infiniteCanvas.getRepresented(icComposite.id);
          const composite_rep_free    = composite_represented.r_free();

          const facade_rep_free       = composite_rep_free.parts.facade;
          const curseFacade_rep_free  = composite_rep_free.parts.curseFacade;


          // const countDownTrigger = infiniteCanvas.createCurseTrigger_countdown();
          infiniteCanvas.accurse__metamorphosis(facade_rep_free);

          const curseFunc = () => {
            // logger.log("curseFunc, rep_free:", facade_rep_free);
            const mathNode = random_constantNode();
            facade_rep_free.mathNode = mathNode;
            facade_rep_free.curse_metamorphosis.reset();
          };
          facade_rep_free.curse_metamorphosis.curseFunc = curseFunc;



          facade_rep_free.curse_metamorphosis.start();





          const curseTrigger = facade_rep_free.curse_metamorphosis.curseTrigger;
          // logger.log("curseTrigger", curseTrigger);

          // Hooker.installHooks(curseTrigger, "impulse");
          // curseTrigger.did["impulse"].on(() => {
            // logger.log("did impulse");
            // const countDownEngine = curseTrigger.engine;
            // const counter         = countDownEngine.getCounter();
            // curseFacade_rep_free.text = "" + counter;
          // });


          // facade_rep_free.curse_metamorphosis.start();

          facade_rep_free.curse_metamorphosis.rx_countDownCounter.subscribe({
            next: (value) => {
              // logger.log("rx_countDownCounter, next", value);
              // logger.log("curseFacade_rep_free", curseFacade_rep_free);

              curseFacade_rep_free.text = "" + value;
              // facade_rep_free.mathNode = new math.ConstantNode(value);
            },
          });


        });


        return icComposite;


        // keyboard_Rx.rx_keyUp.subscribe({
        //   next: (e) => {
        //     logger.log("e",e);
        //
        //     switch(e.code) {
        //       case "Numpad1":
        //         facade_rep_free.curse_metamorphosis.curseTrigger.impulse();
        //         break;
        //     }
        //
        //   },
        // });


      }



      createIcGMChallenge(trueRect, challengeIndex) {
        console.log("createIcGMChallenge", trueRect);

        const challengeName = "gmChallenge " + "#" + challengeIndex;
        const nameLabel     = infiniteCanvas.createIcText(trueRect.x, trueRect.y, challengeName);
        backade.backgroundColor = "brown";
        backade.fill            = "white";
        backade.isMobile    = false;
        // backade.isTouchable = false;

        const gmChallengeConfig = GMChallengeMama.configForIndex(challengeIndex);

        const well = infiniteCanvas.createIcText(trueRect.x, trueRect.y, challengeName);

        const op1  = infiniteCanvas.createIcText(trueRect.x, trueRect.y, challengeName);

        const parts = {
          "nameLabel":  nameLabel,

          "well": well,

          "op1": op1,
          "op2": op2,
          "op3": op3,
          "op4": op4,

          "targetSlot": targetSlot,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "gm_challenge";

        // icComposite.isTouchable = false;


        return icComposite;

      }








      createIcObserver(trueRect, observerConfig_in = null) {
        console.log("createIcObserver");

        const infiniteCanvas = this;

        const type      = "observer";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const arr_mathNode = infiniteCanvas.getAllRepresentedWithType("mathNode");
        console.log("arr_mathNode", arr_mathNode);
        // const mathNode_id  = arr_mathNode.find(e => true).id;
        const mathNode_id  = arr_mathNode.find(e => true).r_official().id;
        console.log("mathNode_id", mathNode_id);
        const observed = {};
        if(mathNode_id != null) {
          observed[mathNode_id] = true;
        }

        var observerConfig = observerConfig_in;
        if(observerConfig == null) {
          observerConfig = {
            observerEngine: ObserverEngine.defaultInstance(infiniteCanvas, icObj),
            observed: observed,
          };
        }

        //debug
        // observerConfig.observerEngine.did['observe'].on((icObj_incoming) => {
        //   console.log("observerEngine.did['observe']", icObj_incoming);
        // });

        const icObserver_spec = {
          isSnappable: false,

          stroke: "#123123",
          strokeWidth: 5,

          fill: "#789456",

          observerConfig: observerConfig,
        };

        const icObserver = Object.assign(icObj, icObserver_spec);

        //add reactive part
        this.mutateObserver__addReactivePart(icObserver, observerConfig);

        return icObserver;
      }

      mutateObserver__addReactivePart(icObserver, observerConfig) {

        const infiniteCanvas = this;

        const observerEngine = observerConfig.observerEngine;

        observerEngine.start();
        infiniteCanvas.onIcObjUpdate(observerEngine.r_official_update_handler2);
      }

      createIcTrigger(trueRect, triggerConfig = null) {
        console.log("createIcTrigger");

        const infiniteCanvas = this;

        const type      = "trigger";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icTrigger_spec = {
          isSnappable: false,

          stroke: "#123123",
          strokeWidth: 5,

          fill: "#888555",

          triggerConfig: triggerConfig,
        };

        const icTrigger = Object.assign(icObj, icTrigger_spec);

        //add reactive part
        this.mutateTrigger__addReactivePart(icTrigger, triggerConfig);

        return icTrigger;
      }

      mutateTrigger__addReactivePart(icTrigger, triggerConfig) {

      }

      createIcEventEmitter(trueRect) {

      }

      createIcEventReceiver(trueRect) {

      }


      createIcRxSubject(trueRect) {
        console.log("createIcRxSubject", trueRect);

        const infiniteCanvas = this;

        const type      = "rxSubject";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRxSubject_spec = {

        };

        const icRxSubject = Object.assign(icObj, icRxSubject_spec);


        const engine = new RxSubjectEngine();
        const eType  = "rxSubject";

        const icEngined = infiniteCanvas.createIcEngined(icRxSubject, eType, engine);

        return icEngined;
      }

      createIcRxSubscription(trueRect) {
        console.log("createIcRxSubscription", trueRect);

        const infiniteCanvas = this;

        const type      = "rxSubscription";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRxSubscription_spec = {

        };

        const icRxSubscription = Object.assign(icObj, icRxSubscription_spec);


        const engine = new RxSubscriptionEngine();
        const eType  = "rxSubscription";

        const icEngined = infiniteCanvas.createIcEngined(icRxSubscription, eType, engine);

        return icEngined;
      }





      createIcFacet_mathNode(trueRect) {
        console.log("createIcFacet_mathNode", trueRect);
        const infiniteCanvas = this;

        const mathNode = new math.ConstantNode("");
        const facade   = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        facade.backgroundColor = "grey";
        facade.isMobile    = true;
        // facade.isTouchable = false;

        const observer = infiniteCanvas.createIcObserver(trueRect, null);

        observer.observerConfig.observerEngine.did['observe'].on((icObj_incoming) => {
          const mathNode_incoming = icObj_incoming.mathNode;
          console.log("mathNode_incoming", mathNode_incoming);

          const mathNode_cloned     = mathNode_incoming.clone();
          const mathNode_simplified = math.simplify(mathNode_cloned);

          // facade.mathNode = mathNode_simplified;
          const facade_represented = infiniteCanvas.getRepresented(facade.id);
          const facade_rep_free    = facade_represented.r_free();

          facade_rep_free.mathNode = mathNode_simplified;
        });

        const parts = {
          "observer":  observer,
          "facade":    facade,
        };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, false);

        const icComposite = this.createIcComposite(trueRect, parts, compositeConfig);
        icComposite.cType = "facet_mathNode";

        // icComposite.isTouchable = false;


        return icComposite;
      }




      createIcEngined(icObj, eType, engine) {
        console.log("createIcEngined");

        const icEngined_spec = {
          eType:  eType,
          engine: engine,
        };

        const icEngined = Object.assign(icObj, icEngined_spec);

        Enginiter.installEngine(icEngined, icEngined.engine);

        return icEngined;
      }

      mutateEngined__addReactivePart(icEngined) {
        console.log("mutateEngined__addReactivePart", icEngined);

        const infiniteCanvas = this;

        // icEngined.engine.start();
        // infiniteCanvas.onIcObjUpdate(icSnapSlot.snapEngine.r_official_update_handler2);
      }


      createIcEngined_debug(trueRect) {
        console.log("createIcEngined_debug", trueRect);

        const engineCarrier   = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "icEngined_debug");
        engineCarrier.backgroundColor = "gold";

        const engine = Engine.debugInstance();

        const eType = "debug";

        const icEngined = infiniteCanvas.createIcEngined(engineCarrier, eType, engine);

        return icEngined;
      }





      createIcCountdown(trueRect, countDownConfig_in = null) {
        console.log("createIcCountdown", trueRect);
        const infiniteCanvas = this;

        const mathNode = new math.ConstantNode("");
        const facade   = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        facade.backgroundColor = "grey";
        facade.isMobile    = true;
        facade.isTouchable = true;  //:)

        class CountDownEngine {
          constructor(facade, countDownConfig_in = null) {

            var countDownConfig = countDownConfig_in;
            if(countDownConfig == null) {
              countDownConfig = CountDownConfig.defaultConfig();
            }

            this.counter_start = countDownConfig.value_start;
            this.counter_end   = countDownConfig.value_end;

            this.stepFunc      = countDownConfig.stepFunc;
            this.stepDuration  = countDownConfig.stepDuration;

            const nb_steps     = math.abs(this.counter_end - this.counter_start);
            this.nb_steps      = nb_steps;

            this.arr_steps     = [...new Array(nb_steps).keys()];
            this.step_current  = 0;

            this.counter = this.counter_start;

            this.progress = 0;

            this.isPaused = true;

            const duration = this.nb_steps * this.stepDuration;

            this.animatedObj = {
              progress: 0
            };

            const countDownEngine = this;
            const animatedObj = this.animatedObj;
            const animation = anime({
              // targets: countDownEngine,
              targets: animatedObj,

              /*animated props*/
              progress: 1,
              /*--------------*/

              direction: 'normal',
              easing: 'linear',
              duration: duration,

              autoplay: false,

              update: (anim) => {
                const progress = anim.progress / 100;
                countDownEngine.progress = progress;
                countDownEngine.update(progress);
              },
            });

            this.animation = animation;




            this.start = function() {
              const countDownEngine = this;

              countDownEngine.stepFunc(0);
              countDownEngine.play();
            };
            // }.bind(this);

            this.stop = function() {
              const countDownEngine = this;

              countDownEngine.reset();
            };
            // }.bind(this);

            this.play = function() {
              const countDownEngine = this;

              const date_play           = new Date();
              countDownEngine.date_play = date_play;

              countDownEngine.isPaused = false;
              countDownEngine.animation.play();
            };
            // }.bind(this);

            this.pause = function() {
              const countDownEngine = this;

              const date_pause           = new Date();
              countDownEngine.date_pause = date_pause;

              countDownEngine.animation.pause();
              countDownEngine.isPaused = true;
            };
            // }.bind(this);

            this.reset = function() {
              const countDownEngine = this;

              countDownEngine.animation.reset();
            };
            // }.bind(this);

            this.update = function(progress) {
              console.log("update", progress);
              const countDownEngine = this;

              const cursor      = progress * countDownEngine.nb_steps;
              const step_cursor = math.floor(cursor);

              const isStepChanged = (step_cursor - countDownEngine.step_current) >= 1;
              if(isStepChanged) {
                countDownEngine.step_current = step_cursor;
                countDownEngine.stepFunc(step_cursor);
              }
            };
            // }.bind(this);

          }

          /*
          start() {
            this.stepFunc(0);
            this.play();
          }

          stop() {
            this.reset();
          }

          play() {
            const countDownEngine = this;

            const date_play           = new Date();
            countDownEngine.date_play = date_play;

            countDownEngine.isPaused = false;
            countDownEngine.animation.play();
          }

          pause() {
            const countDownEngine = this;

            const date_pause           = new Date();
            countDownEngine.date_pause = date_pause;

            countDownEngine.animation.pause();
            countDownEngine.isPaused = true;
          }

          reset() {
            countDownEngine.animation.reset();
          }

          update(progress) {
            console.log("update", progress);
            const cursor      = progress * this.nb_steps;
            const step_cursor = math.floor(cursor);

            const isStepChanged = (step_cursor - this.step_current) >= 1;
            if(isStepChanged) {
              this.step_current = step_cursor;
              this.stepFunc(step_cursor);
            }
          }
          */

        }

        class CountDownConfig {

          constructor(value_start, value_end, stepFunc, stepDuration) {
            this.value_start   = value_start;
            this.value_end     = value_end;

            this.stepFunc      = stepFunc;
            this.stepDuration  = stepDuration;
          }

          static defaultConfig() {
            var outConfig;

            const value_start = 10;
            const value_end   = 0;

            const stepFunc = (stepIndex) => {
              console.log("stepFunc", stepIndex);
            };

            const stepDuration = 1000;

            outConfig = new CountDownConfig(value_start, value_end, stepFunc, stepDuration);

            return outConfig;
          }

        }

        const countDownConfig = CountDownConfig.defaultConfig();
        countDownConfig.stepFunc = (stepIndex) => {
          console.log("stepFunc", stepIndex);

          const facade_represented = infiniteCanvas.getRepresented(facade.id);
          const facade_rep_free    = facade_represented.r_free();

          const mathNode = new math.ConstantNode(stepIndex);
          facade_rep_free.mathNode = mathNode;
        };

        const engine    = new CountDownEngine(facade, countDownConfig);
        console.log("fresh engine", engine);
        const eType     = "countdown";

        const icEngined = infiniteCanvas.createIcEngined(facade, eType, engine);

        return icEngined;
      }



      createIcInteractor(trueRect, interactorConfig_in = null) {
        console.log("createIcCountdown", trueRect);
        const infiniteCanvas = this;

        // const mathNode = new math.ConstantNode("");
        // const facade   = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
        const facade   = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "interactor");
        facade.backgroundColor = "gold";
        facade.isMobile    = true;
        facade.isTouchable = true;  //:)

        class InteractorEngine {
          constructor() {

            this.initialized = false;

            this.initialize = function(scopeObj) {
              this.initialized = true;
              this.scopeObj = scopeObj;
            }

            this.start = function() {
              console.log("this.scopeObj.facade", this.scopeObj.facade);
            };

            this.stop = function() {

            };

            this.interact = function() {
              console.log("interact");

              this.scopeObj.facade.text += "+";
            };

          }
        }

        const engine = new InteractorEngine();
        console.log("fresh engine", engine);
        const eType = "interactor";

        const icEngined = infiniteCanvas.createIcEngined(facade, eType, engine);

        return icEngined;
      }





        //add
      addIcObject(icObj) {
        console.log("addIcObject", icObj);

        const represented = this.createRepresentedIcObject(icObj);
        this.addRepresented(represented);

      }

      didAddIcObject(icObj) {

      }

      addRepresented(represented) {
        console.log("addRepresented", represented);

        const id_icObj = represented.r_official().id;
        const represented_check = this.getRepresented(id_icObj);
        if(represented_check != null) {
          //ignore
          console.log("represented already added => ignore");
          return;
        }

        this.tetherIcObject(represented);   //== track icObj updates

        this.introduceToExistingObjects(represented);

        //store
        const rep_official = represented.r_official();
        this.represented[rep_official.id] = represented;

        //add free representation
        const rep_free = represented.r_free();
        this.addRepresentation(represented, rep_free);

        if(rep_official.type == "composite") {
          Object.values(represented.parts).forEach((part__represented, i) => {
            this.addRepresented(part__represented);
          });
        }

        this.didAddRepresented(represented);
      }

      didAddRepresented(represented) {
        this.setChanged(true);

        this.didAddRepresentedListeners.forEach((listener, i) => {
          listener(represented);
        });
      }

      onAddRepresented(listener) {
        this.didAddRepresentedListeners.push(listener);
      }

      offAddRepresented(listener) {
        this.didAddRepresentedListeners = Utils.arrayByRemovingElement(this.didAddRepresentedListeners, listener);
      }

      onceOnAddRepresentedForIcObject(icObject, func) {

        var autoUnsub = (represented) => {

          //compare icObject with represented
          const r_official = represented.r_official();
          if(r_official.id == icObject.id) {
            this.offAddRepresented(autoUnsub);
            func(icObject);
          }

        }

        this.onAddRepresented(autoUnsub);
      }

      removeRepresented(represented, shouldAlsoRemoveChildren = false) {
        // logger.trace("removeRepresented", represented);

        // if(represented == null) {
        //   throw new Error("represented == null");
        // }

        const id_icObj = represented.r_official().id;
        const represented_check = this.getRepresented(id_icObj);
        if(represented_check == null) {
          //ignore
          console.log("represented already removed => ignore");
          return;
        }


        if(shouldAlsoRemoveChildren) {
          if(represented.r_official().type == "composite") {
            Object.values(represented.parts).forEach((part__represented, i) => {
              this.removeRepresented(part__represented, shouldAlsoRemoveChildren);
            });
          }
        }

        if(represented.r_official().type == "engined") {
          represented.r_free().engine.awoken.stop();
        }



        this.untetherIcObject(represented);   //== stop tracking icObj updates

        this.extroduceFromExistingObjects(represented);

        //unstore
          //representations
        Object.values(represented.reps).forEach((rep, i) => {
          this.removeRepresentation(represented, rep);
        });


          //represented
        const rep_official   = represented.r_official();
        const id_represented = rep_official.id;
        // this.represented[id_represented] = null;
        delete this.represented[id_represented];


        //deconstruct
        represented.deconstruct();

        this.didRemoveRepresented(represented);
      }

      didRemoveRepresented(represented) {
        // logger.log("didRemoveRepresented", represented);

        this.setChanged(true);

        this.didRemoveRepresentedListeners.forEach((listener, i) => {
          listener(represented);
        });
      }

      onRemoveRepresented(listener) {
        this.didRemoveRepresentedListeners.push(listener);
      }

      offRemoveRepresented(listener) {
        this.didRemoveRepresentedListeners = Utils.arrayByRemovingElement(this.didRemoveRepresentedListeners, listener);
      }










      addRepresentation(represented, representation) {

        if(this.representations[representation.id_rep] == null) {
          this.representations[representation.id_rep] = representation;
        } else {
          throw new Error("oh, no, id collision for id: " + representation.id_rep);
        }

        this.didAddRepresentation(represented, representation);
      }

      didAddRepresentation(represented, representation) {
        this.setChanged(true);

        this.didAddRepresentationListeners.forEach((listener, i) => {
          listener(represented, representation);
        });

        this.redrawCanvas(RedrawOccasion.objectAdded);
      }

      removeRepresentation(represented, representation) {

        // if(this.representations[representation.id_rep] != null) {
          delete this.representations[representation.id_rep];
        // }

        this.didRemoveRepresentation(represented, representation);
      }

      didRemoveRepresentation(represented, representation) {
        this.setChanged(true);

        // this.didAddObjectListeners.forEach((listener, i) => {
        //   listener(icObj);
        // });

        this.redrawCanvas(RedrawOccasion.objectRemoved);
      }

      addPureIcObject(icObj) {

        this.pure_icObjects["any"].push(icObj);


        if(this.pure_icObjects[icObj.type] == null) {
          this.pure_icObjects[icObj.type] = [];
        }
        this.pure_icObjects[icObj.type].push(icObj);

        this.didAddPureObject(icObj);
      }

      didAddPureObject(icObj) {
        this.didAddPureObjectListeners.forEach((listener, i) => {
          listener(icObj);
        });

        this.redrawCanvas(RedrawOccasion.pureObjectAdded);
      }


      removeIcObject(icObj) {
        console.log("removeIcObject", icObj);

        //SHU TODO: removeIcObject


        this.didRemoveObject_p(icObj);
      }

      didRemoveObject_p(icObj) {
        this.setChanged(true);

        // this.didAddObjectListeners.forEach((listener, i) => {
        //   listener(icObj);
        // });
        //
        // this.redrawCanvas(RedrawOccasion.objectRemoved);
      }

      // manageIcObjUpdate(icObj, requestCanvasRedraw = false) {
      //   console.log("manageIcObjUpdate");
      //
      //   if(icObj.toBeDeleted) {
      //     console.log("this", this);
      //     this.removeIcObject(icObj);
      //   }
      //
      //   this.icObjDidUpdate(icObj);
      //
      //   this.setChanged(true);
      // }

      icObjDidUpdate(icObj, outerUpdatesDict) {
        console.log("icObjDidUpdate", icObj, outerUpdatesDict);
        this.icObjListeners.forEach((listener, i) => {
          listener(icObj, outerUpdatesDict);
        });
      }

      onIcObjUpdate(listener) {
        this.icObjListeners.push(listener);
      }

      offIcObjUpdate(listener) {
        this.icObjListeners = Utils.arrayByRemovingElement(this.icObjListeners, listener);
      }


      addDehydratedIcObject(icObj) {
        const rehydrated = this.rehydrated(icObj);

        this.addIcObject(rehydrated);
      }

      rehydrated(icObj) {
        var rehydrated;

        // rehydrated = icObj.clone();
        rehydrated = icObj.deepClone();


        // switch(icObj.type) {
        //   case "snapSlot":
        //     const icSnapSlot = rehydrated;
        //     //add reactive part
        //     this.mutateSnapSlot__addReactivePart(icSnapSlot);
        //     rehydrated = icSnapSlot;
        //     break;
        //   default:
        //   break;
        // }

        return rehydrated;
      }

      addPastedIcObject(icObj) {
        const infiniteCanvas = this;

        const true_cursor = this.getTrueCursor();

        icObj.position = {
          x: true_cursor.x,
          y: true_cursor.y,
        };

        icObj.homeScale = {
          X: infiniteCanvas.scale.X,
          Y: infiniteCanvas.scale.Y,
        };

        infiniteCanvas.addIcObject(icObj);
      }


      //convenience

      addNewIcObject(icObj) {

        icObj.orientation = this.orientation;

        const inputProperties = this.inputProperties;

        const activeColor = inputProperties.getActiveColor();
        switch(icObj.type) {
          case "rect":
          case "point":
          case "sparkle":
            icObj.fill = activeColor;
            break;
          case "text":
            icObj.textColor = activeColor;
            break;
          case "circle":
            icObj.stroke = activeColor;
            break;

          case "svg":
            icObj.stroke      = activeColor;
            icObj.strokeWidth = 5;

            icObj.fill        = "yellow";
            break;

          case "observer":
          case "trigger":
          case "eventEmitter":
          case "eventReceiver":
            break;

          case "snapSlot":
            break;
          case "freeDrawing":
            break;

          default:
            icObj.fill = activeColor;
            break;
        }

        icObj.opacity = inputProperties.getActiveOpacity();

        icObj.zIndex = this.getFreshZIndex();

        this.addIcObject(icObj);
      }

      addNewRect() {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const icRect = this.createIcRect_withLTWH(left, top, width, height);
        this.addNewIcObject(icRect);
      }

      addNewText(text = "icText") {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icText = this.createIcText(left, top, text);

        // //debug
        // const width  = 100;   //"information" size
        // const height = 100;
        // icText.width  = width;
        // icText.height = height;

        this.addNewIcObject(icText);
      }

      addNewTag(text = "icTag") {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icTag = this.createIcTag(left, top, text);

        this.addNewIcObject(icTag);
      }


      addNewImage(img) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icImage = this.createIcImage(left, top, img);
        this.addNewIcObject(icImage);
      }

      addNewCircle() {
        const true_cursor = this.getTrueCursor();
        const radius = 100;

        const left   = true_cursor.x;
        const top    = true_cursor.y;
        const width  = 100;   //"information" size
        const height = 100;

        const icCircle = this.createIcCircle(left, top, width, height);
        this.addNewIcObject(icCircle);
      }

      addNewPoint() {
        const true_cursor = this.getTrueCursor();

        const icPoint = this.createIcPoint(true_cursor);
        this.addNewIcObject(icPoint);


        /*
        //debug
        const point_from = this.cursor;
        const center     = this.getScreenCenterPoint();

        [10,20,30,70,80,90,  270,300, -85].forEach((angleInDegrees, i) => {

          const screenPoint = Geometry.pointWithRotation(point_from, center, angleInDegrees);
          // console.log("screenPoint", screenPoint);

          this.addPoint(this.toTruePoint(screenPoint));
        });
        */

        // function debugRotation(point_from, center) {
        //
        //   [10,20,30,70,80,90].forEach((angleInDegrees, i) => {
        //
        //     const screenPoint = Geometry.pointWithRotation(point_from, center, angleInDegrees);
        //     this.addPoint(screenPoint);
        //   });
        //
        // }
        //
        // debugRotation(this.cursor, screenCenterPoint);


      }

      // addPurePoint(point) {
      //   const icPoint = this.createIcPoint(point);
      //   this.addPureIcObject(icPoint);
      // }
      //
      // addPureCircle(center, radius) {
      //
      //   const icCircle = this.createIcCircle(center, radius);
      //   this.addPureIcObject(icCircle);
      //
      // }

      addNewSvg(svgEl) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icSvg = this.createIcSvg(left, top, svgEl);
        this.addNewIcObject(icSvg);
      }

      addNewTex(tex) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icTex = this.createIcTex(left, top, tex);
        this.addNewIcObject(icTex);
      }

      addNewMathNode(mathNode) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icMathNode = this.createIcMathNode(left, top, mathNode);
        this.addNewIcObject(icMathNode);
      }

      addNewHtmlElt(html_elt) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icHtmlElt = this.createIcHtmlElt(left, top, html_elt);
        this.addNewIcObject(icHtmlElt);
      }


      addNewSnapSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width:  width,
          height: height,
        };

        const icSnapSlot = this.createIcSnapSlot(trueRect);
        this.addNewIcObject(icSnapSlot);
      }

      addNewSparkle(img) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        // const width  = 100;   //"information" size
        // const height = 100;

        // const trueRect = Geometry.createRect(left, top, width, height);

        const sparkleConfig = {

        };

        // const icSparkle = this.createIcSparkle(trueRect, img, sparkleConfig);
        const icSparkle = this.createIcSparkle(true_cursor, img, sparkleConfig);
        this.addNewIcObject(icSparkle);
      }


      addNewTouchSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };


        const toucher = Toucher.debugInstance();

        const touchSlotConfig = {
          transformationFunc: toucher.transformationFunc,
        };

        const icTouchSlot = this.createIcTouchSlot(trueRect, touchSlotConfig);
        this.addNewIcObject(icTouchSlot);
      }

      getNextTouchSlotRank() {
        var outNumber;
        const arr_touchSlot = Object.values(this.represented)
                                    .map(represented => represented.r_official())
                                    .filter(rep => (rep.type == "touchSlot"));
        outNumber = arr_touchSlot.length;
        return outNumber;
      }




      addNewComposite() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icComposite = this.createIcComposite_debug(trueRect);
        this.addNewIcObject(icComposite);
      }

      addNewGreenMouseBox(mathNode) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icComposite = this.createIcGreenMouseBox(trueRect, mathNode);
        this.addNewIcObject(icComposite);
      }

      // composed(trueRect, arr_icObj) {
      //   var outIcObj;
      //
      //   const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
      //   const icComposite     = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
      //
      //   return outIcObj;
      // }

      compose(arr_icObj) {
        console.log("compose", arr_icObj);
        const infiniteCanvas = this;

        function debugTrueRect(infiniteCanvas) {
          const true_cursor = infiniteCanvas.getTrueCursor();

          const left = true_cursor.x;
          const top  = true_cursor.y;

          const width  = 100;   //"information" size
          const height = 100;

          const trueRect = {
            x: left,
            y: top,
            width:  width,
            height: height,
          };

          return trueRect;
        }

        const trueRect = debugTrueRect(infiniteCanvas);
        console.log("trueRect", trueRect);

        const parts = arr_icObj; //SHU: arr is an obj with propNames = indexes
        // const parts = {
        //   "1": arr_icObj[0],
        //   "2": arr_icObj[1],
        // };

        const compositeConfig = Compositer.defaultCompositeConfig(parts, true);

        const icComposite = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);
        // icComposite.cType = cType;

        icComposite.stroke      = "cyan";
        icComposite.strokeWidth = 5;




        //get tag object (if any)
        const tag = arr_icObj.find(icObj => icObj.type == "tag");

        var cType;
        if(tag != null) {
          cType = tag.text;
        } else {
          cType = "anonymous";
        }
        icComposite.cType = cType;


        if(tag != null) {
          //stick tag next to handle

          // tag.isMobile = false;
          // compositeConfig.parts[tag].isMobile = false;

          tag.position = {
            x: icComposite.position.x + icComposite.size.width,
            y: icComposite.position.y,
          };
        }



        this.addNewIcObject(icComposite);
      }

      decompose(icComposite) {
        console.log("decompose", icComposite);

        const arr_parts = Object.values(icComposite.parts);

        arr_parts.forEach((part, i) => {
          part.compositeId     = -1;
          part.isCompositePart = false;
          // part.isMobile        = false;
        });

        // icComposite.engine.stop();
        icComposite.engine.awoken.stop();

        const represented = this.getRepresented(icComposite.id);
        const rep_free = represented.r_free();
        rep_free.im_dying_now = true;

        // this.removeRepresented(represented);
      }


      getSupervessel() {
        const supervessel__represented = Object.values(this.represented).find(represented => represented.r_official().isSupervessel);
        const supervessel__rep_free    = supervessel__represented.r_free();
        return supervessel__rep_free;
      }

      getActiveObject() {

      }

      operateOnActiveObject(opName) {
        return;
      }

      operateOnActiveObject__split() {

        const infiniteCanvas = this;

        //get supervessel
        const rep_free__supervessel = infiniteCanvas.getSupervessel();
        logger.log("rep_free__supervessel", rep_free__supervessel);

        //get cargo
        const arr_cargo = Object.values(rep_free__supervessel.parts);
        if(arr_cargo.length == 0) {
          //ignore            //SHU: ou alors faire surgir des paires du vide canvassien
          return;
        }
        const rep_free__cargo_1 = arr_cargo.find(e => true);

        //split
        const arr_components = infiniteCanvas.splitObject(rep_free__cargo_1);

        //if split was successful: perform replacement in supervessel
        if(arr_components.length > 0) {
          //remove original part
          rep_free__supervessel.engine.awoken.removePart(rep_free__cargo_1);

          //add parts: components
          arr_components.forEach((component, i) => {
            //add to infiniteCanvas
            infiniteCanvas.addIcObject(component);

            //get rep_free
            const rep_free__component = infiniteCanvas.getRepresented(component.id).r_free();

            //add to supervessel
            rep_free__supervessel.engine.awoken.addPart(rep_free__component);
          });

        }

      }

      splitObject(icObj) {
        var outArr;

        const infiniteCanvas = this;

        outArr = [];

        switch(icObj.type) {
          case "mathNode":
            {
              const mathNode = icObj.mathNode;

              const arr_components = Splitter.split_full(mathNode);

              outArr = arr_components.map((mathNode__component, i) => {
                const position = {
                  x: icObj.position.x + 50 * i,
                  y: icObj.position.y + 50 * i,
                };
                const icMathNode = infiniteCanvas.createIcMathNode(position.x, position.y, mathNode__component);
                return icMathNode;
              });

            }
            break;

          case "text":
            {
              const text = icObj.text;
              const arr_components = text.split("");

              outArr = arr_components.map((str__component, i) => {
                const position = {
                  x: icObj.position.x + 50 * i,
                  y: icObj.position.y + 50 * i,
                };
                const icText = infiniteCanvas.createIcText(position.x, position.y, str__component);
                return icText;
              });
            }
            break;

          case "image":
            //SHU TODO: un puzzle en quelques pressions
            break;

          case "bag":
            break;


          default:
            break;
        }

        return outArr;
      }

      operateOnActiveObject__join() {

        const infiniteCanvas = this;

        //get supervessel
        const rep_free__supervessel = infiniteCanvas.getSupervessel();
        logger.log("rep_free__supervessel", rep_free__supervessel);

        //get cargo
        const arr_cargo = Object.values(rep_free__supervessel.parts);
        if(arr_cargo.length == 0) {
          //ignore            //SHU: ou alors faire surgir des paires du vide canvassien
          return;
        }

        //join
        const icObj__joined = infiniteCanvas.joinObjects(arr_cargo);

        //if join was successful: perform replacement in supervessel
        if(icObj__joined != null) {
          //remove original parts
          arr_cargo.forEach((rep_free__cargo, i) => {
            rep_free__supervessel.engine.awoken.removePart(rep_free__cargo);
          });

          //add part: joined
          {
            //add to infiniteCanvas
          infiniteCanvas.addIcObject(icObj__joined);

            //get rep_free
          const rep_free__joined = infiniteCanvas.getRepresented(icObj__joined.id).r_free();

            //add to supervessel
          rep_free__supervessel.engine.awoken.addPart(rep_free__joined);
          }


        }

      }

      joinObjects(arr_icObj) {
        var outIcObj;

        const infiniteCanvas = this;

        const typeDescription = infiniteCanvas.createTypeDescription(arr_icObj);

        if(typeDescription.type == "single") {
          const icObjType = typeDescription.arr_type.find(e => true);
          switch(icObjType) {
            case "mathNode":
              {
                const arr_mathNode = arr_icObj.map(icObj => icObj.mathNode);
                const mathNode__joined = Joiner.random_join(arr_mathNode);

                const icObj = arr_icObj.find(e => true);
                const position = {
                  x: icObj.position.x,
                  y: icObj.position.y,
                };

                const icMathNode = infiniteCanvas.createIcMathNode(position.x, position.y, mathNode__joined);
                outIcObj = icMathNode;
              }
              break;
            case "text":
              {

              }
              break;
            default:
              break;
          }
        } else {

        }

        return outIcObj;
      }

      createTypeDescription(arr_icObj) {
        var outTypeDesc = {};

        const arr_type__all = arr_icObj.map(icObj => icObj.type);

        const set_type      = new Set(arr_type__all);
        const arr_type__distinct = [...set_type];
        outTypeDesc.arr_type = arr_type__distinct;

        if(arr_type__distinct.length == 1) {
          outTypeDesc.type = "single";
        } else {
          outTypeDesc.type = "multi";
        }

        return outTypeDesc;
      }




      addNewLabelValue(text, value) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icLabelValue = this.createIcLabelValue(trueRect, text, value);
        this.addNewIcObject(icLabelValue);
      }


      addNewButton() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icButton = this.createIcButton(trueRect);
        this.addNewIcObject(icButton);
      }

      addNewClickWell(value) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icClickWell = this.createIcClickWell(trueRect, value);
        this.addNewIcObject(icClickWell);
      }

      addNewBornAgainGreenMouse(value) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icBornAgainGreenMouse = this.createIcBornAgainGreenMouse(trueRect, value);
        this.addNewIcObject(icBornAgainGreenMouse);
      }




      addNewGMOperator() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMOperator = this.createIcGMOperator(trueRect);
        this.addNewIcObject(icGMOperator);
      }

      addNewGMOperator_editable(text) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMOperator = this.createIcGMOperator_editable(trueRect, text);
        this.addNewIcObject(icGMOperator);
      }


      addNewGMOperator_withType(type) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMOperator = this.createIcGMOperator_withType(trueRect, type);
        this.addNewIcObject(icGMOperator);
      }


      addNewGMTargetSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMTargetSlot = this.createIcGMTargetSlot(trueRect);
        this.addNewIcObject(icGMTargetSlot);
      }

      addNewGMTargetTouchSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMTargetTouchSlot = this.createIcGMTargetTouchSlot(trueRect);
        this.addNewIcObject(icGMTargetTouchSlot);
      }


      addNewWell() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icWell = this.createIcWell(trueRect);
        this.addNewIcObject(icWell);
      }

      addNewGreenMouseWell() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGreenMouseWell = this.createIcGreenMouseWell(trueRect);
        this.addNewIcObject(icGreenMouseWell);
      }

      addNewGMChallenge(challengeIndex) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMChallenge = this.createIcGMChallenge(trueRect, challengeIndex);
        this.addNewIcObject(icGMChallenge);
      }


      addNewRxSubject(value) {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icRxSubject = this.createIcRxSubject(trueRect, value);
        this.addNewIcObject(icRxSubject);
      }

      addNewRxSubscription() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icRxSubscription = this.createIcRxSubscription(trueRect);
        this.addNewIcObject(icRxSubscription);
      }





      addNewObserver() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icObserver = this.createIcObserver(trueRect);
        this.addNewIcObject(icObserver);
      }

      addNewTrigger() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icTrigger = this.createIcTrigger(trueRect);
        this.addNewIcObject(icTrigger);
      }

      addNewEventEmitter() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icEventEmitter = this.createIcEventEmitter(trueRect);
        this.addNewIcObject(icEventEmitter);
      }

      addNewEventReceiver() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icEventReceiver = this.createIcEventReceiver(trueRect);
        this.addNewIcObject(icEventReceiver);
      }

      addNewFacet_mathNode() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icFacet_mathNode = this.createIcFacet_mathNode(trueRect);
        this.addNewIcObject(icFacet_mathNode);
      }

      addNewIcEngined_debug() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icEngined_debug = this.createIcEngined_debug(trueRect);
        this.addNewIcObject(icEngined_debug);
      }

      addNewCountdown() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icCountdown = this.createIcCountdown(trueRect);
        this.addNewIcObject(icCountdown);
      }







      configureInitialIcObjects() {

        // this.addAxes();

      }

      addAxes() {

        const icRectX = this.createIcRect_withLTWH(0, 0, 1000, 10);
        icRectX.fill = "red";
        this.addIcObject(icRectX);

        const icRectY = this.createIcRect_withLTWH(0, 0, 10, 1000);
        icRectY.fill = "blue";
        this.addIcObject(icRectY);

      }





      setupRedrawConditions() {
        // if the window changes size, redraw the canvas
        window.addEventListener("resize", (event) => {
            this.redrawCanvas(RedrawOccasion.windowResize);
        });
      }



      redrawCanvas(redrawOccasion) {

        debug.setScale(this.scale);
        debug.setOffset(this.offset);

        // console.log("this.icObjects", this.icObjects);
        // debug.setNbObjects(Object.values(this.icObjects.any).length);

        /*
        console.log("**reps[[[[[");
        Object.values(this.representations).forEach((rep, i) => {
          console.log("**rep", rep.type, rep.id_rep);
        });
        console.log("**reps]]]]]");
        */

        const nbDisplayedRepresentations = Object.values(this.representations).length;
        debug.setNbObjects(nbDisplayedRepresentations);

        this.redrawCanvasListeners.forEach((listener, i) => {
          listener(redrawOccasion);
        });
      }




      // convert coordinates
      toScreenX(xTrue) {
          return (xTrue + this.offset.dx) * this.scale;
      }
      toScreenY(yTrue) {
          return (yTrue + this.offset.dy) * this.scale;
      }
      toScreenPoint(truePoint) {
        return Geometry.createPoint(this.toScreenX(truePoint.x), this.toScreenY(truePoint.y));
      }
      toScreenRect(trueRect) {
        const truePointTL = Geometry.createPoint(trueRect.left, trueRect.top);
        const truePointBR = Geometry.createPoint(trueRect.left + trueRect.width, trueRect.top + trueRect.height);

        const screen_pointTL = this.toScreenPoint(truePointTL);
        const screen_pointBR = this.toScreenPoint(truePointBR);

        const screen_w = screen_pointBR.x - screen_pointTL.x;
        const screen_h = screen_pointBR.y - screen_pointTL.y;

        const screenRect = Geometry.createRect(screen_pointTL.x, screen_pointTL.y, screen_w, screen_h);

        return screenRect;
      }
      toScreenSize(trueSize) {
        const screen_w  = trueSize.width  / this.scale.X;
        const screen_h  = trueSize.height / this.scale.Y;
        return Geometry.createSize(screen_w, screen_h);
      }
      // toScreenLength(trueLength) {
      //   return trueLength * this.scale;
      // }




      getOrientationBaseVectors() {
        return this.getRotationBaseVectors(this.orientation);
      }

      getStdBaseVectors() {
        return this.getRotationBaseVectors(-this.orientation);
      }

      getRotationBaseVectors(angle) {

        const cosTheta = Math.cos(angle * (Math.PI / 180));
        const sinTheta = Math.sin(angle * (Math.PI / 180));

        const orientation_vector_u = {
          x: cosTheta,
          y: sinTheta,
        };

        const orientation_vector_v = {
          x: -sinTheta,
          y: cosTheta,
        };

        const baseVectors = {
          u: orientation_vector_u,
          v: orientation_vector_v,
        };

        return baseVectors;

      }


      // toTrueX(xScreen) {
      //     return (xScreen / this.scale.X) - this.offset.dx;
      // }
      // toTrueY(yScreen) {
      //     return (yScreen / this.scale.Y) - this.offset.dy;
      // }
      toTrueX(screenPoint) {
          // console.log("toTrueX", "screenPoint", screenPoint);
          //
          // console.log("screenPoint.x", screenPoint.x);
          // console.log("this.scale.X", this.scale.X);
          // console.log("this.offset.dx", this.offset.dx);
          // console.log("this.offset", this.offset);


          const v = this.toNoOrPoint(screenPoint);

          const stdBaseVectors = this.getStdBaseVectors();
          // console.log("stdBaseVectors", stdBaseVectors);

          const trueX = Geometry.dotProduct_2d(v, stdBaseVectors.u);

          return trueX;
      }
      toTrueY(screenPoint) {
        const v = this.toNoOrPoint(screenPoint);

        const stdBaseVectors = this.getStdBaseVectors();

        return Geometry.dotProduct_2d(v, stdBaseVectors.v);
      }

      trueWidth() {
          // return canvas.clientWidth / scale;
          return this.canvas.width / this.scale.X;
      }
      trueHeight() {
          // return canvas.clientHeight / scale;
          return this.canvas.height / this.scale.Y;
      }

      toTruePoint(point) {
        const trueX = this.toTrueX(point);
        // console.log("trueX", trueX);

        const trueY = this.toTrueY(point);
        const truePoint = Geometry.createPoint(trueX, trueY);
        // console.log("truePoint", truePoint);
        return truePoint;
      }

      toTrueRect(rect) {
        const pointTL = Geometry.createPoint(rect.left, rect.top);
        const pointBR = Geometry.createPoint(rect.left + rect.width, rect.left + rect.height);

        const true_pointTL = this.toTruePoint(pointTL);
        const true_pointBR = this.toTruePoint(pointBR);

        const true_w = true_pointBR.x - true_pointTL.x;
        const true_h = true_pointBR.y - true_pointTL.y;

        const trueRect = Geometry.createRect(true_pointTL.x, true_pointTL.y, true_w, true_h);

        return trueRect;
      }

      getTrueCursor() {
        return this.toTruePoint(this.cursor);
      }

      truePointFromNoOrPoint(noOrPoint) {

        const stdBaseVectors = this.getStdBaseVectors();
        // console.log("stdBaseVectors", stdBaseVectors);

        const trueX = Geometry.dotProduct_2d(noOrPoint, stdBaseVectors.u);
        const trueY = Geometry.dotProduct_2d(noOrPoint, stdBaseVectors.v);

        const truePoint = Geometry.createPoint(trueX, trueY);

        return truePoint;
      }



      //noOr == no orientation == almost true point (wrong axes orientation)
      toNoOrX(screenX) {
        const noOrX = (screenX / this.scale.X) - this.offset.dx;
        return noOrX;
      }

      toNoOrY(screenY) {
        const noOrY = (screenY / this.scale.Y) - this.offset.dy;
        return noOrY;
      }

      toNoOrPoint(screenPoint) {
        return Geometry.createPoint(this.toNoOrX(screenPoint.x), this.toNoOrY(screenPoint.y));
      }

      toNoOrRect(screenRect) {
        const noOrTL = this.toNoOrPoint(Geometry.getPointTL(screenRect));
        const noOrBR = this.toNoOrPoint(Geometry.getPointBR(screenRect));
        const w = noOrBR.x - noOrTL.x;
        const h = noOrBR.y - noOrTL.y;
        return Geometry.createRect(noOrTL.x, noOrTL.y, w, h);
      }



      getCanvasBoundingRect() {
        // return canvas.getBoundingClientRect();
        return this.canvas.getBoundingClientRect();
      }

      getCanvasBoundingTrueRect() {
        const canvasBoundingRect = this.getCanvasBoundingRect();

        const trueRect = this.toTrueRect(canvasBoundingRect);

        return trueRect;
      }


      getScreenRect() {
        return this.getCanvasBoundingRect();
      }

      getScreenCenterPoint() {
        return Geometry.getCenterPoint(this.getCanvasBoundingRect());
      }

      getTrueCenterPoint() {
        const centerPoint_screen = this.getScreenCenterPoint();
        // console.log("centerPoint_screen", centerPoint_screen);
        const centerPoint_true   = this.toTruePoint(centerPoint_screen);
        return centerPoint_true;
      }

      getNoOrCenterPoint() {
        const centerPoint_screen = this.getScreenCenterPoint();
        // console.log("centerPoint_screen", centerPoint_screen);
        const centerPoint_noOr   = this.toNoOrPoint(centerPoint_screen);
        return centerPoint_noOr;
      }



      //"entry points"

      manageCursorMove_line() {

        /*
        //create line
        const line = {
            x0: prevScaledX,
            y0: prevScaledY,
            x1: scaledX,
            y1: scaledY
        };

        //console.log("line", line);

        // add the line to our drawing history
        drawings.push(line);

        // draw a line
        drawLine(prevCursorX, prevCursorY, cursorX, cursorY);
        */

      }

      manageCursorMove_offset() {

        const noOr_cursor         = this.toNoOrPoint(this.cursor);
        const noOr_previousCursor = this.toNoOrPoint(this.previousCursor);

        // move the screen
        const dOffsetX = (noOr_cursor.x - noOr_previousCursor.x) * this.inputProperties.moveProperties.moveMultiplier;
        const dOffsetY = (noOr_cursor.y - noOr_previousCursor.y) * this.inputProperties.moveProperties.moveMultiplier;

        const dOffset = {
          dx: dOffsetX,
          dy: dOffsetY,
        };

        //console.log("offset", offset);
        this.updateDOffset(dOffset);
        this.redrawCanvas(RedrawOccasion.offsetChanged);
      }

      manageCursorMove_rotate() {

        // console.log("this.cursor",         this.cursor);
        // console.log("this.previousCursor", this.previousCursor);

        // const screenRect   = this.getScreenRect();
        // console.log("screenRect", screenRect);
        const screenCenterPoint = this.getScreenCenterPoint();
        // console.log("screenCenterPoint", screenCenterPoint);


        // get rotation angle
        const v1 = {
          x: this.cursor.x - screenCenterPoint.x,
          y: this.cursor.y - screenCenterPoint.y,
        };
        const v2 = {
          x: this.previousCursor.x - screenCenterPoint.x,
          y: this.previousCursor.y - screenCenterPoint.y,
        };

        const norm_v1 = Geometry.norm_2d(v1);
        const norm_v2 = Geometry.norm_2d(v2);

        //angle = arccos[(xa * xb + ya * yb) / (√(xa2 + ya2) * √(xb2 + yb2))]
        const angle_abs = Math.acos( Geometry.dotProduct_2d(v1,v2) / (norm_v1 * norm_v2) );
        console.log("mcr", "angle_abs", angle_abs);

        if(isNaN(angle_abs)) {
          //ignore
          console.log("ignore", "isNaN(angle_abs) == true");
          // console.log("norm_v1", norm_v1);
          // console.log("norm_v2", norm_v2);
          return;
        }

        // * this.inputProperties.moveProperties.moveMultiplier

        //get the right sign
        const v1_3d = Geometry.vector_3d(v1);
        const v2_3d = Geometry.vector_3d(v2);
        const vn = {
          x:0,
          y:0,
          z:1,
        };

        const cross = Geometry.crossProduct_3d(v1_3d, v2_3d);
        // console.log("cross", cross);
        const sign = Geometry.dotProduct_3d(vn, cross) < 0 ? +1 : -1;

        const angleInRadians = sign * angle_abs;

        const angleInDegrees = angleInRadians * 180 / Math.PI;
        console.log("mcr", "angleInDegrees", angleInDegrees);

        const rotationCenter = this.getNoOrCenterPoint();
        // console.log("rotationCenter", rotationCenter);

        this.updateWithDRotation(angleInDegrees, rotationCenter);

        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }

      manageCenterRotation(angleInDegrees) {
        const rotationCenter = this.getNoOrCenterPoint();
        // console.log("rotationCenter", rotationCenter);

        this.updateWithDRotation(angleInDegrees, rotationCenter);

        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }

      logCursor() {

        console.log("this.cursor",         this.cursor);
        const true_cursor         = this.toTruePoint(this.cursor);
        console.log("true_cursor", true_cursor);


        const screenCenterPoint = this.getScreenCenterPoint();
        console.log("screenCenterPoint", screenCenterPoint);

      }




      //   // zoom the page based on where the cursor is
      //   var distX = event.pageX / canvas.clientWidth;
      //   var distY = event.pageY / canvas.clientHeight;
      //
      //   // calculate how much we need to zoom
      //   const unitsZoomedX = trueWidth() * scaleAmount;
      //   const unitsZoomedY = trueHeight() * scaleAmount;
      //
      //   const unitsAddLeft = unitsZoomedX * distX;
      //   const unitsAddTop = unitsZoomedY * distY;
      //
      //   offsetX -= unitsAddLeft;
      //   offsetY -= unitsAddTop;

      manageScaleUpdateWithScaleAmount(scaleAmount) {
        console.log("manageScaleUpdateWithScaleAmount", scaleAmount);

        const scale_new = {
          X: this.scale.X * (1 + scaleAmount),
          Y: this.scale.Y * (1 + scaleAmount),
        };


        // zoom the page based on where the cursor is
        const cursor            = this.cursor;
        const screenCenterPoint = this.getScreenCenterPoint();
        const screenRect        = this.getScreenRect();

        const cursorRatio = {
          X: cursor.x / screenRect.width,
          Y: cursor.y / screenRect.height,
        };
        console.log("cursorRatio", cursorRatio);

        const noOrRect = this.toNoOrRect(screenRect);

        const unitsZoomed = {
          X: noOrRect.width  * scaleAmount,
          Y: noOrRect.height * scaleAmount,
        };
        console.log("unitsZoomed", unitsZoomed);


        // const unitsZoomed = {
        //   X: this.trueWidth()  * scaleAmount,
        //   Y: this.trueHeight() * scaleAmount,
        // };

        // const sign = scaleAmount > 0 ? -1 : +1;

        const dOffset = {
          dx: - unitsZoomed.X * cursorRatio.X,
          dy: - unitsZoomed.Y * cursorRatio.Y,
        };
        console.log("dOffset", dOffset);

        this.updateScaleAndDOffset(scale_new, dOffset);

        this.redrawCanvas(RedrawOccasion.scaleChanged);
      }


      // zIndex

      enterZIndexEditing() {
        this.isZIndexEditing = true;


      }

      leaveZIndexEditing() {
        this.isZIndexEditing = false;


      }

      manageZIndexEditingScrement(screment) {
        console.log("manageZIndexEditingScrement", screment);

        //get selected objects
        const arr_rep_free = Object.values(this.represented).map(represented => represented.r_free());
        const arr_rep_free_selected = arr_rep_free
                                      .filter(rep_free => {
                                        return rep_free.isSelected;
                                      });

        //update zIndex
        arr_rep_free_selected.forEach((rep_free, i) => {
          rep_free.zIndex += screment;
        });

        // if(icObj_active.type == "composite") {
        //
        // } else {
        //   icObj_active.zIndex += screment;
        // }

      }

      getArrZIndex() {
        const arr_represented  = Object.values(this.represented);
        // const arr_rep_official = arr_represented.map(represented => represented.r_official());
        const arr_rep_free     = arr_represented.map(represented => represented.r_free());

        const arr_zIndex = arr_rep_free.map(rep_free => rep_free.zIndex);
        return arr_zIndex;
      }

      getFreshZIndex() {
        var outIndex;

        const arr_zIndex = this.getArrZIndex();
        if(arr_zIndex.length == 0) {
          outIndex = 0;
        } else {
          const zIndex_max = math.max(arr_zIndex);

          outIndex = zIndex_max + 1;
        }

        return outIndex;
      }











      //save/load

      createInfinishute_p() {

        const counter = this.counter;
        const offset  = this.offset;
        const scale   = this.scale;
        const orientation = this.orientation;

        // const arr_icObjects_serial_p = this.icObjects.any.map(icObj => icObj.toSerial_p());
        // console.log("this.icObjects['any'].length", this.icObjects['any'].length);
        // console.log("this.icObjects.any.length",    this.icObjects.any.length);

        const arr_official_serial_p = Object.values(this.represented).map(represented => represented.officialSerial_p());
        const all_official_serial_p = Promise.all(arr_official_serial_p);

        // const arr_rep_serial_p = Object.values(this.representations).map(rep => rep.toSerial_p());
        // const all_rep_serial_p = Promise.all(arr_rep_serial_p);

        const infinishute_p = all_official_serial_p.then((arr_official_serial) => {
          const infinishute = {};

          infinishute.offset      = offset;
          infinishute.scale       = scale;
          infinishute.orientation = orientation;

          infinishute.counter     = counter;

          infinishute.official = arr_official_serial.reduce((acc, official) => {
            console.log("official", )
            acc[official.id] = official;
            return acc;
          }, {});

          // infinishute.representations = arr_rep_serial.reduce((acc, rep) => {
          //   acc[rep.id_rep] = rep;
          //   return acc;
          // }, {});

          return infinishute;
        });

        return infinishute_p;
      }

      manageSaveInfinishute_p() {

        const infiniteCanvas = this;
        const infinishute_p = this.createInfinishute_p();

        return infinishute_p

                //debug
               .then(infinishute => {
                 console.log("infinishute", infinishute);
                 return infinishute;
               })

               .then(infinishute => {
                 return FileIntegration.saveInfinishute_p(infinishute);
               })
               .then(success => {
                 console.log("saveInfinishute_p", "success", success);
                 infiniteCanvas.setChanged(!success);
               });
      }

      manageSaveInfinishute_p_2(infinishute_p) {

        return infinishute_p
               .then(infinishute => {
                 return FileIntegration.saveInfinishute_p(infinishute);
               })
               .then(success => {
                 console.log("saveInfinishute_p", "success", success);
                 infiniteCanvas.setChanged(!success);
               });

      }


      manageLoadInfinishute(json) {
        console.log("manageLoadInfinishute", json);

        this.offset      = json.offset;
        this.scale       = json.scale;
        this.orientation = json.orientation;

        this.counter = json.counter;

        const infiniteCanvas = this;

        const arr_official = Object.values(json.official);

        const arr_icObj_p = arr_official.map((json_icObject, i) => {
          const icObj_p = IcObject.fromJson_p(json_icObject);
          return icObj_p;
        });

        Promise.all(arr_icObj_p)
        .then(arr_icObj => {
          console.log("manageLoadInfinishute", "arr_icObj", arr_icObj);

          arr_icObj.forEach((icObj, i) => {
            console.log("manageLoadInfinishute", "icObj", icObj);

            infiniteCanvas.addDehydratedIcObject(icObj);
            // infiniteCanvas.addRepresented(icObj);
          });

        });

      }


      //core mutators

      updateCursor(cursor) {
        // console.log("updateCursor", cursor);
        this.previousCursor = Object.assign({}, this.cursor);
        this.cursor         = Object.assign({}, cursor);
      }


      updateOffset(offset_new) {
        console.log("updateOffset", offset_new);

        this.previousOffset = Object.assign({}, this.offset);

        this.offset = Object.assign({}, offset_new);

        this.dOffset.dx = this.offset.dx - this.previousOffset.dx;
        this.dOffset.dy = this.offset.dy - this.previousOffset.dy;

        // this.redrawCanvas(RedrawOccasion.offsetChanged);
      }

      updateScale(scale_new) {
        this.scale = Object.assign({}, scale_new);
        // this.update("scale", Object.assign({}, scale_new));

        this.didUpdateListenersDict["scaleChanged"].forEach((listener, i) => {
          listener(this);
        });
      }


      updateDOffset(dOffset_new) {
        const offset_new = {
          dx: this.offset.dx + dOffset_new.dx,
          dy: this.offset.dy + dOffset_new.dy,
        };
        this.updateOffset(offset_new);
      }

      updateScaleAndDOffset(scale_new, dOffset) {
        //console.log("updateScaleAndDOffset", scale_new, dOffset);
        this.updateScale(scale_new);
        this.updateDOffset(dOffset);
      }

      updateScaleAndOffset(scale_new, offset) {
        console.log("updateScaleAndOffset", scale_new, offset);
        this.updateScale(scale_new);
        this.updateOffset(offset);
      }

      updateOrientation(orientation_new) {
        console.log("updateOrientation", orientation_new);
        var orientation_bounded = Geometry.boundedAngleInDegrees(orientation_new);
        console.log("orientation_bounded", orientation_bounded);
        this.orientation = orientation_bounded;
      }

      updateWithDRotation(angleInDegrees, noOrCenterPoint) {
        console.log("updateWithDRotation", angleInDegrees, noOrCenterPoint);

        console.log("angleInDegrees", angleInDegrees);

        const radius = Geometry.norm_2d(noOrCenterPoint);

        // this.addPurePoint(centerPoint);
        // this.addPureCircle(centerPoint, radius);

        // this.addPoint(noOrCenterPoint);
        // this.addCircle(noOrCenterPoint, radius);

        const orientation_new = this.orientation - angleInDegrees;
        this.updateOrientation(orientation_new);


        const v = {
          x: noOrCenterPoint.x,
          y: noOrCenterPoint.y,
        };
        // console.log("v.x", v.x);
        // console.log("v.y", v.y);

        const angleInRadians = angleInDegrees / 180 * Math.PI;

        const ddx = Math.cos(angleInRadians) * v.x - Math.sin(angleInRadians) * v.y;
        const ddy = Math.sin(angleInRadians) * v.x + Math.cos(angleInRadians) * v.y;
        // console.log("ddx", ddx);
        // console.log("ddy", ddy);

        const dx = v.x - ddx
        const dy = v.y - ddy;
        // console.log("dx", dx);
        // console.log("dy", dy);


        const doffset_new = {
          dx: dx,
          dy: dy,
        };
        // console.log("doffset_new", doffset_new);

        this.updateDOffset(doffset_new);


      }


      updateWithDOrientation(dOrientation) {
        const orientation_new = this.orientation + dOrientation;
        this.updateOrientation(orientation_new);

        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }


      move_to_initial_position() {
        console.log("move_to_initial_position");
        this.updateScaleAndOffset(this.coords_initial.scale, this.coords_initial.offset);
      }

      getCurrentPov() {
        const scale  = this.scale;
        const offset = this.offset;

        const pov = new POV(scale, offset);
        return pov;
      }

      set_pov(pov) {
        this.updateScaleAndOffset(pov.scale, pov.offset);
      }


      move_to_position(position) {
        console.log("move_to_position", position);

        const offset = {
          dx: -position.x,        //SHU: this is a bit ???
          dy: -position.y,
        };
        this.updateScaleAndOffset(this.scale, offset);
        this.redrawCanvas(RedrawOccasion.offsetChanged);
      }




      manageImageImport(img) {
        this.addNewImage(img);
      }

      manageTextImport(text) {
        this.addNewText(text);
      }





      //top down request
      requestViewUpdateForIcObj(icObj) {
        console.log("requestViewUpdateForIcObj", icObj);
        this.requestSyncWithIcObjListeners.forEach((listener, i) => {
          listener(icObj);
        });
      }


    }


    class IcObject {

      constructor(id, type, position, size, homeScale) {
        this.id   = id;
        this.type = type;

        this.position = position;
        this.size     = size;       //"information" size    //gives an idea of the sharpness/heavyness of the object

        this.homeScale = homeScale;

        this.orientation = 0;
        this.scale     = {
          X:1,
          Y:1,
        };
        this.flip = {
          X:false,
          Y:false,
        };

        this.zIndex = 0;


        this.fill   = "";
        this.stroke = "";
        // this.colors = {};
        this.opacity = 1.0;

        this.strokeWidth = 3;

        this.backgroundColor = "";

        // this.hotState = {
        //   toBeDeleted: false,
        //
        //   perceptionScale: {
        //     X:1,
        //    Y:1,
        //   },
        // };

        this.canBeMoved    = true;
        this.canBeRotated  = true;
        this.canBeResized  = true;
        this.canBeSelected = true;

        this.canBeHeld     = true;

        // this.isSnapped     = false;
        this.isSnappable   = true;
        this.snapState     = SnapState.Unsnapped;
        this.snappedTo     = -1;

        // this.isTouchable    = true;
        this.isTouchable    = false;
        // this.touchState    = TouchState.Untouched;
        this.touchStateDict = {};


        this.cType           = "";
        this.isCompositePart = false;
        this.isMobile        = false;
        this.compositeId     = -1;

        this.isHeld          = false;
        // this.addInteraction_hold();

        this.isUsingCenterPosition = false;

        this.isSelected      = false;

        // this.exoObject     = null;

        this.didUpdateListeners = [];
      }

      static fromJson_p(json_icObject) {
        console.log("fromJson_p", json_icObject);

        const id   = json_icObject.id;
        const type = json_icObject.type;

        const position = json_icObject.position;
        const size     = json_icObject.size;

        const homeScale = json_icObject.homeScale;


        const icObj = new IcObject(id, type, position, size, homeScale);


        const scale = json_icObject.scale;
        icObj.scale = scale;

        const orientation = json_icObject.orientation;
        icObj.orientation = orientation;

        const flip = json_icObject.flip;
        icObj.flip = flip;

        const zIndex = json_icObject.zIndex;
        icObj.zIndex = zIndex;


        const fill   = json_icObject.fill;
        icObj.fill = fill;
        const stroke = json_icObject.stroke;
        icObj.stroke = stroke;

        const backgroundColor = json_icObject.backgroundColor;
        icObj.backgroundColor = backgroundColor;

        const opacity = json_icObject.opacity;
        icObj.opacity = opacity;


        const isSnappable = json_icObject.isSnappable;
        icObj.isSnappable = isSnappable;
        const snapState = json_icObject.snapState;
        icObj.snapState = snapState;
        const snappedTo = json_icObject.snappedTo;
        icObj.snappedTo = snappedTo;


        const isTouchable  = json_icObject.isTouchable;
        icObj.isTouchable  = isTouchable;
        // const touchState = json_icObject.touchState;
        // icObj.touchState = touchState;
        const touchStateDict = json_icObject.touchStateDict;
        icObj.touchStateDict = touchStateDict;


        const cType           = json_icObject.cType;
        icObj.cType           = cType;
        const isCompositePart = json_icObject.isCompositePart;
        icObj.isCompositePart = isCompositePart;
        const isMobile        = json_icObject.isMobile;
        icObj.isMobile        = isMobile;
        const compositeId     = json_icObject.compositeId;
        icObj.compositeId     = compositeId;

        if(json_icObject.engine_serial != null) {
          const eType           = json_icObject.eType;
          icObj.eType           = eType;
          const engine_serial   = json_icObject.engine_serial;

          // const engine          = deserialize(engine_serial);
          // console.log("rehydrated engine", engine);
          // // engine.initialize()
          // icObj.engine          = engine;

          const virgin          = deserialize(engine_serial);

          icObj.engine            = {};
          icObj.engine.initialize = virgin.initialize.bind(icObj.engine);
          icObj.engine.virgin     = virgin;

          console.log("rehydrated engine", icObj.engine);


          const getScopeObj = deserialize(json_icObject.getScopeObj);
          icObj.getScopeObj = getScopeObj;
        }

        const isUsingCenterPosition = json_icObject.isUsingCenterPosition;
        icObj.isUsingCenterPosition = snappedTo;


        var icObj_p = Promise.resolve(icObj);

        switch(icObj.type) {
          case "text":
          case "tag":
            const text      = json_icObject.text;
            icObj.text      = text;
            const textColor = json_icObject.textColor;
            icObj.textColor = textColor;
            const fontSize  = json_icObject.fontSize;
            icObj.fontSize  = fontSize;

            break;
          case "image":
            const img_serial = json_icObject.img;
            const img_p = FileIntegration.imageFromImgSrc_p(img_serial);

            const arr_p = [icObj_p, img_p];

            icObj_p = Promise.all(arr_p)
                      .then(([icObj, img]) => {

                        icObj.img = img;

                        return icObj;
                      });
            break;
          case "circle":
            const radius   = json_icObject.radius;

            icObj.radius = radius;
            break;

          case "group":
            {
              const children = json_icObject.children;

              const arr_p = children.map(json_child => {
                const icObj = IcObject.fromJson_p(json_child);
                return icObj;
              });

              icObj_p = Promise.all(arr_p)
              .then((arr_icObj) => {
                icObj.children = arr_icObj;

                return icObj;
              });
            }
            break;

          case "freeDrawing":
            const exoObject   = json_icObject.exoObject;
            icObj.exoObject = exoObject;
            break;

          case "sparkle":
            {
            const img_serial = json_icObject.img;
            const img_p = FileIntegration.imageFromImgSrc_p(img_serial);

            const arr_p = [icObj_p, img_p];

            icObj_p = Promise.all(arr_p)
                      .then(([icObj, img]) => {

                        icObj.img = img;

                        return icObj;
                      });
            }
            break;

          case "touchSlot":
            {
            const touchSlotConfig_serial = json_icObject.touchSlotConfig_serial;
            const touchSlotConfig        = deserialize(touchSlotConfig_serial);

            icObj_p = icObj_p
                      .then(icObj => {

                        icObj.touchSlotConfig = touchSlotConfig;

                        return icObj;
                      })

            }
            break;

          case "snapSlot":
            {
            const snapSlotConfig_serial = json_icObject.snapSlotConfig_serial;
            const snapSlotConfig        = deserialize(snapSlotConfig_serial);

            icObj_p = icObj_p
                      .then(icObj => {

                        icObj.snapSlotConfig = snapSlotConfig;

                        return icObj;
                      })

            }
            break;

          case "composite":
            {
              const parts = json_icObject.parts;

              // const arr_p = parts.map(json_part => {
              //   const icObj = IcObject.fromJson_p(json_part);
              //   return icObj;
              // });
              // icObj_p = Promise.all(arr_p)
              // .then((arr_icObj) => {
              //   icObj.parts = arr_icObj;
              //
              //   // if(icObj.engine == null) {
              //   //   icObj.engine = Compositer.defaultCompositeEngine(icObj, icObj.parts);
              //   // }
              //
              //   return icObj;
              // });

              const arr_part_serial_miniDict_p = Object.entries(parts).reduce((acc, [partName, json_part]) => {
                const part_miniDict_p = IcObject.fromJson_p(json_part)
                                                 .then(icObj => {

                                                   const part_miniDict = {
                                                     [partName]: icObj,
                                                   };

                                                   return part_miniDict;
                                                 });

                acc.push(part_miniDict_p);
                return acc;
              }, []);

              icObj_p = Promise.all(arr_part_serial_miniDict_p)
              .then((arr_part_miniDict) => {
                icObj.parts = {};
                Object.assign(icObj.parts, ...arr_part_miniDict);

                return icObj;
              });


              const compositeConfig_serial = json_icObject.compositeConfig_serial;
              const compositeConfig        = deserialize(compositeConfig_serial);

              icObj_p = icObj_p
                        .then(icObj => {
                          icObj.compositeConfig = compositeConfig;
                          return icObj;
                        });
            }
            break;

          case "mathNode":
            const mathNode  = math.parse(json_icObject.mathNodeString);
            icObj.mathNode  = mathNode;
            break;


          // case "engined":
          //
          //   break;

          default:
            break;
        }


        return icObj_p;
      }

      toSerial_p() {
        var out_p;

        const icObj = this;

        const icObj_serial = Object.assign({}, icObj);

        if(icObj.engine != null) {
          const engine = icObj.engine;

          //don't serialize engine directly
          delete icObj_serial.engine;

          //serialize the virgin version of engine (== a version which is context-free and not bound)
          const virgin = engine.virgin;

          const engine_cloned = Object.assign({}, virgin);
          console.log("engine_cloned", engine_cloned);

          const engine_serial = serialize(engine_cloned);
          icObj_serial.engine_serial = engine_serial;

          icObj_serial.getScopeObj = serialize(icObj.getScopeObj);  //SHU: maybe this function is a bit useless
        }

        var icObj_serial_p = Promise.resolve(icObj_serial);

        switch(icObj.type) {
          // case "text":
          //   const text     = icObj.text;
          //   const fontSize = icObj.fontSize;
          //
          //   icObj_serial.text     = text;
          //   icObj_serial.fontSize = fontSize;
          //
          //   break;
          case "image":
            {
            const img = icObj.img;
            const img_serial_p = FileIntegration.dataUrlForImgViaCanvas_p(img);

            const arr_p = [icObj_serial_p, img_serial_p];

            icObj_serial_p = Promise.all(arr_p)
                                    .then(([icObj_serial, img_serial]) => {

                                      icObj_serial.img = img_serial;
                                      return icObj_serial;
                                    });
            }
            break;

          // case "circle":
          //   const radius     = icObj.radius;
          //   icObj_serial.radius = radius;
          //
          //   break;

          // case "group":
          //   const children = icObj.children;
          //   icObj_serial.children = children;
          //
          //   break;

          case "freeDrawing":
            {
            const exoObject = icObj.exoObject;
            const exoObject_serial = Object.assign({}, exoObject);
            icObj_serial.exoObject = exoObject_serial;
            }
            break;

          case "sparkle":
            {
            const img = icObj.img;
            const img_serial_p = FileIntegration.dataUrlForImgViaCanvas_p(img);

            const arr_p = [icObj_serial_p, img_serial_p];

            icObj_serial_p = Promise.all(arr_p)
                                    .then(([icObj_serial, img_serial]) => {

                                      icObj_serial.img = img_serial;
                                      return icObj_serial;
                                    });
            }
            break;

          case "touchSlot":
            {
            const touchSlotConfig = icObj.touchSlotConfig;
            const touchSlotConfig_serial = serialize(touchSlotConfig);

            icObj_serial_p = icObj_serial_p
                            .then((icObj_serial) => {

                              icObj_serial.touchSlotConfig_serial = touchSlotConfig_serial;
                              return icObj_serial;
                            });
            }
            break;

          case "snapSlot":
            {
            const snapSlotConfig = icObj.snapSlotConfig;
            const snapSlotConfig_serial = serialize(snapSlotConfig);

            icObj_serial_p = icObj_serial_p
                            .then((icObj_serial) => {

                              icObj_serial.snapSlotConfig_serial = snapSlotConfig_serial;
                              return icObj_serial;
                            });
            }
            break;



          case "composite":
            {
            const parts = icObj.parts;
            const arr_part_serial_miniDict_p = Object.entries(icObj.parts).reduce((acc, [partName, part]) => {
              const part_serial_miniDict_p = part.toSerial_p()
                                               .then(part_serial => {

                                                 const part_serial_miniDict = {
                                                   [partName]: part_serial,
                                                 };

                                                 return part_serial_miniDict;
                                               });

              acc.push(part_serial_miniDict_p);
              return acc;
            }, []);

            icObj_serial_p = Promise.all([icObj_serial_p, ...arr_part_serial_miniDict_p])
                                    .then(([icObj_serial, ...arr_part_serial_miniDict]) => {    //SHU: wow, pas mal le spread operator
                                      // icObj_serial.parts = arr_part_serial_miniDict.reduce((acc, x) => {
                                      //   Object.assign(acc, x);
                                      //   return acc;
                                      // }, {});
                                      icObj_serial.parts = {};
                                      Object.assign(icObj_serial.parts, ...arr_part_serial_miniDict);
                                      return icObj_serial;
                                    });

            const compositeConfig        = icObj.compositeConfig;
            const compositeConfig_serial = serialize(compositeConfig);

            icObj_serial_p = icObj_serial_p
                            .then((icObj_serial) => {

                              icObj_serial.compositeConfig_serial = compositeConfig_serial;
                              return icObj_serial;
                            });
            }
            break;

          case "mathNode":
            {
            const mathNode       = icObj.mathNode;
            const mathNodeString = mathNode.toString();
            const mathNode_serial_p = Promise.resolve(mathNodeString);

            const arr_p = [icObj_serial_p, mathNode_serial_p];

            icObj_serial_p = Promise.all(arr_p)
                                    .then(([icObj_serial, mathNode_serial]) => {

                                      icObj_serial.mathNodeString = mathNode_serial;
                                      return icObj_serial;
                                    });
            }
            break;

          default:
            break;
        }

        out_p = icObj_serial_p;

        return out_p;
      }


      addInteraction_hold() {
        console.log("IcObject::addInteraction_hold", "this.id", this.id, this.id_rep);
        const icObj = this;

        icObj.holdListeners     = [];
        icObj.nowHeld = () => {
          icObj.isHeld = true;
          icObj.holdListeners.forEach((listener, i) => {
            listener(icObj);
          });
        }
        icObj.onHold  = (listener) => {
          icObj.holdListeners.push(listener);
        };
        icObj.offHold = (listener) => {
          icObj.holdListeners = Utils.arrayByRemovingElement(icObj.holdListeners, listener);
        };

        icObj.releaseListeners = [];
        icObj.nowReleased = () => {
          icObj.isHeld = false;
          icObj.releaseListeners.forEach((listener, i) => {
            listener(icObj);
          });
        }
        icObj.onRelease  = (listener) => {
          icObj.releaseListeners.push(listener);
        };
        icObj.offRelease = (listener) => {
          icObj.releaseListeners = Utils.arrayByRemovingElement(icObj.releaseListeners, listener);
        };

      }

      addInteraction_edit() {
        const icObj = this;

        icObj.editEnterListeners     = [];
        icObj.nowEditEnter = () => {
          icObj.isEditing = true;
          icObj.editEnterListeners.forEach((listener, i) => {
            listener(icObj);
          });
        }
        icObj.onEditEnter  = (listener) => {
          icObj.editEnterListeners.push(listener);
        };
        icObj.offEditEnter = (listener) => {
          icObj.editEnterListeners = Utils.arrayByRemovingElement(icObj.editEnterListeners, listener);
        };

        icObj.editExitListeners = [];
        icObj.nowEditExit = () => {
          icObj.isEditing = false;
          icObj.editExitListeners.forEach((listener, i) => {
            listener(icObj);
          });
        }
        icObj.onEditExit  = (listener) => {
          icObj.editExitListeners.push(listener);
        };
        icObj.offEditExit = (listener) => {
          icObj.editExitListeners = Utils.arrayByRemovingElement(icObj.editExitListeners, listener);
        };

      }

      addInteraction_click() {
        console.log("IcObject::addInteraction_click", "this.id", this.id, this.id_rep);
        const icObj = this;

        icObj.clickListeners = [];
        icObj.nowClicked = () => {
          icObj.clickListeners.forEach((listener, i) => {
            listener(icObj);
          });
        };
        icObj.onClick = (listener) => {
          icObj.clickListeners.push(listener);
        };

      }




      getScreenPositionWithoutOffset() {
        const screenX = this.position.x * this.homeScale.X;
        const screenY = this.position.y * this.homeScale.Y;
        return Geometry.createPoint(screenX, screenY);
      }

      getScreenPointBRWithoutOffset() {       //SHU TODO: take orientation into account
        const screenX = (this.position.x + this.size.width)  * this.homeScale.X;
        const screenY = (this.position.y + this.size.height) * this.homeScale.Y;
        return Geometry.createPoint(screenX, screenY);
      }

      getScreenRect() {
        const screenPointTL = this.getScreenPositionWithoutOffset();
        const screenPointBR = this.getScreenPointBRWithoutOffset();

        const left   = screenPointTL.x;
        const top    = screenPointTL.y;
        const width  = screenPointBR.x - screenPointTL.x;
        const height = screenPointBR.y - screenPointTL.y;
        return Geometry.createRect(left, top, width, height);
      }



      getHomeScreenSize() {
        return this.size;
      }

      // getTrueSize() {
      //   // const homeScreenSize = this.getHomeScreenSize();
      //   const trueSize = {
      //     width:    this.size.width / this.homeScale.X * this.scale.X,
      //     height:   this.size.width / this.homeScale.Y * this.scale.Y,
      //   }
      //   return trueSize;
      // }

      getRect() {
        const rect = Geometry.createRect(this.position.x, this.position.y, this.size.width, this.size.height);
        return rect;
      }



      update(icObj_new, requestCanvasRedraw) {
        // console.log("icObj.update", "icObj_new", icObj_new);

        const icObj = this;

        if(icObj_new.type != icObj.type) {
          // console.log("invalid type for icObj_new", "icObj", icObj, "icObj_new", icObj_new);
          throw new Error("invalid type for icObj_new" + "icObj" + icObj + "icObj_new" + icObj_new);
        }

        this.position = Object.assign({}, icObj_new.position);
        this.size     = Object.assign({}, icObj_new.size);

        this.homeScale = Object.assign({}, icObj_new.homeScale);

        this.scale       = Object.assign({}, icObj_new.scale);
        this.orientation = icObj_new.orientation;
        this.flip        = Object.assign({}, icObj_new.flip);

        // this.fill        = icObj_new.fill;
        // this.stroke      = icObj_new.stroke;


        // this.perceptionScale = Object.assign({}, icObj_new.perceptionScale);

        if(this.type == "text") {
          this.text     = icObj_new.text;
          this.fontSize = icObj_new.fontSize;
        }

        if(this.type == "toggleRect") {
          this.isActive = icObj_new.isActive;
        }

        this.didUpdate(requestCanvasRedraw);
      }


      didUpdate(requestCanvasRedraw) {
        const icObj = this;
        this.didUpdateListeners.forEach((listener, i) => {      //SHU: todo: "everything is promised"
          listener(icObj, requestCanvasRedraw);
        });
      }

      delete_p() {
        return new Promise((resolve, reject) => {

          this.toBeDeleted = true;

          this.didUpdate(false);

          resolve(this);
        });
      }

      clone() {
        const id   = this.id;
        const type = this.type;

        const position = this.position;
        const size     = this.size;

        const homeScale = this.homeScale;

        const icObj_clone = new IcObject(id, type, position, size, homeScale);

        Object.assign(icObj_clone, this);
        console.log("icObj_clone", icObj_clone);

        return icObj_clone;
      }

      deepClone() { //SHU TODO: pour l'instant j'ai la flemme, mais il faudra des deep copy
        const id   = this.id;
        const type = this.type;

        const position = {
          x: this.position.x,
          y: this.position.y,
        };
        const size     = {
          width:  this.size.width,
          height: this.size.height,
        };

        const homeScale = {
          X: this.homeScale.X,
          Y: this.homeScale.Y,
        };

        const icObj_clone = new IcObject(id, type, position, size, homeScale);

        // Object.entries(this).forEach(([key, value], i) => {
        //   // if(icObj_clone[key] == null) {
        //     const valueDeepCopy = JSON.parse(JSON.stringify(value));
        //     icObj_clone[key] = valueDeepCopy;
        //   // }
        // });

        const arr_alreadySet = [
          "id",
          "type",
          "position",
          "size",
          "homeScale",
        ];

        Object.entries(this)
        .filter(([key, value]) => {
          const valueAlreadyCopied = (arr_alreadySet.includes(key));
          // console.log(key, valueAlreadyCopied);
          return !valueAlreadyCopied;
        })
        .forEach(([key, value], i) => {
          // if(icObj_clone[key] == null) {
            // const valueDeepCopy = JSON.parse(JSON.stringify(value));
            // icObj_clone[key] = valueDeepCopy;
            const valueCopy  = value;
            icObj_clone[key] = valueCopy;
          // }
        });

        return icObj_clone;
      }


    }


    /*
    class IcComposite {

      constructor(handle, otherPartsDict) {
        this.parts  = Object.assign(otherPartsDict, {
          "handle": handle,
        };
      }

      getHandle() {
        return this.parts["handle"];
      }

      getPart(icObjId) {
        const part = Object.values(this.parts).find(part => (part.icObject.id == icObjId));
        return part;
      }

      getIcObject(icObjId) {
        const part = this.getPart(icObjId);
        return part ? part.icObject : null;
      }

      managePartUpdate(part, updateDict) {

        const icObj_compositePart = part.icObject;

        const arr_compositePartIcObj = Object.values(this.parts).map(compositePart => compositePart.icObject);
        const arr_compositePartIcObj__other = arr_compositePartIcObj.filter(icObj => icObj.id != icObj_compositePart.id);

        arr_compositePartIcObj__other.forEach((icObj, i) => {

          //test
          // icObj.position = Object.assign({}, icObj_compositePart.position);

          //get free rep
          // const represented = infiniteCanvas.getRepresented(icObj.id);
          // const rep_free    = represented.r_free();

          const rep_free = icObj;

          if(outerUpdatesDict.position != null) {

            const position_offset = {
              dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
              dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
            };
            // console.log("position_offset", position_offset);

            const obj = {
              position: {
                x: rep_free.position.x + position_offset.dx,
                y: rep_free.position.y + position_offset.dy,
              },
            };

            rep_free.syncWith(obj);

            //debug
            // rep_free.position = {
            //   x: icObj_compositePart.position.x + 100,
            //   y: icObj_compositePart.position.y + 100,
            // };

          }

        });

      }

      outerUpdatePart(part, updateDict) {

      }

    }

    class IcCompositePart {

      constructor(icObject, isMobile = false) {
        this.icObject = icObject;

        this.isMobile = isMobile;
      }

    }
    */







    /* POVs */

    class POV {

      constructor(scale, offset) {

      }

      static debug() {
        const scale  = 5;
        const offset = {
          dx:+100,
          dy:+100,
        };
        return new POV(scale, offset);
      }


    }



    class Animation {

      constructor() {
        const animationConfig__default = {
          duration: 5000,  //duration == 0 => instant teleport, 'blink'
          /*
          animation : linear,
          */
        }
      }

      move_to_pov__animation(pov_to, animationConfig) {
        console.log("move_to_initial_position");

        const pov_from = getCurrentPov();
        console.log("pov_from", pov_from);

        const duration = animationConfig.duration;

        const time_start = Date.now();

        const frame_duration = 17; //17 ms <-> 60 Hz
        const myIntervalLoop = setInterval(function () {

          const time_curr = Date.now();
          const elapsed   = time_curr - time_start;

          const progress   = getProgress(elapsed, duration);

          // console.log("progress", progress);
          if (progress < 1.0) {
            const pov_target = getPovForProgress(pov_from, pov_to, progress);
            // console.log("pov_target", pov_target);
            set_pov(pov_target);
          } else {
            set_pov(pov_to);
            clearInterval(myIntervalLoop);
          }
        }, frame_duration);

        updateScaleAndOffset(coords_initial.scale, coords_initial.offset);
      }

      getPovForProgress(pov_from, pov_to, progress) {
        const arr_propPaths = [
          "scale",
          "offset.dx",
          "offset.dy",
        ];
        function getPropForPropPath(obj, propPath) {
          const arr_path = propPath.split(".");
          return arr_path.reduce((acc, pathElt) => {
            return acc[pathElt];
          }, obj);
        }
        function setPropAtPropPath(obj, propPath, value) {
          const arr_path = propPath.split(".");
          const arr__all_but_last = arr_path.slice(0, -1);
          const penultimate = arr__all_but_last.reduce((acc, pathElt) => {

            //create if not found
            if(acc[pathElt] == null) {
              acc[pathElt] = {};
            }

            return acc[pathElt];
          }, obj);

          const [lastPathElt] = arr_path.slice(-1);
          penultimate[lastPathElt] = value;
        }
        const pov_progress = arr_propPaths.reduce((acc, propPath) => {
          const prop_from = getPropForPropPath(pov_from, propPath);
          const prop_to   = getPropForPropPath(pov_to, propPath);

          //linear progress
          const prop_progress = prop_from + (prop_to - prop_from) * progress;

          setPropAtPropPath(acc, propPath, prop_progress);

          return acc;
        }, {});

        return pov_progress;
      }

      getProgress(curr, total) {
        return curr/total;
      }

    }







    /*****
      REPRESENTATIONS / BACKING OBJECT
    *//////

    var ID = () => {
      let arr = new Uint32Array(8);
      window.crypto.getRandomValues(arr);
      let str = '';
      for (let i = 0; i < arr.length; i++) {
        str += (i < 2 || i > 5 ? '' : '-') + arr[i].toString(16).slice(-4);
      }
      return str;
    };

    class BackingSchema {

      constructor(propsDict) {
        const arr_entries = Object.entries(propsDict).map(([propName, prop]) => {
          var propType;
          if(prop != null) {
            propType = prop.constructor;
          } else {
            propType = Object;
          }
          return [propName, propType];
        });
        const propConstructorsDict = Object.fromEntries(arr_entries);

        Object.assign(this, propConstructorsDict);
      }

      static fromObject(obj) {
        return new BackingSchema(obj);
      }
    }

    class BackingObject {

      constructor(repClass, backingSchema, obj = null) {
        this.id = ID();

        /**/
        //pour la forme
        this.repClass      = repClass;
        this.backingSchema = backingSchema;
        /**/

        // this.counter = 0;
        this.representations = {};

        // this.inner = new repClass();                                                     //}
        //this.inner = {};                                                                  //} SHU: ça se discute
        this.innerRep = createRepresentation(obj, "id_inner_rep" + "__" + this.id, []);     //}
        this.addRepresentation(this.innerRep);
      }

      static fromBackingSchemaAndObject(backingSchema, obj) {
        const repClass = obj.constructor;

        const backingObject = new BackingObject(repClass, backingSchema, obj);
        return backingObject;
      }

      static fromObject(obj) {
        const repClass      = obj.constructor;
        const backingSchema = BackingSchema.fromObject(obj);

        const backingObject = new BackingObject(repClass, backingSchema, obj);
        return backingObject;
      }

      generateNewRepId() {
        // const id = this.counter;
        // this.counter += 1;
        // return id;

        const id_rep = ID();
        return id_rep;
      }

      getNewRepresentation() {
        const backingObj = this;

        const id_rep = backingObj.generateNewRepId();

        const target         = backingObj.innerRep;
        console.log("target", target);

        const arr_backingObj = [backingObj];
        const rep = createRepresentation(target, id_rep, arr_backingObj);

        backingObj.addRepresentation(rep);

        return rep;
      }

      // updateWithRepresentation(rep__update) {
      //
      //   const arr_affected = Object.values(this.representations).filter(rep => rep.id != rep__update.id);
      //
      //   arr_affected.forEach((rep, i) => {
      //     rep.syncWith(rep__update);
      //   });
      //
      // }

      updateWithPropFromRepresentation(propName, setValue, rep__update) {
        // console.log("updateWithPropFromRepresentation", propName, setValue, rep__update);
        // console.log("rep__update.id_rep", rep__update.id_rep);

        const arr_affected = Object.values(this.representations).filter(rep => rep.id_rep != rep__update.id_rep);
        // console.log("arr_affected", arr_affected.map(rep => rep.id_rep));

        arr_affected.forEach((rep, i) => {
          rep.updateFromOuter(propName, setValue, rep__update);
        });

      }

      addRepresentation(representation) {
        this.representations[representation.id_rep] = representation;
        // this.innerRep.follow(representation);  //SHU: innerRep now useless ?
      }

      removeRepresentation(rep) {
        //rep should no longer get any update from any other rep
        rep.unfollowAll();

        //all following reps must unfollow
        const arr_followers = Object.values(rep.followers);
        arr_followers.forEach((rep_follower) => {
          rep_follower.unfollow(rep);
        });

        //remove reference in dict
        delete this.representations[rep.id_rep];
      }

    }

      //original representation
    // function createRepresentation(target, id_rep, arr_backingObj) {
    //     // console.log("createRepresentation", "target", target);
    //     // console.log("createRepresentation", JSON.stringify(target));
    //
    //     // const targetClass = target.constructor;
    //
    //     const broadcaster = {}; //--> push to backingObject(s)
    //     broadcaster.id_rep = id_rep;
    //     broadcaster.arr_backingObj = arr_backingObj;
    //     broadcaster.addBackingObject = function(backingObj) {
    //       broadcaster.arr_backingObj.push(backingObj);
    //       backingObj.addRepresentation(broadcaster.representation);
    //     };
    //
    //     broadcaster.createSisterRepresentation = function(backingObj = null) {
    //       var targetBackingObj = backingObj;
    //       if(targetBackingObj == null) {
    //         const backingObj_first = broadcaster.arr_backingObj.find(e => true);
    //         targetBackingObj = backingObj_first;
    //       }
    //       return targetBackingObj.getNewRepresentation();
    //     };
    //
    //     const receiver  = {}; //<-- receive updates from backingObject(s)
    //     receiver.id_rep = id_rep;
    //
    //
    //     const inner = target.clone();
    //     // console.log("inner", inner);
    //
    //     const representation = new Proxy({}, {
    //         get: function (obj, propName) {
    //           // console.log("representation.get", propName);
    //           var outProp;
    //
    //           if(propName in broadcaster) {
    //             outProp = broadcaster[propName];//.bind(broadcaster);
    //           } else if(propName in receiver) {
    //             outProp = receiver[propName];//.bind(receiver);
    //           }
    //
    //           else if(propName in inner) {
    //             outProp = inner[propName];//.bind(inner);
    //           }
    //
    //           // else {
    //           //   console.log("representation", obj);
    //           //   throw new Error("unknown propName" + "(" + propName + ")" + " for representation: " + obj);
    //           // }
    //
    //           return outProp;
    //         },
    //         set: function (obj, propName, setValue) {
    //           // console.log("representation.set", propName, setValue);
    //
    //           updateInternals(propName,setValue);
    //           broadcaster.arr_backingObj.forEach((backingObj, i) => {
    //             console.log("representation", broadcaster.representation, "has updated");
    //             // console.log("broadcasting to", backingObj);
    //             backingObj.updateWithPropFromRepresentation(propName, setValue, broadcaster.representation);
    //           });
    //
    //           return true;
    //         },
    //     });
    //
    //     function updateInternals(propName, value) {
    //       // console.log("updateInternals", propName, value);
    //
    //       inner[propName] = value;
    //     }
    //
    //
    //
    //
    //
    //
    //     receiver.updateFromOuter = (propName,value) => {
    //       // console.log("updateFromOuter", propName, value);
    //
    //       updateInternals(propName,value);
    //
    //       // receiver.didUpdateProp(prop,value);
    //
    //       //timeout to avoid calling didUpdate for every updated prop
    //       if(receiver.didUpdateTimeout == null) {
    //         const timeout_delayInMs = 17;
    //         receiver.didUpdateTimeout = setTimeout(() => {
    //           // console.log("didUpdateTimeout", "triggering");
    //           receiver.didUpdate();
    //           receiver.didUpdateTimeout = null;
    //         }, timeout_delayInMs);
    //       }
    //     };
    //
    //     // receiver.didUpdatePropListeners = [];
    //     // receiver.didUpdateProp = (prop,value) => {
    //     //   receiver.didUpdatePropListeners.forEach((listener, i) => {
    //     //     listener(prop,value);
    //     //   });
    //     // }
    //
    //     receiver.didUpdateTimeout   = null;
    //     receiver.didUpdateListeners = [];
    //     receiver.didUpdate = () => {
    //       // console.log("receiver", "didUpdate");
    //       receiver.didUpdateListeners.forEach((listener, i) => {
    //         listener(receiver.representation);
    //       });
    //     };
    //
    //     receiver.addOnOuterUpdate = (listener) => {
    //       receiver.didUpdateListeners.push(listener);
    //     };
    //
    //
    //
    //
    //     const glassFacade = new Proxy(inner, {
    //       get: function (obj, propName) {
    //         // console.log("glassFacade.get", propName);
    //         var outProp;
    //
    //         if (propName === 'toJSON') {
		// 		      return function() { return obj; }
    //         }
    //
    //         if(propName in inner)	{	//Be careful! The in operator matches all object keys, including those in the object's prototype chain.
    //           outProp = inner[propName];
    //         } else {
    //           outProp = representation[propName];
    //         }
    //
    //         return outProp;
    //       },
    //       set: function (obj, propName, setValue) {
    //           //console.log("glassFacade.set", propName /*,setValue*/ );
    //           representation[propName] = setValue;
    //           return true;
    //       },
    //     });
    //
    //     broadcaster.representation = glassFacade;
    //     receiver.representation    = glassFacade;
    //
    //
    //     return glassFacade;
    //   }
    //

      class RepresentationFactory {
        static initial(obj) {
            return BackingObject.fromObject(obj).getNewRepresentation();
        }
      }

      class RepresentedFactory {
        static initial(obj) {
            const backingObj = BackingObject.fromObject(obj);
            const rep_official = backingObj.getNewRepresentation();
            const represented = new Represented(backingObj, rep_official);
            rep_official.represented = represented;
            return represented;
        }
      }

      class Represented {

        constructor(backingObj, rep_official) {
          this.backingObj = backingObj;

          this.reps = {};
          this.reps["official"] = rep_official;
        }

        r_official() {
          return this.reps["official"];
        }

        createNewRepresentationWithName(repName) {
          const rep_new = this.backingObj.getNewRepresentation();
          rep_new.represented = this;

          this.reps[repName] = rep_new;

          return rep_new;
        }

        getRepresentation(repName) {
          return this.reps[repName];
        }

        // removeRepresentation(repName) {
        //   if(repName == "official") {
        //     throw new Error("Represented::removeRepresentation, can't remove official rep");
        //   }
        //   const rep = this.reps[repName];
        //   this.backingObj.removeRepresentation(rep);
        //   delete this.reps[repName];
        // }

        removeRepresentation(rep) {
          if(rep == this.r_official()) {
            throw new Error("Represented::removeRepresentation, can't remove official rep");
          }
          this.backingObj.removeRepresentation(rep);

          const repName = this.getRepNameForRep(rep);
          delete this.reps[repName];
        }

        deconstruct() {
          //warning: this is only to be used when destroying represented
          // this.backingObj = null;
          this.reps = {};
        }

        getRepNameForRep(rep_unknown) {
          var outString;

          const entry_found = Object.entries(this.reps).find(([repName, rep]) => rep == rep_unknown);
          if(entry_found != null) {
            outString = entry_found[0];
          } else {
            console.log("rep not found in represented");
            outString = null;
          }

          return outString;
        }



        //convenience
        r_free() {
          return this.reps["free"];
        }

        r_snapped() {
          return this.reps["snapped"];
        }






        officialSerial_p() {
          const rep      = this.r_official();
          const serial_p = rep.toSerial_p();
          return serial_p;
        }





      }

      // class RepresentationNetwork {
      //
      //
      // }
      //
      // class RepresentationNetworkNode {
      //
      //
      // }


        //representation "plus"
      function createRepresentation(target, id_rep, arr_backingObj) {
          // console.log("createRepresentation", "target", target);
          // console.log("createRepresentation", JSON.stringify(target));

          // const targetClass = target.constructor;

          const broadcaster = {}; //--> push to backingObject(s)
          broadcaster.id_rep = id_rep;
          broadcaster.arr_backingObj = arr_backingObj;
          broadcaster.addBackingObject = function(backingObj) {
            broadcaster.arr_backingObj.push(backingObj);
            backingObj.addRepresentation(broadcaster.representation);
          };

          // broadcaster.createSisterRepresentation = function(backingObj = null) {  //~ "gemini rep"
          //   var targetBackingObj = backingObj;
          //   if(targetBackingObj == null) {
          //     const backingObj_first = broadcaster.arr_backingObj.find(e => true);
          //     targetBackingObj = backingObj_first;
          //   }
          //
          //   const rep_elder  = broadcaster.representation;
          //   const rep_sister = targetBackingObj.getNewRepresentation();
          //
          //   rep_sister.follow(rep_elder);
          //   rep_elder.follow(rep_sister);
          //
          //   return rep_sister;
          // };
          //
          // broadcaster.removeSisterRepresentation = (rep) => {
          //   //SHU: TODO
          // };

          broadcaster.followers = {};
          broadcaster.addFollower = function(rep) {
            broadcaster.followers[rep.id_rep] = rep;
          }

          broadcaster.removeFollower = function(rep) {
            delete broadcaster.followers[rep.id_rep];
          }


          broadcaster.didUpdateFromInner = (representation, propName, oldValue, newValue) => {
            broadcaster.didUpdateFromInnerListeners.forEach((listener, i) => {
              listener(representation, propName, oldValue, newValue);
            });
          };

          // var innerUpdates = {};
          broadcaster.didUpdateFromInnerListeners = [];
          broadcaster.onInnerUpdate = (listener) => {
            broadcaster.didUpdateFromInnerListeners.push(listener);
          };
          broadcaster.offInnerUpdate = (listener) => {
            broadcaster.didUpdateFromInnerListeners = Utils.arrayByRemovingElement(broadcaster.didUpdateFromInnerListeners, listener);
          };

          broadcaster.offAllInnerUpdates = () => {
            receiver.didUpdateFromInnerListeners = [];
          };


          const receiver  = {}; //<-- receive updates from backingObject(s)
          receiver.id_rep = id_rep;


          const inner = target.clone();
          // console.log("inner", inner);

          const representation = new Proxy({}, {
              get: function (obj, propName) {
                // console.log("representation.get", propName);
                var outProp;

                if(propName in broadcaster) {
                  outProp = broadcaster[propName];//.bind(broadcaster);
                } else if(propName in receiver) {
                  outProp = receiver[propName];//.bind(receiver);
                }

                else if(propName in inner) {
                  outProp = inner[propName];//.bind(inner);
                }

                // else {
                //   console.log("representation", obj);
                //   throw new Error("unknown propName" + "(" + propName + ")" + " for representation: " + obj);
                // }

                return outProp;
              },
              set: function (obj, propName, setValue) {
                // console.log("representation.set", propName, setValue);

                if(propName in broadcaster) {
                  broadcaster[propName] = setValue;
                } else if(propName in receiver) {
                  receiver[propName] = setValue;
                }

                else {
                  //setting something in inner

                  const oldValue = inner[propName];
                  const newValue = setValue;

                  updateInternals(propName,setValue);
                  broadcaster.arr_backingObj.forEach((backingObj, i) => {
                    // console.log("representation has updated", broadcaster.representation);
                    // console.log("broadcasting to", backingObj);
                    backingObj.updateWithPropFromRepresentation(propName, setValue, broadcaster.representation);
                  });

                  broadcaster.didUpdateFromInner(broadcaster.representation, propName, oldValue, newValue);

                }

                return true;
              },
          });

          function updateInternals(propName, value) {
            // console.log("updateInternals", propName, value);

            inner[propName] = value;
          }

          //follow system

          receiver.followed = {};

          receiver.follow = function(rep) {
            const follower = receiver.representation;
            const followed = rep;

            if(followed == follower) {
              //can't follow self
              //ignore
              return;
            }

            followed.followers[follower.id_rep] = follower;
            follower.followed[followed.id_rep]  = followed;
          }

          receiver.unfollow = function(rep) {
            const follower = receiver.representation;
            const followed = rep;

            if(followed.followers[follower.id_rep] != null) {
              delete followed.followers[follower.id_rep];
            }
            if(follower.followed[followed.id_rep] != null) {
              delete follower.followed[followed.id_rep];
            }
          }

          receiver.followAll = function() {
            const arr_repDicts = arr_backingObj.map((backingObj) => backingObj.representations);
            const arr_allreps  = arr_repDicts.reduce((acc, repDict) => {
              const arr = acc;
              arr.push(...Object.values(repDict));
              return arr;
            }, []);
            arr_allreps.forEach((rep, i) => {
              receiver.follow(rep);
            });
          }

          receiver.unfollowAll = function() {
            const followed = Object.assign({}, receiver.followed);
            Object.values(followed).forEach((rep, i) => {
              receiver.unfollow(rep);
            });
          }

          // receiver.inner = inner;
          receiver.syncWith = function(rep) {
            // Object.entries(rep.inner).forEach(([propName,value], i) => {
            //   updateInternals(propName, value);
            // });
            Object.keys(inner).forEach((propName, i) => {
              const value = rep[propName];
              console.log("+++syncWith", propName, value);
              updateInternals(propName, value);
            });
          }

          receiver.syncWithObj = function(obj) {
            Object.keys(obj).forEach((propName, i) => {
              const value = obj[propName];
              updateInternals(propName, value);
            });
          }


          var outerUpdates = {};
          receiver.updateFromOuter = (propName, value, rep) => {
            // console.log("updateFromOuter", propName, value);

            const isRepFollowed = (receiver.followed[rep.id_rep] == rep);
            if(!isRepFollowed) {
              // console.log("rep not followed", "ignore");
              return;
            }

            // outerUpdates[propName] = value;
            if(outerUpdates[propName] == null) {
              outerUpdates[propName] = {
                old: inner[propName],     //SHU: beware with this

                //debug
                // old: value,
              };
            }
            outerUpdates[propName]["new"] = value;


            updateInternals(propName,value);

            // receiver.didUpdateProp(prop,value);

            function reportOuterUpdates() {
              // console.log("didUpdateTimeout", "triggering");
              receiver.didUpdateFromOuter(outerUpdates);
              receiver.didUpdateFromOuterTimeout = null;
              outerUpdates = {};
            }

            //timeout to avoid calling didUpdate for every updated prop
            if(receiver.didUpdateFromOuterTimeout == null) {

              // const timeout_delayInMs = 17;
              const timeout_delayInMs = 0;
              // const timeout_delayInMs = 500;

              receiver.didUpdateFromOuterTimeout = setTimeout(() => {
                reportOuterUpdates();
              }, timeout_delayInMs);

            }

            // requestAnimationFrame(reportOuterUpdates);

          };


          // receiver.remoteInnerUpdate = (propName, value, rep) => {
          //
          // };


          // receiver.didUpdatePropListeners = [];
          // receiver.didUpdateProp = (prop,value) => {
          //   receiver.didUpdatePropListeners.forEach((listener, i) => {
          //     listener(prop,value);
          //   });
          // }

          receiver.didUpdateFromOuterTimeout   = null;
          receiver.didUpdateFromOuterListeners = [];
          receiver.didUpdateFromOuter = (updateDict) => {
            // console.log("receiver", "didUpdate");
            receiver.didUpdateFromOuterListeners.forEach((listener, i) => {
              listener(receiver.representation, updateDict);
            });
          };

          receiver.onOuterUpdate = (listener) => {
            receiver.didUpdateFromOuterListeners.push(listener);
          };

          receiver.offOuterUpdate = (listener) => {
            receiver.didUpdateFromOuterListeners = Utils.arrayByRemovingElement(receiver.didUpdateFromOuterListeners, listener);
          };

          receiver.offAllOuterUpdates = () => {
            receiver.didUpdateFromOuterListeners = [];
          };

          receiver.represented = null;


          receiver.toSerial_p = () => {
            // console.log("inner", inner);
            return inner.toSerial_p();
          }


          const glassFacade = new Proxy(inner, {
            get: function (obj, propName) {
              // console.log("glassFacade.get", propName);
              var outProp;

              if (propName === 'toJSON') {
  				      return function() { return obj; }
              }

              if(propName in inner)	{	//Be careful! The in operator matches all object keys, including those in the object's prototype chain.
                outProp = inner[propName];
              } else {
                outProp = representation[propName];
              }

              return outProp;
            },
            set: function (obj, propName, setValue) {
                //console.log("glassFacade.set", propName /*,setValue*/ );
                representation[propName] = setValue;
                return true;
            },
          });

          broadcaster.representation = glassFacade;
          receiver.representation    = glassFacade;


          return glassFacade;
        }



      /*//////
      *********/

      class Enginiter {

        static installEngine(engineCarrier, engine) {

          //install func for engine to work properly
          engineCarrier.getScopeObj = function(engineCarrier) {
            const scopeObj = {
              engineCarrier: engineCarrier,
            };
            return scopeObj;
          };

          //install engine
          engineCarrier.engine = engine;
        }

      }

      class Engine {
        constructor() {

          this.initialized = false;

          this.initialize = function(scopeObj) {
            this.initialized = true;
            this.scopeObj = scopeObj;
          }

          this.start = function() {   //SHU: attention, il y a peut-être une drôlerie de closure ici
            console.log("this.scopeObj.engineCarrier", this.scopeObj.engineCarrier);
            const engineCarrier = this.scopeObj.engineCarrier;
            //do something with engineCarrier
          };

          this.stop = function() {
            // delete this.scopeObj;
          };

        }

        static debugInstance() {
          const engine = new Engine();

          engine.start = function() {   //SHU: attention, il y a peut-être une drôlerie de closure ici
            console.log("engine.start()");

            console.log("this.scopeObj.engineCarrier", this.scopeObj.engineCarrier);

            const engineCarrier = this.scopeObj.engineCarrier;

            engineCarrier.text += "[]";

            const interval__growth = setInterval(() => {
              // engineCarrier.text += "[]";              //linear      growth
              engineCarrier.text += engineCarrier.text;   //exponential growth

              if(engineCarrier.text.length > 10000) {
                engineCarrier.engine.stop();
              }

            }, 1000);


            if(this.scopeObj.running == null) {
              this.scopeObj.running = {};
            }
            this.scopeObj.running["interval"] = {
              interval__growth: interval__growth,
            };

          };

          engine.stop = function() {
            if(this.scopeObj.running != null) {
              if(this.scopeObj.running["interval"] != null) {
                const arr_interval = Object.values(this.scopeObj.running["interval"]);

                arr_interval.forEach((interval, i) => {
                  clearInterval(interval);
                });

              }
            }
          };

          return engine;
        }

      }


      class Toucher {

        constructor() {
          this.transformationFunc = null;
        }

        static debugInstance() {
          const toucher = new Toucher();

          const transformationFunc = (icObject_in) => {
            var outMutationObject = {};

            function randomColor() {
                var r = 255*Math.random()|0,
                    g = 255*Math.random()|0,
                    b = 255*Math.random()|0;
                return 'rgb(' + r + ',' + g + ',' + b + ')';
            }

            const color = randomColor();
            outMutationObject.fill = color;

            return outMutationObject;
          };

          toucher.transformationFunc = transformationFunc;

          return toucher;
        }

      }


      class TouchSlotEngine {
        // constructor(touchSlotConfig) {
        constructor() {

          this.initialized = false;

          this.initialize = function(scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
                  .filter(([propName, prop]) => isFunction(prop))
                  .forEach(([propName, prop], i) => {
                    this.awoken[propName] = prop.bind(this.awoken);
                  });

            // this.scopeObj  = scopeObj;
              //engineCarrier,
              //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptTouching = function(icObj_slot, icObj_piece) {
            logger.log("attemptTouching", icObj_slot, icObj_piece);

            const canTouch = this.checkCanTouch(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            console.log("attempting to touch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if(canTouch) {
              console.log("can touch");

              const rep_official = icObj_piece;
              const represented  = icObj_piece.represented;
              const rep_free     = represented.getRepresentation("free");

              // console.log("rep_free.isHeld", rep_free.isHeld);
              // if(rep_free.isHeld) {
              //   presnap(icObj_slot, icObj_piece);
              // } else {
              //   presnap(icObj_slot, icObj_piece);
              //   snap(icObj_slot, icObj_piece);
              // }

              this.touch(icObj_slot, icObj_piece);

            } else {
              console.log("can't touch");
            }

          };

          this.checkCanTouch = function(icObj_slot, icObj_piece) {
            logger.log("checkCanTouch", icObj_piece);
            var outBool;

            // outBool = Touch.canTouch(icObj_piece, icObj_slot);

            var canTouchFunc = this.scopeObj.engineCarrier.touchSlotConfig.canTouchFunc;
            if(canTouchFunc == null) {
              canTouchFunc = Touch.canTouch;
            }

            const context = this.scopeObj.engineCarrier.touchSlotConfig.context;

            outBool = canTouchFunc(icObj_piece, icObj_slot, context);

            return outBool;
          };


          this.touch = function(icObj_slot, icObj_piece) {
            console.log("touch", icObj_piece);

            const icTouchSlot = this.scopeObj.engineCarrier;


            const rep_official = icObj_piece;
            // const represented  = icObj_piece.represented;
            // const rep_free     = represented.getRepresentation("free");
            // const rep_touched  = represented.getRepresentation("snapped");

            rep_official.touchStateDict[icObj_slot.id] = TouchState.Touched;

            const represented  = icObj_piece.represented;
            const rep_free     = represented.getRepresentation("free");

            //apply mutation
            console.log("touch: apply mutation");
            // console.log("rep_official.text", rep_official.text);

            // if(rep_official.text != null) {
            //
            //   /*
            //   const number_in   = parseInt(rep_official.text,10);
            //   const number_out  = number_in + 1;
            //
            //   rep_free.text     = "" + number_out;
            //   */
            //
            //   const number_in   = parseInt(rep_official.text,10);
            //   const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            //   const number_out  = transformationFunc(number_in);
            //
            //   rep_free.text     = "" + number_out;
            // }
            // else

            // if(rep_official.mathNode != null) {
            //
            //   // const tex_in    = rep_official.tex;
            //   // const expr_in   = algebra.fromTex(tex_in);
            //   const mathNode_in = rep_official.mathNode;
            //
            //   const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            //   const mathNode_out  = transformationFunc(mathNode_in);
            //
            //   rep_free.mathNode = mathNode_out;
            //
            //   // const tex_out = expr_out.toTex();
            //   // rep_free.tex  = tex_out;
            // }
            // else

            {
              console.log("&&&touch");
              console.log("icTouchSlot", icTouchSlot);

              const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;

              var icObj__touched = rep_free;

              ////temporary
              //// {
              ////   if(icObj__touched.type == "composite" && icObj__touched.parts.contactArea != null) {
              ////     icObj__touched = icObj__touched.parts.facade;
              ////   }
              //// }

              logger.log("icObj__touched", icObj__touched);


              const transformationOutput = transformationFunc(icObj__touched);
              if(transformationOutput.type == "new") {
                //new version

                const icTouchSlot = this.scopeObj.infiniteCanvas;

                const rep_free__supervessel = infiniteCanvas.getSupervessel();

                rep_free__supervessel.engine.awoken.removePart(icObj__touched);

                //remove old
                {
                  // infiniteCanvas.removeIcObject(icObj__touched);
                  icObj__touched.im_dying_now = true;
                }

                //add new

                function addNew(icObj__new) {
                  icObj__new.isTouchable = true;
                  icObj__new.touchStateDict[icObj_slot.id] = TouchState.Touched;
                  if(icObj__new.type == "composite") {
                    icObj__new.parts.forEach((part, i) => {
                      part.touchStateDict[icObj_slot.id] = TouchState.Touched;
                    });
                  }

                  infiniteCanvas.addIcObject(icObj__new);

                  const rep_free__new = infiniteCanvas.getRepresented(icObj__new.id).r_free();
                  rep_free__supervessel.engine.awoken.addPart(rep_free__new);

                }

                if(transformationOutput.value instanceof IcObject) {

                  const icObj__new = transformationOutput.value;
                  logger.log("icObj__new", icObj__new);

                  addNew(icObj__new);

                } else if(transformationOutput.value instanceof Array) {

                  transformationOutput.value.forEach((icObj__new, i) => {
                    addNew(icObj__new);
                  });

                } else {
                  throw new Error("unsupported transformationOutput.value: " + transformationOutput.value);
                }



              } else if(transformationOutput.type == "mutated") {
                logger.log("transformationOutput:", transformationOutput);
                //old version
                // const mutationObj = transformationFunc(icObj__touched);
                const mutationObj = transformationOutput;

                switch(transformationOutput.type) {
                  case "mathNode":
                    icObj__touched.mathNode = mutationObj.mathNode;
                    break;
                  default:
                    // throw new Error("unsupported transformationOutput.type: " + transformationOutput.type);      //SHU: careful
                    Object.assign(icObj__touched, mutationObj);
                    break;
                }

              } else {

              }


            }



          };





          this.attemptUntouching = function(icObj_slot, icObj_piece) {
            console.log("attemptUntouching", icObj_slot, icObj_piece);

            const canUntouch = this.checkCanUntouch(icObj_slot, icObj_piece);
            console.log("canUntouch", canUntouch);

            const rep_official = icObj_piece;
            console.log("attempting to untouch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

            if(canUntouch) {
              // console.log("can untouch");
              this.untouch(icObj_slot, icObj_piece);

            } else {
              // console.log("can't untouch");
            }

          };

          this.checkCanUntouch = function(icObj_slot, icObj_piece) {
            console.log("checkCanUntouch", icObj_piece);
            var outBool;

            outBool = Touch.canUntouch(icObj_piece, icObj_slot);

            return outBool;
          };

          this.untouch = function(icObj_slot, icObj_piece) {
            console.log("untouch", icObj_piece);

            const rep_free     = icObj_piece;   //SHU: this is probably false

            const represented  = icObj_piece.represented;
            const rep_official = represented.getRepresentation("official");

            rep_official.touchStateDict[icObj_slot.id] = TouchState.Untouched;
          };



          // this.r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
          this.r_official_update_handler = function(icObj_slot, icObj_piece, outerUpdatesDict) {

            logger.log("r_official_update_handler", icObj_piece);

            const touchState = icObj_piece.touchStateDict[icObj_slot.id];
            console.log("touchState", touchState);

            if(touchState == TouchState.Untouched) {
              this.attemptTouching(icObj_slot, icObj_piece);
            } else if(touchState == TouchState.Touched) {
              this.attemptUntouching(icObj_slot, icObj_piece);
            }

          };

          // this.r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
          this.r_official_update_handler2 = function(rep_official_incoming, outerUpdatesDict) {   //SHU: when using func.bind(myObj), be sure not to use arrow functions

            logger.log("r_official_update_handler2", rep_official_incoming);

            // console.log("engine::r_official_update_handler2, this", this);
            // console.log("this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            // console.log("infiniteCanvas", infiniteCanvas);
            const icTouchSlot    = this.scopeObj.engineCarrier;

            const represented  = infiniteCanvas.getRepresented(icTouchSlot.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const touchSlot   = rep_official;
            const incomingObj = rep_official_incoming;

            if(incomingObj != touchSlot) { //don't touch oneself

              if(!incomingObj.isTouchable) {
                //ignore: incomingObj is intangible
              } else {
                this.r_official_update_handler(touchSlot, incomingObj, outerUpdatesDict);
              }

            } else {
              console.log("I won't touch myself");  //SHU: ...
            }

          };


          this.start = function() {
            console.log("engine::start, this", this);
            // logger.log("touchSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icTouchSlot    = this.scopeObj.engineCarrier;


            infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);

            //for each existing canvas object, add touchState wrt this new touchSlot
            infiniteCanvas.onceOnAddRepresentedForIcObject(icTouchSlot, (icTouchSlot) => {

              const id_touchSlot = icTouchSlot.id;

              const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
              const arr_official_preexisiting = arr_official.filter(rep => (rep.id != id_touchSlot));
              arr_official_preexisiting.forEach((rep, i) => {

                rep.touchStateDict[id_touchSlot] = TouchState.Untouched;
                //SHU TODO: check if touches

              });

            });

          };

          this.stop = function() {
            // delete this.scopeObj;
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }

      class SnapSlotEngine {
        // constructor(touchSlotConfig) {
        constructor() {

          this.initialized = false;

          this.initialize = function(scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
                  .filter(([propName, prop]) => isFunction(prop))
                  .forEach(([propName, prop], i) => {
                    this.awoken[propName] = prop.bind(this.awoken);
                  });

            // this.scopeObj  = scopeObj;
              //engineCarrier,
              //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.attemptSnapping = function(icObj_slot, icObj_piece) {
            console.log("attemptSnapping", icObj_slot, icObj_piece);

            const canSnap = this.checkCanSnap(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            console.log("attempting to snap with snapState: " + rep_official.snapState);

            // const isValidPieceSnapState = (rep_official.snapState == SnapState.Unsnapped);
            //
            // if(isValidPieceSnapState) {
            //
            // } else {
            //   console.log("can't snap while snapState == " + rep_official.snapState)
            //   // throw new Error("attempting to snap with snapState: " + rep_official.snapState);
            //   return;
            // }

            if(canSnap) {
              console.log("can snap");

              const rep_official = icObj_piece;
              const represented  = icObj_piece.represented;
              const rep_free     = represented.getRepresentation("free");

              console.log("rep_free.isHeld", rep_free.isHeld);
              if(rep_free.isHeld) {
                this.presnap(icObj_slot, icObj_piece);
              } else {
                this.presnap(icObj_slot, icObj_piece);
                this.snap(icObj_slot, icObj_piece);
              }

            } else {
              console.log("can't snap");
            }

          };


          this.checkCanSnap = function(icObj_slot, icObj_piece) {
            console.log("checkCanSnap", icObj_piece);
            var outBool;

            const icSnapSlot     = this.scopeObj.engineCarrier;
            const canSnapFunc    = icSnapSlot.snapSlotConfig.canSnapFunc;

            outBool = canSnapFunc(icObj_piece, icObj_slot);

            return outBool;
          };

          var rep_free_onRelease__triggerSnap          = null;
          var rep_free_afterPresnap__attemptUnsnapping = null;

          var rep_free_callbacks = {
            onRelease__triggerSnap:          null,
            afterPresnap__attemptUnsnapping: null,
          };


          this.presnap = function(icObj_slot, icObj_piece) {
            console.log("presnap", icObj_piece);

            const rep_official = icObj_piece;
            const represented  = icObj_piece.represented;
            const rep_free     = represented.getRepresentation("free");
            const rep_snapped  = represented.createNewRepresentationWithName("snapped");

            rep_official.snapState = SnapState.Presnapped;
            // rep_official.snappedTo = icObj_slot;
            rep_official.snappedTo = icObj_slot.id;


            rep_official.unfollow(rep_free);


            rep_snapped.position     = Object.assign({}, icObj_slot.position);
            rep_snapped.homeScale    = Object.assign({}, icObj_slot.homeScale);
            rep_snapped.scale        = Object.assign({}, icObj_slot.scale);
            rep_snapped.orientation  = icObj_slot.orientation;

            rep_snapped.opacity = 0.8;


            //debug
            // rep_snapped.text = "rep_snapped__snapped";

            infiniteCanvas.addRepresentation(represented, rep_snapped);


            // rep_official.syncWith(rep_snapped);
            rep_official.syncWithObj({
              position:   rep_snapped.position,
              size:       rep_snapped.size,
              homeScale:  rep_snapped.homeScale,
              scale:      rep_snapped.scale,

              // didUpdateListeners : rep_snapped.didUpdateListeners,
              // holdListeners      : rep_snapped.holdListeners,
              // releaseListeners   : rep_snapped.releaseListeners,
            });
            rep_official.follow(rep_snapped);


            rep_free.opacity = 0.2;
              //debug
            // rep_free.opacity = 1.0;
            // rep_free.fill = "blue";
            // rep_free.text = "rep_free__presnapped";


            //add release listener
            // icObj_fRep.onHold((icObj) => {
            //
            // });

            //add release listener for rep_free
            rep_free_onRelease__triggerSnap = (rep_free) => {
              console.log("rep_free_onRelease__triggerSnap");

              this.snap(icObj_slot, icObj_piece);
            };
            rep_free.onRelease(rep_free_onRelease__triggerSnap);


            //add unsnap listener for rep_free
            rep_free_afterPresnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
              console.log("rep_free_afterPresnap__attemptUnsnapping", rep_free);

              this.attemptUnsnapping(icObj_slot, rep_free);
            };
            rep_free.onInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);

          };


          this.snap = function(icObj_slot, icObj_piece) {
            console.log("snap", icObj_piece);

            const rep_official = icObj_piece;
            const represented  = icObj_piece.represented;
            const rep_free     = represented.getRepresentation("free");
            const rep_snapped  = represented.getRepresentation("snapped");

            console.log("**snap", "rep_free.isHeld", rep_free.isHeld);

            console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
            if(rep_free_afterPresnap__attemptUnsnapping != null) {
              rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
            }
            rep_free_afterPresnap__attemptUnsnapping = null;


            rep_free.offRelease(rep_free_onRelease__triggerSnap);
            rep_free_onRelease__triggerSnap = null;



            // rep_free.syncWith(rep_snapped);
            // rep_free.syncWith(rep_official);

            //SHU TODO: MYSTERE ET BOULE DE GOMME: il y a un truc avec syncWith qui casse rep_free ... ???

            rep_free.syncWithObj({
              position:   rep_snapped.position,
              size:       rep_snapped.size,
              homeScale:  rep_snapped.homeScale,
              scale:      rep_snapped.scale,

              // didUpdateListeners : rep_snapped.didUpdateListeners,
              // holdListeners      : rep_snapped.holdListeners,
              // releaseListeners   : rep_snapped.releaseListeners,
            });



            rep_free.opacity = 1.0;
              //debug
            // rep_free.opacity = 1.0;
            // rep_free.fill = "red";
            // rep_free.text = "rep_free__snapped";

            rep_official.unfollow(rep_snapped);
            rep_official.follow(rep_free);
            rep_official.snapState = SnapState.Snapped;
            // rep_official.snappedTo = icObj_slot;
            // rep_official.snappedTo = icObj_slot.id;



            console.log("remove rep_snapped", rep_snapped.id_rep);
            rep_snapped.im_dying_now = true;
            infiniteCanvas.removeRepresentation(represented, rep_snapped);
            represented.removeRepresentation(rep_snapped);

            //add unsnap listener for rep_free
            // rep_free_afterSnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
            //   console.log("rep_free_afterSnap__attemptUnsnapping", rep_free);
            //
            //   attemptUnsnapping(icObj_slot, rep_free);
            // };
            // rep_free.onInnerUpdate(rep_free_afterSnap__attemptUnsnapping);


              //debug
            // rep_free.onHold((rep_free) => {
            //   console.log("###rep_free.id_rep", rep_free.id_rep);
            //   console.log("###rep_free.onHold", "rep_free.isHeld", rep_free.isHeld);
            // });

          };





          this.attemptUnsnapping = function(icObj_slot, icObj_piece) {
            console.log("attemptUnsnapping", icObj_slot, icObj_piece);

            const canUnsnap = this.checkCanUnsnap(icObj_slot, icObj_piece);
            console.log("canUnsnap", canUnsnap);

            const rep_official = icObj_piece;
            console.log("attempting to unsnap with snapState: " + rep_official.snapState);

            // const isValidPieceSnapState = (rep_official.snapState == SnapState.Presnapped);
            //
            // if(isValidPieceSnapState) {
            //
            // } else {
            //   console.log("can't unsnap while snapState == " + rep_official.snapState)
            //   // throw new Error("attempting to unsnap with snapState: " + rep_official.snapState);
            //   return;
            // }

            if(canUnsnap) {
              // console.log("can unsnap");
              this.unsnap(icObj_slot, icObj_piece);     //presnap already sets up an unsnap listener

            } else {
              // console.log("can't unsnap");

              //SHU TODO: hasLeftSlot
              // const hasLeftSlot = Snap.hasLeftSlot()
              const hasLeftSlot = true;

              if(hasLeftSlot) {


                // const rep_official = icObj_piece;
                const represented  = icObj_piece.represented;
                const rep_free     = represented.getRepresentation("free");

                console.log("#rep_free.id_rep", rep_free.id_rep);
                console.log("#rep_free.isHeld", rep_free.isHeld);

                if(rep_free.isHeld) {
                  if(icObj_piece.snapState == SnapState.Snapped) {
                    this.presnap(icObj_slot, icObj_piece);
                  }
                } else {
                  //do nothing
                  // snap(icObj_slot, icObj_piece);
                }

              } else {
                //do nothing
                // snap(icObj_slot, icObj_piece);
              }



            }

          };

          this.checkCanUnsnap = function(icObj_slot, icObj_piece) {
            console.log("checkCanUnsnap", icObj_piece);
            var outBool;

            const icSnapSlot     = this.scopeObj.engineCarrier;
            const canUnsnapFunc  = icSnapSlot.snapSlotConfig.canUnsnapFunc;

            outBool = canUnsnapFunc(icObj_piece, icObj_slot);

            return outBool;
          };


          this.unsnap = function(icObj_slot, icObj_piece) {
            console.log("unsnap", icObj_piece);

            // const represented  = icObj_piece.represented;
            // const rep_official = represented.getRepresentation("official");
            // const rep_snapped  = represented.getRepresentation("snapped");

            const rep_unknown  = icObj_piece; //SHU TODO: solve snapSlot's rep madness
            const represented  = icObj_piece.represented;
            const rep_official = represented.getRepresentation("official");
            const rep_free     = represented.getRepresentation("free");
            const rep_snapped  = represented.getRepresentation("snapped");


            console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
            if(rep_free_afterPresnap__attemptUnsnapping != null) {
              rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
            }
            rep_free_afterPresnap__attemptUnsnapping = null;

            // if(rep_free_afterSnap__attemptUnsnapping != null) {
            //   rep_free.offInnerUpdate(rep_free_afterSnap__attemptUnsnapping);
            // }
            // rep_free_afterSnap__attemptUnsnapping = null;


            // rep_free.offRelease(rep_free_onRelease__triggerSnap);
            // rep_free_onRelease__triggerSnap = null;

            if(rep_free.offRelease != null) { //****************************************  SHU: il y a un problème ici, quand j'aurai trois neurones de disponibles, j'investiguerai
              rep_free.offRelease(rep_free_onRelease__triggerSnap);
              rep_free_onRelease__triggerSnap = null;
            }                                 //****************************************


            rep_official.syncWith(rep_free);
            rep_official.follow(rep_free);


            if(rep_snapped != null) {
              console.log("remove rep_snapped", rep_snapped.id_rep);
              rep_snapped.im_dying_now = true;
              infiniteCanvas.removeRepresentation(represented, rep_snapped);
              represented.removeRepresentation(rep_snapped);
            } else {
              console.log("rep_snapped already destroyed somewhere else");
            }


            // rep_free.im_dying_now = true; //SHU: this is interesting

            /*
            rep_free.opacity = 1.0;
              //debug
              // rep_free.fill = "lime";
              // rep_free.text = "rep_free__unsnapped";
              // setTimeout(() => {
              //   rep_free.fill = "lime";
              //   rep_free.text = "rep_free__unsnapped";
              // }, 0);
            */

            setTimeout(() => {                  //SHU: looks like setTimeout is needed here
              rep_free.opacity = 1.0;

              rep_official.snapState = SnapState.Unsnapped;
              // rep_official.snappedTo = null;
              rep_official.snappedTo = -1;
            }, 0);

          };






          this.r_official_update_handler = function(icObj_slot, icObj_piece, outerUpdatesDict) {
            console.log("r_official_update_handler", icObj_piece);

            console.log("icObj_piece.snapState", icObj_piece.snapState);

            // if(outerUpdatesDict["snapState"] == SnapState.Snapped) {
            //   //official just changed snapState to .Snapped
            //   //ignore
            //   return;
            // }

            if(icObj_piece.snapState == SnapState.Unsnapped) {
              this.attemptSnapping(icObj_slot, icObj_piece);
            } else if(icObj_piece.snapState == SnapState.Snapped) {
              this.attemptUnsnapping(icObj_slot, icObj_piece);               //SHU666666 : this is the key line to understand what is wrong
            } else if(icObj_piece.snapState == SnapState.Presnapped) {

            }

          };

          this.r_official_update_handler2 = function(rep_official_incoming, outerUpdatesDict) {
            console.log("r_official_update_handler2", rep_official_incoming);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icSnapSlot     = this.scopeObj.engineCarrier;

            const represented  = infiniteCanvas.getRepresented(icSnapSlot.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const snapSlot    = rep_official;
            const incomingObj = rep_official_incoming;

            if(incomingObj != snapSlot) { //don't snap oneself

              if(!incomingObj.isSnappable) {
                //ignore: incomingObj is diamagnetic
              } else {
                console.log("++++incomingObj.snappedTo", incomingObj.snappedTo);
                // if(incomingObj.snappedTo != null && incomingObj.snappedTo != snapSlot) {
                if(incomingObj.snappedTo != -1 && incomingObj.snappedTo != snapSlot.id) {
                  //ignore: incomingObj is already snapped to another slot
                } else {
                  this.r_official_update_handler(snapSlot, incomingObj, outerUpdatesDict);
                }
              }

            } else {
              console.log("I won't snap myself");
            }

          };




          this.start = function() {
            console.log("engine::start, this", this);
            console.log("snapSlotEngine::start", "this.scopeObj", this.scopeObj);
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const icSnapSlot     = this.scopeObj.engineCarrier;

            infiniteCanvas.onIcObjUpdate(this.r_official_update_handler2);
          };

          this.stop = function() {
            //SHU TODO: infiniteCanvas.offIcObjUpdate when snap slot is destroyed
          };



          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }


      class CompositeEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function(scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
                  .filter(([propName, prop]) => isFunction(prop))
                  .forEach(([propName, prop], i) => {
                    this.awoken[propName] = prop.bind(this.awoken);
                  });

            // this.scopeObj  = scopeObj;
              //engineCarrier,
              //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          };


          this.createHandleListener = function() {
            const handle__listener = (representation, propName, oldValue, newValue) => {
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.manageHandleUpdate(representation, updatesDict);
            };

            return handle__listener;
          };

          this.createPartListener = function() {
            const part__listener = (representation, propName, oldValue, newValue) => {
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              this.managePartUpdate(representation, updatesDict);
            };

            return part__listener;
          };



          this.createListeners = function() {
            var outListenersDict = {};

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;


            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();



            const handle__listener = this.createHandleListener();

            // outListenersDict["handle"] = handle__listener;
            outListenersDict[handle.id] = handle__listener;

            const parts          = handle__rep_free.parts;
            const part_listeners = Object.entries(parts).reduce((acc, [partName, part__rep_free]) => {

              const part__listener = this.createPartListener();

              // acc[partName] = part__listener;
              acc[part__rep_free.id] = part__listener;

              return acc;
            }, {});

            Object.assign(outListenersDict, part_listeners);

            return outListenersDict;
          };




          this.getArr_everyone = function() {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;


            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            const parts               = handle__rep_free.parts;

            return [handle__rep_free] + Object.values(parts);
          };

          this.getArr_everyoneBut = function(rep) {
            const arr_everyoneElse = this.getArr_everyone().filter(rep => rep.id != solo_rep.id);
            return arr_everyoneElse;
          };

          this.onEveryoneBut = function(solo_rep) {
            const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = this.listeners[rep.id];
              rep.onInnerUpdate(listener);
            });
          };

          this.offEveryoneBut = function(rep) {
            const arr_everyoneElse = this.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = this.listeners[rep.id];
              rep.offInnerUpdate(listener);
            });
          };

          //part update
          this.managePartUpdate = function(icObj_compositePart, outerUpdatesDict) {
            logger.log("managePartUpdate", icObj_compositePart);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            const compositeConfig   = handle.compositeConfig;
            console.log("compositeConfig", compositeConfig);
            const id__compositePart = icObj_compositePart.id;
            console.log("id__compositePart", id__compositePart);

            const isMobile          = compositeConfig[id__compositePart].isMobile;

            if(isMobile) {
              //ignore
            } else {

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free    = handle__represented.r_free();

              // const part__represented   = infiniteCanvas.getRepresented(icObj_compositePart.id);

              // rep_free__composite.composite.managePartUpdate(rep_free__compositePart, outerUpdatesDict);
              if(outerUpdatesDict.position != null) {

                const offset = {
                  dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                  dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
                };

                const parts           = handle__rep_free.parts;

                const arr_parts_all   = Object.values(parts);
                const arr_parts_other = arr_parts_all.filter(part => part.id != icObj_compositePart.id);

                const arr_handle_and_other = [handle__rep_free, ...arr_parts_other];

                // arr_parts_other.forEach((rep_free, i) => {
                arr_handle_and_other.forEach((rep_free, i) => {

                  const listener = this.listeners[rep_free.id];
                  // console.log("°°°listener", listener);

                  //listen:off
                  rep_free.offInnerUpdate(listener);

                  //mutate
                  // logger.log("mutating part:", rep_free.id);
                  {
                    const position_new = {
                      x: rep_free.position.x + offset.dx,
                      y: rep_free.position.y + offset.dy,
                    };

                    rep_free.position = position_new;
                  }

                  //listen:on
                  rep_free.onInnerUpdate(listener);

                });


              //   {
              //     const rep_free = handle__rep_free;
              //
              //     //listen:off
              //     rep_free.offInnerUpdate(listener);
              //
              //     //mutate
              //     {
              //       const position_new = {
              //         x: rep_free.position.x + offset.dx,
              //         y: rep_free.position.y + offset.dy,
              //       };
              //
              //       rep_free.position = position_new;
              //     }
              //
              //     //listen:on
              //     rep_free.onInnerUpdate(listener);
              //   }


              }

            }

          };

          //handle update
          this.manageHandleUpdate = function(icObj_composite, outerUpdatesDict) {
            console.log("manageHandleUpdate", icObj_composite);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(icObj_composite.id);
            const handle__rep_free    = handle__represented.r_free();

            if(outerUpdatesDict.position != null) {

              const offset = {
                dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
              };

              const parts           = handle__rep_free.parts;
              const arr_parts_all   = Object.values(parts);
              arr_parts_all.forEach((part__rep_free, i) => {

                const listener = this.listeners[part__rep_free.id];

                //listen:off
                part__rep_free.offInnerUpdate(listener);


                //mutate
                // logger.log("mutating part:", part__rep_free.id);
                {
                  const position_new = {
                    x: part__rep_free.position.x + offset.dx,
                    y: part__rep_free.position.y + offset.dy,
                  };

                  part__rep_free.position = position_new;
                }

                //listen:on
                part__rep_free.onInnerUpdate(listener);

              });

            }
            // else if(outerUpdatesDict.parts != null) {
            //   logger.log("outerUpdatesDict.parts", outerUpdatesDict.parts);
            //
            //   // const arr_parts__old = [];
            //   // const arr_parts__new = [];
            //
            //   Object.values(outerUpdatesDict.parts.new).forEach((part__rep_free, i) => {
            //     const part__listener = this.createPartListener();
            //     this.listeners[part__rep_free.id] = part__listener;
            //
            //     if(handle__rep_free.compositeConfig[part__rep_free.id] == null) {
            //       const config__part = {
            //         // isMobile: true,
            //         isMobile: false,
            //       };
            //       handle__rep_free.compositeConfig[part__rep_free.id] = config__part;
            //     }
            //
            //     //'activate' listener
            //     // const part__listener = this.listeners[part__rep_free.id];
            //     part__rep_free.onInnerUpdate(part__listener);
            //
            //   });
            //
            // }

          };


          this.addPart = function(part__rep_free, isMobile = true) {
          // this.addPart = function(part, config__part) {
            // logger.log("addPart", this, part__rep_free);

            //get free_rep
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

              //add part to .parts
            const miniDict = {
              [part__rep_free.id]: part__rep_free,
            };

            handle__rep_free.parts = Object.assign({}, handle__rep_free.parts, miniDict);
            // // // Object.assign(handle__rep_free.parts, miniDict);
            // // //handle__rep_free.parts[part.id] = part;

              //add partConfig
            const config__part = {
              // isMobile: true,
              isMobile: isMobile,
            };
            handle__rep_free.compositeConfig[part__rep_free.id] = config__part;

              //setup listener
                  //create
            const part__listener = this.createPartListener();
                  //store
            this.listeners[part__rep_free.id] = part__listener;
                  //activate
            part__rep_free.onInnerUpdate(part__listener);

          };

          this.removePart = function(part__rep_free) {
            // logger.log("removePart", this, part__rep_free);

            //get free_rep
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

              //deactivate listener
                  //retrieve
            const part__listener = this.listeners[part__rep_free.id];
                  //deactivate
            part__rep_free.offInnerUpdate(part__listener);

              //remove part from .parts
            const parts__updated = Object.assign({}, handle__rep_free.parts);
            delete parts__updated[part__rep_free.id];
            handle__rep_free.parts = parts__updated;

              //remove partConfig
            delete handle__rep_free.compositeConfig[part__rep_free.id];

          };




          this.start = function() {
            console.log("engine::start, this", this);
            console.log("compositeEngine::start", "this.scopeObj", this.scopeObj);

            this.listeners = this.createListeners();

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            console.log("compositeEngine.start", handle.id);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();


            //listen to handle
            const handle__listener = this.listeners[handle.id];
            handle__rep_free.onInnerUpdate(handle__listener);

            //listen to parts
            const parts           = handle__rep_free.parts;
            const arr_parts_all   = Object.values(parts);
            arr_parts_all.forEach((part__rep_free, i) => {

              //'activate' listeners
              const part__listener = this.listeners[part__rep_free.id];
              part__rep_free.onInnerUpdate(part__listener);
            });


            //debug (~tests)
            // setTimeout(() => {
            //   console.log("ççç setTimeout handle__rep_free.id_rep", handle__rep_free.id_rep);
            //
            //   handle__rep_free.position = {
            //     x: handle__rep_free.position.x + 200,
            //     y: handle__rep_free.position.y - 50,
            //   };
            // }, 3000);
            //
            // setTimeout(() => {
            //   const part1 = arr_parts_all[0];
            //   part1.position = {
            //     x: part1.position.x - 200,
            //     y: part1.position.y - 100,
            //   };
            // }, 6000);
            //
            // setTimeout(() => {
            //   const part3 = arr_parts_all[2];
            //   part3.position = {
            //     x: part3.position.x + 150,
            //     y: part3.position.y + 100,
            //   };
            // }, 9000);
          };

          this.stop = function() {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const handle         = this.scopeObj.engineCarrier;

            console.log("compositeEngine.stop", handle);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            const handle__listener = this.listeners[handle.id];
            handle__rep_free.offInnerUpdate(handle__listener);

            const parts           = handle__rep_free.parts;
            const arr_parts_all   = Object.values(parts);
            arr_parts_all.forEach((part__rep_free, i) => {

              const part__listener = this.listeners[part__rep_free.id];
              part__rep_free.offInnerUpdate(part__listener);
            });

          };



          this.virgin = Object.assign({}, this);  //virgin == not bound


        }

      }


      class Compositer {

        // static createPart(icObj, isMobile = true) {
        //   var outPart;
        //
        //   outPart = new CompositePart(icObj, isMobile);
        //
        //   return outPart;
        // }

        static defaultCompositeConfig(parts, isMobile = true) {
          var outConfig;

          outConfig = Object.entries(parts).reduce((acc, [partName, part], index) => {
            // const isMobile = true;

            // acc[partName] = {
            acc[part.id] = {
              isMobile: isMobile,
            };

            return acc;
          }, {});

          return outConfig;
        }

      }


      // class CompositePart {
      //   constructor(icObj, isMobile) {
      //
      //     this.icObj    = icObj;
      //     this.isMobile = isMobile;
      //
      //   }
      // }


      class ButtonEngine {
        constructor() {

          this.initialized = false;

          this.initialize = function(scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
                  .filter(([propName, prop]) => isFunction(prop))
                  .forEach(([propName, prop], i) => {
                    this.awoken[propName] = prop.bind(this.awoken);
                  });

            // this.scopeObj  = scopeObj;
              //engineCarrier,
              //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }


          this.clickListener = function() {
            const button     = this.scopeObj.engineCarrier;
            const buttonFunc = button.buttonConfig.buttonFunc;
            buttonFunc(this.scopeObj);
          };

          this.start = function() {
            console.log("engine::start, this", this);
            console.log("buttonEngine::start", "this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const button         = this.scopeObj.engineCarrier;

            console.log("buttonEngine.start", button.id);

            //get free_rep
            const button__represented = infiniteCanvas.getRepresented(button.id);
            const button__rep_free    = button__represented.r_free();


            //"prestart"
            button__rep_free.addInteraction_click();


            //listen to button
            const button__listener = this.clickListener;
            button__rep_free.onClick(button__listener);

          };

          this.stop = function() {
            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const button         = this.scopeObj.engineCarrier;

            console.log("buttonEngine.start", button.id);

            //get free_rep
            const button__represented = infiniteCanvas.getRepresented(button.id);
            const button__rep_free    = button__represented.r_free();

            const button__listener = this.clickListener;
            button__rep_free.offClick(button__listener);
          };


          this.virgin = Object.assign({}, this);  //virgin == not bound


        }


      }




      class GMOperatorTextChangeEngine {


        constructor() {

          this.initialized = false;

          this.initialize = function(scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
                  .filter(([propName, prop]) => isFunction(prop))
                  .forEach(([propName, prop], i) => {
                    this.awoken[propName] = prop.bind(this.awoken);
                  });

            // this.scopeObj  = scopeObj;
              //engineCarrier,
              //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }



          this.mathOperatorFuncNameForSymbol = function(mathOperatorSymbol) {
            var outMathOperatorFuncName;

            switch(mathOperatorSymbol) {
              case "+":
              case "plus":
              case "add":
                outMathOperatorFuncName = 'add';
                break;
              case "-":
              case "minus":
              case "subtract":
                outMathOperatorFuncName = 'subtract';
                break;
              case "x":
              case "×":
              case "times":
              case "multiplyBy":
                outMathOperatorFuncName = 'multiply';
                break;
              case "/":
              case "divideBy":
              case "add":
                outMathOperatorFuncName = 'divide';
                break;
              default:
                outMathOperatorFuncName = 'unknown';
                break;
            }

            return outMathOperatorFuncName;
          };

          this.createTransformationFunc = function(mathOperatorSymbol_in, mathOperatorFuncName_in, node_b_in) {
            return (node_a) => {
              var outNode;

              const mathOperatorSymbol      = mathOperatorSymbol_in;
              const mathOperatorFuncName    = mathOperatorFuncName_in;
              const node_b                  = node_b_in;

              function standardOperation(node_in) {
                var outNode;

                // const node_b        = new math.ConstantNode(mathValue);
                const node_operator = new math.OperatorNode(mathOperatorSymbol, mathOperatorFuncName, [node_in, node_b]);

                const node_unsimplified = node_operator;

                if(node_in.autoSimplify) {
                  const node_simplified = math.simplify(node_unsimplified);
                  outNode = node_simplified;
                } else {
                  outNode = node_unsimplified;
                }

                outNode.autoSimplify = node_in.autoSimplify;

                return outNode;
              }

              // logger.log("node_a", node_a);
              if(node_a.isEquation) {
                console.log("node_a", node_a);
                const node_left     = standardOperation(node_a.params[0]);
                const node_right    = standardOperation(node_a.params[1]);
                const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                node_equation.isEquation = true;

                outNode = node_equation;
              } else {
                outNode = standardOperation(node_a);
              }

              // outNode.autoSimplify = node_a.autoSimplify;

              return outNode;
            };
          };

          this.transformationFuncForText = function(text) {

            const components   = text.split(" ");
            const mathOperatorSymbol = components[0];
            const mathValueString    = components[1];

            // const mathValue          = Number(mathValueString);

            // const mathValueTex       = MathExpression.fromText(mathValueString).toLatex();
            // console.log("mathValueTex", mathValueTex);

            // const node_b             = math.parse(mathValueTex);   //SHU: math only parses expressions written in math.js DSL
            const node_b             = math.parse(mathValueString);
            console.log("node_b", node_b);

            const mathOperatorFuncName = this.mathOperatorFuncNameForSymbol(mathOperatorSymbol);

            const transformationFunc = this.createTransformationFunc(mathOperatorSymbol, mathOperatorFuncName, node_b);
            // return transformationFunc;

            const icObjTransformationFunc = (icObj) => {
              var outIcObj;

              outIcObj = icObj.clone();

              // logger.log("icObj.mathNode", icObj.mathNode);
              outIcObj.mathNode = transformationFunc(icObj.mathNode);

              return outIcObj;
            };

            return icObjTransformationFunc;
          };


          this.updateTouchSlotWithText = function(text) {

            const gmOperator = this.scopeObj.engineCarrier;
            const touchSlot  = gmOperator.parts["touchSlot"];

            const transformationFunc = this.transformationFuncForText(text);
            const touchSlotConfig = {
              transformationFunc: transformationFunc,
            };
            touchSlot.touchSlotConfig = touchSlotConfig;

          };

          this.textChangeListener = function(rep_free_in) {
            console.log("textChangeListener, rep_free_in", rep_free_in);

            //SHU TODO: trouver pourquoi la facade récupérée n'est pas une rep_free   (quel merdier...)
            const rep_free = infiniteCanvas.getRepresented(rep_free_in.id).r_free();
            console.log("textChangeListener, rep_free", rep_free);

            const text = rep_free.text;
            this.updateTouchSlotWithText(text);
          };





          this.start = function() {
            console.log("engine::start, this", this);
            console.log("GMOperatorTextChangeEngine::start", "this.scopeObj", this.scopeObj);

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const gmOperator     = this.scopeObj.engineCarrier;

            console.log("GMOperatorTextChangeEngine.start", gmOperator);

            const facade    = gmOperator.parts["facade"];

            const rep_free  = facade;

            if(rep_free.onEditExit == null) {
      					rep_free.addInteraction_edit();
      				}

            rep_free.onEditExit(this.textChangeListener);
          };

          this.stop = function() {

            const infiniteCanvas = this.scopeObj.infiniteCanvas;
            const gmOperator     = this.scopeObj.engineCarrier;

            console.log("GMOperatorTextChangeEngine.stop", gmOperator);

            const rep_free = gmOperator;

            rep_free.offEditExit(this.textChangeListener);
          };



          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

        lol() {



        }

      }



      class GMOperatorMama {

        static operatorConfigForRank(rank) {
          var outOperatorConfig = null;

          var name               = null;
          var transformationFunc = null;
          switch(rank%4) {
            case 0:
              name = "+1";
              // transformationFunc = (number) => (number + 1);
              // transformationFunc = (expr) => {
              // console.log("expr", expr);
              transformationFunc = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  const node_b        = new math.ConstantNode(1);
                  const node_operator = new math.OperatorNode('+', 'add', [node_in, node_b]);

                  const node_unsimplified = node_operator;

                  if(node_in.autoSimplify) {
                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;
                  } else {
                    outNode = node_unsimplified;
                  }

                  outNode.autoSimplify = node_in.autoSimplify;

                  return outNode;
                }

                if(node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left     = standardOperation(node_a.params[0]);
                  const node_right    = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                // outNode.autoSimplify = node_a.autoSimplify;

                return outNode;
              };
              break;
            case 1:
              name = "+10";
              // transformationFunc = (number) => (number + 10);
              // transformationFunc = (expr) => expr.add(10);
              transformationFunc = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  const node_b        = new math.ConstantNode(10);
                  const node_operator = new math.OperatorNode('+', 'add', [node_a, node_b]);

                  const node_unsimplified = node_operator;

                  if(node_a.autoSimplify) {
                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;
                  } else {
                    outNode = node_unsimplified;
                  }

                  outNode.autoSimplify = node_a.autoSimplify;

                  return outNode;
                }

                if(node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left     = standardOperation(node_a.params[0]);
                  const node_right    = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                // outNode.autoSimplify = node_a.autoSimplify;

                return outNode;
              };
              break;
            case 2:
              name = "×2";
              // transformationFunc = (number) => (number * 2);
              // transformationFunc = (expr) => expr.multiply(2);
              const transformationFunc__mathNode = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  const node_b        = new math.ConstantNode(2);
                  const node_operator = new math.OperatorNode('x', 'multiply', [node_a, node_b]);

                  const node_unsimplified = node_operator;

                  if(node_a.autoSimplify) {
                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;
                  } else {
                    outNode = node_unsimplified;
                  }

                  outNode.autoSimplify = node_a.autoSimplify;

                  return outNode;
                };

                if(node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left     = standardOperation(node_a.params[0]);
                  const node_right    = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                // outNode.autoSimplify = node_a.autoSimplify;

                return outNode;

              };

              /*
              const transformationFunc__default = (icObj) => {

                icObj.scale = {
                  X: icObj.scale.X * 2,
                  Y: icObj.scale.Y * 2,
                };

                return icObj;
              }

              transformationFunc = (icObj) => {
                var out;
                console.log("transformationFunc, icObj", icObj);

                switch(icObj.type) {
                  case "mathNode":
                    out = transformationFunc__mathNode(icObj);
                    break;
                  default:
                    out = transformationFunc__default(icObj);
                    break;
                }

                return out;
              }
              */
              transformationFunc = transformationFunc__mathNode;


              break;
            case 3:
              name = "×(-1)";
              // transformationFunc = (number) => (number * (-1));
              // transformationFunc = (expr) => expr.multiply(-1);
              transformationFunc = (node_a) => {
                var outNode;

                function standardOperation(node_in) {
                  var outNode;

                  const node_minus_1                  = new math.ConstantNode(-1);
                  const node_minus_1_with_parentheses = new math.ParenthesisNode(node_minus_1);
                  const node_b = node_minus_1_with_parentheses;

                  const node_operator = new math.OperatorNode('x', 'multiply', [node_a, node_b]);

                  const node_unsimplified = node_operator;

                  if(node_a.autoSimplify) {
                    const node_simplified = math.simplify(node_unsimplified);
                    outNode = node_simplified;
                  } else {
                    outNode = node_unsimplified;
                  }

                  outNode.autoSimplify = node_a.autoSimplify;

                  return outNode;
                }


                if(node_a.isEquation) {
                  console.log("node_a", node_a);
                  const node_left     = standardOperation(node_a.params[0]);
                  const node_right    = standardOperation(node_a.params[1]);
                  const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
                  node_equation.isEquation = true;

                  outNode = node_equation;
                } else {
                  outNode = standardOperation(node_a);
                }

                // outNode.autoSimplify = node_a.autoSimplify;

                return outNode;

              };
              break;
            default:
              break;
          }

          // const operatorConfig = new OperatorConfig(name, transformationFunc);

          const icObjTransformationFunc = (icObj) => {
            var outIcObj;

            outIcObj = icObj.clone();

            outIcObj.mathNode = transformationFunc(icObj.mathNode);

            return outIcObj;
          };
          const operatorConfig = new OperatorConfig(name, icObjTransformationFunc);

          outOperatorConfig = operatorConfig;

          return outOperatorConfig;
        }

      }

      class OperatorConfig {

        constructor(name, transformationFunc) {
          this.name               = name;
          this.transformationFunc = transformationFunc;
        }

      }


      class Hooker {

        static createHook() {

          const listeners = [];
          const hookObj = {
            listeners: listeners,
            trigger: (...args) => {
              listeners.forEach((listener, i) => {
                listener(...args);
              });
            },
            on: (listener) => {
              listeners.push(listener);
            },
            off: (listener) => {
              listeners.push(listener);
            },
          };

          return hookObj;
        }

        static installHooks(obj, funcName) {

          const func_original  = obj[funcName];
          if(func_original == null) {
            throw new Error('obj["' + funcName + '"]' + " == null");
          }

          //create hooks
          if(obj.will == null) {
            obj.will = {};
          }
          obj.will[funcName] = this.createHook();

          if(obj.did == null) {
            obj.did = {};
          }
          obj.did[funcName] = this.createHook();



          //decorate func                         //SHU: en fait on pourrait ne pas faire assigner obj.will et obj.did et garder ces objects enfermés dans la définition de la fonction décorée
          // const func_original  = obj[funcName];
          const func_decorated = (...args) => {
            // console.log("func_decorated", ...args);
            obj.will[funcName].trigger(...args);
            func_original(...args);
            obj.did[funcName].trigger(...args);
          };

          obj[funcName] = func_decorated;
        }

      }







/**** view  / controller ****/



      class FabricIntegration {

        constructor(infiniteCanvas, inputProperties) {

          //initialize fabric properties
          fabric.Object.prototype.transparentCorners = false;
          fabric.Object.prototype.cornerStyle = 'circle';
          fabric.Object.prototype.cornerColor = 'black';
          fabric.Object.prototype.borderColor = 'black';
          fabric.Object.prototype.padding     = 10;


          fabric.Rect.prototype.rx = 5;
          fabric.Rect.prototype.ry = 5;


          fabric.Object.prototype.getFObjZIndex = function() {
              // logger.log("this", this);
              // logger.log("this.canvas", this.canvas);
              if(!this.canvas) {          //SHU TODO: understand where this strange state originates from
                return 0;
              }
              return this.canvas.getObjects().indexOf(this);
          };


          // // fabricjs group - always show border
          // fabric.Group.prototype.initialize = (function (initialize) {
          //     return function () {
          //         initialize.apply(this, arguments)
          //         // prepend rect before=behind group objects
          //         this._objects = [
          //         new fabric.Rect({
          //             // position from group center
          //             left: -0.5*this.width,
          //             top: -0.5*this.height,
          //             width: this.width,
          //             height: this.height,
          //
          //             stroke: '#00f',
          //             strokeWidth: 2,
          //             fill: false,
          //         })]
          //         .concat(this._objects)
          //
          //         // TODO repaint border on group resize event
          //
          //         // TODO remove border on group destroy
          //     };
          // })(fabric.Group.prototype.initialize);





          this.infiniteCanvas  = infiniteCanvas;
          this.inputProperties = inputProperties;

          this.mouseIntegration = null;   //set after birth

          const fabricCanvas = new fabric.Canvas(infiniteCanvas.canvas.id, {

            // backgroundColor: 'rgb(100,200,100)',
            // backgroundColor: 'rgb(100,100,100)',
            // backgroundColor: 'rgb(200,200,200)',      //it is important to choose a nice bgColor to stay motivated during dev
            // backgroundColor: 'rgb(230,240,240)',
            backgroundColor: 'rgb(100,100,100)',


            selectionColor:  'blue',
            selectionLineWidth: 2,

            width:  canvas.width,
            height: canvas.height,


            imageSmoothingEnabled: true,
            preserveObjectStacking: true,
          });

          this.fabricCanvas = fabricCanvas;
          this.context      = fabricCanvas.getContext("2d");
          //console.log("fabricCanvas", fabricCanvas);

          this.fabric_objects = [];
          // this.inner_fabric_objects = [];
          // this.outer_fabric_objects = [];

          this.fabric_objects__pure = [];


          this.fabric_objects__hud = [];


          this.fObjForIcObj_dict = {};


          //debug
          {
            // this.isEnabled_supervessel = true;
            this.isEnabled_supervessel = false;
          }

          // this.debugFabric();
          this.synchronizeWithIcObjects(infiniteCanvas.icObjects);

          // this.debugOriginalAxes();

          this.initializeSelectionMgmt();

          this.initializeFreeDrawing();

          this.initializeFabricObjectCopyCut();

          // this.configureActiveSelectionListeners();
        }

        setFabricObjects(fabric_objects__new) {
          this.fabric_objects = fabric_objects__new;
        }

        getFabricObjects() {
          return this.fabric_objects;
        }

        createSupervessel() {
          // logger.log("createSupervessel");

          const infiniteCanvas = this.infiniteCanvas;

          const trueRect_0 = {
            x: 200,
            y: 200,
            width: 100,
            height: 100,
          };

          const parts           = [];
          const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
          const icComposite     = infiniteCanvas.createIcComposite(trueRect_0, parts, compositeConfig);
          infiniteCanvas.addIcObject(icComposite);

          const rep_free = infiniteCanvas.getRepresented(icComposite.id).r_free();
          const fColor = new fabric.Color("lightgray");
          fColor.setAlpha(0.3);
          const rgbaColorString = fColor.toRgba();
          rep_free.fill        = rgbaColorString;

          // rep_free.strokeWidth = 1.5;
          // rep_free.stroke      = "red";

          rep_free.isSupervessel = true;

          return rep_free;
        }

        initializeSelectionMgmt() {
          const fabricIntegration = this;

          const fabricCanvas      = fabricIntegration.fabricCanvas;

          //create supervessel
          setTimeout(() => {      //SHU: encore une envie de vomir
            const rep_free__supervessel = fabricIntegration.createSupervessel();
          }, 500);


          // fabricCanvas.on('selection:cleared', function(options) {
          //   // console.log("selection:cleared", options);
          //   const selectionMgmtObj = getSelectionMgmtObject(options);
          //   processSelectionMgmtObject(selectionObj);
          // });
          // fabricCanvas.on('selection:created', function(options) {
          //   // console.log("selection:created", options);
          //   const selectionMgmtObj = getSelectionMgmtObject(options);
          //   processSelectionMgmtObject(selectionObj);
          // });
          // fabricCanvas.on('selection:updated', function(options) {
          //   // console.log("selection:updated", options);
          //   const selectionMgmtObj = getSelectionMgmtObject(options);
          //   processSelectionMgmtObject(selectionObj);
          // });

          function selectionHandler__default(options) {
            const selectionMgmtObj = getSelectionMgmtObject(options);
            processSelectionMgmtObject(selectionMgmtObj, options);
          }

          fabricCanvas.on('mouse:down:before', (e) => {
            logger.log("mouse:down:before", e);

            if(this.isEnabled_supervessel) {  //SHU: debug clause

              const fObj__supervessel  = fabricIntegration.getFObj__supervessel();
              const icObj__supervessel = fObj__supervessel.icObj;

              if(e.target != null) {

                if(e.target == fObj__supervessel) {
                  //ignore
                  return;
                }

                const arr_part__supervessel = Object.values(icObj__supervessel.parts);
                if(arr_part__supervessel.length > 0) {

                  const arr_part = Object.values(icObj__supervessel.parts);
                  arr_part.forEach((part, i) => {
                    icObj__supervessel.engine.awoken.removePart(part);
                  });

                }
                // else {

                  const fObj__clicked  = e.target;
                  const icObj__clicked = fObj__clicked.icObj;
                  // logger.log("fObj__clicked", fObj__clicked);
                  // logger.log("icObj__clicked", icObj__clicked);


                  logger.log("icObj__supervessel", icObj__supervessel);

                  icObj__supervessel.zIndex = icObj__clicked.zIndex + 1;
                  icObj__supervessel.position = {
                    x: icObj__clicked.position.x,
                    y: icObj__clicked.position.y,
                  };


                  fabricCanvas._setupCurrentTransform(e, fObj__supervessel);  //magic happens here

                  fabricCanvas.setActiveObject(fObj__supervessel);

                  icObj__supervessel.engine.awoken.addPart(icObj__clicked);

                  const options = {
                    selected: [fObj__supervessel],
                  };
                  selectionHandler__default(options);

                // }

              } else {
                // const fObj__supervessel  = fabricIntegration.getFObj__supervessel();
                // const icObj__supervessel = fObj__supervessel.icObj;

                const arr_part = Object.values(icObj__supervessel.parts);
                arr_part.forEach((part, i) => {
                  icObj__supervessel.engine.awoken.removePart(part);
                });
              }

            }

          });
          fabricCanvas.on('selection:created', (e) => {
            logger.log("selection:created", e);
            selectionHandler__default(e);
          });
          fabricCanvas.on('before:transform', (e) => {
            logger.log("before:transform", e);
          });

          fabricCanvas.on('selection:updated', (e) => {
            logger.log("selection:updated", e);
            selectionHandler__default(e);
          });

          fabricCanvas.on('selection:cleared', (e) => {
            logger.log("selection:cleared", e);
            selectionHandler__default(e);
          });


          function getSelectionMgmtObject(options) {
            var outObj;

            const arr_fObj     = Object.values(fabricIntegration.fabric_objects);

            const arr_selected = (options.selected != null) ? options.selected : [];

            const difference = arr_fObj.filter(x => !arr_selected.includes(x));
            const arr_unselected = difference;

            outObj = {
              arr_selected:   arr_selected,
              arr_unselected: arr_unselected,
            };

            return outObj;
          }

          function processSelectionMgmtObject(selectionMgmtObj, options) {
            logger.log("processSelectionMgmtObject", selectionMgmtObj, options);

            selectionMgmtObj.arr_selected.forEach((fObj, i) => {
              const icObj = fObj.icObj;
              icObj.isSelected = true;
            });
            selectionMgmtObj.arr_unselected.forEach((fObj, i) => {
              const icObj = fObj.icObj;
              icObj.isSelected = false;
            });


            //supervessel
            if(selectionMgmtObj.arr_selected.length == 0) {
              logger.log("selectionMgmtObj.arr_selected.length == 0");

            } else if(selectionMgmtObj.arr_selected.length == 1) {
              logger.log("selectionMgmtObj.arr_selected.length == 1");

              // const fObj__selected  = selectionMgmtObj.arr_selected.find(e => true);
              // const icObj__selected = fObj__selected.icObj;
              // // icObj__selected.nowReleased();
              // //XXX fabricCanvas.dismissActiveObject();
              //
              // const icObj__supervessel = fabricIntegration.getIcObj__supervessel();
              // icObj__supervessel.position = {
              //   x: icObj__selected.position.x,
              //   y: icObj__selected.position.y,
              // };
              //
              // const fObj__supervessel = fabricIntegration.getFObj__supervessel();
              // fabricCanvas.setActiveObject(fObj__supervessel);
              // // icObj__supervessel.nowHeld();
              //
              // const o2 = fObj__supervessel;
              // // fabricCanvas._setupCurrentTransform(o2.e, o2.target);
              //
              // // fabricCanvas.on('mouse:down', function(o) {
              // //   // logger.log("789789");
              // //   // fabricCanvas._setupCurrentTransform(o.e, o.target);
              // //   fabricCanvas._setupCurrentTransform(o2.e, o2.target);
              // // });
              //
              // // fabricCanvas.fire("event:dragleave", () => {
              // //
              // // });
              // // fabricCanvas.fire("event:dragenter", () => {
              // //
              // // });
              //
              // //look for Event instance
              // const e = null;
              // logger.log("options", options);
              // const transform__current = fabricCanvas.getCurrentTransform();
              // logger.log("transform__current", transform__current);
              //
              // fabricCanvas._setupCurrentTransform(e, o2);
              // // fabricCanvas.renderAll();

            } else {
              logger.log("selectionMgmtObj.arr_selected.length > 1");
            }

          }

        }

        getFObj__supervessel() {
          const fObj__supervessel = this.getFabricObjects().find(fObj => fObj.icObj.isSupervessel);
          return fObj__supervessel;
        }

        getIcObj__supervessel() {
          const icObj__supervessel = this.getFabricObjects().map(fObj => fObj.icObj).find(icObj => icObj.isSupervessel);
          return icObj__supervessel;
        }


        setSupervesselEnabled(enabled) {
          console.log("setSupervesselEnabled", enabled);
          this.isEnabled_supervessel = enabled;
          // this.fabricCanvas.requestRenderAll();
        }


        // debugOriginalAxes() {
        //
        //   this.debugOriginalAxis_X();
        //   this.debugOriginalAxis_Y();
        // }
        //
        // debugOriginalAxis_X() {
        //
        //   // const line = new fabric.Line([0, -100, 0, +100], {
        //   //   left: 0,
        //   //   top: 0,
        //   //   stroke: 'red'
        //   // });
        //   //
        //   // this.addInnerFabricObject(line);
        //
        //   const rect = new fabric.Rect({
        //     left: 0,
        //     top: 0,
        //     width: 1000,
        //     height: 10,
        //     fill: 'blue',
        //   });
        //
        //   this.addInnerFabricObject(rect);
        //
        //
        //
        // }
        //
        // debugOriginalAxis_Y() {
        //
        //   // const line = new fabric.Line([-100, 0, 100, 0], {
        //   //   left: 0,
        //   //   top: 0,
        //   //   stroke: 'red'
        //   // });
        //   //
        //   // this.addInnerFabricObject(line);
        //
        //   const rect = new fabric.Rect({
        //     left: 0,
        //     top: 0,
        //     width: 10,
        //     height: 1000,
        //     fill: 'red',
        //   });
        //
        //   this.addInnerFabricObject(rect);
        //
        // }



        redrawCanvas(redrawOccasion) {
          console.log("redrawCanvas", redrawOccasion);

          switch(redrawOccasion) {

            case RedrawOccasion.offsetChanged:
              this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.scaleChanged: //order is important here
              this.updateFabricObjectsSize(redrawOccasion);
              this.updateFabricObjectsPosition(redrawOccasion);
              break;

            case RedrawOccasion.orientationChanged:
              this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.objectAdded:
              this.updateFabricObjectsPosition(redrawOccasion);
              this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.pureObjectAdded:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.objectRemoved:
              this.updateFabricObjectsPosition(redrawOccasion);
              this.updateFabricObjectsSize(redrawOccasion);
              break;


            case RedrawOccasion.windowResize:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;


            case RedrawOccasion.forceRedraw:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            default:
              throw new Error("unknown redraw occasion:" + redrawOccasion);
              break;
          }

          this.fabricCanvas.renderAll(); //SHU: render only what is visible (is fabric smart enough ?)
        }


        synchronizeWithIcObjects(icObjects) {

          icObjects.any.forEach((icObj, i) => {
            this.addFabricObjectWithIcObj(icObj);
          });

        }


        addFabricObjectWithIcObj(icObj__r_free) {
          const fabricIntegration = this;
          const fabricCanvas      = this.fabricCanvas;

          console.log("addFabricObjectWithIcObj", "icObj", icObj__r_free);
          // const fObj = this.createFabricObjectWithIcObj(icObj);

          // var icObj_fRep = icObj__r_free.createSisterRepresentation();
          var icObj_fRep = icObj__r_free;
          const fObj_p = fabricIntegration.createFabricObjectWithIcObj_p(icObj_fRep);

          fObj_p.then(fObj => {
            manageCreatedFObj(fObj);
          });

          function manageCreatedFObj(fObj) {

            function standardRedraw(fObj) {
              const icObj = fObj.icObj;
              fObj.set({
                opacity: icObj.opacity,
                fill:    icObj.fill,
              });

              if(icObj.text) {
                console.log("fObj", fObj);
                fObj.set({
                  text: icObj.text,
                  fill: icObj.textColor,
                });
              }

              fabricIntegration.updateFabricObject_size_default(fObj);
              fabricIntegration.updateFabricObject_position_default(fObj);

              fabricCanvas.renderAll();
            }

            function fObjZIndexForIcObj(icObj) {
              var outIndex;

              //get zIndex-ordered icObj array
              const arr_icObj = Object.values(fabricIntegration.fabric_objects).map(fObj => fObj.icObj);


              //create order dict
              var mapped = arr_icObj.map(function(icObj_elt, i) {
                const mapped_obj = {
                  index: i,
                  object: icObj_elt,
                  sortingValue: icObj_elt.zIndex,
                };

                return mapped_obj;
              })

              mapped.sort(function(a, b) {
                if (a.sortingValue > b.sortingValue) {
                  return 1;
                }
                if (a.sortingValue < b.sortingValue) {
                  return -1;
                }
                return 0;
              });
              // console.log("mapped", mapped);

              const dict_indexForObjectId = mapped.reduce((acc, mappedObj, index) => {
                // console.log("mappedObj", mappedObj, "index", index);
                const id_object = mappedObj.object.id;
                acc[id_object] = index;
                return acc;
              }, {});
              // console.log("dict_indexForObjectId", dict_indexForObjectId);


              //get index in order dict
              outIndex = dict_indexForObjectId[icObj.id];

              return outIndex;
            }

            const innerUpdateListener = (icObj_fRep, propName, oldValue, newValue) => {
              // logger.log("innerUpdateListener", icObj_fRep.id_rep, propName, newValue);

              if(propName == "im_dying_now") {
                console.log("im_dying_now");
                if(icObj_fRep.im_dying_now) {
                  fabricIntegration.removeFabricObject(fObj);
                  icObj_fRep.im_dying_now = false;
                  icObj_fRep.im_dead_now  = true;
                }
              }
              else if(propName == "im_active_now") {
                console.log("im_active_now");
                if(icObj_fRep.im_active_now) {
                  fabricIntegration.fabricCanvas.setActiveObject(fObj);
                }
              }

              // else if(propName == "isHeld") {
              //   console.log("innerUpdate", "isHeld");
              // }
              else if(propName == "zIndex") {
                const zIndex_icObj = icObj_fRep.zIndex;
                console.log("zIndex_icObj", zIndex_icObj);

                // fObj.moveTo(zIndex_icObj);
                const zIndex_fObj__target = fObjZIndexForIcObj(icObj_fRep);
                fObj.moveTo(zIndex_fObj__target);

                //debug
                const zIndex_fObj__actual = fObj.getFObjZIndex();
                console.log("zIndex_fObj__actual", zIndex_fObj__actual);
              }


              // else if(propName == "text") {
              //   logger.log("innerUpdate, text", fObj.text);
              //   standardRedraw(fObj);
              // }
              else if(   propName == "tex"
                      || propName == "mathNode"
                      || propName == "richMathNode") {

                fObj.refreshTex_p()
                .then((fObj) => {
                  standardRedraw(fObj);
                });
              }
              else if(propName == "htmlElt") {
                fObj.refreshScreenshot_p()
                .then((fObj) => {
                  standardRedraw(fObj);
                });
              }
              else {
                console.log("icObj_fRep","onInnerUpdate", icObj_fRep);
                standardRedraw(fObj);

                // if(icObj.type == "sparkle") {
                //
                // }

              }

            };
            fObj.fListener_inner = innerUpdateListener;
            icObj_fRep.onInnerUpdate(innerUpdateListener);

            // const outerUpdateListener = (icObj_fRep) => {
            const outerUpdateListener = (icObj_fRep, propName, oldValue, newValue) => {
              // logger.log("outerUpdateListener", icObj_fRep.id_rep, propName, newValue);

              if(propName == "im_dying_now") {
                console.log("im_dying_now");
                if(icObj_fRep.im_dying_now) {
                  fabricIntegration.removeFabricObject(fObj);
                  icObj_fRep.im_dying_now = false;
                  icObj_fRep.im_dead_now  = true;
                }
              }
              // else if(propName == "isHeld") {
              //   console.log("outerUpdate", "isHeld");
              // }
              else if(propName == "text") {
                // logger.log("outerUpdate, text", fObj.text);
                standardRedraw(fObj);
              }
              else if(   propName == "tex"
                      || propName == "mathNode"
                      || propName == "richMathNode") {

                fObj.refreshTex_p()
                .then((fObj) => {
                  standardRedraw(fObj);
                });
              }
              else if(propName == "htmlElt") {
                fObj.refreshScreenshot_p()
                .then((fObj) => {
                  standardRedraw(fObj);
                });
              }
              else {
                console.log("icObj_fRep","onOuterUpdate", icObj_fRep);
                standardRedraw(fObj);
              }

            };
            fObj.fListener_outer = outerUpdateListener;
            icObj_fRep.onOuterUpdate(outerUpdateListener);


            // if(icObj_fRep.onHold != null) {
            //   icObj_fRep.onHold((icObj) => {
            //
            //   });
            // }
            //
            // if(icObj_fRep.onRelease != null) {
            //   icObj_fRep.onRelease((icObj) => {
            //
            //   });
            // }


            if(fObj) {
              fabricIntegration.addOuterFabricObject(fObj);
            }

            //"initial refresh"
            const icObj = fObj.icObj;
            if(   icObj.type == "tex"
               || icObj.type == "mathNode"
               || icObj.type == "richMathNode") {
              fObj.refreshTex_p()
              .then((fObj) => {
                fabricCanvas.renderAll();
              });
            }
            else if(icObj.type == "htmlElt") {
              fObj.refreshScreenshot_p()
              .then((fObj) => {
                fabricCanvas.renderAll();
              });
            }


            if(icObj.im_active_now) {
              fabricIntegration.fabricCanvas.setActiveObject(fObj);

              icObj.nowHeld();

              //SHU TODO
              //while held, position offset should follow cursor offset     (a DSL would be nice someday)

            }

            standardRedraw(fObj);

          }

        }


        addFabricObjectWithPureIcObj(icObj) {

          const fObj = this.createFabricObjectWithIcObj(icObj);

          if(fObj) {
            this.addPureOuterFabricObject(fObj);
          }

        }

        createFabricObjectWithIcObj_p(icObj) {
          var fObj_p = null;

          switch(icObj.type) {
            case "rect":
              {
              const fObj = this.createFabricRectWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;
            case "text":
            case "tag":
              {
              const fObj = this.createFabricITextWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;
            case "image":
              {
              const fObj = this.createFabricImageWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            case "circle":
              {
              const fObj = this.createFabricCircleWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;
            case "point":
              {
              const fObj = this.createFabricCircleWithIcPoint(icObj);
              // fObj = this.createFabricCompositeWithIcObj__point(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "freeDrawing":
              {
              // fObj = this.createFabricPolylineWithIcFreeDrawing(icObj);

              const fObj = this.createFabricFreeDrawingWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "svg":
              {
              fObj_p = this.createFabricSvgWithIcObj_p(icObj);
              }
              break;

            case "tex":
              {
              const fObj = this.createFabricTexWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "mathNode":
              {
              const fObj = this.createFabricMathNodeWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "richMathNode":
              {
              const fObj = this.createFabricRichMathNodeWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "htmlElt":
              {
              const fObj = this.createFabricHtmlEltWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            case "group":
              {
              const fObj = this.createFabricGroupWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;





            case "toggleRect":
              {
              const fObj = this.createFabricToggleRectWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            case "snapSlot":
              {
              const fObj = this.createFabricSnapSlotWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "touchSlot":
              {
              const fObj = this.createFabricTouchSlotWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            case "composite":
              {
              const fObj = this.createFabricCompositeWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "button":
              {
              const fObj = this.createFabricButtonWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;




            case "well":
              {
              const fObj = this.createFabricWellWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "greenMouseWell":
              {
              const fObj = this.createFabricGreenMouseWellWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            case "rxSubject":
              {
              const fObj = this.createFabricRxSubjectWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "rxSubscription":
              {
              const fObj = this.createFabricRxSubscriptionWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;



            case "observer":
              {
              const fObj = this.createFabricRectWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;
            case "trigger":
              {
              const fObj = this.createFabricRectWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;
            case "eventEmitter":
              {
              const fObj = this.createFabricRectWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;
            case "eventReceiver":
              {
              const fObj = this.createFabricRectWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;




            case "segment":
              {
              const fObj = this.createFabricSegmentWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "line":
              {
              const fObj = this.createFabricLineWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            case "sparkle":
              {
              const fObj = this.createFabricSparkleWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            default:
              throw new Error("addFabricObjectWithIcObj " + "unsupported type: " + icObj.type);
              break;
          }

          //common props
          fObj_p = fObj_p.then(fObj => {
            fObj.opacity = icObj.opacity;
            return fObj;
          });

          return fObj_p;
        }


        createFabricRectWithIcObj(icObj) {
          console.log("createFabricRectWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,


            stroke:      icObj.stroke,
            strokeWidth: icObj.strokeWidth,

            // fill: '#f55',
            // fill: 'red',
            fill: icObj.fill,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj : icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);




          //debug
          // fObj.setControlsVisibility({
          //    mt: false,
          //    mb: false,
          //    ml: false,
          //    mr: false,
          //
          //    tl: true,
          //    tr: false,
          //    br: false,
          //    bl: false,
          //
          //    mtr: true,
          // });

          // fObj.hasControls = false;
          fObj.hasBorders  = true;


          return fObj;

        }


        createFabricITextWithIcObj(icObj) {
          // console.log("createFabricITextWithIcObj", icObj);

          const scale  = this.infiniteCanvas.scale;

          var fObj = new fabric.IText(icObj.text);
          fObj.set({
            left:   icObj.position.x,
            top:    icObj.position.y,
            // width:  100,
            // height: 100,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,


            fontSize: icObj.fontSize,

            // scaleX: scale,
            // scaleY: scale,

            // fill: '#f55',
            // fill: 'black',
            fill: icObj.textColor,
            backgroundColor: icObj.backgroundColor ? icObj.backgroundColor : "",

            // opacity: 0.7,


            //~'persistent'
            // birth_scale : birth_scale,

            // trueRect : trueRect,
            // true_fontSize : true_fontSize,
            icObj : icObj,

          });

          //initial size poll
          icObj.size = {          //SHU TODO: convert screen coords to infiniteCanvas coords
            width:  fObj.width,
            height: fObj.height,
          };

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          this.addInteraction_editText(fObj);

          return fObj;
        }

        createFabricImageWithIcObj(icObj) {

          // const scale  = infiniteCanvas.scale;

          var fObj = new fabric.Image(icObj.img);

          fObj.set({
            left:   icObj.position.x,
            top:    icObj.position.y,

            width:  icObj.img.width,
            height: icObj.img.height,
            // width:  icObj.size.width,
            // height: icObj.size.height,


            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            icObj: icObj,
          });

          // const width  = icObj.size.width;
          // const height = icObj.size.height;
          // fObj.scaleToHeight(width);
          // fObj.scaleToWidth(height);


          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;
        }


        createFabricCircleWithIcObj(icObj) {
          // console.log("createFabricCircleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Circle();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            radius: icObj.radius,

            // fill: '#f55',
            // fill: 'red',
            // fill: '',
            fill: icObj.fill,

            // stroke: 'blue',
            stroke: icObj.stroke,
            strokeWidth : 5,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj : icObj,
          });

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }

        createFabricCircleWithIcPoint(icObj) {

          const fabricIntegration = this;

          // console.log("createFabricCircleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Circle();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,


            radius: 10,

            // fill: '#f55',
            // fill: 'blue',
            fill: icObj.fill,

            stroke: '',

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj : icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          // if(icObj.canBeResized) {
          //   this.addInteraction_resize2(fObj);
          // }
          // if(icObj.canBeRotated) {
          //   this.addInteraction_rotate(fObj);
          // }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;

        }

        createFabricSvgWithIcFreeDrawing(icObj) {
          console.log("createFabricSvgWithIcFreeDrawing", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,



            fill: icObj.fill,

            // opacity: 0.7,

            icObj : icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }


        createFabricSvgWithIcObj_p(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const dataUrl = SvgHelper.toDataURL(icObj.svg);

          const promise = new Promise((resolve, reject) => {

            fabric.Image.fromURL(dataUrl, function (img) {
              console.log("img", img);
              // fabricCanvas.add(img);
              // console.log('CORS enabled + crossOrigin property - DataURL: ', img.toDataURL());
              resolve(img);
            },
            null,
            {
              crossOrigin: 'Anonymous',
            });

          });

          const promise2 = promise.then((fObj) => {

            fObj.set({
              left:   icObj.position.x,
              top:    icObj.position.y,

              width:  fObj.width,
              height: fObj.height,
              // width:  icObj.size.width,
              // height: icObj.size.height,


              scaleX: icObj.scale.X,
              scaleY: icObj.scale.Y,

              flipX:   icObj.flip.X,
              flipY:   icObj.flip.Y,

              angle :  icObj.orientation,

              icObj: icObj,
            });

            // const width  = icObj.size.width;
            // const height = icObj.size.height;
            // fObj.scaleToHeight(width);
            // fObj.scaleToWidth(height);


            //event listeners
            if(icObj.canBeHeld) {
              this.addInteraction_hold(fObj);
            }
            if(icObj.canBeMoved) {
              this.addInteraction_move(fObj);
            }
            if(icObj.canBeResized) {
              this.addInteraction_resize2(fObj);
            }
            if(icObj.canBeRotated) {
              this.addInteraction_rotate(fObj);
            }


            this.addInteraction_select(fObj);
            // this.addListeners(fObj);

            return fObj;
          });

          return promise2;
        }


        createFabricTexWithIcObj(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left:   icObj.position.x,
            top:    icObj.position.y,

            width:  icObj.size.width,
            height: icObj.size.height,


            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            originX: "left",
            originY: "top",


            icObj: icObj,
          });


          fObj.refreshTex_p = () => {
            console.log("refreshTex");

            const tex   = icObj.tex;
            const fill  = icObj.fill;

            const svgEl   = TexHelper.toSvgEl(tex, fill);
            const dataUrl = SvgHelper.toDataURL(svgEl);
            const fObj_svg_image_p = new Promise((resolve, reject) => {

              fabric.Image.fromURL(dataUrl, function (img) {
                console.log("img", img);
                // fabricCanvas.add(img);
                // console.log('CORS enabled + crossOrigin property - DataURL: ', img.toDataURL());

                // img.set({
                //   originX: "left",
                //   originY: "top",
                //   left:0,
                //   top:0,
                // });
                // img.setCoords();

                resolve(img);
              },
              null,
              {
                crossOrigin: 'Anonymous',
              });

            });

            const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
              if(fObj.child_tex != null) {
                fObj.remove(fObj.child_tex);
              }

              //add svg image as child
              fObj.child_tex = fObj_child;

              // fObj.add(fObj_child);
              fObj.addWithUpdate(fObj_child);
              console.log("fObj, added child:", fObj_child);

              /*
              fObj.set({
                width:  icObj.size.width,
                height: icObj.size.height,
              });

              function adapt_child() {
                const width  = icObj.size.width;
                const height = icObj.size.height;
                fObj_child.scaleToHeight(width);
                fObj_child.scaleToWidth(height);
              }

              function adapt_group() {
                fObj.set({
                  width:  fObj_child.width,
                  height: fObj_child.height,
                });
              }

              // adapt_child();
              */

              return fObj;
            });

            return add_fObjfObj_svg_image_p;
          };

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          // fObj.refreshTex_p()
          // .then((fObj) => {
          //   fabricCanvas.renderAll();
          // });

          return fObj;
        }


        // createFabricMathNodeWithIcObj(icObj) {
        //
        //   const fabricCanvas = this.fabricCanvas;
        //
        //   const fObj = new fabric.Group();
        //
        //   fObj.set({
        //     left:   icObj.position.x,
        //     top:    icObj.position.y,
        //
        //     width:  icObj.size.width,
        //     height: icObj.size.height,
        //
        //
        //     scaleX: icObj.scale.X,
        //     scaleY: icObj.scale.Y,
        //
        //     flipX:   icObj.flip.X,
        //     flipY:   icObj.flip.Y,
        //
        //     angle :  icObj.orientation,
        //
        //     originX: "left",
        //     originY: "top",
        //
        //
        //     icObj: icObj,
        //   });
        //
        //
        //   fObj.refreshTex_p = () => {
        //     console.log("refreshTex");
        //
        //     const tex   = icObj.mathNode.toTex();
        //     console.log("tex:", tex);
        //
        //     function upgradeTex(tex) {
        //       var outTex;
        //
        //       outTex = tex.replaceAll("\\cdot", "\\times");
        //
        //       return outTex;
        //     }
        //
        //     const tex_upgraded = upgradeTex(tex);
        //
        //     const fill  = icObj.fill;
        //
        //     // const svgEl   = TexHelper.toSvgEl(tex, fill);
        //     const svgEl   = TexHelper.toSvgEl(tex_upgraded, fill);
        //
        //     svgEl.setAttribute("width",  fObj.width);
        //     svgEl.setAttribute("height", fObj.height);
        //
        //     const dataUrl = SvgHelper.toDataURL(svgEl);
        //     const fObj_svg_image_p = new Promise((resolve, reject) => {
        //
        //       fabric.Image.fromURL(dataUrl, function (img) {
        //         // console.log("img", img);
        //
        //         const group = fObj;
        //         img.set({
        //           // left: 0,
	      //           // top: 0,
        //           //SHU: that smell of Scotch Tape
        //           left: -group.width/2,
	      //           top:  -group.height/2,
        //
        //           //debug
        //           // stroke: "yellow",
        //           // strokeWidth: 2,
        //         });
        //
        //         resolve(img);
        //       },
        //       null,
        //       {
        //         crossOrigin: 'Anonymous',
        //       });
        //
        //     });
        //
        //     const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
        //       if(fObj.child_tex != null) {
        //         fObj.remove(fObj.child_tex);
        //       }
        //
        //       //add svg image as child
        //       fObj.child_tex = fObj_child;
        //
        //       fObj.add(fObj_child);
        //       // fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children
        //       console.log("fObj, added child:", fObj_child);
        //
        //       return fObj;
        //     });
        //
        //     return add_fObjfObj_svg_image_p;
        //   };
        //
        //   //event listeners
        //   if(icObj.canBeHeld) {
        //     this.addInteraction_hold(fObj);
        //   }
        //   if(icObj.canBeMoved) {
        //     this.addInteraction_move(fObj);
        //   }
        //   if(icObj.canBeResized) {
        //     this.addInteraction_resize2(fObj);
        //   }
        //   if(icObj.canBeRotated) {
        //     this.addInteraction_rotate(fObj);
        //   }
        //
        //
        //   this.addInteraction_select(fObj);
        //   // this.addListeners(fObj);
        //
        //   this.addInteraction_doubleClick(fObj);
        //
        //
        //
        //   return fObj;
        // }

        createFabricMathNodeWithIcObj(icObj) {
          // logger.log("createFabricMathNodeWithIcObj", icObj);

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left:   icObj.position.x,
            top:    icObj.position.y,

            // width:  icObj.size.width,
            // height: icObj.size.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            originX: "center",
            // originX: icObj.originX ? icObj.originX : "left",
            originY: "top",

            icObj: icObj,
          });


          fObj.refreshTex_p = () => {
            console.log("refreshTex");

            const mathNode = icObj.mathNode;

            const tex   = mathNode.toTex();
            console.log("tex:", tex);

            function upgradeTex(tex) {
              var outTex;

              outTex = tex.replaceAll("\\cdot", "\\times");

              return outTex;
            }

            const tex_upgraded = upgradeTex(tex);

            const fill  = icObj.fill;

            // const svgEl   = TexHelper.toSvgEl(tex, fill);
            const svgEl   = TexHelper.toSvgEl(tex_upgraded, fill);

            // svgEl.setAttribute("width",  fObj.width);
            // svgEl.setAttribute("height", fObj.height);
            // logger.log('svgEl.getAttribute("width")',  svgEl.getAttribute("width"));
            // logger.log('svgEl.getAttribute("height")', svgEl.getAttribute("height"));
            const width_ex__svgEl  = parseFloat(svgEl.getAttribute("width").replace("ex", ""));
            const height_ex__svgEl = parseFloat(svgEl.getAttribute("height").replace("ex", ""));

            const depth__mathNode = getDepth(icObj.mathNode);

            const scaleFactor     = Math.max(20, 70 - depth__mathNode * 8);
            // const scaleFactor     = 10 + depth__mathNode * 10;

            const width_px__svgEl  = width_ex__svgEl  * scaleFactor;
            const height_px__svgEl = height_ex__svgEl * scaleFactor;
            // logger.log('width_px__svgEl',   width_px__svgEl);
            // logger.log('height_px__svgEl',  height_px__svgEl);

            fObj.set({
              width:  width_px__svgEl,
              height: height_px__svgEl,
            });

            const dataUrl = SvgHelper.toDataURL(svgEl);
            const fObj_svg_image_p = new Promise((resolve, reject) => {

              fabric.Image.fromURL(dataUrl, function (img) {
                // console.log("img", img);

                const group = fObj;
                img.set({
                  // left: 0,
	                // top: 0,
                  //SHU: that smell of Scotch Tape
                  left: -group.width/2,
	                top:  -group.height/2,

                  // width:  group.width,
                  // height: group.height,
                  // width:  width_px__svgEl,
                  // height: height_px__svgEl,

                  //debug
                  // stroke: "yellow",
                  // strokeWidth: 2,
                });

                img.scaleToWidth(width_px__svgEl);
                img.scaleToHeight(height_px__svgEl);

                resolve(img);
              },
              null,
              {
                crossOrigin: 'Anonymous',
              });

            });

            const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
              if(fObj.child_tex != null) {
                fObj.remove(fObj.child_tex);
              }

              //add svg image as child
              fObj.child_tex = fObj_child;

              fObj.add(fObj_child);
              // fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children
              console.log("fObj, added child:", fObj_child);

              return fObj;
            });

            return add_fObjfObj_svg_image_p;
          };

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          this.addInteraction_doubleClick(fObj);



          return fObj;
        }


        createFabricRichMathNodeWithIcObj(icObj) {
          logger.log("createFabricRichMathNodeWithIcObj", icObj);

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left:   icObj.position.x,
            top:    icObj.position.y,

            // width:  icObj.size.width,
            // height: icObj.size.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            originX: "center",
            // originX: icObj.originX ? icObj.originX : "left",
            originY: "top",

            icObj: icObj,
          });


          fObj.refreshTex_p = () => {
            console.log("refreshTex");

            const richMathNode = icObj.richMathNode;
            const mathNode     = richMathNode.mathNode;

            // const tex   = mathNode.toTex();
            const tex   = richMathNode.toTex();
            logger.log("tex:", tex);

            function upgradeTex(tex) {
              var outTex;

              outTex = tex.replaceAll("\\cdot", "\\times");

              // outTex = "{\\color{blue} 0} {\\color{white} +} {\\color{red} 1}";

              return outTex;
            }

            const tex_upgraded = upgradeTex(tex);

            const fill  = icObj.fill;

            // const svgEl   = TexHelper.toSvgEl(tex, fill);
            const svgEl   = TexHelper.toSvgEl(tex_upgraded, fill);

            // svgEl.setAttribute("width",  fObj.width);
            // svgEl.setAttribute("height", fObj.height);
            // logger.log('svgEl.getAttribute("width")',  svgEl.getAttribute("width"));
            // logger.log('svgEl.getAttribute("height")', svgEl.getAttribute("height"));
            const width_ex__svgEl  = parseFloat(svgEl.getAttribute("width").replace("ex", ""));
            const height_ex__svgEl = parseFloat(svgEl.getAttribute("height").replace("ex", ""));


            const depth__mathNode = getDepth(mathNode);

            const scaleFactor     = Math.max(20, 70 - depth__mathNode * 8);
            // const scaleFactor     = 10 + depth__mathNode * 10;

            const width_px__svgEl  = width_ex__svgEl  * scaleFactor;
            const height_px__svgEl = height_ex__svgEl * scaleFactor;
            // logger.log('width_px__svgEl',   width_px__svgEl);
            // logger.log('height_px__svgEl',  height_px__svgEl);

            fObj.set({
              width:  width_px__svgEl,
              height: height_px__svgEl,
            });

            const dataUrl = SvgHelper.toDataURL(svgEl);
            const fObj_svg_image_p = new Promise((resolve, reject) => {

              fabric.Image.fromURL(dataUrl, function (img) {
                // console.log("img", img);

                const group = fObj;
                img.set({
                  // left: 0,
	                // top: 0,
                  //SHU: that smell of Scotch Tape
                  left: -group.width/2,
	                top:  -group.height/2,

                  // width:  group.width,
                  // height: group.height,
                  // width:  width_px__svgEl,
                  // height: height_px__svgEl,

                  //debug
                  // stroke: "yellow",
                  // strokeWidth: 2,
                });

                img.scaleToWidth(width_px__svgEl);
                img.scaleToHeight(height_px__svgEl);

                resolve(img);
              },
              null,
              {
                crossOrigin: 'Anonymous',
              });

            });

            const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
              if(fObj.child_tex != null) {
                fObj.remove(fObj.child_tex);
              }

              //add svg image as child
              fObj.child_tex = fObj_child;

              fObj.add(fObj_child);
              // fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children
              console.log("fObj, added child:", fObj_child);

              return fObj;
            });

            return add_fObjfObj_svg_image_p;
          };

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          this.addInteraction_doubleClick(fObj);



          return fObj;
        }


        createFabricHtmlEltWithIcObj(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left:   icObj.position.x,
            top:    icObj.position.y,

            width:  icObj.size.width,
            height: icObj.size.height,


            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            originX: "left",
            originY: "top",


            icObj: icObj,
          });


          fObj.refreshScreenshot_p = () => {
            console.log("refreshScreenshot_p");

            const html_elt = icObj.htmlElt;
            console.log("html_elt", html_elt);

            // const canvasElt_p = html2canvas(html_elt);
            const canvasElt_p = html2canvas(html_elt, {
              // onclone: function (clone__htmlElt) {
                  // clone__htmlElt.style.visibility = "visible";
                  // clone__htmlElt.style.display = "block";
                // },
            });

            const fObj_hmtlElt_image_p = canvasElt_p.then((canvasElt) => {

              function getNumericalValueForPxString(pxString) {
                return parseInt(pxString.replace("px", ""));
              }

              const width__canvasElt  = getNumericalValueForPxString(canvasElt.style.width);
              const height__canvasElt = getNumericalValueForPxString(canvasElt.style.height);

              const img = new fabric.Image(canvasElt);

              const group = fObj;
              img.set({
                // left: 0,
                // top: 0,
                //SHU: that smell of Scotch Tape
                left: -group.width/2,
                top:  -group.height/2,

                //debug
                // stroke: "yellow",
                // strokeWidth: 2,
              });

              return img;
            });

            const add_fObjfObj_htmlElt_image_p = fObj_hmtlElt_image_p.then((fObj_child) => {
              if(fObj.child_htmlScreenshot != null) {
                fObj.remove(fObj.child_htmlScreenshot);
              }

              //add image as child
              fObj.child_htmlScreenshot = fObj_child;

              // fObj.add(fObj_child);
              fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children
              console.log("fObj, added child:", fObj_child);

              return fObj;
            });

            return add_fObjfObj_htmlElt_image_p;
          };

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }




          //group

        createFabricGroupWithIcObj(icObj) {
          console.log("createFabricGroupWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Group();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            fill:    icObj.fill,

            // opacity: 0.7,

            icObj : icObj,
          });


          //create inner objects
          const fGroup = fObj;
          const childFObjs = icObj.children.map(icObj => {
            return this.createFabricGroupContentForFabricGroup(icObj, fGroup);
          });

          //add inner objects
          fObj.add(...childFObjs);



          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;

        }

        createFabricGroupContentForFabricGroup(icObj, fGroup) {
          const icGroup = fGroup.icObj;

          var fObj = this.createFabricObjectWithIcObj(icObj);

          //set the right coordinates:
          const icGroup_rect = Geometry.createRect(icGroup.position.x, icGroup.position.y, icGroup.size.width, icGroup.size.height);
          const  fGroup_rect = Geometry.createRect(fGroup.left, fGroup.top, fGroup.width, fGroup.height);

          const position = Geometry.getPointFromRectToRect(icObj.position, icGroup_rect, fGroup_rect);

          // const offsetFromCenterToTL = {
          //   dx: -fGroup.width,
          //   dy: -fGroup.height,
          // };

          const offsetFromCenterToTL = {
            dx: -fGroup.width/2,
            dy: -fGroup.height/2,
          };

          fObj.set({
            left: position.x + offsetFromCenterToTL.dx,
            top:  position.y + offsetFromCenterToTL.dy,
          });

          return fObj;

        }








        createFabricToggleRectWithIcObj(icObj) {
          console.log("createFabricToggleRectWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            //to avoid overlapping when clicking
            padding:     0,
            strokeWidth: 0,

            icObj : icObj,
          });

          configureWithIsActive(fObj, icObj.isActive);

          function configureWithIsActive(fObj, isActive) {

            const cfg = isActive ? fObj.icObj.activeCfg : fObj.icObj.inactiveCfg;

            fObj.set({
              fill:    cfg.fill,
              opacity: cfg.opacity,
            });

          }

          fObj.hasControls = false;
          fObj.hasBorders  = true;


          //event listeners
          if(icObj.canBeSelected) {

            this.addInteraction_select(fObj);

            if(icObj.canBeHeld) {
              this.addInteraction_hold(fObj);
            }

            if(icObj.canBeMoved) {
              this.addInteraction_move(fObj);
            }
            if(icObj.canBeResized) {
              this.addInteraction_resize2(fObj);
            }
            if(icObj.canBeRotated) {
              this.addInteraction_rotate(fObj);
            }


            const fabricCanvas = this.fabricCanvas;

            fObj.on('mouseup', function(options) {
              console.log("mouseup", "options", options);

              const icObj = fObj.icObj;

              const isActive_update = !icObj.isActive;

              const icObj_new = Object.assign({}, icObj);
              icObj_new.isActive = isActive_update;

              icObj.update(icObj_new, false);

              configureWithIsActive(fObj, isActive_update);

              fabricCanvas.renderAll();

            });


          } else {
            fObj.selectable = false;
          }

          // this.addListeners(fObj);



          return fObj;

        }


        createFabricSnapSlotWithIcObj(icObj) {
          console.log("createFabricSnapSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            //to avoid overlapping when clicking
            padding:     0,
            stroke:      icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj : icObj,
          });


          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }

        createFabricTouchSlotWithIcObj(icObj) {
          console.log("createFabricTouchSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            //to avoid overlapping when clicking
            padding:     0,
            stroke:      icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj : icObj,
          });


          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }


        createFabricCompositeWithIcObj(icObj) {
          console.log("createFabricCompositeWithIcObj", icObj);

          const fObj = this.createFabricRectWithIcObj(icObj);

          return fObj;
        }

        createFabricCompositePartWithIcObj(icObj) {
          console.log("createFabricCompositeWithIcObj", icObj);

          const fObj = this.createFabricObjectWithIcObj(icObj);

          return fObj;
        }


        createFabricButtonWithIcObj(icObj) {
          console.log("createFabricSnapSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            //to avoid overlapping when clicking
            padding:     0,

            stroke:      icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill:        icObj.fill,

            icObj : icObj,
          });


          // if(icObj.canBeHeld) {
          //   this.addInteraction_hold(fObj);
          // }
          fObj.selectable = false;
          this.addInteraction_click(fObj);

          return fObj;
        }



        createFabricWellWithIcObj(icObj) {
          console.log("createFabricWellWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            //to avoid overlapping when clicking
            padding:     0,
            stroke:      icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj : icObj,
          });


          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }

        createFabricGreenMouseWellWithIcObj(icObj) {
          console.log("createFabricGreenMouseWellWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            //to avoid overlapping when clicking
            padding:     0,
            stroke:      icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj : icObj,
          });


          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }


        createFabricRxSubjectWithIcObj(icObj) {
          return this.createFabricRectWithIcObj(icObj);
        }

        createFabricRxSubscriptionWithIcObj(icObj) {
          return this.createFabricRectWithIcObj(icObj);
        }





        createFabricSegmentWithIcObj(icObj) {
          console.log("createFabricLineWithIcSegment", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Line();

          // console.log("line:", fObj);
          // throw new Error("please die here");

          function screenPointWithoutOffset(infiniteCanvas, truePoint) {
            const screenX = truePoint.x * infiniteCanvas.scale.X;
            const screenY = truePoint.y * infiniteCanvas.scale.Y;
            return Geometry.createPoint(screenX, screenY);
          }

          const screenPoint_start = screenPointWithoutOffset(infiniteCanvas, icObj.point_start);
          const screenPoint_end   = screenPointWithoutOffset(infiniteCanvas, icObj.point_end);

          fObj.set({
            x1:   screenPoint_start.x,
            y1:   screenPoint_start.y,

            x2:   screenPoint_end.x,
            y2:   screenPoint_end.y,

            // x1:   100,
            // y1:   100,
            //
            // x2:   500,
            // y2:   500,

            stroke:      "black",
            strokeWidth: 5,
            fill:        "red",

            // stroke:      icObj.stroke,
            // strokeWidth: icObj.strokeWidth,
            // fill:        icObj.fill,

            icObj : icObj,
          });



          //write now known icObj props
          const screenRect = {
            left:   fObj.left,
            top:    fObj.top,
            width:  fObj.width,
            height: fObj.height,
          };

          const trueRect = infiniteCanvas.toTrueRect(screenRect);

          icObj.position = {
            x: trueRect.x,
            y: trueRect.y,
          };

          icObj.size = {
            width:  trueRect.width,
            height: trueRect.height,
          };




          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          return fObj;
        }



        createFabricFreeDrawingWithIcObj(icObj) {
          console.log("createFabricFreeDrawingWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          const exoObject = icObj.exoObject;

          var fObj = new fabric.Path(exoObject.path);

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,
            //
            // scaleX:  icObj.scale.X,
            // scaleY:  icObj.scale.Y,
            //
            // flipX:   icObj.flip.X,
            // flipY:   icObj.flip.Y,


            angle :  icObj.orientation,


            stroke:           exoObject.stroke,
            strokeDashArray:  exoObject.strokeDashArray,
            strokeLineCap:    exoObject.strokeLineCap,
            strokeLineJoin:   exoObject.strokeLineJoin,
            strokeMiterLimit: exoObject.strokeMiterLimit,
            strokeWidth:      exoObject.strokeWidth,

            fill:             exoObject.fill,

            opacity: icObj.opacity,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj : icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);




          //debug
          fObj.setControlsVisibility({
             mt: false,
             mb: false,
             ml: false,
             mr: false,

             tl: true,
             tr: false,
             br: false,
             bl: false,

             mtr: true,
          });

          // fObj.hasControls = false;
          fObj.hasBorders  = true;


          return fObj;
        }


        createFabricSparkleWithIcObj(icObj) {
          console.log("createFabricSparkleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          // var fObj = new fabric.Triangle();
          var fObj = new fabric.Image(icObj.img);


          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          // const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,
            width:  icObj.img.width,
            height: icObj.img.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            // fill: '#f55',
            // fill: 'red',
            fill: icObj.fill,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj : icObj,
          });

          if(icObj.isUsingCenterPosition) {
            fObj.set({
              originX: "center",          //:)
              originY: "center",          //:)
            });
          }


          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          return fObj;
        }







        addInteraction_move(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          fObj.on('moving', function(options) {
            // console.log("moving", "options", options);

            const target = options.target;

            const offset = infiniteCanvas.offset;
            const scale  = infiniteCanvas.scale;

            // const trueRect_left__new = (target.left / scale - offset.dx);
            // const trueRect_top__new  = (target.top  / scale - offset.dy);
            //
            // const trueRect_update = {
            //   left: trueRect_left__new,
            //   top:  trueRect_top__new,
            // };
            // Object.assign(target.trueRect, trueRect_update);



            const icObj = fObj.icObj;

            const screenPoint = {
              x: target.left,
              y: target.top,
            };

            const position_update = infiniteCanvas.toTruePoint(screenPoint);


            //---old style---
            // const icObj_new = Object.assign({}, icObj);
            // Object.assign(icObj_new.position, position_update);
            // icObj.update(icObj_new, false);

            //---new style: rep inner update---
            const rep_free = fObj.icObj;
            console.log("ççç on 'moving' rep_free.id_rep", rep_free.id_rep);
            const listener = fObj.fListener_inner;

            //listen:off
            rep_free.offInnerUpdate(listener);

            //mutate
            {
              rep_free.position = position_update;
            }

            //listen:on
            rep_free.onInnerUpdate(listener);

          });

        }

        // addInteraction_resize(fObj) {
        //
        //   const infiniteCanvas = this.infiniteCanvas;
        //   const fabricCanvas   = this.fabricCanvas;
        //
        //   var isScaling = false;
        //   var original_trueRect = null;
        //   fObj.on('scaling', function(options) {
        //     console.log("scaling", "options", options);
        //     const original = options.transform.original;
        //
        //     const target   = options.transform.target;
        //
        //     if(!isScaling) {
        //       original_trueRect = Geometry.createRect(target.icObj.position.x, target.icObj.position.y, target.icObj.size.width, target.icObj.size.height);
        //       console.log("original_trueRect", original_trueRect);
        //       isScaling = true;
        //     }
        //
        //     const scaleFactorX = target.scaleX / original.scaleX;
        //     const scaleFactorY = target.scaleY / original.scaleY;
        //
        //     console.log("scaleFactorX", scaleFactorX);
        //
        //     const trueRect_width__new  = (original_trueRect.width  * scaleFactorX);
        //     const trueRect_height__new = (original_trueRect.height * scaleFactorY);
        //
        //     console.log("trueRect_width__new", trueRect_width__new);
        //
        //
        //
        //     const offset = infiniteCanvas.offset;
        //     const scale  = infiniteCanvas.scale;
        //
        //     // const trueRect_update = {
        //     //   width:  trueRect_width__new,
        //     //   height: trueRect_height__new,
        //     // };
        //     //
        //     // // Object.assign(target.trueRect, trueRect_update);
        //     // Object.assign(fObj.trueRect, trueRect_update);
        //
        //     const trueRect_update = {
        //       left:  target.left / scale.X - offset.dx,
        //       top:   target.top  / scale.Y - offset.dy,
        //
        //       width:  (original_trueRect.width  * scaleFactorX),
        //       height: (original_trueRect.height * scaleFactorY),
        //     };
        //
        //     const icObj_update = {
        //       position: Geometry.createPoint(trueRect_update.left, trueRect_update.top),
        //       size:     Geometry.createSize(trueRect_update.width, trueRect_update.height),
        //     };
        //
        //     const icObj = fObj.icObj;
        //
        //     const icObj_new = Object.assign({}, icObj);
        //     Object.assign(icObj_new, icObj_update);
        //
        //     icObj.update(icObj_new, false);
        //
        //   });
        //   fObj.on('scaled', function(options) {
        //     console.log("scaled", "options", options);
        //     isScaling = false;
        //     original_trueRect = null;
        //
        //     const original = options.transform.original;
        //     const target   = options.transform.target;
        //
        //     target.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //
        //       //not used:
        //       // width:  target.trueRect.width  * scale,
        //       // height: target.trueRect.height * scale,
        //
        //       //used instead:
        //       // width:  target.trueRect.width,
        //       // height: target.trueRect.height,
        //       width:  target.icObj.size.width,
        //       height: target.icObj.size.height,
        //
        //       scaleX : original.scaleX,
        //       scaleY : original.scaleY,
        //     });
        //     target.setCoords();
        //   });
        //
        // }

        addInteraction_resize2(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          var isScaling = false;
          var original_homeScale = null;
          var original_scale     = null;
          fObj.on('scaling', function(options) {
            console.log("scaling", "options", options);


            const original = options.transform.original;
            const target   = options.transform.target;

            if(!isScaling) {
              original_homeScale = Object.assign({}, target.icObj.homeScale);
              // console.log("original_homeScale", original_homeScale);
              original_scale = Object.assign({}, target.icObj.scale);

              isScaling = true;
            }



            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);

            switch(options.transform.action) {

              case "scale":
                handle_proportionnal_scale();
                break;

              case "scaleX":
              case "scaleY":
                handle_axis_scale();
                // handle_proportionnal_scale();


                break;
            }

            function handle_proportionnal_scale() {

              const icObj = fObj.icObj;

              var homeScale_new;

              // if(fObj instanceof fabric.Text) {

                // const fontSize_fObj = fObj.fontSize;
                // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
                //
                // homeScale_new = {
                //   X: original_homeScale.X,
                //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
                // };

              // } else {

                homeScale_new = {
                  X: original_homeScale.X / scaleFactor.X,
                  Y: original_homeScale.Y / scaleFactor.Y,
                };

              // }
              console.log("homeScale_new", homeScale_new);

              const icObj_update = {
                homeScale: homeScale_new,
              };

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new, icObj_update);

              icObj.update(icObj_new, false);



              //update position
              {

                const fObj_pos = {
                  x: fObj.left,
                  y: fObj.top,
                };

                const position_update = infiniteCanvas.toTruePoint(fObj_pos);

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.position, position_update);

                icObj.update(icObj_new, false);

              }

              // //update flipX
              // {
              //   const flipX_update = fObj.flipX;
              //
              //   const icObj_new = Object.assign({}, icObj);
              //   Object.assign(icObj_new.flipX, flipX_update);
              //
              //   icObj.update(icObj_new, false);
              // }


            }

            function handle_axis_scale() {

              const icObj = fObj.icObj;

              var scale_new;

              // if(fObj instanceof fabric.Text) {

                // const fontSize_fObj = fObj.fontSize;
                // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
                //
                // homeScale_new = {
                //   X: original_homeScale.X,
                //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
                // };

              // } else {

                scale_new = {
                  X: original_scale.X * scaleFactor.X,
                  Y: original_scale.Y * scaleFactor.Y,
                };

              // }
              console.log("scale_new", scale_new);

              const icObj_update = {
                scale: scale_new,
              };

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new, icObj_update);

              icObj.update(icObj_new, false);




              //update position
              {

                const fObj_pos = {
                  x: fObj.left,
                  y: fObj.top,
                };

                const position_update = infiniteCanvas.toTruePoint(fObj_pos);

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.position, position_update);

                icObj.update(icObj_new, false);

              }

              //update flipX
              {
                const flip_update = {
                  X: (fObj.flipX != null) ? fObj.flipX : false,
                  Y: (fObj.flipY != null) ? fObj.flipY : false,
                };

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.flip, flip_update);

                icObj.update(icObj_new, false);
              }



            }




          });
          fObj.on('scaled', function(options) {
            console.log("scaled", "options", options);
            isScaling = false;

            /*
            const original = options.transform.original;
            const target   = options.transform.target;

            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);


            const icObj = fObj.icObj;

            var homeScale_new;

            if(fObj instanceof fabric.Text) {

              // const fontSize_fObj = fObj.fontSize;
              // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
              //
              // homeScale_new = {
              //   X: scale.X / scale_fObj.X / scaleFactor__fontSize,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

            } else {

              homeScale_new = {
                X: original_homeScale.X / scaleFactor.X,
                Y: original_homeScale.Y / scaleFactor.Y,
              };

            }
            console.log("homeScale_new", homeScale_new);


            const icObj_update = {
              homeScale: homeScale_new,
            };

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);

            icObj.update(icObj_new, false);
            */

            original_homeScale = null;

          });

        }


        addInteraction_rotate(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          // const fabricCanvas   = this.fabricCanvas;

          // var isRotating = false;

          fObj.on('rotating', function(options) {
            // console.log("rotating", "options", options);

            // if(!isRotating) {
            //   isRotating = true;
            //
            //
            // }

            const original = options.transform.original;


            const target = options.transform.target;

            const icObj = fObj.icObj;

            // const orientation_update = target.angle + infiniteCanvas.orientation;
            const orientation_update = Geometry.boundedAngleInDegrees(target.angle + infiniteCanvas.orientation);
            // console.log("orientation_update", orientation_update);




            // console.log("target.angle",     target.angle);
            // console.log("original.angle", original.angle);
            //
            // const rotationAngle = target.angle - original.angle;
            // const rotationAngle_bounded = Geometry.boundedAngleInDegrees(rotationAngle);
            // console.log("rotationAngle", rotationAngle);
            //
            // const originalRect   = Geometry.createRect(original.left, original.top, target.width, target.height);
            // const originalTL     = Geometry.getPointTL(originalRect);
            // const originalCenter = Geometry.getCenterPoint(originalRect);
            // console.log("originalTL",     originalTL);
            // console.log("originalCenter", originalCenter);
            //
            // const screenTL_new = Geometry.pointWithRotation(originalTL, originalCenter, rotationAngle_bounded);
            // console.log("screenTL_new", screenTL_new);
            //
            //
            //
            //
            //
            //
            // const position_update = infiniteCanvas.toTruePoint(screenTL_new);



            const screenPoint = {
              x: target.left,
              y: target.top,
            };

            const position_update = infiniteCanvas.toTruePoint(screenPoint);


            const icObj_new = Object.assign({}, icObj);
            // Object.assign(icObj_new.orientation, orientation_update);

            icObj_new.orientation = orientation_update;

            Object.assign(icObj_new.position, position_update);

            icObj.update(icObj_new, false);
          });

        }


        addInteraction_select(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;


          // fObj.on('selected', function(options) {
          //   console.log("selected", "options", options);
          //
          //   // const activeGroup = fabricCanvas.getActiveGroup();
          //
          //   /*
          //   const activeObject   = fabricCanvas.getActiveObject();
          //
          //   // console.log("activeObject", activeObject);
          //
          //   const icObj = activeObject.icObj;
          //
          //   console.log("icObj.size.width",  icObj.size.width);
          //   console.log("icObj.homeScale.X", icObj.homeScale.X);
          //   console.log("icObj.scale.X",     icObj.scale.X);
          //
          //   console.log("icObj.getTrueSize()", activeObject.icObj.getTrueSize());
          //
          //   console.log("activeObject.scaleX", activeObject.scaleX);
          //   console.log("activeObject.scaleY", activeObject.scaleY);
          //
          //   console.log("infiniteCanvas.scale.X", infiniteCanvas.scale.X);
          //
          //   if(fObj instanceof fabric.Text) {
          //     console.log("icObj.fontSize", icObj.fontSize);
          //     console.log(" fObj.fontSize",  fObj.fontSize);
          //   }
          //   */
          //
          //   const icObj = fObj.icObj;
          //   icObj.isSelected = true;
          //
          // });

          // fObj.on('deselected', function(options) {
          //   console.log("selected", "options", options);
          // });

        }

        addInteraction_hold(fObj) {
          // logger.trace("addInteraction_hold", fObj);

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          const icObj = fObj.icObj;

          var isHeld = false;
          //hold
          fObj.on('mousedown', function(options) {
            isHeld = true;
            console.log("isHeld", isHeld);
            console.log("icObj", icObj);
            console.log("fObj.icObj", fObj.icObj);

            icObj.nowHeld();
          });

          //release
          fObj.on('mouseup', function(options) {
            console.log("fObj, mouseup", options);
            isHeld = false;
            console.log("isHeld", isHeld);
            icObj.nowReleased();
          });

        }


        addInteraction_editText(fObj) {

          // fObj.on('changed', function(options) {
          //
          // });

          fObj.on('changed', function(options) {
            console.log("changed", "options", options);

            console.log("fObj.text", fObj.text);

            const text_new = fObj.text;

            const icObj = fObj.icObj;


            //old way
            /*
            const icObj_update = {
              text: text_new,
            };
            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);
            icObj.update(icObj_new, false);
            */

            //new way
            icObj.text = text_new;
          });


          fObj.on('editing:entered', function(options) {
            const icObj = fObj.icObj;
            icObj.nowEditEnter();
          });

          fObj.on('editing:exited', function(options) {
            const icObj = fObj.icObj;
            console.log("editing:exited, icObj", icObj);
            console.log("editing:exited, icObj.text", icObj.text);

            icObj.nowEditExit();
          });

        }

        addInteraction_click(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          fObj.on('mousedown', function(options) {
            console.log("mousedown", "options", options);

            const icObj = fObj.icObj;

            icObj.nowClicked();
          });

        }

        addInteraction_doubleClick(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          fObj.on('mousedblclick', function(options) {
            console.log("mousedblclick", "options", options);

            const icObj = fObj.icObj;

            icObj.edit.start();
          });

        }


        configureActiveSelectionListeners() {
          // object:moving
          // object:scaling
          // object:rotating
          // object:skewing
          // object:moved
          // object:scaled
          // object:rotated
          // object:skewed

          const fabricIntegration = this;

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          //creation
          this.fabricCanvas.on("selection:created", (options) => {
            // console.log("selection:created", event);

            const activeObject = this.fabricCanvas.getActiveObject();

            if(activeObject instanceof fabric.ActiveSelection) {
              const activeSelection = activeObject;
              // console.log("activeSelection", activeSelection);

              //inject 'initial' props
              activeSelection.icObj = infiniteCanvas.createIcActiveSelection_from_activeSelectionFObj(activeSelection);
            }

          });

          //update
          this.fabricCanvas.on("selection:updated", (options) => {
            //SHU TODO
          });







          //move
          this.fabricCanvas.on("object:moving", (options) => {
            // console.log("object:moving", event);

            const target = options.target;
            if(target.type == "activeSelection") {
              activeSelection_moving(target);
            }

          });

          //scale
          this.fabricCanvas.on("object:scaling", (options) => {
            // console.log("object:scaling", options);

            const target = options.target;
            if(target.type == "activeSelection") {
              activeSelection_scaling(options);
            }

          });
          this.fabricCanvas.on("object:scaled", (options) => {
            // console.log("object:scaling", event);

            const target = options.target;
            if(target.type == "activeSelection") {
              activeSelection_scaled(target);
            }

          });


          //rotate
          this.fabricCanvas.on("object:rotating", (options) => {
            // console.log("object:rotating", event);

            const target = options.target;
            if(target.type == "activeSelection") {
              activeSelection_rotating(options);
            }

          });







          function activeSelection_moving(activeSelection) {
            console.log("activeSelection moving");

            //update activeSelection position
            {
              const fObj = activeSelection;

              const icObj = fObj.icObj;

              const fObj_screenPos = {
                x: fObj.left,
                y: fObj.top,
              };

              const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new.position, position_update);

              icObj.update(icObj_new, false);
            }

            //update children position

            const activeSelectionCL = activeSelection.left + activeSelection.width  / 2;
            const activeSelectionCT = activeSelection.top  + activeSelection.height / 2;

            function updateChildFObj_position(fObj) {

              const icObj = fObj.icObj;

              const screenPoint = {
                x: activeSelectionCL + fObj.left,
                y: activeSelectionCT + fObj.top,
              };

              const position_update = infiniteCanvas.toTruePoint(screenPoint);

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new.position, position_update);

              icObj.update(icObj_new, false);
            }

            activeSelection.forEachObject((fObj, index, arr_fObj) => {
              updateChildFObj_position(fObj);
            }, fabricIntegration.fabricCanvas.context);


          }



          var isScaling = false;
          var original_props = {};
          function activeSelection_scaling(options) {
            console.log("activeSelection scaling", options);

            const target   = options.target;
            const original = options.transform.original;

            const activeSelection = target;

            if(!isScaling) {

              //store original props
              const activeSelection_icObj_propDict = {
                homeScale:  Object.assign({}, activeSelection.icObj.homeScale),
                scale:      Object.assign({}, activeSelection.icObj.scale),
              };

              original_props["activeSelection_icObj"] = activeSelection_icObj_propDict;

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                const propDict = {
                  homeScale:  Object.assign({}, icObj.homeScale),
                  scale:      Object.assign({}, icObj.scale),
                };

                original_props[icObj.id] = propDict;

              }, fabricIntegration.fabricCanvas.context);

              isScaling = true;
            }



            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);

            switch(options.transform.action) {

              case "scale":
                handle_proportionnal_scale(activeSelection);
                break;

              case "scaleX":
              case "scaleY":
                handle_axis_scale(activeSelection);

                break;
            }

            function handle_proportionnal_scale(activeSelection) {

              //update activeSelection icObj
              {
                const icObj = activeSelection.icObj;

                var homeScale_new;

                const original_homeScale = original_props["activeSelection_icObj"].homeScale;

                homeScale_new = {
                  X: original_homeScale.X / scaleFactor.X,
                  Y: original_homeScale.Y / scaleFactor.Y,
                };

                console.log("homeScale_new", homeScale_new);

                const icObj_update = {
                  homeScale: homeScale_new,
                };

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new, icObj_update);

                icObj.update(icObj_new, false);
              }


              //update children

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                //update scale
                {
                  var homeScale_new;

                  const original_homeScale = original_props[icObj.id].homeScale;

                  homeScale_new = {
                    X: original_homeScale.X / scaleFactor.X,
                    Y: original_homeScale.Y / scaleFactor.Y,
                  };

                  console.log("homeScale_new", homeScale_new);

                  const icObj_update = {
                    homeScale: homeScale_new,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new, icObj_update);

                  icObj.update(icObj_new, false);
                }


                //update position
                {

                  const activeSelectionCenterX = activeSelection.width / 2;
                  const activeSelectionCenterY = activeSelection.height / 2;

                  const fObj_pos_wrt_ASTL = {
                    left: activeSelectionCenterX + fObj.left,
                    top:  activeSelectionCenterY + fObj.top,
                  };

                  const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

                  const fObj_screenPos = {
                    x: activeSelection.left + scaleFactor.X * (Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left - Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
                    y: activeSelection.top  + scaleFactor.Y * (Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
                  };

                  const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.position, position_update);

                  icObj.update(icObj_new, false);

                }
              });

            }

            function handle_axis_scale(activeSelection) {

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                //update scale
                {
                  var scale_new;

                  const original_scale = original_props[icObj.id].scale;

                  scale_new = {
                    X: original_scale.X * scaleFactor.X,
                    Y: original_scale.Y * scaleFactor.Y,
                  };

                  console.log("scale_new", scale_new);

                  const icObj_update = {
                    scale: scale_new,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new, icObj_update);

                  icObj.update(icObj_new, false);
                }


                var fObj_sign = {
                  X:+1,
                  Y:+1
                };
                switch(options.originX) {
                  case "left":
                    fObj_sign.X = +1;
                    break;
                  case "right":
                    fObj_sign.X = -1;
                    break;
                }

                switch(options.originY) {
                  case "top":
                    fObj_sign.Y = +1;
                    break;
                  case "bottom":
                    fObj_sign.Y = -1;
                    break;
                }


                //update position
                {

                  const activeSelectionCenterX = fObj_sign.X * activeSelection.width / 2;
                  const activeSelectionCenterY = fObj_sign.Y * activeSelection.height / 2;

                  const fObj_pos_wrt_ASTL = {
                    left: activeSelectionCenterX + fObj_sign.X * fObj.left,
                    top:  activeSelectionCenterY + fObj_sign.Y * fObj.top,
                  };

                  const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

                  const fObj_screenPos = {
                    x: activeSelection.left + scaleFactor.X * (Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left - Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
                    y: activeSelection.top  + scaleFactor.Y * (Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
                  };

                  const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.position, position_update);

                  icObj.update(icObj_new, false);

                }

                //update flip
                {
                  const flip_update = {
                    X: (activeSelection.flipX != null) ? activeSelection.flipX : false,
                    Y: (activeSelection.flipY != null) ? activeSelection.flipY : false,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.flip, flip_update);

                  icObj.update(icObj_new, false);
                }

              });

            }


          }

          function activeSelection_scaled(activeSelection) {
            isScaling = false;
            original_props = {};
          }





          function activeSelection_rotating(options) {
            console.log("activeSelection rotating", options);

            const target   = options.transform.target;
            // const original = options.transform.original;

            const activeSelection = target;

            activeSelection.forEachObject((fObj, index, arr_fObj) => {
              const icObj = fObj.icObj;

              const activeSelectionCenterX = activeSelection.width / 2;
              const activeSelectionCenterY = activeSelection.height / 2;

              const fObj_pos_wrt_ASTL = {
                left: activeSelectionCenterX + fObj.left,
                top:  activeSelectionCenterY + fObj.top,
              };

              const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

              const fObj_screenPos = {
                x: activeSelection.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left - Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top,
                y: activeSelection.top  + Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top,
              };

              const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);




              const fObj_angle = target.angle + fObj.angle;
              const orientation_update = Geometry.boundedAngleInDegrees(fObj_angle + infiniteCanvas.orientation);

              const icObj_new = Object.assign({}, icObj);

              Object.assign(icObj_new.position, position_update);
              icObj_new.orientation = orientation_update;

              icObj.update(icObj_new, false);
            });

          }


        }







        addListeners(fObj) {

          fObj.on('modified', function(options) {
            console.log("modified", "options", options);
          });

        }



        // createFabricSampleObjectWithCanvasBoundingRect(canvasBoundingTrueRect) {
        //
        //   const trueRect = {
        //     left: canvasBoundingTrueRect.left,
        //     top:  canvasBoundingTrueRect.top,
        //     width:  50,
        //     height: 50,
        //   };
        //
        //   var fObj = new fabric.Rect();
        //   fObj.set({
        //     left:   trueRect.left,
        //     top:    trueRect.top,
        //     width:  trueRect.width,
        //     height: trueRect.height,
        //
        //     // fill: '#f55',
        //     fill: 'red',
        //     // opacity: 0.7,
        //
        //     trueRect : trueRect,
        //   });
        //
        //   //event listeners
        //
        //   fObj.on('moving', function(options) {
        //     console.log("moving", "options", options);
        //
        //     const target = options.target;
        //
        //     const trueRect_left__new = (target.left / scale - offset.dx);
        //     const trueRect_top__new  = (target.top  / scale - offset.dy);
        //
        //     const trueRect_update = {
        //       left: trueRect_left__new,
        //       top:  trueRect_top__new,
        //     };
        //
        //     Object.assign(target.trueRect, trueRect_update);
        //     Object.assign(.trueRect, trueRect_update);
        //
        //   });
        //
        //
        //   var isScaling = false;
        //   var original_trueRect = null;
        //   fObj.on('scaling', function(options) {
        //     console.log("scaling", "options", options);
        //     const original = options.transform.original;
        //
        //     const target   = options.transform.target;
        //
        //     if(!isScaling) {
        //       original_trueRect = Object.assign({}, target.trueRect);
        //       console.log("original_trueRect", original_trueRect);
        //       isScaling = true;
        //     }
        //
        //     const scaleFactorX = target.scaleX / original.scaleX;
        //     const scaleFactorY = target.scaleY / original.scaleY;
        //
        //     console.log("scaleFactorX", scaleFactorX);
        //
        //
        //     const trueRect_width__new  = (original_trueRect.width  * scaleFactorX);
        //     const trueRect_height__new = (original_trueRect.height * scaleFactorY);
        //
        //     console.log("trueRect_width__new", trueRect_width__new);
        //
        //     const trueRect_update = {
        //       width:  trueRect_width__new,
        //       height: trueRect_height__new,
        //     };
        //
        //     // Object.assign(target.trueRect, trueRect_update);
        //     Object.assign(fObj.trueRect, trueRect_update);
        //   });
        //   fObj.on('scaled', function(options) {
        //     console.log("scaled", "options", options);
        //     isScaling = false;
        //     original_trueRect = null;
        //
        //     const original = options.transform.original;
        //     const target   = options.transform.target;
        //
        //     target.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //
        //       //not used:
        //       // width:  target.trueRect.width  * scale,
        //       // height: target.trueRect.height * scale,
        //
        //       //used instead:
        //       width:  target.trueRect.width,
        //       height: target.trueRect.height,
        //
        //       scaleX : original.scaleX,
        //       scaleY : original.scaleY,
        //     });
        //     target.setCoords();
        //   });
        //
        //
        //   fObj.on('modified', function(options) {
        //     console.log("modified", "options", options);
        //   });
        //
        //   fObj.on('selected', function(options) {
        //     console.log("selected", "options", options);
        //     const activeObject   = this.infiniteCanvas.canvas.getActiveObject();
        //
        //     console.log("activeObject.trueRect", activeObject.trueRect);
        //     console.log("activeObject.scaleX", activeObject.scaleX);
        //     console.log("activeObject.scaleY", activeObject.scaleY);
        //
        //
        //   });
        //
        //   // fabric.util.addListener(canvas, 'object:modified', function (event, self) {
        //   //   console.log('object:modified', "event", event);
        //   //
        //   // });
        //
        //   return fObj;
        // }



        addOuterFabricObject(fObj) {
          console.log("addOuterFabricObject", fObj);

          const fabricIntegration = this;

          // this.outer_fabric_objects.push(fObj);
          fabricIntegration.fabric_objects.push(fObj);

          const icObj = fObj.icObj;
          fabricIntegration.fObjForIcObj_dict[icObj.id] = fObj;

          fabricIntegration.fabricCanvas.add(fObj);

        }

        // addPureOuterFabricObject(fObj) {
        //   console.log("addPureOuterFabricObject", fObj);
        //
        //   // this.outer_fabric_objects.push(fObj);
        //   this.fabric_objects__pure.push(fObj);
        //
        //   this.fabricCanvas.add(fObj);
        // }

        addInnerFabricObject(fObj) {
          console.log("addInnerFabricObject", fObj);

          // this.inner_fabric_objects.push(fObj);
          this.fabric_objects.push(fObj);

          this.fabricCanvas.add(fObj);
        }


        removeFabricObject(fObj) {
          console.log("removeFabricObject", fObj);

          /*
          //nuke
          // this.fabricCanvas.remove(...this.fabricCanvas.getObjects());
          this.fabricCanvas.remove(...this.fabric_objects);
          */

          console.log("this.fabric_objects.length", this.fabric_objects.length);
          {
            const fabric_objects_new =  Utils.arrayByRemovingElement(this.fabric_objects, fObj);

            this.setFabricObjects(fabric_objects_new);
          }
          console.log("this.fabric_objects.length", this.fabric_objects.length);


          console.log("this.fabric_objects", this.fabric_objects);


          // fObj.remove();
          this.fabricCanvas.remove(fObj);

          /*
          //antinuke
          this.fabricCanvas.add(...this.fabric_objects);
          */

          // console.log("this.fabricCanvas", this.fabricCanvas);
          // this.fabricCanvas.requestRenderAll();
        }


        deselectAll() {
          // this.fabricCanvas.deactivateAll();

          // this.fabricCanvas.discardActiveGroup();
          this.fabricCanvas.discardActiveObject();
          this.fabricCanvas.renderAll();
        }





        // debugFabric() {
        //
        //   const trueRect = {
        //     top:  100,
        //     left: 100,
        //     width: 20,
        //     height: 20,
        //   };
        //
        //   // create a rectangle object
        //   var fObj = new fabric.Rect({
        //     left: trueRect.left,
        //     top: trueRect.top,
        //     fill: 'red',
        //     width: trueRect.width,
        //     height: trueRect.height,
        //     trueRect : trueRect,
        //   });
        //
        //   this.addFabricObject(fObj);
        // }

        // updateFabricObjectsPosition(redrawOccasion) {
        //   console.log("updateFabricObjectsPosition", redrawOccasion);
        //
        //   const offset      = this.infiniteCanvas.offset;
        //   const scale       = this.infiniteCanvas.scale;
        //
        //   this.fabric_objects.forEach((fObj, i) => {
        //     //console.log("fObj A", fObj);
        //
        //     const icObj = fObj.icObj;
        //
        //     const truePos = {
        //       x: icObj.position.x  + offset.dx,
        //       y: icObj.position.y  + offset.dy,
        //     };
        //
        //     fObj.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //       left: truePos.x * scale.X,
        //       top:  truePos.y * scale.Y,
        //     });
        //
        //     // Object.assign(fObj.trueRect, truePos);
        //     fObj.setCoords();
        //
        //     //console.log("fObj B", fObj);
        //
        //   });
        // }

        updateFabricObjectsPosition(redrawOccasion) {

          switch(redrawOccasion) {
            case RedrawOccasion.scaleChanged:
              this.updateFabricObjectsPosition_zScroll(redrawOccasion);
              break;

            // case RedrawOccasion.orientationChanged:
            //   this.updateFabricObjectsPosition_rScroll();
            //   break;

            default:
              this.updateFabricObjectsPosition_default(redrawOccasion);
              break;
          }

        }

        updateFabricObjectsPosition_zScroll(redrawOccasion) {

          const activeObject = this.fabricCanvas.getActiveObject();

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          if(activeObject instanceof fabric.ActiveSelection) {

            const activeSelection = activeObject;

            this.updateFabricObject_position_zScroll__container(activeSelection);

            const arr_affected   = activeSelection.getObjects()
                                                  .filter(fObj => fObj.icObj.canBeMoved);

            const arr1 = fabric_objects;
            const arr2 = arr_affected;

            let difference = arr1.filter(x => !arr2.includes(x));
            const arr_unaffected = difference;

            arr_affected.forEach((fObj, i) => {
              this.updateFabricObject_position_zScroll__contained(activeSelection, fObj);
            });

            arr_unaffected.forEach((fObj, i) => {
              this.updateFabricObject_position_default(fObj);
            });

          } else {
            fabric_objects.forEach((fObj, i) => {

              if(fObj == activeObject) {
                this.updateFabricObject_position_zScroll__container(fObj);
              } else {
                this.updateFabricObject_position_default(fObj);
              }

            });
          }

        }

        // updateFabricObjectsPosition_rScroll(redrawOccasion) {
        //
        //   const activeObject = this.fabricCanvas.getActiveObject();
        //
        //   // const fabric_objects = this.fabric_objects;
        //   const fabric_objects = this.getFabricObjects();
        //
        //   fabric_objects.forEach((fObj, i) => {
        //
        //     if(fObj == activeObject) {
        //       this.updateFabricObject_position_rScroll(fObj);
        //     } else {
        //       this.updateFabricObject_position_default(fObj);
        //     }
        //
        //   });
        //
        // }


        updateFabricObjectsPosition_default(redrawOccasion) {

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          var fObjs_to_move = [];

          const activeObject = this.fabricCanvas.getActiveObject();
          if(activeObject instanceof fabric.ActiveSelection) {
            const activeSelection = activeObject;

            fObjs_to_move = [activeSelection];

            const arr_affected   = activeSelection.getObjects();

            const arr1 = fabric_objects;
            const arr2 = arr_affected;

            let difference = arr1.filter(x => !arr2.includes(x));
            const arr_unaffected = difference;

            fObjs_to_move.push(...arr_unaffected);

          } else {
            fObjs_to_move = [...fabric_objects];
          }

          fObjs_to_move.forEach((fObj, i) => {
            this.updateFabricObject_position_default(fObj);
          });

        }

        // updateFabricObject_position_rScroll(fObj) {
        //
        //   const infiniteCanvas = this.infiniteCanvas;
        //
        //   const offset      = infiniteCanvas.offset;
        //   const scale       = infiniteCanvas.scale;
        //
        //   const orientation = 0;
        //
        //   const orientationBaseVectors = infiniteCanvas.getOrientationBaseVectors();
        //
        //   // const origin = {
        //   //   x:0,
        //   //   y:0,
        //   // };
        //
        //   // const centerPoint = infiniteCanvas.getTrueCenterPoint();
        //   // console.log("centerPoint", centerPoint);
        //
        //   function compute_fObj_position_vector(icObj) {
        //
        //     const v1_no_orientation = {
        //       x: icObj.position.x,
        //       y: icObj.position.y,
        //     }
        //
        //     const v1_with_orientation = {
        //       x: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.u),
        //       y: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.v),
        //     };
        //
        //     const v1_with_orientation__with_offset = {
        //       x: v1_with_orientation.x + offset.dx,
        //       y: v1_with_orientation.y + offset.dy,
        //     };
        //
        //     const v1_with_orientation__with_offset__scaled = {
        //       x: v1_with_orientation__with_offset.x * scale.X,
        //       y: v1_with_orientation__with_offset.y * scale.Y,
        //     };
        //
        //     return v1_with_orientation__with_offset__scaled;
        //
        //   }
        //
        //
        //
        //   const icObj = fObj.icObj;
        //
        //   const v = compute_fObj_position_vector(icObj);
        //
        //   fObj.set({
        //     // x: x + offsetX,
        //     // y: y + offsetY,
        //     left: v.x,
        //     top:  v.y,
        //
        //     angle: icObj.orientation - orientation,
        //   });
        //
        //   // Object.assign(fObj.trueRect, truePos);
        //   fObj.setCoords();
        //
        // }

        updateFabricObject_position_zScroll__container(fObj) {
          console.log("updateFabricObject_position_zScroll__container", fObj);
          const infiniteCanvas = this.infiniteCanvas;

          const icObj = fObj.icObj;


          var position_update = null;

          const mouseIntegration = this.mouseIntegration;
          if(mouseIntegration.leftMouseDown) {
            // console.log("leftMouseDown zScroll");

            const cursor_truePoint = infiniteCanvas.getTrueCursor();
            //SHU: TODO: (later) prendre en compte le point grâce auquel on a attrapé l'objet (ce n'est pas le coin top left)
            position_update = cursor_truePoint;

          } else {
            // console.log("leftMouseUp zScroll");

            const fObj_screenPos = {
              x: fObj.left,
              y: fObj.top,
            };
            position_update = infiniteCanvas.toTruePoint(fObj_screenPos);
          }


          const icObj_new = Object.assign({}, icObj);
          Object.assign(icObj_new.position, position_update);

          icObj.update(icObj_new, false);

        }

        updateFabricObject_position_zScroll__contained(activeSelection, fObj) {
          console.log("updateFabricObject_position_zScroll", fObj);

          const scaleFactor = {
            X: activeSelection.scaleX,
            Y: activeSelection.scaleY,
          };

          //update position
          {
            const icObj = fObj.icObj;

            const activeSelectionCenterX = activeSelection.width / 2;
            const activeSelectionCenterY = activeSelection.height / 2;

            const fObj_pos_wrt_ASTL = {
              left: activeSelectionCenterX + fObj.left,
              top:  activeSelectionCenterY + fObj.top,
            };

            const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

            const fObj_screenPos = {
              x: activeSelection.left + scaleFactor.X * (Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left - Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
              y: activeSelection.top  + scaleFactor.Y * (Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
            };

            const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new.position, position_update);

            icObj.update(icObj_new, false);

          }

        }


        updateFabricObject_position_default(fObj) {
          console.log("updateFabricObject_position_default", fObj);

          //SHU: TODO: update fabric.Line object position
          if(fObj instanceof fabric.Line) {
            return;
          }

          // if(fObj.icObj.type == "sparkle") {
          //   return;
          // }


          const infiniteCanvas = this.infiniteCanvas;

          const offset      = infiniteCanvas.offset;
          const scale       = infiniteCanvas.scale;

          const orientation = infiniteCanvas.orientation;

          const orientationBaseVectors = infiniteCanvas.getOrientationBaseVectors();

          // const origin = {
          //   x:0,
          //   y:0,
          // };

          // const centerPoint = infiniteCanvas.getTrueCenterPoint();
          // console.log("centerPoint", centerPoint);

          function compute_fObj_position_vector(icObj) {

            const v1_no_orientation = {
              x: icObj.position.x,
              y: icObj.position.y,
            }

            const v1_with_orientation = {
              x: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.u),
              y: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.v),
            };

            const v1_with_orientation__with_offset = {
              x: v1_with_orientation.x + offset.dx,
              y: v1_with_orientation.y + offset.dy,
            };

            const v1_with_orientation__with_offset__scaled = {
              x: v1_with_orientation__with_offset.x * scale.X,
              y: v1_with_orientation__with_offset.y * scale.Y,
            };

            return v1_with_orientation__with_offset__scaled;

          }



          const icObj = fObj.icObj;

          const v = compute_fObj_position_vector(icObj);

          fObj.set({
            // x: x + offsetX,
            // y: y + offsetY,
            left: v.x,
            top:  v.y,

            angle: icObj.orientation - orientation,
          });

          // Object.assign(fObj.trueRect, truePos);
          fObj.setCoords();
        }






        updateFabricObjectsSize(redrawOccasion) {
          console.log("updateFabricObjectsSize", redrawOccasion);

          switch(redrawOccasion) {
            case RedrawOccasion.scaleChanged:
              this.updateFabricObjectsSize_zScroll();
              break;

            default:
              this.updateFabricObjectsSize_default();
              break;
          }

          // canvas.renderAll();
        }


        updateFabricObjectsSize_zScroll() {

          const activeObject = this.fabricCanvas.getActiveObject();

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          if(activeObject instanceof fabric.ActiveSelection) {

            const activeSelection = activeObject;

            this.updateFabricObject_size_zScroll(activeSelection);

            const arr_affected   = activeSelection.getObjects()
                                                  .filter(fObj => fObj.icObj.canBeMoved);


            const arr1 = fabric_objects;
            const arr2 = arr_affected;

            let difference = arr1.filter(x => !arr2.includes(x));
            const arr_unaffected = difference;

            arr_affected.forEach((fObj, i) => {
              this.updateFabricObject_size_zScroll(fObj);
            });

            arr_unaffected.forEach((fObj, i) => {
              this.updateFabricObject_size_default(fObj);
            });

          } else {
            fabric_objects.forEach((fObj, i) => {

              if(fObj == activeObject) {
                this.updateFabricObject_size_zScroll(fObj);
              } else {
                this.updateFabricObject_size_default(fObj);
              }

            });
          }



        }

        updateFabricObjectsSize_default() {
          console.log("updateFabricObjectsSize_default");

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          fabric_objects.forEach((fObj, i) => {
            this.updateFabricObject_size_default(fObj);
          });

        }



        updateFabricObject_size_zScroll(fObj) {
          console.log("updateFabricObject_size_zScroll", fObj);
          console.log("fObj.icObj", fObj.icObj);

          const scale  = this.infiniteCanvas.scale;

          // if(fObj instanceof fabric.ActiveSelection) {
            // updateActiveSelectionFObj_size_zScroll(fObj);
          // } else {
            updateStdFObj_size_zScroll(fObj);
          // }



          function updateStdFObj_size_zScroll(fObj) {
            console.log("updateFabricObject_size_zScroll", fObj);

            const scale_fObj = {
              X: fObj.scaleX,
              Y: fObj.scaleY,
            };
            console.log("scale_fObj", scale_fObj);

            const icObj = fObj.icObj;


            var homeScale_new;

            if(fObj instanceof fabric.Text) {

              const fontSize_fObj = fObj.fontSize;
              const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;

              // homeScale_new = {
              //   X: scale.X / scale_fObj.X / scaleFactor__fontSize,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

              homeScale_new = {
                X: scale.X / (scale_fObj.X / icObj.scale.X) / scaleFactor__fontSize,
                Y: scale.Y / (scale_fObj.Y / icObj.scale.Y) / scaleFactor__fontSize,
              };

            } else {

              // homeScale_new = {
              //   X: scale.X / scale_fObj.X,
              //   Y: scale.Y / scale_fObj.Y,
              // };

              homeScale_new = {
                X: scale.X / (scale_fObj.X / icObj.scale.X),
                Y: scale.Y / (scale_fObj.Y / icObj.scale.Y),
              };

            }
            console.log("homeScale_new", homeScale_new);

            const icObj_update = {
              homeScale: homeScale_new,
            };

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);

            icObj.update(icObj_new, false);

            // fObj.setCoords();

          }

          function updateActiveSelectionFObj_size_zScroll(activeSelection) {

            activeSelection.getObjects().forEach((fObj, i) => {
              updateStdFObj_size_zScroll(fObj);
            });


          }






        }

        updateFabricObject_size_default(fObj) {
          console.log("updateFabricObject_size_default", fObj);

          //SHU: TODO: update fabric.Line object position
          if(fObj instanceof fabric.Line) {
            return;
          }

          // if(fObj.icObj.type == "sparkle") {
          //   return;
          // }


          const scale  = this.infiniteCanvas.scale;
          console.log("scale", scale);

          console.log("scale.X", scale.X);
          console.log("fObj.icObj.homeScale.X", fObj.icObj.homeScale.X);

          const scaleFactorX = scale.X / fObj.icObj.homeScale.X;
          const scaleFactorY = scale.Y / fObj.icObj.homeScale.Y;

          const scaleFactor = {
            X: scaleFactorX,
            Y: scaleFactorY,
          };

          console.log("scaleFactorX", scaleFactorX);



          if(fObj instanceof fabric.Text) {

            // const fontSize = fObj.true_fontSize * scale;
            // const fontSize = fObj.icObj.fontSize * scale.X;
            const fontSize = fObj.icObj.fontSize * scaleFactor.X;

            console.log("fontSize", fontSize);
            // fObj.set({
            //   fontSize: fontSize,
            // });

            const fontSize_max = 10000;
            // if(fontSize > fontSize_max) {
            //
            //   const scaleAmount_fix = (fontSize - fontSize_max) / fontSize_max;
            //   const scale_fix = 1.0 * (1 + scaleAmount_fix);
            //   console.log("scale_fix", scale_fix);
            //
            //   fObj.set({
            //     fontSize: fontSize_max,
            //
            //     scaleX: scale_fix,
            //     scaleY: scale_fix,
            //   });
            //
            // } else {
            //   fObj.set({
            //     fontSize: fontSize,
            //
            //     scaleX: 1,
            //     scaleY: 1,
            //   });
            // }

            function scaleWithTargetFontSize(targetFontSize) {

              const scaleAmount_fix = (fontSize - targetFontSize) / targetFontSize;
              const scale_fix = {
                X: fObj.icObj.scale.X * (1 + scaleAmount_fix),
                Y: fObj.icObj.scale.Y * (1 + scaleAmount_fix),
              };
              console.log("scale_fix", scale_fix);

              fObj.set({
                fontSize: targetFontSize,

                scaleX: scale_fix.X,
                scaleY: scale_fix.Y,
              });

            }

            if(fontSize > fontSize_max) {

              scaleWithTargetFontSize(fontSize_max);

            } else {
              // fObj.set({
              //   fontSize: fontSize,
              //
              //   scaleX: fObj.icObj.scale.X,
              //   scaleY: fObj.icObj.scale.Y,
              // });

              const closestIntegerFontSize = Math.max(1, Math.floor(fontSize));

              scaleWithTargetFontSize(closestIntegerFontSize);

            }



          }
          // else if(fObj instanceof fabric.Image) {
          //
          //   // fObj.scale(scale);
          //
          //   const width  = fObj.icObj.img.width  * scale.X;
          //   const height = fObj.icObj.img.height * scale.Y;
          //
          //   fObj.scaleToWidth(width);
          //   fObj.scaleToHeight(height);
          //
          // } else if(fObj instanceof fabric.Rect) {
          else {

            console.log("fObj", fObj);
            fObj.set({
              scaleX: fObj.icObj.scale.X * scaleFactor.X,
              scaleY: fObj.icObj.scale.Y * scaleFactor.Y,
            });

          }
          // else {
          //   console.log("unknown instance type");
          // }

          fObj.setCoords();

        }






        updateIcObjWithFObj(fObj) {
          console.log("updateIcObjWithFObj", fObj);

          const offset = this.infiniteCanvas.offset;
          const scale  = this.infiniteCanvas.scale;
          console.log("scale", scale);


          const trueRect_update = {
            left:  fObj.left / scale.X - offset.dx,
            top:   fObj.top  / scale.Y - offset.dy,

            width:  fObj.width  / scale.X,
            height: fObj.height / scale.Y,
          };

          const icObj_update = {
            position: Geometry.createPoint(trueRect_update.left, trueRect_update.top),
            size:     Geometry.createSize(trueRect_update.width, trueRect_update.height),
          };

          const icObj = fObj.icObj;

          const icObj_new = Object.assign({}, icObj);
          Object.assign(icObj_new, icObj_update);

          console.log("icObj_new", icObj_new);

          icObj.update(icObj_new, false);

        }









        //free drawing

        initializeFreeDrawing() {

          // this.fabricCanvas.isDrawingMode = true;

          if (fabric.PatternBrush) {
              var vLinePatternBrush = new fabric.PatternBrush(canvas);
              vLinePatternBrush.getPatternSrc = function() {

                var patternCanvas = fabric.document.createElement('canvas');
                patternCanvas.width = patternCanvas.height = 10;
                var ctx = patternCanvas.getContext('2d');

                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(0, 5);
                ctx.lineTo(10, 5);
                ctx.closePath();
                ctx.stroke();

                return patternCanvas;
              };

              var hLinePatternBrush = new fabric.PatternBrush(canvas);
              hLinePatternBrush.getPatternSrc = function() {

                var patternCanvas = fabric.document.createElement('canvas');
                patternCanvas.width = patternCanvas.height = 10;
                var ctx = patternCanvas.getContext('2d');

                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(5, 0);
                ctx.lineTo(5, 10);
                ctx.closePath();
                ctx.stroke();

                return patternCanvas;
              };

              var squarePatternBrush = new fabric.PatternBrush(canvas);
              squarePatternBrush.getPatternSrc = function() {

                var squareWidth = 10, squareDistance = 2;

                var patternCanvas = fabric.document.createElement('canvas');
                patternCanvas.width = patternCanvas.height = squareWidth + squareDistance;
                var ctx = patternCanvas.getContext('2d');

                ctx.fillStyle = this.color;
                ctx.fillRect(0, 0, squareWidth, squareWidth);

                return patternCanvas;
              };

              var diamondPatternBrush = new fabric.PatternBrush(canvas);
              diamondPatternBrush.getPatternSrc = function() {

                var squareWidth = 10, squareDistance = 5;
                var patternCanvas = fabric.document.createElement('canvas');
                var rect = new fabric.Rect({
                  width: squareWidth,
                  height: squareWidth,
                  angle: 45,
                  fill: this.color
                });

                var canvasWidth = rect.getBoundingRect().width;

                patternCanvas.width = patternCanvas.height = canvasWidth + squareDistance;
                rect.set({ left: canvasWidth / 2, top: canvasWidth / 2 });

                var ctx = patternCanvas.getContext('2d');
                rect.render(ctx);

                return patternCanvas;
              };

              // var img = new Image();
              // img.src = 'img/sparkle_gradient.png';
              //
              // var texturePatternBrush = new fabric.PatternBrush(canvas);
              // texturePatternBrush.source = img;
            }

        }


        enterFreeDrawing() {
          const fabricIntegration = this;

          const brush = this.fabricCanvas.freeDrawingBrush;

          brush.width = 20;

          const rgbColor = this.inputProperties.getActiveColor();
          const opacity  = this.inputProperties.getActiveOpacity();
          const rgbaColorString = this.inputProperties.getActiveRgbaColorString();

          // brush.color   = this.inputProperties.getActiveColor();
          brush.color = rgbaColorString;

          this.fabricCanvas.isDrawingMode = true;

          this.current_freeDrawing_objects = [];
          function freeDrawing_objectAdded(e) {
            console.log("freeDrawing_objectAdded",e);

            const fObj = e.target;
            fObj.set({
              stroke:  rgbColor,
              opacity: opacity,
            });

            fabricIntegration.current_freeDrawing_objects.push(e.target);
            // console.log("fabricIntegration.current_freeDrawing_objects", fabricIntegration.current_freeDrawing_objects);
          }

          this.freeDrawing_objectAdded = freeDrawing_objectAdded;
          this.fabricCanvas.on('object:added', this.freeDrawing_objectAdded);

        }

        leaveFreeDrawing() {
          this.fabricCanvas.isDrawingMode = false;
          this.fabricCanvas.off('object:added', this.freeDrawing_objectAdded);

          //get newly created fabric objects
          // var last = canvas_objects[canvas_objects.length -1]; //Get last object
          const freeDrawing_objects_created = [...this.current_freeDrawing_objects];
          this.current_freeDrawing_objects = [];

          this.manageCreatedFreeDrawingObjects(freeDrawing_objects_created);

        }

        manageCreatedFreeDrawingObjects(arr_fObj) {
          console.log("manageCreatedFreeDrawingObjects", arr_fObj);

          //group newly created fabric objects (or not (for easy delete))

          //create icObj from fObj
          arr_fObj.forEach((fObj) => {
            const icObj = this.infiniteCanvas.createIcFreeDrawing_from_freeDrawingFObj(fObj);
            this.infiniteCanvas.addNewIcObject(icObj);

            //SHU: HERE WE COULD HAVE RECYCLED ALREADY CREATED FOBJ AND AVOID RECREATING A NEW ONE
            this.fabricCanvas.remove(fObj);
          });

        }






        deleteSelection() {
          const fabricIntegration = this;

          const fObj = this.fabricCanvas.getActiveObject();

          function deleteFObj(fObj_to_delete) {
            const icObj = fObj_to_delete.icObj;
            icObj.delete_p()
            .then(() => {
              fabricIntegration.removeFabricObject(fObj_to_delete);
              icObj.im_dying_now = false;
              icObj.im_dead_now  = true;
            })
            .catch(err => {
              console.log("fObj.icObj.delete_p", "error", err);
            });
          }

          if(fObj instanceof fabric.ActiveSelection) {

            fObj.getObjects().forEach((fObj, i) => {
              deleteFObj(fObj);
            });

            this.fabricCanvas.discardActiveObject();
            this.fabricCanvas.requestRenderAll();

          } else {

            deleteFObj(fObj);

          }


        }


        shouldIgnoreShortcutInput() {
          var outBool;

          const fObj = this.fabricCanvas.getActiveObject();
          if(fObj) {
            outBool = fObj.isEditing;
          } else {
            outBool = false;
          }

          return outBool;
        }




        initializeFabricObjectCopyCut() {
          const fabricIntegration = this;

          const legacyOnCopyFunc = document.oncopy;
          document.oncopy = function(event) {

            if(legacyOnCopyFunc) {
              legacyOnCopyFunc(event);
            }

            fabricIntegration.copySelection(event);
          };

          const legacyOnCutFunc = document.oncut;
          document.oncut = function(event) {

            if(legacyOnCutFunc) {
              legacyOnCutFunc(event);
            }

            fabricIntegration.cutSelection(event);
          };

        }

        copySelection(event) {
          console.log("copySelection", event);

          const clipboardIntegration = this.clipboardIntegration;
          // this.fabricCanvas.getActiveObject().clone(function(cloned) {
          //   clipboardIntegration.manageInnerCopy("fabric.general", cloned);
          // });
          const icObj = this.fabricCanvas.getActiveObject().icObj;
          const cloned = icObj.deepClone();
          cloned.position.x += 10;
          cloned.position.y += 10;

          clipboardIntegration.manageInnerCopy("fabric.general", cloned);
        }

        cutSelection(event) {
          console.log("cutSelection", event);

          //copy
          this.copySelection(event);

          //remove object
          const icObj = this.fabricCanvas.getActiveObject().icObj;
          // const fObj  = this.fabricCanvas.getActiveObject();

          const infiniteCanvas = this.infiniteCanvas;
          infiniteCanvas.removeIcObject(icObj);
        }


        setAntiAliasEnabled(enabled) {
          console.log("setAntiAliasEnabled", enabled);
          this.fabricCanvas.imageSmoothingEnabled = enabled;
          this.fabricCanvas.requestRenderAll();
        }




        //Groups

        groupSelectedObjects() {

          //get selected objects
          const canvas = this.fabricCanvas;

          if (!canvas.getActiveObject()) {
            return;
          }
          if (canvas.getActiveObject().type !== 'activeSelection') {
            return;
          }

          const activeSelection = canvas.getActiveObject();
          console.log("activeSelection to create group", activeSelection);

          const fObj = canvas.getActiveObject().toGroup();
          console.log("fabric created group", fObj);

          // const fObj_childObjects = fObj.getObjects();
          // console.log("fObj_childObjects", fObj_childObjects);

          const icObj = infiniteCanvas.createIcGroup_from_groupFObj(fObj);
          fObj.icObj = icObj;

          //debug
          // const fRect = new fabric.Rect();
          // fRect.set({
          //   left:   fObj.left,
          //   top:    fObj.top,
          //   width:  fObj.width,
          //   height: fObj.height,
          //
          //   fill: 'red',
          // });
          // this.fabricCanvas.add(fRect);

          {
            const fRect = new fabric.Rect();

            const trueRect  = infiniteCanvas.toTrueRect(fObj);
            const position  = Geometry.getPointTL(trueRect);
            const size      = Geometry.createSize(trueRect.width, trueRect.height);

            const homeScale = Object.assign({}, infiniteCanvas.scale);

            const type = "rect";
            const icObj = infiniteCanvas.createIcObject(type, position, size, homeScale);

            const position_screen = icObj.getScreenPositionWithoutOffset();
            // console.log("position_screen", position_screen);
            const homeSize_screen = icObj.getHomeScreenSize();
            // console.log("homeSize_screen", homeSize_screen);

            fRect.set({
              left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
              top:    position_screen.y,

              width:  homeSize_screen.width,
              height: homeSize_screen.height,

              fill: 'red',
            });

            this.fabricCanvas.add(fRect);
          }



          //test pour le moment
          // this.fabricCanvas.remove(fObj);



          icObj.children.forEach((child_icObj, i) => {
            infiniteCanvas.removeIcObject(child_icObj);
          });
          infiniteCanvas.addIcObject(icObj);


          canvas.requestRenderAll();

        }

        ungroupSelectedObject() {

          const canvas = this.fabricCanvas;

          if (!canvas.getActiveObject()) {
            return;
          }
          if (canvas.getActiveObject().type != 'group') {
            return;
          }
          canvas.getActiveObject().toActiveSelection();
          canvas.requestRenderAll();

        }


        //Composites

        composeSelectedObjects() {
          console.log("composeSelectedObjects");
          const infiniteCanvas = this.infiniteCanvas;

          //get selected objects
          const canvas = this.fabricCanvas;

          const activeObject = canvas.getActiveObject();
          if (activeObject == null) {
            return;
          }
          if(activeObject.type != 'activeSelection') {
            console.log("can only compose objects from an activeSelection");
            return;
          }

          const activeSelection = activeObject;
          console.log("activeSelection", activeSelection);

          const arr_fObj = activeSelection.getObjects();

          this.deselectAll();



          const arr_topLevelFObj = arr_fObj.filter(fObj => {
            const isTopLevelObj = !fObj.icObj.isCompositePart;
            return isTopLevelObj;
          });

          const arr_topLevelIcObj = arr_topLevelFObj.map((fObj, i) => {
            return fObj.icObj;
          });

          infiniteCanvas.compose(arr_topLevelIcObj);


          // this.deselectAll();
          // canvas.renderAll();

        }

        decomposeSelectedObject() {
          console.log("decomposeSelectedObject");
          const infiniteCanvas = this.infiniteCanvas;

          const canvas = this.fabricCanvas;

          var icObj_composite;

          const activeObject = canvas.getActiveObject();
          if (activeObject.type == 'activeSelection') {
            const activeSelection = activeObject;
            const arr_fObj = activeSelection.getObjects();
            const arr_icObj = arr_fObj.map((fObj, i) => {
              return fObj.icObj;
            });
            icObj_composite = arr_icObj.find(icObj => (icObj.type == "composite"));

          } else if (activeObject != null) {
            const fObj  = activeObject;
            const icObj = fObj.icObj;
            if(icObj.type == "composite") {
              icObj_composite = icObj;
            }
          }

          if(icObj_composite != null) {
            this.deselectAll();
            infiniteCanvas.decompose(icObj_composite);
          }

        }








        syncWithIcObj(icObj) {
          const fObj = this.getFObjForIcObj(icObj);
          this.updateFObjWithIcObj(fObj, icObj);

          this.fabricCanvas.requestRenderAll();
          // this.fabricCanvas.renderAll();
        }

        getFObjForIcObj(icObj) {
          const fObj = this.fObjForIcObj_dict[icObj.id];

          if(!fObj) {
            console.log("icObj", icObj);
            console.log("this.fObjForIcObj_dict", this.fObjForIcObj_dict);
            throw new Error("fObj not found for icObj.id: "+ icObj.id);
          }

          return fObj;
        }

        updateFObjWithIcObj(fObj, icObj) {
          console.log("updateFObjWithIcObj", fObj, icObj);

          function configureWithIsActive(fObj, isActive) {

            const cfg = isActive ? fObj.icObj.activeCfg : fObj.icObj.inactiveCfg;

            fObj.set({
              fill:    cfg.fill,
              opacity: cfg.opacity,
            });

            fObj.set("dirty", true);
          }

          configureWithIsActive(fObj, icObj.isActive);

          // fObj.setCoords();
        }


      }


















/*******************/


      class Geometry {

        static createPoint(x, y) {
          const point = {
            x : x,
            y : y,
          };
          return point;
        }

        static createRect(x,y,w,h) {
          const rect = {
            left: x,
            top: y,
            width: w,
            height: h,
          };
          return rect;
        }



        static createLine(point0, point1) {
          const line = {
            x0 : point0.x,
            y0 : point0.y,

            x1 : point1.x,
            y1 : point1.y,
          }
          return line;
        }

        static createTriangle() {
          const pointA = Geometry.createPoint(100,100);
          const pointB = Geometry.createPoint(0,300);
          const pointC = Geometry.createPoint(-100, -200);

          const lineAB = Geometry.createLine(pointA, pointB);
          const lineAC = Geometry.createLine(pointA, pointC);
          const lineBC = Geometry.createLine(pointB, pointC);

          const lines = [lineAB, lineAC, lineBC];
          return lines;
        }

        static createAxes() {
          const length = 10000;

          const pointX0 = Geometry.createPoint(     0,0);
          const pointX1 = Geometry.createPoint(length,0);
          const lineX   = Geometry.createLine(pointX0, pointX1);

          const pointY0 = Geometry.createPoint(0,0);
          const pointY1 = Geometry.createPoint(0,length);
          const lineY   = Geometry.createLine(pointY0, pointY1);

          const lines = [lineX, lineY];
          return lines;
        }



        static createSize(width, height) {
          const size = {
            width  : width,
            height : height,
          };
          return size;
        }



        static rectForRectRel(rect, rect_rel) {
          var outRect;

          outRect = {
            x:       rect.x + rect_rel.l * rect.width,
            y:       rect.y + rect_rel.t * rect.height,
            width:   (rect_rel.r - rect_rel.l) * rect.width,
            height:  (rect_rel.b - rect_rel.t) * rect.height,
          };

          return outRect;
        }




        static containedRect(containerRect, size) {
          var outRect;

          const containerSize = {
            width:  containerRect.width,
            height: containerRect.height,
          };
          const containedSize_ = Geometry.containedSize(containerSize, size);


          const center  = Geometry.getCenterPoint(containerRect);
          const offset  = {
            dx: - containedSize_.width /2,
            dy: - containedSize_.height /2,
          };
          const pointTL = Geometry.createPointWithOffset(center, offset);


          outRect = createRect(pointTL.x, pointTL.y, containedSize_.width, containedSize_.height);
          return outRect;
        }

        static getPointTL(rect) {
          const pointTL = Geometry.createPoint(rect.left, rect.top);
          return pointTL;
        }

        static getPointBR(rect) {
          const pointBR = Geometry.createPoint(rect.left + rect.width, rect.top + rect.height);
          return pointBR;
        }

        static getCenterPoint(rect) {
          const pointTL = Geometry.getPointTL(rect);
          const offset = {
            dx: rect.width /2,
            dy: rect.height /2,
          };
          return Geometry.createPointWithOffset(pointTL, offset);
        }

        static createPointWithOffset(point, offset) {
          return Geometry.createPoint(point.x + offset.dx, point.y + offset.dy);
        }

        static containedSize(containerSize, size) {
          var outSize;

          const size_ratio__container = containerSize.width / containerSize.height;
          const size_ratio__rect      = size.width / size.height;

          //console.log("size_ratio__container", size_ratio__container);
          //console.log("size_ratio__rect", size_ratio__rect);


          var scaleFactor;
          if(size_ratio__container > size_ratio__rect) {
            scaleFactor = containerSize.height / size.height;
          } else {
            scaleFactor = containerSize.width / size.width;
          }

          //console.log("scaleFactor", scaleFactor);


          outSize = {
            width:  size.width  * scaleFactor,
            height: size.height * scaleFactor,
          }

          return outSize;
        }



        static dotProduct_2d(v1,v2) {
        	return v1.x * v2.x + v1.y * v2.y;
        }

        static norm_2d(v1) {
          return Math.sqrt(Geometry.dotProduct_2d(v1,v1));
        }

        static vector_3d(v1, z = 0) {
          return {
            x: v1.x,
            y: v1.y,
            z: z,
          };
        }

        static dotProduct_3d(v1,v2) {
        	return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
        }

        static crossProduct_3d(v1,v2) {
        	return {
        		x: v1.y * v2.z - v1.z * v2.y,
        		y: v1.z * v2.x - v1.x * v2.z,
        		z: v1.x * v2.y - v1.y * v2.x,
        	};
        }

        static boundedAngleInDegrees(angleInDegrees) {

          var angleInDegrees_bounded = angleInDegrees;

          angleInDegrees_bounded = angleInDegrees_bounded % 360;
          if(angleInDegrees_bounded < 0) {
            angleInDegrees_bounded += 360;
          }

          return angleInDegrees_bounded;
        }

        static pointWithRotation(point_from, point_center, angleInDegrees) {
          console.log("pointWithRotation", point_from, point_center, angleInDegrees);

          const v = {
            x: point_from.x - point_center.x,
            y: point_from.y - point_center.y,
          };
          console.log("v.x", v.x);
          console.log("v.y", v.y);

          // const radius = Geometry.norm_2d(v);

          const angleInRadians = angleInDegrees / 180 * Math.PI;

          const dx = Math.cos(angleInRadians) * v.x - Math.sin(angleInRadians) * v.y;
          const dy = Math.sin(angleInRadians) * v.x + Math.cos(angleInRadians) * v.y;
          console.log("dx", dx);
          console.log("dy", dy);


          const point_to = {
            x: point_center.x + dx,
            y: point_center.y + dy,
          };


          return point_to;
        }

        static getPointFromRectToRect(point_from, rect_from, rect_to) {
          const point_to = {
            x: point_from.x * ( rect_to.width /  rect_from.width),
            y: point_from.y * (rect_to.height / rect_from.height),
          };

          return point_to;
        }


        static createLRTBRect(rect) {
          const lrtb = {
            left:    rect.left,
            right:   rect.left + rect.width,
            top:     rect.top,
            bottom:  rect.top + rect.height,
          };
          return lrtb;
        }

        static intersectRect(rect1, rect2) {

          const r1 = this.createLRTBRect(rect1);
          console.log("r1", r1);
          const r2 = this.createLRTBRect(rect2);
          console.log("r2", r2);

          return !(r2.left > r1.right ||
                   r2.right < r1.left ||
                   r2.top > r1.bottom ||
                   r2.bottom < r1.top);
         }



         static distance(p1,p2) {
           const v = {
             x: p2.x - p1.x,
             y: p2.y - p1.y,
           };

           const norm = this.norm_2d(v);

           return norm;
         }

      }


      const SnapState = {
        "Unsnapped"  : "Unsnapped",
        "Presnapped" : "Presnapped",
        "Snapped"    : "Snapped",
      };

      class Snap { //GeometryWise snapping

        static canSnap(icObj_over, icObj_below) { //SHU: what would be nice would be to use the norm of a transformation matrix to settle threshold
          // const ratio__position        = {
          //   x:  (icObj_over.position.x - icObj_below.position.x) / icObj_below.position.x,
          //   y:  (icObj_over.position.y - icObj_below.position.y) / icObj_below.position.y,
          // };
          // console.log("ratio__position", ratio__position);
          // if(!(Math.abs(ratio__position.x) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__position.y) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__size        = {
          //   width:  (icObj_over.size.width  - icObj_below.size.width)  / icObj_below.size.width,
          //   height: (icObj_over.size.height - icObj_below.size.height) / icObj_below.size.height,
          // };
          // console.log("ratio__size", ratio__size);
          // if(!(Math.abs(ratio__size.width) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__size.height) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__orientation = (icObj_over.orientation - icObj_below.orientation) / icObj_below.orientation;
          // console.log("ratio__orientation", ratio__orientation);
          // if(!(Math.abs(ratio__orientation) < 0.10)) {
          //   return false;
          // }


          //snapping params:
          // const snapping_params = {
          //   // position: {
          //   //   x: 0.10,
          //   //   y: 0.10,
          //   // },
          //   position: {
          //     x: 0.05,
          //     y: 0.05,
          //   },
          //   size: {
          //     width:  0.05,
          //     height: 0.05,
          //   },
          //   homeScale: {
          //
          //   },
          //   orientation: {
          //     orientation: 0.05,
          //   },
          // };

          const snapping_params = {
            // position: {
            //   x: 0.10,
            //   y: 0.10,
            // },
            position: {
              x: 0.50,
              y: 0.50,
            },
            size: {
              width:  0.05,
              height: 0.05,
            },
            // homeScale: {
            //   X:  0.05,
            //   Y:  0.05,
            // },
            orientation: {
              orientation: 0.05,
            },
          };


          //SHU TODO: a nice and complex canSnapFunc
          const canSnapFunc = (icObj_over, icObj_below) => {

          };


          // const unsamenessRatio__position = {
          //   x:  Snap.unsamenessRatio(icObj_over.position.x, icObj_below.position.x),
          //   y:  Snap.unsamenessRatio(icObj_over.position.y, icObj_below.position.y),
          // };
          // if(unsamenessRatio__position.x > snapping_params.position.x) {
          //   return false;
          // }
          // if(unsamenessRatio__position.y > snapping_params.position.y) {
          //   return false;
          // }

          const distance = Geometry.distance(icObj_over.position, icObj_below.position);
          console.log("distance", distance);
          if(distance > 200) {
            return false;
          }

          /*
          const unsamenessRatio__size = {
            width:  Snap.unsamenessRatio(icObj_over.size.width,  icObj_below.size.width),
            height: Snap.unsamenessRatio(icObj_over.size.height, icObj_below.size.height),
          };
          console.log("°°unsamenessRatio__size.width",  unsamenessRatio__size.width);
          console.log("°°icObj_over.size.width",  icObj_over.size.width);
          console.log("°°icObj_below.size.width",  icObj_below.size.width);

          console.log("°°unsamenessRatio__size.height", unsamenessRatio__size.height);
          console.log("°°icObj_over.size.height",  icObj_over.size.height);
          console.log("°°icObj_below.size.height",  icObj_below.size.height);

          if(unsamenessRatio__size.width > snapping_params.size.width) {
            return false;
          }
          if(unsamenessRatio__size.height > snapping_params.size.height) {
            return false;
          }

          const icObj_over__zero_centered_orientation  = (icObj_over.orientation > 180 ? icObj_over.orientation - 180 : icObj_over.orientation);
          const icObj_below__zero_centered_orientation = (icObj_below.orientation > 180 ? icObj_below.orientation - 180 : icObj_below.orientation);

          const unsamenessRatio__orientation = {
            // orientation: Snap.unsamenessRatio(icObj_over.orientation,  icObj_below.orientation),
            // orientation: Math.abs((icObj_over.orientation - icObj_below.orientation) / 360.0),
            orientation: Snap.unsamenessRatio(icObj_over__zero_centered_orientation,  icObj_below__zero_centered_orientation),
          };
          console.log("unsamenessRatio__orientation.orientation", unsamenessRatio__orientation.orientation);
          if(unsamenessRatio__orientation.orientation > snapping_params.orientation.orientation) {
            return false;
          }
          */

          return true;
        }

        static canSnap_noSize(icObj_over, icObj_below) {

          const snapping_params = {
            // position: {
            //   x: 0.10,
            //   y: 0.10,
            // },
            position: {
              x: 0.50,
              y: 0.50,
            },
            // size: {
            //   width:  0.05,
            //   height: 0.05,
            // },
            // homeScale: {
            //   X:  0.05,
            //   Y:  0.05,
            // },
            orientation: {
              orientation: 0.05,
            },
          };


          //SHU TODO: a nice and complex canSnapFunc
          const canSnapFunc = (icObj_over, icObj_below) => {

          };


          const unsamenessRatio__position = {
            x:  Snap.unsamenessRatio(icObj_over.position.x, icObj_below.position.x),
            y:  Snap.unsamenessRatio(icObj_over.position.y, icObj_below.position.y),
          };
          if(unsamenessRatio__position.x > snapping_params.position.x) {
            return false;
          }
          if(unsamenessRatio__position.y > snapping_params.position.y) {
            return false;
          }

          // const unsamenessRatio__size = {
          //   width:  Snap.unsamenessRatio(icObj_over.size.width,  icObj_below.size.width),
          //   height: Snap.unsamenessRatio(icObj_over.size.height, icObj_below.size.height),
          // };
          // console.log("°°unsamenessRatio__size.width",  unsamenessRatio__size.width);
          // console.log("°°icObj_over.size.width",  icObj_over.size.width);
          // console.log("°°icObj_below.size.width",  icObj_below.size.width);
          //
          // console.log("°°unsamenessRatio__size.height", unsamenessRatio__size.height);
          // console.log("°°icObj_over.size.height",  icObj_over.size.height);
          // console.log("°°icObj_below.size.height",  icObj_below.size.height);
          //
          // if(unsamenessRatio__size.width > snapping_params.size.width) {
          //   return false;
          // }
          // if(unsamenessRatio__size.height > snapping_params.size.height) {
          //   return false;
          // }

          const icObj_over__zero_centered_orientation  = (icObj_over.orientation > 180 ? icObj_over.orientation - 180 : icObj_over.orientation);
          const icObj_below__zero_centered_orientation = (icObj_below.orientation > 180 ? icObj_below.orientation - 180 : icObj_below.orientation);

          const unsamenessRatio__orientation = {
            // orientation: Snap.unsamenessRatio(icObj_over.orientation,  icObj_below.orientation),
            // orientation: Math.abs((icObj_over.orientation - icObj_below.orientation) / 360.0),
            orientation: Snap.unsamenessRatio(icObj_over__zero_centered_orientation,  icObj_below__zero_centered_orientation),
          };
          console.log("unsamenessRatio__orientation.orientation", unsamenessRatio__orientation.orientation);
          if(unsamenessRatio__orientation.orientation > snapping_params.orientation.orientation) {
            return false;
          }

          return true;
        }


        static canUnsnap(icObj_over, icObj_below) {
          return !this.canSnap(icObj_over, icObj_below);
        }

        /*
        static canUnsnap(icObj_over, icObj_below) { //SHU: what would be nice would be to use the norm of a transformation matrix to settle threshold
          // const ratio__position        = {
          //   x:  (icObj_over.position.x - icObj_below.position.x) / icObj_below.position.x,
          //   y:  (icObj_over.position.y - icObj_below.position.y) / icObj_below.position.y,
          // };
          // console.log("ratio__position", ratio__position);
          // if(!(Math.abs(ratio__position.x) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__position.y) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__size        = {
          //   width:  (icObj_over.size.width  - icObj_below.size.width)  / icObj_below.size.width,
          //   height: (icObj_over.size.height - icObj_below.size.height) / icObj_below.size.height,
          // };
          // console.log("ratio__size", ratio__size);
          // if(!(Math.abs(ratio__size.width) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__size.height) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__orientation = (icObj_over.orientation - icObj_below.orientation) / icObj_below.orientation;
          // console.log("ratio__orientation", ratio__orientation);
          // if(!(Math.abs(ratio__orientation) < 0.10)) {
          //   return false;
          // }


          //snapping params:
          const unsnapping_params = {
            // position: {
            //   x: 0.10,
            //   y: 0.10,
            // },
            position: {
              x: 0.10,
              y: 0.10,
            },
            size: {
              width:  0.10,
              height: 0.10,
            },
            orientation: {
              orientation: 0.10,
            },
          };

          // //SHU TODO: a nice and complex canUnsnapFunc
          // const canUnsnapFunc = (icObj_over, icObj_below) => {
          //
          // };


          const unsamenessRatio__position = {
            x:  Snap.unsamenessRatio(icObj_over.position.x, icObj_below.position.x),
            y:  Snap.unsamenessRatio(icObj_over.position.y, icObj_below.position.y),
          };
          if(unsamenessRatio__position.x < unsnapping_params.position.x) {
            return false;
          }
          if(unsamenessRatio__position.y < unsnapping_params.position.y) {
            return false;
          }

          const unsamenessRatio__size = {
            width:  Snap.unsamenessRatio(icObj_over.size.width,  icObj_below.size.width),
            height: Snap.unsamenessRatio(icObj_over.size.height, icObj_below.size.height),
          };
          if(unsamenessRatio__size.width < unsnapping_params.size.width) {
            return false;
          }
          if(unsamenessRatio__size.height < unsnapping_params.size.height) {
            return false;
          }

          const unsamenessRatio__orientation = {
            orientation: Snap.unsamenessRatio(icObj_over.orientation,  icObj_below.orientation),
          };
          if(unsamenessRatio__orientation.orientation < unsnapping_params.orientation.orientation) {
            return false;
          }

          return true;
        }
        */



        static unsamenessRatio(nb1, nb2) {
          var outNumber;
          outNumber = (nb1 - nb2);
          // if(outNumber != 0) {
          if(nb2 != 0) {
            outNumber = outNumber / nb2;
          }
          outNumber = Math.abs(outNumber);
          return outNumber;
        }

        static snapAnimation(icObj_over, icObj2_below) {

        }



        static defaultSnapEngine(infiniteCanvas, icSnapSlot) {
          var outSnapEngine;

          const canSnapFunc = (above, below) => {
            return Snap.canSnap(above, below);
          };

          const canUnsnapFunc = (above, below) => {
            return Snap.canUnsnap(above, below);
          };

          // const snapEngine = {
          //   canSnapFunc:   canSnapFunc,
          //   canUnsnapFunc: canUnsnapFunc,
          // };
          //
          // outSnapEngine = snapEngine;

          const snapEngine = SnapEngine.defaultInstance(infiniteCanvas, icSnapSlot);

          Hooker.installHooks(snapEngine, "presnap");
          // snapEngine.will["presnap"].on((...args) => {
          //   console.log("will presnap", ...args);
          // });
          // snapEngine.did["presnap"].on((...args) => {
          //   console.log("did presnap", ...args);
          // });
          Hooker.installHooks(snapEngine, "snap");
          Hooker.installHooks(snapEngine, "unsnap");



          snapEngine.canSnapFunc   = canSnapFunc;
          snapEngine.canUnsnapFunc = canUnsnapFunc;

          outSnapEngine = snapEngine;

          return outSnapEngine;
        }

        static defaultSnapSlotConfig() {
          const canSnapFunc = (above, below) => {
            return Snap.canSnap(above, below);
          };

          const canUnsnapFunc = (above, below) => {
            return Snap.canUnsnap(above, below);
          };

          const snapSlotConfig = {
            canSnapFunc:    canSnapFunc,
            canUnsnapFunc:  canUnsnapFunc,
          };

          return snapSlotConfig;
        }

      }

      // class SnapEngine {
      //
      //   constructor() {
      //
      //   }
      //
      //   start() {
      //
      //   }
      //
      //   stop() {
      //
      //   }
      //
      //   static defaultInstance(infiniteCanvas, icSnapSlot) {
      //     var outEngine;
      //
      //     const snapEngine = new SnapEngine();
      //
      //     const attemptSnapping = function(icObj_slot, icObj_piece) {
      //       console.log("attemptSnapping", icObj_slot, icObj_piece);
      //
      //       const canSnap = snapEngine.checkCanSnap(icObj_slot, icObj_piece);
      //
      //       const rep_official = icObj_piece;
      //       console.log("attempting to snap with snapState: " + rep_official.snapState);
      //
      //       // const isValidPieceSnapState = (rep_official.snapState == SnapState.Unsnapped);
      //       //
      //       // if(isValidPieceSnapState) {
      //       //
      //       // } else {
      //       //   console.log("can't snap while snapState == " + rep_official.snapState)
      //       //   // throw new Error("attempting to snap with snapState: " + rep_official.snapState);
      //       //   return;
      //       // }
      //
      //       if(canSnap) {
      //         console.log("can snap");
      //
      //         const rep_official = icObj_piece;
      //         const represented  = icObj_piece.represented;
      //         const rep_free     = represented.getRepresentation("free");
      //
      //         console.log("rep_free.isHeld", rep_free.isHeld);
      //         if(rep_free.isHeld) {
      //           snapEngine.presnap(icObj_slot, icObj_piece);
      //         } else {
      //           snapEngine.presnap(icObj_slot, icObj_piece);
      //           snapEngine.snap(icObj_slot, icObj_piece);
      //         }
      //
      //       } else {
      //         console.log("can't snap");
      //       }
      //
      //     };
      //     snapEngine.attemptSnapping = attemptSnapping;
      //
      //     const checkCanSnap = function(icObj_slot, icObj_piece) {
      //       console.log("checkCanSnap", icObj_piece);
      //       var outBool;
      //
      //       // outBool = Snap.canSnap(icObj_piece, icObj_slot);
      //       outBool = snapEngine.canSnapFunc(icObj_piece, icObj_slot);
      //
      //       return outBool;
      //     };
      //
      //     var rep_free_onRelease__triggerSnap          = null;
      //     var rep_free_afterPresnap__attemptUnsnapping = null;
      //
      //     var rep_free_callbacks = {
      //       onRelease__triggerSnap:          null,
      //       afterPresnap__attemptUnsnapping: null,
      //     };
      //     snapEngine.checkCanSnap = checkCanSnap;
      //
      //     const presnap = function(icObj_slot, icObj_piece) {
      //       console.log("presnap", icObj_piece);
      //
      //       const rep_official = icObj_piece;
      //       const represented  = icObj_piece.represented;
      //       const rep_free     = represented.getRepresentation("free");
      //       const rep_snapped  = represented.createNewRepresentationWithName("snapped");
      //
      //       rep_official.snapState = SnapState.Presnapped;
      //       // rep_official.snappedTo = icObj_slot;
      //       rep_official.snappedTo = icObj_slot.id;
      //
      //
      //       rep_official.unfollow(rep_free);
      //
      //
      //       rep_snapped.position     = Object.assign({}, icObj_slot.position);
      //       rep_snapped.homeScale    = Object.assign({}, icObj_slot.homeScale);
      //       rep_snapped.scale        = Object.assign({}, icObj_slot.scale);
      //       rep_snapped.orientation  = icObj_slot.orientation;
      //
      //       infiniteCanvas.addRepresentation(represented, rep_snapped);
      //
      //
      //       // rep_official.syncWith(rep_snapped);
      //       rep_official.syncWithObj({
      //         position:   rep_snapped.position,
      //         size:       rep_snapped.size,
      //         homeScale:  rep_snapped.homeScale,
      //         scale:      rep_snapped.scale,
      //
      //         // didUpdateListeners : rep_snapped.didUpdateListeners,
      //         // holdListeners      : rep_snapped.holdListeners,
      //         // releaseListeners   : rep_snapped.releaseListeners,
      //       });
      //       rep_official.follow(rep_snapped);
      //
      //
      //       rep_free.opacity = 0.0;
      //         //debug
      //       rep_free.opacity = 1.0;
      //       rep_free.fill = "blue";
      //
      //       //add release listener
      //       // icObj_fRep.onHold((icObj) => {
      //       //
      //       // });
      //
      //       //add release listener for rep_free
      //       rep_free_onRelease__triggerSnap = (rep_free) => {
      //         console.log("rep_free_onRelease__triggerSnap");
      //
      //         snapEngine.snap(icObj_slot, icObj_piece);
      //       };
      //       rep_free.onRelease(rep_free_onRelease__triggerSnap);
      //
      //
      //       //add unsnap listener for rep_free
      //       rep_free_afterPresnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
      //         console.log("rep_free_afterPresnap__attemptUnsnapping", rep_free);
      //
      //         snapEngine.attemptUnsnapping(icObj_slot, rep_free);
      //       };
      //       rep_free.onInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
      //
      //     };
      //     snapEngine.presnap = presnap;
      //
      //
      //     const snap = function(icObj_slot, icObj_piece) {
      //       console.log("snap", icObj_piece);
      //
      //       const rep_official = icObj_piece;
      //       const represented  = icObj_piece.represented;
      //       const rep_free     = represented.getRepresentation("free");
      //       const rep_snapped  = represented.getRepresentation("snapped");
      //
      //       console.log("**snap", "rep_free.isHeld", rep_free.isHeld);
      //
      //       console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
      //       if(rep_free_afterPresnap__attemptUnsnapping != null) {
      //         rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
      //       }
      //       rep_free_afterPresnap__attemptUnsnapping = null;
      //
      //
      //       rep_free.offRelease(rep_free_onRelease__triggerSnap);
      //       rep_free_onRelease__triggerSnap = null;
      //
      //
      //
      //       // rep_free.syncWith(rep_snapped);
      //       // rep_free.syncWith(rep_official);
      //
      //       //SHU TODO: MYSTERE ET BOULE DE GOMME: il y a un truc avec syncWith qui casse rep_free ... ???
      //
      //       rep_free.syncWithObj({
      //         position:   rep_snapped.position,
      //         size:       rep_snapped.size,
      //         homeScale:  rep_snapped.homeScale,
      //         scale:      rep_snapped.scale,
      //
      //         // didUpdateListeners : rep_snapped.didUpdateListeners,
      //         // holdListeners      : rep_snapped.holdListeners,
      //         // releaseListeners   : rep_snapped.releaseListeners,
      //       });
      //
      //
      //
      //       rep_free.opacity = 1.0;
      //         //debug
      //       rep_free.opacity = 1.0;
      //       rep_free.fill = "red";
      //
      //       rep_official.unfollow(rep_snapped);
      //       rep_official.follow(rep_free);
      //       rep_official.snapState = SnapState.Snapped;
      //       // rep_official.snappedTo = icObj_slot;
      //       // rep_official.snappedTo = icObj_slot.id;
      //
      //
      //
      //       console.log("remove rep_snapped", rep_snapped.id_rep);
      //       rep_snapped.im_dying_now = true;
      //       infiniteCanvas.removeRepresentation(represented, rep_snapped);
      //       represented.removeRepresentation(rep_snapped);
      //
      //       //add unsnap listener for rep_free
      //       // rep_free_afterSnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
      //       //   console.log("rep_free_afterSnap__attemptUnsnapping", rep_free);
      //       //
      //       //   attemptUnsnapping(icObj_slot, rep_free);
      //       // };
      //       // rep_free.onInnerUpdate(rep_free_afterSnap__attemptUnsnapping);
      //
      //
      //         //debug
      //       // rep_free.onHold((rep_free) => {
      //       //   console.log("###rep_free.id_rep", rep_free.id_rep);
      //       //   console.log("###rep_free.onHold", "rep_free.isHeld", rep_free.isHeld);
      //       // });
      //
      //     };
      //     snapEngine.snap = snap;
      //
      //
      //
      //
      //
      //     const attemptUnsnapping = function(icObj_slot, icObj_piece) {
      //       console.log("attemptUnsnapping", icObj_slot, icObj_piece);
      //
      //       const canUnsnap = snapEngine.checkCanUnsnap(icObj_slot, icObj_piece);
      //       console.log("canUnsnap", canUnsnap);
      //
      //       const rep_official = icObj_piece;
      //       console.log("attempting to unsnap with snapState: " + rep_official.snapState);
      //
      //       // const isValidPieceSnapState = (rep_official.snapState == SnapState.Presnapped);
      //       //
      //       // if(isValidPieceSnapState) {
      //       //
      //       // } else {
      //       //   console.log("can't unsnap while snapState == " + rep_official.snapState)
      //       //   // throw new Error("attempting to unsnap with snapState: " + rep_official.snapState);
      //       //   return;
      //       // }
      //
      //       if(canUnsnap) {
      //         // console.log("can unsnap");
      //         snapEngine.unsnap(icObj_slot, icObj_piece);     //presnap already sets up an unsnap listener
      //
      //       } else {
      //         // console.log("can't unsnap");
      //
      //         //SHU TODO: hasLeftSlot
      //         // const hasLeftSlot = Snap.hasLeftSlot()
      //         const hasLeftSlot = true;
      //
      //         if(hasLeftSlot) {
      //
      //
      //           // const rep_official = icObj_piece;
      //           const represented  = icObj_piece.represented;
      //           const rep_free     = represented.getRepresentation("free");
      //
      //           console.log("#rep_free.id_rep", rep_free.id_rep);
      //           console.log("#rep_free.isHeld", rep_free.isHeld);
      //
      //           if(rep_free.isHeld) {
      //             if(icObj_piece.snapState == SnapState.Snapped) {
      //               snapEngine.presnap(icObj_slot, icObj_piece);
      //             }
      //           } else {
      //             //do nothing
      //             // snap(icObj_slot, icObj_piece);
      //           }
      //
      //         } else {
      //           //do nothing
      //           // snap(icObj_slot, icObj_piece);
      //         }
      //
      //
      //
      //       }
      //
      //     };
      //     snapEngine.attemptUnsnapping = attemptUnsnapping;
      //
      //     const checkCanUnsnap = function(icObj_slot, icObj_piece) {
      //       console.log("checkCanUnsnap", icObj_piece);
      //       var outBool;
      //
      //       // outBool = Snap.canUnsnap(icObj_piece, icObj_slot);
      //       outBool = snapEngine.canUnsnapFunc(icObj_piece, icObj_slot);
      //
      //       return outBool;
      //     };
      //     snapEngine.checkCanUnsnap = checkCanSnap;
      //
      //
      //     const unsnap = function(icObj_slot, icObj_piece) {
      //       console.log("unsnap", icObj_piece);
      //
      //       // const represented  = icObj_piece.represented;
      //       // const rep_official = represented.getRepresentation("official");
      //       // const rep_snapped  = represented.getRepresentation("snapped");
      //
      //       const rep_unknown  = icObj_piece; //SHU TODO: solve snapSlot's rep madness
      //       const represented  = icObj_piece.represented;
      //       const rep_official = represented.getRepresentation("official");
      //       const rep_free     = represented.getRepresentation("free");
      //       const rep_snapped  = represented.getRepresentation("snapped");
      //
      //
      //       console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
      //       if(rep_free_afterPresnap__attemptUnsnapping != null) {
      //         rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
      //       }
      //       rep_free_afterPresnap__attemptUnsnapping = null;
      //
      //       // if(rep_free_afterSnap__attemptUnsnapping != null) {
      //       //   rep_free.offInnerUpdate(rep_free_afterSnap__attemptUnsnapping);
      //       // }
      //       // rep_free_afterSnap__attemptUnsnapping = null;
      //
      //
      //       // rep_free.offRelease(rep_free_onRelease__triggerSnap);
      //       // rep_free_onRelease__triggerSnap = null;
      //
      //       if(rep_free.offRelease != null) { //****************************************  SHU: il y a un problème ici, quand j'aurai trois neurones de disponibles, j'investiguerai
      //         rep_free.offRelease(rep_free_onRelease__triggerSnap);
      //         rep_free_onRelease__triggerSnap = null;
      //       }                                 //****************************************
      //
      //
      //       rep_official.syncWith(rep_free);
      //       rep_official.follow(rep_free);
      //
      //
      //       if(rep_snapped != null) {
      //         console.log("remove rep_snapped", rep_snapped.id_rep);
      //         rep_snapped.im_dying_now = true;
      //         infiniteCanvas.removeRepresentation(represented, rep_snapped);
      //         represented.removeRepresentation(rep_snapped);
      //       } else {
      //         console.log("rep_snapped already destroyed somewhere else");
      //       }
      //
      //
      //       // rep_free.im_dying_now = true; //SHU: this is interesting
      //
      //       rep_free.opacity = 1.0;
      //         //debug
      //       rep_free.fill = "lime";
      //
      //       rep_official.snapState = SnapState.Unsnapped;
      //       // rep_official.snappedTo = null;
      //       rep_official.snappedTo = -1;
      //
      //     };
      //     snapEngine.unsnap = unsnap;
      //
      //
      //
      //
      //
      //
      //     const r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
      //       console.log("r_official_update_handler", icObj_piece);
      //
      //       console.log("icObj_piece.snapState", icObj_piece.snapState);
      //
      //       // if(outerUpdatesDict["snapState"] == SnapState.Snapped) {
      //       //   //official just changed snapState to .Snapped
      //       //   //ignore
      //       //   return;
      //       // }
      //
      //       if(icObj_piece.snapState == SnapState.Unsnapped) {
      //         snapEngine.attemptSnapping(icObj_slot, icObj_piece);
      //       } else if(icObj_piece.snapState == SnapState.Snapped) {
      //         snapEngine.attemptUnsnapping(icObj_slot, icObj_piece);               //SHU666666 : this is the key line to understand what is wrong
      //       } else if(icObj_piece.snapState == SnapState.Presnapped) {
      //
      //       }
      //
      //     };
      //     snapEngine.r_official_update_handler = r_official_update_handler;
      //
      //     const r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
      //       console.log("r_official_update_handler2", rep_official_incoming);
      //
      //       const represented  = infiniteCanvas.getRepresented(icSnapSlot.id);
      //       console.log("represented", represented);
      //       const rep_official = represented.r_official();
      //
      //       const snapSlot    = rep_official;
      //       const incomingObj = rep_official_incoming;
      //
      //       if(incomingObj != snapSlot) { //don't snap oneself
      //
      //         if(!incomingObj.isSnappable) {
      //           //ignore: incomingObj is diamagnetic
      //         } else {
      //           console.log("++++incomingObj.snappedTo", incomingObj.snappedTo);
      //           // if(incomingObj.snappedTo != null && incomingObj.snappedTo != snapSlot) {
      //           if(incomingObj.snappedTo != -1 && incomingObj.snappedTo != snapSlot.id) {
      //             //ignore: incomingObj is already snapped to another slot
      //           } else {
      //             snapEngine.r_official_update_handler(snapSlot, incomingObj, outerUpdatesDict);
      //           }
      //         }
      //
      //       } else {
      //         console.log("I won't snap myself");
      //       }
      //
      //     };
      //     snapEngine.r_official_update_handler2 = r_official_update_handler2;
      //
      //     outEngine = snapEngine;
      //
      //     return outEngine;
      //   }
      //
      // }



      const TouchState = {
        "Untouched"  : "Untouched",
        "Touched"    : "Touched",
      };

      class Touch { //GeometryWise touching

        static canTouch(icObj_over, icObj_below) {

          //flemme: use fabric fObj.intersectsWithObject(fObj2)
          // const over__represented  = infiniteCanvas.getRepresented(icObj_over.id);
          // const over__rep_free     = over__represented.r_free();
          // const over__fObj         = over__rep_free.fObj;                            //<-- this is not available
          //
          // const below__represented  = infiniteCanvas.getRepresented(icObj_below.id);
          // const below__rep_free     = below__represented.r_free();
          // const below__fObj         = below__rep_free.fObj;                          //<-- this is not available
          //
          // const isIntersecting = over__fObj.intersectsWithObject(below__fObj);

          const rect__over  = icObj_over.getRect();
          const rect__below = icObj_below.getRect();

          console.log("rect__over", rect__over);
          console.log("rect__below", rect__below);

          const isIntersecting = Geometry.intersectRect(rect__over, rect__below);
          console.log("isIntersecting", isIntersecting);

          return isIntersecting;
        }

        static canUntouch(icObj_over, icObj_below) {
          return !this.canTouch(icObj_over, icObj_below);
        }

      }



      class RxSubjectEngine {

        constructor() {

          this.initialized = false;

          this.initialize = function(scopeObj) {

            //"wake up":
            //bind all funcs
            // function isFunction(functionToCheck) {
            //   return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
            // }
            const isFunction = value => value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);

            this.awoken = {
              'i_am': "awoken",
            };
            console.log("this.virgin", this.virgin);
            Object.entries(this.virgin)
                  .filter(([propName, prop]) => isFunction(prop))
                  .forEach(([propName, prop], i) => {
                    this.awoken[propName] = prop.bind(this.awoken);
                  });

            // this.scopeObj  = scopeObj;
              //engineCarrier,
              //infiniteCanvas,
            this.awoken.scopeObj = scopeObj;

            this.initialized = true;
          }





          this.next = function(value) {

            const engineCarrier = this.scopeObj.engineCarrier;
            engineCarrier.value = value;

            this.rxSubject.next(value);
          };

          this.getRxSubject = function() {
            return this.rxSubject;
          };



          this.start = function() {
            console.log("RxSubjectEngine::start, this", this);
            console.log("RxSubjectEngine::start", "this.scopeObj", this.scopeObj);

            const engineCarrier = this.scopeObj.engineCarrier;
            const value         = engineCarrier.value;

            const replaySubject = new Rx.ReplaySubject(1);
            replaySubject.next(value);

            this.rxSubject = replaySubject;
          };

          this.stop = function() {

            this.rxSubject.complete();
          };



          this.virgin = Object.assign({}, this);  //virgin == not bound

        }

      }

      class RxSubscriptionEngine {

      }











      class Observe {

      }

      class ObserverEngine {

        constructor() {

        }

        start() {

        }

        stop() {

        }

        observe(icObj_incoming) { //this function is to be hooked

        }

        static defaultInstance(infiniteCanvas, icObserver) {
          var outEngine;

          const observerEngine = new ObserverEngine();
          Hooker.installHooks(observerEngine, "observe");


          const r_official_update_handler = (observer, icObj_incoming, outerUpdatesDict) => {
            console.log("observerEngine::r_official_update_handler", icObj_incoming);

            observerEngine.observe(icObj_incoming);
          };
          observerEngine.r_official_update_handler = r_official_update_handler;

          const r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
            console.log("observerEngine::r_official_update_handler2", rep_official_incoming);

            const represented  = infiniteCanvas.getRepresented(icObserver.id);
            // console.log("represented", represented);
            const rep_official = represented.r_official();

            const observer    = rep_official;
            const incomingObj = rep_official_incoming;
            // console.log("incomingObj.id", incomingObj.id);

            if(incomingObj != observer) { //don't observe oneself

              console.log("observer.observerConfig.observed", observer.observerConfig.observed);
              const isObserved = observer.observerConfig.observed[incomingObj.id];

              if(!isObserved) {
                //ignore: incomingObj is not observed
              } else {
                observerEngine.r_official_update_handler(observer, incomingObj, outerUpdatesDict);
              }

            } else {
              console.log("I won't observe myself");
            }

          };
          observerEngine.r_official_update_handler2 = r_official_update_handler2;

          outEngine = observerEngine;

          return outEngine;
        }

      }









      class Curse {

        constructor(curseTrigger) {
          // logger.log("Curse::constructor", curseTrigger);

          this.curseFunc    = null;

          this.curseTrigger       = curseTrigger;
          this.curseTrigger.curse = this;
        }

        enact() {
          if(this.curseFunc != null) {
            this.curseFunc();
          }
        }

        start() {
          this.curseTrigger.start();
        }

        stop() {
          this.curseTrigger.stop();
        }

        reset() {

        }

      }


      class CurseTrigger_countdown {

        constructor() {
          this.curse     = null;


          const curseTrigger = this;

          const countDownConfig = CountDownConfig.defaultConfig();
          countDownConfig.stepFunc = (countDownObj) => {
            // logger.log("stepFunc", countDownObj);

            if(countDownObj.index == 10) {             //SHU123
              curseTrigger.expulse();
            }
          };

          // const engine    = new CountDownEngine_auto(countDownConfig);
          const engine    = new CountDownEngine(countDownConfig);

          this.engine = engine;
        }

        impulse() {
          if(this.engine.impulse != null) {
            this.engine.impulse();
          }
        }

        expulse() {
          this.curse.enact();
        }

        start() {
          this.engine.start();
        }

        stop() {
          this.engine.stop();
        }

      }





      class CountDownConfig {

        constructor(value_start, value_end, stepFunc, stepDuration) {
          this.value_start   = value_start;
          this.value_end     = value_end;

          this.stepFunc      = stepFunc;
          this.stepDuration  = stepDuration;
        }

        static defaultConfig() {
          var outConfig;

          const value_start = 10;
          const value_end   = 0;

          const stepFunc = (stepIndex) => {
            console.log("stepFunc", stepIndex);
          };

          const stepDuration = 1000;

          outConfig = new CountDownConfig(value_start, value_end, stepFunc, stepDuration);

          return outConfig;
        }

      }




      class CountDownSequencer {

        constructor(value_from, value_to = 0) {

          // const animatedObj = {
          //   value: value_from,
          //
          //   index:    0,
          //   progress: 0,
          // };
          // this.animatedObj = animatedObj;

          const nb_values = (value_from - value_to) + 1;
          const arr_keyframes = [...new Array(nb_values).keys()].reverse().map((value, index) => {
            // logger.log("keyframe: value, index", value, index);

            const progress = (value_from - value) / (value_from - value_to);
            // logger.log("keyframe: progress", progress);


            const keyframe = {
              value:    value,

              index:    index,
              progress: progress,

              duration: 1,
            };

            return keyframe;
          });
          this.arr_keyframes = arr_keyframes;

          const animatedObj = Object.assign({}, arr_keyframes[0]);
          this.animatedObj = animatedObj;

          const arr_butfirst_keyframes = arr_keyframes.slice(1);
          this.arr_butfirst_keyframes  = arr_butfirst_keyframes;

          const stepDuration = 1;
          this.stepDuration  = stepDuration;

          const duration     = (nb_values - 1) * stepDuration;
          // const duration     = nb_values * stepDuration;

          this.duration      = duration;

          const countDownSequencer = this;
          const animation = anime({
            // targets: countDownEngine,
            targets: animatedObj,

            /*animated props*/
            // progress: 1,
            /*--------------*/
            // keyframes: arr_keyframes,
            keyframes: arr_butfirst_keyframes,

            direction: 'normal',
            easing: 'linear',
            duration: duration,

            autoplay: false,

            // update: (anim) => {                        //SHU: this would have been nice, but it triggers bizarrely
            //   countDownSequencer.update(animatedObj);
            // },
          });

          this.animation = animation;

          // this.debugAnimation();
        }

        debugAnimation() {
          const duration = this.duration;

          this.arr_keyframes.forEach((keyframe, i) => {

            const progress__keyframe  = keyframe.progress;
            const timestamp__keyframe = progress__keyframe * duration;
            // logger.log("timestamp__keyframe", timestamp__keyframe);

            this.animation.seek(timestamp__keyframe);

            // logger.log("this.animatedObj", this.animatedObj);
          });

          this.animation.seek(0);
        }

        // moveToFirstFrame() {
        //   this.animation.seek(0);
        //   this.update(this.animatedObj);
        // }

        moveToNextFrame() {
          // logger.log("moveToNextFrame");

          const index__current = this.animatedObj.index;
          // logger.log("index__current", index__current);
          const index__next    = index__current + 1;
          // logger.log("index__next", index__next);

          if(index__next < this.arr_keyframes.length) {

            const keyframe__next  = this.arr_keyframes[index__next];
            // logger.log("keyframe__next", keyframe__next);


            const progress__next  = keyframe__next.progress;
            const timestamp__next = progress__next * this.duration;
            // logger.log("timestamp__next", timestamp__next);

            this.animation.seek(timestamp__next);
            // logger.log("this.animation.progress", this.animation.progress);
            this.update();

          } else {
            // logger.log("can't move further");
          }

        }


        update() {
          if(this.countDownEngine != null) {
            const animatedObj = this.animatedObj;
            this.countDownEngine.update(animatedObj);
          }
        }

        // pulse() {
        //   this.moveToNextFrame();
        // }

      }


      class CountDownObj {
        constructor(value_from) {
          this.value    = value_from;
          this.progress = 0;
        }
      }

      class CountDownEngine {     //SHU:    /!\ this is not an icEngined engine


        constructor(countDownConfig_in = null) {

          var countDownConfig = countDownConfig_in;
          if(countDownConfig == null) {
            countDownConfig = CountDownConfig.defaultConfig();
          }

          this.counter_start = countDownConfig.value_start;
          this.counter_end   = countDownConfig.value_end;

          this.stepFunc      = countDownConfig.stepFunc;
          this.stepDuration  = countDownConfig.stepDuration;

          const nb_steps     = math.abs(this.counter_end - this.counter_start);
          this.nb_steps      = nb_steps;

          this.arr_steps     = [...new Array(nb_steps).keys()];
          this.step_current  = 0;

          this.counter = this.counter_start;

          this.progress = 0;

          this.isPaused = true;

          const duration = this.nb_steps * this.stepDuration;

          const countDownSequencer = new CountDownSequencer(nb_steps);
          countDownSequencer.countDownEngine = this;
          this.countDownSequencer = countDownSequencer;



          const rx_countDownCounter = new ReplaySubject(1);
          const countDownObj = countDownSequencer.animatedObj;
          rx_countDownCounter.next(countDownObj.value);
          this.rx_countDownCounter = rx_countDownCounter;


          this.start = function() {
            const countDownEngine = this;

            // countDownEngine.stepFunc(0);
            // countDownEngine.stepFunc(countDownSequencer.animatedObj);
            countDownEngine.update(countDownSequencer.animatedObj);

            countDownEngine.play();
          };
          // }.bind(this);

          this.stop = function() {
            const countDownEngine = this;

            countDownEngine.reset();
          };
          // }.bind(this);

          this.play = function() {
            const countDownEngine = this;

            const date_play           = new Date();
            countDownEngine.date_play = date_play;

            countDownEngine.isPaused = false;
            // countDownEngine.animation.play();
          };
          // }.bind(this);

          this.pause = function() {
            const countDownEngine = this;

            const date_pause           = new Date();
            countDownEngine.date_pause = date_pause;

            // countDownEngine.animation.pause();
            countDownEngine.isPaused = true;
          };
          // }.bind(this);

          this.reset = function() {
            const countDownEngine = this;

            // countDownEngine.animation.reset();
          };
          // }.bind(this);

          this.update = function(countDownObj) {
            // logger.log("update", countDownObj);
            const countDownEngine = this;

            countDownEngine.stepFunc(countDownObj);
            countDownEngine.rx_countDownCounter.next(countDownObj.value);
          };
          // }.bind(this);


          this.impulse = function() {
            // this.countDownSequencer.pulse();
            this.countDownSequencer.moveToNextFrame();
          };


          this.getCounter = function() {
            return this.countDownSequencer.animatedObj.value;
          };

        }

      }


      // class CountDownEngine {     //SHU:    /!\ this is not an icEngined engine
      //   constructor(countDownConfig_in = null) {
      //
      //     var countDownConfig = countDownConfig_in;
      //     if(countDownConfig == null) {
      //       countDownConfig = CountDownConfig.defaultConfig();
      //     }
      //
      //     this.counter_start = countDownConfig.value_start;
      //     this.counter_end   = countDownConfig.value_end;
      //
      //     this.stepFunc      = countDownConfig.stepFunc;
      //     this.stepDuration  = countDownConfig.stepDuration;
      //
      //     const nb_steps     = math.abs(this.counter_end - this.counter_start);
      //     this.nb_steps      = nb_steps;
      //
      //     this.arr_steps     = [...new Array(nb_steps).keys()];
      //     this.step_current  = 0;
      //
      //     this.counter = this.counter_start;
      //
      //     this.progress = 0;
      //
      //     this.isPaused = true;
      //
      //     const duration = this.nb_steps * this.stepDuration;
      //
      //     this.animatedObj = {
      //       progress: 0
      //     };
      //
      //     const countDownEngine = this;
      //     const animatedObj = this.animatedObj;
      //     const animation = anime({
      //       // targets: countDownEngine,
      //       targets: animatedObj,
      //
      //       /*animated props*/
      //       progress: 1,
      //       /*--------------*/
      //
      //       direction: 'normal',
      //       easing: 'linear',
      //       duration: duration,
      //
      //       autoplay: false,
      //
      //       update: (anim) => {
      //         const progress = anim.progress / 100;
      //         countDownEngine.progress = progress;
      //         countDownEngine.update(progress);
      //       },
      //     });
      //
      //     this.animation = animation;
      //
      //
      //
      //     this.start = function() {
      //       const countDownEngine = this;
      //
      //       countDownEngine.stepFunc(0);
      //       countDownEngine.play();
      //     };
      //     // }.bind(this);
      //
      //     this.stop = function() {
      //       const countDownEngine = this;
      //
      //       countDownEngine.reset();
      //     };
      //     // }.bind(this);
      //
      //     this.play = function() {
      //       const countDownEngine = this;
      //
      //       const date_play           = new Date();
      //       countDownEngine.date_play = date_play;
      //
      //       countDownEngine.isPaused = false;
      //       countDownEngine.animation.play();
      //     };
      //     // }.bind(this);
      //
      //     this.pause = function() {
      //       const countDownEngine = this;
      //
      //       const date_pause           = new Date();
      //       countDownEngine.date_pause = date_pause;
      //
      //       countDownEngine.animation.pause();
      //       countDownEngine.isPaused = true;
      //     };
      //     // }.bind(this);
      //
      //     this.reset = function() {
      //       const countDownEngine = this;
      //
      //       countDownEngine.animation.reset();
      //     };
      //     // }.bind(this);
      //
      //     this.update = function(progress) {
      //       console.log("update", progress);
      //       const countDownEngine = this;
      //
      //       const cursor      = progress * countDownEngine.nb_steps;
      //       const step_cursor = math.floor(cursor);
      //
      //       const isStepChanged = (step_cursor - countDownEngine.step_current) >= 1;
      //       if(isStepChanged) {
      //         countDownEngine.step_current = step_cursor;
      //         countDownEngine.stepFunc(step_cursor);
      //       }
      //     };
      //     // }.bind(this);
      //
      //   }
      //
      // }







//I/O

      class FileIntegration {

        constructor(clipboardIntegration) {
          this.clipboardIntegration = clipboardIntegration;

          document.onpaste = function(event) {
            console.log("onpaste", "event", event);
            clipboardIntegration.rx_outerPaste.next(event);
          };

        }

        static openFileDialog (accept, callback) {

            // Create an input element
            var inputElement = document.createElement("input");

            // Set its type to file
            inputElement.type = "file";

            // Set accept to the file types you want the user to select.
            // Include both the file extension and the mime type
            inputElement.accept = accept;

            // set onchange event to call callback when user has selected file
            inputElement.addEventListener("change", callback)

            // dispatch a click event to open the file dialog
            inputElement.dispatchEvent(new MouseEvent("click"));

        }

        static openFile_p(accept) {

          return new Promise((resolve, reject) => {

            FileIntegration.openFileDialog(accept, event => {
              const fileList = event.target.files;
              ////console.log("fileList:", fileList);

              const file = fileList[0];
              //console.log("file", file);

              resolve(file);
            });
          });

        }




        // static addImageFromFile_p(file) {
        //
        //   function addZimageForImg(img) {
        //     //console.log("img", img);
        //
        //     // const zimage = createZimageWithCurrentBoundingRect(img);
        //
        //     const canvasBoundingTrueRect = getCanvasBoundingTrueRect();
        //
        //     // object-fit : contain
        //     const img_size = {
        //       width: img.width,
        //       height: img.height
        //     };
        //     const trueRect = containedRect(canvasBoundingTrueRect, img_size);
        //
        //     const zimage = createZimage(img, trueRect);
        //
        //     addZimage(zimage);
        //
        //     redrawCanvas();
        //   }
        //
        //   function addFabricImageForImg(img) {
        //     //console.log("img", img);
        //
        //     // const zimage = createZimageWithCurrentBoundingRect(img);
        //
        //     const canvasBoundingTrueRect = getCanvasBoundingTrueRect();
        //
        //     // object-fit : contain
        //     const img_size = {
        //       width: img.width,
        //       height: img.height
        //     };
        //     const trueRect = containedRect(canvasBoundingTrueRect, img_size);
        //
        //     const fabricImage = createFabricImage(img, trueRect);
        //     addFabricObject(fabricImage);
        //
        //     redrawCanvas();
        //   }
        //
        //   return createImage_p(file)
        //         .then(img => {
        //           // addZimageForImg(img);
        //           addFabricImageForImg(img);
        //         });
        //
        // }



        //IMPORT image

        static importImage_p() {
          const accept = ".jpg, .jpeg, .png";
          return FileIntegration.openFile_p(accept)
                .then(FileIntegration.createImage_p);
        }


        static createImage_p(file) {
          return FileIntegration.getFileData_p(file)
                .then(FileIntegration.dataToImgSrc_p)
                .then(FileIntegration.imageFromImgSrc_p);
        }

        static imageFromImgSrc_p(imgSrc) {
          //console.log('imgSrc', imgSrc);
          // return new Promise(r => img.onload=r, img.src=imgSrc)
          return new Promise((resolve, reject) => {
            const img   = new Image();
            img.onload  =      () => resolve(img);
            img.onerror = (error) => reject(error);

            img.src = imgSrc;
          });
        }

        static dataToImgSrc_p(data) {
          var imgSrc_p;

          if(data.startsWith("data:image")) {
            imgSrc_p = Promise.resolve(data);
          } else {
            imgSrc_p = FileIntegration.dataToBlob_p(data)
                  .then(blob1 => {
                    //change blob type
                    const blob2 = new Blob([blob1], {type: 'image/png'})
                    return blob2;
                  })
                  .then(FileIntegration.getFileData_p);
                  // .then(blob2 => {
                  //   const imgSrc = URL.createObjectURL(blob2);
                  //   ////console.log("converted imgSrc:", imgSrc);
                  //   //>>converted imgSrc: blob:http://localhost:8080/7243f1de-493f-412b-b1ec-b042b0cbcac4
                  //   return imgSrc;
                  // });
          }

          return imgSrc_p;
        }

        static dataToBlob_p(data) {
          return fetch(data)
                 .then(res => res.blob());
        }

        static imageContentsToBlob_p(img) {
          return this.dataToBlob_p(img.src);
        }


        //file utils

        static getFileData_p(file) {
          ////console.log("getFileData_p", file);

          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function(evt) {
               const file_url = evt.target.result; //<=> var file_url = reader.result;
               ////console.log("file_url:", file_url);
               resolve(file_url);
            };
            reader.readAsDataURL(file);
          });

        }

        static getFileText_p(file) {
          ////console.log("getFileText_p", file);

          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function(evt) {
               const file_url = evt.target.result; //<=> var file_url = reader.result;
               ////console.log("file_url:", file_url);
               resolve(file_url);
            };
            reader.readAsText(file);
          });

        }


        // static getFileImage_p(filename) {
        //   const file_url = "/img/" + filename;
        //   return fetch(file_url)
        //         .then(FileIntegration.createImage_p);
        // }







        //PASTE image


        static getPastedFile_p(event) {
          var outPromise;

          var items = (event.clipboardData || event.originalEvent.clipboardData).items;
          //console.log(JSON.stringify(items)); // will give you the mime types

          const arr_files = Object.values(items)
                                .filter(item => item.kind == 'file')
                                .map(item => item.getAsFile());

          if(arr_files.length == 1) {
            const file = arr_files.find(e => true);
            outPromise = Promise.resolve(file);
          } else {
            const error = new Error("arr_files.length != 1");
            outPromise = Promise.reject(error);
          }

          return outPromise;
        }





        //SAVE / LOAD

        static save_to_file(obj) {

          const json = JSON.stringify(obj);

          const filename = "infinishute.json";
          FileIntegration.download(json, filename, 'text/json');
        }

        static download(content, fileName, contentType) {
          var a = document.createElement("a");
          var file = new Blob([content], {type: contentType});
          a.href = URL.createObjectURL(file);
          a.download = fileName;
          a.click();
        }


        // static objByConvertingImagesToBase64_p(obj) {
        //
        //   const zimages_raw = obj.zimages;
        //
        //   const arr__zimages_serial_p = zimages_raw.map(zimage => {
        //
        //     //console.log("zimage", zimage);
        //     const imgSrc_base64_p = FileIntegration.dataUrlForImgViaCanvas_p(zimage.img);
        //
        //     return imgSrc_base64_p
        //            .then(imgSrc_base64 => {
        //
        //              const zimage_serial = {
        //                imgSrc_base64:  imgSrc_base64,
        //                trueRect:       zimage.trueRect,
        //              };
        //
        //              return zimage_serial;
        //            });
        //
        //   });
        //
        //   return Promise.all(arr__zimages_serial_p)
        //          .then(arr__zimages_serial => {
        //
        //            const obj2 = {};
        //
        //            obj2.zimages  = arr__zimages_serial;
        //            obj2.drawings = obj.drawings;
        //
        //            return obj2;
        //          });
        // }

        static objByConvertingImagesToBase64_p(obj) {

          const zimages_raw = obj.zimages;

          const arr__zimages_serial_p = zimages_raw.map(zimage => {

            //console.log("zimage", zimage);
            const imgSrc_base64_p = FileIntegration.dataUrlForImgViaCanvas_p(zimage.img);

            return imgSrc_base64_p
                   .then(imgSrc_base64 => {

                     const zimage_serial = {
                       imgSrc_base64:  imgSrc_base64,
                       trueRect:       zimage.trueRect,
                     };

                     return zimage_serial;
                   });

          });

          return Promise.all(arr__zimages_serial_p)
                 .then(arr__zimages_serial => {

                   const obj2 = {};

                   obj2.zimages  = arr__zimages_serial;
                   obj2.drawings = obj.drawings;

                   return obj2;
                 });
        }



        static saveInfinishute_p(infiniShute) {

          // const obj = {
          //   // zimages  : zimages,
          //   // drawings : drawings,
          //
          //   infiniteCanvas: infiniteCanvas,
          // };
          // //console.log("obj", obj);
          //
          // FileIntegration.objByConvertingImagesToBase64_p(obj)
          // .then(obj2 => {
          //   //console.log("obj2", obj2);
          //   FileIntegration.save_to_file(obj2);
          // });

          FileIntegration.save_to_file(infiniShute);

          //?
          return Promise.resolve(true);
        }

        static loadInfinishute_p() {
          const accept = ".json";
          return FileIntegration.openFile_p(accept)
                .then(FileIntegration.createJson_p)
                // .then(FileIntegration.createInfinishute_p);
                // .then(infinishute => {
                //   configureWithInfinishute(infinishute);
                // });
        }

        static createJson_p(file) {
          return FileIntegration.getFileText_p(file)
                .then(text => {
                  //console.log("text:", text);

                  const json = JSON.parse(text);
                  //console.log("json:", json);
                  return json;
                });

        }

        // static createInfinishute_p(json) {
        //   const infinishute = {};
        //
        //   infinishute.drawings = json.drawings;
        //
        //   const zimages_serial = json.zimages;
        //   const arr__zimage_p = zimages_serial.map(zimage_serial => {
        //
        //     const imgSrc = zimage_serial.imgSrc_base64;
        //     return FileIntegration.imageFromImgSrc_p(imgSrc)
        //            .then(image => {
        //              const zimage = {
        //                img: image,
        //                trueRect: zimage_serial.trueRect,
        //              };
        //
        //              return zimage;
        //            });
        //   })
        //
        //   return Promise.all(arr__zimage_p)
        //                 .then(zimages => {
        //                   infinishute.zimages = zimages;
        //
        //                   return infinishute;
        //                 });
        //
        // }

        // static createInfinishute_p(json) {
        //   const infinishute = {};
        //
        //   return json;
        // }


        static dataUrlForImgViaCanvas_p(img) {

          const src = img.src;

          const outputFormat = "image/png";

          return new Promise((resolve, reject) => {
            var imgAux = new Image();

            imgAux.crossOrigin = 'Anonymous';
            imgAux.onload = function() {
              var canvasAux = document.createElement('CANVAS');
              var ctxAux    = canvasAux.getContext('2d');
              var dataURL;
              canvasAux.height = this.naturalHeight;
              canvasAux.width  = this.naturalWidth;
              ctxAux.drawImage(this, 0, 0);
              dataURL = canvasAux.toDataURL(outputFormat);
              resolve(dataURL);
            };
            imgAux.onerror = (error) => reject(error);

            imgAux.src = src;
          });

        }

      }




      //Clipboard mgmt

      class ClipboardObject {
        constructor(source, content) {
          this.source  = source;
          this.content = content;
        }
      }

      class InnerCopyEvent {
        constructor(clipboardObject) {
          this.timestamp       = Date.now();
          this.clipboardObject = clipboardObject;
        }
      }

      class ClipboardIntegration {

        constructor(arr_sources) {
          // this.arr_sources = arr_sources;
          const rx_innerCopy = new Subject();
          this.rx_innerCopy  = rx_innerCopy;

          // this.arr_paste_p = arr_sources.map(source => source.paste_p);
          const rx_outerPaste = new Subject();
          this.rx_outerPaste  = rx_outerPaste;

          const clipboardIntegration = this;
          // const rx_mixedPaste = Rx.combineLatest(rx_outerPaste, rx_innerCopy)
          const rx_mixedPaste = rx_outerPaste.pipe(Rx_operators.withLatestFrom(rx_innerCopy))
            .pipe(Rx_operators.map(([clipboardEvent, innerCopyEvent]) => {
              var outVal;

              console.log("rx_mixedPaste");
              console.log("clipboardEvent", clipboardEvent);
              console.log("innerCopyEvent", innerCopyEvent);

              const timestamp_outer = clipboardEvent.timeStamp;
              const timestamp_inner = Date.now() - innerCopyEvent.timestamp;
              console.log("timestamp_outer", timestamp_outer);
              console.log("timestamp_inner", timestamp_inner);

              if(timestamp_inner < timestamp_outer) {
                const icObj = innerCopyEvent.clipboardObject.content;
                icObj.id += 1000;

                //clone newly created, shift it, and copy it {
                const cloned = icObj.deepClone();
                cloned.id += 1000;

                cloned.position.x += 10;
                cloned.position.y += 10;

                clipboardIntegration.manageInnerCopy("fabric.general", cloned);
                //}

                outVal = icObj;

              } else {
                outVal = clipboardIntegration.outerToInner(clipboardEvent);
              }

              return outVal;
            }));

          this.rx_mixedPaste = rx_mixedPaste;
        }

        manageInnerCopy(source, content) {

          const cbObj = new ClipboardObject(source, content);

          const innerCopyEvent = new InnerCopyEvent(cbObj);
          this.rx_innerCopy.next(innerCopyEvent);




          //copy to navigator clipboard
          const icObj = content;

          const outerWrapper = outerWrapperForIcObj(icObj);
          if(outerWrapper != null) {

            writeToClipboard_p(outerWrapper)
            .then(success => {
              console.log("writeToClipboard_p, success");
            })
            .catch(err => {
              console.log("writeToClipboard_p, error:" + err);
            });


          }

          function outerWrapperForIcObj(icObj) {
            var out;

            switch(icObj.type) {
              case "image":
                const outerWrapper_image = {
                  type:   "image",
                  content: icObj.img,
                };
                out = outerWrapper_image;
                break;
              case "text":
                const outerWrapper_text = {
                  type:   "text",
                  content: icObj.text,
                };
                out = outerWrapper_text;
                break;
              default:
                out = null;
                break;
            }

            return out;
          }

          function writeToClipboard_p(outerWrapper) {
            var out_p;

            switch(outerWrapper.type) {
              case "text":
                const text = outerWrapper.content;
                out_p = writeToClipboard_text_p(text);
                break;
              case "image":
                const img = outerWrapper.content;
                //const imgSrc_p = FileIntegration.dataUrlForImgViaCanvas_p(img);
                // out_p = img_serial_p
                //         .then(imgSrc => {
                //           return writeToClipboard_image_p(imgSrc);
                //         });
                out_p = writeToClipboard_image_p(img);
                break;
              // case "mixed":
              //   writeToClipboard_mixed(outerWrapper.content);
              //   break;
              default:
                throw new Error("outerWrapper, unsupported type: " + outerWrapper.type);
            }

            return out_p;
          }

          function writeToClipboard_text_p(text) {
            return navigator.clipboard.writeText(text)
            .then(success => {
              console.log("navigator.clipboard.writeText, success");
            })
            .catch(err => {
              console.log("navigator.clipboard.writeText, error:" + err);
            });
          }

          function writeToClipboard_image_p(img) {
            console.log("writeToClipboard_image", img);

            // const image = await fetch('ceiling-cat.jpg');
            // const blob_image = new Blob([imgSrc], { type: 'image/png' });
            const blob_image_p = FileIntegration.imageContentsToBlob_p(img);

            // const blob_text = new Blob(['Cute sleeping kitten'], {type: 'text/plain'});

            const item_p = blob_image_p.then(blob_image => {
              const item = new ClipboardItem({
                // 'text/plain': blob_text,

                'image/png': blob_image,
              });

              return item;
            });

            return item_p
                  .then(item => {
                    navigator.clipboard.write([item])
                  })
                  .then(success => {
                    console.log("navigator.clipboard.write, success");
                  })
                  .catch(err => {
                    console.log("navigator.clipboard.write, error:" + err);
                  });
          }

        }

        manageOuterPaste(clipboardEvent) {
          this.rx_outerPaste.next(clipboardEvent);
        }

        outerToInner(clipboardEvent) {

          // get text representation of clipboard
          var text = (clipboardEvent.originalEvent || clipboardEvent).clipboardData.getData('text/plain');
          if(text) {
            console.log("text", text);
            fileIntegration.onPasteTextListeners.forEach((listener, i) => {
              listener(text);
            });
          } else {
            console.log("not a text");

            FileIntegration.getPastedFile_p(clipboardEvent)
            .then(FileIntegration.createImage_p)
            .then(img => {
              fileIntegration.onPasteImageListeners.forEach((listener, i) => {
                listener(img);
              });
            });

          }

          return

        }

        innerToOuter(icObj) {
          return null;
        }

        lol() {
          // pasteFabricObjects(event) {
          //   console.log("pasteFabricObjects", event);
          //
          //   const clipboardData = event.clipboardData;
          //   // _clipboard.clone(function(clonedObj) {
          //   navigator.clipboard.read()
          //   .then((items) => {
          //     console.log("items", items);
          //   })
          //   .catch((err) => {
          //     console.log("err", err);
          //   });
          //
          //
          //   clipboardData.clone(function(clonedObj) {
          //     fabricCanvas.discardActiveObject();
          //     clonedObj.set({
          //       left: clonedObj.left + 10,
          //       top: clonedObj.top + 10,
          //       evented: true,
          //     });
          //     if (clonedObj.type === 'activeSelection') {
          //       // active selection needs a reference to the canvas.
          //       clonedObj.canvas = fabricCanvas;
          //       clonedObj.forEachObject(function(obj) {
          //         fabricCanvas.add(obj);
          //       });
          //       // this should solve the unselectability
          //       clonedObj.setCoords();
          //     } else {
          //       fabricCanvas.add(clonedObj);
          //     }
          //
          //     _clipboard.top += 10;
          //     _clipboard.left += 10;
          //
          //     fabricCanvas.setActiveObject(clonedObj);
          //     fabricCanvas.requestRenderAll();
          //   });
          // }
        }

        lol2() {
          fileIntegration.onPasteImageListeners.push((img) => {
            infiniteCanvas.manageImageImport(img);
          });
          fileIntegration.onPasteTextListeners.push((text) => {
            infiniteCanvas.manageTextImport(text);
          });
        }

      }










//User Input

      class InputProperties {
        constructor() {
          this.scroll_step__default = 1.0 / 500;
          this.scrollProperties = {
            step: this.scroll_step__default,
          };



          this.scroll_step__slow = this.scroll_step__default / 10;
          this.scroll_step__fast = this.scroll_step__default * 10;


          this.move_multiplier__default = 1.0;
          this.moveProperties = {
            moveMultiplier: this.move_multiplier__default,
          };

          this.move_multiplier__slow = this.move_multiplier__default / 10;
          this.move_multiplier__fast = this.move_multiplier__default * 10;


          this.colorProperties = {
            activeIndex : 0,
            list: [
              "lime",

              "red",
              "green",
              "blue",

              "white",
              "black",

              "orange",
              "purple",
              "yellow",
            ],
          };

          this.setNextColor(0);

          this.opacity = 1.0;
          const screment = 0;
          this.setNextOpacity(screment);
        }

        setScrollStep(value) {
          //console.log("setScrollStep", value);
          this.scrollProperties.step = value;
        }

        setMoveMultiplier(value) {
          //console.log("setMoveMultiplier", value);
          this.moveProperties.moveMultiplier = value;
        }



        getActiveColor() {
          return this.colorProperties.list[this.colorProperties.activeIndex];
        }

        setNextColor(screment) {
          console.log("setNextColor", screment);

          var index = this.colorProperties.activeIndex;
          index += screment;
          if(index >= this.colorProperties.list.length) {
            index -= this.colorProperties.list.length;
          } else if(index < 0) {
            index += this.colorProperties.list.length;
          }

          this.colorProperties.activeIndex = index;

          //debug
          debug.setActiveColor(this.getActiveRgbaColorString());
        }


        getActiveOpacity() {
          return this.opacity;
        }

        setNextOpacity(screment) {
          console.log("setNextOpacity", screment);

          const opacity_prev = this.opacity;

          const step_opacity     = 0.1;
          const screment_opacity = step_opacity * (-screment);

          const opacity_bounded  = Math.min(1.0, Math.max(0.0, opacity_prev + screment_opacity));
          this.opacity = opacity_bounded;

          //debug
          debug.setActiveColor(this.getActiveRgbaColorString());
        }

        getActiveRgbaColorString() {
          const color   = this.getActiveColor();
          const opacity = this.getActiveOpacity();

          const fColor = new fabric.Color(color);
          fColor.setAlpha(opacity);
          const rgbaColorString = fColor.toRgba();

          return rgbaColorString;
        }

      }





      class KeyDownToggle {

        constructor(name, keyDownFunc, keyDownToggleFunc = null) {
          this.name        = name;
          this.keyDownFunc = keyDownFunc;
          this.isActive    = false;

          this.keyDownToggleFunc = keyDownToggleFunc;
          if(keyDownToggleFunc == null) {
            this.keyDownToggleFunc = KeyDownToggle.keyDownToggleFunc();
          }
        }

        update(e, down) {
          const updateValue = this.keyDownFunc(e, down);
          if(updateValue != null) {
            if(this.isActive != updateValue) {
              this.isActive = updateValue;
              this.keyDownToggleFunc(this.isActive);
            }
          }
        }

        static defaultKeyDownFunc(arr_keyCode) {
          const keyDownFunc = (e, down) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if(keyCode == e.code) {
                acc = down;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyDownFunc;
        }

        static keyDownToggleFunc() {
          return (isActive) => {
            console.log("KeyDownToggle::update", this.name, this.isActive);
          };
        }

      }

      class KeyDownTimeout {

        constructor(name, keyDownFunc, triggeredFunc, delayInMs) {
          this.name          = name;
          this.keyDownFunc   = keyDownFunc;
          this.triggeredFunc = triggeredFunc;
          this.delayInMs     = delayInMs;

          this.isActive    = false;
        }

        update(e, down) {
          const updateValue = this.keyDownFunc(e, down);
          if(updateValue != null) {
            if(this.isActive != updateValue) {
              this.isActive = updateValue;
              console.log("KeyDownTimeout::update", this.name, this.isActive);

              const keyDownTimeout = this;

              function theFunc() {
                console.log("KeyDownTimeout", "call triggeredFunc()");
                keyDownTimeout.triggeredFunc();
              }

              function mayRepeat(theFunc) {

                setTimeout(function(){
                  if(keyDownTimeout.isActive) {
                    theFunc();
                    mayRepeat(theFunc);
                  }
                }, keyDownTimeout.delayInMs);
              }

              theFunc();
              mayRepeat(theFunc);

            }
          }
        }

        static defaultKeyDownFunc(arr_keyCode) {
          const keyDownFunc = (e, down) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if(keyCode == e.code) {
                acc = down;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyDownFunc;
        }

      }

      class KeyUpABToggle {

        constructor(name, keyUpFunc, triggeredFunc) {
          this.name          = name;
          this.keyUpFunc     = keyUpFunc;
          this.triggeredFunc = triggeredFunc;

          this.isModeA     = true;
        }

        update(e) {
          const updateValue = this.keyUpFunc(e);
          console.log("updateValue", updateValue);
          if(updateValue) {
            this.isModeA = !this.isModeA;
            console.log("KeyUpABToggle::update", this.name, this.isModeA);

            this.triggeredFunc(this.isModeA);
          }
        }

        static defaultKeyUpFunc(arr_keyCode) {
          const keyUpFunc = (e) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if(keyCode == e.code) {
                acc = true;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyUpFunc;
        }

      }

      class KeyboardIntegration {

        constructor(infiniteCanvas, inputProperties, fileIntegration, fabricIntegration) {
          this.infiniteCanvas  = infiniteCanvas;
          this.inputProperties = inputProperties;

          this.fileIntegration = fileIntegration;

          this.fabricIntegration = fabricIntegration;


          // this.altKeyDown = false;
          this.keyDownToggles  = {};
          this.keyDownTimeouts = {};

          this.keyUpABToggles  = {};


          this.configureKeyboardEventHandlers();
        }

        configureKeyboardEventHandlers() {
          const keyboardIntegration = this;
          const infiniteCanvas      = this.infiniteCanvas;

          const fabricIntegration   = this.fabricIntegration;

          document.addEventListener('keyup',   logKey);
          document.addEventListener('keyup',   handleKeyUp);
          document.addEventListener('keydown', handleKeyDown);


          function configureKeyDownToggles() {

            keyboardIntegration.keyDownToggles = {
              // alt: new KeyDownToggle("alt", KeyDownToggle.defaultKeyDownFunc(["AltLeft", "AltRight"])),   //do not use alt, alt is kind of a system key
              r: new KeyDownToggle("r", KeyDownToggle.defaultKeyDownFunc(["KeyR"])),

              c: new KeyDownToggle("c", KeyDownToggle.defaultKeyDownFunc(["KeyC"])),
              v: new KeyDownToggle("v", KeyDownToggle.defaultKeyDownFunc(["KeyV"])),


              shiftLeft: new KeyDownToggle("shiftLeft", KeyDownToggle.defaultKeyDownFunc(["ShiftLeft"]), (isActive) => {
                //only side effect is used
              }),

              // shiftLeft: new KeyDownToggle("shiftLeft", KeyDownToggle.defaultKeyDownFunc(["ShiftLeft"]), (isActive) => {
              backquote: new KeyDownToggle("backquote", KeyDownToggle.defaultKeyDownFunc(["Backquote"]), (isActive) => {
                /**/
                if(isActive) {
                  fabricIntegration.enterFreeDrawing();
                } else {
                  fabricIntegration.leaveFreeDrawing();
                }
                /**/
              }),

              zIndexEditing: new KeyDownToggle("zIndexEditing", KeyDownToggle.defaultKeyDownFunc(["Digit2"]), (isActive) => {
                if(isActive) {
                  infiniteCanvas.enterZIndexEditing();
                } else {
                  infiniteCanvas.leaveZIndexEditing();
                }
              }),

            };

          }
          configureKeyDownToggles();


          function configureKeyDownTimeouts() {

            const default_timeout_delayInMs = 17; //17 ms == 60 fps
            keyboardIntegration.keyDownTimeouts = {

              a: new KeyDownTimeout("a", KeyDownToggle.defaultKeyDownFunc(["KeyQ"]), () => {
                var scaleAmount_for_100ms;

                if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  scaleAmount_for_100ms = -0.3;
                } else {
                  scaleAmount_for_100ms = -0.1;
                }

                const scaleAmount = default_timeout_delayInMs / 100 * scaleAmount_for_100ms;
                keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
              }, default_timeout_delayInMs),

              z: new KeyDownTimeout("z", KeyDownToggle.defaultKeyDownFunc(["KeyW"]), () => {
                var scaleAmount_for_100ms;

                if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  scaleAmount_for_100ms = +0.3;
                } else {
                  scaleAmount_for_100ms = +0.1;
                }

                const scaleAmount = default_timeout_delayInMs / 100 * scaleAmount_for_100ms;
                keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
              }, default_timeout_delayInMs),
            };

          }
          configureKeyDownTimeouts();


          function configureKeyUpABToggles() {

            keyboardIntegration.keyUpABToggles = {
              ":": new KeyUpABToggle(":", KeyUpABToggle.defaultKeyUpFunc(["Period"]), (isModeA) => {
                  keyboardIntegration.fabricIntegration.setAntiAliasEnabled(isModeA);
              }),

              "n": new KeyUpABToggle("n", KeyUpABToggle.defaultKeyUpFunc(["KeyN"]), (isModeA) => {
                  keyboardIntegration.fabricIntegration.setSupervesselEnabled(isModeA);
              }),

              "d": new KeyUpABToggle("d", KeyUpABToggle.defaultKeyUpFunc(["KeyD"]), (isModeA) => {
                  const infiniteCanvas = keyboardIntegration.infiniteCanvas;
                  if(!isModeA) {
                    infiniteCanvas.createIcLine_start();
                  } else {
                    infiniteCanvas.createIcLine_end();
                  }
              }),

              "^": new KeyUpABToggle("^", KeyUpABToggle.defaultKeyUpFunc(["BracketLeft"]), (isModeA) => {
                  const infiniteCanvas = keyboardIntegration.infiniteCanvas;
                  if(!isModeA) {
                    infiniteCanvas.debug_sparkleAnims(true);
                  } else {
                    infiniteCanvas.debug_sparkleAnims(false);
                  }
              }),
            };

          }
          configureKeyUpABToggles();



          function updateKeyDownToggles(e, down) {
            const arr_keyDownToggles = Object.values(keyboardIntegration.keyDownToggles);
            arr_keyDownToggles.forEach((keyDownToggle, i) => {
              keyDownToggle.update(e, down);
            });
          }

          function updateKeyDownTimeouts(e, down) {
            const arr_keyDownTimeouts = Object.values(keyboardIntegration.keyDownTimeouts);
            arr_keyDownTimeouts.forEach((keyDownTimeout, i) => {
              keyDownTimeout.update(e, down);
            });
          }

          function updateKeyUpABToggles(e) {
            const arr_keyUpABToggles = Object.values(keyboardIntegration.keyUpABToggles);
            arr_keyUpABToggles.forEach((keyUpABToggle, i) => {
              keyUpABToggle.update(e);
            });
          }


          function logKey(e) {
            //console.log("logKey", "e.code", e.code);
          }

          function handleKeyUp(e) {
            logger.log("handleKeyUp", "e", e);

            if(fabricIntegration.shouldIgnoreShortcutInput()) {
              return;
            }

            updateKeyDownToggles(e, false);
            updateKeyDownTimeouts(e, false);
            updateKeyUpABToggles(e);



            switch(e.code) {
              case "KeyA":
                // handleKeyUp_A(e);
                break;

              case "KeyI":
                FileIntegration.importImage_p()
                .then(img => {
                  infiniteCanvas.manageImageImport(img);
                });
                break;

              case "KeyS":
                infiniteCanvas.manageSaveInfinishute_p()
                .then((success) => {
                  console.log("success", success);
                });
                break;
              case "KeyL":
                FileIntegration.loadInfinishute_p()

                //debug
               .then(infinishute => {
                 console.log("loaded infinishute", infinishute);
                 return infinishute;
               })

                .then(infinishute => {
                  infiniteCanvas.manageLoadInfinishute(infinishute);
                });
                break;

              /*
              // case "ShiftLeft":
              case "KeyZ":
                handleKey_Shift(e);
                break;
              // case "ControlLeft":
              case "KeyX":
                handleKey_Ctrl(e);
                break;
              */


              case "KeyE":
                {
                  const cursor =
                  fabricIntegration.activateObjectAtCursor();
                }
                break;


              case "KeyF":
                {
                  keyboardIntegration.infiniteCanvas.addNewRect();
                }
                break;


              // case "KeyF":
              //   handleKeyUp_F(e);
              //   break;

              // case "KeyT":
              //   handleKeyUp_T(e);
              //   break;
              case "KeyT":
                {
                  if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                    //tag
                    const debug_text = "challenge.";
                    keyboardIntegration.infiniteCanvas.addNewTag(debug_text);
                  } else {
                    //text
                    const debug_text = "icText";
                    keyboardIntegration.infiniteCanvas.addNewText(debug_text);
                  }

                }
                break;

              case "KeyA":
                {
                  keyboardIntegration.infiniteCanvas.addNewCircle();
                }
                break;

              case "KeyH":
                {
                  keyboardIntegration.infiniteCanvas.addNewSnapSlot();
                }
                break;

              case "KeyZ":
                {
                  // keyboardIntegration.infiniteCanvas.addNewSparkle();
                  FileIntegration.importImage_p()
                  .then(img => {
                    infiniteCanvas.addNewSparkle(img);
                  });
                }
                break;

              case "KeyU":
                {
                  // keyboardIntegration.infiniteCanvas.addNewTouchSlot();

                  keyboardIntegration.infiniteCanvas.addNewGMOperator();

                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_editable("x (22/7)");
                }
                break;

              case "KeyU":
                {
                  // keyboardIntegration.infiniteCanvas.addNewTouchSlot();
                  // keyboardIntegration.infiniteCanvas.addNewGMOperator();
                  keyboardIntegration.infiniteCanvas.addNewGMChallenge(0);
                }
                break;

              case "Digit6":
                {
                  // const html_elt = document.getElementById("debug_nbObjects");
                  // const html_elt = document.body;


                  const input = document.createElement("INPUT");
                  input.setAttribute("type", "text");
                  // input.setAttribute("text", "lolilol");

                  input.style.backgroundColor = "yellow";
                  document.body.appendChild(input);

                  const html_elt = input;


                  /*
                  const div = document.createElement("DIV");
                  div.style.backgroundColor = "yellow";
                  div.style.width  = "200px";
                  div.style.height = "200px";

                  // div.style.visibility = "hidden";
                  // div.style.display = "none";

                  document.body.appendChild(div);

                  const html_elt = div;
                  */

                  keyboardIntegration.infiniteCanvas.addNewHtmlElt(html_elt);
                }
              break;


              case "Digit5":
                {
                  keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify__remove_parentheses");
                }
              break;

              case "Digit7":
                {
                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify");
                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify__step_by_step");
                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("simplify__top_layer");

                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("equation__add1");

                  // keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("split__top_layer");
                  keyboardIntegration.infiniteCanvas.addNewGMOperator_withType("decomposition__product_primes");

                }
              break;

              case "Digit8":
                {
                  // keyboardIntegration.infiniteCanvas.addNewTouchSlot();
                  // keyboardIntegration.infiniteCanvas.addNewGMTargetSlot();

                  keyboardIntegration.infiniteCanvas.addNewGMTargetTouchSlot();

                }
              break;

              case "KeyJ":
                {
                  keyboardIntegration.infiniteCanvas.addNewWell();
                }
                break;

              case "KeyN":
                {
                  // keyboardIntegration.infiniteCanvas.addNewComposite();
                  // keyboardIntegration.infiniteCanvas.addNewGreenMouseWell();
                }
                break;

              case "KeyM":
                {
                  logger.log("keyM");
                  // keyboardIntegration.infiniteCanvas.addNewTouchSlot();
                  // keyboardIntegration.infiniteCanvas.addNewBornAgainGreenMouse(1);

                  // keyboardIntegration.infiniteCanvas.addNewRxSubject(1);
                  // keyboardIntegration.infiniteCanvas.addNewLabelValue("lol", 9);

                  keyboardIntegration.infiniteCanvas.operateOnActiveObject__split();     // == split supervessel cargo
                }
                break;

              case "Comma":
                {
                  // keyboardIntegration.infiniteCanvas.addNewButton();
                  // keyboardIntegration.infiniteCanvas.addNewRxSubscription();

                  keyboardIntegration.infiniteCanvas.operateOnActiveObject__join();     // == join supervessel cargo
                }
                break;




              case "Quote":
                {
                  const tex = '\\frac{1}{x^2-1}';
                  // const svgEl = TexHelper.toSvgEl(tex);
                  // keyboardIntegration.infiniteCanvas.addNewSvg(svgEl);

                  // keyboardIntegration.infiniteCanvas.addNewTex(tex);

                  // const expression = new algebra.Expression("x");
                  // expression.autoSimplify = false;
                  // keyboardIntegration.infiniteCanvas.addNewExpr(expression);

                  // const equation = new algebra.Equation(new algebra.Expression("x"), new algebra.Expression("3"));
                  // keyboardIntegration.infiniteCanvas.addNewExpr(equation);


                  /*
                  // const mathNode = math.parse("1");
                  const mathNode = new math.ConstantNode(1);
                  // const mathNode = new math.SymbolNode("x");
                  mathNode.autoSimplify = true;
                  // mathNode.autoSimplify = false;
                  keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
                  */

                  // const mathNode = random_mathNode_withDepth(4);
                  // const mathNode = random_mathNode_withDepth_and_nbSymbols(4,0);
                  // const mathNode = random_mathNode_withDepth_and_nbSymbols(4,1);

                  // const mathNode = random_onion_mathNode(5);
                  // const mathNode = random_onion_mathNode(5, false);
                  // const mathNode = random_onion_mathNode(3);

                  // const mathNode = random_onion_mathNode(2);
                  // const mathNode = random_onion_mathNode(3);
                  // mathNode.autoSimplify = false;

                  const mathNode = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
                  mathNode.autoSimplify = true;

                  keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
                  // keyboardIntegration.infiniteCanvas.addNewGreenMouseBox(mathNode);
                }
                break;

              case "Digit0":
                {
                  keyboardIntegration.infiniteCanvas.addNewFacet_mathNode();
                }
                break;

              case "Digit9":
                {
                  // keyboardIntegration.infiniteCanvas.addNewCountdown();
                  keyboardIntegration.infiniteCanvas.addNewIcEngined_debug();
                }
                break;








              case "Equal":
                {
                  // keyboardIntegration.infiniteCanvas.addNewObserver();
                  keyboardIntegration.infiniteCanvas.addNewClickWell(-22);
                }
                break;

              case "Minus":
                {
                  keyboardIntegration.infiniteCanvas.addNewTrigger();
                }
                break;

              case "Backslash":
                {
                  // keyboardIntegration.infiniteCanvas.addNewEventEmitter();

                  const mathNode_left     = new math.SymbolNode("x");
                  mathNode_left.autoSimplify = false;
                  const mathNode_right    = new math.ConstantNode(1);
                  mathNode_right.autoSimplify = true;
                  const mathNode_equation = new math.RelationalNode(["equal"], [mathNode_left, mathNode_right]);
                  // mathNode_equation.params[0].autoSimplify = false;
                  // mathNode_equation.params[1].autoSimplify = true;
                  mathNode_equation.isEquation = true;

                  const mathNode = mathNode_equation;
                  keyboardIntegration.infiniteCanvas.addNewMathNode(mathNode);
                }
                break;

              case "BracketRight":
                {
                  keyboardIntegration.infiniteCanvas.addNewClickWell();
                  // keyboardIntegration.infiniteCanvas.addNewEventReceiver();
                }
                break;

              case "BracketRight":
                {
                  keyboardIntegration.infiniteCanvas.addNewEventReceiver();
                }
                break;





              case "KeyG":
                {
                  if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                    //compose
                    fabricIntegration.composeSelectedObjects();
                  } else {
                    //group
                    fabricIntegration.groupSelectedObjects();
                  }
                }
                break;

              case "KeyB":
                {
                  if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                    //decompose
                    fabricIntegration.decomposeSelectedObject();
                  } else {
                    //ungroup
                    fabricIntegration.ungroupSelectedObject();
                  }
                }
                break;




              // case "Digit0":
              case "Numpad0":
                keyboardIntegration.infiniteCanvas.move_to_initial_position();
                break;

              case "BackQuote":
                keyboardIntegration.infiniteCanvas.move_to_pov__animation(pov_debug, animationConfig__default);
                break;



                // case "KeyW":
                //   {
                //     const scaleAmount = -0.1;
                //     keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
                //   }
                //   break;
                //
                // case "KeyE":
                //   {
                //     const scaleAmount = 0.1;
                //     keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
                //   }
                //   break;


              // case "KeyM":
              case "Semicolon":
                if(keyboardIntegration.keyDownToggles.r.isActive) {
                  keyboardIntegration.infiniteCanvas.manageCenterRotation(-10);
                } else {
                  keyboardIntegration.infiniteCanvas.updateWithDOrientation(-10);
                }
                break;

              case "KeyP":
                if(keyboardIntegration.keyDownToggles.r.isActive) {
                  keyboardIntegration.infiniteCanvas.manageCenterRotation(+10);
                } else {
                  keyboardIntegration.infiniteCanvas.updateWithDOrientation(+10);
                }
                break;

              case "KeyK":
                {
                  function openUrlInNewTab(url){
                    var win = window.open(url, '_blank');
                  }
                  openUrlInNewTab("https://www.qwant.com/?l=fr");
                }
                break;


              // case "AltLeft":
              // case "AltRight":
              //   keyboardIntegration.altKeyDown = false;
              //   break;

              case "Delete":
                fabricIntegration.deleteSelection();
                break;


              case "Space":
                fabricIntegration.deselectAll();
                break;


              default:
                break;
            }
          }

          function handleKeyDown(e) {
            //console.log("handleKeyDown", "e.code", e.code);

            if(fabricIntegration.shouldIgnoreShortcutInput()) {
              return;
            }

            updateKeyDownToggles(e, true);
            updateKeyDownTimeouts(e, true);


            switch(e.code) {
              /*
              // case "ShiftLeft":
              case "KeyZ":
                handleKey_Shift(e);
                break;
              // case "ControlLeft":
              case "KeyX":
                handleKey_Ctrl(e);
                break;
              */

              // case "AltLeft":
              // case "AltRight":
              //   keyboardIntegration.altKeyDown = true;
              //   break;

              default:
                break;
            }
          }



          // function handleKeyUp_A(e) {
          //   //console.log("handleKeyUp_A", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const zimage_scream = this.createScreamZimage(canvasBoundingTrueRect);
          //   this.addZimage(zimage_scream);
          //
          //   this.redrawCanvas();
          // }

          // function handleKeyUp_F(e) {
          //   //console.log("handleKeyUp_F", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const fObj = this.createFabricSampleObjectWithCanvasBoundingRect(canvasBoundingTrueRect);
          //   this.addFabricObject(fObj);
          //
          //   this.redrawCanvas();
          // }

          // function handleKeyUp_T(e) {
          //   //console.log("handleKeyUp_T", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const fObj = this.createFabricSampleTextObjectWithCanvasBoundingRect(canvasBoundingTrueRect);
          //   this.addFabricObject(fObj);
          //
          //   this.redrawCanvas();
          // }

          //scroll fast/slow

          /*
                  $(document).keydown(function(event) {
                  if (event.ctrlKey==true && (event.which == '61' || event.which == '107' || event.which == '173' || event.which == '109'  || event.which == '187'  || event.which == '189'  ) ) {
                          event.preventDefault();
                       }
                      // 107 Num Key  +
                      // 109 Num Key  -
                      // 173 Min Key  hyphen/underscor Hey
                      // 61 Plus key  +/= key
                  });

                  $(window).bind('mousewheel DOMMouseScroll', function (event) {
                         if (event.ctrlKey == true) {
                         event.preventDefault();
                         }
                  });
          */



          function handleKey_Shift(e) {
            switch(e.type) {
              case "keydown":
                this.setScrollStep(scroll_step__fast);
                this.setMoveMultiplier(move_multiplier__fast);
                break;
              case "keyup":
                this.setScrollStep(scroll_step__default);
                this.setMoveMultiplier(move_multiplier__default);
                break;
              default:
                break;
            }
          }

          function handleKey_Ctrl(e) {
            switch(e.type) {
              case "keydown":
                this.setScrollStep(scroll_step__slow);
                this.setMoveMultiplier(move_multiplier__slow);
                break;
              case "keyup":
                this.setScrollStep(scroll_step__default);
                this.setMoveMultiplier(move_multiplier__default);
                break;
              default:
                break;
            }
          }

        }


      }



      class MouseIntegration {

        constructor(canvasContainer, infiniteCanvas, inputProperties, keyboardIntegration) {

          this.infiniteCanvas  = infiniteCanvas;
          this.inputProperties = inputProperties;

          this.leftMouseDown  = false;
          this.rightMouseDown = false;

          this.keyboardIntegration = keyboardIntegration;

          this.configureMouseEventHandlers(canvasContainer);
        }

        // Mouse Event Handlers
        configureMouseEventHandlers(canvasContainer) {
          const mouseIntegration = this;

          const keyboardIntegration = this.keyboardIntegration;
          const inputProperties     = this.inputProperties;

          const infiniteCanvas      = this.infiniteCanvas;


          canvasContainer.addEventListener('mousedown', onMouseDown);
          canvasContainer.addEventListener('mouseup',   onMouseUp, false);
          canvasContainer.addEventListener('mouseout',  onMouseUp, false);
          canvasContainer.addEventListener('mousemove', onMouseMove, false);
          canvasContainer.addEventListener('wheel',     onMouseWheel, false);

          // mouse functions
          function onMouseDown(event) {

              /*
              // update the cursor coordinates
              const cursor = {
                x: event.pageX,
                y: event.pageY,
              };

              this.infiniteCanvas.updateCursor(cursor);
              */

              // detect left clicks
              if (event.button == 0) {
                  mouseIntegration.leftMouseDown = true;
                  mouseIntegration.rightMouseDown = false;
              }
              // detect right clicks
              if (event.button == 2) {
                  mouseIntegration.rightMouseDown = true;
                  mouseIntegration.leftMouseDown = false;
              }
          }

          function onMouseMove(event) {
              // //console.log("onMouseMove", "event", event);

              // update cursor with mouse position
              const cursor = {
                x: event.pageX,
                y: event.pageY,
              };
              mouseIntegration.infiniteCanvas.updateCursor(cursor);


              if (mouseIntegration.leftMouseDown) {
                mouseIntegration.infiniteCanvas.manageCursorMove_line();
              }
              else if (mouseIntegration.rightMouseDown) {
                //console.log("onMouseMove", "rightMouseDown", "event", event);

                // console.log("keyboardIntegration.altKeyDown", keyboardIntegration.altKeyDown);
                // if(keyboardIntegration.keyDownToggles.r.isActive) {
                //   mouseIntegration.infiniteCanvas.manageCursorMove_rotate();
                // } else {
                //   mouseIntegration.infiniteCanvas.manageCursorMove_offset();
                // }
                mouseIntegration.infiniteCanvas.manageCursorMove_offset();

              } else if(keyboardIntegration.keyDownToggles.r.isActive) {
                mouseIntegration.infiniteCanvas.manageCursorMove_rotate();
              }

          }

          function onMouseUp() {
              mouseIntegration.leftMouseDown  = false;
              mouseIntegration.rightMouseDown = false;

              mouseIntegration.infiniteCanvas.logCursor();
          }

          function onMouseWheel(event) {

            if(keyboardIntegration.keyDownToggles.c.isActive) {
              colorScroll();
            } else if(keyboardIntegration.keyDownToggles.v.isActive) {
              opacityScroll();
            } else if(infiniteCanvas.isZIndexEditing) {
              zIndexEditingScroll();
            }
            else {
              zoomScroll();
            }

            function colorScroll() {
              const deltaY   = event.deltaY;
              const screment = deltaY > 0 ? 1 : -1;
              inputProperties.setNextColor(screment);
            }

            function opacityScroll() {
              const deltaY   = event.deltaY;
              const screment = deltaY > 0 ? 1 : -1;
              inputProperties.setNextOpacity(screment);
            }

            function zIndexEditingScroll() {
              const deltaY   = event.deltaY;
              const screment = deltaY > 0 ? 1 : -1;
              infiniteCanvas.manageZIndexEditingScrement(screment);
            }

            function zoomScroll() {
              const deltaY = event.deltaY;
              // const scaleAmount = -deltaY / 500;
              const scroll_step = mouseIntegration.inputProperties.scrollProperties.step;
              //console.log("onMouseWheel", "scroll_step", scroll_step);
              const scaleAmount = -deltaY * scroll_step;

              const scaleAmount_max =  0.99;
              const scaleAmount_min = -0.99;
              const scaleAmount_bounded = Math.min(scaleAmount_max, Math.max(scaleAmount_min, scaleAmount));

              mouseIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount_bounded);

              /*
              var zoom = canvas.getZoom();
              zoom *= 0.999 ** deltaY;
              // if (zoom > 20) zoom = 20;
              // if (zoom < 0.01) zoom = 0.01;
              canvas.setZoom(zoom);
              event.preventDefault();
              event.stopPropagation();
              */



              // const scale_new = scale * (1 + scaleAmount);

              /*
              // zoom the page based on where the cursor is
              var distX = event.pageX / canvas.clientWidth;
              var distY = event.pageY / canvas.clientHeight;

              // calculate how much we need to zoom
              const unitsZoomedX = trueWidth() * scaleAmount;
              const unitsZoomedY = trueHeight() * scaleAmount;

              const unitsAddLeft = unitsZoomedX * distX;
              const unitsAddTop = unitsZoomedY * distY;

              const dOffsetX = unitsAddLeft;
              const dOffsetY = unitsAddTop;

              const dOffset = {
                dx: dOffsetX,
                dy: dOffsetY,
              };

              updateScaleAndDOffset(scale_new, dOffset);
              */
            }


          }

          // function onMouseWheel(event) {
          //   const deltaY = event.deltaY;
          //   const scaleAmount = -deltaY / 500;
          //   scale = scale * (1 + scaleAmount);
          //
          //   // zoom the page based on where the cursor is
          //   var distX = event.pageX / canvas.clientWidth;
          //   var distY = event.pageY / canvas.clientHeight;
          //
          //   // calculate how much we need to zoom
          //   const unitsZoomedX = trueWidth() * scaleAmount;
          //   const unitsZoomedY = trueHeight() * scaleAmount;
          //
          //   const unitsAddLeft = unitsZoomedX * distX;
          //   const unitsAddTop = unitsZoomedY * distY;
          //
          //   offsetX -= unitsAddLeft;
          //   offsetY -= unitsAddTop;
          // }

        }

      }

      class TouchIntegration {

        constructor(canvasContainer, infiniteCanvas, inputProperties) {
          // touch functions
          this.prevTouches = [null, null]; // up to 2 touches
          this.singleTouch = false;
          this.doubleTouch = false;

          this.configureTouchEventHandlers(canvasContainer);
        }

        configureTouchEventHandlers(canvasContainer) {
          // Touch Event Handlers
          canvasContainer.addEventListener('touchstart',  onTouchStart);
          canvasContainer.addEventListener('touchend',    onTouchEnd);
          canvasContainer.addEventListener('touchcancel', onTouchEnd);
          canvasContainer.addEventListener('touchmove',   onTouchMove);


          function onTouchStart(event) {
              if (event.touches.length == 1) {
                  this.singleTouch = true;
                  this.doubleTouch = false;
              }
              if (event.touches.length >= 2) {
                  this.singleTouch = false;
                  this.doubleTouch = true;
              }

              // store the last touches
              this.prevTouches[0] = event.touches[0];
              this.prevTouches[1] = event.touches[1];

          }

          function onTouchMove(event) {
              // get first touch coordinates
              const touch0X = event.touches[0].pageX;
              const touch0Y = event.touches[0].pageY;
              const prevTouch0X = this.prevTouches[0].pageX;
              const prevTouch0Y = this.prevTouches[0].pageY;

              const pointTouch0 = {

              };

              const pointPrevTouch0 = {

              };

              const scaledX = toTrueX(pointTouch0);
              const scaledY = toTrueY(pointTouch0);
              const prevScaledX = toTrueX(pointPrevTouch0);
              const prevScaledY = toTrueY(pointPrevTouch0);

              if (singleTouch) {
                  // add to history
                  drawings.push({
                      x0: prevScaledX,
                      y0: prevScaledY,
                      x1: scaledX,
                      y1: scaledY
                  })
                  drawLine(prevTouch0X, prevTouch0Y, touch0X, touch0Y);
              }

              if (doubleTouch) {
                  // get second touch coordinates
                  const touch1X = event.touches[1].pageX;
                  const touch1Y = event.touches[1].pageY;
                  const prevTouch1X = prevTouches[1].pageX;
                  const prevTouch1Y = prevTouches[1].pageY;

                  // get midpoints
                  const midX = (touch0X + touch1X) / 2;
                  const midY = (touch0Y + touch1Y) / 2;
                  const prevMidX = (prevTouch0X + prevTouch1X) / 2;
                  const prevMidY = (prevTouch0Y + prevTouch1Y) / 2;

                  // calculate the distances between the touches
                  const hypot = Math.sqrt(Math.pow((touch0X - touch1X), 2) + Math.pow((touch0Y - touch1Y), 2));
                  const prevHypot = Math.sqrt(Math.pow((prevTouch0X - prevTouch1X), 2) + Math.pow((prevTouch0Y - prevTouch1Y), 2));

                  // calculate the screen scale change
                  var zoomAmount = hypot / prevHypot;
                  scale = scale * zoomAmount;
                  const scaleAmount = 1 - zoomAmount;

                  // calculate how many pixels the midpoints have moved in the x and y direction
                  const panX = midX - prevMidX;
                  const panY = midY - prevMidY;
                  // scale this movement based on the zoom level
                  offsetX += (panX / scale);
                  offsetY += (panY / scale);

                  // Get the relative position of the middle of the zoom.
                  // 0, 0 would be top left.
                  // 0, 1 would be top right etc.
                  var zoomRatioX = midX / canvas.clientWidth;
                  var zoomRatioY = midY / canvas.clientHeight;

                  // calculate the amounts zoomed from each edge of the screen
                  const unitsZoomedX = trueWidth() * scaleAmount;
                  const unitsZoomedY = trueHeight() * scaleAmount;

                  const unitsAddLeft = unitsZoomedX * zoomRatioX;
                  const unitsAddTop = unitsZoomedY * zoomRatioY;

                  offsetX += unitsAddLeft;
                  offsetY += unitsAddTop;

                  redrawCanvas();
              }
              prevTouches[0] = event.touches[0];
              prevTouches[1] = event.touches[1];
          }

          function onTouchEnd(event) {
              singleTouch = false;
              doubleTouch = false;
          }

        }



      }


    </script>





    <script>
      // disable right clicking
      document.oncontextmenu = function () {
          return false;
      }

      class State {

      }

      const inputProperties      = new InputProperties();

      const clipboardIntegration = new ClipboardIntegration();
      const fileIntegration      = new FileIntegration(clipboardIntegration);


      const infiniteCanvas      = new InfiniteCanvas(canvas, inputProperties);
      clipboardIntegration.rx_mixedPaste.subscribe({
        next: (icObj) => {
          console.log("rx_mixedPaste, next:", icObj);
          infiniteCanvas.addPastedIcObject(icObj);
        },
      });




      // const canvas = document.getElementById("myCanvas");
      const fabricIntegration   = new FabricIntegration(infiniteCanvas, inputProperties);
      fabricIntegration.clipboardIntegration = clipboardIntegration;

      //debug {
      // console.log("fabricIntegration.fabricCanvas", fabricIntegration.fabricCanvas);
      // infiniteCanvas.canvasContainer = fabricIntegration.fabricCanvas.contextTop.canvas.parentElement;
      //}

      infiniteCanvas.redrawCanvasListeners.push((redrawOccasion) => {
        fabricIntegration.redrawCanvas(redrawOccasion);
      });
      // infiniteCanvas.didAddObjectListeners.push((icObj) => {
      //   const icObj_free = icObj.r_free();
      //   fabricIntegration.addFabricObjectWithIcObj(icObj_free);
      // });
      infiniteCanvas.didAddRepresentationListeners.push((icObj_represented, icObj_representation) => {
        console.log("infiniteCanvas.didAddRepresentationListeners", icObj_represented, icObj_representation);

        const rep_official = icObj_represented.r_official();
        const rep_free     = icObj_represented.r_free();

        //debug
        if(icObj_representation == rep_free) {

            if(rep_official.type == "sparkle") {

              // const homeScale_sparkle = {
              //   X: rep_official.homeScale.X,
              //   Y: rep_official.homeScale.Y,
              // };
              const home_properties = {
                // homeScale: {
                  X: rep_official.homeScale.X,
                  Y: rep_official.homeScale.Y,
                // },
                orientation: rep_official.orientation,
              };



              var animation = null;

              // var homeScale_animated = {
              //   X: rep_official.homeScale.X,
              //   Y: rep_official.homeScale.Y,
              // };
              var animated_properties = {
                X: home_properties.X,
                Y: home_properties.Y,
                orientation: home_properties.orientation,
              };

              const duration_one_way    = 777;
              var   moment              = 0;

              var   timestamp_animStart = -1;

              var from = null;
              var to   = null;


              function animationUpdateFunc() {
                // rep_free.homeScale = homeScale_animated;
                rep_free.homeScale   = {
                  X: animated_properties.X,
                  Y: animated_properties.Y,
                };
                rep_free.orientation = animated_properties.orientation;
              }

              function createNewSparkleAnimation(old1, current, old2, new2, new1) {
                console.log("createNewSparkleAnimation");

                const duration_complement = duration_one_way - moment;

                // anime.set(homeScale_animated, current);
                anime.set(animated_properties, current);


                const animation_seam = anime({
                  // targets: homeScale_animated,
                  targets: animated_properties,
                  X: new2.X,
                  Y: new2.Y,
                  orientation: new2.orientation,

                  duration: duration_complement,
                  easing: 'easeOutSine',

                  update:   animationUpdateFunc,

                  changeBegin: () => {
                    from = new1;
                    to   = new2;

                    timestamp_animStart = Date.now() - moment;
                  },

                  complete: (anim) => {
                    console.log("@@@ completed");

                    //SHU: un peu sale mais comment faire autrement
                    animation = createAnimation_endless();
                    // setTimeout(() => {
                    //   animation = createAnimation_endless();
                    // }, 0);
                  },

                  autoplay: false,
                });

                function createAnimation_endless() {

                  var isForward = true;

                  const animation_endless = anime({
                    // targets: homeScale_animated,
                    // X: new1.X,
                    // Y: new1.Y,
                    targets: animated_properties,
                    X: new1.X,
                    Y: new1.Y,
                    orientation: new1.orientation,

                    direction: 'alternate',
                    easing: 'easeInOutSine',
                    loop:true,


                    autoplay: true,


                    duration: duration_one_way,
                    update:   (anim) => {
                      animationUpdateFunc();
                    },

                    loopBegin: function(anim) {

                      if(isForward) {
                        from = new2;
                        to   = new1;
                      } else {
                        from = new1;
                        to   = new2;
                      }

                      timestamp_animStart = Date.now();
                      moment = 0;

                      isForward = !isForward;
                    },
                    // loopComplete: function(anim) {
                    //
                    // },

                  });

                  return animation_endless;
                }

                return animation_seam;
              }

              function startAnimation() {
                // animation = createNewSparkleAnimationTimeline(homeScale_sparkle, homeScale_sparkle, infiniteCanvas.scale, infiniteCanvas.scale, homeScale_sparkle);
                // animation = createNewSparkleAnimation(homeScale_sparkle, homeScale_sparkle, infiniteCanvas.scale, infiniteCanvas.scale, homeScale_sparkle);

                const from = {
                  X: home_properties.X,
                  Y: home_properties.Y,
                  orientation: home_properties.orientation,
                };
                const to = {
                  X: infiniteCanvas.scale.X,
                  Y: infiniteCanvas.scale.Y,
                  // orientation: home_properties.orientation + 180,
                  orientation: home_properties.orientation + 180 * (home_properties.X / infiniteCanvas.scale.X),
                };
                animation = createNewSparkleAnimation(from, from, to, to, from);

                rep_free.animation = animation;

                animation.play();
                // timestamp_animStart = Date.now() - moment;

              }

              function updateAnimationSeamlessly() {
                console.log("updateAnimationSeamlessly");

                if(animation != null) {
                  // console.log("animation before:", animation);

                  animation.pause();
                  // const homeScale_animated__when_paused = {
                  //   X: homeScale_animated.X,
                  //   Y: homeScale_animated.Y,
                  // };
                  // console.log("homeScale_animated__when_paused.X  ", homeScale_animated__when_paused.X);
                  const animated_properties_when_paused = {
                    X: animated_properties.X,
                    Y: animated_properties.Y,
                    orientation: animated_properties.orientation,
                  };
                  console.log("animated_properties_when_paused.X  ", animated_properties_when_paused.X);

                  const timestamp_animStop = Date.now();

                  moment = (timestamp_animStop - timestamp_animStart);
                  console.log("@@@ timestamp_animStart", timestamp_animStart);
                  console.log("@@@ timestamp_animStop ", timestamp_animStop);

                  console.log("@@@ moment", moment);


                  animation.reset();
                  animation = null;

                  // anime.set(homeScale_animated, homeScale_animated__when_paused);
                  // homeScale_animated = homeScale_animated__when_paused;
                  anime.set(animated_properties, animated_properties_when_paused);
                  animated_properties = animated_properties_when_paused;

                  const old1 = from;
                  const old2 = to;
                  var   new1;
                  var   new2;

                  const A = home_properties;
                  const B = {
                    X: infiniteCanvas.scale.X,
                    Y: infiniteCanvas.scale.Y,
                    // orientation: home_properties.orientation + 180,
                    orientation: home_properties.orientation + 3.6 * (home_properties.X / infiniteCanvas.scale.X),
                  };

                  if(old1 == home_properties) {
                    new1 = A;
                    new2 = B;
                  } else {
                    new1 = B;
                    new2 = A;
                  }

                  // animation = createNewSparkleAnimation(old1, homeScale_animated__when_paused, old2, new2, new1);
                  animation = createNewSparkleAnimation(old1, animated_properties_when_paused, old2, new2, new1);
                  rep_free.animation = animation;

                  animation.play();
                  // timestamp_animStart = Date.now() - moment;

                  // console.log("animation after:", animation);
                }
              }




              startAnimation();

              //listen to infiniteCanvas.scale
              infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
                // console.log("infiniteCanvas.scale.X", infiniteCanvas.scale.X);
                // console.log("infiniteCanvas.scale.Y", infiniteCanvas.scale.Y);

                const isPovTooCloseToSparkle = (home_properties.X < infiniteCanvas.scale.X);

                if(isPovTooCloseToSparkle) {
                  if(animation != null) {
                    animation.reset();
                    animation = null;
                  }
                } else {
                  if(animation != null) {
                    updateAnimationSeamlessly();
                  } else {
                    startAnimation();
                  }
                }

              });


            }
        }

        fabricIntegration.addFabricObjectWithIcObj(icObj_representation);
      });

      infiniteCanvas.didAddPureObjectListeners.push((icObj) => {
        fabricIntegration.addFabricObjectWithPureIcObj(icObj);
      });

      infiniteCanvas.onAddRepresented((represented) => {
        console.log("onAddRepresented", represented);

        // if(represented.r_official().type == "composite") {
        //   // console.log("---here---");
        //
        //   const icComposite = represented.r_official();
        // }

        if(represented.r_official().eType != null) {
          // console.log("---here---");

          // const icEngined = represented.r_official();
          const icEngined = represented.r_free();
          // const icEngined = represented.r_engined();     //SHU: maybe one day...


          //initialize (==hydrate)
          const scopeObj = icEngined.getScopeObj(icEngined);
          scopeObj.infiniteCanvas = infiniteCanvas;

          icEngined.engine.initialize(scopeObj);
          console.log("icEngined.engine.awoken.scopeObj.infiniteCanvas, after ", icEngined.engine.awoken.scopeObj.infiniteCanvas);


          //start
          // icEngined.engine.start();
          // icEngined.engine.start(scopeObj);
          icEngined.engine.awoken.start();

        }

      });

      // infiniteCanvas.requestSyncWithIcObjListeners.push((icObj) => {
      //   fabricIntegration.syncWithIcObj(icObj);
      // });


      // const clipboardIntegration = new ClipboardIntegration(fileIntegration, fabricIntegration);

      const keyboardIntegration = new KeyboardIntegration(infiniteCanvas, inputProperties, fileIntegration, fabricIntegration);

      const canvasContainer     = document.getElementsByClassName("canvas-container")[0];
      const mouseIntegration    = new MouseIntegration(canvasContainer, infiniteCanvas, inputProperties, keyboardIntegration);
      // const touchIntegration    = new TouchIntegration(canvasContainer, infiniteCanvas, inputProperties);
      fabricIntegration.mouseIntegration = mouseIntegration;

    </script>


































    <script>

      class Xylophone {

        constructor(infiniteCanvas, base = 10, exponent_min = -5, exponent_max = +5) {
          this.infiniteCanvas = infiniteCanvas;

          this.base         = base;
          this.exponent_min = exponent_min;
          this.exponent_max = exponent_max;

          this.xyloZones    = {};

          this.activeNumber       = 0;
          this.activeNumberString = "0";  //to avoid decimal <-> binary conversion issues  (0.7 != 0.7000000000000001)

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xylophone      = this;
          const infiniteCanvas = this.infiniteCanvas;

          const base         = this.base;
          const exponent_min = this.exponent_min;
          const exponent_max = this.exponent_max;

          const arr_exponent = [...Array(exponent_max - exponent_min + 1).keys()].map(i => (exponent_min + i));

          arr_exponent.forEach((exponent, i) => {

            const xyloZone = new XyloZone(infiniteCanvas, base, exponent);

            this.xyloZones[xyloZone.id] = xyloZone;
            xyloZone.didUpdateListeners.push((xyloZone) => {
              this.updateActiveNumber();
            });
          });

        }

        updateActiveNumber() {
          this.activeNumber = Object.values(this.xyloZones)
                              .map(xyloZone => xyloZone.activeNumber)
                              // .reduce((acc, x) => (acc + x), 0);
                              .reduce((acc, x) => (acc.plus(x)), new Decimal(0));
          // console.log("xylophone::updateActiveNumber", this.activeNumber;
          console.log("xylophone::updateActiveNumber", this.activeNumber.toFixed());

          this.didUpdate();
        }

        didUpdate() {
          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }


        getArr_exponent() {
            return Object.values(this.xyloZones).map(xyloZone => xyloZone.exponent);
        }

        getExponent_min() {
          return Math.min(...this.getArr_exponent());
        }

        getExponent_max() {
          return Math.max(...this.getArr_exponent());
        }

      }

      class XyloZone {

        constructor(infiniteCanvas, base, exponent) {
          this.infiniteCanvas = infiniteCanvas;

          const exponentString = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
          const numberString   = "" + base + "^" + exponentString;

          this.id       = numberString;

          this.base     = base;
          this.exponent = exponent;

          this.xylophoneTowers = {};

          this.icObjects = {};

          // this.activeNumber       = 0;
          this.activeNumber = new Decimal(0);
          this.activeNumberString = "" + this.activeNumber;

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xyloZone = this;

          const infiniteCanvas = this.infiniteCanvas;

          function activeCfgForTower(xylophoneTower) {
            var outCfg;

            outCfg = {
              fill: xylophoneTower.color,
              opacity: 1.0,
            };

            return outCfg;
          }

          function inactiveCfgForTower(xylophoneTower) {
            var outCfg;

            if(xylophoneTower.mantissa == 0) {
              outCfg = {
                fill: '',
                opacity: 1.0,
              };
            } else {
              outCfg = {
                fill: xylophoneTower.color,
                opacity: 0.3,
              };
            }

            return outCfg;
          }

          function createCanvasToggleRectForXylophoneTower(xylophoneTower) {
            const trueRect  = xylophoneTower.trueRect;

            const activeCfg   = activeCfgForTower(xylophoneTower);
            const inactiveCfg = inactiveCfgForTower(xylophoneTower);

            const isActive = false;

            const icToggleRect = infiniteCanvas.createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive);
            icToggleRect.canBeMoved    = false;
            icToggleRect.canBeRotated  = false;
            icToggleRect.canBeResized  = false;
            icToggleRect.canBeSelected = true;

            return icToggleRect;
          }


          const exponent = this.exponent;
          const base     = this.base;

          //zero tower
          {
            const xylophoneTower = new XylophoneTower(0, exponent, base);
            xyloZone.xylophoneTowers[xylophoneTower.mantissa] = xylophoneTower;
            xylophoneTower.didUpdateListeners.push((xylophoneTower, source) => {

              switch(source) {
                // case "view":
                //   //no sync needed
                //   xyloZone.updateWithXylophoneTowerViewUpdate(xylophoneTower);
                //   break;
                case "model":
                  //sync needed
                  xylophoneTower.icObj.isActive = xylophoneTower.isActive;
                  infiniteCanvas.requestViewUpdateForIcObj(xylophoneTower.icObj);
                  break;
              }

            });


            const icToggleRect = createCanvasToggleRectForXylophoneTower(xylophoneTower);
            icToggleRect.canBeSelected = false;

            xylophoneTower.icObj = icToggleRect;

            infiniteCanvas.addIcObject(icToggleRect);

            xylophoneTower.updateIsActive(true, "model");
          }

          //other towers
          [...Array(base - 1).keys()].forEach((item, j) => {
            const mantissa = j + 1;

            const xylophoneTower = new XylophoneTower(mantissa, exponent, base);
            xyloZone.xylophoneTowers[xylophoneTower.mantissa] = xylophoneTower;
            xylophoneTower.didUpdateListeners.push((xylophoneTower, source) => {

              switch(source) {
                case "view":
                  //no sync needed
                  xyloZone.updateWithXylophoneTowerViewUpdate(xylophoneTower);
                  break;
                case "model":
                  //sync needed
                  xylophoneTower.icObj.isActive = xylophoneTower.isActive;
                  infiniteCanvas.requestViewUpdateForIcObj(xylophoneTower.icObj);
                  break;
              }

            });

            const icToggleRect = createCanvasToggleRectForXylophoneTower(xylophoneTower);
            xylophoneTower.icObj = icToggleRect;

            infiniteCanvas.addIcObject(icToggleRect);

            icToggleRect.didUpdateListeners.push((icToggleRect) => {
              xylophoneTower.updateIsActive(icToggleRect.isActive, "view");
            });
          });




          //zone-dedicated objects

          //number text
          {
            const trueRect = this.xylophoneTowers[0].trueRect;

            const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "lol");
            icText.canBeMoved    = false;
            icText.canBeRotated  = false;
            icText.canBeResized  = false;
            icText.canBeSelected = false;

            const scaleFactor = (this.base ** this.exponent);
            console.log("number text, scaleFactor", scaleFactor);

            icText.homeScale = {
              X: icText.homeScale.X / scaleFactor     * 50,
              Y: icText.homeScale.Y / scaleFactor     * 50,
            };

            icText.fill = "yellow";

            this.icObjects["numberDisplay"] = icText;

            infiniteCanvas.addIcObject(icText);


            this.didUpdateListeners.push((xyloZone) => {
              const activeNumberString = xyloZone.activeNumber.toFixed();
              icText.text = activeNumberString;
              // infiniteCanvas.requestViewUpdateForIcObj(icText); //SHU666
            });
          }


        }

        setActiveMantissa(mantissa) {
          const chosenXylophoneTower = this.xylophoneTowers[mantissa];
          chosenXylophoneTower.updateIsActive(true, "model");

          const towers_to_deactivate = Object.values(this.xylophoneTowers).filter(xylophoneTower => xylophoneTower != chosenXylophoneTower);
          towers_to_deactivate.forEach((xylophoneTower, i) => {
            xylophoneTower.updateIsActive(false, "model");
          });

          this.updateActiveNumber();

          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }

        updateWithXylophoneTowerViewUpdate(chosenXylophoneTower) {
          console.log("updateWithXylophoneTowerViewUpdate", chosenXylophoneTower.mantissa);

          //deactivate all others
          const towers_to_deactivate = Object.values(this.xylophoneTowers).filter(xylophoneTower => xylophoneTower != chosenXylophoneTower);
          towers_to_deactivate.forEach((xylophoneTower, i) => {
            xylophoneTower.updateIsActive(false, "model");
          });

          if(chosenXylophoneTower.isActive) {

          } else {
            const zeroXylophoneTower = this.xylophoneTowers[0];
            zeroXylophoneTower.updateIsActive(true, "model");
          }

          this.updateActiveNumber();
        }

        updateActiveNumber() {
          this.activeNumber = Object.values(this.xylophoneTowers)
                              .filter(xylophoneTower => xylophoneTower.isActive)
                              .map(xylophoneTower => xylophoneTower.number)
                              // .reduce((acc, x) => (acc + x), 0);
                              .reduce((acc, x) => (acc.plus(x)), new Decimal(0));
          // console.log("xyloZone::updateActiveNumber", this.activeNumber);
          console.log("xyloZone::updateActiveNumber", this.activeNumber.toFixed());

          this.didUpdate();
        }

        didUpdate() {
          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }

        getTrueRect() {
          const zeroXylophoneTower = this.xylophoneTowers[0];
          return zeroXylophoneTower.trueRect;
        }

      }

      class XylophoneTower {

          constructor(mantissa, exponent, base) {
            const exponentString = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
            const numberString   = "" + mantissa + " x " + base + "^" + exponentString;

            this.id       = numberString;

            this.mantissa = mantissa;
            this.base     = base;
            this.exponent = exponent;

            this.xyloBrickNumber = new XyloBrickNumber(mantissa, exponent, base);

            this.unreliable_number = mantissa * (base ** exponent);
            this.number = null;
            if(base == 10) {
              //'sharp' number (==arbitrary-precision number)
              const decimalNumberFormatString = "" + mantissa + "e" + exponent;
              this.decimal_decimalNumber = new Decimal(decimalNumberFormatString);
              // console.log("this.decimal_decimalNumber", this.decimal_decimalNumber);
              console.log("this.decimal_decimalNumber.toFixed()", this.decimal_decimalNumber.toFixed());


              this.number = this.decimal_decimalNumber;
            } else {
              //SHU TODO: 'sharp management' when base != 10 ...
              //this seems to be linked to the halting problem
              this.number = this.unreliable_number;
            }

            this.successor     = (mantissa + 1) * (base ** exponent);
            // this.successorXyloBrickNumber = ;

            this.trueRect = XylophoneTower.trueRectForTower(this);
            this.color    = XylophoneTower.colorForMantissa(mantissa);

            this.isActive = false;

            this.didUpdateListeners = [];
          }

          updateIsActive(isActive, source) {
            this.isActive = isActive;

            this.didUpdateListeners.forEach((listener, i) => {
              listener(this, source);
            });

          }

          static trueRectForTower(xylophoneTower) {
            var outTrueRect;

            // const BL = {
            //   x: xylophoneTower.number,
            //   y: 0,
            // };
            // const TR = {
            //   x: xylophoneTower.successor,
            //   y: xylophoneTower.number,
            // }

            if(xylophoneTower.mantissa == 0) {
              const mantissa1_number = (xylophoneTower.base ** xylophoneTower.exponent);
              const nextPower_number = (xylophoneTower.base ** (xylophoneTower.exponent + 1));
              const mantissaN_number = nextPower_number - mantissa1_number;

              outTrueRect = {
                x: mantissa1_number,
                width:  nextPower_number - mantissa1_number,

                // y: -nextPower_number,
                // height: nextPower_number,

                y: - mantissaN_number,
                height: mantissaN_number,
              };
            } else {
              outTrueRect = {
                x: xylophoneTower.unreliable_number,
                y: -xylophoneTower.unreliable_number,
                width: (xylophoneTower.base ** xylophoneTower.exponent),
                height: xylophoneTower.unreliable_number,
              };
            }

            return outTrueRect;
          }

          static colorForMantissa(mantissa) {
            var outColor = null;

            switch(mantissa) {
              case 0:
                outColor = "#000000";
                break;

              case 1:
                outColor = "#FF7F0E";
                break;
              case 2:
                outColor = "#2CA02C";
                break;
              case 3:
                outColor = "#D62728";
                break;
              case 4:
                outColor = "#9467BD";
                break;
              case 5:
                outColor = "#8C564B";
                break;
              case 6:
                outColor = "#E377C2";
                break;
              case 7:
                outColor = "#7F7F7F";
                break;
              case 8:
                outColor = "#BCBD22";
                break;
              case 9:
                outColor = "#17BECF";
                break;

              //SHU TODO: colors or patterns for those:
              case 10:  //A
                outColor = "#000000";
                break;
              case 11:  //B
                outColor = "#000000";
                break;
              case 12:  //C
                outColor = "#000000";
                break;
              case 13:  //D
                outColor = "#000000";
                break;
              case 14:  //E
                outColor = "#000000";
                break;
              case 15:  //F
                outColor = "#000000";
                break;

              default:
                throw new Error("unsupported mantissa: " + mantissa);
            }

            return outColor;
          }


      }


      class XyloZonePerception {
      // class XyloZoneDecoration {

        constructor(infiniteCanvas, xyloZone) {
          this.infiniteCanvas = infiniteCanvas;
          this.xyloZone = xyloZone;

          this.trueRect = null;

          this.icObjects = {};

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xyloZonePerception = this;

          const infiniteCanvas = this.infiniteCanvas;

          const xyloZone_trueRect = xyloZonePerception.xyloZone.getTrueRect();

          //listen to xyloZone
          xyloZonePerception.xyloZone.didUpdateListeners.push((xyloZone) => {

          });

        }

        createInfiniteCanvasObjects() {

          function createCanvasToggleRectForXylophonePerception(xylophoneTower) {
            const trueRect  = xylophoneTower.trueRect;

            const activeCfg   = activeCfgForTower(xylophoneTower);
            const inactiveCfg = inactiveCfgForTower(xylophoneTower);

            const isActive = false;

            const icToggleRect = infiniteCanvas.createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive);
            icToggleRect.canBeMoved    = false;
            icToggleRect.canBeRotated  = false;
            icToggleRect.canBeResized  = false;
            icToggleRect.canBeSelected = true;

            return icToggleRect;
          }

        }

        update(xyloZone) {

        }

      }


      class NumberUtils {

        static randomXylophoneNumber(base, exponent_min, exponent_max) {

          const arr_exponent = [...Array(exponent_max - exponent_min + 1).keys()].map(i => (exponent_min + i));

          const arr_xyloBrickNumber = arr_exponent.map(exponent => {
            const mantissa = Math.floor(Math.random() * 10); // returns a random integer from 0 to 9
            const xyloBrickNumber = new XyloBrickNumber(mantissa, base, exponent);
            return xyloBrickNumber;
          });

          const xylophoneNumber = new XylophoneNumber(arr_xyloBrickNumber);

          return xylophoneNumber;
        }

      }

      class XyloBrickNumber {

        constructor(mantissa, base, exponent) {
          this.mantissa = mantissa;
          this.base     = base;
          this.exponent = exponent;

          this.unreliable_number  = mantissa * (base ** exponent);

          // const exponentString  = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
          // const sciNumberString = "" + mantissa + " x " + base + "^" + exponentString;
          // this.sciNumberString  = numberString;
          //
          // this.decimalNumberString = DecimalBrickNumber.decimalNumberString(mantissa, base, exponent);
        }

        toDecimalNumber() {
          var outDecimal;

          if(this.base == 10) {
            //'sharp' number (==arbitrary-precision number)
            const decimalNumberFormatString = "" + this.mantissa + "e" + this.exponent;
            const decimalNumber = new Decimal(decimalNumberFormatString);

            outDecimal = decimalNumber;
          } else {
            //SHU TODO: 'sharp management' when base != 10 ...
            //this seems to be linked to the halting problem
            throw new Error("unsupported for now");
          }

          return outDecimal;
        }

        // static decimalNumberString(mantissa, base, exponent) {
        //
        // }

      }

      class XylophoneNumber {

        constructor(arr_xyloBrickNumber) {

          //check not empty
          const isEmpty = (arr_xyloBrickNumber.length == 0);

          if(isEmpty) {
            throw new Error("arr_xyloBrickNumber.length == 0");
          }

          //check same base for all
          const base       = arr_xyloBrickNumber.find(e => true).base;
          const isSameBase = arr_xyloBrickNumber.every(xyloBrickNumber => (xyloBrickNumber.base == base));

          if(!isSameBase) {
            console.log("arr_xyloBrickNumber", arr_xyloBrickNumber);
            throw new Error("xyloBrickNumbers have different bases");
          }

          this.base = base;
          this.xyloBrickNumbers = arr_xyloBrickNumber.reduce((acc, xyloBrickNumber) => {
            acc[xyloBrickNumber.exponent] = xyloBrickNumber;
            // acc[xyloBrickNumber.exponent] = xyloBrickNumber.mantissa;
            return acc;
          }, {});

          this.unreliable_number = arr_xyloBrickNumber.reduce((acc, x) => (acc + x.unreliable_number), 0);
        }

        toDecimalNumber() {
          return Object.values(this.xyloBrickNumbers).reduce((acc, x) => {
            const xyloBrickDecimal = x.toDecimalNumber();
            return acc.plus(xyloBrickDecimal);
          }, new Decimal(0));
        }

        // filledToUnit() {
        //
        //   function fillNegative() {
        //     const
        //
        //   }
        //
        //   function fillPositive() {
        //
        //   }
        //
        //
        // }

        // toString() {
        //   const str = Object.keys(this.xyloBrickNumbers).reduce((acc, exponent) => {
        //
        //   }, "");
        //   return str;
        // }

        // isEqual(xylophoneNumber2) {
        //   const xylophoneNumber1 = this;
        //   const areEqual = XylophoneNumber.compare(xylophoneNumber1, xylophoneNumber2) == 0;
        //   return areEqual;
        // }
        //
        // static compare(xylophoneNumber1, xylophoneNumber2) {
        //   var outNumber;
        //
        //   const arr_keys_1 = Object.keys(xylophoneNumber1.xyloBrickNumbers);
        //
        //
        //   return outNumber;
        // }

      }




      // const xylophone = new Xylophone(infiniteCanvas, 10);
      const xylophone = null;
      // const xylophone = new Xylophone(infiniteCanvas, 2);    //always a bit confusing

    </script>

    <!-- debug -->
    <!-- <div id="xyloGame_container" style="position:absolute; left:0; bottom: 0; font-size: 60px; pointer-events: none;">
      <div>
        <div style="display: inline-block;">current number: </div>
        <div style="display: inline-block;" id="xyloGame_currentNumber"></div>
      </div>
      <div>
        <div style="display: inline-block;">target number: </div>
        <div style="display: inline-block;" id="xyloGame_targetNumber"></div>
      </div>
      <div>
        <div style="display: inline-block;"></div>
        <div style="display: inline-block;" id="xyloGame_completed"></div>
      </div>
    </div> -->

    <script>
      class XyloGameHUD {
        constructor (eltsDict) {
          this.eltsDict = eltsDict;
        }

        setCurrentNumberString(numberString) {
          this.eltsDict["currentNumber"].innerHTML = numberString;
        }
        setTargetNumberString(numberString) {
          this.eltsDict["targetNumber"].innerHTML = numberString;
        }
        setCompleted(completed) {
          this.eltsDict["completed"].innerHTML = completed ? "Well done !" : "";
        }
      }

      const xyloGameHUD_eltsDict = {
        currentNumber:  document.getElementById("xyloGame_currentNumber"),
        targetNumber:   document.getElementById("xyloGame_targetNumber"),
        completed:      document.getElementById("xyloGame_completed"),
      };
      const xyloGameHUD = new XyloGameHUD(xyloGameHUD_eltsDict);
    </script>


    <script>

    class XylophoneGame1_xyloWrite {

      constructor(xylophone, xyloGameHUD) {
        this.xylophone    = xylophone;
        this.xyloGameHUD  = xyloGameHUD;

        this.targetXylophoneNumber = null;
        this.targetNumber          = null;

        this.initialize();
      }

      initialize() {
        const xylophone   = this.xylophone;
        const xyloGameHUD = this.xyloGameHUD;

        const base         = xylophone.base;
        const exponent_min = xylophone.getExponent_min();
        const exponent_max = xylophone.getExponent_max();
        const targetXylophoneNumber = NumberUtils.randomXylophoneNumber(base, exponent_min, exponent_max);
        // console.log("targetXylophoneNumber", targetXylophoneNumber.toDecimalNumber().toFixed());

        this.targetXylophoneNumber = targetXylophoneNumber;
        this.targetNumber          = targetXylophoneNumber.toDecimalNumber();

        const targetNumberString = this.targetNumber.toFixed();
        xyloGameHUD.setTargetNumberString(targetNumberString);

        const xylophoneNumberString = xylophone.activeNumber.toFixed();
        xyloGameHUD.setCurrentNumberString(xylophoneNumberString);


        xylophone.didUpdateListeners.push((xylophone) => {
          console.log("XylophoneGame1_xyloWrite", "xylophone did update", xylophone);

          // const xylophoneNumberString = xylophone.getActiveNumberString();
          const xylophoneNumberString = xylophone.activeNumber.toFixed();
          console.log("xylophoneNumberString", xylophoneNumberString);
          xyloGameHUD.setCurrentNumberString(xylophoneNumberString);

          const numbersAreEqual = (targetNumberString == xylophoneNumberString);
          xyloGameHUD.setCompleted(numbersAreEqual);
        });
      }

    }

    class XylophoneGame2_xyloRead {

      constructor(infiniteCanvas) {

      }

    }

    if(xylophone != null) {
      const xyloWrite = new XylophoneGame1_xyloWrite(xylophone, xyloGameHUD);
    }

    </script>



    <script>
        class SandBox_doubleObjects {
          constructor(infiniteCanvas) {
            this.infiniteCanvas = infiniteCanvas;

            this.doubleObjects = {};

            this.initialize();
          }

          initialize() {
            const infiniteCanvas = this.infiniteCanvas;

            this.initialize_doubleObjects(infiniteCanvas);

            const arr_doubleObject = Object.values(this.doubleObjects);
            arr_doubleObject.forEach((doubleObject, i) => {
              this.materialize_doubleObject(doubleObject, infiniteCanvas);
            });

          }

          initialize_doubleObjects(infiniteCanvas) {

            //double object #1
            {
              const dO_id        = "dO#1"
              const dO_homeScale = {
                X:2.0,
                Y:2.0,
              };

              const icRect_front = infiniteCanvas.createIcRect_withLTWH(0, 0, 100, 100);
              icRect_front.fill  = "red";
              icRect_front.homeScale = dO_homeScale;

              const icRect_back = infiniteCanvas.createIcRect_withLTWH(0, 0, 100, 100);
              icRect_back.fill = "blue";
              icRect_back.homeScale = dO_homeScale;

              const doubleObject = new DoubleObject(dO_id, icRect_front, icRect_back);

              this.doubleObjects[doubleObject.id] = doubleObject;
            }

            //double object #2
            {
              const dO_id        = "dO#2"
              const dO_homeScale = {
                X:2.0,
                Y:2.0,
              };

              const img_front_p = FileIntegration.imageFromImgSrc_p("");
              const img_back_p  = FileIntegration.imageFromImgSrc_p("");

              const icObj_front = infiniteCanvas.createIcImage(500, 500, img_front);
              icObj_front.homeScale = dO_homeScale;

              const icObj_back = infiniteCanvas.createIcRect_withLTWH(500, 500, 100, 100);
              icObj_back.homeScale = dO_homeScale;

              const doubleObject = new DoubleObject(dO_id, icObj_front, icObj_back);

              this.doubleObjects[doubleObject.id] = doubleObject;
            }

          }

          materialize_doubleObject(doubleObject, infiniteCanvas) {
            const icObj_active = doubleObject.getActiveIcObject();
            infiniteCanvas.addIcObject(icObj_active);

            infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
              doubleObject.updateWithObservationScale(infiniteCanvas.scale);
            });

            doubleObject.didUpdateListeners.push((icObj_old, icObj_new) => {
              // infiniteCanvas.requestViewUpdateForIcObj(icObj);
              infiniteCanvas.removeIcObject(icObj_old);
              infiniteCanvas.addIcObject(icObj_new);
            });

          }

        }

        class DoubleObject {

          constructor(id, icObj_front, icObj_back) {
            this.id = id;

            this.icObj_front = icObj_front;
            this.icObj_back  = icObj_back;

            const factor_scaleToggle = 0.90;
            this.scale_toggle = {
              X: icObj_front.homeScale.X * factor_scaleToggle,
              Y: icObj_front.homeScale.Y * factor_scaleToggle,
            };

            // this.icObj_active = null;
            this.icObj_active = icObj_front;

            this.didUpdateListeners = [];
          }

          getActiveIcObject() {
            return this.icObj_active;
          }

          updateWithObservationScale(scale_obs) {
            console.log("updateWithObservationScale", scale_obs);

            const icObj_active = this.getIcObjectForObservationScale(scale_obs);

            this.setActiveIcObject(icObj_active);
          }

          getIcObjectForObservationScale(scale_obs) {
            var outIcObj;

            const isFar = scale_obs.X < this.scale_toggle.X && scale_obs.Y < this.scale_toggle.Y;

            if(isFar) {
              outIcObj = this.icObj_front;
            } else {
              outIcObj = this.icObj_back;
            }

            return outIcObj;
          }

          setActiveIcObject(icObj_new) {

            const icObj_old = this.icObj_active;

            if(icObj_new != icObj_old) {
              this.icObj_active = icObj_new;

              this.didUpdateListeners.forEach((listener, i) => {
                listener(icObj_old, icObj_new);
              });
            }

          }

          // didUpdate() {
          //
          // }



        }

        class ManyAnObject {

        }

        // const sandBox_doubleObjects = new SandBox_doubleObjects(infiniteCanvas);

    </script>


    <script>
        class SandBox_sparkles {
          constructor(infiniteCanvas) {
            this.infiniteCanvas = infiniteCanvas;

            this.objects = {};

            this.initialize();
          }

          initialize() {
            const infiniteCanvas = this.infiniteCanvas;

            this.initialize_objects(infiniteCanvas);

            const arr_objects = Object.values(this.objects);
            arr_objects.forEach((object, i) => {
              this.materialize_object(object, infiniteCanvas);
            });

          }

          initialize_objects(infiniteCanvas) {

            //sparkle #1
            {
              const dO_id        = "dO#1"
              const dO_homeScale = {
                X:20.0,
                Y:20.0,
              };

              const img_sparkle = "lol";
              const icObj = infiniteCanvas.createIcImage(500, 500, img_sparkle);  //SHU: formally, sparkle could hold any icObject or even more complicated type
              icObj.homeScale = dO_homeScale;                                     //     sparkle can hold any "representable" object

              const sparkle = new Sparkle(dO_id, icObj);
              sparkle.obsScale = infiniteCanvas.scale;

              this.sparkles[sparkle.id] = sparkle;
            }

          }

          materialize_object(object, infiniteCanvas) {

            const sparkle = object;

            const icObj = sparkle.icObj;
            infiniteCanvas.addIcObject(icObj);

            infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
              sparkle.updateWithObservationScale(infiniteCanvas.scale);
            });

            sparkle.didUpdateListeners.push((sparkle) => {
              const icObj = sparkle.icObj;
              infiniteCanvas.requestViewUpdateForIcObj(icObj);
            });

          }

        }

        class Sparkle {

          constructor(id, icObj) {
            this.id = id;

            this.icObj = icObj;

            this.homeScale = Object.assign({}, icObj.homeScale);
            this.obsScale  = null;

            this.didUpdateListeners = [];
          }

          updateWithObservationScale(scale_obs) {
            console.log("updateWithObservationScale", scale_obs);
            icObj.homeScale = scale_obs;
          }

          static default_sparkleImage_p() {
            const imageName = "sparkle_gradient.png";



          }

        }

        // const sandBox_sparkles = new SandBox_sparkles(infiniteCanvas);

    </script>

    <script>
        class ZPuzzle {
          constructor(infiniteCanvas) {
            this.infiniteCanvas = infiniteCanvas;

            this.objects = {
              slots:  {},
              pieces: {},
            };

            this.initialize();
          }

          initialize() {
            const infiniteCanvas = this.infiniteCanvas;

            this.initialize_objects(infiniteCanvas);

            const arr_slots = Object.values(this.objects.slots);
            arr_slots.forEach((slot, i) => {
              this.materialize_slot(slot, infiniteCanvas);
            });

            const arr_pieces = Object.values(this.objects.pieces);
            arr_pieces.forEach((piece, i) => {
              this.materialize_piece(piece, infiniteCanvas);

              const slot = this.objects.slots[piece.id];
              this.bindSlotAndPiece(slot, piece);
            });

          }

          initialize_objects(infiniteCanvas) {

            //s/p #1
            {
              const id = "id_sp1";
              const icObj = infiniteCanvas.createIcRect_withLTWH(500, 500, 500 , 500);
              icObj.fill = ZPuzzle.colorForNumber(1);

              const slotAndPiece = ZPuzzle.debugSlotAndPiece(id, icObj);
              this.objects.slots[id]  = slotAndPiece.slot;
              this.objects.pieces[id] = slotAndPiece.piece;
              slotAndPiece.piece.icObj.position = {
                x: slotAndPiece.piece.icObj.position.x + 600,
                y: slotAndPiece.piece.icObj.position.x + 100,
              };
            }

          }



          materialize_slot(slot, infiniteCanvas) {

            const icObj = slot.icObj;
            infiniteCanvas.addIcObject(icObj);

            // infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
            //   sparkle.updateWithObservationScale(infiniteCanvas.scale);
            // });

            // sparkle.didUpdateListeners.push((sparkle) => {
            //   const icObj = sparkle.icObj;
            //   infiniteCanvas.requestViewUpdateForIcObj(icObj);
            // });

          }

          materialize_piece(piece, infiniteCanvas) {

            const icObj = piece.icObj;
            infiniteCanvas.addIcObject(icObj);

            // infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
            //   sparkle.updateWithObservationScale(infiniteCanvas.scale);
            // });

            // sparkle.didUpdateListeners.push((sparkle) => {
            //   const icObj = sparkle.icObj;
            //   infiniteCanvas.requestViewUpdateForIcObj(icObj);
            // });

          }

          bindSlotAndPiece(slot, piece) {
            piece.didUpdateListeners.push((piece) => {
              console.log("piece, didUpdate");

              console.log("piece.isSnapped:", piece.isSnapped);

              if(!piece.isSnapped) {
                slot.attemptSnapping(piece);
              } else {
                // slot.attemptUnsnapping(piece);
              }

            });
          }


          static debugSlotAndPiece(spid, icObj) {
            // const icObj_slot  = icObj.clone();


            // const icObj_slot = backingObj.inner;
            // const backingObj = BackingObject.fromObject(icObj);
            // const icObj_slot = backingObj.getNewRepresentation();
            const icObj_slot = RepresentationFactory.initial(icObj);
            icObj_slot.addOnOuterUpdate((icObj_slot) => {
              console.log("icObj_slot","onOuterUpdate", icObj_slot);

            });

            icObj_slot.opacity = 0.2;
            const slot = new ZPuzzleSlot(spid, icObj_slot);

            // const icObj_piece = icObj.clone();
            // const icObj_piece = backingObj.getNewRepresentation();
            const icObj_piece = RepresentationFactory.initial(icObj);
            icObj_piece.addOnOuterUpdate((icObj_piece) => {
              console.log("icObj_piece","onOuterUpdate", icObj_piece);

            });


            //debug
            ///////////////////////
            // icObj_piece.createSisterRepresentation().addOnOuterUpdate((icObj_piece) => {
            //   console.log("icObj_piece sister rep","onOuterUpdate", icObj_piece);
            //
            // });
            //
            // setTimeout(() => {
            //   console.log("setTimeout", "update icObj_piece.position");
            //   icObj_piece.position = {
            //     x: icObj_piece.position.x + 100,
            //     y: icObj_piece.position.y + 100,
            //   };
            // }, 3000);
            //
            // setTimeout(() => {
            //   console.log("setTimeout", "update icObj_piece.position");
            //   icObj_piece.position = {
            //     x: icObj_piece.position.x + 100,
            //     y: icObj_piece.position.y + 100,
            //   };
            // }, 8000);
            ////////////////////////


            const piece = new ZPuzzlePiece(spid, icObj_piece);

            const slotAndPiece = {
              slot: slot,
              piece: piece,
            };

            return slotAndPiece;
          }

          static colorForNumber(number) {
            var outColor;

            switch(number) {
              case 1:
                outColor = "#FF7F0E";
                break;
              case 2:
                outColor = "#2CA02C";
                break;
              case 3:
                outColor = "#D62728";
                break;
              case 4:
                outColor = "#9467BD";
                break;
              case 5:
                outColor = "#8C564B";
                break;
              case 6:
                outColor = "#E377C2";
                break;
              case 7:
                outColor = "#7F7F7F";
                break;
              case 8:
                outColor = "#BCBD22";
                break;
              case 9:
                outColor = "#17BECF";
                break;

              default:
                outColor = "#000000";
                break;
            }

            return outColor;
          }

        }

        class ZPuzzleSlot {

          constructor(id, icObj) {
            this.id = id;

            // this.type = "typeA";

            this.icObj = icObj;

            // this.didUpdateListeners = [];
          }

          attemptSnapping(piece) {
            console.log("attemptSnapping", piece);

            const canSnap = this.checkCanSnap(piece);

            if(canSnap) {
              console.log("can snap");
              this.snap(piece);
            } else {
              console.log("can't snap");
            }

          }

          checkCanSnap(piece) {
            var outBool;

            const slot = this;

            // const isSameType = (piece.type == slot.type);
            // if(!isSameType) {
            //   return false;
            // }

            const isSlotAllowedForPiece = piece.isAllowedSlot(slot);
            if(!isSlotAllowedForPiece) {
              return false;
            }

            const icObj_slot  = slot.icObj;
            const icObj_piece = piece.icObj;

            outBool = Snap.canSnap(icObj_piece, icObj_slot);

            return outBool;
          }

          snap(piece) {
            console.log("Zslot", "snap", piece);

            piece.isSnapped = true;


            const icObj_slot  = this.icObj;
            const icObj_piece = piece.icObj;

            const icObj_new = Object.assign({}, icObj_piece);
            icObj_new.position     = Object.assign({}, icObj_slot.position);
            icObj_new.homeScale    = Object.assign({}, icObj_slot.homeScale);
            icObj_new.scale        = Object.assign({}, icObj_slot.scale);
            icObj_new.orientation  = icObj_slot.orientation;

            icObj_piece.update(icObj_new, "model");
          }

        }

        class ZPuzzlePiece {

          constructor(id, icObj) {
            this.id = id;

            this.icObj = icObj;

            this.isSnapped = false;

            this.didUpdateListeners = [];

            icObj.didUpdateListeners.push((icObj) => {
              console.log("ZPuzzlePiece", "icObj didUpdate", icObj);
              this.didUpdate();
            })
          }

          didUpdate() {
            this.didUpdateListeners.forEach((listener, i) => {
              listener(this);
            });
          }

          isAllowedSlot(slot) {
            var outBool;
            const piece = this;

            const isSameId = (slot.id == piece.id);
            outBool = isSameId;

            return outBool;
          }

        }






        // const zPuzzle_4pieces = ZPuzzle.default_4pieces(infiniteCanvas);
        // const zPuzzle_4pieces = new ZPuzzle(infiniteCanvas);

    </script>



    <script>

      class GolfGame1 {

        constructor(infiniteCanvas, golfGame1Config) {

          this.name    = golfGame1Config.name;

          //create objects (courses)
          this.courses = Object.entries(golfGame1Config.golfCourses).reduce((acc, [golfCourseName, golfCourseConfig]) => {

            const golfCourse    = new GolfCourse(infiniteCanvas, golfCourseConfig);

            acc[golfCourseName] = golfCourse;

            return acc;
          }, {});


          //add logic
            //segues
          const zip = (a, b) => a.map((k, i) => [k, b[i]]);

          const arr_courses        = Object.values(this.courses);
          const arr_courses_from   = arr_courses.slice(0, -1);
          const arr_courses_to     = arr_courses.slice(1);
          const arr_courses_zipped = zip(arr_courses_from, arr_courses_to);

          this.arr_segues = arr_courses_zipped.map(([course_from, course_to]) => {
            const segueConfig = {};
            const segue = new GolfSegue(infiniteCanvas, segueConfig, course_from, course_to);
            return segue;
          });

            //steps
          // logger.log("golfGame1Config.steps", golfGame1Config.steps);
          this.steps = Object.entries(golfGame1Config.steps)
                       .filter(([stepName, stepConfig]) => (stepName != "begin" && stepName != "end"))
                       .reduce((acc, [stepName, stepConfig], i) => {

                          const golfCourseName = stepConfig.golfCourseName;
                          const golfCourse     = this.courses[golfCourseName];

                          const segue = this.arr_segues[i];
                          console.log("segue", segue);

                          const step    = new GolfStep(infiniteCanvas, stepConfig, golfCourse, segue);
                          acc[stepName] = step;

                          return acc;
                        }, {});



        }

        static fromJson(json_golfGame) {

        }














        static mini_gameConfig_9() {
          return {
            name: "Parcours entiers relatifs",
            challenges: [
              "11,+ 5,- 2,x 7,/ 2,78;4",
              "19,+ 1,- 9,x 6,/ 4,30;3",
              "24,+ 1,- 1,x 7,/ 2,90;5",
              "51,+ (-1),- (-1),x (-7),/ 4,-91;3",
              "-9,+ 8,- 5,x (-3),/ (-2),46;5",
              "20,+ 1,- 7,x 9,/ 3,42;4",
              "1,+ 2,- 5,x 7,/ 2,-7;4",
              "20,+ 4,- 6,x 6,/ 4,21;3",
              "64,+ 8,- 2,x 5,/ 2,85;5",
            ],
          };
        }

        static gameConfig_9() {
          var outConfig;

          const mini_gameConfig_9 = GolfGame1.mini_gameConfig_9();
          const name              = mini_gameConfig_9.name;

          const arr_golfStepMiniString = mini_gameConfig_9.challenges;
          // const arr_golfCourseString = GolfGame1.arr_game_9().map(str => str.split(";")[0]);

          const courseConfig_begin = GolfCourseConfig.instance_begin();
          const courseConfig_end   = GolfCourseConfig.instance_end();

          const config = arr_golfStepMiniString.reduce((acc, golfStepMiniString, index) => {

            const arr_str_components = golfStepMiniString.split(";");
            const golfCourseMiniString     = arr_str_components[0];
            const golfStepConfigMiniString = arr_str_components[1];

            const courseConfig = GolfCourseConfig.challengeCourseConfig_fromMiniString(golfCourseMiniString);
            courseConfig.rect.x = (courseConfig_begin.rect.x + 2000) + index * 2000;

            const courseName = "" + index;
            acc.golfCourses[courseName] = courseConfig;


            const par = golfStepConfigMiniString;
            const componentSpecs = {
              "tee": {
                ammo: 8,        //SHU: tee ammo ^^
              },
            };
            const stepConfig = new GolfStepConfig("challenge", courseName, par, componentSpecs);

            acc.steps[index] = stepConfig;

            return acc;
          }, {
            name: name,
            golfCourses: {
              "begin": courseConfig_begin,
              "end":   courseConfig_end,
            },
            steps: {
              "begin": GolfStepConfig.step_begin("begin"),
              "end":   GolfStepConfig.step_end("end"),
            },
          });

          // const miniDict__golfCourses_begin_end = {
          //   "begin": courseConfig_begin,
          //   "end":   courseConfig_end,
          // };
          //
          // const miniDict__steps_begin_end = {
          //   "begin": GolfStepConfig.step_begin("begin"),
          //   "end":   GolfStepConfig.step_end("end"),
          // };

          config.golfCourses["end"].rect.x = config.golfCourses["8"].rect.x + 2000;   //SHU: buark


          outConfig = config;

          return outConfig;
        }

        static seriousInstance(infiniteCanvas) {
          var out;

          const golfGame1Config = GolfGame1.gameConfig_9();

          out = new GolfGame1(infiniteCanvas, golfGame1Config);

          return out;
        }

      }

      class GolfObject {

        constructor(type, icObj) {
          this.type  = type;
          this.icObj = icObj;
        }

      }


      class GolfCourseConfig {

        constructor(rect, componentsConfig) {
          this.rect = rect;
          this.componentsConfig = componentsConfig;
        }

        static instance_begin(titleString) {
          var outCourseConfig;

          const courseConfig = GolfCourseConfig.template_begin();

          courseConfig.components.title.config.text = titleString;

          outCourseConfig = courseConfig;

          return outCourseConfig;
        }

        static instance_end(titleString) {
          var outCourseConfig;

          const courseConfig = GolfCourseConfig.template_end();

          courseConfig.components.title.config.text = titleString;

          outCourseConfig = courseConfig;

          return outCourseConfig;
        }

        // static instance_challenge() {
        //
        // }

        static template_begin() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
              },
              rect_rel: {
                l: 0.0,
                r: 1.0,
                t: 0.0,
                b: 1.0,
              },
            },

            "title": {
              type: "rect",
              zIndex: 0,
              config: {
                // fill: "green",
                fill: "almond",
                text: "<title>",
              },
              rect_rel: {
                l: 0.2,
                r: 0.8,
                t: 0.2,
                b: 0.4,
              },
            },

            "button_start": {
              type: "button",
              zIndex: 20,
              config: {
                // fill: "green",
                fill: "almond",
                text: "<start>",
              },
              rect_rel: {
                l: 0.2,
                r: 0.8,
                t: 0.6,
                b: 0.8,
              },
            },
          };

          const config = {
            rect: {
              x:           0,
              y:           0,
              width:    1600,
              height:   1000,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }

        static template_end() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                fill: "orange",

              },
              rect_rel: {
                l: 0.0,
                r: 1.0,
                t: 0.0,
                b: 1.0,
              },
            },

            "title": {
              type: "rect",
              zIndex: 0,
              config: {
                // fill: "green",
                fill: "almond",
                text: "<title>",
              },
              rect_rel: {
                l: 0.2,
                r: 0.8,
                t: 0.2,
                b: 0.4,
              },
            },

            "total_score": {
              type: "labelValue",
              zIndex: 0,
              config: {
                // fill: "green",
                fill: "almond",
                text: "total score:",
              },
              rect_rel: {
                l: 0.3,
                r: 0.7,
                t: 0.3,
                b: 0.5,
              },
            },

            "total_par": {
              type: "labelValue",
              zIndex: 0,
              config: {
                // fill: "green",
                fill: "almond",
                text: "total par:",
              },
              rect_rel: {
                l: 0.3,
                r: 0.7,
                t: 0.5,
                b: 0.8,
              },
            },

            // "medal": {
            //   type: "img",
            //   zIndex: 0,
            //   config: {
            //     // fill: "green",
            //     fill: "almond",
            //   },
            //   rect_rel: {
            //     l: 0.7,
            //     r: 0.9,
            //     t: 0.3,
            //     b: 0.6,
            //   },
            // },

          };

          const config = {
            rect: {
              x:           0,
              y:           0,
              width:    1600,
              height:   1000,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }

        static template_challenge() {
          var outConfig;

          const components = {
            "bg": {
              type: "rect",
              zIndex: -10,
              config: {
                // fill: "green",
                // fill: "lightgreen",
                // fill: "orange",
                fill: "lightyellow",
              },
              rect_rel: {
                l: 0.0,
                r: 1.0,
                t: 0.0,
                b: 1.0,
              },
            },

            "tee": {
              type: "rect",
              zIndex: 100,
              config: {
                fill: "lightgreen",
              },
              rect_rel: {
                l: 0.05,
                r: 0.15,
                t: 0.40,
                b: 0.50,
              },
            },

            // "bumpers": {
              "bumper1": {
                type: "gm_operator",
                zIndex: 51,
                config: {
                  operatorString: "+ 1",
                },
                rect_rel: {
                  l: 0.15,
                  r: 0.25,
                  t: 0.80,
                  b: 0.90,
                },
              },
              "bumper2": {
                type: "gm_operator",
                zIndex: 52,
                config: {
                  operatorString: "+ 10",
                },
                rect_rel: {
                  l: 0.35,
                  r: 0.45,
                  t: 0.80,
                  b: 0.90,
                },
              },
              "bumper3": {
                type: "gm_operator",
                zIndex: 53,
                config: {
                  operatorString: "x 2",
                },
                rect_rel: {
                  l: 0.55,
                  r: 0.65,
                  t: 0.80,
                  b: 0.90,
                },
              },
              "bumper4": {
                type: "gm_operator",
                zIndex: 54,
                config: {
                  operatorString: "x (-1)",
                },
                rect_rel: {
                  l: 0.75,
                  r: 0.85,
                  t: 0.80,
                  b: 0.90,
                },
              },
            // },

            "hole": {
              type: "gm_targetTouchSlot",
              zIndex: 10,
              config: {
                value: -48,
              },
              rect_rel: {
                l: 0.85,
                r: 0.95,
                t: 0.40,
                b: 0.50,
              },
            },
          };

          const config = {
            rect: {
              x:           0,
              y:           0,
              width:    1600,
              height:   1000,
            },
            components: components,
          };

          outConfig = config;

          return outConfig;
        }



        static challengeCourseConfigMiniObj_fromMiniString(challengeCourseMiniString) {

          const arr_courseStringComponent = challengeCourseMiniString.split(",");
          const nb_compoments = arr_courseStringComponent.length;

          const courseConfigMiniObj = arr_courseStringComponent.reduce((acc, x, i) => {

            const componentString = x;

            switch(i) {
              case 0:
                const initial = parseInt(componentString);
                acc["initial"] = initial;
                break;
              case (nb_compoments - 1):
                const target = parseInt(componentString);
                acc["target"] = target;
                break;
              default:
                const operatorString = componentString;
                if(acc["operators"] == null) {
                  acc["operators"] = [];
                }
                acc["operators"].push(operatorString);
                break;
            }

            return acc;
          }, {});

          return courseConfigMiniObj;
        }


        static challengeCourseConfig_fromMiniString(courseMiniString) {
          var outCourseConfig;

          const courseConfigMiniObj = GolfCourseConfig.challengeCourseConfigMiniObj_fromMiniString(courseMiniString);

          const courseConfig = GolfCourseConfig.template_challenge();

          // courseConfig.components.ball.config.value = courseConfigMiniObj.initial;
          courseConfig.components.hole.config.value = courseConfigMiniObj.target;

          //SHU TODO: remove this ugliness
          // const entries_bumper = Object.entries(courseConfig.components).filter(([componentName, component]) => componentName.startsWith("bumper"));
          const entries_bumper = Object.entries(courseConfig.components).filter(([componentName, component]) => component.type == "gm_operator");
          entries_bumper.forEach(([componentName, component], i) => {
            component.config.operatorString = courseConfigMiniObj.operators[i];
          });

          outCourseConfig = courseConfig;

          return outCourseConfig;
        }

      }


      class GolfCourse {

        constructor(infiniteCanvas, golfCourseConfig) {
          console.log("GolfCourse, constructor", golfCourseConfig);
          this.infiniteCanvas = infiniteCanvas;

          this.rect = golfCourseConfig.rect;

          // this.components =
          const components = Object.entries(golfCourseConfig.components).reduce((acc, [componentName, componentConfig]) => {
            // logger.log("componentName", componentName);

            const icObj = this.createIcObjForComponent(infiniteCanvas, componentConfig);
            infiniteCanvas.addIcObject(icObj);

            const represented = infiniteCanvas.getRepresented(icObj.id);
            const rep_free    = represented.r_free();

            const component = new GolfObject(componentConfig.type, rep_free);

            acc[componentName] = component;

            return acc;
          }, {});
          this.components = components;
        }


        createIcObjForComponent(infiniteCanvas, componentConfig) {
          console.log("createIcObjForComponent", componentConfig);
          var outIcObj;

          const rect_rel__component = componentConfig.rect_rel;
          const trueRect__component = Geometry.rectForRectRel(this.rect, rect_rel__component);

          switch(componentConfig.type) {
            case "rect":
              {
              const config = componentConfig.config;
              const fill   = config.fill;
              outIcObj = infiniteCanvas.createIcRect(trueRect__component);
              outIcObj.fill = fill;
              }
              break;
            case "gm_clickWell":
              {
              const config = componentConfig.config;
              const value  = config.value;
              // outIcObj = infiniteCanvas.createIcGMClickWell(trueRect__component, value);
              outIcObj = infiniteCanvas.createIcBornAgainGreenMouse(trueRect__component, value);
              }
              break;
            case "gm_operator":
              {
              const config         = componentConfig.config;
              const operatorString = config.operatorString;
              outIcObj = infiniteCanvas.createIcGMOperator(trueRect__component, operatorString);
              }
              break;
            case "gm_targetTouchSlot":
              {
              const config = componentConfig.config;
              const value  = config.value;
              outIcObj = infiniteCanvas.createIcGMTargetTouchSlot(trueRect__component, value);
              // outIcObj = infiniteCanvas.createIcGMBoxTargetTouchSlot(trueRect__component, value);
              // outIcObj = infiniteCanvas.createIcGMBlob(trueRect__component, value);
              }
              break;


            case "button":
              {
              const config = componentConfig.config;
              const fill   = config.fill;
              outIcObj = infiniteCanvas.createIcButton(trueRect__component);
              outIcObj.fill = fill;
              }
              break;

            case "labelValue":
              {
              const config = componentConfig.config;
              const fill   = config.fill;
              const text   = config.text;
              outIcObj = infiniteCanvas.createIcLabelValue(trueRect__component, text, 0);
              outIcObj.fill = fill;
              }
              break;

            // case "img":
            //   {
            //   const config = componentConfig.config;
            //   const fill   = config.fill;
            //   const text   = config.text;
            //   outIcObj = infiniteCanvas.createIcImage(trueRect__component, null);
            //   outIcObj.fill = fill;
            //   }
            //   break;


            default:
              throw new Error("unsupported type: " + componentConfig.type);
              break;
          }

          //common props
          const zIndex = componentConfig.zIndex;
          outIcObj.zIndex = zIndex;

          return outIcObj;
        }

        fillHole() {
          const icObj_hole = this.components["hole"].icObj;
          // icObj_hole.parts["facade"].fill = "yellow";
          icObj_hole.parts["touchSlot"].fill = "yellow";
        }

        freeHole() {
          const icObj_hole = this.components["hole"].icObj;
          // icObj_hole.parts["facade"].fill = "yellow";
          icObj_hole.parts["touchSlot"].fill = "";
        }


        mutateIntoScoreLabel(score) {

          const golfCourse     = this;
          const infiniteCanvas = this.infiniteCanvas;

          //remove almost all golfCourse components
          // Object.entries(golfCourse.components)
          // .filter(([componentName, component]) => {
          //   return (componentName != "bg");
          // })
          // .forEach(([componentName, component], i) => {
          //   const icObj = component.icObj;
          //
          //   // icObj.im_dying_now = true;
          //   // infiniteCanvas.removeIcObject(icObj);
          //
          //   const represented = icObj.represented;
          //   infiniteCanvas.removeRepresented(represented, true);
          // });

          //change bg color
          const icObj_bg = golfCourse.components["bg"].icObj;

          // function colorForScore(score) {
          //   var outColor;
          //
          //   switch(score.medal) {
          //     case "bronze":
          //     outColor = "bronze";
          //     break;
          //     case "silver":
          //     outColor = "silver";
          //     break;
          //     case "gold":
          //     outColor = "gold";
          //     break;
          //   }
          //
          //   return outColor;
          // }
          icObj_bg.fill = "gold";

          //add score label
          const rect__scoreLabel = {
            x:      golfCourse.rect.x,
            y:      golfCourse.rect.y,
            width:  golfCourse.rect.width,
            height: golfCourse.rect.height,
          };
          const scoreLabel = infiniteCanvas.createIcText(rect__scoreLabel.x, rect__scoreLabel.y, "" + score);     //SHU TODO: createIcLabel(trueRect, text)
          infiniteCanvas.addIcObject(scoreLabel);


        }

      }

      class GolfStepConfig {
        constructor(type, golfCourseName, par, componentSpecs) {
          this.type = type;

          this.golfCourseName = golfCourseName;
          this.par = par;

          this.componentSpecs = componentSpecs;
        }

        static step_begin(golfCourseName) {
          const type = "begin";
          const stepConfig = new GolfStepConfig(type, golfCourseName);
          return stepConfig;
        }

        static step_end(golfCourseName) {
          const type = "end";
          const stepConfig = new GolfStepConfig(type, golfCourseName);
          return stepConfig
        }

      }

      class GolfStep {

        constructor(infiniteCanvas, golfStepConfig, golfCourse, segue) {
          // logger.log("GolfStep::constructor", golfStepConfig, golfCourse, segue);

          this.infiniteCanvas = infiniteCanvas;
          // this.golfStepConfig = golfStepConfig;
          this.golfCourse     = golfCourse;
          this.segue          = segue;

          this.configure(golfStepConfig);

          this.invest(golfCourse);

          this.possess(golfCourse);
        }

        configure(golfStepConfig) {
          this.par = golfStepConfig.par;
        }

        invest(golfCourse) {

          const step = this;

          //add objects
          {
            const infiniteCanvas = this.infiniteCanvas;

              //add label/value: score
            function addLabel_score() {
              const rect__score = golfCourse.rect;
              rect__score.width  = 300;
              rect__score.height = 150;

              const string__score = "score:";
              const value__score  = 0;

              const icObj__score  = infiniteCanvas.createIcLabelValue(rect__score, string__score, value__score);
              icObj__score.zIndex = 200;

              infiniteCanvas.addIcObject(icObj__score);

              const rep_free__score_valueLabel = infiniteCanvas.getRepresented(icObj__score.id).r_free();
              step.rep_free__score_valueLabel  = rep_free__score_valueLabel;
              step.rep_free__score_value       = rep_free__score_valueLabel.parts["value"];
            }
            addLabel_score();

              //add label/value: par
            function addLabelValue_par() {
              const rect__par = {
                x: step.rep_free__score_valueLabel.position.x,
                y: step.rep_free__score_valueLabel.position.y + 120,
                width:  300,
                height: 150,
              };

              const string__par = "par:";
              const value__par  = step.par;

              const icObj__par = infiniteCanvas.createIcLabelValue(rect__par, string__par, value__par);
              icObj__par.zIndex = 201;

              infiniteCanvas.addIcObject(icObj__par);

              const rep_free__par_valueLabel = infiniteCanvas.getRepresented(icObj__par.id).r_free();
              step.rep_free__par_valueLabel  = rep_free__par_valueLabel;
              step.rep_free__par_value       = rep_free__par_valueLabel.parts["value"];

              setTimeout(() => {
                step.rep_free__par_value.position = {
                  x: step.rep_free__score_value.position.x,
                  y: step.rep_free__par_value.position.y,
                };
              }, 20);   //SHU TODO: remove this ugliness
            }
            addLabelValue_par();



              //add button: restart
          }


          //invest: "this is mine now"
          {
            step.rep_free__ball = golfCourse.components["ball"].icObj;
            // this.rep_free__ball = golfCourse.components["ball"].icObj;
            step.rep_free__hole = golfCourse.components["hole"].icObj;
          }

        }

        possess(golfCourse) {
          this.initializeCompletionListeners();

          this.setupAttemptListeners(golfCourse);

          this.setupCompletionTrigger(golfCourse);
          this.addCompletionListener(golfCourse);
        }

        initializeCompletionListeners() {
          // this.nb_attempts = 0;
          this.arr_attempt = [];

          this.listeners_completed = [];

          this.onCompleted  = (listener) => {
            this.listeners_completed.push(listener);
          };
          this.offCompleted = (listener) => {
            this.listeners_completed = Utils.arrayByRemovingElement(this.listeners_completed, listener);
          };
          this.nowCompleted = () => {
            this.listeners_completed.forEach((listener, i) => {
              listener(this);
            });
          };
        }

        setupAttemptListeners(golfCourse) {   //SHU: this is where BigBrother sneaked in from

          const step = this;

          function waitForNewAttempt() {
            const ball__rep_free = golfCourse.components["ball"].icObj;

            const createAttemptFunc = () => {

                const attempt = new GolfStepAttempt();

                step.arr_attempt.push(attempt);

                ball__rep_free.offHold(createAttemptFunc);
            };

            ball__rep_free.onHold(createAttemptFunc);
          }

          //gm.onHold(create attempt)
          {
            waitForNewAttempt();
          }

          //gm.onTouched(add event to attempt)
          {

          }

          //gm.onRelease(finalize attempt)
          {
            const ball__rep_free = golfCourse.components["ball"].icObj;

            ball__rep_free.onRelease(waitForNewAttempt);
          }

          //create attempt






          //course use listeners

          function listenToOperatorTouches(icObj__rep_free) {

            const touchSlot__rep_free  = icObj__rep_free.parts["touchSlot"];
            // logger.log("touchSlot__rep_free", touchSlot__rep_free);

            const touchSlotEngine = touchSlot__rep_free.engine;

            Hooker.installHooks(touchSlotEngine.awoken, "touch");
            touchSlotEngine.awoken.did["touch"].on((...args) => {
              // logger.log("did touch", ...args);

              // counter += 1
              const attempt = step.getCurrentAttempt();
              // logger.log("attempt", attempt);
              attempt.manoeuvre.nb_touched += 1;

              //debug
              step.rep_free__score_value.text = "" + attempt.manoeuvre.nb_touched;
            });

          }

          const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_operator");

          arr_gm_operator.forEach((gm_operator, i) => {
            const icObj__rep_free = gm_operator.icObj;
            listenToOperatorTouches(icObj__rep_free);
          });

        }

        setupCompletionTrigger(golfCourse) {

          const targetTouchSlot__rep_free = golfCourse.components["hole"].icObj;

          const touchSlot__rep_free = targetTouchSlot__rep_free.parts["touchSlot"];

          const touchSlotEngine = touchSlot__rep_free.engine;

          Hooker.installHooks(touchSlotEngine.awoken, "touch");
          touchSlotEngine.awoken.did["touch"].on((...args) => {
            // logger.log("did touch", ...args);

            this.nowCompleted();
          });

        }

        addCompletionListener(golfCourse) {

          const step = this;

          this.onCompleted((golfStep) => {
            // console.log("step, onCompleted", golfStep);
            // logger.log("step, onCompleted", golfStep);

            /*
            const score = golfStep.arr_attempts.length;
            golfCourse.mutateIntoScoreLabel(score);
            */

            step.segue.play(golfStep);
          });

        }

        getCurrentAttempt() {
          return this.arr_attempt[this.arr_attempt.length - 1];
        }


      }

      class GolfStepAttempt {

        constructor() {
          this.evolution = new GolfStepAttemptEvolution();
          this.manoeuvre = new GolfStepAttemptManoeuvre();
        }

      }

      class GolfStepAttemptEvolution {

        constructor() {
          this.nb_touched = 0;
        }

      }

      class GolfStepAttemptManoeuvre {

        constructor() {
          this.nb_touched = 0;
        }

      }


      class GolfSegue {

        constructor(infiniteCanvas, golfSegueConfig, golfCourse_from, golfCourse_to) {
          this.infiniteCanvas = infiniteCanvas;

          this.golfSegueConfig = golfSegueConfig;
          this.configure(golfSegueConfig);

          this.golfCourse_from = golfCourse_from;
          this.golfCourse_to   = golfCourse_to;
        }

        configure(golfSegueConfig) {

        }

        play(step_from) {
          // logger.log("GolfSegue::play", step_from);

          const score = 12;
          // this.golfCourse_from.mutateIntoScoreLabel(score);

          this.golfCourse_from.fillHole();

          const position_to = {
            x: this.golfCourse_to.rect.x,
            y: this.golfCourse_to.rect.y,
          };
          this.infiniteCanvas.move_to_position(position_to);

        }


      }
    </script>
    <!-- <script>
      setTimeout(() => {    //SHU: wait for mathjax to finish loading
        // const golfGame1 = GolfGame1.defaultInstance(infiniteCanvas);
        // const golfGame1 = GolfGame1.debugInstance(infiniteCanvas);
        const golfGame1 = GolfGame1.seriousInstance(infiniteCanvas);
      }, 1000);

    </script> -->



    <script>

      class GMABChallenge {
        constructor(a, b, arr_operators) {

        }

        isPossible() {

        }

        hasPeriodicSolution() {

        }

      }

      class GMABPath {
        constructor(a, b, st) {

        }

        isPeriodic() {

        }

        getLength() {

        }


      }

      class LasagnaTreeNursery {
        constructor(operators) {
          this.operators = operators;
        }

        treeOfDepth(root, depth) {    //mathNode, gmOperator, mathNode, ...

        }

      }

      class GMItem {
        constructor(type, content, name, description, specs = {}) {
          this.type        = type;
          this.content     = content;
          this.name        = name;
          this.description = description;
          this.specs       = specs;     //specific behavior (for example: does not accept symbolic input params)
        }

        clone() {
          var outItem;

          outItem = new GMItem();
          Object.assign(outItem, this);
          outItem.content = this.content.cloneDeep();

          return outItem;
        }

        static value(content, name, description, specs = {}) {
          const type = "value";
          const item = new GMItem(type, content, name, description, specs);
          return item;
        }

        static operator(content, name, description, specs = {}) {
          const type = "operator";
          const item = new GMItem(type, content, name, description, specs);
          return item;
        }

      }

      class GMOperatorGroup {

        constructor(arr_gm_operator) {

        }

      }

      class GMMaker {

        static createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, nb_iter) {
          var outItem;

          const arr_index = [...new Array(nb_iter).keys()];

          const mathNode__initial = gmItem__initial.content;

          const mathNode__initial_clone = mathNode__initial.cloneDeep();
          mathNode__initial_clone.autoSimplify = mathNode__initial.autoSimplify;

          const mathNode__target = arr_index.reduce((acc, x) => {

            const node_a = acc;

            const gmItem_operator = Utils.randomElementInArray(arr_gmItem_operator);

            const operatorNodeFactoryFunc = gmItem_operator.content;

            var node_op = operatorNodeFactoryFunc(node_a);
            if(node_a.autoSimplify) {
              node_op = math.simplify(node_op);
              // node_op = Simplifier.simplify(node_op);

              node_op = Simplifier.simplify_top_layer(node_op);
            }
            node_op.autoSimplify = node_a.autoSimplify;

            return node_op;
          }, mathNode__initial_clone);

          outItem = GMItem.value(mathNode__target, "target", "");

          return outItem;
        }

      }


    </script>


    <script>
      class GolfGame__Endless_Practice {

        constructor(infiniteCanvas) {
          this.infiniteCanvas = infiniteCanvas;

          //create golfCourse
          const golfCourseConfig = GolfCourseConfig.template_challenge();
          const golfCourse       = new GolfCourse(infiniteCanvas, golfCourseConfig);
          this.golfCourse = golfCourse;

          //prepare golf course
          this.prepareGolfCourse(golfCourse);

          //setup step generator
            //numbers
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance1(infiniteCanvas, golfCourse, stepGeneratorFunc);
            //litterals
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance2(infiniteCanvas, golfCourse, stepGeneratorFunc);
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance3(infiniteCanvas, golfCourse, stepGeneratorFunc);
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance4(infiniteCanvas, golfCourse, stepGeneratorFunc);
            //equations
          //SHU TODO

            //fractions
          const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__frac_to_one(infiniteCanvas, golfCourse, stepGeneratorFunc);
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__one_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc);
          // const stepGeneratorFunc = () => GolfGameStep__Endless_Practice.randomInstance__frac_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc);



          //create first step
          // const step = GolfGameStep__Endless_Practice.randomInstance1(infiniteCanvas, golfCourse);
          const step = stepGeneratorFunc();

          //start game
          step.start();
        }

        prepareGolfCourse(golfCourse) {

          const infiniteCanvas = this.infiniteCanvas;

          //clear
            //nothing to clear

          //add "Impossible" button
          {
            const rect_rel__button = {
              l: 0.75,
              r: 0.95,
              t: 0.10,
              b: 0.20,
            };
            const trueRect__button = Geometry.rectForRectRel(golfCourse.rect, rect_rel__button);

            const icObj__button = infiniteCanvas.createIcButton(trueRect__button);
            infiniteCanvas.addIcObject(icObj__button);

            golfCourse.components["button_impossible"] = {
              icObj: icObj__button,
            };

          }



          if(golfCourse.components["hole"]) {
            const icObj__hole      = golfCourse.components["hole"].icObj;

            const icObj__facade    = icObj__hole.parts["facade"];
            const icObj__touchSlot = icObj__hole.parts["touchSlot"];

            // logger.log("icObj__facade", icObj__facade);
            // icObj__facade.originX = "right";
            // icObj__facade.fill = "blue";
            // logger.log("icObj__facade", icObj__facade);

            const rep_free__hole =  infiniteCanvas.getRepresented(icObj__hole.id).r_free();
            const rep_free__facade = rep_free__hole.parts.facade;
            const rep_free__touchSlot = rep_free__hole.parts.touchSlot;

            rep_free__hole.compositeConfig[rep_free__facade.id].isMobile    = true;
            rep_free__hole.compositeConfig[rep_free__touchSlot.id].isMobile = true;


            rep_free__facade.originX = "right";
            rep_free__facade.position = {
              x: rep_free__facade.position.x,
              y: rep_free__facade.position.y - 150,
            };

            rep_free__touchSlot.position = {
              x: rep_free__touchSlot.position.x,
              y: rep_free__touchSlot.position.y + 100,
            };


            rep_free__hole.compositeConfig[rep_free__facade.id].isMobile    = false;
            rep_free__hole.compositeConfig[rep_free__touchSlot.id].isMobile = false;


          }

        }

        // static random_challengeMathNodeConfig() {
        //   logger.log("random_challengeMathNodeConfig");
        //
        //   const mathNode__initial = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
        //   mathNode__initial.autoSimplify = true;
        //
        //   const mathNode__target  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
        //
        //   // const min__nb_operators = 2;
        //   // const max__nb_operators = 5;
        //   // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
        //   const nb_operators = 4;
        //
        //   const arr_operatorNodeFunc = [...new Array(nb_operators).keys()].map(index => {
        //     const operatorNodeFunc = random_operatorNodeFactoryFunc_binary(["ConstantNode"]);
        //     return operatorNodeFunc;
        //   });
        //
        //   const mathNodeConfig = {
        //     initial: mathNode__initial,
        //     target : mathNode__target,
        //     operatorFuncs: arr_operatorNodeFunc,
        //   };
        //
        //   return mathNodeConfig;
        // }

        static random_challengeGMItemConfig(range_initial, range_target) {
          // logger.log("random_challengeGMItemConfig");

          // const mathNode__initial = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
          const mathNode__initial = random_constantNode(range_initial);
          mathNode__initial.autoSimplify = true;
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");

          // const mathNode__target  = random_terminal_mathNode_withType_inArr(["ConstantNode"]);
          const mathNode__target = random_constantNode(range_target);

          const gmItem__target = GMItem.value(mathNode__target, "target", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: -10,
                  max: +10,
                },
              },
            };

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams);
            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const gmItem__operator = GMItem.operator(func, name, "");
            return gmItem__operator;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,
            operators:  arr_gmItem_operator,
          };

          return gmItemConfig;
        }

        static random_challengeGMItemConfig__x_to_expr() {
          // logger.log("random_challengeGMItemConfig__x_to_expr");

          const mathNode__initial = new math.SymbolNode("x");
          // mathNode__initial.autoSimplify = true;
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: -10,
                  max: +10,
                },
              },
            };

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams);
            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const gmItem__operator = GMItem.operator(func, name, "");
            return gmItem__operator;
          });


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, 4);

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,
            operators:  arr_gmItem_operator,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__x_to_expr__shuffled() {
          // logger.log("random_challengeGMItemConfig__x_to_expr__shuffled");

          const mathNode__initial = new math.SymbolNode("y");
          // mathNode__initial.autoSimplify = true;
          const gmItem__initial = GMItem.value(mathNode__initial, "initial", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: -10,
                  max: +10,
                },
              },
              isShuffled: true,
            };

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams);
            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const gmItem__operator = GMItem.operator(func, name, "");
            return gmItem__operator;
          });


          const gmItem__target   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial, arr_gmItem_operator, 4);

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,
            operators:  arr_gmItem_operator,
          };

          return gmItemConfig;
        }


        static random_challengeGMItemConfig__expr_to_x() {
          // logger.log("random_challengeGMItemConfig__expr_to_x");

          const mathNode__target = new math.SymbolNode("x");
          // mathNode__initial.autoSimplify = true;
          const gmItem__target = GMItem.value(mathNode__target, "target", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: -10,
                  max: +10,
                },
              },
            };

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams);
            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };
            const gmItem__operator = GMItem.operator(func, name, "", specs);
            return gmItem__operator;
          });

          const depth__initial    = 4;
          // const depth__initial    = 10;

          const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__target, arr_gmItem_operator, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator__inverse = GMItem.operator(func, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            // operators:  arr_gmItem_operator,
            operators: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }


        //fractions

        static random_challengeGMItemConfig__frac_to_one() {
          // logger.log("random_challengeGMItemConfig__expr_to_x");

          // const mathNode__target = new math.SymbolNode("x");
          const mathNode__target = new math.ConstantNode(1);
          // mathNode__initial.autoSimplify = true;
          const gmItem__target = GMItem.value(mathNode__target, "target", "");


          // const min__nb_operators = 2;
          // const max__nb_operators = 5;
          // const nb_operators      = Math.floor(Math.random() * (max__nb_operators - min__nb_operators)) + min__nb_operators;
          const nb_operators = 4;

          const arr_gmItem_operator = [...new Array(nb_operators).keys()].map(index => {

            const operatorParams = {
              node_b: {
                types: ["ConstantNode"],
                range: {
                  min: +1,
                  max: +10,
                },
              },
            };

            const op_multiply = Operator.multiply();
            const op_divide   = Operator.divide();
            const arr_op = [
              // op_multiply,
              op_divide,
            ];

            const operatorNodeFuncWrapper = random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op);

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };
            const gmItem__operator = GMItem.operator(func, name, "", specs);
            return gmItem__operator;
          });

          const depth__initial    = 4;
          // const depth__initial    = 10;

          const gmItem__initial_seed = gmItem__target.clone();
          gmItem__initial_seed.content.autoSimplify = true;
          const gmItem__initial   = GMMaker.createGMItemTarget__x_to_expr(gmItem__initial_seed, arr_gmItem_operator, depth__initial);
          const mathNode__initial = gmItem__initial.content;
          mathNode__initial.autoSimplify = true;


          const arr_gmItem_operator__inverse = arr_gmItem_operator.map((gmItem__operator) => {

            const operatorNodeFuncWrapper = gmItem__operator.specs.funcWrapper.inverse;
            // logger.log("operatorNodeFuncWrapper", operatorNodeFuncWrapper);

            const operator__inverse = operatorNodeFuncWrapper.semantics.operator;

            const name = operatorNodeFuncWrapper.semantics.name;
            const func = operatorNodeFuncWrapper.func;
            const specs = {
              funcWrapper: operatorNodeFuncWrapper,
            };

            const gmItem__operator__inverse = GMItem.operator(func, name, "", specs);

            return gmItem__operator__inverse;
          });

          const gmItemConfig = {
            initial:    gmItem__initial,
            target :    gmItem__target,

            // operators:  arr_gmItem_operator,
            operators: arr_gmItem_operator__inverse,
          };

          return gmItemConfig;
        }




      }





      class GolfGameStep__Endless_Practice {

        constructor(infiniteCanvas, golfStepConfig, golfCourse, stepGeneratorFunc) {

          this.infiniteCanvas = infiniteCanvas;
          // this.golfStepConfig = golfStepConfig;
          this.golfCourse     = golfCourse;

          this.stepGeneratorFunc = stepGeneratorFunc;

          this.configure(golfStepConfig);

        }

        static randomInstance1(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          // const game = this;
          // const challengeMathNodeConfig = GolfGame__Endless_Practice.random_challengeMathNodeConfig();
          // const stepConfig = {
          //   challengeMathNodeConfig: challengeMathNodeConfig,
          //   // game: game,
          // };

          const range_initial = {min: 0, max: 10, step: 1};
          const range_target  = {min: -100, max: 100, step: 1};

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig(range_initial, range_target);
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance2(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          // const game = this;
          // const challengeMathNodeConfig = GolfGame__Endless_Practice.random_challengeMathNodeConfig();
          // const stepConfig = {
          //   challengeMathNodeConfig: challengeMathNodeConfig,
          //   // game: game,
          // };

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__x_to_expr();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance3(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          // const game = this;
          // const challengeMathNodeConfig = GolfGame__Endless_Practice.random_challengeMathNodeConfig();
          // const stepConfig = {
          //   challengeMathNodeConfig: challengeMathNodeConfig,
          //   // game: game,
          // };

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__x_to_expr__shuffled();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        static randomInstance4(infiniteCanvas, golfCourse, stepGeneratorFunc) {
          // const game = this;
          // const challengeMathNodeConfig = GolfGame__Endless_Practice.random_challengeMathNodeConfig();
          // const stepConfig = {
          //   challengeMathNodeConfig: challengeMathNodeConfig,
          //   // game: game,
          // };

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__expr_to_x();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }

        //fractions

        static randomInstance__frac_to_one(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_one();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static randomInstance__one_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__one_to_frac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }


        static randomInstance__frac_to_frac(infiniteCanvas, golfCourse, stepGeneratorFunc) {

          const challengeGMItemConfig = GolfGame__Endless_Practice.random_challengeGMItemConfig__frac_to_frac();
          const stepConfig = {
            challengeGMItemConfig: challengeGMItemConfig,
          };

          const step = new GolfGameStep__Endless_Practice(infiniteCanvas, stepConfig, golfCourse, stepGeneratorFunc);

          return step;
        }



        configure(golfStepConfig) {
          // this.par = golfStepConfig.par;
          this.nb_attempts = 0;

          // this.challengeMathNodeConfig = golfStepConfig.challengeMathNodeConfig;
          this.challengeGMItemConfig = golfStepConfig.challengeGMItemConfig;
        }

        start() {
          const golfCourse        = this.golfCourse;
          const stepGeneratorFunc = this.stepGeneratorFunc;

          this.invest(golfCourse);

          this.possess(golfCourse);

          this.recurse(stepGeneratorFunc);

          // this.infiniteCanvas.redrawCanvas(RedrawOccasion.forceRedraw);   //SHU666:pour éviter les bugs de non rafraîchissement des teXFObj //ce n'est pas la panacée
        }

        end() {
          // this.golfCourse.fillHole();
          const step = this;
          const infiniteCanvas = this.infiniteCanvas;

          step.rep_free__hole.parts.touchSlot.fill  = "yellow";

          //destroy ball
            //end curses
          // step.rep_free__ball.curse_bornAgain_end();
          // step.rep_free__ball.curse_greenMouse_end();
          step.rep_free__ball.parts.facade.curse_greenMouse_end();


            //remove "die" hooks listeners
          step.rep_free__ball.will["die"].listeners = [];

            //remove
          step.rep_free__ball.im_dying_now = true;
          step.rep_free__ball.parts.facade.im_dying_now      = true;
          step.rep_free__ball.parts.contactArea.im_dying_now = true;

          // infiniteCanvas.removeRepresented(step.rep_free__ball.represented);

          //remove all listeners
          const touchSlot__rep_free       = step.rep_free__hole.parts.touchSlot;
          const touchSlotEngine           = touchSlot__rep_free.engine;
          touchSlotEngine.awoken.did["touch"].off(this.listener_targetDidTouch);

        }

        addNewBall() {
          const step = this;
          const infiniteCanvas = this.infiniteCanvas;
          const golfCourse = this.golfCourse;


          const icObj__tee = golfCourse.components["tee"].icObj;
          const trueRect__ball = {
            x:      icObj__tee.position.x,
            y:      icObj__tee.position.y,
            width:  50,
            height: 50,
          };

          // const value = 0;
          //debug
          const mathNode__initial = step.challengeGMItemConfig.initial.content;
          // const value = mathNode__initial.value;

          // const icObj = infiniteCanvas.createIcBornAgainGreenMouseBox(trueRect__ball, mathNode__initial);
          const icObj = infiniteCanvas.createIcGreenMouseBox(trueRect__ball, mathNode__initial);

          // const icObj = infiniteCanvas.createIcMathNode(trueRect__ball.x, trueRect__ball.y, mathNode__initial);

          infiniteCanvas.addIcObject(icObj);

          const rep_free__ball = infiniteCanvas.getRepresented(icObj.id).r_free();
          Hooker.installHooks(rep_free__ball, "die");
          rep_free__ball.did["die"].on(() => {
            // logger.log("did die");

            rep_free__ball.parts.facade.im_dying_now      = true;
            rep_free__ball.parts.contactArea.im_dying_now = true;

            step.addNewBall();
          });

          step.rep_free__ball  = rep_free__ball;
        }

        invest(golfCourse) {

          const step           = this;
          const infiniteCanvas = this.infiniteCanvas;

          //clear: remove objects



          //furnish: add objects
          {
            const infiniteCanvas = this.infiniteCanvas;

              //add label/value: score
            function addLabel_score() {
              const rect__score = golfCourse.rect;
              rect__score.width  = 300;
              rect__score.height = 150;

              const string__score = "score:";
              const value__score  = 0;

              const icObj__score  = infiniteCanvas.createIcLabelValue(rect__score, string__score, value__score);
              icObj__score.zIndex = 200;

              infiniteCanvas.addIcObject(icObj__score);

              const rep_free__score_valueLabel = infiniteCanvas.getRepresented(icObj__score.id).r_free();
              step.rep_free__score_valueLabel  = rep_free__score_valueLabel;
              step.rep_free__score_value       = rep_free__score_valueLabel.parts["value"];
            }
            addLabel_score();

              //add label/value: par
            function addLabelValue_par() {
              const rect__par = {
                x: step.rep_free__score_valueLabel.position.x,
                y: step.rep_free__score_valueLabel.position.y + 120,
                width:  300,
                height: 150,
              };

              const string__par = "par:";
              const value__par  = step.par;

              const icObj__par = infiniteCanvas.createIcLabelValue(rect__par, string__par, value__par);
              icObj__par.zIndex = 201;

              infiniteCanvas.addIcObject(icObj__par);

              const rep_free__par_valueLabel = infiniteCanvas.getRepresented(icObj__par.id).r_free();
              step.rep_free__par_valueLabel  = rep_free__par_valueLabel;
              step.rep_free__par_value       = rep_free__par_valueLabel.parts["value"];

              setTimeout(() => {
                step.rep_free__par_value.position = {
                  x: step.rep_free__score_value.position.x,
                  y: step.rep_free__par_value.position.y,
                };
              }, 20);   //SHU TODO: remove this ugliness
            }
            addLabelValue_par();


              //add ball:
              step.addNewBall();


              //add button: restart


              //add button: impossible

          }


          //invest: "this is mine now"
          {
            // step.rep_free__ball = golfCourse.components["ball"].icObj;
            step.rep_free__hole = golfCourse.components["hole"].icObj;
          }


          //employ: now you do X
            //initial
          const mathNode__initial      = step.challengeGMItemConfig.initial.content;
          step.rep_free__ball.mathNode = mathNode__initial;
          // logger.log("mathNode__initial", mathNode__initial);



            //target
          const mathNode__target       = step.challengeGMItemConfig.target.content;
          step.rep_free__hole.parts.facade.mathNode = mathNode__target;
          step.rep_free__hole.parts.touchSlot.fill  = "";
            //operators
          const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_operator");
          const arr_rep_free__operator = arr_gm_operator.map((gm_operator, i) => {
            const icObj__rep_free = gm_operator.icObj;
            return icObj__rep_free;
          });
          const arr_gmItem_operator = step.challengeGMItemConfig.operators;

          const zip = (a, b) => a.map((k, i) => [k, b[i]]);

          const arr_zipped = zip(arr_rep_free__operator, arr_gmItem_operator);

          arr_zipped.forEach(([rep_free__operator, gmItem_operator], i) => {


            //touchSlot
            const rep_free__touchSlot = rep_free__operator.parts["touchSlot"];

            const mathNodeTransformationFunc = gmItem_operator.content;
            const icObjTransformationFunc = (icObj) => {
              // logger.log("icObjTransformationFunc", icObj);
              var outIcObj;



              outIcObj = icObj.clone();
              // logger.log("outIcObj", outIcObj);

              if(outIcObj.mathNode) {
                delete outIcObj.mathNode;     //SHU666: true sadness
              }



              if(icObj.cType == "gm_box") {
                // logger.log("gm_box");

                const facade = icObj.parts.facade;
                outIcObj.parts.facade.mathNode = mathNodeTransformationFunc(facade.mathNode);
              }

              // if(icObj.mathNode != null) {
              //   // logger.log("icObj.mathNode", icObj.mathNode);
              //   outIcObj.mathNode = mathNodeTransformationFunc(icObj.mathNode);
              // }

              return outIcObj;
            };
            rep_free__touchSlot.touchSlotConfig.transformationFunc = icObjTransformationFunc;


            //facade
            const rep_free__facade = rep_free__operator.parts["facade"];
            rep_free__facade.text = gmItem_operator.name;

            rep_free__facade.originX = "center";

          });


          // step.infiniteCanvas.redrawCanvas(RedrawOccasion.forceRedraw);   //SHU666:pour éviter les bugs de non rafraîchissement des teXFObj //ce n'est pas la panacée
        }

        possess(golfCourse) {
          this.initializeCompletionListeners();

          this.setupAttemptListeners(golfCourse);

          this.setupCompletionTrigger(golfCourse);
          this.addCompletionListener(golfCourse);
        }

        recurse(stepGeneratorFunc) {
          const step = this;

          const segueConfig = {};
          const step_from   = step;

          const golfCourse_to = step_from.golfCourse;

          const segue = new GolfGameSegue__Endless_Practice(infiniteCanvas, segueConfig, step_from, golfCourse_to, stepGeneratorFunc);

          this.segue = segue;
        }


        initializeCompletionListeners() {
          // this.nb_attempts = 0;
          this.arr_attempt = [];

          this.listeners_completed = [];

          this.onCompleted  = (listener) => {
            this.listeners_completed.push(listener);
          };
          this.offCompleted = (listener) => {
            this.listeners_completed = Utils.arrayByRemovingElement(this.listeners_completed, listener);
          };
          this.nowCompleted = () => {
            this.listeners_completed.forEach((listener, i) => {
              listener(this);
            });
          };
        }

        setupAttemptListeners(golfCourse) {   //SHU: this is where BigBrother sneaked in from

          const step = this;

          // function waitForNewAttempt() {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   const createAttemptFunc = () => {
          //
          //       const attempt = new GolfStepAttempt();
          //
          //       step.arr_attempt.push(attempt);
          //
          //       ball__rep_free.offHold(createAttemptFunc);
          //   };
          //
          //   ball__rep_free.onHold(createAttemptFunc);
          // }
          //
          // //gm.onHold(create attempt)
          // {
          //   waitForNewAttempt();
          // }
          //
          // //gm.onTouched(add event to attempt)
          // {
          //
          // }
          //
          // //gm.onRelease(finalize attempt)
          // {
          //   const ball__rep_free = golfCourse.components["ball"].icObj;
          //
          //   ball__rep_free.onRelease(waitForNewAttempt);
          // }

          //create attempt






          //course use listeners

          function listenToOperatorTouches(icObj__rep_free) {

            const touchSlot__rep_free  = icObj__rep_free.parts["touchSlot"];
            // logger.log("touchSlot__rep_free", touchSlot__rep_free);

            const touchSlotEngine = touchSlot__rep_free.engine;

            Hooker.installHooks(touchSlotEngine.awoken, "touch");
            touchSlotEngine.awoken.did["touch"].on((...args) => {
              // logger.log("did touch", ...args);

              // // counter += 1
              // const attempt = step.getCurrentAttempt();
              // logger.log("attempt", attempt);
              // attempt.manoeuvre.nb_touched += 1;
              //
              // //debug
              // step.rep_free__score_value.text = "" + attempt.manoeuvre.nb_touched;



              // const rep_free__curseFacade = step.rep_free__hole.parts.curseFacade;
              const rep_free__curseFacade = step.rep_free__hole.parts.curseFacade;
              if(rep_free__curseFacade != null) {
                const rep_free__facade      = step.rep_free__hole.parts.facade;
                rep_free__facade.curse_metamorphosis.curseTrigger.impulse();
              }


            });

          }

          const arr_gm_operator = Object.values(golfCourse.components).filter(component => component.type == "gm_operator");

          arr_gm_operator.forEach((gm_operator, i) => {
            const icObj__rep_free = gm_operator.icObj;
            listenToOperatorTouches(icObj__rep_free);
          });

        }

        setupCompletionTrigger(golfCourse) {

          const targetTouchSlot__rep_free = golfCourse.components["hole"].icObj;

          const touchSlot__rep_free = targetTouchSlot__rep_free.parts["touchSlot"];

          const touchSlotEngine = touchSlot__rep_free.engine;

          Hooker.installHooks(touchSlotEngine.awoken, "touch");
          const listener_targetDidTouch = (...args) => {
            // logger.log("did touch", ...args);

            this.nowCompleted();
          };
          this.listener_targetDidTouch = listener_targetDidTouch;
          touchSlotEngine.awoken.did["touch"].on(listener_targetDidTouch);

        }

        addCompletionListener(golfCourse) {

          const step = this;

          this.listener_onCompleted = (golfStep) => {
            // console.log("step, onCompleted", golfStep);
            // logger.log("step, onCompleted", golfStep);

            /*
            const score = golfStep.arr_attempts.length;
            golfCourse.mutateIntoScoreLabel(score);
            */

            step.offCompleted(step.listener_onCompleted);
            step.end();

            step.segue.play(golfStep);
          };

          this.onCompleted(this.listener_onCompleted);
        }

        getCurrentAttempt() {
          return this.arr_attempt[this.arr_attempt.length - 1];
        }







      }

      class GolfGameSegue__Endless_Practice {

        constructor(infiniteCanvas, golfSegueConfig, step_from, golfCourse_to, /*step_to = null,*/ stepGeneratorFunc) {
          this.infiniteCanvas = infiniteCanvas;

          this.golfSegueConfig = golfSegueConfig;
          this.configure(golfSegueConfig);

          this.step_from = step_from;

          this.golfCourse_to = golfCourse_to;
          // this.step_to       = step_to;
          this.stepGeneratorFunc = stepGeneratorFunc;
        }

        configure(golfSegueConfig) {

        }

        play(step_from) {
          // logger.log("GolfSegue::play", step_from);

          const golfCourse_to = this.golfCourse_to;

          setTimeout(() => {

            const position_to = {
              x: golfCourse_to.rect.x,
              y: golfCourse_to.rect.y,
            };
            this.infiniteCanvas.move_to_position(position_to);


            if(this.step_to == null) {
              // const step = GolfGameStep__Endless_Practice.randomInstance1(infiniteCanvas, golfCourse_to);
              const step = this.stepGeneratorFunc();
              this.step_to = step;
            }
            this.step_to.start();

          }, 500);

        }


      }

    </script>
    <!-- <script>
      setTimeout(() => {    //SHU: wait for mathjax to finish loading
        const golfGame__endless_practice = new GolfGame__Endless_Practice(infiniteCanvas);     //practice
      }, 1000);
    </script> -->






    <script>
      class Keyboard_Rx {
        constructor() {
          this.rx_keyUp = new Subject();
          document.addEventListener('keyup', (e) => {
            this.rx_keyUp.next(e);
          });
        }
      }
    </script>
    <script>
      const keyboard_Rx = new Keyboard_Rx();
    </script>





    <script>

      class Atelier__X_X {

        constructor(infiniteCanvas) {
          this.infiniteCanvas = infiniteCanvas;

          // this.debug1();
          // this.debug2();

          // this.debug_countdown_1();

          // this.debug_colored_tex();

          // this.debug_rich_wedding();

          // this.debug_splitter_sptl();
          // this.debug_splitter_spf();

          // this.debug_composite_mutation();
          // this.debug_morpher();

          // this.debug_exoSkeleton();
          // this.debug_exoSkeleton2();

          // this.debug_octomouse();

          //--fractions--
          // this.debug_decomp_product_primes();
          // this.debug_inverse();
          // this.debug_simplify_singleoperatorize();
          this.debug_simplify_topPriorityShell();

        }

        debug1() {

          const infiniteCanvas = this.infiniteCanvas;

          //create targetTouchSlot
          const trueRect_2 = {
            x: 1000,
            y: 500,
            width: 100,
            height: 100,
          };
          const icTargetTouchSlot = infiniteCanvas.createIcGMTargetTouchSlot(trueRect_2, 12);
          infiniteCanvas.addIcObject(icTargetTouchSlot);


          //create var
          const trueRect_1 = {
            x: 500,
            y: 500,
            width: 100,
            height: 100,
          };
          const mathNode = new math.SymbolNode("x");
          const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
          icMathNode.isTouchable = true;
          infiniteCanvas.addIcObject(icMathNode);
        }

        debug2() {

          const infiniteCanvas = this.infiniteCanvas;

          //create icGreenMouseBox
          const trueRect_2 = {
            x: 1000,
            y: 500,
            width: 100,
            height: 100,
          };
          const icGreenMouseBox = infiniteCanvas.createIcGreenMouseBox(trueRect_2, new math.ConstantNode(12));
          // icGreenMouseBox.shouldAlsoRemoveChildren = true;
          infiniteCanvas.addIcObject(icGreenMouseBox);

          setTimeout(() => {
            const represented = infiniteCanvas.getRepresented(icGreenMouseBox.id);
            logger.log("represented", represented);
            represented.r_free().im_dying_now                   = true;
            represented.r_free().parts.facade.im_dying_now      = true;
            represented.r_free().parts.contactArea.im_dying_now = true;
          }, 1000);

        }

        debug_countdown_1() {

          const infiniteCanvas = this.infiniteCanvas;

          //create icGreenMouseBox
          const trueRect = {
            x: 1000,
            y: 500,
            width: 100,
            height: 100,
          };
          // const icMathNode = infiniteCanvas.createIcMathNode(trueRect_2, new math.ConstantNode(12));
          const mathNode = new math.ConstantNode(12);
          const icMathNode = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
          // infiniteCanvas.addIcObject(icMathNode);

          const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "0");
          // infiniteCanvas.addIcObject(icMathNode);

          const parts = {
            curseFacade:  icText,
            mathNode:     icMathNode,
          };

          const compositeConfig = Compositer.defaultCompositeConfig(parts, false);
          const icComposite = infiniteCanvas.createIcComposite(trueRect, parts, compositeConfig);

          infiniteCanvas.addIcObject(icComposite);



          const facade_represented = infiniteCanvas.getRepresented(icMathNode.id);
          const facade_rep_free    = facade_represented.r_free();

          // const countDownTrigger = infiniteCanvas.createCurseTrigger_countdown();
          infiniteCanvas.accurse__metamorphosis(facade_rep_free);

          const curseFunc = () => {
            logger.log("curseFunc, rep_free:", facade_rep_free);
            const mathNode = random_constantNode();
            facade_rep_free.mathNode = mathNode;
            facade_rep_free.curse_metamorphosis.reset();
          };
          facade_rep_free.curse_metamorphosis.curseFunc = curseFunc;



          facade_rep_free.curse_metamorphosis.start();


          keyboard_Rx.rx_keyUp.subscribe({
            next: (e) => {
              logger.log("e",e);

              switch(e.code) {
                case "Numpad1":
                  facade_rep_free.curse_metamorphosis.curseTrigger.impulse();
                  break;
              }

            },
          });






          const composite_represented = infiniteCanvas.getRepresented(icComposite.id);
          const composite_rep_free    = composite_represented.r_free();
          const curseFacade_rep_free  = composite_rep_free.parts.curseFacade;

          const curseTrigger = facade_rep_free.curse_metamorphosis.curseTrigger;
          logger.log("curseTrigger", curseTrigger);

          // Hooker.installHooks(curseTrigger, "impulse");
          // curseTrigger.did["impulse"].on(() => {
            // logger.log("did impulse");
            // const countDownEngine = curseTrigger.engine;
            // const counter         = countDownEngine.getCounter();
            // curseFacade_rep_free.text = "" + counter;
          // });


          // facade_rep_free.curse_metamorphosis.start();

          facade_rep_free.curse_metamorphosis.rx_countDownCounter.subscribe({
            next: (value) => {
              logger.log("rx_countDownCounter, next", value);
              logger.log("curseFacade_rep_free", curseFacade_rep_free);

              curseFacade_rep_free.text = "" + value;
              // facade_rep_free.mathNode = new math.ConstantNode(value);
            },
          });


        }


        debug_colored_tex() {

          const infiniteCanvas = this.infiniteCanvas;

          function addRichMathNode() {

            const trueRect = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };

            const mathNode = new math.ConstantNode(123456790);
            const richMathNode = new RichMathNode(mathNode);
            // richMathNode.rich.colorMode = "plain";
            richMathNode.rich.colorMode = "xylophone";
            // richMathNode.rich.colorMode = "evenodd";

            richMathNode.rich.color     = "red";


            // const icMathNode = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
            // infiniteCanvas.addIcObject(icMathNode);

            // const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "0");

            // const richMathNodeConfig = {
            //   mathNode: mathNode,
            //   color: "blue",
            // };
            const icRichMathNode = infiniteCanvas.createIcRichMathNode(trueRect.x, trueRect.y, richMathNode);

            infiniteCanvas.addIcObject(icRichMathNode);
          }

          addRichMathNode();

        }

        debug_rich_wedding() {

          const infiniteCanvas = this.infiniteCanvas;

          function addRichMathNode(trueRect, value, colorMode) {

            const mathNode     = new math.ConstantNode(value);
            const richMathNode = new RichMathNode(mathNode);
            // richMathNode.rich.colorMode = "plain";
            richMathNode.rich.colorMode = colorMode;
            // richMathNode.rich.colorMode = "evenodd";

            richMathNode.rich.color     = "red";


            // const icMathNode = infiniteCanvas.createIcMathNode(trueRect.x, trueRect.y, mathNode);
            // infiniteCanvas.addIcObject(icMathNode);

            // const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "0");

            // const richMathNodeConfig = {
            //   mathNode: mathNode,
            //   color: "blue",
            // };
            const icRichMathNode = infiniteCanvas.createIcRichMathNode(trueRect.x, trueRect.y, richMathNode);

            infiniteCanvas.addIcObject(icRichMathNode);
          }

          const trueRect_1 = {
            x: 1000,
            y: 500,
            width: 100,
            height: 100,
          };
          const trueRect_1bis = {
            x:      trueRect_1.x,
            y:      trueRect_1.y + 50,
            width:  trueRect_1.width,
            height: trueRect_1.height,
          };
          const trueRect_2 = {
            x: 1500,
            y: 500,
            width: 100,
            height: 100,
          };

          addRichMathNode(trueRect_1,    10023456, "xylophone");
          addRichMathNode(trueRect_1bis, 10023456, "fullplain");

          // addRichMathNode(trueRect_2, 10023456, "plain");

          // addRichMathNode(trueRect_2,  51, "evenOdd");


        }

        debug_splitter_sptl() {

        }

        debug_splitter_spf() {

        }

        debug_composite_mutation() {

          const infiniteCanvas = this.infiniteCanvas;

          //create composite
          const trueRect_0 = {
            x: 200,
            y: 200,
            width: 100,
            height: 100,
          };

          const parts           = [];
          const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
          const icComposite     = infiniteCanvas.createIcComposite(trueRect_0, parts, compositeConfig);
          infiniteCanvas.addIcObject(icComposite);

          const rep_free__composite = infiniteCanvas.getRepresented(icComposite.id).r_free();
          rep_free__composite.fill = "lightgrey";
          // rep_free.isSupervessel = true;
          logger.log("rep_free__composite.compositeConfig", rep_free__composite.compositeConfig);


          function addMathNode(rep_free__composite) {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const mathNode = new math.SymbolNode("12");
            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);

            const rep_free__mathNode = infiniteCanvas.getRepresented(icMathNode.id).r_free();

            // rep_free__composite.addPart(rep_free__mathNode);
            // rep_free__composite.engine.addPart(rep_free__mathNode);
            rep_free__composite.engine.awoken.addPart(rep_free__mathNode);      //SHU: un peu de vomi

            return rep_free__mathNode;
          }

          function addRect(rep_free__composite) {
            const trueRect = {
              x: 700,
              y: 700,
              width: 100,
              height: 100,
            };
            const icRect = infiniteCanvas.createIcRect(trueRect);
            infiniteCanvas.addIcObject(icRect);

            const rep_free__rect = infiniteCanvas.getRepresented(icRect.id).r_free();
            rep_free__rect.fill = "yellow";

            const miniDict = {
              [rep_free__rect.id]: rep_free__rect,
            };

            rep_free__composite.parts = Object.assign({}, rep_free__composite.parts, miniDict);
          }


          setTimeout(() => {

            const rep_free__mathNode = addMathNode(rep_free__composite);
            // addRect(rep_free__composite);

            setTimeout(() => {

              rep_free__composite.engine.awoken.removePart(rep_free__mathNode);

              setTimeout(() => {

                rep_free__composite.engine.awoken.addPart(rep_free__mathNode);

              }, 2000);

            }, 2000);

          }, 2000);

        }

        debug_morpher() {

          const infiniteCanvas = this.infiniteCanvas;

          // //create supervessel
          // {
          //   const trueRect_0 = {
          //     x: 200,
          //     y: 200,
          //     width: 100,
          //     height: 100,
          //   };
          //
          //   const parts           = [];
          //   const compositeConfig = Compositer.defaultCompositeConfig(parts, true);
          //   const icComposite     = infiniteCanvas.createIcComposite(trueRect_0, parts, compositeConfig);
          //   infiniteCanvas.addIcObject(icComposite);
          //
          //   const rep_free = infiniteCanvas.getRepresented(icComposite.id).r_free();
          //   rep_free.fill = "lightgrey";
          //   rep_free.isSupervessel = true;
          // }



          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            const mathNode = new math.SymbolNode("12");
            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create morpher
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "morpher__math_to_text");
            infiniteCanvas.addIcObject(gmOperator);
          }
          {
            const trueRect_3 = {
              x: 1000,
              y: 800,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_3, "morpher__text_to_math");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_exoSkeleton() {

          const infiniteCanvas = this.infiniteCanvas;

          const trueRect_1 = {
            x: 500,
            y: 500,
            width: 100,
            height: 100,
          };
          // const icObj__heart = infiniteCanvas.createIcText(trueRect_1.x, trueRect_1.y, "heart");
          const icObj__heart = infiniteCanvas.createIcRect(trueRect_1);
          // infiniteCanvas.addIcObject(icText);


          const exoSkeletonConfig = {
            grab: {
              position_easy: "right",
            },
            contact: {
              position_easy: "bottom",
            },
            display: {
              position_easy: "center",
            },
            // heartArea:
          };

          const icExoSkeleton = infiniteCanvas.createIcExoSkeleton(icObj__heart, exoSkeletonConfig);
          infiniteCanvas.addIcObject(icExoSkeleton);


          //create morpher
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 1");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_exoSkeleton2() {

          const infiniteCanvas = this.infiniteCanvas;

          const trueRect_1 = {
            x: 500,
            y: 500,
            width: 100,
            height: 100,
          };

          const icObj__member_1 = infiniteCanvas.createIcText(trueRect_1.x, trueRect_1.y, "2 + 2");
          // const icObj__equals   = infiniteCanvas.createIcText(trueRect_1.x, trueRect_1.y, "=");
          const icObj__member_2 = infiniteCanvas.createIcText(trueRect_1.x, trueRect_1.y, "5");

          const internalsObj = {
            "member_1": icObj__member_1,
            // "equals": icObj__center,
            "member_2": icObj__member_2,
          };
          // infiniteCanvas.addIcObject(icText);

          const exoSkeletonConfig = {
            internals: internalsObj,

            grab: {
              position_easy: "right_right",
            },

            member_1: {
              display: {
                position_easy: "left",
              },
              contact: {
                position_easy: "bottom_left",
              },
            },

            member_2: {
              display: {
                position_easy: "right",
              },
              contact: {
                position_easy: "bottom_right",
              },
            },


          };

          const icExoSkeleton = infiniteCanvas.createIcExoSkeleton(exoSkeletonConfig);
          infiniteCanvas.addIcObject(icExoSkeleton);


          //create operator
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator(trueRect_2, "+ 1");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }



        debug_octoMouse() {

        }


        debug_decomp_product_primes() {

          const infiniteCanvas = this.infiniteCanvas;

          //debug: multi factor
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            // const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(7), new math.ConstantNode(7), new math.ConstantNode(7)]);
            const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(120), new math.ConstantNode(7), new math.ConstantNode(7)]);


            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            const mathNode = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(8)]);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create morpher
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "decomposition__product_primes");
            infiniteCanvas.addIcObject(gmOperator);
          }


        }

        debug_inverse() {

          const infiniteCanvas = this.infiniteCanvas;

          //debug: multi factor
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            // const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(7), new math.ConstantNode(7), new math.ConstantNode(7)]);
            const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(120), new math.ConstantNode(7), new math.ConstantNode(7)]);


            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            const mathNode = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(8)]);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create morpher
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "inverse");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_simplify_singleoperatorize() {

          const infiniteCanvas = this.infiniteCanvas;

          //debug: multi factor
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            // const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(7), new math.ConstantNode(7), new math.ConstantNode(7)]);
            const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(120), new math.ConstantNode(7), new math.ConstantNode(7)]);


            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }

          //create var
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            const mathNode = new math.OperatorNode("/", "divide", [new math.ConstantNode(1), new math.ConstantNode(8)]);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create morpher
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "singleOperatorize");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }

        debug_simplify_topPriorityShell() {

          const infiniteCanvas = this.infiniteCanvas;

          //debug: multi factor
          {
            const trueRect_1 = {
              x: 500,
              y: 500,
              width: 100,
              height: 100,
            };
            // const mathNode = new math.ConstantNode(1/8);
            // const mathNode = new math.OperatorNode("x", "multiply", [new math.ConstantNode(7), new math.ConstantNode(7), new math.ConstantNode(7)]);

            const mathNode_a = new math.ConstantNode(4);
            const mathNode_b = new math.ConstantNode(7);

            const mathNode = new math.OperatorNode("x", "multiply", [mathNode_a, mathNode_b, Inverser.inverse(mathNode_a), Inverser.inverse(mathNode_b)]);

            const icMathNode = infiniteCanvas.createIcMathNode(trueRect_1.x, trueRect_1.y, mathNode);
            icMathNode.isTouchable = true;
            infiniteCanvas.addIcObject(icMathNode);
          }


          //create morpher
          {
            const trueRect_2 = {
              x: 1000,
              y: 500,
              width: 100,
              height: 100,
            };
            const gmOperator = infiniteCanvas.createIcGMOperator_withType(trueRect_2, "simplify__topPriorityShell");
            infiniteCanvas.addIcObject(gmOperator);
          }

        }



      }

    </script>
    <script>
      setTimeout(() => {    //SHU: wait for mathjax to finish loading
        const atelier__X_X = new Atelier__X_X(infiniteCanvas);
      }, 1000);
    </script>






</body>

</html>
