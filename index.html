<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Canvas</title>

    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;

            /* Prevent document pinch-zoom & touch-hold-to-highlight */
            touch-action: none;

            -webkit-touch-callout: none;
            /* iOS Safari */
            -webkit-user-select: none;
            /* Safari */
            -khtml-user-select: none;
            /* Konqueror HTML */
            -moz-user-select: none;
            /* Old versions of Firefox */
            -ms-user-select: none;
            /* Internet Explorer/Edge */
            user-select: none;
            /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
        }
    </style>

</head>

<body>

    <!-- <script src='lib/base64.js' type='text/javascript'></script> -->

    <!-- UI -->
    <script src='lib/fabric.min.js' type='text/javascript'></script>
    <script src='lib/anime.min.js'  type='text/javascript'></script>
    <!-- <script src='lib/mathjax.tex-mml-chtml.js' type='text/javascript'></script> -->
    <script src='lib/mathjax.tex-svg.js' type='text/javascript'></script>
    <script>
      console.log("MathJax", MathJax);
      //discovery
      // const mathJaxContainer_svg = MathJax.tex2svg('\\frac{1}{x^2-1}', {display: true});
      const mathJaxContainer_svg = MathJax.tex2svg('\\frac{1}{x^2-1}');
      console.log("mathJaxContainer_svg", mathJaxContainer_svg);

      //integration
      class TexHelper {
        static toSvgEl(tex, color = "red") {
          const mathJaxContainer_svg = MathJax.tex2svg(tex);

          const htmlCollection = mathJaxContainer_svg.children;
          const svgEl = htmlCollection.item(0);
          console.log("svgEl", svgEl);

          svgEl.style.color = color;
          // svgEl.style.color2 = "blue";

          return svgEl;
        }
      }

      class SvgHelper {
        static toDataURL(svgEl) {
          var outDataUrl;

          // const svgSource = svgEl.outerHTML;

          const serializer = new XMLSerializer();
          const svgSource  = serializer.serializeToString(svgEl);

          // svgSource = svgSource.replaceAll('http://', 'https://');
          console.log("svgSource", svgSource);

          const dataUrl   = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svgSource)));

          outDataUrl = dataUrl;

          return outDataUrl;
        }
      }

    </script>

    <!-- Maths -->
    <script src='lib/decimal.min.js' type='text/javascript'></script>

    <script src='lib/math.js' type='text/javascript'></script>
    <script src='lib/algebra-0.2.6.min.js' type='text/javascript'></script>
    <script>

      //discovery
      {
        // const chain = math.chain(1);
        //OR
        const chain = math.chain();
        chain.value = 1;
        console.log("debug::chain, initial", chain);

        const step1 = chain.add(8);
        const r1    = step1.done();
        // const r1 = chain.valueOf();
        console.log("debug::chain, r1", r1);

        const step2 = step1.multiply(100);
        const r2    = step2.done();
        console.log("debug::chain, r2", r2);

        console.log("debug::chain is not mutated in place");     //which is nice and not surprising from a functional programming pov
        console.log("debug::chain.done()", chain.done());
      }

      //chaining on expression
      /*
      { //SHU: THE DREAM
        const math_with_algebra = math.create(math.all);
        math_with_algebra.import(algebra, {wrap: true, silent: true});
        // math_with_algebra.import(algebra, {override: true, wrap: true, silent: true});

        const chain = math_with_algebra.chain();

        // const expr   = new algebra.Expression("x");
        const expr   = new math_with_algebra.Expression("x");
        // const expr = "x";

        console.log("expr", expr);
        chain.value = expr;                                             //SHU TODO: make this possible
        console.log("debug::chain, initial", chain);

        // const step1 = chain.add(8);                                      //SHU: en fait c'est peut-être juste un problème de coercion.
        const step1 = chain.add(new math_with_algebra.Expression(8));    //SHU: Ah non. Dommage.

        const r1    = step1.done();
        // const r1 = chain.valueOf();
        console.log("debug::chain, r1", r1);

        const step2 = chain.multiply(100);
        const r2    = step2.done();
        console.log("debug::chain, r2", r2);
      }
      */

      { //SHU: THE WORKAROUND
        var expr   = new algebra.Expression("x");
        expr = expr.multiply(2);
        expr = expr.multiply("x");
        expr = expr.multiply(new algebra.Expression("x"));
        expr = expr.add("y");
        expr = expr.add(new algebra.Fraction(1, 3));
        expr = expr.add("y");                                       //SHU: oh, no. There is automatic reducing.
        console.log("expr", expr.toString());

        //Simplification
        //All expression operations accept a simplify argument that will yield an unsimplified expression when set to false.
        //You can then get a simplified expression with Expression.simplify.

        var expr   = new algebra.Expression("x");
        expr = expr.multiply(2,false);
        expr = expr.multiply("x",false);
        expr = expr.multiply(new algebra.Expression("x"),false);
        expr = expr.add("y",false);
        expr = expr.add(new algebra.Fraction(1, 3),false);
        expr = expr.add(new algebra.Expression("y"),false);
        console.log("expr", expr.toString());                       //SHU: unsimplified expression terms order is wrong
        expr = expr.simplify();                                     //SHU TODO: show correct terms order
        console.log("expr", expr.toString());
      }

    </script>


    <!-- UX -->
    <script type="text/javascript" src="lib/rxjs.umd.min.js"></script> <!-- for easy inner/outer copy|paste -->
    <script>
      const Rx = rxjs;
      const Rx_operators = rxjs.operators;

      const Subject       = Rx.Subject;
      const ReplaySubject = Rx.ReplaySubject;

      //debug
      /*
      const rx_debug__subject    = new Subject();
      const rx_debug__observable = rx_debug__subject.asObservable();
      const rx_debug__sub        = rx_debug__observable.subscribe({
        next: (value) => {
          console.log("value", value);
        },
      });
      rx_debug__subject.next(10);
      rx_debug__subject.next(100);
      rx_debug__subject.next(1000);
      */
    </script>

    <canvas id="myCanvas">Your browser does not support HTML5 canvas</canvas>
    <script>
      const canvas = document.getElementById("myCanvas");
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
    </script>


    <!-- debug -->
    <div id="debug_container" style="position:absolute; left:0; top: 0; font-size: 60px; pointer-events: none;">
      <div>
        <div style="display: inline-block;">current scale: </div>
        <div style="display: inline-block;"id="debug_scale"></div>
      </div>
      <div>
        <div style="display: inline-block;">offset: </div>
        <div style="display: inline-block;" id="debug_offset"></div>
      </div>
      <div>
        <div style="display: inline-block;">nb objects: </div>
        <div style="display: inline-block;" id="debug_nbObjects"></div>
      </div>
      <div>
        <div style="display: inline-block;">current object rect: </div>
        <div style="display: inline-block;" id="debug_currObjRect"></div>
      </div>
      <div>
        <div style="display: inline-block;">activeColor: </div>
        <div style="display: inline-block;" id="debug_activeColor">"   "</div>
      </div>
    </div>

    <script>
      class Debug {
        constructor (eltsDict) {
          this.eltsDict = eltsDict;
        }

        setScale(scale) {
          this.eltsDict["scale"].innerHTML = JSON.stringify(scale);
        }
        setOffset(offset) {
          this.eltsDict["offset"].innerHTML = JSON.stringify(offset);
        }
        setNbObjects(nb_objects) {
          this.eltsDict["nb_objects"].innerHTML = nb_objects;
        }
        setCurrentObjectRect(current_object_rect) {
          this.eltsDict["current_object_rect"].innerHTML = JSON.stringify(current_object_rect);
        }

        setActiveColor(color) {
          this.eltsDict["active_color"].style.backgroundColor = color;
        }

      }

      const debugEltsDict = {
        scale:                document.getElementById("debug_scale"),
        offset:               document.getElementById("debug_offset"),
        nb_objects:           document.getElementById("debug_nbObjects"),
        current_object_rect:  document.getElementById("debug_currObjRect"),

        active_color:         document.getElementById("debug_activeColor"),
      };
      const debug = new Debug(debugEltsDict);

    </script>




    <script>

/**** model  ****/

    const RedrawOccasion = {
      // "forceRedraw"   : 0,
      "forceRedraw"   : "forceRedraw",


      // "offsetChanged" : 10,
      "offsetChanged"       : "offsetChanged",
      // "scaleChanged"  : 11,
      "scaleChanged"        : "scaleChanged",
      "orientationChanged"  : "orientationChanged",


      // "objectAdded"   : 20,
      "objectAdded"     : "objectAdded",
      "pureObjectAdded" : "pureObjectAdded",

      "objectRemoved"     : "objectRemoved",



      // "windowResize"  : 100,
      "windowResize"  : "windowResize",
    };


    class InfiniteCanvas {

      constructor(canvas, inputProperties) {

        this.canvas          = canvas;
        this.inputProperties = inputProperties;

          //--properties

        this.coords_initial = {
          scale: {
            X:1,
            Y:1,
          },
          offset: {
            dx: 0,
            dy: 0,
          },
          orientation: 0,
        };

        // coordinates of our cursor
        this.cursor = {
          x: 0,
          y: 0,
        };
        this.previousCursor = Object.assign({}, this.cursor);


        // distance from origin
        this.offset         = Object.assign({}, this.coords_initial.offset);
        this.previousOffset = Object.assign({}, this.offset);
        this.dOffset = {
          dx: 0,
          dy: 0,
        };

        // zoom amount
        this.scale = Object.assign({}, this.coords_initial.scale);

        this.orientation = this.coords_initial.orientation;

        this.didUpdateListeners = [];


          //--objects

        this.icObjects = {
          any: [],
        };
        this.didAddObjectListeners = [];

        this.pure_icObjects = {
          any: [],
        };
        this.didAddPureObjectListeners = [];

        this.creationManagers = {};



        this.represented = {};
        this.didAddRepresentedListeners = [];
        this.representations = {};
        this.didAddRepresentationListeners = [];


        this.didUpdateListenersDict = {
          // "objectAdded": [],
          "scaleChanged": [],
        };

        this.requestSyncWithIcObjListeners = [];

        this.icObjListeners = [];


        this.redrawCanvasListeners = [];
        this.setupRedrawConditions();

        this.counter = 0;


        this.configureInitialIcObjects();




          //--track changes

        // this.lastChangeTimestamp = null;
        this.changed            = false;



        var mySaveTimeout = null;

        const infiniteCanvas = this;
        window.addEventListener("beforeunload", (e) => {
          console.log("beforeunload", e);

          if(infiniteCanvas.changed /*&& !infiniteCanvas.leaveWithoutSaving*/) {

            const infiniteCanvas = this;
            const infinishute_p  = this.createInfinishute_p();

            function userStaysOnPage() {
              infiniteCanvas.manageSaveInfinishute_p_2(infinishute_p);
            }

            setTimeout(function() {                   //the nested setTimeout is the working way :)
              mySaveTimeout = setTimeout( () => {
                userStaysOnPage();
              }, 100 );
            },1);

          }

        });

        window.addEventListener('unload', function onUnload(e) {
          console.log("onUnload", e);
          clearTimeout(mySaveTimeout);
        });

      }

      setChanged(changed) {
              //uncomment for promptWhenUnsavedChanges
        // this.changed = changed;
        this.changed = false;


        if(this.changed) {
          window.onbeforeunload = () => {
            return "You have unsaved changes;";
          };

        } else {
          window.onbeforeunload = null;
        }

      }

      //properties

      update(propName, newValue) {
        const oldValue = this[propName];
        this[propName] = newValue;
        this.didUpdate(propName, oldValue, newValue);
      }

      didUpdate(propName, oldValue, newValue) {
        this.didUpdateListeners.forEach((listener, i) => {
          listener(this, propName, oldValue, newValue);
        });
      }


      //objects
        //creation

      generateIcObjectId() {
        const id = this.counter;
        this.counter += 1;
        return id;
      }

      createIcObject(type, position, size, homeScale) {

        const id = this.generateIcObjectId();

        const icObj = new IcObject(id, type, position, size, homeScale);
        return icObj;

        // return this.createRepresentedIcObject(icObj);
      }

      createRepresentedIcObject(icObj) {

        const icObj__represented  = RepresentedFactory.initial(icObj);
        const icObj__rep_official = icObj__represented.r_official();

        const icObj__rep_free     = icObj__represented.createNewRepresentationWithName("free");
        icObj__rep_free.addInteraction_hold();

        if(icObj.type == "composite") {

          icObj__represented.parts  = {};
          icObj__rep_official.parts = {};
          icObj__rep_free.parts     = {};

          Object.entries(icObj.parts)
                .forEach(([partName, part_icObj], i) => {

                  const part__represented  = this.createRepresentedIcObject(part_icObj);
                  const part__rep_official = part__represented.r_official();
                  const part__rep_free     = part__represented.createNewRepresentationWithName("free");
                  part__rep_free.addInteraction_hold();

                  icObj__represented.parts[partName]  = part__represented;
                  icObj__rep_official.parts[partName] = part__rep_official;
                  icObj__rep_free.parts[partName]     = part__rep_free;
                });
        }

        return icObj__represented;
      }

      tetherIcObject(represented) {
        const infiniteCanvas = this;

        // icObj.didUpdateListeners.push((icObj, requestCanvasRedraw) => {
        //   infiniteCanvas.manageIcObjUpdate(icObj, requestCanvasRedraw);
        // });

        const rep_official = represented.r_official();
        rep_official.onOuterUpdate((rep_official, updateDict) => {
          console.log("rep_official", "onOuterUpdate", rep_official);
          infiniteCanvas.icObjDidUpdate(rep_official, updateDict);
        });

        const rep_free     = represented.r_free();
        rep_official.follow(rep_free);

      }

      introduceToExistingObjects(represented) {

        this.introduceToExistingType_touchSlot(represented);
      }

      introduceToExistingType_touchSlot(represented) {

        const rep_official__incoming = represented.r_official();

        const existing_type = "touchSlot";

        const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
        const arr_official_exisitingType = arr_official.filter(rep => (rep.type == existing_type));
        arr_official_exisitingType.forEach((rep, i) => {

          const id_touchSlot = rep.id;

          rep_official__incoming.touchStateDict[id_touchSlot] = TouchState.Untouched;
          //SHU TODO: check if touches

        });

      }

      getRepresented(id) {
        return this.represented[id];
      }

      createIcRect_withLTWH(left, top, width, height) {

        const type      = "rect";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;
      }

      createIcRect_withLTRB(left, top, right, bottom) {
        const width  = right - left;
        const height = bottom - top;
        const icRect = this.createRect_withLTWH(left, top, width, height);

        return icRect;
      }

      createIcRect(trueRect) {

        const type      = "rect";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;
      }

      createIcPoint(point) {

        const type      = "point";
        const position  = Geometry.createPoint(point.x, point.y);
        const size      = Geometry.createSize(0, 0);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icPoint_spec = {
          "color"   : "blue",
          "name"    : "A",
        };

        const icPoint = Object.assign(icObj, icPoint_spec);

        return icPoint;

      }

      createIcCircle(left, top, width, height, fillColor = '') {

        const type      = "circle";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const radius = width / 2;

        const icCircle_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,

          radius   : radius,

          "stroke" : "blue",
          "fill"   : fillColor,
        };

        const icCircle = Object.assign(icObj, icCircle_spec);

        return icCircle;
      }


      createIcText(left, top, text) {

        const type      = "text";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(0, 0);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        // const text     = "icText";
        const fontSize = 100;

        const icText_spec = {
          text:      text,
          textColor: "black",
          fontSize:  fontSize,
        };

        const icText = Object.assign(icObj, icText_spec);

        return icText;
      }

      createIcImage(left, top, img) {
        const type      = "image";
        const position  = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size      = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icImage_spec = {
          img : img,
        };

        const icImage = Object.assign(icObj, icImage_spec);

        return icImage;
      }

      createIcFreeDrawing_from_freeDrawingFObj(fObj) {
        console.log("createIcFreeDrawing_from_freeDrawingFObj", fObj);
        console.log("createIcFreeDrawing_from_freeDrawingFObj", fObj.constructor.name);


        const type      = "freeDrawing";


        const trueRect  = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size     = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        const exoObject = Object.assign({}, fObj);
        exoObject.icObj = null; // remove circular dependency

        const icFreeDrawing_spec = {
          // path: fObj.path,

          exoObject: exoObject,
        };

        const icFreeDrawing = Object.assign(icObj, icFreeDrawing_spec);

        return icFreeDrawing;
      }

      createIcSvg(left, top, svgEl) {
        const type      = "svg";
        const position  = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size      = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSvg_spec = {
          svg : svgEl,
        };

        var icSvg = Object.assign(icObj, icSvg_spec);

        const color_property = {
          get color() {
            return icSvg.svg.style.color;
          },
          set color(value) {
              icSvg.svg.style.color = value;
          },
        };

        icSvg = Object.assign(icSvg, color_property);

        return icSvg;
      }

      createIcTex(left, top, tex) {
        const type      = "tex";
        const position  = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size      = Geometry.createSize(500, 500);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icTex_spec = {
          tex: tex,
        };

        const icTex = Object.assign(icObj, icTex_spec);

        //debug
        // const infiniteCanvas = this;
        // setTimeout(() => {
        //   const tex = '\\frac{50}{50x^2-50}';
        //
        //   const represented = infiniteCanvas.getRepresented(icObj.id);
        //   // const rep_official = represented.r_official();
        //   // rep_official.tex = tex;
        //   const rep_free = represented.r_free();
        //   rep_free.tex = tex;
        //
        // }, 5000);

        return icTex;
      }

      createIcExpr(left, top, expr) {
        const type      = "expr";
        const position  = Geometry.createPoint(left, top);

        // const size      = Geometry.createSize(img.width, img.height);
        const size      = Geometry.createSize(100, 100);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icExpr_spec = {
          expr: expr,
        };

        const icExpr = Object.assign(icObj, icExpr_spec);

        return icExpr;
      }



      createIcGroupWithChildIcObjects(arr_icObjs) {
        console.log("createIcGroupWithChildIcObjects", arr_icObjs);

        const type      = "group";

        const trueRect  = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size     = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icGroup_spec = {
          children: children,
        };

        const icGroup = Object.assign(icObj, icGroup_spec);

        return icGroup;
      }

      createIcGroup_from_groupFObj(fObj) {
        console.log("createIcGroup_from_groupFObj", fObj);

        const type      = "group";

        const trueRect  = this.toTrueRect(fObj);
        const position  = Geometry.getPointTL(trueRect);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const fChildren  = fObj.getObjects();
        const icChildren = fChildren.map(fObj => {
          const icObj = fObj.icObj;

          //?add position wrt group
          return icObj;
        });

        const icGroup_spec = {
          children: icChildren,
        };

        const icGroup = Object.assign(icObj, icGroup_spec);

        return icGroup;
      }

      createIcActiveSelection_from_activeSelectionFObj(fObj) {
        console.log("createIcActiveSelection_from_activeSelectionFObj", fObj);

        const type      = "activeSelection";

        const trueRect  = this.toTrueRect(fObj);
        const position  = Geometry.getPointTL(trueRect);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const fChildren  = fObj.getObjects();
        const icChildren = fChildren.map(fObj => {
          const icObj = fObj.icObj;

          //add position wrt group

        });

        const icActiveSelection_spec = {
          children: icChildren,
        };

        const icActiveSelection = Object.assign(icObj, icActiveSelection_spec);

        return icActiveSelection;

      }




      createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive) {

        const type      = "toggleRect";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icToggleRect_spec = {
          activeCfg:   activeCfg,
          inactiveCfg: inactiveCfg,

          isActive:    isActive,
        };

        const icToggleRect = Object.assign(icObj, icToggleRect_spec);

        return icToggleRect;

      }



      createIcSnapSlot(trueRect, snapEngineGenFunc_in = null) {
        console.log("createIcSnapSlot");

        const infiniteCanvas = this;

        const type      = "snapSlot";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        //debug for icText snapping
        // const icTextSize = {
        //   width:  248.4375,
        //   height: 113,
        //   // width:  268.4375,
        //   // height: 130,
        // };
        // icObj.size = icTextSize;

        var snapEngineGenFunc = snapEngineGenFunc_in;
        if(snapEngineGenFunc == null) {
          // console.log("snapEngine == null");
          snapEngineGenFunc = (icSnapSlot) => Snap.defaultSnapEngine(infiniteCanvas, icSnapSlot);
        }
        const snapEngine = snapEngineGenFunc(icObj);

        const icSnapSlot_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 3,

          snapEngine: snapEngine,
        };

        const icSnapSlot = Object.assign(icObj, icSnapSlot_spec);

        //add reactive part
        this.mutateSnapSlot__addReactivePart(icSnapSlot);

        return icSnapSlot;
      }

      mutateSnapSlot__addReactivePart(icSnapSlot) {
        console.log("mutateSnapSlot__addReactivePart", icSnapSlot);

        const infiniteCanvas = this;

        // const canSnapFunc__default = (icObj_piece) => {
        //   return true;
        // };
        //
        // var canSnapFunc;
        // if(canSnapFunc_param != null) {
        //   canSnapFunc = canSnapFunc_param;
        // } else {
        //   canSnapFunc = canSnapFunc__default;
        // }

        icSnapSlot.snapEngine.start();
        infiniteCanvas.onIcObjUpdate(icSnapSlot.snapEngine.r_official_update_handler2);

        //SHU TODO: infiniteCanvas.offIcObjUpdate when snap slot is destroyed

      }

      createIcLine_start() {
        // console.log("createIcLine_start");

        //check
        {
          const creationManager_line = this.creationManagers["line"];
          if(creationManager_line != null) {
            throw new Error("createIcLine_start, creationManager_line != null");
          }
        }

        // this.creationManagers["line"] = new LineCreationManager();
        this.creationManagers["line"] = {};
        const creationManager_line = this.creationManagers["line"];

        const true_cursor = this.getTrueCursor();

        creationManager_line.point_start = Object.assign({}, true_cursor);
      }

      createIcLine_end() {
        // console.log("createIcLine_end");

        //check
        {
          const creationManager_line = this.creationManagers["line"];
          if(creationManager_line == null) {
            throw new Error("createIcLine_end, creationManager_line == null");
          }
        }

        const creationManager_line = this.creationManagers["line"];

        const true_cursor = this.getTrueCursor();

        creationManager_line.point_end = Object.assign({}, true_cursor);

        // this.createIcLine(creationManager_line.point_start, creationManager_line.point_end);
        const icSegment = this.createIcSegment(creationManager_line.point_start, creationManager_line.point_end);
        this.addIcObject(icSegment);

        delete this.creationManagers["line"];
      }

      createIcLine(startPoint, endPoint) {

        const type      = "line";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;

      }

      createIcSegment(point_start, point_end) {
        // console.log("createIcSegment", point_start, point_end);

        const type      = "segment";
        const position  = null;
        const size      = null;
        const homeScale = "none";

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icSegment_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
          point_start: point_start,
          point_end: point_end,
        };

        const icSegment = Object.assign(icObj, icSegment_spec);

        return icSegment;
      }


      // createIcSparkle(trueRect, img, sparkleConfig) {
      createIcSparkle(truePoint, img, sparkleConfig) {
        // console.log("createIcSparkle", truePoint, sparkleConfig);

        const type     = "sparkle";

        // const position = Geometry.getPointTL(trueRect);
        // const size     = Geometry.createSize(trueRect.width, trueRect.height);
        // const center = Geometry.getCenterPoint(trueRect);
        const position = {
          x: truePoint.x,
          y: truePoint.y,
        };
        const size     = Geometry.createSize(img.width, img.height);

        const homeScale = {
          // X: this.scale.X * 10,
          // Y: this.scale.Y * 10,
          X: this.scale.X,
          Y: this.scale.Y,
        };

        const icObj = this.createIcObject(type, position, size, homeScale);



        const icSparkle_spec = {
          isUsingCenterPosition: true,
          // center: center,

          homeScale_max: 10000,
          homeScale_min: 0,

          img: img,

          isSnappable: false,
        };

        const icSparkle = Object.assign(icObj, icSparkle_spec);

        return icSparkle;
      }

      debug_sparkleAnims(isAnimPaused) {
        console.log("debug_sparkleAnims(", isAnimPaused, ")");

        const arr_sparkles = Object.values(this.represented)
                                   .map(represented => {
                                     // return represented.r_official();
                                     return represented.r_free();
                                   })
                                   .filter(rep => {
                                     const isSparkle = (rep.type == "sparkle");
                                     return isSparkle;
                                   });

        arr_sparkles.forEach((rep, i) => {
          rep.isAnimPaused = isAnimPaused;

          const animation = rep.animation;
          const progress  = animation.progress / 100.0;
          console.log("debug_sparkleAnims: progress", progress);

          if(isAnimPaused) {
            animation.pause();
          } else {
            animation.play();
          }
        });
      }



      createIcTouchSlot(trueRect, touchSlotConfig) {
        console.log("createIcTouchSlot");

        const infiniteCanvas = this;

        const type      = "touchSlot";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        //debug for icText snapping
        // const icTextSize = {
        //   width:  248.4375,
        //   height: 113,
        //   // width:  268.4375,
        //   // height: 130,
        // };
        // icObj.size = icTextSize;


        const icTouchSlot_spec = {
          isSnappable: false,

          stroke: "black",
          strokeWidth: 3,

          touchSlotConfig: touchSlotConfig,
        };

        const icTouchSlot = Object.assign(icObj, icTouchSlot_spec);

        //add reactive part
        this.mutateTouchSlot__addReactivePart(icTouchSlot, touchSlotConfig);

        return icTouchSlot;
      }

      mutateTouchSlot__addReactivePart(icTouchSlot) {
        console.log("mutateTouchSlot__addReactivePart", icTouchSlot);

        const infiniteCanvas = this;

        const attemptTouching = function(icObj_slot, icObj_piece) {
          console.log("attemptTouching", icObj_slot, icObj_piece);

          const canTouch = checkCanTouch(icObj_slot, icObj_piece);

          const rep_official = icObj_piece;
          console.log("attempting to touch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

          if(canTouch) {
            console.log("can touch");

            const rep_official = icObj_piece;
            const represented  = icObj_piece.represented;
            const rep_free     = represented.getRepresentation("free");

            // console.log("rep_free.isHeld", rep_free.isHeld);
            // if(rep_free.isHeld) {
            //   presnap(icObj_slot, icObj_piece);
            // } else {
            //   presnap(icObj_slot, icObj_piece);
            //   snap(icObj_slot, icObj_piece);
            // }

            touch(icObj_slot, icObj_piece);

          } else {
            console.log("can't touch");
          }

        };

        const checkCanTouch = function(icObj_slot, icObj_piece) {
          console.log("checkCanTouch", icObj_piece);
          var outBool;

          outBool = Touch.canTouch(icObj_piece, icObj_slot);

          return outBool;
        };


        const touch = function(icObj_slot, icObj_piece) {
          console.log("touch", icObj_piece);

          const rep_official = icObj_piece;
          // const represented  = icObj_piece.represented;
          // const rep_free     = represented.getRepresentation("free");
          // const rep_touched  = represented.getRepresentation("snapped");

          rep_official.touchStateDict[icObj_slot.id] = TouchState.Touched;

          const represented  = icObj_piece.represented;
          const rep_free     = represented.getRepresentation("free");

          //apply mutation
          console.log("touch: apply mutation");
          // console.log("rep_official.text", rep_official.text);
          if(rep_official.text != null) {

            /*
            const number_in   = parseInt(rep_official.text,10);
            const number_out  = number_in + 1;

            rep_free.text     = "" + number_out;
            */

            const number_in   = parseInt(rep_official.text,10);
            const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            const number_out  = transformationFunc(number_in);

            rep_free.text     = "" + number_out;
          }
          // console.log("rep_official.text", rep_official.text);


          if(rep_official.expr != null) {

            // const tex_in    = rep_official.tex;
            // const expr_in   = algebra.fromTex(tex_in);
            const expr_in = rep_official.expr;

            const transformationFunc = icTouchSlot.touchSlotConfig.transformationFunc;
            const expr_out  = transformationFunc(expr_in);

            rep_free.expr = expr_out;

            // const tex_out = expr_out.toTex();
            // rep_free.tex  = tex_out;
          }



        };





        const attemptUntouching = function(icObj_slot, icObj_piece) {
          console.log("attemptUntouching", icObj_slot, icObj_piece);

          const canUntouch = checkCanUntouch(icObj_slot, icObj_piece);
          console.log("canUntouch", canUntouch);

          const rep_official = icObj_piece;
          console.log("attempting to untouch with touchState: " + rep_official.touchStateDict[icObj_slot.id]);

          if(canUntouch) {
            // console.log("can untouch");
            untouch(icObj_slot, icObj_piece);

          } else {
            // console.log("can't untouch");
          }

        };

        const checkCanUntouch = function(icObj_slot, icObj_piece) {
          console.log("checkCanUntouch", icObj_piece);
          var outBool;

          outBool = Touch.canUntouch(icObj_piece, icObj_slot);

          return outBool;
        };

        const untouch = function(icObj_slot, icObj_piece) {
          console.log("untouch", icObj_piece);

          const rep_free     = icObj_piece;   //SHU: this is probably false

          const represented  = icObj_piece.represented;
          const rep_official = represented.getRepresentation("official");

          rep_official.touchStateDict[icObj_slot.id] = TouchState.Untouched;
        };



        const r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
          console.log("r_official_update_handler", icObj_piece);

          const touchState = icObj_piece.touchStateDict[icObj_slot.id];
          console.log("touchState", touchState);

          if(touchState == TouchState.Untouched) {
            attemptTouching(icObj_slot, icObj_piece);
          } else if(touchState == TouchState.Touched) {
            attemptUntouching(icObj_slot, icObj_piece);
          }

        };

        const r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
          console.log("r_official_update_handler2", rep_official_incoming);

          const represented  = infiniteCanvas.getRepresented(icTouchSlot.id);
          console.log("represented", represented);
          const rep_official = represented.r_official();

          const touchSlot   = rep_official;
          const incomingObj = rep_official_incoming;

          if(incomingObj != touchSlot) { //don't touch oneself

            if(!incomingObj.isTouchable) {
              //ignore: incomingObj is intangible
            } else {
              r_official_update_handler(touchSlot, incomingObj, outerUpdatesDict);
            }

          } else {
            console.log("I won't touch myself");  //SHU: ...
          }

        };

        infiniteCanvas.onIcObjUpdate(r_official_update_handler2);

        //for each existing canvas object, add touchState wrt this new touchSlot
        infiniteCanvas.onceOnAddRepresentedForIcObject(icTouchSlot, (icTouchSlot) => {

          const id_touchSlot = icTouchSlot.id;

          const arr_official = Object.values(infiniteCanvas.represented).map(represented => represented.r_official());
          const arr_official_preexisiting = arr_official.filter(rep => (rep.id != id_touchSlot));
          arr_official_preexisiting.forEach((rep, i) => {

            rep.touchStateDict[id_touchSlot] = TouchState.Untouched;
            //SHU TODO: check if touches

          });

        });

      }

      // createIcComposite(parts, engine) {
      createIcComposite_debug(trueRect) {
        console.log("createIcComposite_debug", trueRect);

        function createPartsDict() {
          // const part1_trueRect = trueRect;
          const part1_trueRect = {
            x:      trueRect.x + 400,
            y:      trueRect.y + 50,
            width:  trueRect.width,
            height: trueRect.height,
          };
          const part1_icObj    = infiniteCanvas.createIcRect(part1_trueRect);
          part1_icObj.fill     = "cyan";
          part1_icObj.isMobile = false;

          // const part2_trueRect = {
          //   x:      trueRect.x + 400,
          //   y:      trueRect.y + 50,
          //   width:  trueRect.width,
          //   height: trueRect.height,
          // };
          const part2_trueRect = part1_trueRect;
          const part2_icObj    = infiniteCanvas.createIcRect(part2_trueRect);
          part2_icObj.fill     = "orange";
          part2_icObj.isMobile = true;

          const part3_trueRect = part1_trueRect;
          const part3_icObj    = infiniteCanvas.createIcRect(part2_trueRect);
          part3_icObj.fill     = "magenta";
          part3_icObj.isMobile = true;

          const partsDict = {
            "part1": part1_icObj,
            "part2": part2_icObj,
            "part3": part3_icObj,
          };

          return partsDict;
        }

        const parts      = createPartsDict();
        const engineFunc = (icObj, parts) => Compositer.defaultCompositeEngine(icObj, parts);

        const icComposite = this.createIcComposite(trueRect, parts, engineFunc);

        return icComposite;
      }

      mutateComposite__addReactivePart(icComposite) {

        const infiniteCanvas = this;

        // infiniteCanvas.onIcObjUpdate(icComposite.engine.manageIcObjUpdate);
        // icComposite.engine.start();
      }

      createIcComposite(trueRect, parts, engineFunc_in = null) {
        console.log("createIcComposite", trueRect);

        const infiniteCanvas = this;

        const type      = "composite";

        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);
        const icObj = this.createIcObject(type, position, size, homeScale);

        Object.values(parts).forEach((part, i) => {
          part.isCompositePart = true;
          part.compositeId     = icObj.id;
        });

        var engineFunc = engineFunc_in;
        if(engineFunc == null) {
          engineFunc = (icObj, parts) => Compositer.defaultCompositeEngine(icObj, parts);
        }
        const engine = engineFunc(icObj, parts);

        const icComposite_spec = {
          isSnappable: false,

          // stroke: "red",
          // strokeWidth: 4,

          fill: "pink",

          parts:  parts,
          engine: engine,
        };

        const icComposite = Object.assign(icObj, icComposite_spec);

        //add reactive part
        this.mutateComposite__addReactivePart(icComposite);

        return icComposite;
      }


      createIcWell(trueRect) {
        console.log("createIcWell", trueRect);

        const startingValue = 1;

        const canSnapFunc  = (above, below) => {
          var outBool;

          const canSnapFunc_geometryWise = (above, below) => {
            // return Snap.canSnap(above, below);
            return Snap.canSnap_noSize(above, below);
          };

          // const canSnapFunc_valueWise    = (above, below) => (above.value == targetValue);
          // const canSnapFunc_valueWise    = (above, below) => {
          //   const value = parseInt(above.text,10);
          //   const isValueValid = (value == targetValue);
          //   return isValueValid;
          // };

          const canSnapFuncs = {
            "geometry": canSnapFunc_geometryWise,
            // "value":    canSnapFunc_valueWise,
          };

          const canSnapFunc_allWise = (above, below) => Object.entries(canSnapFuncs).reduce((acc, [canSnapFunc_xWiseName, canSnapFunc_xWise]) => {
            const canSnap_xWise = canSnapFunc_xWise(above,below);
            console.log("canSnap_xWise", canSnapFunc_xWiseName, canSnap_xWise);
            return acc && canSnap_xWise;
          }, true);

          const canSnap_allWise = canSnapFunc_allWise(above, below);
          console.log("canSnap_allWise", canSnap_allWise);

          outBool = canSnap_allWise;

          return outBool;
        };
        const canUnsnapFunc  = (above, below) => {
          return Snap.canUnsnap(above, below);
        };
        // const snapMutationFunc  = (above, below) => {   //SHU TODO: toSnapState mutations: toPresnapped, toSnapped, toUnsnapped
        //   //how rep_snapped  will differ from rep_official
        //   //how snappedState will differ from rep_official
        // };
        const snapEngineGenFunc = (icSnapSlot) => {
          const snapEngine = Snap.defaultSnapEngine(infiniteCanvas, icSnapSlot);
          snapEngine.canSnapFunc   = canSnapFunc;
          snapEngine.canUnsnapFunc = canUnsnapFunc;

          snapEngine.will['unsnap'].on((snapSlot, icObj) => {
            console.log("well, snapEngine.will['unsnap']", snapSlot, icObj);

            const cloned = icObj.deepClone();
            cloned.snapState = SnapState.Unsnapped;
            cloned.position = Object.assign({}, snapSlot.position);
            infiniteCanvas.addIcObject(cloned);

            // snapEngine.clonedObj = cloned;
          });

          return snapEngine;
        };

        const snapSlot     = infiniteCanvas.createIcSnapSlot(trueRect, snapEngineGenFunc);
        snapSlot.fill      = "lightblue";
        snapSlot.isMobile  = false;

        const text          = startingValue.toString(10);
        const stem          = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        stem.textColor       = "blue";
        stem.backgroundColor = "";
        stem.isMobile       = true;
        stem.isTouchable    = true;

        infiniteCanvas.onceOnAddRepresentedForIcObject(stem, (stem) => {

          //get free rep
          const represented = infiniteCanvas.getRepresented(stem.id);
          console.log("represented", represented);
          const rep_free = represented.r_free();

          infiniteCanvas.greenMouseify(rep_free);

          rep_free.greenMouseCurse_start();
        });


        const parts = {
          "snapSlot": snapSlot,
          "stem":     stem,
        };

        const engineFunc = (icObj, parts) => Compositer.defaultCompositeEngine(icObj, parts);

        const icComposite = this.createIcComposite(trueRect, parts, engineFunc);
        icComposite.cType = "well";

        icComposite.isTouchable = false;

        return icComposite;
      }

      mutateWell__addReactivePart(icWell) {

      }

      greenMouseify(rep) {
        console.log("greenMouseify", rep);

        rep.deathFunc = () => {
          console.log("greenMouse, deathFunc");
          rep.im_dead_now = true;
        };

        rep.greenMouseCurse = (icObj) => {
          console.log("greenMouse, curse()");
          rep.greenMouseCurse_end();
          rep.deathFunc();
        };

        rep.greenMouseCurse_start = () => {
          rep.onRelease(rep.greenMouseCurse);
        };

        rep.greenMouseCurse_end = () => {
          rep.offRelease(rep.greenMouseCurse);
        };

      }

      createIcGreenMouseWell(trueRect) {

      }

      mutateGreenMouseWell__addReactivePart(icGreenMouseWell) {

      }

      createIcGMOperator(trueRect) {
        console.log("createIcGMOperator", trueRect);

        // var operator = new Operator("+1");
        const rank            = this.getNextTouchSlotRank();
        const operatorConfig  = GMOperatorMama.operatorConfigForRank(rank);

        const touchSlotConfig = {
          transformationFunc: operatorConfig.transformationFunc,
        };

        const touchSlot    = infiniteCanvas.createIcTouchSlot(trueRect, touchSlotConfig);
        touchSlot.fill     = "";
        touchSlot.isMobile = false;

        const text         = operatorConfig.name;
        const facade       = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        facade.backgroundColor = "blanchedalmond";
        facade.isMobile    = false;
        facade.isTouchable = false;

        const parts = {
          "touchSlot": touchSlot,
          "facade":    facade,
        };

        const engineFunc = (icObj, parts) => Compositer.defaultCompositeEngine(icObj, parts);

        const icComposite = this.createIcComposite(trueRect, parts, engineFunc);
        icComposite.cType = "gm_operator";

        icComposite.isTouchable = false;

        return icComposite;
      }


      createIcGMTargetSlot(trueRect) {
        console.log("createIcGMTargetSlot", trueRect);

        const targetValue = -48;

        const text          = targetValue.toString(10);
        const backade       = infiniteCanvas.createIcText(trueRect.x, trueRect.y, text);
        backade.backgroundColor = "grey";
        backade.isMobile    = false;
        backade.isTouchable = false;

        const canSnapFunc  = (above, below) => {
          var outBool;

          const canSnapFunc_geometryWise = (above, below) => {
            // return Snap.canSnap(above, below);
            return Snap.canSnap_noSize(above, below);
          };

          // const canSnapFunc_valueWise    = (above, below) => (above.value == targetValue);
          const canSnapFunc_valueWise    = (above, below) => {
            const value = parseInt(above.text,10);
            const isValueValid = (value == targetValue);
            return isValueValid;
          };

          const canSnapFuncs = {
            "geometry": canSnapFunc_geometryWise,
            "value":    canSnapFunc_valueWise,
          };

          const canSnapFunc_allWise = (above, below) => Object.entries(canSnapFuncs).reduce((acc, [canSnapFunc_xWiseName, canSnapFunc_xWise]) => {
            const canSnap_xWise = canSnapFunc_xWise(above,below);
            console.log("canSnap_xWise", canSnapFunc_xWiseName, canSnap_xWise);
            return acc && canSnap_xWise;
          }, true);

          const canSnap_allWise = canSnapFunc_allWise(above, below);
          console.log("canSnap_allWise", canSnap_allWise);

          outBool = canSnap_allWise;

          return outBool;
        };
        const canUnsnapFunc  = (above, below) => {
          return Snap.canUnsnap(above, below);
        };
        // const snapMutationFunc  = (above, below) => {   //SHU TODO: toSnapState mutations: toPresnapped, toSnapped, toUnsnapped
        //   //how rep_snapped  will differ from rep_official
        //   //how snappedState will differ from rep_official
        // };
        const snapEngineGenFunc = (icSnapSlot) => {
          const snapEngine = Snap.defaultSnapEngine(infiniteCanvas, icSnapSlot);
          snapEngine.canSnapFunc   = canSnapFunc;
          snapEngine.canUnsnapFunc = canUnsnapFunc;
          return snapEngine;
        };

        const snapSlot     = infiniteCanvas.createIcSnapSlot(trueRect, snapEngineGenFunc);
        snapSlot.fill      = "";
        snapSlot.isMobile  = false;



        const parts = {
          "backade":  backade,
          "snapSlot": snapSlot,
        };

        const engineFunc = (icObj, parts) => Compositer.defaultCompositeEngine(icObj, parts);

        const icComposite = this.createIcComposite(trueRect, parts, engineFunc);
        icComposite.cType = "gm_targetSlot";

        icComposite.isTouchable = false;


        return icComposite;
      }





        //add
      addIcObject(icObj) {
        console.log("addIcObject", icObj);

        const represented = this.createRepresentedIcObject(icObj);
        this.addRepresented(represented);

        // this.didAddIcObject();
      }

      didAddIcObject(icObj) {

      }

      addRepresented(represented) {
        console.log("addRepresented", represented);

        this.tetherIcObject(represented);   //== track icObj updates

        this.introduceToExistingObjects(represented);

        //store
        const rep_official = represented.r_official();
        this.represented[rep_official.id] = represented;

        //add free representation
        const rep_free = represented.r_free();
        this.addRepresentation(represented, rep_free);

        if(rep_official.type == "composite") {
          Object.values(represented.parts).forEach((part__represented, i) => {
            this.addRepresented(part__represented);
          });
        }

        this.didAddRepresented(represented);
      }

      didAddRepresented(represented) {
        this.setChanged(true);

        this.didAddRepresentedListeners.forEach((listener, i) => {
          listener(represented);
        });
      }

      onAddRepresented(listener) {
        this.didAddRepresentedListeners.push(listener);
      }

      offAddRepresented(listener) {
        this.didAddRepresentedListeners = Utils.arrayByRemovingElement(this.didAddRepresentedListeners, listener);
      }

      onceOnAddRepresentedForIcObject(icObject, func) {

        var autoUnsub = (represented) => {

          //compare icObject with represented
          const r_official = represented.r_official();
          if(r_official.id == icObject.id) {
            this.offAddRepresented(autoUnsub);
            func(icObject);
          }

        }

        this.onAddRepresented(autoUnsub);
      }

      addRepresentation(represented, representation) {

        if(this.representations[representation.id_rep] == null) {
          this.representations[representation.id_rep] = representation;
        } else {
          throw new Error("oh, no, id collision for id: " + representation.id_rep);
        }

        this.didAddRepresentation(represented, representation);
      }

      didAddRepresentation(represented, representation) {
        this.setChanged(true);

        this.didAddRepresentationListeners.forEach((listener, i) => {
          listener(represented, representation);
        });

        this.redrawCanvas(RedrawOccasion.objectAdded);
      }

      removeRepresentation(represented, representation) {

        delete this.representations[representation.id_rep];

        this.didRemoveRepresentation(represented, representation);
      }

      didRemoveRepresentation(represented, representation) {
        this.setChanged(true);

        // this.didAddObjectListeners.forEach((listener, i) => {
        //   listener(icObj);
        // });

        this.redrawCanvas(RedrawOccasion.objectRemoved);
      }

      addPureIcObject(icObj) {

        this.pure_icObjects["any"].push(icObj);


        if(this.pure_icObjects[icObj.type] == null) {
          this.pure_icObjects[icObj.type] = [];
        }
        this.pure_icObjects[icObj.type].push(icObj);

        this.didAddPureObject(icObj);
      }

      didAddPureObject(icObj) {
        this.didAddPureObjectListeners.forEach((listener, i) => {
          listener(icObj);
        });

        this.redrawCanvas(RedrawOccasion.pureObjectAdded);
      }


      removeIcObject(icObj) {
        console.log("removeIcObject", icObj);

        //SHU TODO: removeIcObject


        this.didRemoveObject_p(icObj);
      }

      didRemoveObject_p(icObj) {
        this.setChanged(true);

        // this.didAddObjectListeners.forEach((listener, i) => {
        //   listener(icObj);
        // });
        //
        // this.redrawCanvas(RedrawOccasion.objectRemoved);
      }

      manageIcObjUpdate(icObj, requestCanvasRedraw = false) {
        console.log("manageIcObjUpdate");

        if(icObj.toBeDeleted) {
          console.log("this", this);
          this.removeIcObject(icObj);
        }

        this.icObjDidUpdate(icObj);

        this.setChanged(true);
      }

      icObjDidUpdate(icObj, outerUpdatesDict) {
        console.log("icObjDidUpdate", icObj, outerUpdatesDict);
        this.icObjListeners.forEach((listener, i) => {
          listener(icObj, outerUpdatesDict);
        });
      }

      onIcObjUpdate(listener) {
        this.icObjListeners.push(listener);
      }



      addDehydratedIcObject(icObj) {
        const rehydrated = this.rehydrated(icObj);

        this.addIcObject(rehydrated);
      }

      rehydrated(icObj) {
        var rehydrated;

        // rehydrated = icObj.clone();
        rehydrated = icObj.deepClone();


        switch(icObj.type) {
          case "snapSlot":
            const icSnapSlot = rehydrated;
            //add reactive part
            this.mutateSnapSlot__addReactivePart(icSnapSlot);
            rehydrated = icSnapSlot;
            break;
          default:
          break;
        }

        return rehydrated;
      }

      addPastedIcObject(icObj) {
        const infiniteCanvas = this;

        const true_cursor = this.getTrueCursor();

        icObj.position = {
          x: true_cursor.x,
          y: true_cursor.y,
        };

        icObj.homeScale = {
          X: infiniteCanvas.scale.X,
          Y: infiniteCanvas.scale.Y,
        };

        infiniteCanvas.addIcObject(icObj);
      }


      //convenience

      addNewIcObject(icObj) {

        icObj.orientation = this.orientation;

        const inputProperties = this.inputProperties;

        const activeColor = inputProperties.getActiveColor();
        switch(icObj.type) {
          case "rect":
          case "point":
          case "sparkle":
            icObj.fill = activeColor;
            break;
          case "text":
            icObj.textColor = activeColor;
            break;
          case "circle":
            icObj.stroke = activeColor;
            break;

          case "svg":
            icObj.stroke      = activeColor;
            icObj.strokeWidth = 5;

            icObj.fill        = "yellow";
            break;

          default:
            icObj.fill = activeColor;
            break;
        }

        icObj.opacity = inputProperties.getActiveOpacity();

        this.addIcObject(icObj);
      }

      addNewRect() {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const icRect = this.createIcRect_withLTWH(left, top, width, height);
        this.addNewIcObject(icRect);
      }

      addNewText(text = "icText") {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icText = this.createIcText(left, top, text);

        // //debug
        // const width  = 100;   //"information" size
        // const height = 100;
        // icText.width  = width;
        // icText.height = height;

        this.addNewIcObject(icText);
      }


      addNewImage(img) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icImage = this.createIcImage(left, top, img);
        this.addNewIcObject(icImage);
      }

      addNewCircle() {
        const true_cursor = this.getTrueCursor();
        const radius = 100;

        const left   = true_cursor.x;
        const top    = true_cursor.y;
        const width  = 100;   //"information" size
        const height = 100;

        const icCircle = this.createIcCircle(left, top, width, height);
        this.addNewIcObject(icCircle);
      }

      addNewPoint() {
        const true_cursor = this.getTrueCursor();

        const icPoint = this.createIcPoint(true_cursor);
        this.addNewIcObject(icPoint);


        /*
        //debug
        const point_from = this.cursor;
        const center     = this.getScreenCenterPoint();

        [10,20,30,70,80,90,  270,300, -85].forEach((angleInDegrees, i) => {

          const screenPoint = Geometry.pointWithRotation(point_from, center, angleInDegrees);
          // console.log("screenPoint", screenPoint);

          this.addPoint(this.toTruePoint(screenPoint));
        });
        */

        // function debugRotation(point_from, center) {
        //
        //   [10,20,30,70,80,90].forEach((angleInDegrees, i) => {
        //
        //     const screenPoint = Geometry.pointWithRotation(point_from, center, angleInDegrees);
        //     this.addPoint(screenPoint);
        //   });
        //
        // }
        //
        // debugRotation(this.cursor, screenCenterPoint);


      }

      // addPurePoint(point) {
      //   const icPoint = this.createIcPoint(point);
      //   this.addPureIcObject(icPoint);
      // }
      //
      // addPureCircle(center, radius) {
      //
      //   const icCircle = this.createIcCircle(center, radius);
      //   this.addPureIcObject(icCircle);
      //
      // }

      addNewSvg(svgEl) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icSvg = this.createIcSvg(left, top, svgEl);
        this.addNewIcObject(icSvg);
      }

      addNewTex(tex) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icTex = this.createIcTex(left, top, tex);
        this.addNewIcObject(icTex);
      }

      addNewExpr(expr) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icExpr = this.createIcExpr(left, top, expr);
        this.addNewIcObject(icExpr);
      }


      addNewSnapSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width:  width,
          height: height,
        };

        const icSnapSlot = this.createIcSnapSlot(trueRect);
        this.addNewIcObject(icSnapSlot);
      }

      addNewSparkle(img) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        // const width  = 100;   //"information" size
        // const height = 100;

        // const trueRect = Geometry.createRect(left, top, width, height);

        const sparkleConfig = {

        };

        // const icSparkle = this.createIcSparkle(trueRect, img, sparkleConfig);
        const icSparkle = this.createIcSparkle(true_cursor, img, sparkleConfig);
        this.addNewIcObject(icSparkle);
      }


      addNewTouchSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const rank            = this.getNextTouchSlotRank();
        const touchSlotConfig = this.touchSlotConfigForTouchSlotRank(rank);


        const icTouchSlot = this.createIcTouchSlot(trueRect, touchSlotConfig);
        this.addNewIcObject(icTouchSlot);
      }

      getNextTouchSlotRank() {
        var outNumber;
        const arr_touchSlot = Object.values(this.represented)
                                    .map(represented => represented.r_official())
                                    .filter(rep => (rep.type == "touchSlot"));
        outNumber = arr_touchSlot.length;
        return outNumber;
      }




      addNewComposite() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icComposite = this.createIcComposite_debug(trueRect);
        this.addNewIcObject(icComposite);
      }

      addNewGMOperator() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMOperator = this.createIcGMOperator(trueRect);
        this.addNewIcObject(icGMOperator);
      }

      addNewGMTargetSlot() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGMTargetSlot = this.createIcGMTargetSlot(trueRect);
        this.addNewIcObject(icGMTargetSlot);
      }


      addNewWell() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icWell = this.createIcWell(trueRect);
        this.addNewIcObject(icWell);
      }

      addNewGreenMouseWell() {
        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const trueRect = {
          x: left,
          y: top,
          width: width,
          height: height,
        };

        const icGreenMouseWell = this.createIcGreenMouseWell(trueRect);
        this.addNewIcObject(icGreenMouseWell);
      }






      configureInitialIcObjects() {

        // this.addAxes();

      }

      addAxes() {

        const icRectX = this.createIcRect_withLTWH(0, 0, 1000, 10);
        icRectX.fill = "red";
        this.addIcObject(icRectX);

        const icRectY = this.createIcRect_withLTWH(0, 0, 10, 1000);
        icRectY.fill = "blue";
        this.addIcObject(icRectY);

      }





      setupRedrawConditions() {
        // if the window changes size, redraw the canvas
        window.addEventListener("resize", (event) => {
            this.redrawCanvas(RedrawOccasion.windowResize);
        });
      }



      redrawCanvas(redrawOccasion) {

        debug.setScale(this.scale);
        debug.setOffset(this.offset);

        // console.log("this.icObjects", this.icObjects);
        // debug.setNbObjects(Object.values(this.icObjects.any).length);

        console.log("**reps[[[[[");
        Object.values(this.representations).forEach((rep, i) => {
          console.log("**rep", rep.type, rep.id_rep);
        });
        console.log("**reps]]]]]");


        const nbDisplayedRepresentations = Object.values(this.representations).length;
        debug.setNbObjects(nbDisplayedRepresentations);

        this.redrawCanvasListeners.forEach((listener, i) => {
          listener(redrawOccasion);
        });
      }




      // convert coordinates
      toScreenX(xTrue) {
          return (xTrue + this.offset.dx) * this.scale;
      }
      toScreenY(yTrue) {
          return (yTrue + this.offset.dy) * this.scale;
      }
      toScreenPoint(truePoint) {
        return Geometry.createPoint(this.toScreenX(truePoint.x), this.toScreenY(truePoint.y));
      }
      toScreenRect(trueRect) {
        const truePointTL = Geometry.createPoint(trueRect.left, trueRect.top);
        const truePointBR = Geometry.createPoint(trueRect.left + trueRect.width, trueRect.top + trueRect.height);

        const screen_pointTL = this.toScreenPoint(truePointTL);
        const screen_pointBR = this.toScreenPoint(truePointBR);

        const screen_w = screen_pointBR.x - screen_pointTL.x;
        const screen_h = screen_pointBR.y - screen_pointTL.y;

        const screenRect = Geometry.createRect(screen_pointTL.x, screen_pointTL.y, screen_w, screen_h);

        return screenRect;
      }
      toScreenSize(trueSize) {
        const screen_w  = trueSize.width  / this.scale.X;
        const screen_h  = trueSize.height / this.scale.Y;
        return Geometry.createSize(screen_w, screen_h);
      }
      // toScreenLength(trueLength) {
      //   return trueLength * this.scale;
      // }




      getOrientationBaseVectors() {
        return this.getRotationBaseVectors(this.orientation);
      }

      getStdBaseVectors() {
        return this.getRotationBaseVectors(-this.orientation);
      }

      getRotationBaseVectors(angle) {

        const cosTheta = Math.cos(angle * (Math.PI / 180));
        const sinTheta = Math.sin(angle * (Math.PI / 180));

        const orientation_vector_u = {
          x: cosTheta,
          y: sinTheta,
        };

        const orientation_vector_v = {
          x: -sinTheta,
          y: cosTheta,
        };

        const baseVectors = {
          u: orientation_vector_u,
          v: orientation_vector_v,
        };

        return baseVectors;

      }


      // toTrueX(xScreen) {
      //     return (xScreen / this.scale.X) - this.offset.dx;
      // }
      // toTrueY(yScreen) {
      //     return (yScreen / this.scale.Y) - this.offset.dy;
      // }
      toTrueX(screenPoint) {
          // console.log("toTrueX", "screenPoint", screenPoint);
          //
          // console.log("screenPoint.x", screenPoint.x);
          // console.log("this.scale.X", this.scale.X);
          // console.log("this.offset.dx", this.offset.dx);
          // console.log("this.offset", this.offset);


          const v = this.toNoOrPoint(screenPoint);

          const stdBaseVectors = this.getStdBaseVectors();
          // console.log("stdBaseVectors", stdBaseVectors);

          const trueX = Geometry.dotProduct_2d(v, stdBaseVectors.u);

          return trueX;
      }
      toTrueY(screenPoint) {
        const v = this.toNoOrPoint(screenPoint);

        const stdBaseVectors = this.getStdBaseVectors();

        return Geometry.dotProduct_2d(v, stdBaseVectors.v);
      }

      trueWidth() {
          // return canvas.clientWidth / scale;
          return this.canvas.width / this.scale.X;
      }
      trueHeight() {
          // return canvas.clientHeight / scale;
          return this.canvas.height / this.scale.Y;
      }

      toTruePoint(point) {
        const trueX = this.toTrueX(point);
        // console.log("trueX", trueX);

        const trueY = this.toTrueY(point);
        const truePoint = Geometry.createPoint(trueX, trueY);
        // console.log("truePoint", truePoint);
        return truePoint;
      }

      toTrueRect(rect) {
        const pointTL = Geometry.createPoint(rect.left, rect.top);
        const pointBR = Geometry.createPoint(rect.left + rect.width, rect.left + rect.height);

        const true_pointTL = this.toTruePoint(pointTL);
        const true_pointBR = this.toTruePoint(pointBR);

        const true_w = true_pointBR.x - true_pointTL.x;
        const true_h = true_pointBR.y - true_pointTL.y;

        const trueRect = Geometry.createRect(true_pointTL.x, true_pointTL.y, true_w, true_h);

        return trueRect;
      }

      getTrueCursor() {
        return this.toTruePoint(this.cursor);
      }

      truePointFromNoOrPoint(noOrPoint) {

        const stdBaseVectors = this.getStdBaseVectors();
        // console.log("stdBaseVectors", stdBaseVectors);

        const trueX = Geometry.dotProduct_2d(noOrPoint, stdBaseVectors.u);
        const trueY = Geometry.dotProduct_2d(noOrPoint, stdBaseVectors.v);

        const truePoint = Geometry.createPoint(trueX, trueY);

        return truePoint;
      }



      //noOr == no orientation == almost true point (wrong axes orientation)
      toNoOrX(screenX) {
        const noOrX = (screenX / this.scale.X) - this.offset.dx;
        return noOrX;
      }

      toNoOrY(screenY) {
        const noOrY = (screenY / this.scale.Y) - this.offset.dy;
        return noOrY;
      }

      toNoOrPoint(screenPoint) {
        return Geometry.createPoint(this.toNoOrX(screenPoint.x), this.toNoOrY(screenPoint.y));
      }

      toNoOrRect(screenRect) {
        const noOrTL = this.toNoOrPoint(Geometry.getPointTL(screenRect));
        const noOrBR = this.toNoOrPoint(Geometry.getPointBR(screenRect));
        const w = noOrBR.x - noOrTL.x;
        const h = noOrBR.y - noOrTL.y;
        return Geometry.createRect(noOrTL.x, noOrTL.y, w, h);
      }



      getCanvasBoundingRect() {
        // return canvas.getBoundingClientRect();
        return this.canvas.getBoundingClientRect();
      }

      getCanvasBoundingTrueRect() {
        const canvasBoundingRect = this.getCanvasBoundingRect();

        const trueRect = this.toTrueRect(canvasBoundingRect);

        return trueRect;
      }


      getScreenRect() {
        return this.getCanvasBoundingRect();
      }

      getScreenCenterPoint() {
        return Geometry.getCenterPoint(this.getCanvasBoundingRect());
      }

      getTrueCenterPoint() {
        const centerPoint_screen = this.getScreenCenterPoint();
        // console.log("centerPoint_screen", centerPoint_screen);
        const centerPoint_true   = this.toTruePoint(centerPoint_screen);
        return centerPoint_true;
      }

      getNoOrCenterPoint() {
        const centerPoint_screen = this.getScreenCenterPoint();
        // console.log("centerPoint_screen", centerPoint_screen);
        const centerPoint_noOr   = this.toNoOrPoint(centerPoint_screen);
        return centerPoint_noOr;
      }



      //"entry points"

      manageCursorMove_line() {

        /*
        //create line
        const line = {
            x0: prevScaledX,
            y0: prevScaledY,
            x1: scaledX,
            y1: scaledY
        };

        //console.log("line", line);

        // add the line to our drawing history
        drawings.push(line);

        // draw a line
        drawLine(prevCursorX, prevCursorY, cursorX, cursorY);
        */

      }

      manageCursorMove_offset() {

        const noOr_cursor         = this.toNoOrPoint(this.cursor);
        const noOr_previousCursor = this.toNoOrPoint(this.previousCursor);

        // move the screen
        const dOffsetX = (noOr_cursor.x - noOr_previousCursor.x) * this.inputProperties.moveProperties.moveMultiplier;
        const dOffsetY = (noOr_cursor.y - noOr_previousCursor.y) * this.inputProperties.moveProperties.moveMultiplier;

        const dOffset = {
          dx: dOffsetX,
          dy: dOffsetY,
        };

        //console.log("offset", offset);
        this.updateDOffset(dOffset);
        this.redrawCanvas(RedrawOccasion.offsetChanged);
      }

      manageCursorMove_rotate() {

        // console.log("this.cursor",         this.cursor);
        // console.log("this.previousCursor", this.previousCursor);

        // const screenRect   = this.getScreenRect();
        // console.log("screenRect", screenRect);
        const screenCenterPoint = this.getScreenCenterPoint();
        // console.log("screenCenterPoint", screenCenterPoint);


        // get rotation angle
        const v1 = {
          x: this.cursor.x - screenCenterPoint.x,
          y: this.cursor.y - screenCenterPoint.y,
        };
        const v2 = {
          x: this.previousCursor.x - screenCenterPoint.x,
          y: this.previousCursor.y - screenCenterPoint.y,
        };

        const norm_v1 = Geometry.norm_2d(v1);
        const norm_v2 = Geometry.norm_2d(v2);

        //angle = arccos[(xa * xb + ya * yb) / (√(xa2 + ya2) * √(xb2 + yb2))]
        const angle_abs = Math.acos( Geometry.dotProduct_2d(v1,v2) / (norm_v1 * norm_v2) );
        console.log("mcr", "angle_abs", angle_abs);

        if(isNaN(angle_abs)) {
          //ignore
          console.log("ignore", "isNaN(angle_abs) == true");
          // console.log("norm_v1", norm_v1);
          // console.log("norm_v2", norm_v2);
          return;
        }

        // * this.inputProperties.moveProperties.moveMultiplier

        //get the right sign
        const v1_3d = Geometry.vector_3d(v1);
        const v2_3d = Geometry.vector_3d(v2);
        const vn = {
          x:0,
          y:0,
          z:1,
        };

        const cross = Geometry.crossProduct_3d(v1_3d, v2_3d);
        // console.log("cross", cross);
        const sign = Geometry.dotProduct_3d(vn, cross) < 0 ? +1 : -1;

        const angleInRadians = sign * angle_abs;

        const angleInDegrees = angleInRadians * 180 / Math.PI;
        console.log("mcr", "angleInDegrees", angleInDegrees);

        const rotationCenter = this.getNoOrCenterPoint();
        // console.log("rotationCenter", rotationCenter);

        this.updateWithDRotation(angleInDegrees, rotationCenter);

        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }

      manageCenterRotation(angleInDegrees) {
        const rotationCenter = this.getNoOrCenterPoint();
        // console.log("rotationCenter", rotationCenter);

        this.updateWithDRotation(angleInDegrees, rotationCenter);

        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }

      logCursor() {

        console.log("this.cursor",         this.cursor);
        const true_cursor         = this.toTruePoint(this.cursor);
        console.log("true_cursor", true_cursor);


        const screenCenterPoint = this.getScreenCenterPoint();
        console.log("screenCenterPoint", screenCenterPoint);

      }




      //   // zoom the page based on where the cursor is
      //   var distX = event.pageX / canvas.clientWidth;
      //   var distY = event.pageY / canvas.clientHeight;
      //
      //   // calculate how much we need to zoom
      //   const unitsZoomedX = trueWidth() * scaleAmount;
      //   const unitsZoomedY = trueHeight() * scaleAmount;
      //
      //   const unitsAddLeft = unitsZoomedX * distX;
      //   const unitsAddTop = unitsZoomedY * distY;
      //
      //   offsetX -= unitsAddLeft;
      //   offsetY -= unitsAddTop;

      manageScaleUpdateWithScaleAmount(scaleAmount) {
        console.log("manageScaleUpdateWithScaleAmount", scaleAmount);

        const scale_new = {
          X: this.scale.X * (1 + scaleAmount),
          Y: this.scale.Y * (1 + scaleAmount),
        };


        // zoom the page based on where the cursor is
        const cursor            = this.cursor;
        const screenCenterPoint = this.getScreenCenterPoint();
        const screenRect        = this.getScreenRect();

        const cursorRatio = {
          X: cursor.x / screenRect.width,
          Y: cursor.y / screenRect.height,
        };
        console.log("cursorRatio", cursorRatio);

        const noOrRect = this.toNoOrRect(screenRect);

        const unitsZoomed = {
          X: noOrRect.width  * scaleAmount,
          Y: noOrRect.height * scaleAmount,
        };
        console.log("unitsZoomed", unitsZoomed);


        // const unitsZoomed = {
        //   X: this.trueWidth()  * scaleAmount,
        //   Y: this.trueHeight() * scaleAmount,
        // };

        // const sign = scaleAmount > 0 ? -1 : +1;

        const dOffset = {
          dx: - unitsZoomed.X * cursorRatio.X,
          dy: - unitsZoomed.Y * cursorRatio.Y,
        };
        console.log("dOffset", dOffset);

        this.updateScaleAndDOffset(scale_new, dOffset);

        this.redrawCanvas(RedrawOccasion.scaleChanged);
      }








      //save/load

      createInfinishute_p() {

        const counter = this.counter;
        const offset  = this.offset;
        const scale   = this.scale;
        const orientation = this.orientation;

        // const arr_icObjects_serial_p = this.icObjects.any.map(icObj => icObj.toSerial_p());
        // console.log("this.icObjects['any'].length", this.icObjects['any'].length);
        // console.log("this.icObjects.any.length",    this.icObjects.any.length);

        const arr_official_serial_p = Object.values(this.represented).map(represented => represented.officialSerial_p());
        const all_official_serial_p = Promise.all(arr_official_serial_p);

        // const arr_rep_serial_p = Object.values(this.representations).map(rep => rep.toSerial_p());
        // const all_rep_serial_p = Promise.all(arr_rep_serial_p);

        const infinishute_p = all_official_serial_p.then((arr_official_serial) => {
          const infinishute = {};

          infinishute.offset      = offset;
          infinishute.scale       = scale;
          infinishute.orientation = orientation;

          infinishute.counter     = counter;

          infinishute.official = arr_official_serial.reduce((acc, official) => {
            console.log("official", )
            acc[official.id] = official;
            return acc;
          }, {});

          // infinishute.representations = arr_rep_serial.reduce((acc, rep) => {
          //   acc[rep.id_rep] = rep;
          //   return acc;
          // }, {});

          return infinishute;
        });

        return infinishute_p;
      }

      manageSaveInfinishute_p() {

        const infiniteCanvas = this;
        const infinishute_p = this.createInfinishute_p();

        return infinishute_p

                //debug
               .then(infinishute => {
                 console.log("infinishute", infinishute);
                 return infinishute;
               })

               .then(infinishute => {
                 return FileIntegration.saveInfinishute_p(infinishute);
               })
               .then(success => {
                 console.log("saveInfinishute_p", "success", success);
                 infiniteCanvas.setChanged(!success);
               });
      }

      manageSaveInfinishute_p_2(infinishute_p) {

        return infinishute_p
               .then(infinishute => {
                 return FileIntegration.saveInfinishute_p(infinishute);
               })
               .then(success => {
                 console.log("saveInfinishute_p", "success", success);
                 infiniteCanvas.setChanged(!success);
               });

      }


      manageLoadInfinishute(json) {
        console.log("manageLoadInfinishute", json);

        this.offset      = json.offset;
        this.scale       = json.scale;
        this.orientation = json.orientation;

        this.counter = json.counter;

        const infiniteCanvas = this;

        const arr_official = Object.values(json.official);

        const arr_icObj_p = arr_official.map((json_icObject, i) => {
          const icObj_p = IcObject.fromJson_p(json_icObject);
          return icObj_p;
        });

        Promise.all(arr_icObj_p)
        .then(arr_icObj => {
          console.log("manageLoadInfinishute", "arr_icObj", arr_icObj);

          arr_icObj.forEach((icObj, i) => {
            console.log("manageLoadInfinishute", "icObj", icObj);

            infiniteCanvas.addDehydratedIcObject(icObj);
            // infiniteCanvas.addRepresented(icObj);
          });

        });

      }


      //core mutators

      updateCursor(cursor) {
        // console.log("updateCursor", cursor);
        this.previousCursor = Object.assign({}, this.cursor);
        this.cursor         = Object.assign({}, cursor);
      }


      updateOffset(offset_new) {
        console.log("updateOffset", offset_new);

        this.previousOffset = Object.assign({}, this.offset);

        this.offset = Object.assign({}, offset_new);

        this.dOffset.dx = this.offset.dx - this.previousOffset.dx;
        this.dOffset.dy = this.offset.dy - this.previousOffset.dy;

        // this.redrawCanvas(RedrawOccasion.offsetChanged);
      }

      updateScale(scale_new) {
        this.scale = Object.assign({}, scale_new);
        // this.update("scale", Object.assign({}, scale_new));

        this.didUpdateListenersDict["scaleChanged"].forEach((listener, i) => {
          listener(this);
        });
      }


      updateDOffset(dOffset_new) {
        const offset_new = {
          dx: this.offset.dx + dOffset_new.dx,
          dy: this.offset.dy + dOffset_new.dy,
        };
        this.updateOffset(offset_new);
      }

      updateScaleAndDOffset(scale_new, dOffset) {
        //console.log("updateScaleAndDOffset", scale_new, dOffset);
        this.updateScale(scale_new);
        this.updateDOffset(dOffset);
      }

      updateScaleAndOffset(scale_new, offset) {
        console.log("updateScaleAndOffset", scale_new, offset);
        this.updateScale(scale_new);
        this.updateOffset(offset);
      }

      updateOrientation(orientation_new) {
        console.log("updateOrientation", orientation_new);
        var orientation_bounded = Geometry.boundedAngleInDegrees(orientation_new);
        console.log("orientation_bounded", orientation_bounded);
        this.orientation = orientation_bounded;
      }

      updateWithDRotation(angleInDegrees, noOrCenterPoint) {
        console.log("updateWithDRotation", angleInDegrees, noOrCenterPoint);

        console.log("angleInDegrees", angleInDegrees);

        const radius = Geometry.norm_2d(noOrCenterPoint);

        // this.addPurePoint(centerPoint);
        // this.addPureCircle(centerPoint, radius);

        // this.addPoint(noOrCenterPoint);
        // this.addCircle(noOrCenterPoint, radius);

        const orientation_new = this.orientation - angleInDegrees;
        this.updateOrientation(orientation_new);


        const v = {
          x: noOrCenterPoint.x,
          y: noOrCenterPoint.y,
        };
        // console.log("v.x", v.x);
        // console.log("v.y", v.y);

        const angleInRadians = angleInDegrees / 180 * Math.PI;

        const ddx = Math.cos(angleInRadians) * v.x - Math.sin(angleInRadians) * v.y;
        const ddy = Math.sin(angleInRadians) * v.x + Math.cos(angleInRadians) * v.y;
        // console.log("ddx", ddx);
        // console.log("ddy", ddy);

        const dx = v.x - ddx
        const dy = v.y - ddy;
        // console.log("dx", dx);
        // console.log("dy", dy);


        const doffset_new = {
          dx: dx,
          dy: dy,
        };
        // console.log("doffset_new", doffset_new);

        this.updateDOffset(doffset_new);


      }


      updateWithDOrientation(dOrientation) {
        const orientation_new = this.orientation + dOrientation;
        this.updateOrientation(orientation_new);

        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }


      move_to_initial_position() {
        console.log("move_to_initial_position");
        this.updateScaleAndOffset(this.coords_initial.scale, this.coords_initial.offset);
      }

      getCurrentPov() {
        const scale  = this.scale;
        const offset = this.offset;

        const pov = new POV(scale, offset);
        return pov;
      }

      set_pov(pov) {
        this.updateScaleAndOffset(pov.scale, pov.offset);
      }



      manageImageImport(img) {
        this.addNewImage(img);
      }

      manageTextImport(text) {
        this.addNewText(text);
      }





      //top down request
      requestViewUpdateForIcObj(icObj) {
        console.log("requestViewUpdateForIcObj", icObj);
        this.requestSyncWithIcObjListeners.forEach((listener, i) => {
          listener(icObj);
        });
      }


    }


    class IcObject {

      constructor(id, type, position, size, homeScale) {
        this.id   = id;
        this.type = type;

        this.position = position;
        this.size     = size;       //"information" size    //gives an idea of the sharpness/heavyness of the object

        this.homeScale = homeScale;

        this.orientation = 0;
        this.scale     = {
          X:1,
          Y:1,
        };
        this.flip = {
          X:false,
          Y:false,
        };


        this.fill   = "";
        this.stroke = "";
        // this.colors = {};
        this.opacity = 1.0;

        this.strokeWidth = 3;

        // this.hotState = {
        //   toBeDeleted: false,
        //
        //   perceptionScale: {
        //     X:1,
        //    Y:1,
        //   },
        // };

        this.canBeMoved    = true;
        this.canBeRotated  = true;
        this.canBeResized  = true;
        this.canBeSelected = true;

        this.canBeHeld     = true;

        // this.isSnapped     = false;
        this.isSnappable   = true;
        this.snapState     = SnapState.Unsnapped;
        this.snappedTo     = -1;

        this.isTouchable    = true;
        // this.touchState    = TouchState.Untouched;
        this.touchStateDict = {};


        this.cType           = "";
        this.isCompositePart = false;
        this.isMobile        = false;
        this.compositeId     = -1;

        this.isHeld          = false;
        // this.addInteraction_hold();

        this.isUsingCenterPosition = false;

        // this.exoObject     = null;

        this.didUpdateListeners = [];
      }

      static fromJson_p(json_icObject) {
        console.log("fromJson_p", json_icObject);

        const id   = json_icObject.id;
        const type = json_icObject.type;

        const position = json_icObject.position;
        const size     = json_icObject.size;

        const homeScale = json_icObject.homeScale;


        const icObj = new IcObject(id, type, position, size, homeScale);


        const scale = json_icObject.scale;
        icObj.scale = scale;

        const orientation = json_icObject.orientation;
        icObj.orientation = orientation;

        const flip = json_icObject.flip;
        icObj.flip = flip;


        const fill   = json_icObject.fill;
        icObj.fill = fill;
        const stroke = json_icObject.stroke;
        icObj.stroke = stroke;

        const opacity = json_icObject.opacity;
        icObj.opacity = opacity;


        const isSnappable = json_icObject.isSnappable;
        icObj.isSnappable = isSnappable;
        const snapState = json_icObject.snapState;
        icObj.snapState = snapState;
        const snappedTo = json_icObject.snappedTo;
        icObj.snappedTo = snappedTo;


        const isTouchable  = json_icObject.isTouchable;
        icObj.isTouchable  = isTouchable;
        // const touchState = json_icObject.touchState;
        // icObj.touchState = touchState;
        const touchStateDict = json_icObject.touchStateDict;
        icObj.touchStateDict = touchStateDict;


        const cType           = json_icObject.cType;
        icObj.cType           = cType;
        const isCompositePart = json_icObject.isCompositePart;
        icObj.isCompositePart = isCompositePart;
        const isMobile        = json_icObject.isMobile;
        icObj.isMobile        = isMobile;
        const compositeId     = json_icObject.compositeId;
        icObj.compositeId     = compositeId;


        const isUsingCenterPosition = json_icObject.isUsingCenterPosition;
        icObj.isUsingCenterPosition = snappedTo;


        var icObj_p = Promise.resolve(icObj);

        switch(icObj.type) {
          case "text":
            const text      = json_icObject.text;
            icObj.text      = text;
            const textColor = json_icObject.textColor;
            icObj.textColor = textColor;
            const fontSize  = json_icObject.fontSize;
            icObj.fontSize  = fontSize;

            break;
          case "image":
            const img_serial = json_icObject.img;
            const img_p = FileIntegration.imageFromImgSrc_p(img_serial);

            const arr_p = [icObj_p, img_p];

            icObj_p = Promise.all(arr_p)
                      .then(([icObj, img]) => {

                        icObj.img = img;

                        return icObj;
                      });
            break;
          case "circle":
            const radius   = json_icObject.radius;

            icObj.radius = radius;
            break;

          case "group":
            {
              const children = json_icObject.children;

              const arr_p = children.map(json_child => {
                const icObj = IcObject.fromJson_p(json_child);
                return icObj;
              });

              Promise.all(arr_p)
              .then((arr_icObj) => {
                icObj.children = arr_icObj;
              });
            }
            break;

          case "freeDrawing":
            const exoObject   = json_icObject.exoObject;
            icObj.exoObject = exoObject;
            break;

          case "sparkle":
            {
            const img_serial = json_icObject.img;
            const img_p = FileIntegration.imageFromImgSrc_p(img_serial);

            const arr_p = [icObj_p, img_p];

            icObj_p = Promise.all(arr_p)
                      .then(([icObj, img]) => {

                        icObj.img = img;

                        return icObj;
                      });
            }
            break;

          case "composite":
            {
              const parts = json_icObject.parts;

              const arr_p = parts.map(json_part => {
                const icObj = IcObject.fromJson_p(json_part);
                return icObj;
              });

              Promise.all(arr_p)
              .then((arr_icObj) => {
                icObj.parts = arr_icObj;

                if(icObj.engine == null) {
                  icObj.engine = Compositer.defaultCompositeEngine(icObj, icObj.parts);
                }

              });
            }
            break;


          default:
            break;
        }

        return icObj_p;
      }

      toSerial_p() {
        var out_p;

        const icObj = this;

        const icObj_serial = Object.assign({}, icObj);

        var icObj_serial_p = Promise.resolve(icObj_serial);

        switch(icObj.type) {
          // case "text":
          //   const text     = icObj.text;
          //   const fontSize = icObj.fontSize;
          //
          //   icObj_serial.text     = text;
          //   icObj_serial.fontSize = fontSize;
          //
          //   break;
          case "image":
            {
            const img = icObj.img;
            const img_serial_p = FileIntegration.dataUrlForImgViaCanvas_p(img);

            const arr_p = [icObj_serial_p, img_serial_p];

            icObj_serial_p = Promise.all(arr_p)
                                    .then(([icObj_serial, img_serial]) => {

                                      icObj_serial.img = img_serial;
                                      return icObj_serial;
                                    });
            }
            break;

          // case "circle":
          //   const radius     = icObj.radius;
          //   icObj_serial.radius = radius;
          //
          //   break;

          // case "group":
          //   const children = icObj.children;
          //   icObj_serial.children = children;
          //
          //   break;

          case "freeDrawing":
            {
            const exoObject = icObj.exoObject;
            const exoObject_serial = Object.assign({}, exoObject);
            icObj_serial.exoObject = exoObject_serial;
            }
            break;

          case "sparkle":
            {
            const img = icObj.img;
            const img_serial_p = FileIntegration.dataUrlForImgViaCanvas_p(img);

            const arr_p = [icObj_serial_p, img_serial_p];

            icObj_serial_p = Promise.all(arr_p)
                                    .then(([icObj_serial, img_serial]) => {

                                      icObj_serial.img = img_serial;
                                      return icObj_serial;
                                    });
            }
            break;

          case "composite":
            {
            const parts = icObj.parts;
            const arr_p = Object.values(icObj.parts).map(part => part.toSerial_p());

            icObj_serial_p = Promise.all([icObj_serial_p, ...arr_p])
                                    .then(([icObj_serial, ...arr_parts_serial]) => {    //SHU: wow, pas mal le spread operator
                                      icObj_serial.parts = arr_parts_serial;
                                      return icObj_serial;
                                    });
                                    // .then(([arr_serial]) => {
                                    //   const icObj_serial     = arr_serial[0];
                                    //   const arr_parts_serial = arr_serial.slice(1);
                                    //
                                    //   icObj_serial.parts = arr_parts_serial;
                                    //   return icObj_serial;
                                    // });
            }
            break;

          default:
            break;
        }

        out_p = icObj_serial_p;

        return out_p;
      }


      addInteraction_hold() {
        const icObj = this;

        icObj.holdListeners     = [];
        icObj.nowHeld = () => {
          icObj.isHeld = true;
          icObj.holdListeners.forEach((listener, i) => {
            listener(icObj);
          });
        }
        icObj.onHold  = (listener) => {
          icObj.holdListeners.push(listener);
        };
        icObj.offHold = (listener) => {
          icObj.holdListeners = Utils.arrayByRemovingElement(icObj.holdListeners, listener);
        };

        icObj.releaseListeners = [];
        icObj.nowReleased = () => {
          icObj.isHeld = false;
          icObj.releaseListeners.forEach((listener, i) => {
            listener(icObj);
          });
        }
        icObj.onRelease  = (listener) => {
          icObj.releaseListeners.push(listener);
        };
        icObj.offRelease = (listener) => {
          icObj.releaseListeners = Utils.arrayByRemovingElement(icObj.releaseListeners, listener);
        };

      }




      getScreenPositionWithoutOffset() {
        const screenX = this.position.x * this.homeScale.X;
        const screenY = this.position.y * this.homeScale.Y;
        return Geometry.createPoint(screenX, screenY);
      }

      getHomeScreenSize() {
        return this.size;
      }

      // getTrueSize() {
      //   // const homeScreenSize = this.getHomeScreenSize();
      //   const trueSize = {
      //     width:    this.size.width / this.homeScale.X * this.scale.X,
      //     height:   this.size.width / this.homeScale.Y * this.scale.Y,
      //   }
      //   return trueSize;
      // }

      getRect() {
        const rect = Geometry.createRect(this.position.x, this.position.y, this.size.width, this.size.height);
        return rect;
      }



      update(icObj_new, requestCanvasRedraw) {
        // console.log("icObj.update", "icObj_new", icObj_new);

        const icObj = this;

        if(icObj_new.type != icObj.type) {
          // console.log("invalid type for icObj_new", "icObj", icObj, "icObj_new", icObj_new);
          throw new Error("invalid type for icObj_new" + "icObj" + icObj + "icObj_new" + icObj_new);
        }

        this.position = Object.assign({}, icObj_new.position);
        this.size     = Object.assign({}, icObj_new.size);

        this.homeScale = Object.assign({}, icObj_new.homeScale);

        this.scale       = Object.assign({}, icObj_new.scale);
        this.orientation = icObj_new.orientation;
        this.flip        = Object.assign({}, icObj_new.flip);

        // this.fill        = icObj_new.fill;
        // this.stroke      = icObj_new.stroke;


        // this.perceptionScale = Object.assign({}, icObj_new.perceptionScale);

        if(this.type == "text") {
          this.text     = icObj_new.text;
          this.fontSize = icObj_new.fontSize;
        }

        if(this.type == "toggleRect") {
          this.isActive = icObj_new.isActive;
        }

        this.didUpdate(requestCanvasRedraw);
      }


      didUpdate(requestCanvasRedraw) {
        const icObj = this;
        this.didUpdateListeners.forEach((listener, i) => {      //SHU: todo: "everything is promised"
          listener(icObj, requestCanvasRedraw);
        });
      }

      delete_p() {
        return new Promise((resolve, reject) => {

          this.toBeDeleted = true;

          this.didUpdate(false);

          resolve(this);
        });
      }

      clone() {
        const id   = this.id;
        const type = this.type;

        const position = this.position;
        const size     = this.size;

        const homeScale = this.homeScale;

        const icObj_clone = new IcObject(id, type, position, size, homeScale);

        Object.assign(icObj_clone, this);
        console.log("icObj_clone", icObj_clone);

        return icObj_clone;
      }

      deepClone() { //SHU TODO: pour l'instant j'ai la flemme, mais il faudra des deep copy
        const id   = this.id;
        const type = this.type;

        const position = {
          x: this.position.x,
          y: this.position.y,
        };
        const size     = {
          width:  this.size.width,
          height: this.size.height,
        };

        const homeScale = {
          X: this.homeScale.X,
          Y: this.homeScale.Y,
        };

        const icObj_clone = new IcObject(id, type, position, size, homeScale);

        // Object.entries(this).forEach(([key, value], i) => {
        //   // if(icObj_clone[key] == null) {
        //     const valueDeepCopy = JSON.parse(JSON.stringify(value));
        //     icObj_clone[key] = valueDeepCopy;
        //   // }
        // });

        const arr_alreadySet = [
          "id",
          "type",
          "position",
          "size",
          "homeScale",
        ];

        Object.entries(this)
        .filter(([key, value]) => {
          const valueAlreadyCopied = (arr_alreadySet.includes(key));
          // console.log(key, valueAlreadyCopied);
          return !valueAlreadyCopied;
        })
        .forEach(([key, value], i) => {
          // if(icObj_clone[key] == null) {
            // const valueDeepCopy = JSON.parse(JSON.stringify(value));
            // icObj_clone[key] = valueDeepCopy;
            const valueCopy  = value;
            icObj_clone[key] = valueCopy;
          // }
        });

        return icObj_clone;
      }


    }


    /*
    class IcComposite {

      constructor(handle, otherPartsDict) {
        this.parts  = Object.assign(otherPartsDict, {
          "handle": handle,
        };
      }

      getHandle() {
        return this.parts["handle"];
      }

      getPart(icObjId) {
        const part = Object.values(this.parts).find(part => (part.icObject.id == icObjId));
        return part;
      }

      getIcObject(icObjId) {
        const part = this.getPart(icObjId);
        return part ? part.icObject : null;
      }

      managePartUpdate(part, updateDict) {

        const icObj_compositePart = part.icObject;

        const arr_compositePartIcObj = Object.values(this.parts).map(compositePart => compositePart.icObject);
        const arr_compositePartIcObj__other = arr_compositePartIcObj.filter(icObj => icObj.id != icObj_compositePart.id);

        arr_compositePartIcObj__other.forEach((icObj, i) => {

          //test
          // icObj.position = Object.assign({}, icObj_compositePart.position);

          //get free rep
          // const represented = infiniteCanvas.getRepresented(icObj.id);
          // const rep_free    = represented.r_free();

          const rep_free = icObj;

          if(outerUpdatesDict.position != null) {

            const position_offset = {
              dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
              dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
            };
            // console.log("position_offset", position_offset);

            const obj = {
              position: {
                x: rep_free.position.x + position_offset.dx,
                y: rep_free.position.y + position_offset.dy,
              },
            };

            rep_free.syncWith(obj);

            //debug
            // rep_free.position = {
            //   x: icObj_compositePart.position.x + 100,
            //   y: icObj_compositePart.position.y + 100,
            // };

          }

        });

      }

      outerUpdatePart(part, updateDict) {

      }

    }

    class IcCompositePart {

      constructor(icObject, isMobile = false) {
        this.icObject = icObject;

        this.isMobile = isMobile;
      }

    }
    */







    /* POVs */

    class POV {

      constructor(scale, offset) {

      }

      static debug() {
        const scale  = 5;
        const offset = {
          dx:+100,
          dy:+100,
        };
        return new POV(scale, offset);
      }


    }



    class Animation {

      constructor() {
        const animationConfig__default = {
          duration: 5000,  //duration == 0 => instant teleport, 'blink'
          /*
          animation : linear,
          */
        }
      }

      move_to_pov__animation(pov_to, animationConfig) {
        console.log("move_to_initial_position");

        const pov_from = getCurrentPov();
        console.log("pov_from", pov_from);

        const duration = animationConfig.duration;

        const time_start = Date.now();

        const frame_duration = 17; //17 ms <-> 60 Hz
        const myIntervalLoop = setInterval(function () {

          const time_curr = Date.now();
          const elapsed   = time_curr - time_start;

          const progress   = getProgress(elapsed, duration);

          // console.log("progress", progress);
          if (progress < 1.0) {
            const pov_target = getPovForProgress(pov_from, pov_to, progress);
            // console.log("pov_target", pov_target);
            set_pov(pov_target);
          } else {
            set_pov(pov_to);
            clearInterval(myIntervalLoop);
          }
        }, frame_duration);

        updateScaleAndOffset(coords_initial.scale, coords_initial.offset);
      }

      getPovForProgress(pov_from, pov_to, progress) {
        const arr_propPaths = [
          "scale",
          "offset.dx",
          "offset.dy",
        ];
        function getPropForPropPath(obj, propPath) {
          const arr_path = propPath.split(".");
          return arr_path.reduce((acc, pathElt) => {
            return acc[pathElt];
          }, obj);
        }
        function setPropAtPropPath(obj, propPath, value) {
          const arr_path = propPath.split(".");
          const arr__all_but_last = arr_path.slice(0, -1);
          const penultimate = arr__all_but_last.reduce((acc, pathElt) => {

            //create if not found
            if(acc[pathElt] == null) {
              acc[pathElt] = {};
            }

            return acc[pathElt];
          }, obj);

          const [lastPathElt] = arr_path.slice(-1);
          penultimate[lastPathElt] = value;
        }
        const pov_progress = arr_propPaths.reduce((acc, propPath) => {
          const prop_from = getPropForPropPath(pov_from, propPath);
          const prop_to   = getPropForPropPath(pov_to, propPath);

          //linear progress
          const prop_progress = prop_from + (prop_to - prop_from) * progress;

          setPropAtPropPath(acc, propPath, prop_progress);

          return acc;
        }, {});

        return pov_progress;
      }

      getProgress(curr, total) {
        return curr/total;
      }

    }







    /*****
      REPRESENTATIONS / BACKING OBJECT
    *//////

    var ID = () => {
      let arr = new Uint32Array(8);
      window.crypto.getRandomValues(arr);
      let str = '';
      for (let i = 0; i < arr.length; i++) {
        str += (i < 2 || i > 5 ? '' : '-') + arr[i].toString(16).slice(-4);
      }
      return str;
    };

    class BackingSchema {

      constructor(propsDict) {
        const arr_entries = Object.entries(propsDict).map(([propName, prop]) => {
          var propType;
          if(prop != null) {
            propType = prop.constructor;
          } else {
            propType = Object;
          }
          return [propName, propType];
        });
        const propConstructorsDict = Object.fromEntries(arr_entries);

        Object.assign(this, propConstructorsDict);
      }

      static fromObject(obj) {
        return new BackingSchema(obj);
      }
    }

    class BackingObject {

      constructor(repClass, backingSchema, obj = null) {
        this.id = ID();

        /**/
        //pour la forme
        this.repClass      = repClass;
        this.backingSchema = backingSchema;
        /**/

        // this.counter = 0;
        this.representations = {};

        // this.inner = new repClass();                                                     //}
        //this.inner = {};                                                                  //} SHU: ça se discute
        this.innerRep = createRepresentation(obj, "id_inner_rep" + "__" + this.id, []);     //}
        this.addRepresentation(this.innerRep);
      }

      static fromBackingSchemaAndObject(backingSchema, obj) {
        const repClass = obj.constructor;

        const backingObject = new BackingObject(repClass, backingSchema, obj);
        return backingObject;
      }

      static fromObject(obj) {
        const repClass      = obj.constructor;
        const backingSchema = BackingSchema.fromObject(obj);

        const backingObject = new BackingObject(repClass, backingSchema, obj);
        return backingObject;
      }

      generateNewRepId() {
        // const id = this.counter;
        // this.counter += 1;
        // return id;

        const id_rep = ID();
        return id_rep;
      }

      getNewRepresentation() {
        const backingObj = this;

        const id_rep = backingObj.generateNewRepId();

        const target         = backingObj.innerRep;
        console.log("target", target);

        const arr_backingObj = [backingObj];
        const rep = createRepresentation(target, id_rep, arr_backingObj);

        backingObj.addRepresentation(rep);

        return rep;
      }

      // updateWithRepresentation(rep__update) {
      //
      //   const arr_affected = Object.values(this.representations).filter(rep => rep.id != rep__update.id);
      //
      //   arr_affected.forEach((rep, i) => {
      //     rep.syncWith(rep__update);
      //   });
      //
      // }

      updateWithPropFromRepresentation(propName, setValue, rep__update) {
        // console.log("updateWithPropFromRepresentation", propName, setValue, rep__update);
        // console.log("rep__update.id_rep", rep__update.id_rep);

        const arr_affected = Object.values(this.representations).filter(rep => rep.id_rep != rep__update.id_rep);
        // console.log("arr_affected", arr_affected.map(rep => rep.id_rep));

        arr_affected.forEach((rep, i) => {
          rep.updateFromOuter(propName, setValue, rep__update);
        });

      }

      addRepresentation(representation) {
        this.representations[representation.id_rep] = representation;
        // this.innerRep.follow(representation);  //SHU: innerRep now useless ?
      }

      removeRepresentation(rep) {
        //rep should no longer get any update from any other rep
        rep.unfollowAll();

        //all following reps must unfollow
        const arr_followers = Object.values(rep.followers);
        arr_followers.forEach((rep_follower) => {
          rep_follower.unfollow(rep);
        });

        //remove reference in dict
        delete this.representations[rep.id_rep];
      }

    }

      //original representation
    // function createRepresentation(target, id_rep, arr_backingObj) {
    //     // console.log("createRepresentation", "target", target);
    //     // console.log("createRepresentation", JSON.stringify(target));
    //
    //     // const targetClass = target.constructor;
    //
    //     const broadcaster = {}; //--> push to backingObject(s)
    //     broadcaster.id_rep = id_rep;
    //     broadcaster.arr_backingObj = arr_backingObj;
    //     broadcaster.addBackingObject = function(backingObj) {
    //       broadcaster.arr_backingObj.push(backingObj);
    //       backingObj.addRepresentation(broadcaster.representation);
    //     };
    //
    //     broadcaster.createSisterRepresentation = function(backingObj = null) {
    //       var targetBackingObj = backingObj;
    //       if(targetBackingObj == null) {
    //         const backingObj_first = broadcaster.arr_backingObj.find(e => true);
    //         targetBackingObj = backingObj_first;
    //       }
    //       return targetBackingObj.getNewRepresentation();
    //     };
    //
    //     const receiver  = {}; //<-- receive updates from backingObject(s)
    //     receiver.id_rep = id_rep;
    //
    //
    //     const inner = target.clone();
    //     // console.log("inner", inner);
    //
    //     const representation = new Proxy({}, {
    //         get: function (obj, propName) {
    //           // console.log("representation.get", propName);
    //           var outProp;
    //
    //           if(propName in broadcaster) {
    //             outProp = broadcaster[propName];//.bind(broadcaster);
    //           } else if(propName in receiver) {
    //             outProp = receiver[propName];//.bind(receiver);
    //           }
    //
    //           else if(propName in inner) {
    //             outProp = inner[propName];//.bind(inner);
    //           }
    //
    //           // else {
    //           //   console.log("representation", obj);
    //           //   throw new Error("unknown propName" + "(" + propName + ")" + " for representation: " + obj);
    //           // }
    //
    //           return outProp;
    //         },
    //         set: function (obj, propName, setValue) {
    //           // console.log("representation.set", propName, setValue);
    //
    //           updateInternals(propName,setValue);
    //           broadcaster.arr_backingObj.forEach((backingObj, i) => {
    //             console.log("representation", broadcaster.representation, "has updated");
    //             // console.log("broadcasting to", backingObj);
    //             backingObj.updateWithPropFromRepresentation(propName, setValue, broadcaster.representation);
    //           });
    //
    //           return true;
    //         },
    //     });
    //
    //     function updateInternals(propName, value) {
    //       // console.log("updateInternals", propName, value);
    //
    //       inner[propName] = value;
    //     }
    //
    //
    //
    //
    //
    //
    //     receiver.updateFromOuter = (propName,value) => {
    //       // console.log("updateFromOuter", propName, value);
    //
    //       updateInternals(propName,value);
    //
    //       // receiver.didUpdateProp(prop,value);
    //
    //       //timeout to avoid calling didUpdate for every updated prop
    //       if(receiver.didUpdateTimeout == null) {
    //         const timeout_delayInMs = 17;
    //         receiver.didUpdateTimeout = setTimeout(() => {
    //           // console.log("didUpdateTimeout", "triggering");
    //           receiver.didUpdate();
    //           receiver.didUpdateTimeout = null;
    //         }, timeout_delayInMs);
    //       }
    //     };
    //
    //     // receiver.didUpdatePropListeners = [];
    //     // receiver.didUpdateProp = (prop,value) => {
    //     //   receiver.didUpdatePropListeners.forEach((listener, i) => {
    //     //     listener(prop,value);
    //     //   });
    //     // }
    //
    //     receiver.didUpdateTimeout   = null;
    //     receiver.didUpdateListeners = [];
    //     receiver.didUpdate = () => {
    //       // console.log("receiver", "didUpdate");
    //       receiver.didUpdateListeners.forEach((listener, i) => {
    //         listener(receiver.representation);
    //       });
    //     };
    //
    //     receiver.addOnOuterUpdate = (listener) => {
    //       receiver.didUpdateListeners.push(listener);
    //     };
    //
    //
    //
    //
    //     const glassFacade = new Proxy(inner, {
    //       get: function (obj, propName) {
    //         // console.log("glassFacade.get", propName);
    //         var outProp;
    //
    //         if (propName === 'toJSON') {
		// 		      return function() { return obj; }
    //         }
    //
    //         if(propName in inner)	{	//Be careful! The in operator matches all object keys, including those in the object's prototype chain.
    //           outProp = inner[propName];
    //         } else {
    //           outProp = representation[propName];
    //         }
    //
    //         return outProp;
    //       },
    //       set: function (obj, propName, setValue) {
    //           //console.log("glassFacade.set", propName /*,setValue*/ );
    //           representation[propName] = setValue;
    //           return true;
    //       },
    //     });
    //
    //     broadcaster.representation = glassFacade;
    //     receiver.representation    = glassFacade;
    //
    //
    //     return glassFacade;
    //   }
    //

      class RepresentationFactory {
        static initial(obj) {
            return BackingObject.fromObject(obj).getNewRepresentation();
        }
      }

      class RepresentedFactory {
        static initial(obj) {
            const backingObj = BackingObject.fromObject(obj);
            const rep_official = backingObj.getNewRepresentation();
            const represented = new Represented(backingObj, rep_official);
            rep_official.represented = represented;
            return represented;
        }
      }

      class Represented {

        constructor(backingObj, rep_official) {
          this.backingObj = backingObj;

          this.reps = {};
          this.reps["official"] = rep_official;
        }

        r_official() {
          return this.reps["official"];
        }

        createNewRepresentationWithName(repName) {
          const rep_new = this.backingObj.getNewRepresentation();
          rep_new.represented = this;

          this.reps[repName] = rep_new;

          return rep_new;
        }

        getRepresentation(repName) {
          return this.reps[repName];
        }

        // removeRepresentation(repName) {
        //   if(repName == "official") {
        //     throw new Error("Represented::removeRepresentation, can't remove official rep");
        //   }
        //   const rep = this.reps[repName];
        //   this.backingObj.removeRepresentation(rep);
        //   delete this.reps[repName];
        // }

        removeRepresentation(rep) {
          if(rep == this.r_official()) {
            throw new Error("Represented::removeRepresentation, can't remove official rep");
          }
          this.backingObj.removeRepresentation(rep);

          const repName = this.getRepNameForRep(rep);
          delete this.reps[repName];
        }

        getRepNameForRep(rep_unknown) {
          var outString;

          const entry_found = Object.entries(this.reps).find(([repName, rep]) => rep == rep_unknown);
          if(entry_found != null) {
            outString = entry_found[0];
          } else {
            console.log("rep not found in represented");
            outString = null;
          }

          return outString;
        }



        //convenience
        r_free() {
          return this.reps["free"];
        }

        r_snapped() {
          return this.reps["snapped"];
        }






        officialSerial_p() {
          const rep      = this.r_official();
          const serial_p = rep.toSerial_p();
          return serial_p;
        }





      }

      // class RepresentationNetwork {
      //
      //
      // }
      //
      // class RepresentationNetworkNode {
      //
      //
      // }


        //representation "plus"
      function createRepresentation(target, id_rep, arr_backingObj) {
          // console.log("createRepresentation", "target", target);
          // console.log("createRepresentation", JSON.stringify(target));

          // const targetClass = target.constructor;

          const broadcaster = {}; //--> push to backingObject(s)
          broadcaster.id_rep = id_rep;
          broadcaster.arr_backingObj = arr_backingObj;
          broadcaster.addBackingObject = function(backingObj) {
            broadcaster.arr_backingObj.push(backingObj);
            backingObj.addRepresentation(broadcaster.representation);
          };

          // broadcaster.createSisterRepresentation = function(backingObj = null) {  //~ "gemini rep"
          //   var targetBackingObj = backingObj;
          //   if(targetBackingObj == null) {
          //     const backingObj_first = broadcaster.arr_backingObj.find(e => true);
          //     targetBackingObj = backingObj_first;
          //   }
          //
          //   const rep_elder  = broadcaster.representation;
          //   const rep_sister = targetBackingObj.getNewRepresentation();
          //
          //   rep_sister.follow(rep_elder);
          //   rep_elder.follow(rep_sister);
          //
          //   return rep_sister;
          // };
          //
          // broadcaster.removeSisterRepresentation = (rep) => {
          //   //SHU: TODO
          // };

          broadcaster.followers = {};
          broadcaster.addFollower = function(rep) {
            broadcaster.followers[rep.id_rep] = rep;
          }

          broadcaster.removeFollower = function(rep) {
            delete broadcaster.followers[rep.id_rep];
          }


          broadcaster.didUpdateFromInner = (representation, propName, oldValue, newValue) => {
            broadcaster.didUpdateFromInnerListeners.forEach((listener, i) => {
              listener(representation, propName, oldValue, newValue);
            });
          };

          // var innerUpdates = {};
          broadcaster.didUpdateFromInnerListeners = [];
          broadcaster.onInnerUpdate = (listener) => {
            broadcaster.didUpdateFromInnerListeners.push(listener);
          };
          broadcaster.offInnerUpdate = (listener) => {
            broadcaster.didUpdateFromInnerListeners = Utils.arrayByRemovingElement(broadcaster.didUpdateFromInnerListeners, listener);
          };


          const receiver  = {}; //<-- receive updates from backingObject(s)
          receiver.id_rep = id_rep;


          const inner = target.clone();
          // console.log("inner", inner);

          const representation = new Proxy({}, {
              get: function (obj, propName) {
                // console.log("representation.get", propName);
                var outProp;

                if(propName in broadcaster) {
                  outProp = broadcaster[propName];//.bind(broadcaster);
                } else if(propName in receiver) {
                  outProp = receiver[propName];//.bind(receiver);
                }

                else if(propName in inner) {
                  outProp = inner[propName];//.bind(inner);
                }

                // else {
                //   console.log("representation", obj);
                //   throw new Error("unknown propName" + "(" + propName + ")" + " for representation: " + obj);
                // }

                return outProp;
              },
              set: function (obj, propName, setValue) {
                // console.log("representation.set", propName, setValue);

                if(propName in broadcaster) {
                  broadcaster[propName] = setValue;
                } else if(propName in receiver) {
                  receiver[propName] = setValue;
                }

                else {
                  //setting something in inner

                  const oldValue = inner[propName];
                  const newValue = setValue;

                  updateInternals(propName,setValue);
                  broadcaster.arr_backingObj.forEach((backingObj, i) => {
                    console.log("representation has updated", broadcaster.representation);
                    // console.log("broadcasting to", backingObj);
                    backingObj.updateWithPropFromRepresentation(propName, setValue, broadcaster.representation);
                  });

                  broadcaster.didUpdateFromInner(broadcaster.representation, propName, oldValue, newValue);

                }

                return true;
              },
          });

          function updateInternals(propName, value) {
            // console.log("updateInternals", propName, value);

            inner[propName] = value;
          }

          //follow system

          receiver.followed = {};

          receiver.follow = function(rep) {
            const follower = receiver.representation;
            const followed = rep;

            if(followed == follower) {
              //can't follow self
              //ignore
              return;
            }

            followed.followers[follower.id_rep] = follower;
            follower.followed[followed.id_rep]  = followed;
          }

          receiver.unfollow = function(rep) {
            const follower = receiver.representation;
            const followed = rep;

            if(followed.followers[follower.id_rep] != null) {
              delete followed.followers[follower.id_rep];
            }
            if(follower.followed[followed.id_rep] != null) {
              delete follower.followed[followed.id_rep];
            }
          }

          receiver.followAll = function() {
            const arr_repDicts = arr_backingObj.map((backingObj) => backingObj.representations);
            const arr_allreps  = arr_repDicts.reduce((acc, repDict) => {
              const arr = acc;
              arr.push(...Object.values(repDict));
              return arr;
            }, []);
            arr_allreps.forEach((rep, i) => {
              receiver.follow(rep);
            });
          }

          receiver.unfollowAll = function() {
            const followed = Object.assign({}, receiver.followed);
            Object.values(followed).forEach((rep, i) => {
              receiver.unfollow(rep);
            });
          }

          // receiver.inner = inner;
          receiver.syncWith = function(rep) {
            // Object.entries(rep.inner).forEach(([propName,value], i) => {
            //   updateInternals(propName, value);
            // });
            Object.keys(inner).forEach((propName, i) => {
              const value = rep[propName];
              console.log("+++syncWith", propName, value);
              updateInternals(propName, value);
            });
          }

          receiver.syncWithObj = function(obj) {
            Object.keys(obj).forEach((propName, i) => {
              const value = obj[propName];
              updateInternals(propName, value);
            });
          }


          var outerUpdates = {};
          receiver.updateFromOuter = (propName, value, rep) => {
            // console.log("updateFromOuter", propName, value);

            const isRepFollowed = (receiver.followed[rep.id_rep] == rep);
            if(!isRepFollowed) {
              console.log("rep not followed", "ignore");
              return;
            }

            // outerUpdates[propName] = value;
            if(outerUpdates[propName] == null) {
              outerUpdates[propName] = {
                old: inner[propName],     //SHU: beware with this

                //debug
                // old: value,
              };
            }
            outerUpdates[propName]["new"] = value;


            updateInternals(propName,value);

            // receiver.didUpdateProp(prop,value);

            //timeout to avoid calling didUpdate for every updated prop
            if(receiver.didUpdateFromOuterTimeout == null) {
              const timeout_delayInMs = 17;
              receiver.didUpdateFromOuterTimeout = setTimeout(() => {
                // console.log("didUpdateTimeout", "triggering");
                receiver.didUpdateFromOuter(outerUpdates);
                receiver.didUpdateFromOuterTimeout = null;
                outerUpdates = {};
              }, timeout_delayInMs);
            }
          };


          // receiver.remoteInnerUpdate = (propName, value, rep) => {
          //
          // };


          // receiver.didUpdatePropListeners = [];
          // receiver.didUpdateProp = (prop,value) => {
          //   receiver.didUpdatePropListeners.forEach((listener, i) => {
          //     listener(prop,value);
          //   });
          // }

          receiver.didUpdateFromOuterTimeout   = null;
          receiver.didUpdateFromOuterListeners = [];
          receiver.didUpdateFromOuter = (updateDict) => {
            // console.log("receiver", "didUpdate");
            receiver.didUpdateFromOuterListeners.forEach((listener, i) => {
              listener(receiver.representation, updateDict);
            });
          };

          receiver.onOuterUpdate = (listener) => {
            receiver.didUpdateFromOuterListeners.push(listener);
          };

          receiver.offOuterUpdate = (listener) => {
            receiver.didUpdateFromOuterListeners = Utils.arrayByRemovingElement(receiver.didUpdateFromOuterListeners, listener);
          };

          receiver.represented = null;


          receiver.toSerial_p = () => {
            // console.log("inner", inner);
            return inner.toSerial_p();
          }


          const glassFacade = new Proxy(inner, {
            get: function (obj, propName) {
              // console.log("glassFacade.get", propName);
              var outProp;

              if (propName === 'toJSON') {
  				      return function() { return obj; }
              }

              if(propName in inner)	{	//Be careful! The in operator matches all object keys, including those in the object's prototype chain.
                outProp = inner[propName];
              } else {
                outProp = representation[propName];
              }

              return outProp;
            },
            set: function (obj, propName, setValue) {
                //console.log("glassFacade.set", propName /*,setValue*/ );
                representation[propName] = setValue;
                return true;
            },
          });

          broadcaster.representation = glassFacade;
          receiver.representation    = glassFacade;


          return glassFacade;
        }



      /*//////
      *********/


      class Compositer {

        static defaultCompositeEngine(handle, parts) {

          const engine = {};

          engine.isMobilePart = function(part) {
            // return false;
            return part.isMobile;
          };

          engine.initialize = function() {

            engine.listeners = engine.createListeners();

          };

          engine.createListeners = () => {
            var outListenersDict = {};

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();



            const handle__listener = (representation, propName, oldValue, newValue) => {
              const updatesDict = {
                [propName]: {
                  old: oldValue,
                  new: newValue,
                },
              };
              engine.manageHandleUpdate(representation, updatesDict);
            };

            // outListenersDict["handle"] = handle__listener;
            outListenersDict[handle.id] = handle__listener;


            const part_listeners = Object.entries(handle__rep_free.parts).reduce((acc, [partName, part__rep_free]) => {

              const part__listener = (representation, propName, oldValue, newValue) => {
                const updatesDict = {
                  [propName]: {
                    old: oldValue,
                    new: newValue,
                  },
                };
                engine.managePartUpdate(representation, updatesDict);
              };

              // acc[partName] = part__listener;
              acc[part__rep_free.id] = part__listener;

              return acc;
            }, {});

            Object.assign(outListenersDict, part_listeners);

            return outListenersDict;
          };

          engine.start = function() {

            console.log("engine.start", handle.id);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();


            //listen to handle
            const handle__listener = engine.listeners[handle.id];
            handle__rep_free.onInnerUpdate(handle__listener);

            //listen to parts
            const arr_parts_all   = Object.values(handle__rep_free.parts);
            arr_parts_all.forEach((part__rep_free, i) => {

              const part__listener = engine.listeners[part__rep_free.id];
              part__rep_free.onInnerUpdate(part__listener);
            });


            //debug (~tests)
            // setTimeout(() => {
            //   console.log("ççç setTimeout handle__rep_free.id_rep", handle__rep_free.id_rep);
            //
            //   handle__rep_free.position = {
            //     x: handle__rep_free.position.x + 200,
            //     y: handle__rep_free.position.y - 50,
            //   };
            // }, 3000);
            //
            // setTimeout(() => {
            //   const part1 = arr_parts_all[0];
            //   part1.position = {
            //     x: part1.position.x - 200,
            //     y: part1.position.y - 100,
            //   };
            // }, 6000);
            //
            // setTimeout(() => {
            //   const part3 = arr_parts_all[2];
            //   part3.position = {
            //     x: part3.position.x + 150,
            //     y: part3.position.y + 100,
            //   };
            // }, 9000);

          };

          engine.stop = function(){

            console.log("engine.stop", handle.id);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            const handle__listener = engine.listeners[handle.id];
            handle__rep_free.offInnerUpdate(handle__listener);

            const arr_parts_all   = Object.values(handle__rep_free.parts);
            arr_parts_all.forEach((part__rep_free, i) => {

              const part__listener = engine.listeners[part__rep_free.id];
              part__rep_free.offInnerUpdate(part__listener);
            });

          };

          engine.getArr_everyone = () => {

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(handle.id);
            const handle__rep_free    = handle__represented.r_free();

            return [handle__rep_free] + Object.values(handle__rep_free.parts);
          }

          engine.getArr_everyoneBut = (rep) => {
            const arr_everyoneElse = engine.getArr_everyone().filter(rep => rep.id != solo_rep.id);
            return arr_everyoneElse;
          }

          engine.onEveryoneBut = (solo_rep) => {
            const arr_everyoneElse = engine.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = engine.listeners[rep.id];
              rep.onInnerUpdate(listener);
            });
          };

          engine.offEveryoneBut = (rep) => {
            const arr_everyoneElse = engine.getArr_everyoneBut(solo_rep);
            arr_everyoneElse.forEach((rep, i) => {
              const listener = engine.listeners[rep.id];
              rep.offInnerUpdate(listener);
            });
          };

          //part update
          engine.managePartUpdate = function(icObj_compositePart, outerUpdatesDict) {
            console.log("part_update", icObj_compositePart);

            if(icObj_compositePart.isMobile) {
              //ignore
            } else {

              //get free_rep
              const handle__represented = infiniteCanvas.getRepresented(handle.id);
              const handle__rep_free    = handle__represented.r_free();

              // const part__represented   = infiniteCanvas.getRepresented(icObj_compositePart.id);

              // rep_free__composite.composite.managePartUpdate(rep_free__compositePart, outerUpdatesDict);
              if(outerUpdatesDict.position != null) {

                const offset = {
                  dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                  dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
                };

                const arr_parts_all   = Object.values(handle__rep_free.parts);
                const arr_parts_other = arr_parts_all.filter(part => part.id != icObj_compositePart.id);

                const arr_handle_and_other = [handle__rep_free, ...arr_parts_other];

                // arr_parts_other.forEach((rep_free, i) => {
                arr_handle_and_other.forEach((rep_free, i) => {

                  const listener = engine.listeners[rep_free.id];
                  // console.log("°°°listener", listener);

                  //listen:off
                  rep_free.offInnerUpdate(listener);

                  //mutate
                  {
                    const position_new = {
                      x: rep_free.position.x + offset.dx,
                      y: rep_free.position.y + offset.dy,
                    };

                    rep_free.position = position_new;
                  }

                  //listen:on
                  rep_free.onInnerUpdate(listener);

                });


              //   {
              //     const rep_free = handle__rep_free;
              //
              //     //listen:off
              //     rep_free.offInnerUpdate(listener);
              //
              //     //mutate
              //     {
              //       const position_new = {
              //         x: rep_free.position.x + offset.dx,
              //         y: rep_free.position.y + offset.dy,
              //       };
              //
              //       rep_free.position = position_new;
              //     }
              //
              //     //listen:on
              //     rep_free.onInnerUpdate(listener);
              //   }


              }

            }

          };

          //handle update
          engine.manageHandleUpdate = function(icObj_composite, outerUpdatesDict) {
            console.log("manageHandleUpdate", icObj_composite);

            //get free_rep
            const handle__represented = infiniteCanvas.getRepresented(icObj_composite.id);
            const handle__rep_free    = handle__represented.r_free();

            if(outerUpdatesDict.position != null) {

              const offset = {
                dx: outerUpdatesDict.position.new.x - outerUpdatesDict.position.old.x,
                dy: outerUpdatesDict.position.new.y - outerUpdatesDict.position.old.y,
              };

              const arr_parts_all   = Object.values(handle__rep_free.parts);
              arr_parts_all.forEach((part__rep_free, i) => {

                const listener = engine.listeners[part__rep_free.id];

                //listen:off
                part__rep_free.offInnerUpdate(listener);

                //mutate
                {
                  const position_new = {
                    x: part__rep_free.position.x + offset.dx,
                    y: part__rep_free.position.y + offset.dy,
                  };

                  part__rep_free.position = position_new;
                }

                //listen:on
                part__rep_free.onInnerUpdate(listener);

              });

            }

          };

          return engine;
        }

      }


      class GMOperatorMama {

        static operatorConfigForRank(rank) {
          var outOperatorConfig = null;

          var name               = null;
          var transformationFunc = null;
          switch(rank%4) {
            case 0:
              name = "+1";
              // transformationFunc = (number) => (number + 1);
              transformationFunc = (expr) => expr.add(1);
              break;
            case 1:
              name = "+10";
              // transformationFunc = (number) => (number + 10);
              transformationFunc = (expr) => expr.add(10);
              break;
            case 2:
              name = "×2";
              // transformationFunc = (number) => (number * 2);
              transformationFunc = (expr) => expr.multiply(2);
              break;
            case 3:
              name = "×(-1)";
              // transformationFunc = (number) => (number * (-1));
              transformationFunc = (expr) => expr.multiply(-1);
              break;
            default:
              break;
          }

          const operatorConfig = new OperatorConfig(name, transformationFunc);
          outOperatorConfig = operatorConfig;

          return outOperatorConfig;
        }

      }

      class OperatorConfig {

        constructor(name, transformationFunc) {
          this.name               = name;
          this.transformationFunc = transformationFunc;
        }

      }


      class Hooker {

        static createHook() {

          const listeners = [];
          const hookObj = {
            listeners: listeners,
            trigger: (...args) => {
              listeners.forEach((listener, i) => {
                listener(...args);
              });
            },
            on: (listener) => {
              listeners.push(listener);
            },
            off: (listener) => {
              listeners.push(listener);
            },
          };

          return hookObj;
        }

        static installHooks(obj, funcName) {

          //create hooks
          if(obj.will == null) {
            obj.will = {};
          }
          obj.will[funcName] = this.createHook();

          if(obj.did == null) {
            obj.did = {};
          }
          obj.did[funcName] = this.createHook();



          //decorate func                         //SHU: en fait on pourrait ne pas faire assigner obj.will et obj.did et garder ces objects enfermés dans la définition de la fonction décorée
          const func_original  = obj[funcName];
          const func_decorated = (...args) => {
            // console.log("func_decorated", ...args);
            obj.will[funcName].trigger(...args);
            func_original(...args);
            obj.did[funcName].trigger(...args);
          };

          obj[funcName] = func_decorated;
        }

      }







/**** view  / controller ****/



      class FabricIntegration {

        constructor(infiniteCanvas, inputProperties) {

          //initialize fabric properties
          fabric.Object.prototype.transparentCorners = false;
          fabric.Object.prototype.cornerStyle = 'circle';
          fabric.Object.prototype.cornerColor = 'black';
          fabric.Object.prototype.borderColor = 'black';
          fabric.Object.prototype.padding     = 10;


          fabric.Rect.prototype.rx = 5;
          fabric.Rect.prototype.ry = 5;


          // // fabricjs group - always show border
          // fabric.Group.prototype.initialize = (function (initialize) {
          //     return function () {
          //         initialize.apply(this, arguments)
          //         // prepend rect before=behind group objects
          //         this._objects = [
          //         new fabric.Rect({
          //             // position from group center
          //             left: -0.5*this.width,
          //             top: -0.5*this.height,
          //             width: this.width,
          //             height: this.height,
          //
          //             stroke: '#00f',
          //             strokeWidth: 2,
          //             fill: false,
          //         })]
          //         .concat(this._objects)
          //
          //         // TODO repaint border on group resize event
          //
          //         // TODO remove border on group destroy
          //     };
          // })(fabric.Group.prototype.initialize);





          this.infiniteCanvas  = infiniteCanvas;
          this.inputProperties = inputProperties;

          this.mouseIntegration = null;   //set after birth

          const fabricCanvas = new fabric.Canvas(infiniteCanvas.canvas.id, {

            // backgroundColor: 'rgb(100,200,100)',
            // backgroundColor: 'rgb(100,100,100)',
            // backgroundColor: 'rgb(200,200,200)',      //it is important to choose a nice bgColor to stay motivated during dev
            // backgroundColor: 'rgb(230,240,240)',
            backgroundColor: 'rgb(100,100,100)',


            selectionColor:  'blue',
            selectionLineWidth: 2,

            width:  canvas.width,
            height: canvas.height,


            imageSmoothingEnabled: true,
          });

          this.fabricCanvas = fabricCanvas;
          this.context      = fabricCanvas.getContext("2d");
          //console.log("fabricCanvas", fabricCanvas);

          this.fabric_objects = [];
          // this.inner_fabric_objects = [];
          // this.outer_fabric_objects = [];

          this.fabric_objects__pure = [];


          this.fabric_objects__hud = [];


          this.fObjForIcObj_dict = {};



          // this.debugFabric();
          this.synchronizeWithIcObjects(infiniteCanvas.icObjects);

          // this.debugOriginalAxes();

          this.initializeFreeDrawing();

          this.initializeFabricObjectCopyCut();

          this.configureActiveSelectionListeners();
        }

        setFabricObjects(fabric_objects__new) {
          this.fabric_objects = fabric_objects__new;
        }

        getFabricObjects() {
          return this.fabric_objects;
        }




        // debugOriginalAxes() {
        //
        //   this.debugOriginalAxis_X();
        //   this.debugOriginalAxis_Y();
        // }
        //
        // debugOriginalAxis_X() {
        //
        //   // const line = new fabric.Line([0, -100, 0, +100], {
        //   //   left: 0,
        //   //   top: 0,
        //   //   stroke: 'red'
        //   // });
        //   //
        //   // this.addInnerFabricObject(line);
        //
        //   const rect = new fabric.Rect({
        //     left: 0,
        //     top: 0,
        //     width: 1000,
        //     height: 10,
        //     fill: 'blue',
        //   });
        //
        //   this.addInnerFabricObject(rect);
        //
        //
        //
        // }
        //
        // debugOriginalAxis_Y() {
        //
        //   // const line = new fabric.Line([-100, 0, 100, 0], {
        //   //   left: 0,
        //   //   top: 0,
        //   //   stroke: 'red'
        //   // });
        //   //
        //   // this.addInnerFabricObject(line);
        //
        //   const rect = new fabric.Rect({
        //     left: 0,
        //     top: 0,
        //     width: 10,
        //     height: 1000,
        //     fill: 'red',
        //   });
        //
        //   this.addInnerFabricObject(rect);
        //
        // }



        redrawCanvas(redrawOccasion) {
          console.log("redrawCanvas", redrawOccasion);

          switch(redrawOccasion) {

            case RedrawOccasion.offsetChanged:
              this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.scaleChanged: //order is important here
              this.updateFabricObjectsSize(redrawOccasion);
              this.updateFabricObjectsPosition(redrawOccasion);
              break;

            case RedrawOccasion.orientationChanged:
              this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.objectAdded:
              this.updateFabricObjectsPosition(redrawOccasion);
              this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.pureObjectAdded:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.objectRemoved:
              this.updateFabricObjectsPosition(redrawOccasion);
              this.updateFabricObjectsSize(redrawOccasion);
              break;


            case RedrawOccasion.windowResize:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;


            case RedrawOccasion.forceRedraw:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            default:
              throw new Error("unknown redraw occasion:" + redrawOccasion);
              break;
          }

          this.fabricCanvas.renderAll(); //SHU: render only what is visible (is fabric smart enough ?)
        }


        synchronizeWithIcObjects(icObjects) {

          icObjects.any.forEach((icObj, i) => {
            this.addFabricObjectWithIcObj(icObj);
          });

        }


        addFabricObjectWithIcObj(icObj__r_free) {
          const fabricIntegration = this;
          const fabricCanvas      = this.fabricCanvas;

          console.log("addFabricObjectWithIcObj", "icObj", icObj__r_free);
          // const fObj = this.createFabricObjectWithIcObj(icObj);

          // var icObj_fRep = icObj__r_free.createSisterRepresentation();
          var icObj_fRep = icObj__r_free;
          const fObj_p = fabricIntegration.createFabricObjectWithIcObj_p(icObj_fRep);

          fObj_p.then(fObj => {
            manageCreatedFObj(fObj);
          });

          function manageCreatedFObj(fObj) {

            function standardRedraw(fObj) {
              const icObj = fObj.icObj;
              fObj.set({
                opacity: icObj.opacity,
                fill:    icObj.fill,
              });

              if(icObj.text) {
                console.log("fObj", fObj);
                fObj.set({
                  text: icObj.text,
                  fill: icObj.textColor,
                });
              }

              fabricIntegration.updateFabricObject_size_default(fObj);
              fabricIntegration.updateFabricObject_position_default(fObj);

              fabricCanvas.renderAll();
            }

            const innerUpdateListener = (icObj_fRep, propName, oldValue, newValue) => {
              console.log("innerUpdateListener", icObj_fRep.id_rep, propName);

              if(propName == "im_dead_now") {
                console.log("im_dead_now");
                if(icObj_fRep.im_dead_now) {
                  fabricIntegration.removeFabricObject(fObj);
                }
              }
              // else if(propName == "isHeld") {
              //   console.log("innerUpdate", "isHeld");
              // }
              else if(propName == "tex") {
                fObj.refreshTex_p()
                .then((fObj) => {
                  standardRedraw(fObj);
                });
              }
              else if(propName == "expr") {
                fObj.refreshTex_p()
                .then((fObj) => {
                  standardRedraw(fObj);
                });
              }
              else {
                console.log("icObj_fRep","onInnerUpdate", icObj_fRep);
                standardRedraw(fObj);

                // if(icObj.type == "sparkle") {
                //
                // }

              }

            };
            fObj.fListener_inner = innerUpdateListener;
            icObj_fRep.onInnerUpdate(innerUpdateListener);

            const outerUpdateListener = (icObj_fRep) => {
              console.log("outerUpdateListener", icObj_fRep.id_rep, propName);

              if(propName == "im_dead_now") {
                console.log("im_dead_now");
                if(icObj_fRep.im_dead_now) {
                  fabricIntegration.removeFabricObject(fObj);
                }
              }
              // else if(propName == "isHeld") {
              //   console.log("outerUpdate", "isHeld");
              // }
              else if(propName == "tex") {
                fObj.refreshTex_p()
                .then((fObj) => {
                  standardRedraw(fObj);
                });
              }
              else if(propName == "expr") {
                fObj.refreshTex_p()
                .then((fObj) => {
                  standardRedraw(fObj);
                });
              }
              else {
                console.log("icObj_fRep","onOuterUpdate", icObj_fRep);
                standardRedraw(fObj);
              }

            };
            fObj.fListener_outer = outerUpdateListener;
            icObj_fRep.onOuterUpdate(outerUpdateListener);


            // if(icObj_fRep.onHold != null) {
            //   icObj_fRep.onHold((icObj) => {
            //
            //   });
            // }
            //
            // if(icObj_fRep.onRelease != null) {
            //   icObj_fRep.onRelease((icObj) => {
            //
            //   });
            // }


            if(fObj) {
              fabricIntegration.addOuterFabricObject(fObj);
            }

            //"initial refresh"
            const icObj = fObj.icObj;
            if(icObj.type == "tex") {
              fObj.refreshTex_p()
              .then((fObj) => {
                fabricCanvas.renderAll();
              });
            }
            else if(icObj.type == "expr") {
              fObj.refreshTex_p()
              .then((fObj) => {
                fabricCanvas.renderAll();
              });
            }

          }

        }


        addFabricObjectWithPureIcObj(icObj) {

          const fObj = this.createFabricObjectWithIcObj(icObj);

          if(fObj) {
            this.addPureOuterFabricObject(fObj);
          }

        }

        createFabricObjectWithIcObj_p(icObj) {
          var fObj_p = null;

          switch(icObj.type) {
            case "rect":
              {
              const fObj = this.createFabricRectWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;
            case "text":
              {
              const fObj = this.createFabricITextWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;
            case "image":
              {
              const fObj = this.createFabricImageWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            case "circle":
              {
              const fObj = this.createFabricCircleWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;
            case "point":
              {
              const fObj = this.createFabricCircleWithIcPoint(icObj);
              // fObj = this.createFabricCompositeWithIcObj__point(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "freeDrawing":
              {
              // fObj = this.createFabricPolylineWithIcFreeDrawing(icObj);

              const fObj = this.createFabricFreeDrawingWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "svg":
              {
              fObj_p = this.createFabricSvgWithIcObj_p(icObj);
              }
              break;

            case "tex":
              {
              const fObj = this.createFabricTexWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "expr":
              {
              const fObj = this.createFabricExprWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            case "group":
              {
              const fObj = this.createFabricGroupWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;





            case "toggleRect":
              {
              const fObj = this.createFabricToggleRectWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            case "snapSlot":
              {
              const fObj = this.createFabricSnapSlotWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "touchSlot":
              {
              const fObj = this.createFabricTouchSlotWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            case "composite":
              {
              const fObj = this.createFabricCompositeWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "well":
              {
              const fObj = this.createFabricWellWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "greenMouseWell":
              {
              const fObj = this.createFabricGreenMouseWellWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            case "segment":
              {
              const fObj = this.createFabricSegmentWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;

            case "line":
              {
              const fObj = this.createFabricLineWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            case "sparkle":
              {
              const fObj = this.createFabricSparkleWithIcObj(icObj);
              fObj_p = Promise.resolve(fObj);
              }
              break;


            default:
              throw new Error("addFabricObjectWithIcObj " + "unsupported type: " + icObj.type);
              break;
          }

          //common props
          fObj_p = fObj_p.then(fObj => {
            fObj.opacity = icObj.opacity;
            return fObj;
          });

          return fObj_p;
        }


        createFabricRectWithIcObj(icObj) {
          console.log("createFabricRectWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,


            // fill: '#f55',
            // fill: 'red',
            fill: icObj.fill,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj : icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);




          //debug
          fObj.setControlsVisibility({
             mt: false,
             mb: false,
             ml: false,
             mr: false,

             tl: true,
             tr: false,
             br: false,
             bl: false,

             mtr: true,
          });

          // fObj.hasControls = false;
          fObj.hasBorders  = true;


          return fObj;

        }


        createFabricITextWithIcObj(icObj) {
          // console.log("createFabricITextWithIcObj", icObj);

          const scale  = this.infiniteCanvas.scale;

          var fObj = new fabric.IText(icObj.text);
          fObj.set({
            left:   icObj.position.x,
            top:    icObj.position.y,
            // width:  100,
            // height: 100,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,


            fontSize: icObj.fontSize,

            // scaleX: scale,
            // scaleY: scale,

            // fill: '#f55',
            // fill: 'black',
            fill: icObj.textColor,
            backgroundColor: icObj.backgroundColor ? icObj.backgroundColor : "",

            // opacity: 0.7,


            //~'persistent'
            // birth_scale : birth_scale,

            // trueRect : trueRect,
            // true_fontSize : true_fontSize,
            icObj : icObj,

          });

          //initial size poll
          icObj.size = {
            width:  fObj.width,
            height: fObj.height,
          };

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          this.addInteraction_editText(fObj);

          return fObj;
        }

        createFabricImageWithIcObj(icObj) {

          // const scale  = infiniteCanvas.scale;

          var fObj = new fabric.Image(icObj.img);

          fObj.set({
            left:   icObj.position.x,
            top:    icObj.position.y,

            width:  icObj.img.width,
            height: icObj.img.height,
            // width:  icObj.size.width,
            // height: icObj.size.height,


            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            icObj: icObj,
          });

          // const width  = icObj.size.width;
          // const height = icObj.size.height;
          // fObj.scaleToHeight(width);
          // fObj.scaleToWidth(height);


          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;
        }


        createFabricCircleWithIcObj(icObj) {
          // console.log("createFabricCircleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Circle();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            radius: icObj.radius,

            // fill: '#f55',
            // fill: 'red',
            // fill: '',
            fill: icObj.fill,

            // stroke: 'blue',
            stroke: icObj.stroke,
            strokeWidth : 5,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj : icObj,
          });

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }

        createFabricCircleWithIcPoint(icObj) {

          const fabricIntegration = this;

          // console.log("createFabricCircleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Circle();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,


            radius: 10,

            // fill: '#f55',
            // fill: 'blue',
            fill: icObj.fill,

            stroke: '',

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj : icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          // if(icObj.canBeResized) {
          //   this.addInteraction_resize2(fObj);
          // }
          // if(icObj.canBeRotated) {
          //   this.addInteraction_rotate(fObj);
          // }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;

        }

        createFabricSvgWithIcFreeDrawing(icObj) {
          console.log("createFabricSvgWithIcFreeDrawing", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,



            fill: icObj.fill,

            // opacity: 0.7,

            icObj : icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }


        createFabricSvgWithIcObj_p(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const dataUrl = SvgHelper.toDataURL(icObj.svg);

          const promise = new Promise((resolve, reject) => {

            fabric.Image.fromURL(dataUrl, function (img) {
              console.log("img", img);
              // fabricCanvas.add(img);
              // console.log('CORS enabled + crossOrigin property - DataURL: ', img.toDataURL());
              resolve(img);
            },
            null,
            {
              crossOrigin: 'Anonymous',
            });

          });

          const promise2 = promise.then((fObj) => {

            fObj.set({
              left:   icObj.position.x,
              top:    icObj.position.y,

              width:  fObj.width,
              height: fObj.height,
              // width:  icObj.size.width,
              // height: icObj.size.height,


              scaleX: icObj.scale.X,
              scaleY: icObj.scale.Y,

              flipX:   icObj.flip.X,
              flipY:   icObj.flip.Y,

              angle :  icObj.orientation,

              icObj: icObj,
            });

            // const width  = icObj.size.width;
            // const height = icObj.size.height;
            // fObj.scaleToHeight(width);
            // fObj.scaleToWidth(height);


            //event listeners
            if(icObj.canBeHeld) {
              this.addInteraction_hold(fObj);
            }
            if(icObj.canBeMoved) {
              this.addInteraction_move(fObj);
            }
            if(icObj.canBeResized) {
              this.addInteraction_resize2(fObj);
            }
            if(icObj.canBeRotated) {
              this.addInteraction_rotate(fObj);
            }


            this.addInteraction_select(fObj);
            // this.addListeners(fObj);

            return fObj;
          });

          return promise2;
        }


        createFabricTexWithIcObj(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left:   icObj.position.x,
            top:    icObj.position.y,

            width:  icObj.size.width,
            height: icObj.size.height,


            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            originX: "left",
            originY: "top",


            icObj: icObj,
          });


          fObj.refreshTex_p = () => {
            console.log("refreshTex");

            const tex   = icObj.tex;
            const fill  = icObj.fill;

            const svgEl   = TexHelper.toSvgEl(tex, fill);
            const dataUrl = SvgHelper.toDataURL(svgEl);
            const fObj_svg_image_p = new Promise((resolve, reject) => {

              fabric.Image.fromURL(dataUrl, function (img) {
                console.log("img", img);
                // fabricCanvas.add(img);
                // console.log('CORS enabled + crossOrigin property - DataURL: ', img.toDataURL());

                // img.set({
                //   originX: "left",
                //   originY: "top",
                //   left:0,
                //   top:0,
                // });
                // img.setCoords();

                resolve(img);
              },
              null,
              {
                crossOrigin: 'Anonymous',
              });

            });

            const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
              if(fObj.child_tex != null) {
                fObj.remove(fObj.child_tex);
              }

              //add svg image as child
              fObj.child_tex = fObj_child;

              // fObj.add(fObj_child);
              fObj.addWithUpdate(fObj_child);
              console.log("fObj, added child:", fObj_child);

              /*
              fObj.set({
                width:  icObj.size.width,
                height: icObj.size.height,
              });

              function adapt_child() {
                const width  = icObj.size.width;
                const height = icObj.size.height;
                fObj_child.scaleToHeight(width);
                fObj_child.scaleToWidth(height);
              }

              function adapt_group() {
                fObj.set({
                  width:  fObj_child.width,
                  height: fObj_child.height,
                });
              }

              // adapt_child();
              */

              return fObj;
            });

            return add_fObjfObj_svg_image_p;
          };

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          // fObj.refreshTex_p()
          // .then((fObj) => {
          //   fabricCanvas.renderAll();
          // });

          return fObj;
        }


        createFabricExprWithIcObj(icObj) {

          const fabricCanvas = this.fabricCanvas;

          const fObj = new fabric.Group();

          fObj.set({
            left:   icObj.position.x,
            top:    icObj.position.y,

            width:  icObj.size.width,
            height: icObj.size.height,


            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            originX: "left",
            originY: "top",


            icObj: icObj,
          });


          fObj.refreshTex_p = () => {
            console.log("refreshTex");

            const tex   = icObj.expr.toTex();
            console.log("tex:", tex);
            const fill  = icObj.fill;

            const svgEl   = TexHelper.toSvgEl(tex, fill);
            svgEl.setAttribute("width",  fObj.width);
            svgEl.setAttribute("height", fObj.height);

            const dataUrl = SvgHelper.toDataURL(svgEl);
            const fObj_svg_image_p = new Promise((resolve, reject) => {

              fabric.Image.fromURL(dataUrl, function (img) {
                // console.log("img", img);

                const group = fObj;
                img.set({
                  // left: 0,
	                // top: 0,
                  //SHU: that smell of Scotch Tape
                  left: -fObj.width/2,
	                top:  -fObj.height/2,

                  //debug
                  // stroke: "yellow",
                  // strokeWidth: 2,
                });

                resolve(img);
              },
              null,
              {
                crossOrigin: 'Anonymous',
              });

            });

            const add_fObjfObj_svg_image_p = fObj_svg_image_p.then((fObj_child) => {
              if(fObj.child_tex != null) {
                fObj.remove(fObj.child_tex);
              }

              //add svg image as child
              fObj.child_tex = fObj_child;

              fObj.add(fObj_child);
              // fObj.addWithUpdate(fObj_child);        //this updates group's size to fit children
              console.log("fObj, added child:", fObj_child);

              return fObj;
            });

            return add_fObjfObj_svg_image_p;
          };

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;
        }



          //group

        createFabricGroupWithIcObj(icObj) {
          console.log("createFabricGroupWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Group();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            fill:    icObj.fill,

            // opacity: 0.7,

            icObj : icObj,
          });


          //create inner objects
          const fGroup = fObj;
          const childFObjs = icObj.children.map(icObj => {
            return this.createFabricGroupContentForFabricGroup(icObj, fGroup);
          });

          //add inner objects
          fObj.add(...childFObjs);



          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;

        }

        createFabricGroupContentForFabricGroup(icObj, fGroup) {
          const icGroup = fGroup.icObj;

          var fObj = this.createFabricObjectWithIcObj(icObj);

          //set the right coordinates:
          const icGroup_rect = Geometry.createRect(icGroup.position.x, icGroup.position.y, icGroup.size.width, icGroup.size.height);
          const  fGroup_rect = Geometry.createRect(fGroup.left, fGroup.top, fGroup.width, fGroup.height);

          const position = Geometry.getPointFromRectToRect(icObj.position, icGroup_rect, fGroup_rect);

          // const offsetFromCenterToTL = {
          //   dx: -fGroup.width,
          //   dy: -fGroup.height,
          // };

          const offsetFromCenterToTL = {
            dx: -fGroup.width/2,
            dy: -fGroup.height/2,
          };

          fObj.set({
            left: position.x + offsetFromCenterToTL.dx,
            top:  position.y + offsetFromCenterToTL.dy,
          });

          return fObj;

        }








        createFabricToggleRectWithIcObj(icObj) {
          console.log("createFabricToggleRectWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            //to avoid overlapping when clicking
            padding:     0,
            strokeWidth: 0,

            icObj : icObj,
          });

          configureWithIsActive(fObj, icObj.isActive);

          function configureWithIsActive(fObj, isActive) {

            const cfg = isActive ? fObj.icObj.activeCfg : fObj.icObj.inactiveCfg;

            fObj.set({
              fill:    cfg.fill,
              opacity: cfg.opacity,
            });

          }

          fObj.hasControls = false;
          fObj.hasBorders  = true;


          //event listeners
          if(icObj.canBeSelected) {

            this.addInteraction_select(fObj);

            if(icObj.canBeHeld) {
              this.addInteraction_hold(fObj);
            }

            if(icObj.canBeMoved) {
              this.addInteraction_move(fObj);
            }
            if(icObj.canBeResized) {
              this.addInteraction_resize2(fObj);
            }
            if(icObj.canBeRotated) {
              this.addInteraction_rotate(fObj);
            }


            const fabricCanvas = this.fabricCanvas;

            fObj.on('mouseup', function(options) {
              console.log("mouseup", "options", options);

              const icObj = fObj.icObj;

              const isActive_update = !icObj.isActive;

              const icObj_new = Object.assign({}, icObj);
              icObj_new.isActive = isActive_update;

              icObj.update(icObj_new, false);

              configureWithIsActive(fObj, isActive_update);

              fabricCanvas.renderAll();

            });


          } else {
            fObj.selectable = false;
          }

          // this.addListeners(fObj);



          return fObj;

        }


        createFabricSnapSlotWithIcObj(icObj) {
          console.log("createFabricSnapSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            //to avoid overlapping when clicking
            padding:     0,
            stroke:      icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj : icObj,
          });


          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }

        createFabricTouchSlotWithIcObj(icObj) {
          console.log("createFabricTouchSlotWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            //to avoid overlapping when clicking
            padding:     0,
            stroke:      icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj : icObj,
          });


          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }


        createFabricCompositeWithIcObj(icObj) {
          console.log("createFabricCompositeWithIcObj", icObj);

          const fObj = this.createFabricRectWithIcObj(icObj);

          return fObj;
        }

        createFabricCompositePartWithIcObj(icObj) {
          console.log("createFabricCompositeWithIcObj", icObj);

          const fObj = this.createFabricObjectWithIcObj(icObj);

          return fObj;
        }



        createFabricWellWithIcObj(icObj) {
          console.log("createFabricWellWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            //to avoid overlapping when clicking
            padding:     0,
            stroke:      icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj : icObj,
          });


          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }

        createFabricGreenMouseWellWithIcObj(icObj) {
          console.log("createFabricGreenMouseWellWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            //to avoid overlapping when clicking
            padding:     0,
            stroke:      icObj.stroke,
            strokeWidth: icObj.strokeWidth,
            fill: "",

            icObj : icObj,
          });


          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }


          return fObj;
        }




        createFabricSegmentWithIcObj(icObj) {
          console.log("createFabricLineWithIcSegment", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Line();

          // console.log("line:", fObj);
          // throw new Error("please die here");

          function screenPointWithoutOffset(infiniteCanvas, truePoint) {
            const screenX = truePoint.x * infiniteCanvas.scale.X;
            const screenY = truePoint.y * infiniteCanvas.scale.Y;
            return Geometry.createPoint(screenX, screenY);
          }

          const screenPoint_start = screenPointWithoutOffset(infiniteCanvas, icObj.point_start);
          const screenPoint_end   = screenPointWithoutOffset(infiniteCanvas, icObj.point_end);

          fObj.set({
            x1:   screenPoint_start.x,
            y1:   screenPoint_start.y,

            x2:   screenPoint_end.x,
            y2:   screenPoint_end.y,

            // x1:   100,
            // y1:   100,
            //
            // x2:   500,
            // y2:   500,

            stroke:      "black",
            strokeWidth: 5,
            fill:        "red",

            // stroke:      icObj.stroke,
            // strokeWidth: icObj.strokeWidth,
            // fill:        icObj.fill,

            icObj : icObj,
          });



          //write now known icObj props
          const screenRect = {
            left:   fObj.left,
            top:    fObj.top,
            width:  fObj.width,
            height: fObj.height,
          };

          const trueRect = infiniteCanvas.toTrueRect(screenRect);

          icObj.position = {
            x: trueRect.x,
            y: trueRect.y,
          };

          icObj.size = {
            width:  trueRect.width,
            height: trueRect.height,
          };




          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          return fObj;
        }



        createFabricFreeDrawingWithIcObj(icObj) {
          console.log("createFabricFreeDrawingWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          const exoObject = icObj.exoObject;

          var fObj = new fabric.Path(exoObject.path);

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,
            //
            // scaleX:  icObj.scale.X,
            // scaleY:  icObj.scale.Y,
            //
            // flipX:   icObj.flip.X,
            // flipY:   icObj.flip.Y,


            angle :  icObj.orientation,


            stroke:           exoObject.stroke,
            strokeDashArray:  exoObject.strokeDashArray,
            strokeLineCap:    exoObject.strokeLineCap,
            strokeLineJoin:   exoObject.strokeLineJoin,
            strokeMiterLimit: exoObject.strokeMiterLimit,
            strokeWidth:      exoObject.strokeWidth,

            fill:             exoObject.fill,

            opacity: icObj.opacity,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj : icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);




          //debug
          fObj.setControlsVisibility({
             mt: false,
             mb: false,
             ml: false,
             mr: false,

             tl: true,
             tr: false,
             br: false,
             bl: false,

             mtr: true,
          });

          // fObj.hasControls = false;
          fObj.hasBorders  = true;


          return fObj;
        }


        createFabricSparkleWithIcObj(icObj) {
          console.log("createFabricSparkleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          // var fObj = new fabric.Triangle();
          var fObj = new fabric.Image(icObj.img);


          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          // const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,
            width:  icObj.img.width,
            height: icObj.img.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            // fill: '#f55',
            // fill: 'red',
            fill: icObj.fill,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj : icObj,
          });

          if(icObj.isUsingCenterPosition) {
            fObj.set({
              originX: "center",          //:)
              originY: "center",          //:)
            });
          }


          if(icObj.canBeHeld) {
            this.addInteraction_hold(fObj);
          }

          return fObj;
        }







        addInteraction_move(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          fObj.on('moving', function(options) {
            // console.log("moving", "options", options);

            const target = options.target;

            const offset = infiniteCanvas.offset;
            const scale  = infiniteCanvas.scale;

            // const trueRect_left__new = (target.left / scale - offset.dx);
            // const trueRect_top__new  = (target.top  / scale - offset.dy);
            //
            // const trueRect_update = {
            //   left: trueRect_left__new,
            //   top:  trueRect_top__new,
            // };
            // Object.assign(target.trueRect, trueRect_update);



            const icObj = fObj.icObj;

            const screenPoint = {
              x: target.left,
              y: target.top,
            };

            const position_update = infiniteCanvas.toTruePoint(screenPoint);


            //---old style---
            // const icObj_new = Object.assign({}, icObj);
            // Object.assign(icObj_new.position, position_update);
            // icObj.update(icObj_new, false);

            //---new style: rep inner update---
            const rep_free = fObj.icObj;
            console.log("ççç on 'moving' rep_free.id_rep", rep_free.id_rep);
            const listener = fObj.fListener_inner;

            //listen:off
            rep_free.offInnerUpdate(listener);

            //mutate
            {
              rep_free.position = position_update;
            }

            //listen:on
            rep_free.onInnerUpdate(listener);

          });

        }

        // addInteraction_resize(fObj) {
        //
        //   const infiniteCanvas = this.infiniteCanvas;
        //   const fabricCanvas   = this.fabricCanvas;
        //
        //   var isScaling = false;
        //   var original_trueRect = null;
        //   fObj.on('scaling', function(options) {
        //     console.log("scaling", "options", options);
        //     const original = options.transform.original;
        //
        //     const target   = options.transform.target;
        //
        //     if(!isScaling) {
        //       original_trueRect = Geometry.createRect(target.icObj.position.x, target.icObj.position.y, target.icObj.size.width, target.icObj.size.height);
        //       console.log("original_trueRect", original_trueRect);
        //       isScaling = true;
        //     }
        //
        //     const scaleFactorX = target.scaleX / original.scaleX;
        //     const scaleFactorY = target.scaleY / original.scaleY;
        //
        //     console.log("scaleFactorX", scaleFactorX);
        //
        //     const trueRect_width__new  = (original_trueRect.width  * scaleFactorX);
        //     const trueRect_height__new = (original_trueRect.height * scaleFactorY);
        //
        //     console.log("trueRect_width__new", trueRect_width__new);
        //
        //
        //
        //     const offset = infiniteCanvas.offset;
        //     const scale  = infiniteCanvas.scale;
        //
        //     // const trueRect_update = {
        //     //   width:  trueRect_width__new,
        //     //   height: trueRect_height__new,
        //     // };
        //     //
        //     // // Object.assign(target.trueRect, trueRect_update);
        //     // Object.assign(fObj.trueRect, trueRect_update);
        //
        //     const trueRect_update = {
        //       left:  target.left / scale.X - offset.dx,
        //       top:   target.top  / scale.Y - offset.dy,
        //
        //       width:  (original_trueRect.width  * scaleFactorX),
        //       height: (original_trueRect.height * scaleFactorY),
        //     };
        //
        //     const icObj_update = {
        //       position: Geometry.createPoint(trueRect_update.left, trueRect_update.top),
        //       size:     Geometry.createSize(trueRect_update.width, trueRect_update.height),
        //     };
        //
        //     const icObj = fObj.icObj;
        //
        //     const icObj_new = Object.assign({}, icObj);
        //     Object.assign(icObj_new, icObj_update);
        //
        //     icObj.update(icObj_new, false);
        //
        //   });
        //   fObj.on('scaled', function(options) {
        //     console.log("scaled", "options", options);
        //     isScaling = false;
        //     original_trueRect = null;
        //
        //     const original = options.transform.original;
        //     const target   = options.transform.target;
        //
        //     target.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //
        //       //not used:
        //       // width:  target.trueRect.width  * scale,
        //       // height: target.trueRect.height * scale,
        //
        //       //used instead:
        //       // width:  target.trueRect.width,
        //       // height: target.trueRect.height,
        //       width:  target.icObj.size.width,
        //       height: target.icObj.size.height,
        //
        //       scaleX : original.scaleX,
        //       scaleY : original.scaleY,
        //     });
        //     target.setCoords();
        //   });
        //
        // }

        addInteraction_resize2(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          var isScaling = false;
          var original_homeScale = null;
          var original_scale     = null;
          fObj.on('scaling', function(options) {
            console.log("scaling", "options", options);


            const original = options.transform.original;
            const target   = options.transform.target;

            if(!isScaling) {
              original_homeScale = Object.assign({}, target.icObj.homeScale);
              // console.log("original_homeScale", original_homeScale);
              original_scale = Object.assign({}, target.icObj.scale);

              isScaling = true;
            }



            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);

            switch(options.transform.action) {

              case "scale":
                handle_proportionnal_scale();
                break;

              case "scaleX":
              case "scaleY":
                handle_axis_scale();
                // handle_proportionnal_scale();


                break;
            }

            function handle_proportionnal_scale() {

              const icObj = fObj.icObj;

              var homeScale_new;

              // if(fObj instanceof fabric.Text) {

                // const fontSize_fObj = fObj.fontSize;
                // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
                //
                // homeScale_new = {
                //   X: original_homeScale.X,
                //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
                // };

              // } else {

                homeScale_new = {
                  X: original_homeScale.X / scaleFactor.X,
                  Y: original_homeScale.Y / scaleFactor.Y,
                };

              // }
              console.log("homeScale_new", homeScale_new);

              const icObj_update = {
                homeScale: homeScale_new,
              };

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new, icObj_update);

              icObj.update(icObj_new, false);



              //update position
              {

                const fObj_pos = {
                  x: fObj.left,
                  y: fObj.top,
                };

                const position_update = infiniteCanvas.toTruePoint(fObj_pos);

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.position, position_update);

                icObj.update(icObj_new, false);

              }

              // //update flipX
              // {
              //   const flipX_update = fObj.flipX;
              //
              //   const icObj_new = Object.assign({}, icObj);
              //   Object.assign(icObj_new.flipX, flipX_update);
              //
              //   icObj.update(icObj_new, false);
              // }


            }

            function handle_axis_scale() {

              const icObj = fObj.icObj;

              var scale_new;

              // if(fObj instanceof fabric.Text) {

                // const fontSize_fObj = fObj.fontSize;
                // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
                //
                // homeScale_new = {
                //   X: original_homeScale.X,
                //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
                // };

              // } else {

                scale_new = {
                  X: original_scale.X * scaleFactor.X,
                  Y: original_scale.Y * scaleFactor.Y,
                };

              // }
              console.log("scale_new", scale_new);

              const icObj_update = {
                scale: scale_new,
              };

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new, icObj_update);

              icObj.update(icObj_new, false);




              //update position
              {

                const fObj_pos = {
                  x: fObj.left,
                  y: fObj.top,
                };

                const position_update = infiniteCanvas.toTruePoint(fObj_pos);

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.position, position_update);

                icObj.update(icObj_new, false);

              }

              //update flipX
              {
                const flip_update = {
                  X: (fObj.flipX != null) ? fObj.flipX : false,
                  Y: (fObj.flipY != null) ? fObj.flipY : false,
                };

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.flip, flip_update);

                icObj.update(icObj_new, false);
              }



            }




          });
          fObj.on('scaled', function(options) {
            console.log("scaled", "options", options);
            isScaling = false;

            /*
            const original = options.transform.original;
            const target   = options.transform.target;

            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);


            const icObj = fObj.icObj;

            var homeScale_new;

            if(fObj instanceof fabric.Text) {

              // const fontSize_fObj = fObj.fontSize;
              // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
              //
              // homeScale_new = {
              //   X: scale.X / scale_fObj.X / scaleFactor__fontSize,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

            } else {

              homeScale_new = {
                X: original_homeScale.X / scaleFactor.X,
                Y: original_homeScale.Y / scaleFactor.Y,
              };

            }
            console.log("homeScale_new", homeScale_new);


            const icObj_update = {
              homeScale: homeScale_new,
            };

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);

            icObj.update(icObj_new, false);
            */

            original_homeScale = null;

          });

        }


        addInteraction_rotate(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          // const fabricCanvas   = this.fabricCanvas;

          // var isRotating = false;

          fObj.on('rotating', function(options) {
            // console.log("rotating", "options", options);

            // if(!isRotating) {
            //   isRotating = true;
            //
            //
            // }

            const original = options.transform.original;


            const target = options.transform.target;

            const icObj = fObj.icObj;

            // const orientation_update = target.angle + infiniteCanvas.orientation;
            const orientation_update = Geometry.boundedAngleInDegrees(target.angle + infiniteCanvas.orientation);
            // console.log("orientation_update", orientation_update);




            // console.log("target.angle",     target.angle);
            // console.log("original.angle", original.angle);
            //
            // const rotationAngle = target.angle - original.angle;
            // const rotationAngle_bounded = Geometry.boundedAngleInDegrees(rotationAngle);
            // console.log("rotationAngle", rotationAngle);
            //
            // const originalRect   = Geometry.createRect(original.left, original.top, target.width, target.height);
            // const originalTL     = Geometry.getPointTL(originalRect);
            // const originalCenter = Geometry.getCenterPoint(originalRect);
            // console.log("originalTL",     originalTL);
            // console.log("originalCenter", originalCenter);
            //
            // const screenTL_new = Geometry.pointWithRotation(originalTL, originalCenter, rotationAngle_bounded);
            // console.log("screenTL_new", screenTL_new);
            //
            //
            //
            //
            //
            //
            // const position_update = infiniteCanvas.toTruePoint(screenTL_new);



            const screenPoint = {
              x: target.left,
              y: target.top,
            };

            const position_update = infiniteCanvas.toTruePoint(screenPoint);


            const icObj_new = Object.assign({}, icObj);
            // Object.assign(icObj_new.orientation, orientation_update);

            icObj_new.orientation = orientation_update;

            Object.assign(icObj_new.position, position_update);

            icObj.update(icObj_new, false);
          });

        }


        addInteraction_select(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          fObj.on('selected', function(options) {
            console.log("selected", "options", options);

            // const activeGroup = fabricCanvas.getActiveGroup();


            /*
            const activeObject   = fabricCanvas.getActiveObject();

            // console.log("activeObject", activeObject);

            const icObj = activeObject.icObj;

            console.log("icObj.size.width",  icObj.size.width);
            console.log("icObj.homeScale.X", icObj.homeScale.X);
            console.log("icObj.scale.X",     icObj.scale.X);

            console.log("icObj.getTrueSize()", activeObject.icObj.getTrueSize());

            console.log("activeObject.scaleX", activeObject.scaleX);
            console.log("activeObject.scaleY", activeObject.scaleY);

            console.log("infiniteCanvas.scale.X", infiniteCanvas.scale.X);

            if(fObj instanceof fabric.Text) {
              console.log("icObj.fontSize", icObj.fontSize);
              console.log(" fObj.fontSize",  fObj.fontSize);
            }
            */

          });

        }

        addInteraction_hold(fObj) {
          console.log("addInteraction_hold", fObj);

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          const icObj = fObj.icObj;

          var isHeld = false;
          //hold
          fObj.on('mousedown', function(options) {
            isHeld = true;
            console.log("isHeld", isHeld);
            icObj.nowHeld();
          });

          //release
          fObj.on('mouseup', function(options) {
            isHeld = false;
            console.log("isHeld", isHeld);
            icObj.nowReleased();
          });

        }


        addInteraction_editText(fObj) {

          // fObj.on('changed', function(options) {
          //
          // });

          fObj.on('changed', function(options) {
            console.log("changed", "options", options);

            console.log("fObj.text", fObj.text);

            const text_new = fObj.text;

            const icObj = fObj.icObj;

            const icObj_update = {
              text: text_new,
            };

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);

            icObj.update(icObj_new, false);

          });

        }


        configureActiveSelectionListeners() {
          // object:moving
          // object:scaling
          // object:rotating
          // object:skewing
          // object:moved
          // object:scaled
          // object:rotated
          // object:skewed

          const fabricIntegration = this;

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          //creation
          this.fabricCanvas.on("selection:created", (options) => {
            // console.log("selection:created", event);

            const activeObject = this.fabricCanvas.getActiveObject();

            if(activeObject instanceof fabric.ActiveSelection) {
              const activeSelection = activeObject;
              // console.log("activeSelection", activeSelection);

              //inject 'initial' props
              activeSelection.icObj = infiniteCanvas.createIcActiveSelection_from_activeSelectionFObj(activeSelection);
            }

          });


          //move
          this.fabricCanvas.on("object:moving", (options) => {
            // console.log("object:moving", event);

            const target = options.target;
            if(target.type == "activeSelection") {
              activeSelection_moving(target);
            }

          });

          //scale
          this.fabricCanvas.on("object:scaling", (options) => {
            // console.log("object:scaling", options);

            const target = options.target;
            if(target.type == "activeSelection") {
              activeSelection_scaling(options);
            }

          });
          this.fabricCanvas.on("object:scaled", (options) => {
            // console.log("object:scaling", event);

            const target = options.target;
            if(target.type == "activeSelection") {
              activeSelection_scaled(target);
            }

          });


          //rotate
          this.fabricCanvas.on("object:rotating", (options) => {
            // console.log("object:rotating", event);

            const target = options.target;
            if(target.type == "activeSelection") {
              activeSelection_rotating(options);
            }

          });







          function activeSelection_moving(activeSelection) {
            console.log("activeSelection moving");

            //update activeSelection position
            {
              const fObj = activeSelection;

              const icObj = fObj.icObj;

              const fObj_screenPos = {
                x: fObj.left,
                y: fObj.top,
              };

              const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new.position, position_update);

              icObj.update(icObj_new, false);
            }

            //update children position

            const activeSelectionCL = activeSelection.left + activeSelection.width  / 2;
            const activeSelectionCT = activeSelection.top  + activeSelection.height / 2;

            function updateChildFObj_position(fObj) {

              const icObj = fObj.icObj;

              const screenPoint = {
                x: activeSelectionCL + fObj.left,
                y: activeSelectionCT + fObj.top,
              };

              const position_update = infiniteCanvas.toTruePoint(screenPoint);

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new.position, position_update);

              icObj.update(icObj_new, false);
            }

            activeSelection.forEachObject((fObj, index, arr_fObj) => {
              updateChildFObj_position(fObj);
            }, fabricIntegration.fabricCanvas.context);


          }



          var isScaling = false;
          var original_props = {};
          function activeSelection_scaling(options) {
            console.log("activeSelection scaling", options);

            const target   = options.target;
            const original = options.transform.original;

            const activeSelection = target;

            if(!isScaling) {

              //store original props
              const activeSelection_icObj_propDict = {
                homeScale:  Object.assign({}, activeSelection.icObj.homeScale),
                scale:      Object.assign({}, activeSelection.icObj.scale),
              };

              original_props["activeSelection_icObj"] = activeSelection_icObj_propDict;

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                const propDict = {
                  homeScale:  Object.assign({}, icObj.homeScale),
                  scale:      Object.assign({}, icObj.scale),
                };

                original_props[icObj.id] = propDict;

              }, fabricIntegration.fabricCanvas.context);

              isScaling = true;
            }



            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);

            switch(options.transform.action) {

              case "scale":
                handle_proportionnal_scale(activeSelection);
                break;

              case "scaleX":
              case "scaleY":
                handle_axis_scale(activeSelection);

                break;
            }

            function handle_proportionnal_scale(activeSelection) {

              //update activeSelection icObj
              {
                const icObj = activeSelection.icObj;

                var homeScale_new;

                const original_homeScale = original_props["activeSelection_icObj"].homeScale;

                homeScale_new = {
                  X: original_homeScale.X / scaleFactor.X,
                  Y: original_homeScale.Y / scaleFactor.Y,
                };

                console.log("homeScale_new", homeScale_new);

                const icObj_update = {
                  homeScale: homeScale_new,
                };

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new, icObj_update);

                icObj.update(icObj_new, false);
              }


              //update children

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                //update scale
                {
                  var homeScale_new;

                  const original_homeScale = original_props[icObj.id].homeScale;

                  homeScale_new = {
                    X: original_homeScale.X / scaleFactor.X,
                    Y: original_homeScale.Y / scaleFactor.Y,
                  };

                  console.log("homeScale_new", homeScale_new);

                  const icObj_update = {
                    homeScale: homeScale_new,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new, icObj_update);

                  icObj.update(icObj_new, false);
                }


                //update position
                {

                  const activeSelectionCenterX = activeSelection.width / 2;
                  const activeSelectionCenterY = activeSelection.height / 2;

                  const fObj_pos_wrt_ASTL = {
                    left: activeSelectionCenterX + fObj.left,
                    top:  activeSelectionCenterY + fObj.top,
                  };

                  const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

                  const fObj_screenPos = {
                    x: activeSelection.left + scaleFactor.X * (Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left - Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
                    y: activeSelection.top  + scaleFactor.Y * (Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
                  };

                  const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.position, position_update);

                  icObj.update(icObj_new, false);

                }
              });

            }

            function handle_axis_scale(activeSelection) {

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                //update scale
                {
                  var scale_new;

                  const original_scale = original_props[icObj.id].scale;

                  scale_new = {
                    X: original_scale.X * scaleFactor.X,
                    Y: original_scale.Y * scaleFactor.Y,
                  };

                  console.log("scale_new", scale_new);

                  const icObj_update = {
                    scale: scale_new,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new, icObj_update);

                  icObj.update(icObj_new, false);
                }


                var fObj_sign = {
                  X:+1,
                  Y:+1
                };
                switch(options.originX) {
                  case "left":
                    fObj_sign.X = +1;
                    break;
                  case "right":
                    fObj_sign.X = -1;
                    break;
                }

                switch(options.originY) {
                  case "top":
                    fObj_sign.Y = +1;
                    break;
                  case "bottom":
                    fObj_sign.Y = -1;
                    break;
                }


                //update position
                {

                  const activeSelectionCenterX = fObj_sign.X * activeSelection.width / 2;
                  const activeSelectionCenterY = fObj_sign.Y * activeSelection.height / 2;

                  const fObj_pos_wrt_ASTL = {
                    left: activeSelectionCenterX + fObj_sign.X * fObj.left,
                    top:  activeSelectionCenterY + fObj_sign.Y * fObj.top,
                  };

                  const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

                  const fObj_screenPos = {
                    x: activeSelection.left + scaleFactor.X * (Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left - Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
                    y: activeSelection.top  + scaleFactor.Y * (Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
                  };

                  const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.position, position_update);

                  icObj.update(icObj_new, false);

                }

                //update flip
                {
                  const flip_update = {
                    X: (activeSelection.flipX != null) ? activeSelection.flipX : false,
                    Y: (activeSelection.flipY != null) ? activeSelection.flipY : false,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.flip, flip_update);

                  icObj.update(icObj_new, false);
                }

              });

            }


          }

          function activeSelection_scaled(activeSelection) {
            isScaling = false;
            original_props = {};
          }





          function activeSelection_rotating(options) {
            console.log("activeSelection rotating", options);

            const target   = options.transform.target;
            // const original = options.transform.original;

            const activeSelection = target;

            activeSelection.forEachObject((fObj, index, arr_fObj) => {
              const icObj = fObj.icObj;

              const activeSelectionCenterX = activeSelection.width / 2;
              const activeSelectionCenterY = activeSelection.height / 2;

              const fObj_pos_wrt_ASTL = {
                left: activeSelectionCenterX + fObj.left,
                top:  activeSelectionCenterY + fObj.top,
              };

              const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

              const fObj_screenPos = {
                x: activeSelection.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left - Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top,
                y: activeSelection.top  + Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top,
              };

              const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);




              const fObj_angle = target.angle + fObj.angle;
              const orientation_update = Geometry.boundedAngleInDegrees(fObj_angle + infiniteCanvas.orientation);

              const icObj_new = Object.assign({}, icObj);

              Object.assign(icObj_new.position, position_update);
              icObj_new.orientation = orientation_update;

              icObj.update(icObj_new, false);
            });

          }


        }







        addListeners(fObj) {

          fObj.on('modified', function(options) {
            console.log("modified", "options", options);
          });

        }



        // createFabricSampleObjectWithCanvasBoundingRect(canvasBoundingTrueRect) {
        //
        //   const trueRect = {
        //     left: canvasBoundingTrueRect.left,
        //     top:  canvasBoundingTrueRect.top,
        //     width:  50,
        //     height: 50,
        //   };
        //
        //   var fObj = new fabric.Rect();
        //   fObj.set({
        //     left:   trueRect.left,
        //     top:    trueRect.top,
        //     width:  trueRect.width,
        //     height: trueRect.height,
        //
        //     // fill: '#f55',
        //     fill: 'red',
        //     // opacity: 0.7,
        //
        //     trueRect : trueRect,
        //   });
        //
        //   //event listeners
        //
        //   fObj.on('moving', function(options) {
        //     console.log("moving", "options", options);
        //
        //     const target = options.target;
        //
        //     const trueRect_left__new = (target.left / scale - offset.dx);
        //     const trueRect_top__new  = (target.top  / scale - offset.dy);
        //
        //     const trueRect_update = {
        //       left: trueRect_left__new,
        //       top:  trueRect_top__new,
        //     };
        //
        //     Object.assign(target.trueRect, trueRect_update);
        //     Object.assign(.trueRect, trueRect_update);
        //
        //   });
        //
        //
        //   var isScaling = false;
        //   var original_trueRect = null;
        //   fObj.on('scaling', function(options) {
        //     console.log("scaling", "options", options);
        //     const original = options.transform.original;
        //
        //     const target   = options.transform.target;
        //
        //     if(!isScaling) {
        //       original_trueRect = Object.assign({}, target.trueRect);
        //       console.log("original_trueRect", original_trueRect);
        //       isScaling = true;
        //     }
        //
        //     const scaleFactorX = target.scaleX / original.scaleX;
        //     const scaleFactorY = target.scaleY / original.scaleY;
        //
        //     console.log("scaleFactorX", scaleFactorX);
        //
        //
        //     const trueRect_width__new  = (original_trueRect.width  * scaleFactorX);
        //     const trueRect_height__new = (original_trueRect.height * scaleFactorY);
        //
        //     console.log("trueRect_width__new", trueRect_width__new);
        //
        //     const trueRect_update = {
        //       width:  trueRect_width__new,
        //       height: trueRect_height__new,
        //     };
        //
        //     // Object.assign(target.trueRect, trueRect_update);
        //     Object.assign(fObj.trueRect, trueRect_update);
        //   });
        //   fObj.on('scaled', function(options) {
        //     console.log("scaled", "options", options);
        //     isScaling = false;
        //     original_trueRect = null;
        //
        //     const original = options.transform.original;
        //     const target   = options.transform.target;
        //
        //     target.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //
        //       //not used:
        //       // width:  target.trueRect.width  * scale,
        //       // height: target.trueRect.height * scale,
        //
        //       //used instead:
        //       width:  target.trueRect.width,
        //       height: target.trueRect.height,
        //
        //       scaleX : original.scaleX,
        //       scaleY : original.scaleY,
        //     });
        //     target.setCoords();
        //   });
        //
        //
        //   fObj.on('modified', function(options) {
        //     console.log("modified", "options", options);
        //   });
        //
        //   fObj.on('selected', function(options) {
        //     console.log("selected", "options", options);
        //     const activeObject   = this.infiniteCanvas.canvas.getActiveObject();
        //
        //     console.log("activeObject.trueRect", activeObject.trueRect);
        //     console.log("activeObject.scaleX", activeObject.scaleX);
        //     console.log("activeObject.scaleY", activeObject.scaleY);
        //
        //
        //   });
        //
        //   // fabric.util.addListener(canvas, 'object:modified', function (event, self) {
        //   //   console.log('object:modified', "event", event);
        //   //
        //   // });
        //
        //   return fObj;
        // }



        addOuterFabricObject(fObj) {
          console.log("addOuterFabricObject", fObj);

          const fabricIntegration = this;

          switch(fObj.icObj.type) {
            // case "composite":
            //   Object.values(fObj.parts).forEach((fObjPart, i) => {
            //     default_add(fObjPart);
            //   });
            //   break;
            default:
              default_add(fObj);
              break;
          }

          function default_add(fObj) {

            // this.outer_fabric_objects.push(fObj);
            fabricIntegration.fabric_objects.push(fObj);

            const icObj = fObj.icObj;
            fabricIntegration.fObjForIcObj_dict[icObj.id] = fObj;

            fabricIntegration.fabricCanvas.add(fObj);
          }

        }

        // addPureOuterFabricObject(fObj) {
        //   console.log("addPureOuterFabricObject", fObj);
        //
        //   // this.outer_fabric_objects.push(fObj);
        //   this.fabric_objects__pure.push(fObj);
        //
        //   this.fabricCanvas.add(fObj);
        // }

        addInnerFabricObject(fObj) {
          console.log("addInnerFabricObject", fObj);

          // this.inner_fabric_objects.push(fObj);
          this.fabric_objects.push(fObj);

          this.fabricCanvas.add(fObj);
        }


        removeFabricObject(fObj) {
          console.log("removeFabricObject", fObj);

          /*
          //nuke
          // this.fabricCanvas.remove(...this.fabricCanvas.getObjects());
          this.fabricCanvas.remove(...this.fabric_objects);
          */

          console.log("this.fabric_objects.length", this.fabric_objects.length);
          {
            const fabric_objects_new =  Utils.arrayByRemovingElement(this.fabric_objects, fObj);

            this.setFabricObjects(fabric_objects_new);
          }
          console.log("this.fabric_objects.length", this.fabric_objects.length);


          console.log("this.fabric_objects", this.fabric_objects);


          // fObj.remove();
          this.fabricCanvas.remove(fObj);

          /*
          //antinuke
          this.fabricCanvas.add(...this.fabric_objects);
          */

          // console.log("this.fabricCanvas", this.fabricCanvas);
          // this.fabricCanvas.requestRenderAll();
        }


        deselectAll() {
          // this.fabricCanvas.deactivateAll();

          // this.fabricCanvas.discardActiveGroup();
          this.fabricCanvas.discardActiveObject();
          this.fabricCanvas.renderAll();
        }





        // debugFabric() {
        //
        //   const trueRect = {
        //     top:  100,
        //     left: 100,
        //     width: 20,
        //     height: 20,
        //   };
        //
        //   // create a rectangle object
        //   var fObj = new fabric.Rect({
        //     left: trueRect.left,
        //     top: trueRect.top,
        //     fill: 'red',
        //     width: trueRect.width,
        //     height: trueRect.height,
        //     trueRect : trueRect,
        //   });
        //
        //   this.addFabricObject(fObj);
        // }

        // updateFabricObjectsPosition(redrawOccasion) {
        //   console.log("updateFabricObjectsPosition", redrawOccasion);
        //
        //   const offset      = this.infiniteCanvas.offset;
        //   const scale       = this.infiniteCanvas.scale;
        //
        //   this.fabric_objects.forEach((fObj, i) => {
        //     //console.log("fObj A", fObj);
        //
        //     const icObj = fObj.icObj;
        //
        //     const truePos = {
        //       x: icObj.position.x  + offset.dx,
        //       y: icObj.position.y  + offset.dy,
        //     };
        //
        //     fObj.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //       left: truePos.x * scale.X,
        //       top:  truePos.y * scale.Y,
        //     });
        //
        //     // Object.assign(fObj.trueRect, truePos);
        //     fObj.setCoords();
        //
        //     //console.log("fObj B", fObj);
        //
        //   });
        // }

        updateFabricObjectsPosition(redrawOccasion) {

          switch(redrawOccasion) {
            case RedrawOccasion.scaleChanged:
              this.updateFabricObjectsPosition_zScroll(redrawOccasion);
              break;

            // case RedrawOccasion.orientationChanged:
            //   this.updateFabricObjectsPosition_rScroll();
            //   break;

            default:
              this.updateFabricObjectsPosition_default(redrawOccasion);
              break;
          }

        }

        updateFabricObjectsPosition_zScroll(redrawOccasion) {

          const activeObject = this.fabricCanvas.getActiveObject();

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          if(activeObject instanceof fabric.ActiveSelection) {

            const activeSelection = activeObject;

            this.updateFabricObject_position_zScroll__container(activeSelection);

            const arr_affected   = activeSelection.getObjects()
                                                  .filter(fObj => fObj.icObj.canBeMoved);

            const arr1 = fabric_objects;
            const arr2 = arr_affected;

            let difference = arr1.filter(x => !arr2.includes(x));
            const arr_unaffected = difference;

            arr_affected.forEach((fObj, i) => {
              this.updateFabricObject_position_zScroll__contained(activeSelection, fObj);
            });

            arr_unaffected.forEach((fObj, i) => {
              this.updateFabricObject_position_default(fObj);
            });

          } else {
            fabric_objects.forEach((fObj, i) => {

              if(fObj == activeObject) {
                this.updateFabricObject_position_zScroll__container(fObj);
              } else {
                this.updateFabricObject_position_default(fObj);
              }

            });
          }

        }

        // updateFabricObjectsPosition_rScroll(redrawOccasion) {
        //
        //   const activeObject = this.fabricCanvas.getActiveObject();
        //
        //   // const fabric_objects = this.fabric_objects;
        //   const fabric_objects = this.getFabricObjects();
        //
        //   fabric_objects.forEach((fObj, i) => {
        //
        //     if(fObj == activeObject) {
        //       this.updateFabricObject_position_rScroll(fObj);
        //     } else {
        //       this.updateFabricObject_position_default(fObj);
        //     }
        //
        //   });
        //
        // }


        updateFabricObjectsPosition_default(redrawOccasion) {

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          var fObjs_to_move = [];

          const activeObject = this.fabricCanvas.getActiveObject();
          if(activeObject instanceof fabric.ActiveSelection) {
            const activeSelection = activeObject;

            fObjs_to_move = [activeSelection];

            const arr_affected   = activeSelection.getObjects();

            const arr1 = fabric_objects;
            const arr2 = arr_affected;

            let difference = arr1.filter(x => !arr2.includes(x));
            const arr_unaffected = difference;

            fObjs_to_move.push(...arr_unaffected);

          } else {
            fObjs_to_move = [...fabric_objects];
          }

          fObjs_to_move.forEach((fObj, i) => {
            this.updateFabricObject_position_default(fObj);
          });

        }

        // updateFabricObject_position_rScroll(fObj) {
        //
        //   const infiniteCanvas = this.infiniteCanvas;
        //
        //   const offset      = infiniteCanvas.offset;
        //   const scale       = infiniteCanvas.scale;
        //
        //   const orientation = 0;
        //
        //   const orientationBaseVectors = infiniteCanvas.getOrientationBaseVectors();
        //
        //   // const origin = {
        //   //   x:0,
        //   //   y:0,
        //   // };
        //
        //   // const centerPoint = infiniteCanvas.getTrueCenterPoint();
        //   // console.log("centerPoint", centerPoint);
        //
        //   function compute_fObj_position_vector(icObj) {
        //
        //     const v1_no_orientation = {
        //       x: icObj.position.x,
        //       y: icObj.position.y,
        //     }
        //
        //     const v1_with_orientation = {
        //       x: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.u),
        //       y: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.v),
        //     };
        //
        //     const v1_with_orientation__with_offset = {
        //       x: v1_with_orientation.x + offset.dx,
        //       y: v1_with_orientation.y + offset.dy,
        //     };
        //
        //     const v1_with_orientation__with_offset__scaled = {
        //       x: v1_with_orientation__with_offset.x * scale.X,
        //       y: v1_with_orientation__with_offset.y * scale.Y,
        //     };
        //
        //     return v1_with_orientation__with_offset__scaled;
        //
        //   }
        //
        //
        //
        //   const icObj = fObj.icObj;
        //
        //   const v = compute_fObj_position_vector(icObj);
        //
        //   fObj.set({
        //     // x: x + offsetX,
        //     // y: y + offsetY,
        //     left: v.x,
        //     top:  v.y,
        //
        //     angle: icObj.orientation - orientation,
        //   });
        //
        //   // Object.assign(fObj.trueRect, truePos);
        //   fObj.setCoords();
        //
        // }

        updateFabricObject_position_zScroll__container(fObj) {
          console.log("updateFabricObject_position_zScroll__container", fObj);
          const infiniteCanvas = this.infiniteCanvas;

          const icObj = fObj.icObj;


          var position_update = null;

          const mouseIntegration = this.mouseIntegration;
          if(mouseIntegration.leftMouseDown) {
            // console.log("leftMouseDown zScroll");

            const cursor_truePoint = infiniteCanvas.getTrueCursor();
            //SHU: TODO: (later) prendre en compte le point grâce auquel on a attrapé l'objet (ce n'est pas le coin top left)
            position_update = cursor_truePoint;

          } else {
            // console.log("leftMouseUp zScroll");

            const fObj_screenPos = {
              x: fObj.left,
              y: fObj.top,
            };
            position_update = infiniteCanvas.toTruePoint(fObj_screenPos);
          }


          const icObj_new = Object.assign({}, icObj);
          Object.assign(icObj_new.position, position_update);

          icObj.update(icObj_new, false);

        }

        updateFabricObject_position_zScroll__contained(activeSelection, fObj) {
          console.log("updateFabricObject_position_zScroll", fObj);

          const scaleFactor = {
            X: activeSelection.scaleX,
            Y: activeSelection.scaleY,
          };

          //update position
          {
            const icObj = fObj.icObj;

            const activeSelectionCenterX = activeSelection.width / 2;
            const activeSelectionCenterY = activeSelection.height / 2;

            const fObj_pos_wrt_ASTL = {
              left: activeSelectionCenterX + fObj.left,
              top:  activeSelectionCenterY + fObj.top,
            };

            const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

            const fObj_screenPos = {
              x: activeSelection.left + scaleFactor.X * (Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left - Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
              y: activeSelection.top  + scaleFactor.Y * (Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
            };

            const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new.position, position_update);

            icObj.update(icObj_new, false);

          }

        }


        updateFabricObject_position_default(fObj) {
          console.log("updateFabricObject_position_default", fObj);

          //SHU: TODO: update fabric.Line object position
          if(fObj instanceof fabric.Line) {
            return;
          }

          // if(fObj.icObj.type == "sparkle") {
          //   return;
          // }


          const infiniteCanvas = this.infiniteCanvas;

          const offset      = infiniteCanvas.offset;
          const scale       = infiniteCanvas.scale;

          const orientation = infiniteCanvas.orientation;

          const orientationBaseVectors = infiniteCanvas.getOrientationBaseVectors();

          // const origin = {
          //   x:0,
          //   y:0,
          // };

          // const centerPoint = infiniteCanvas.getTrueCenterPoint();
          // console.log("centerPoint", centerPoint);

          function compute_fObj_position_vector(icObj) {

            const v1_no_orientation = {
              x: icObj.position.x,
              y: icObj.position.y,
            }

            const v1_with_orientation = {
              x: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.u),
              y: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.v),
            };

            const v1_with_orientation__with_offset = {
              x: v1_with_orientation.x + offset.dx,
              y: v1_with_orientation.y + offset.dy,
            };

            const v1_with_orientation__with_offset__scaled = {
              x: v1_with_orientation__with_offset.x * scale.X,
              y: v1_with_orientation__with_offset.y * scale.Y,
            };

            return v1_with_orientation__with_offset__scaled;

          }



          const icObj = fObj.icObj;

          const v = compute_fObj_position_vector(icObj);

          fObj.set({
            // x: x + offsetX,
            // y: y + offsetY,
            left: v.x,
            top:  v.y,

            angle: icObj.orientation - orientation,
          });

          // Object.assign(fObj.trueRect, truePos);
          fObj.setCoords();
        }






        updateFabricObjectsSize(redrawOccasion) {
          console.log("updateFabricObjectsSize", redrawOccasion);

          switch(redrawOccasion) {
            case RedrawOccasion.scaleChanged:
              this.updateFabricObjectsSize_zScroll();
              break;

            default:
              this.updateFabricObjectsSize_default();
              break;
          }

          // canvas.renderAll();
        }


        updateFabricObjectsSize_zScroll() {

          const activeObject = this.fabricCanvas.getActiveObject();

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          if(activeObject instanceof fabric.ActiveSelection) {

            const activeSelection = activeObject;

            this.updateFabricObject_size_zScroll(activeSelection);

            const arr_affected   = activeSelection.getObjects()
                                                  .filter(fObj => fObj.icObj.canBeMoved);


            const arr1 = fabric_objects;
            const arr2 = arr_affected;

            let difference = arr1.filter(x => !arr2.includes(x));
            const arr_unaffected = difference;

            arr_affected.forEach((fObj, i) => {
              this.updateFabricObject_size_zScroll(fObj);
            });

            arr_unaffected.forEach((fObj, i) => {
              this.updateFabricObject_size_default(fObj);
            });

          } else {
            fabric_objects.forEach((fObj, i) => {

              if(fObj == activeObject) {
                this.updateFabricObject_size_zScroll(fObj);
              } else {
                this.updateFabricObject_size_default(fObj);
              }

            });
          }



        }

        updateFabricObjectsSize_default() {
          console.log("updateFabricObjectsSize_default");

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          fabric_objects.forEach((fObj, i) => {
            this.updateFabricObject_size_default(fObj);
          });

        }



        updateFabricObject_size_zScroll(fObj) {
          console.log("updateFabricObject_size_zScroll", fObj);
          console.log("fObj.icObj", fObj.icObj);

          const scale  = this.infiniteCanvas.scale;

          // if(fObj instanceof fabric.ActiveSelection) {
            // updateActiveSelectionFObj_size_zScroll(fObj);
          // } else {
            updateStdFObj_size_zScroll(fObj);
          // }



          function updateStdFObj_size_zScroll(fObj) {
            console.log("updateFabricObject_size_zScroll", fObj);

            const scale_fObj = {
              X: fObj.scaleX,
              Y: fObj.scaleY,
            };
            console.log("scale_fObj", scale_fObj);

            const icObj = fObj.icObj;


            var homeScale_new;

            if(fObj instanceof fabric.Text) {

              const fontSize_fObj = fObj.fontSize;
              const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;

              // homeScale_new = {
              //   X: scale.X / scale_fObj.X / scaleFactor__fontSize,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

              homeScale_new = {
                X: scale.X / (scale_fObj.X / icObj.scale.X) / scaleFactor__fontSize,
                Y: scale.Y / (scale_fObj.Y / icObj.scale.Y) / scaleFactor__fontSize,
              };

            } else {

              // homeScale_new = {
              //   X: scale.X / scale_fObj.X,
              //   Y: scale.Y / scale_fObj.Y,
              // };

              homeScale_new = {
                X: scale.X / (scale_fObj.X / icObj.scale.X),
                Y: scale.Y / (scale_fObj.Y / icObj.scale.Y),
              };

            }
            console.log("homeScale_new", homeScale_new);

            const icObj_update = {
              homeScale: homeScale_new,
            };

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);

            icObj.update(icObj_new, false);

            // fObj.setCoords();

          }

          function updateActiveSelectionFObj_size_zScroll(activeSelection) {

            activeSelection.getObjects().forEach((fObj, i) => {
              updateStdFObj_size_zScroll(fObj);
            });


          }






        }

        updateFabricObject_size_default(fObj) {
          console.log("updateFabricObject_size_default", fObj);

          //SHU: TODO: update fabric.Line object position
          if(fObj instanceof fabric.Line) {
            return;
          }

          // if(fObj.icObj.type == "sparkle") {
          //   return;
          // }


          const scale  = this.infiniteCanvas.scale;
          console.log("scale", scale);

          console.log("scale.X", scale.X);
          console.log("fObj.icObj.homeScale.X", fObj.icObj.homeScale.X);

          const scaleFactorX = scale.X / fObj.icObj.homeScale.X;
          const scaleFactorY = scale.Y / fObj.icObj.homeScale.Y;

          const scaleFactor = {
            X: scaleFactorX,
            Y: scaleFactorY,
          };

          console.log("scaleFactorX", scaleFactorX);



          if(fObj instanceof fabric.Text) {

            // const fontSize = fObj.true_fontSize * scale;
            // const fontSize = fObj.icObj.fontSize * scale.X;
            const fontSize = fObj.icObj.fontSize * scaleFactor.X;

            console.log("fontSize", fontSize);
            // fObj.set({
            //   fontSize: fontSize,
            // });

            const fontSize_max = 10000;
            // if(fontSize > fontSize_max) {
            //
            //   const scaleAmount_fix = (fontSize - fontSize_max) / fontSize_max;
            //   const scale_fix = 1.0 * (1 + scaleAmount_fix);
            //   console.log("scale_fix", scale_fix);
            //
            //   fObj.set({
            //     fontSize: fontSize_max,
            //
            //     scaleX: scale_fix,
            //     scaleY: scale_fix,
            //   });
            //
            // } else {
            //   fObj.set({
            //     fontSize: fontSize,
            //
            //     scaleX: 1,
            //     scaleY: 1,
            //   });
            // }

            function scaleWithTargetFontSize(targetFontSize) {

              const scaleAmount_fix = (fontSize - targetFontSize) / targetFontSize;
              const scale_fix = {
                X: fObj.icObj.scale.X * (1 + scaleAmount_fix),
                Y: fObj.icObj.scale.Y * (1 + scaleAmount_fix),
              };
              console.log("scale_fix", scale_fix);

              fObj.set({
                fontSize: targetFontSize,

                scaleX: scale_fix.X,
                scaleY: scale_fix.Y,
              });

            }

            if(fontSize > fontSize_max) {

              scaleWithTargetFontSize(fontSize_max);

            } else {
              // fObj.set({
              //   fontSize: fontSize,
              //
              //   scaleX: fObj.icObj.scale.X,
              //   scaleY: fObj.icObj.scale.Y,
              // });

              const closestIntegerFontSize = Math.max(1, Math.floor(fontSize));

              scaleWithTargetFontSize(closestIntegerFontSize);

            }



          }
          // else if(fObj instanceof fabric.Image) {
          //
          //   // fObj.scale(scale);
          //
          //   const width  = fObj.icObj.img.width  * scale.X;
          //   const height = fObj.icObj.img.height * scale.Y;
          //
          //   fObj.scaleToWidth(width);
          //   fObj.scaleToHeight(height);
          //
          // } else if(fObj instanceof fabric.Rect) {
          else {

            console.log("fObj", fObj);
            fObj.set({
              scaleX: fObj.icObj.scale.X * scaleFactor.X,
              scaleY: fObj.icObj.scale.Y * scaleFactor.Y,
            });

          }
          // else {
          //   console.log("unknown instance type");
          // }

          fObj.setCoords();

        }






        updateIcObjWithFObj(fObj) {
          console.log("updateIcObjWithFObj", fObj);

          const offset = this.infiniteCanvas.offset;
          const scale  = this.infiniteCanvas.scale;
          console.log("scale", scale);


          const trueRect_update = {
            left:  fObj.left / scale.X - offset.dx,
            top:   fObj.top  / scale.Y - offset.dy,

            width:  fObj.width  / scale.X,
            height: fObj.height / scale.Y,
          };

          const icObj_update = {
            position: Geometry.createPoint(trueRect_update.left, trueRect_update.top),
            size:     Geometry.createSize(trueRect_update.width, trueRect_update.height),
          };

          const icObj = fObj.icObj;

          const icObj_new = Object.assign({}, icObj);
          Object.assign(icObj_new, icObj_update);

          console.log("icObj_new", icObj_new);

          icObj.update(icObj_new, false);

        }









        //free drawing

        initializeFreeDrawing() {

          // this.fabricCanvas.isDrawingMode = true;

          if (fabric.PatternBrush) {
              var vLinePatternBrush = new fabric.PatternBrush(canvas);
              vLinePatternBrush.getPatternSrc = function() {

                var patternCanvas = fabric.document.createElement('canvas');
                patternCanvas.width = patternCanvas.height = 10;
                var ctx = patternCanvas.getContext('2d');

                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(0, 5);
                ctx.lineTo(10, 5);
                ctx.closePath();
                ctx.stroke();

                return patternCanvas;
              };

              var hLinePatternBrush = new fabric.PatternBrush(canvas);
              hLinePatternBrush.getPatternSrc = function() {

                var patternCanvas = fabric.document.createElement('canvas');
                patternCanvas.width = patternCanvas.height = 10;
                var ctx = patternCanvas.getContext('2d');

                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(5, 0);
                ctx.lineTo(5, 10);
                ctx.closePath();
                ctx.stroke();

                return patternCanvas;
              };

              var squarePatternBrush = new fabric.PatternBrush(canvas);
              squarePatternBrush.getPatternSrc = function() {

                var squareWidth = 10, squareDistance = 2;

                var patternCanvas = fabric.document.createElement('canvas');
                patternCanvas.width = patternCanvas.height = squareWidth + squareDistance;
                var ctx = patternCanvas.getContext('2d');

                ctx.fillStyle = this.color;
                ctx.fillRect(0, 0, squareWidth, squareWidth);

                return patternCanvas;
              };

              var diamondPatternBrush = new fabric.PatternBrush(canvas);
              diamondPatternBrush.getPatternSrc = function() {

                var squareWidth = 10, squareDistance = 5;
                var patternCanvas = fabric.document.createElement('canvas');
                var rect = new fabric.Rect({
                  width: squareWidth,
                  height: squareWidth,
                  angle: 45,
                  fill: this.color
                });

                var canvasWidth = rect.getBoundingRect().width;

                patternCanvas.width = patternCanvas.height = canvasWidth + squareDistance;
                rect.set({ left: canvasWidth / 2, top: canvasWidth / 2 });

                var ctx = patternCanvas.getContext('2d');
                rect.render(ctx);

                return patternCanvas;
              };

              var img = new Image();
              img.src = '../assets/honey_im_subtle.png';

              var texturePatternBrush = new fabric.PatternBrush(canvas);
              texturePatternBrush.source = img;
            }

        }


        enterFreeDrawing() {
          const fabricIntegration = this;

          const brush = this.fabricCanvas.freeDrawingBrush;

          brush.width = 20;

          const rgbColor = this.inputProperties.getActiveColor();
          const opacity  = this.inputProperties.getActiveOpacity();
          const rgbaColorString = this.inputProperties.getActiveRgbaColorString();

          // brush.color   = this.inputProperties.getActiveColor();
          brush.color = rgbaColorString;

          this.fabricCanvas.isDrawingMode = true;

          this.current_freeDrawing_objects = [];
          function freeDrawing_objectAdded(e) {
            console.log("freeDrawing_objectAdded",e);

            const fObj = e.target;
            fObj.set({
              stroke:  rgbColor,
              opacity: opacity,
            });

            fabricIntegration.current_freeDrawing_objects.push(e.target);
            // console.log("fabricIntegration.current_freeDrawing_objects", fabricIntegration.current_freeDrawing_objects);
          }

          this.freeDrawing_objectAdded = freeDrawing_objectAdded;
          this.fabricCanvas.on('object:added', this.freeDrawing_objectAdded);

        }

        leaveFreeDrawing() {
          this.fabricCanvas.isDrawingMode = false;
          this.fabricCanvas.off('object:added', this.freeDrawing_objectAdded);

          //get newly created fabric objects
          // var last = canvas_objects[canvas_objects.length -1]; //Get last object
          const freeDrawing_objects_created = [...this.current_freeDrawing_objects];
          this.current_freeDrawing_objects = [];

          this.manageCreatedFreeDrawingObjects(freeDrawing_objects_created);

        }

        manageCreatedFreeDrawingObjects(arr_fObj) {
          console.log("manageCreatedFreeDrawingObjects", arr_fObj);

          //group newly created fabric objects (or not (for easy delete))

          //create icObj from fObj
          arr_fObj.forEach((fObj) => {
            const icObj = this.infiniteCanvas.createIcFreeDrawing_from_freeDrawingFObj(fObj);
            this.infiniteCanvas.addNewIcObject(icObj);

            //SHU: HERE WE COULD HAVE RECYCLED ALREADY CREATED FOBJ AND AVOID RECREATING A NEW ONE
            this.fabricCanvas.remove(fObj);
          });

        }






        deleteSelection() {
          const fabricIntegration = this;

          const fObj = this.fabricCanvas.getActiveObject();

          function deleteFObj(fObj_to_delete) {
            fObj_to_delete.icObj.delete_p()
            .then(() => {
              fabricIntegration.removeFabricObject(fObj_to_delete);
            })
            .catch(err => {
              console.log("fObj.icObj.delete_p", "error", err);
            });
          }

          if(fObj instanceof fabric.ActiveSelection) {

            fObj.getObjects().forEach((fObj, i) => {
              deleteFObj(fObj);
            });

            this.fabricCanvas.discardActiveObject();
            this.fabricCanvas.requestRenderAll();

          } else {

            deleteFObj(fObj);

          }


        }


        shouldIgnoreShortcutInput() {
          var outBool;

          const fObj = this.fabricCanvas.getActiveObject();
          if(fObj) {
            outBool = fObj.isEditing;
          } else {
            outBool = false;
          }

          return outBool;
        }




        initializeFabricObjectCopyCut() {
          const fabricIntegration = this;

          const legacyOnCopyFunc = document.oncopy;
          document.oncopy = function(event) {

            if(legacyOnCopyFunc) {
              legacyOnCopyFunc(event);
            }

            fabricIntegration.copySelection(event);
          };

          const legacyOnCutFunc = document.oncut;
          document.oncut = function(event) {

            if(legacyOnCutFunc) {
              legacyOnCutFunc(event);
            }

            fabricIntegration.cutSelection(event);
          };

        }

        copySelection(event) {
          console.log("copySelection", event);

          const clipboardIntegration = this.clipboardIntegration;
          // this.fabricCanvas.getActiveObject().clone(function(cloned) {
          //   clipboardIntegration.manageInnerCopy("fabric.general", cloned);
          // });
          const icObj = this.fabricCanvas.getActiveObject().icObj;
          const cloned = icObj.deepClone();
          cloned.position.x += 10;
          cloned.position.y += 10;

          clipboardIntegration.manageInnerCopy("fabric.general", cloned);
        }

        cutSelection(event) {
          console.log("cutSelection", event);

          //copy
          this.copySelection(event);

          //remove object
          const icObj = this.fabricCanvas.getActiveObject().icObj;
          // const fObj  = this.fabricCanvas.getActiveObject();

          const infiniteCanvas = this.infiniteCanvas;
          infiniteCanvas.removeIcObject(icObj);
        }


        setAntiAliasEnabled(enabled) {
          console.log("setAntiAliasEnabled", enabled);
          this.fabricCanvas.imageSmoothingEnabled = enabled;
          this.fabricCanvas.requestRenderAll();
        }




        //Groups

        groupSelectedObjects() {

          //get selected objects
          const canvas = this.fabricCanvas;

          if (!canvas.getActiveObject()) {
            return;
          }
          if (canvas.getActiveObject().type !== 'activeSelection') {
            return;
          }

          const activeSelection = canvas.getActiveObject();
          console.log("activeSelection to create group", activeSelection);

          const fObj = canvas.getActiveObject().toGroup();
          console.log("fabric created group", fObj);

          // const fObj_childObjects = fObj.getObjects();
          // console.log("fObj_childObjects", fObj_childObjects);

          const icObj = infiniteCanvas.createIcGroup_from_groupFObj(fObj);
          fObj.icObj = icObj;

          //debug
          // const fRect = new fabric.Rect();
          // fRect.set({
          //   left:   fObj.left,
          //   top:    fObj.top,
          //   width:  fObj.width,
          //   height: fObj.height,
          //
          //   fill: 'red',
          // });
          // this.fabricCanvas.add(fRect);

          {
            const fRect = new fabric.Rect();

            const trueRect  = infiniteCanvas.toTrueRect(fObj);
            const position  = Geometry.getPointTL(trueRect);
            const size      = Geometry.createSize(trueRect.width, trueRect.height);

            const homeScale = Object.assign({}, infiniteCanvas.scale);

            const type = "rect";
            const icObj = infiniteCanvas.createIcObject(type, position, size, homeScale);

            const position_screen = icObj.getScreenPositionWithoutOffset();
            // console.log("position_screen", position_screen);
            const homeSize_screen = icObj.getHomeScreenSize();
            // console.log("homeSize_screen", homeSize_screen);

            fRect.set({
              left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
              top:    position_screen.y,

              width:  homeSize_screen.width,
              height: homeSize_screen.height,

              fill: 'red',
            });

            this.fabricCanvas.add(fRect);
          }



          //test pour le moment
          // this.fabricCanvas.remove(fObj);



          icObj.children.forEach((child_icObj, i) => {
            infiniteCanvas.removeIcObject(child_icObj);
          });
          infiniteCanvas.addIcObject(icObj);


          canvas.requestRenderAll();

        }

        ungroupSelectedObject() {

          const canvas = this.fabricCanvas;

          if (!canvas.getActiveObject()) {
            return;
          }
          if (canvas.getActiveObject().type !== 'group') {
            return;
          }
          canvas.getActiveObject().toActiveSelection();
          canvas.requestRenderAll();

        }





        syncWithIcObj(icObj) {
          const fObj = this.getFObjForIcObj(icObj);
          this.updateFObjWithIcObj(fObj, icObj);

          this.fabricCanvas.requestRenderAll();
          // this.fabricCanvas.renderAll();
        }

        getFObjForIcObj(icObj) {
          const fObj = this.fObjForIcObj_dict[icObj.id];

          if(!fObj) {
            console.log("icObj", icObj);
            console.log("this.fObjForIcObj_dict", this.fObjForIcObj_dict);
            throw new Error("fObj not found for icObj.id: "+ icObj.id);
          }

          return fObj;
        }

        updateFObjWithIcObj(fObj, icObj) {
          console.log("updateFObjWithIcObj", fObj, icObj);

          function configureWithIsActive(fObj, isActive) {

            const cfg = isActive ? fObj.icObj.activeCfg : fObj.icObj.inactiveCfg;

            fObj.set({
              fill:    cfg.fill,
              opacity: cfg.opacity,
            });

            fObj.set("dirty", true);
          }

          configureWithIsActive(fObj, icObj.isActive);

          // fObj.setCoords();
        }


      }


















/*******************/
/** utils  **/


      class Utils {

        static arrayByRemovingElement(src_arr, elt) {

          const index = src_arr.indexOf(elt);

          return this.arrayByRemovingElementAtIndex(src_arr, index);
        }

        static arrayByRemovingElementAtIndex(src_arr, index) {

          const arr = [...src_arr]; //create shallow copy of src_arr

          const arr_removed = arr.splice(index, 1);   //starting at index, remove 1 element
          const arr_new     = arr;                    //array is mutated in place

          return arr;
        }
      }

      class Geometry {

        static createPoint(x, y) {
          const point = {
            x : x,
            y : y,
          };
          return point;
        }

        static createRect(x,y,w,h) {
          const rect = {
            left: x,
            top: y,
            width: w,
            height: h,
          };
          return rect;
        }



        static createLine(point0, point1) {
          const line = {
            x0 : point0.x,
            y0 : point0.y,

            x1 : point1.x,
            y1 : point1.y,
          }
          return line;
        }

        static createTriangle() {
          const pointA = Geometry.createPoint(100,100);
          const pointB = Geometry.createPoint(0,300);
          const pointC = Geometry.createPoint(-100, -200);

          const lineAB = Geometry.createLine(pointA, pointB);
          const lineAC = Geometry.createLine(pointA, pointC);
          const lineBC = Geometry.createLine(pointB, pointC);

          const lines = [lineAB, lineAC, lineBC];
          return lines;
        }

        static createAxes() {
          const length = 10000;

          const pointX0 = Geometry.createPoint(     0,0);
          const pointX1 = Geometry.createPoint(length,0);
          const lineX   = Geometry.createLine(pointX0, pointX1);

          const pointY0 = Geometry.createPoint(0,0);
          const pointY1 = Geometry.createPoint(0,length);
          const lineY   = Geometry.createLine(pointY0, pointY1);

          const lines = [lineX, lineY];
          return lines;
        }



        static createSize(width, height) {
          const size = {
            width  : width,
            height : height,
          };
          return size;
        }






        static containedRect(containerRect, size) {
          var outRect;

          const containerSize = {
            width:  containerRect.width,
            height: containerRect.height,
          };
          const containedSize_ = Geometry.containedSize(containerSize, size);


          const center  = Geometry.getCenterPoint(containerRect);
          const offset  = {
            dx: - containedSize_.width /2,
            dy: - containedSize_.height /2,
          };
          const pointTL = Geometry.createPointWithOffset(center, offset);


          outRect = createRect(pointTL.x, pointTL.y, containedSize_.width, containedSize_.height);
          return outRect;
        }

        static getPointTL(rect) {
          const pointTL = Geometry.createPoint(rect.left, rect.top);
          return pointTL;
        }

        static getPointBR(rect) {
          const pointBR = Geometry.createPoint(rect.left + rect.width, rect.top + rect.height);
          return pointBR;
        }

        static getCenterPoint(rect) {
          const pointTL = Geometry.getPointTL(rect);
          const offset = {
            dx: rect.width /2,
            dy: rect.height /2,
          };
          return Geometry.createPointWithOffset(pointTL, offset);
        }

        static createPointWithOffset(point, offset) {
          return Geometry.createPoint(point.x + offset.dx, point.y + offset.dy);
        }

        static containedSize(containerSize, size) {
          var outSize;

          const size_ratio__container = containerSize.width / containerSize.height;
          const size_ratio__rect      = size.width / size.height;

          //console.log("size_ratio__container", size_ratio__container);
          //console.log("size_ratio__rect", size_ratio__rect);


          var scaleFactor;
          if(size_ratio__container > size_ratio__rect) {
            scaleFactor = containerSize.height / size.height;
          } else {
            scaleFactor = containerSize.width / size.width;
          }

          //console.log("scaleFactor", scaleFactor);


          outSize = {
            width:  size.width  * scaleFactor,
            height: size.height * scaleFactor,
          }

          return outSize;
        }



        static dotProduct_2d(v1,v2) {
        	return v1.x * v2.x + v1.y * v2.y;
        }

        static norm_2d(v1) {
          return Math.sqrt(Geometry.dotProduct_2d(v1,v1));
        }

        static vector_3d(v1, z = 0) {
          return {
            x: v1.x,
            y: v1.y,
            z: z,
          };
        }

        static dotProduct_3d(v1,v2) {
        	return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
        }

        static crossProduct_3d(v1,v2) {
        	return {
        		x: v1.y * v2.z - v1.z * v2.y,
        		y: v1.z * v2.x - v1.x * v2.z,
        		z: v1.x * v2.y - v1.y * v2.x,
        	};
        }

        static boundedAngleInDegrees(angleInDegrees) {

          var angleInDegrees_bounded = angleInDegrees;

          angleInDegrees_bounded = angleInDegrees_bounded % 360;
          if(angleInDegrees_bounded < 0) {
            angleInDegrees_bounded += 360;
          }

          return angleInDegrees_bounded;
        }

        static pointWithRotation(point_from, point_center, angleInDegrees) {
          console.log("pointWithRotation", point_from, point_center, angleInDegrees);

          const v = {
            x: point_from.x - point_center.x,
            y: point_from.y - point_center.y,
          };
          console.log("v.x", v.x);
          console.log("v.y", v.y);

          // const radius = Geometry.norm_2d(v);

          const angleInRadians = angleInDegrees / 180 * Math.PI;

          const dx = Math.cos(angleInRadians) * v.x - Math.sin(angleInRadians) * v.y;
          const dy = Math.sin(angleInRadians) * v.x + Math.cos(angleInRadians) * v.y;
          console.log("dx", dx);
          console.log("dy", dy);


          const point_to = {
            x: point_center.x + dx,
            y: point_center.y + dy,
          };


          return point_to;
        }

        static getPointFromRectToRect(point_from, rect_from, rect_to) {
          const point_to = {
            x: point_from.x * ( rect_to.width /  rect_from.width),
            y: point_from.y * (rect_to.height / rect_from.height),
          };

          return point_to;
        }


        static createLRTBRect(rect) {
          const lrtb = {
            left:    rect.left,
            right:   rect.left + rect.width,
            top:     rect.top,
            bottom:  rect.top + rect.height,
          };
          return lrtb;
        }

        static intersectRect(rect1, rect2) {

          const r1 = this.createLRTBRect(rect1);
          console.log("r1", r1);
          const r2 = this.createLRTBRect(rect2);
          console.log("r2", r2);

          return !(r2.left > r1.right ||
                   r2.right < r1.left ||
                   r2.top > r1.bottom ||
                   r2.bottom < r1.top);
         }


      }


      const SnapState = {
        "Unsnapped"  : "Unsnapped",
        "Presnapped" : "Presnapped",
        "Snapped"    : "Snapped",
      };

      class Snap { //GeometryWise snapping

        static canSnap(icObj_over, icObj_below) { //SHU: what would be nice would be to use the norm of a transformation matrix to settle threshold
          // const ratio__position        = {
          //   x:  (icObj_over.position.x - icObj_below.position.x) / icObj_below.position.x,
          //   y:  (icObj_over.position.y - icObj_below.position.y) / icObj_below.position.y,
          // };
          // console.log("ratio__position", ratio__position);
          // if(!(Math.abs(ratio__position.x) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__position.y) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__size        = {
          //   width:  (icObj_over.size.width  - icObj_below.size.width)  / icObj_below.size.width,
          //   height: (icObj_over.size.height - icObj_below.size.height) / icObj_below.size.height,
          // };
          // console.log("ratio__size", ratio__size);
          // if(!(Math.abs(ratio__size.width) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__size.height) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__orientation = (icObj_over.orientation - icObj_below.orientation) / icObj_below.orientation;
          // console.log("ratio__orientation", ratio__orientation);
          // if(!(Math.abs(ratio__orientation) < 0.10)) {
          //   return false;
          // }


          //snapping params:
          // const snapping_params = {
          //   // position: {
          //   //   x: 0.10,
          //   //   y: 0.10,
          //   // },
          //   position: {
          //     x: 0.05,
          //     y: 0.05,
          //   },
          //   size: {
          //     width:  0.05,
          //     height: 0.05,
          //   },
          //   homeScale: {
          //
          //   },
          //   orientation: {
          //     orientation: 0.05,
          //   },
          // };

          const snapping_params = {
            // position: {
            //   x: 0.10,
            //   y: 0.10,
            // },
            position: {
              x: 0.50,
              y: 0.50,
            },
            size: {
              width:  0.05,
              height: 0.05,
            },
            // homeScale: {
            //   X:  0.05,
            //   Y:  0.05,
            // },
            orientation: {
              orientation: 0.05,
            },
          };


          //SHU TODO: a nice and complex canSnapFunc
          const canSnapFunc = (icObj_over, icObj_below) => {

          };


          const unsamenessRatio__position = {
            x:  Snap.unsamenessRatio(icObj_over.position.x, icObj_below.position.x),
            y:  Snap.unsamenessRatio(icObj_over.position.y, icObj_below.position.y),
          };
          if(unsamenessRatio__position.x > snapping_params.position.x) {
            return false;
          }
          if(unsamenessRatio__position.y > snapping_params.position.y) {
            return false;
          }

          const unsamenessRatio__size = {
            width:  Snap.unsamenessRatio(icObj_over.size.width,  icObj_below.size.width),
            height: Snap.unsamenessRatio(icObj_over.size.height, icObj_below.size.height),
          };
          console.log("°°unsamenessRatio__size.width",  unsamenessRatio__size.width);
          console.log("°°icObj_over.size.width",  icObj_over.size.width);
          console.log("°°icObj_below.size.width",  icObj_below.size.width);

          console.log("°°unsamenessRatio__size.height", unsamenessRatio__size.height);
          console.log("°°icObj_over.size.height",  icObj_over.size.height);
          console.log("°°icObj_below.size.height",  icObj_below.size.height);

          if(unsamenessRatio__size.width > snapping_params.size.width) {
            return false;
          }
          if(unsamenessRatio__size.height > snapping_params.size.height) {
            return false;
          }

          const icObj_over__zero_centered_orientation  = (icObj_over.orientation > 180 ? icObj_over.orientation - 180 : icObj_over.orientation);
          const icObj_below__zero_centered_orientation = (icObj_below.orientation > 180 ? icObj_below.orientation - 180 : icObj_below.orientation);

          const unsamenessRatio__orientation = {
            // orientation: Snap.unsamenessRatio(icObj_over.orientation,  icObj_below.orientation),
            // orientation: Math.abs((icObj_over.orientation - icObj_below.orientation) / 360.0),
            orientation: Snap.unsamenessRatio(icObj_over__zero_centered_orientation,  icObj_below__zero_centered_orientation),
          };
          console.log("unsamenessRatio__orientation.orientation", unsamenessRatio__orientation.orientation);
          if(unsamenessRatio__orientation.orientation > snapping_params.orientation.orientation) {
            return false;
          }

          return true;
        }

        static canSnap_noSize(icObj_over, icObj_below) {

          const snapping_params = {
            // position: {
            //   x: 0.10,
            //   y: 0.10,
            // },
            position: {
              x: 0.50,
              y: 0.50,
            },
            // size: {
            //   width:  0.05,
            //   height: 0.05,
            // },
            // homeScale: {
            //   X:  0.05,
            //   Y:  0.05,
            // },
            orientation: {
              orientation: 0.05,
            },
          };


          //SHU TODO: a nice and complex canSnapFunc
          const canSnapFunc = (icObj_over, icObj_below) => {

          };


          const unsamenessRatio__position = {
            x:  Snap.unsamenessRatio(icObj_over.position.x, icObj_below.position.x),
            y:  Snap.unsamenessRatio(icObj_over.position.y, icObj_below.position.y),
          };
          if(unsamenessRatio__position.x > snapping_params.position.x) {
            return false;
          }
          if(unsamenessRatio__position.y > snapping_params.position.y) {
            return false;
          }

          // const unsamenessRatio__size = {
          //   width:  Snap.unsamenessRatio(icObj_over.size.width,  icObj_below.size.width),
          //   height: Snap.unsamenessRatio(icObj_over.size.height, icObj_below.size.height),
          // };
          // console.log("°°unsamenessRatio__size.width",  unsamenessRatio__size.width);
          // console.log("°°icObj_over.size.width",  icObj_over.size.width);
          // console.log("°°icObj_below.size.width",  icObj_below.size.width);
          //
          // console.log("°°unsamenessRatio__size.height", unsamenessRatio__size.height);
          // console.log("°°icObj_over.size.height",  icObj_over.size.height);
          // console.log("°°icObj_below.size.height",  icObj_below.size.height);
          //
          // if(unsamenessRatio__size.width > snapping_params.size.width) {
          //   return false;
          // }
          // if(unsamenessRatio__size.height > snapping_params.size.height) {
          //   return false;
          // }

          const icObj_over__zero_centered_orientation  = (icObj_over.orientation > 180 ? icObj_over.orientation - 180 : icObj_over.orientation);
          const icObj_below__zero_centered_orientation = (icObj_below.orientation > 180 ? icObj_below.orientation - 180 : icObj_below.orientation);

          const unsamenessRatio__orientation = {
            // orientation: Snap.unsamenessRatio(icObj_over.orientation,  icObj_below.orientation),
            // orientation: Math.abs((icObj_over.orientation - icObj_below.orientation) / 360.0),
            orientation: Snap.unsamenessRatio(icObj_over__zero_centered_orientation,  icObj_below__zero_centered_orientation),
          };
          console.log("unsamenessRatio__orientation.orientation", unsamenessRatio__orientation.orientation);
          if(unsamenessRatio__orientation.orientation > snapping_params.orientation.orientation) {
            return false;
          }

          return true;
        }


        static canUnsnap(icObj_over, icObj_below) {
          return !this.canSnap(icObj_over, icObj_below);
        }

        /*
        static canUnsnap(icObj_over, icObj_below) { //SHU: what would be nice would be to use the norm of a transformation matrix to settle threshold
          // const ratio__position        = {
          //   x:  (icObj_over.position.x - icObj_below.position.x) / icObj_below.position.x,
          //   y:  (icObj_over.position.y - icObj_below.position.y) / icObj_below.position.y,
          // };
          // console.log("ratio__position", ratio__position);
          // if(!(Math.abs(ratio__position.x) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__position.y) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__size        = {
          //   width:  (icObj_over.size.width  - icObj_below.size.width)  / icObj_below.size.width,
          //   height: (icObj_over.size.height - icObj_below.size.height) / icObj_below.size.height,
          // };
          // console.log("ratio__size", ratio__size);
          // if(!(Math.abs(ratio__size.width) < 0.10)) {
          //   return false;
          // }
          // if(!(Math.abs(ratio__size.height) < 0.10)) {
          //   return false;
          // }
          //
          // const ratio__orientation = (icObj_over.orientation - icObj_below.orientation) / icObj_below.orientation;
          // console.log("ratio__orientation", ratio__orientation);
          // if(!(Math.abs(ratio__orientation) < 0.10)) {
          //   return false;
          // }


          //snapping params:
          const unsnapping_params = {
            // position: {
            //   x: 0.10,
            //   y: 0.10,
            // },
            position: {
              x: 0.10,
              y: 0.10,
            },
            size: {
              width:  0.10,
              height: 0.10,
            },
            orientation: {
              orientation: 0.10,
            },
          };

          // //SHU TODO: a nice and complex canUnsnapFunc
          // const canUnsnapFunc = (icObj_over, icObj_below) => {
          //
          // };


          const unsamenessRatio__position = {
            x:  Snap.unsamenessRatio(icObj_over.position.x, icObj_below.position.x),
            y:  Snap.unsamenessRatio(icObj_over.position.y, icObj_below.position.y),
          };
          if(unsamenessRatio__position.x < unsnapping_params.position.x) {
            return false;
          }
          if(unsamenessRatio__position.y < unsnapping_params.position.y) {
            return false;
          }

          const unsamenessRatio__size = {
            width:  Snap.unsamenessRatio(icObj_over.size.width,  icObj_below.size.width),
            height: Snap.unsamenessRatio(icObj_over.size.height, icObj_below.size.height),
          };
          if(unsamenessRatio__size.width < unsnapping_params.size.width) {
            return false;
          }
          if(unsamenessRatio__size.height < unsnapping_params.size.height) {
            return false;
          }

          const unsamenessRatio__orientation = {
            orientation: Snap.unsamenessRatio(icObj_over.orientation,  icObj_below.orientation),
          };
          if(unsamenessRatio__orientation.orientation < unsnapping_params.orientation.orientation) {
            return false;
          }

          return true;
        }
        */



        static unsamenessRatio(nb1, nb2) {
          var outNumber;
          outNumber = (nb1 - nb2);
          // if(outNumber != 0) {
          if(nb2 != 0) {
            outNumber = outNumber / nb2;
          }
          outNumber = Math.abs(outNumber);
          return outNumber;
        }

        static snapAnimation(icObj_over, icObj2_below) {

        }



        static defaultSnapEngine(infiniteCanvas, icSnapSlot) {
          var outSnapEngine;

          const canSnapFunc = (above, below) => {
            return Snap.canSnap(above, below);
          };

          const canUnsnapFunc = (above, below) => {
            return Snap.canUnsnap(above, below);
          };

          // const snapEngine = {
          //   canSnapFunc:   canSnapFunc,
          //   canUnsnapFunc: canUnsnapFunc,
          // };
          //
          // outSnapEngine = snapEngine;

          const snapEngine = SnapEngine.defaultInstance(infiniteCanvas, icSnapSlot);

          Hooker.installHooks(snapEngine, "presnap");
          // snapEngine.will["presnap"].on((...args) => {
          //   console.log("will presnap", ...args);
          // });
          // snapEngine.did["presnap"].on((...args) => {
          //   console.log("did presnap", ...args);
          // });
          Hooker.installHooks(snapEngine, "snap");
          Hooker.installHooks(snapEngine, "unsnap");



          snapEngine.canSnapFunc   = canSnapFunc;
          snapEngine.canUnsnapFunc = canUnsnapFunc;

          outSnapEngine = snapEngine;

          return outSnapEngine;
        }

      }

      class SnapEngine {

        constructor() {

        }

        start() {

        }

        stop() {

        }

        static defaultInstance(infiniteCanvas, icSnapSlot) {
          var outEngine;

          const snapEngine = new SnapEngine();

          const attemptSnapping = function(icObj_slot, icObj_piece) {
            console.log("attemptSnapping", icObj_slot, icObj_piece);

            const canSnap = snapEngine.checkCanSnap(icObj_slot, icObj_piece);

            const rep_official = icObj_piece;
            console.log("attempting to snap with snapState: " + rep_official.snapState);

            // const isValidPieceSnapState = (rep_official.snapState == SnapState.Unsnapped);
            //
            // if(isValidPieceSnapState) {
            //
            // } else {
            //   console.log("can't snap while snapState == " + rep_official.snapState)
            //   // throw new Error("attempting to snap with snapState: " + rep_official.snapState);
            //   return;
            // }

            if(canSnap) {
              console.log("can snap");

              const rep_official = icObj_piece;
              const represented  = icObj_piece.represented;
              const rep_free     = represented.getRepresentation("free");

              console.log("rep_free.isHeld", rep_free.isHeld);
              if(rep_free.isHeld) {
                snapEngine.presnap(icObj_slot, icObj_piece);
              } else {
                snapEngine.presnap(icObj_slot, icObj_piece);
                snapEngine.snap(icObj_slot, icObj_piece);
              }

            } else {
              console.log("can't snap");
            }

          };
          snapEngine.attemptSnapping = attemptSnapping;

          const checkCanSnap = function(icObj_slot, icObj_piece) {
            console.log("checkCanSnap", icObj_piece);
            var outBool;

            // outBool = Snap.canSnap(icObj_piece, icObj_slot);
            outBool = snapEngine.canSnapFunc(icObj_piece, icObj_slot);

            return outBool;
          };

          var rep_free_onRelease__triggerSnap          = null;
          var rep_free_afterPresnap__attemptUnsnapping = null;

          var rep_free_callbacks = {
            onRelease__triggerSnap:          null,
            afterPresnap__attemptUnsnapping: null,
          };
          snapEngine.checkCanSnap = checkCanSnap;

          const presnap = function(icObj_slot, icObj_piece) {
            console.log("presnap", icObj_piece);

            const rep_official = icObj_piece;
            const represented  = icObj_piece.represented;
            const rep_free     = represented.getRepresentation("free");
            const rep_snapped  = represented.createNewRepresentationWithName("snapped");

            rep_official.snapState = SnapState.Presnapped;
            // rep_official.snappedTo = icObj_slot;
            rep_official.snappedTo = icObj_slot.id;


            rep_official.unfollow(rep_free);


            rep_snapped.position     = Object.assign({}, icObj_slot.position);
            rep_snapped.homeScale    = Object.assign({}, icObj_slot.homeScale);
            rep_snapped.scale        = Object.assign({}, icObj_slot.scale);
            rep_snapped.orientation  = icObj_slot.orientation;

            infiniteCanvas.addRepresentation(represented, rep_snapped);


            // rep_official.syncWith(rep_snapped);
            rep_official.syncWithObj({
              position:   rep_snapped.position,
              size:       rep_snapped.size,
              homeScale:  rep_snapped.homeScale,
              scale:      rep_snapped.scale,

              // didUpdateListeners : rep_snapped.didUpdateListeners,
              // holdListeners      : rep_snapped.holdListeners,
              // releaseListeners   : rep_snapped.releaseListeners,
            });
            rep_official.follow(rep_snapped);


            rep_free.opacity = 0.0;
              //debug
            rep_free.opacity = 1.0;
            rep_free.fill = "blue";

            //add release listener
            // icObj_fRep.onHold((icObj) => {
            //
            // });

            //add release listener for rep_free
            rep_free_onRelease__triggerSnap = (rep_free) => {
              console.log("rep_free_onRelease__triggerSnap");

              snapEngine.snap(icObj_slot, icObj_piece);
            };
            rep_free.onRelease(rep_free_onRelease__triggerSnap);


            //add unsnap listener for rep_free
            rep_free_afterPresnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
              console.log("rep_free_afterPresnap__attemptUnsnapping", rep_free);

              snapEngine.attemptUnsnapping(icObj_slot, rep_free);
            };
            rep_free.onInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);

          };
          snapEngine.presnap = presnap;


          const snap = function(icObj_slot, icObj_piece) {
            console.log("snap", icObj_piece);

            const rep_official = icObj_piece;
            const represented  = icObj_piece.represented;
            const rep_free     = represented.getRepresentation("free");
            const rep_snapped  = represented.getRepresentation("snapped");

            console.log("**snap", "rep_free.isHeld", rep_free.isHeld);

            console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
            if(rep_free_afterPresnap__attemptUnsnapping != null) {
              rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
            }
            rep_free_afterPresnap__attemptUnsnapping = null;


            rep_free.offRelease(rep_free_onRelease__triggerSnap);
            rep_free_onRelease__triggerSnap = null;



            // rep_free.syncWith(rep_snapped);
            // rep_free.syncWith(rep_official);

            //SHU TODO: MYSTERE ET BOULE DE GOMME: il y a un truc avec syncWith qui casse rep_free ... ???

            rep_free.syncWithObj({
              position:   rep_snapped.position,
              size:       rep_snapped.size,
              homeScale:  rep_snapped.homeScale,
              scale:      rep_snapped.scale,

              // didUpdateListeners : rep_snapped.didUpdateListeners,
              // holdListeners      : rep_snapped.holdListeners,
              // releaseListeners   : rep_snapped.releaseListeners,
            });



            rep_free.opacity = 1.0;
              //debug
            rep_free.opacity = 1.0;
            rep_free.fill = "red";

            rep_official.unfollow(rep_snapped);
            rep_official.follow(rep_free);
            rep_official.snapState = SnapState.Snapped;
            // rep_official.snappedTo = icObj_slot;
            // rep_official.snappedTo = icObj_slot.id;



            console.log("remove rep_snapped", rep_snapped.id_rep);
            rep_snapped.im_dead_now = true;
            infiniteCanvas.removeRepresentation(represented, rep_snapped);
            represented.removeRepresentation(rep_snapped);

            //add unsnap listener for rep_free
            // rep_free_afterSnap__attemptUnsnapping = (rep_free, propName, oldValue, newValue) => {
            //   console.log("rep_free_afterSnap__attemptUnsnapping", rep_free);
            //
            //   attemptUnsnapping(icObj_slot, rep_free);
            // };
            // rep_free.onInnerUpdate(rep_free_afterSnap__attemptUnsnapping);


              //debug
            // rep_free.onHold((rep_free) => {
            //   console.log("###rep_free.id_rep", rep_free.id_rep);
            //   console.log("###rep_free.onHold", "rep_free.isHeld", rep_free.isHeld);
            // });

          };
          snapEngine.snap = snap;





          const attemptUnsnapping = function(icObj_slot, icObj_piece) {
            console.log("attemptUnsnapping", icObj_slot, icObj_piece);

            const canUnsnap = snapEngine.checkCanUnsnap(icObj_slot, icObj_piece);
            console.log("canUnsnap", canUnsnap);

            const rep_official = icObj_piece;
            console.log("attempting to unsnap with snapState: " + rep_official.snapState);

            // const isValidPieceSnapState = (rep_official.snapState == SnapState.Presnapped);
            //
            // if(isValidPieceSnapState) {
            //
            // } else {
            //   console.log("can't unsnap while snapState == " + rep_official.snapState)
            //   // throw new Error("attempting to unsnap with snapState: " + rep_official.snapState);
            //   return;
            // }

            if(canUnsnap) {
              // console.log("can unsnap");
              snapEngine.unsnap(icObj_slot, icObj_piece);     //presnap already sets up an unsnap listener

            } else {
              // console.log("can't unsnap");

              //SHU TODO: hasLeftSlot
              // const hasLeftSlot = Snap.hasLeftSlot()
              const hasLeftSlot = true;

              if(hasLeftSlot) {


                // const rep_official = icObj_piece;
                const represented  = icObj_piece.represented;
                const rep_free     = represented.getRepresentation("free");

                console.log("#rep_free.id_rep", rep_free.id_rep);
                console.log("#rep_free.isHeld", rep_free.isHeld);

                if(rep_free.isHeld) {
                  if(icObj_piece.snapState == SnapState.Snapped) {
                    snapEngine.presnap(icObj_slot, icObj_piece);
                  }
                } else {
                  //do nothing
                  // snap(icObj_slot, icObj_piece);
                }

              } else {
                //do nothing
                // snap(icObj_slot, icObj_piece);
              }



            }

          };
          snapEngine.attemptUnsnapping = attemptUnsnapping;

          const checkCanUnsnap = function(icObj_slot, icObj_piece) {
            console.log("checkCanUnsnap", icObj_piece);
            var outBool;

            // outBool = Snap.canUnsnap(icObj_piece, icObj_slot);
            outBool = snapEngine.canUnsnapFunc(icObj_piece, icObj_slot);

            return outBool;
          };
          snapEngine.checkCanUnsnap = checkCanSnap;


          const unsnap = function(icObj_slot, icObj_piece) {
            console.log("unsnap", icObj_piece);

            // const represented  = icObj_piece.represented;
            // const rep_official = represented.getRepresentation("official");
            // const rep_snapped  = represented.getRepresentation("snapped");

            const rep_unknown  = icObj_piece; //SHU TODO: solve snapSlot's rep madness
            const represented  = icObj_piece.represented;
            const rep_official = represented.getRepresentation("official");
            const rep_free     = represented.getRepresentation("free");
            const rep_snapped  = represented.getRepresentation("snapped");


            console.log("rep_free_afterPresnap__attemptUnsnapping != null", (rep_free_afterPresnap__attemptUnsnapping != null));
            if(rep_free_afterPresnap__attemptUnsnapping != null) {
              rep_free.offInnerUpdate(rep_free_afterPresnap__attemptUnsnapping);
            }
            rep_free_afterPresnap__attemptUnsnapping = null;

            // if(rep_free_afterSnap__attemptUnsnapping != null) {
            //   rep_free.offInnerUpdate(rep_free_afterSnap__attemptUnsnapping);
            // }
            // rep_free_afterSnap__attemptUnsnapping = null;


            // rep_free.offRelease(rep_free_onRelease__triggerSnap);
            // rep_free_onRelease__triggerSnap = null;

            if(rep_free.offRelease != null) { //****************************************  SHU: il y a un problème ici, quand j'aurai trois neurones de disponibles, j'investiguerai
              rep_free.offRelease(rep_free_onRelease__triggerSnap);
              rep_free_onRelease__triggerSnap = null;
            }                                 //****************************************


            rep_official.syncWith(rep_free);
            rep_official.follow(rep_free);


            if(rep_snapped != null) {
              console.log("remove rep_snapped", rep_snapped.id_rep);
              rep_snapped.im_dead_now = true;
              infiniteCanvas.removeRepresentation(represented, rep_snapped);
              represented.removeRepresentation(rep_snapped);
            } else {
              console.log("rep_snapped already destroyed somewhere else");
            }


            // rep_free.im_dead_now = true; //SHU: this is interesting

            rep_free.opacity = 1.0;
              //debug
            rep_free.fill = "lime";

            rep_official.snapState = SnapState.Unsnapped;
            // rep_official.snappedTo = null;
            rep_official.snappedTo = -1;

          };
          snapEngine.unsnap = unsnap;






          const r_official_update_handler = (icObj_slot, icObj_piece, outerUpdatesDict) => {
            console.log("r_official_update_handler", icObj_piece);

            console.log("icObj_piece.snapState", icObj_piece.snapState);

            // if(outerUpdatesDict["snapState"] == SnapState.Snapped) {
            //   //official just changed snapState to .Snapped
            //   //ignore
            //   return;
            // }

            if(icObj_piece.snapState == SnapState.Unsnapped) {
              snapEngine.attemptSnapping(icObj_slot, icObj_piece);
            } else if(icObj_piece.snapState == SnapState.Snapped) {
              snapEngine.attemptUnsnapping(icObj_slot, icObj_piece);               //SHU666666 : this is the key line to understand what is wrong
            } else if(icObj_piece.snapState == SnapState.Presnapped) {

            }

          };
          snapEngine.r_official_update_handler = r_official_update_handler;

          const r_official_update_handler2 = (rep_official_incoming, outerUpdatesDict) => {
            console.log("r_official_update_handler2", rep_official_incoming);

            const represented  = infiniteCanvas.getRepresented(icSnapSlot.id);
            console.log("represented", represented);
            const rep_official = represented.r_official();

            const snapSlot    = rep_official;
            const incomingObj = rep_official_incoming;

            if(incomingObj != snapSlot) { //don't snap oneself

              if(!incomingObj.isSnappable) {
                //ignore: incomingObj is diamagnetic
              } else {
                console.log("++++incomingObj.snappedTo", incomingObj.snappedTo);
                // if(incomingObj.snappedTo != null && incomingObj.snappedTo != snapSlot) {
                if(incomingObj.snappedTo != -1 && incomingObj.snappedTo != snapSlot.id) {
                  //ignore: incomingObj is already snapped to another slot
                } else {
                  snapEngine.r_official_update_handler(snapSlot, incomingObj, outerUpdatesDict);
                }
              }

            } else {
              console.log("I won't snap myself");
            }

          };
          snapEngine.r_official_update_handler2 = r_official_update_handler2;

          outEngine = snapEngine;

          return outEngine;
        }

      }



      const TouchState = {
        "Untouched"  : "Untouched",
        "Touched"    : "Touched",
      };

      class Touch { //GeometryWise touching

        static canTouch(icObj_over, icObj_below) {

          //flemme: use fabric fObj.intersectsWithObject(fObj2)
          // const over__represented  = infiniteCanvas.getRepresented(icObj_over.id);
          // const over__rep_free     = over__represented.r_free();
          // const over__fObj         = over__rep_free.fObj;                            //<-- this is not available
          //
          // const below__represented  = infiniteCanvas.getRepresented(icObj_below.id);
          // const below__rep_free     = below__represented.r_free();
          // const below__fObj         = below__rep_free.fObj;                          //<-- this is not available
          //
          // const isIntersecting = over__fObj.intersectsWithObject(below__fObj);

          const rect__over  = icObj_over.getRect();
          const rect__below = icObj_below.getRect();

          console.log("rect__over", rect__over);
          console.log("rect__below", rect__below);

          const isIntersecting = Geometry.intersectRect(rect__over, rect__below);
          console.log("isIntersecting", isIntersecting);

          return isIntersecting;
        }

        static canUntouch(icObj_over, icObj_below) {
          return !this.canTouch(icObj_over, icObj_below);
        }

      }











//I/O

      class FileIntegration {

        constructor(clipboardIntegration) {
          this.clipboardIntegration = clipboardIntegration;

          document.onpaste = function(event) {
            console.log("onpaste", "event", event);
            clipboardIntegration.rx_outerPaste.next(event);
          };

        }

        static openFileDialog (accept, callback) {

            // Create an input element
            var inputElement = document.createElement("input");

            // Set its type to file
            inputElement.type = "file";

            // Set accept to the file types you want the user to select.
            // Include both the file extension and the mime type
            inputElement.accept = accept;

            // set onchange event to call callback when user has selected file
            inputElement.addEventListener("change", callback)

            // dispatch a click event to open the file dialog
            inputElement.dispatchEvent(new MouseEvent("click"));

        }

        static openFile_p(accept) {

          return new Promise((resolve, reject) => {

            FileIntegration.openFileDialog(accept, event => {
              const fileList = event.target.files;
              ////console.log("fileList:", fileList);

              const file = fileList[0];
              //console.log("file", file);

              resolve(file);
            });
          });

        }




        // static addImageFromFile_p(file) {
        //
        //   function addZimageForImg(img) {
        //     //console.log("img", img);
        //
        //     // const zimage = createZimageWithCurrentBoundingRect(img);
        //
        //     const canvasBoundingTrueRect = getCanvasBoundingTrueRect();
        //
        //     // object-fit : contain
        //     const img_size = {
        //       width: img.width,
        //       height: img.height
        //     };
        //     const trueRect = containedRect(canvasBoundingTrueRect, img_size);
        //
        //     const zimage = createZimage(img, trueRect);
        //
        //     addZimage(zimage);
        //
        //     redrawCanvas();
        //   }
        //
        //   function addFabricImageForImg(img) {
        //     //console.log("img", img);
        //
        //     // const zimage = createZimageWithCurrentBoundingRect(img);
        //
        //     const canvasBoundingTrueRect = getCanvasBoundingTrueRect();
        //
        //     // object-fit : contain
        //     const img_size = {
        //       width: img.width,
        //       height: img.height
        //     };
        //     const trueRect = containedRect(canvasBoundingTrueRect, img_size);
        //
        //     const fabricImage = createFabricImage(img, trueRect);
        //     addFabricObject(fabricImage);
        //
        //     redrawCanvas();
        //   }
        //
        //   return createImage_p(file)
        //         .then(img => {
        //           // addZimageForImg(img);
        //           addFabricImageForImg(img);
        //         });
        //
        // }



        //IMPORT image

        static importImage_p() {
          const accept = ".jpg, .jpeg, .png";
          return FileIntegration.openFile_p(accept)
                .then(FileIntegration.createImage_p);
        }


        static createImage_p(file) {
          return FileIntegration.getFileData_p(file)
                .then(FileIntegration.dataToImgSrc_p)
                .then(FileIntegration.imageFromImgSrc_p);
        }

        static imageFromImgSrc_p(imgSrc) {
          //console.log('imgSrc', imgSrc);
          // return new Promise(r => img.onload=r, img.src=imgSrc)
          return new Promise((resolve, reject) => {
            const img   = new Image();
            img.onload  =      () => resolve(img);
            img.onerror = (error) => reject(error);

            img.src = imgSrc;
          });
        }

        static dataToImgSrc_p(data) {
          var imgSrc_p;

          if(data.startsWith("data:image")) {
            imgSrc_p = Promise.resolve(data);
          } else {
            imgSrc_p = FileIntegration.dataToBlob_p(data)
                  .then(blob1 => {
                    //change blob type
                    const blob2 = new Blob([blob1], {type: 'image/png'})
                    return blob2;
                  })
                  .then(FileIntegration.getFileData_p);
                  // .then(blob2 => {
                  //   const imgSrc = URL.createObjectURL(blob2);
                  //   ////console.log("converted imgSrc:", imgSrc);
                  //   //>>converted imgSrc: blob:http://localhost:8080/7243f1de-493f-412b-b1ec-b042b0cbcac4
                  //   return imgSrc;
                  // });
          }

          return imgSrc_p;
        }

        static dataToBlob_p(data) {
          return fetch(data)
                 .then(res => res.blob());
        }

        static imageContentsToBlob_p(img) {
          return this.dataToBlob_p(img.src);
        }


        //file utils

        static getFileData_p(file) {
          ////console.log("getFileData_p", file);

          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function(evt) {
               const file_url = evt.target.result; //<=> var file_url = reader.result;
               ////console.log("file_url:", file_url);
               resolve(file_url);
            };
            reader.readAsDataURL(file);
          });

        }

        static getFileText_p(file) {
          ////console.log("getFileText_p", file);

          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function(evt) {
               const file_url = evt.target.result; //<=> var file_url = reader.result;
               ////console.log("file_url:", file_url);
               resolve(file_url);
            };
            reader.readAsText(file);
          });

        }


        // static getFileImage_p(filename) {
        //   const file_url = "/img/" + filename;
        //   return fetch(file_url)
        //         .then(FileIntegration.createImage_p);
        // }







        //PASTE image


        static getPastedFile_p(event) {
          var outPromise;

          var items = (event.clipboardData || event.originalEvent.clipboardData).items;
          //console.log(JSON.stringify(items)); // will give you the mime types

          const arr_files = Object.values(items)
                                .filter(item => item.kind == 'file')
                                .map(item => item.getAsFile());

          if(arr_files.length == 1) {
            const file = arr_files.find(e => true);
            outPromise = Promise.resolve(file);
          } else {
            const error = new Error("arr_files.length != 1");
            outPromise = Promise.reject(error);
          }

          return outPromise;
        }





        //SAVE / LOAD

        static save_to_file(obj) {

          const json = JSON.stringify(obj);

          const filename = "infinishute.json";
          FileIntegration.download(json, filename, 'text/json');
        }

        static download(content, fileName, contentType) {
          var a = document.createElement("a");
          var file = new Blob([content], {type: contentType});
          a.href = URL.createObjectURL(file);
          a.download = fileName;
          a.click();
        }


        // static objByConvertingImagesToBase64_p(obj) {
        //
        //   const zimages_raw = obj.zimages;
        //
        //   const arr__zimages_serial_p = zimages_raw.map(zimage => {
        //
        //     //console.log("zimage", zimage);
        //     const imgSrc_base64_p = FileIntegration.dataUrlForImgViaCanvas_p(zimage.img);
        //
        //     return imgSrc_base64_p
        //            .then(imgSrc_base64 => {
        //
        //              const zimage_serial = {
        //                imgSrc_base64:  imgSrc_base64,
        //                trueRect:       zimage.trueRect,
        //              };
        //
        //              return zimage_serial;
        //            });
        //
        //   });
        //
        //   return Promise.all(arr__zimages_serial_p)
        //          .then(arr__zimages_serial => {
        //
        //            const obj2 = {};
        //
        //            obj2.zimages  = arr__zimages_serial;
        //            obj2.drawings = obj.drawings;
        //
        //            return obj2;
        //          });
        // }

        static objByConvertingImagesToBase64_p(obj) {

          const zimages_raw = obj.zimages;

          const arr__zimages_serial_p = zimages_raw.map(zimage => {

            //console.log("zimage", zimage);
            const imgSrc_base64_p = FileIntegration.dataUrlForImgViaCanvas_p(zimage.img);

            return imgSrc_base64_p
                   .then(imgSrc_base64 => {

                     const zimage_serial = {
                       imgSrc_base64:  imgSrc_base64,
                       trueRect:       zimage.trueRect,
                     };

                     return zimage_serial;
                   });

          });

          return Promise.all(arr__zimages_serial_p)
                 .then(arr__zimages_serial => {

                   const obj2 = {};

                   obj2.zimages  = arr__zimages_serial;
                   obj2.drawings = obj.drawings;

                   return obj2;
                 });
        }



        static saveInfinishute_p(infiniShute) {

          // const obj = {
          //   // zimages  : zimages,
          //   // drawings : drawings,
          //
          //   infiniteCanvas: infiniteCanvas,
          // };
          // //console.log("obj", obj);
          //
          // FileIntegration.objByConvertingImagesToBase64_p(obj)
          // .then(obj2 => {
          //   //console.log("obj2", obj2);
          //   FileIntegration.save_to_file(obj2);
          // });

          FileIntegration.save_to_file(infiniShute);

          //?
          return Promise.resolve(true);
        }

        static loadInfinishute_p() {
          const accept = ".json";
          return FileIntegration.openFile_p(accept)
                .then(FileIntegration.createJson_p)
                // .then(FileIntegration.createInfinishute_p);
                // .then(infinishute => {
                //   configureWithInfinishute(infinishute);
                // });
        }

        static createJson_p(file) {
          return FileIntegration.getFileText_p(file)
                .then(text => {
                  //console.log("text:", text);

                  const json = JSON.parse(text);
                  //console.log("json:", json);
                  return json;
                });

        }

        // static createInfinishute_p(json) {
        //   const infinishute = {};
        //
        //   infinishute.drawings = json.drawings;
        //
        //   const zimages_serial = json.zimages;
        //   const arr__zimage_p = zimages_serial.map(zimage_serial => {
        //
        //     const imgSrc = zimage_serial.imgSrc_base64;
        //     return FileIntegration.imageFromImgSrc_p(imgSrc)
        //            .then(image => {
        //              const zimage = {
        //                img: image,
        //                trueRect: zimage_serial.trueRect,
        //              };
        //
        //              return zimage;
        //            });
        //   })
        //
        //   return Promise.all(arr__zimage_p)
        //                 .then(zimages => {
        //                   infinishute.zimages = zimages;
        //
        //                   return infinishute;
        //                 });
        //
        // }

        // static createInfinishute_p(json) {
        //   const infinishute = {};
        //
        //   return json;
        // }


        static dataUrlForImgViaCanvas_p(img) {

          const src = img.src;

          const outputFormat = "image/png";

          return new Promise((resolve, reject) => {
            var imgAux = new Image();

            imgAux.crossOrigin = 'Anonymous';
            imgAux.onload = function() {
              var canvasAux = document.createElement('CANVAS');
              var ctxAux    = canvasAux.getContext('2d');
              var dataURL;
              canvasAux.height = this.naturalHeight;
              canvasAux.width  = this.naturalWidth;
              ctxAux.drawImage(this, 0, 0);
              dataURL = canvasAux.toDataURL(outputFormat);
              resolve(dataURL);
            };
            imgAux.onerror = (error) => reject(error);

            imgAux.src = src;
          });

        }

      }




      //Clipboard mgmt

      class ClipboardObject {
        constructor(source, content) {
          this.source  = source;
          this.content = content;
        }
      }

      class InnerCopyEvent {
        constructor(clipboardObject) {
          this.timestamp       = Date.now();
          this.clipboardObject = clipboardObject;
        }
      }

      class ClipboardIntegration {

        constructor(arr_sources) {
          // this.arr_sources = arr_sources;
          const rx_innerCopy = new Subject();
          this.rx_innerCopy  = rx_innerCopy;

          // this.arr_paste_p = arr_sources.map(source => source.paste_p);
          const rx_outerPaste = new Subject();
          this.rx_outerPaste  = rx_outerPaste;

          const clipboardIntegration = this;
          // const rx_mixedPaste = Rx.combineLatest(rx_outerPaste, rx_innerCopy)
          const rx_mixedPaste = rx_outerPaste.pipe(Rx_operators.withLatestFrom(rx_innerCopy))
            .pipe(Rx_operators.map(([clipboardEvent, innerCopyEvent]) => {
              var outVal;

              console.log("rx_mixedPaste");
              console.log("clipboardEvent", clipboardEvent);
              console.log("innerCopyEvent", innerCopyEvent);

              const timestamp_outer = clipboardEvent.timeStamp;
              const timestamp_inner = Date.now() - innerCopyEvent.timestamp;
              console.log("timestamp_outer", timestamp_outer);
              console.log("timestamp_inner", timestamp_inner);

              if(timestamp_inner < timestamp_outer) {
                const icObj = innerCopyEvent.clipboardObject.content;

                //clone newly created, shift it, and copy it {
                const cloned = icObj.deepClone();

                cloned.position.x += 10;
                cloned.position.y += 10;

                clipboardIntegration.manageInnerCopy("fabric.general", cloned);
                //}

                outVal = icObj;

              } else {
                outVal = clipboardIntegration.outerToInner(clipboardEvent);
              }

              return outVal;
            }));

          this.rx_mixedPaste = rx_mixedPaste;
        }

        manageInnerCopy(source, content) {

          const cbObj = new ClipboardObject(source, content);

          const innerCopyEvent = new InnerCopyEvent(cbObj);
          this.rx_innerCopy.next(innerCopyEvent);




          //copy to navigator clipboard
          const icObj = content;

          const outerWrapper = outerWrapperForIcObj(icObj);
          if(outerWrapper != null) {

            writeToClipboard_p(outerWrapper)
            .then(success => {
              console.log("writeToClipboard_p, success");
            })
            .catch(err => {
              console.log("writeToClipboard_p, error:" + err);
            });


          }

          function outerWrapperForIcObj(icObj) {
            var out;

            switch(icObj.type) {
              case "image":
                const outerWrapper_image = {
                  type:   "image",
                  content: icObj.img,
                };
                out = outerWrapper_image;
                break;
              case "text":
                const outerWrapper_text = {
                  type:   "text",
                  content: icObj.text,
                };
                out = outerWrapper_text;
                break;
              default:
                out = null;
                break;
            }

            return out;
          }

          function writeToClipboard_p(outerWrapper) {
            var out_p;

            switch(outerWrapper.type) {
              case "text":
                const text = outerWrapper.content;
                out_p = writeToClipboard_text_p(text);
                break;
              case "image":
                const img = outerWrapper.content;
                //const imgSrc_p = FileIntegration.dataUrlForImgViaCanvas_p(img);
                // out_p = img_serial_p
                //         .then(imgSrc => {
                //           return writeToClipboard_image_p(imgSrc);
                //         });
                out_p = writeToClipboard_image_p(img);
                break;
              // case "mixed":
              //   writeToClipboard_mixed(outerWrapper.content);
              //   break;
              default:
                throw new Error("outerWrapper, unsupported type: " + outerWrapper.type);
            }

            return out_p;
          }

          function writeToClipboard_text_p(text) {
            return navigator.clipboard.writeText(text)
            .then(success => {
              console.log("navigator.clipboard.writeText, success");
            })
            .catch(err => {
              console.log("navigator.clipboard.writeText, error:" + err);
            });
          }

          function writeToClipboard_image_p(img) {
            console.log("writeToClipboard_image", img);

            // const image = await fetch('ceiling-cat.jpg');
            // const blob_image = new Blob([imgSrc], { type: 'image/png' });
            const blob_image_p = FileIntegration.imageContentsToBlob_p(img);

            // const blob_text = new Blob(['Cute sleeping kitten'], {type: 'text/plain'});

            const item_p = blob_image_p.then(blob_image => {
              const item = new ClipboardItem({
                // 'text/plain': blob_text,

                'image/png': blob_image,
              });

              return item;
            });

            return item_p
                  .then(item => {
                    navigator.clipboard.write([item])
                  })
                  .then(success => {
                    console.log("navigator.clipboard.write, success");
                  })
                  .catch(err => {
                    console.log("navigator.clipboard.write, error:" + err);
                  });
          }

        }

        manageOuterPaste(clipboardEvent) {
          this.rx_outerPaste.next(clipboardEvent);
        }

        outerToInner(clipboardEvent) {

          // get text representation of clipboard
          var text = (clipboardEvent.originalEvent || clipboardEvent).clipboardData.getData('text/plain');
          if(text) {
            console.log("text", text);
            fileIntegration.onPasteTextListeners.forEach((listener, i) => {
              listener(text);
            });
          } else {
            console.log("not a text");

            FileIntegration.getPastedFile_p(clipboardEvent)
            .then(FileIntegration.createImage_p)
            .then(img => {
              fileIntegration.onPasteImageListeners.forEach((listener, i) => {
                listener(img);
              });
            });

          }

          return

        }

        innerToOuter(icObj) {
          return null;
        }

        lol() {
          // pasteFabricObjects(event) {
          //   console.log("pasteFabricObjects", event);
          //
          //   const clipboardData = event.clipboardData;
          //   // _clipboard.clone(function(clonedObj) {
          //   navigator.clipboard.read()
          //   .then((items) => {
          //     console.log("items", items);
          //   })
          //   .catch((err) => {
          //     console.log("err", err);
          //   });
          //
          //
          //   clipboardData.clone(function(clonedObj) {
          //     fabricCanvas.discardActiveObject();
          //     clonedObj.set({
          //       left: clonedObj.left + 10,
          //       top: clonedObj.top + 10,
          //       evented: true,
          //     });
          //     if (clonedObj.type === 'activeSelection') {
          //       // active selection needs a reference to the canvas.
          //       clonedObj.canvas = fabricCanvas;
          //       clonedObj.forEachObject(function(obj) {
          //         fabricCanvas.add(obj);
          //       });
          //       // this should solve the unselectability
          //       clonedObj.setCoords();
          //     } else {
          //       fabricCanvas.add(clonedObj);
          //     }
          //
          //     _clipboard.top += 10;
          //     _clipboard.left += 10;
          //
          //     fabricCanvas.setActiveObject(clonedObj);
          //     fabricCanvas.requestRenderAll();
          //   });
          // }
        }

        lol2() {
          fileIntegration.onPasteImageListeners.push((img) => {
            infiniteCanvas.manageImageImport(img);
          });
          fileIntegration.onPasteTextListeners.push((text) => {
            infiniteCanvas.manageTextImport(text);
          });
        }

      }










//User Input

      class InputProperties {
        constructor() {
          this.scroll_step__default = 1.0 / 500;
          this.scrollProperties = {
            step: this.scroll_step__default,
          };



          this.scroll_step__slow = this.scroll_step__default / 10;
          this.scroll_step__fast = this.scroll_step__default * 10;


          this.move_multiplier__default = 1.0;
          this.moveProperties = {
            moveMultiplier: this.move_multiplier__default,
          };

          this.move_multiplier__slow = this.move_multiplier__default / 10;
          this.move_multiplier__fast = this.move_multiplier__default * 10;


          this.colorProperties = {
            activeIndex : 0,
            list: [
              "lime",

              "red",
              "green",
              "blue",

              "white",
              "black",

              "orange",
              "purple",
              "yellow",
            ],
          };

          this.setNextColor(0);

          this.opacity = 1.0;
          const screment = 0;
          this.setNextOpacity(screment);
        }

        setScrollStep(value) {
          //console.log("setScrollStep", value);
          this.scrollProperties.step = value;
        }

        setMoveMultiplier(value) {
          //console.log("setMoveMultiplier", value);
          this.moveProperties.moveMultiplier = value;
        }



        getActiveColor() {
          return this.colorProperties.list[this.colorProperties.activeIndex];
        }

        setNextColor(screment) {
          console.log("setNextColor", screment);

          var index = this.colorProperties.activeIndex;
          index += screment;
          if(index >= this.colorProperties.list.length) {
            index -= this.colorProperties.list.length;
          } else if(index < 0) {
            index += this.colorProperties.list.length;
          }

          this.colorProperties.activeIndex = index;

          //debug
          debug.setActiveColor(this.getActiveRgbaColorString());
        }


        getActiveOpacity() {
          return this.opacity;
        }

        setNextOpacity(screment) {
          console.log("setNextOpacity", screment);

          const opacity_prev = this.opacity;

          const step_opacity     = 0.1;
          const screment_opacity = step_opacity * (-screment);

          const opacity_bounded  = Math.min(1.0, Math.max(0.0, opacity_prev + screment_opacity));
          this.opacity = opacity_bounded;

          //debug
          debug.setActiveColor(this.getActiveRgbaColorString());
        }

        getActiveRgbaColorString() {
          const color   = this.getActiveColor();
          const opacity = this.getActiveOpacity();

          const fColor = new fabric.Color(color);
          fColor.setAlpha(opacity);
          const rgbaColorString = fColor.toRgba();

          return rgbaColorString;
        }

      }





      class KeyDownToggle {

        constructor(name, keyDownFunc, keyDownToggleFunc = null) {
          this.name        = name;
          this.keyDownFunc = keyDownFunc;
          this.isActive    = false;

          this.keyDownToggleFunc = keyDownToggleFunc;
          if(keyDownToggleFunc == null) {
            this.keyDownToggleFunc = KeyDownToggle.keyDownToggleFunc();
          }
        }

        update(e, down) {
          const updateValue = this.keyDownFunc(e, down);
          if(updateValue != null) {
            if(this.isActive != updateValue) {
              this.isActive = updateValue;
              this.keyDownToggleFunc(this.isActive);
            }
          }
        }

        static defaultKeyDownFunc(arr_keyCode) {
          const keyDownFunc = (e, down) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if(keyCode == e.code) {
                acc = down;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyDownFunc;
        }

        static keyDownToggleFunc() {
          return (isActive) => {
            console.log("KeyDownToggle::update", this.name, this.isActive);
          };
        }

      }

      class KeyDownTimeout {

        constructor(name, keyDownFunc, triggeredFunc, delayInMs) {
          this.name          = name;
          this.keyDownFunc   = keyDownFunc;
          this.triggeredFunc = triggeredFunc;
          this.delayInMs     = delayInMs;

          this.isActive    = false;
        }

        update(e, down) {
          const updateValue = this.keyDownFunc(e, down);
          if(updateValue != null) {
            if(this.isActive != updateValue) {
              this.isActive = updateValue;
              console.log("KeyDownTimeout::update", this.name, this.isActive);

              const keyDownTimeout = this;

              function theFunc() {
                console.log("KeyDownTimeout", "call triggeredFunc()");
                keyDownTimeout.triggeredFunc();
              }

              function mayRepeat(theFunc) {

                setTimeout(function(){
                  if(keyDownTimeout.isActive) {
                    theFunc();
                    mayRepeat(theFunc);
                  }
                }, keyDownTimeout.delayInMs);
              }

              theFunc();
              mayRepeat(theFunc);

            }
          }
        }

        static defaultKeyDownFunc(arr_keyCode) {
          const keyDownFunc = (e, down) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if(keyCode == e.code) {
                acc = down;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyDownFunc;
        }

      }

      class KeyUpABToggle {

        constructor(name, keyUpFunc, triggeredFunc) {
          this.name          = name;
          this.keyUpFunc     = keyUpFunc;
          this.triggeredFunc = triggeredFunc;

          this.isModeA     = true;
        }

        update(e) {
          const updateValue = this.keyUpFunc(e);
          console.log("updateValue", updateValue);
          if(updateValue) {
            this.isModeA = !this.isModeA;
            console.log("KeyUpABToggle::update", this.name, this.isModeA);

            this.triggeredFunc(this.isModeA);
          }
        }

        static defaultKeyUpFunc(arr_keyCode) {
          const keyUpFunc = (e) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if(keyCode == e.code) {
                acc = true;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyUpFunc;
        }

      }

      class KeyboardIntegration {

        constructor(infiniteCanvas, inputProperties, fileIntegration, fabricIntegration) {
          this.infiniteCanvas  = infiniteCanvas;
          this.inputProperties = inputProperties;

          this.fileIntegration = fileIntegration;

          this.fabricIntegration = fabricIntegration;


          // this.altKeyDown = false;
          this.keyDownToggles  = {};
          this.keyDownTimeouts = {};

          this.keyUpABToggles  = {};


          this.configureKeyboardEventHandlers();
        }

        configureKeyboardEventHandlers() {
          const keyboardIntegration = this;
          const infiniteCanvas      = this.infiniteCanvas;

          const fabricIntegration   = this.fabricIntegration;

          document.addEventListener('keyup',   logKey);
          document.addEventListener('keyup',   handleKeyUp);
          document.addEventListener('keydown', handleKeyDown);


          function configureKeyDownToggles() {

            keyboardIntegration.keyDownToggles = {
              // alt: new KeyDownToggle("alt", KeyDownToggle.defaultKeyDownFunc(["AltLeft", "AltRight"])),   //do not use alt, alt is kind of a system key
              r: new KeyDownToggle("r", KeyDownToggle.defaultKeyDownFunc(["KeyR"])),

              c: new KeyDownToggle("c", KeyDownToggle.defaultKeyDownFunc(["KeyC"])),
              v: new KeyDownToggle("v", KeyDownToggle.defaultKeyDownFunc(["KeyV"])),


              shiftLeft: new KeyDownToggle("shiftLeft", KeyDownToggle.defaultKeyDownFunc(["ShiftLeft"]), (isActive) => {
                if(isActive) {
                  fabricIntegration.enterFreeDrawing();
                } else {
                  fabricIntegration.leaveFreeDrawing();
                }
              }),

            };

          }
          configureKeyDownToggles();


          function configureKeyDownTimeouts() {

            const default_timeout_delayInMs = 17; //17 ms == 60 fps
            keyboardIntegration.keyDownTimeouts = {

              a: new KeyDownTimeout("a", KeyDownToggle.defaultKeyDownFunc(["KeyQ"]), () => {
                var scaleAmount_for_100ms;

                if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  scaleAmount_for_100ms = -0.3;
                } else {
                  scaleAmount_for_100ms = -0.1;
                }

                const scaleAmount = default_timeout_delayInMs / 100 * scaleAmount_for_100ms;
                keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
              }, default_timeout_delayInMs),

              z: new KeyDownTimeout("z", KeyDownToggle.defaultKeyDownFunc(["KeyW"]), () => {
                var scaleAmount_for_100ms;

                if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  scaleAmount_for_100ms = +0.3;
                } else {
                  scaleAmount_for_100ms = +0.1;
                }

                const scaleAmount = default_timeout_delayInMs / 100 * scaleAmount_for_100ms;
                keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
              }, default_timeout_delayInMs),
            };

          }
          configureKeyDownTimeouts();


          function configureKeyUpABToggles() {

            keyboardIntegration.keyUpABToggles = {
              ":": new KeyUpABToggle(":", KeyUpABToggle.defaultKeyUpFunc(["Period"]), (isModeA) => {
                  keyboardIntegration.fabricIntegration.setAntiAliasEnabled(isModeA);
              }),

              "d": new KeyUpABToggle("d", KeyUpABToggle.defaultKeyUpFunc(["KeyD"]), (isModeA) => {
                  const infiniteCanvas = keyboardIntegration.infiniteCanvas;
                  if(!isModeA) {
                    infiniteCanvas.createIcLine_start();
                  } else {
                    infiniteCanvas.createIcLine_end();
                  }
              }),

              "^": new KeyUpABToggle("^", KeyUpABToggle.defaultKeyUpFunc(["BracketLeft"]), (isModeA) => {
                  const infiniteCanvas = keyboardIntegration.infiniteCanvas;
                  if(!isModeA) {
                    infiniteCanvas.debug_sparkleAnims(true);
                  } else {
                    infiniteCanvas.debug_sparkleAnims(false);
                  }
              }),
            };

          }
          configureKeyUpABToggles();



          function updateKeyDownToggles(e, down) {
            const arr_keyDownToggles = Object.values(keyboardIntegration.keyDownToggles);
            arr_keyDownToggles.forEach((keyDownToggle, i) => {
              keyDownToggle.update(e, down);
            });
          }

          function updateKeyDownTimeouts(e, down) {
            const arr_keyDownTimeouts = Object.values(keyboardIntegration.keyDownTimeouts);
            arr_keyDownTimeouts.forEach((keyDownTimeout, i) => {
              keyDownTimeout.update(e, down);
            });
          }

          function updateKeyUpABToggles(e) {
            const arr_keyUpABToggles = Object.values(keyboardIntegration.keyUpABToggles);
            arr_keyUpABToggles.forEach((keyUpABToggle, i) => {
              keyUpABToggle.update(e);
            });
          }


          function logKey(e) {
            //console.log("logKey", "e.code", e.code);
          }

          function handleKeyUp(e) {
            console.log("handleKeyUp", "e", e);

            if(fabricIntegration.shouldIgnoreShortcutInput()) {
              return;
            }

            updateKeyDownToggles(e, false);
            updateKeyDownTimeouts(e, false);
            updateKeyUpABToggles(e);



            switch(e.code) {
              case "KeyA":
                // handleKeyUp_A(e);
                break;

              case "KeyI":
                FileIntegration.importImage_p()
                .then(img => {
                  infiniteCanvas.manageImageImport(img);
                });
                break;

              case "KeyS":
                infiniteCanvas.manageSaveInfinishute_p()
                .then((success) => {
                  console.log("success", success);
                });
                break;
              case "KeyL":
                FileIntegration.loadInfinishute_p()

                //debug
               .then(infinishute => {
                 console.log("loaded infinishute", infinishute);
                 return infinishute;
               })

                .then(infinishute => {
                  infiniteCanvas.manageLoadInfinishute(infinishute);
                });
                break;

              /*
              // case "ShiftLeft":
              case "KeyZ":
                handleKey_Shift(e);
                break;
              // case "ControlLeft":
              case "KeyX":
                handleKey_Ctrl(e);
                break;
              */


              case "KeyE":
                {
                  const cursor =
                  fabricIntegration.activateObjectAtCursor();
                }
                break;


              case "KeyF":
                {
                  keyboardIntegration.infiniteCanvas.addNewRect();
                }
                break;


              // case "KeyF":
              //   handleKeyUp_F(e);
              //   break;

              // case "KeyT":
              //   handleKeyUp_T(e);
              //   break;
              case "KeyT":
                {
                  const debug_text = "1";
                  // const debug_text = "-103";
                  keyboardIntegration.infiniteCanvas.addNewText(debug_text);
                }
                break;

              case "KeyA":
                {
                  keyboardIntegration.infiniteCanvas.addNewCircle();
                }
                break;

              case "KeyH":
                {
                  keyboardIntegration.infiniteCanvas.addNewSnapSlot();
                }
                break;

              case "KeyZ":
                {
                  // keyboardIntegration.infiniteCanvas.addNewSparkle();
                  FileIntegration.importImage_p()
                  .then(img => {
                    infiniteCanvas.addNewSparkle(img);
                  });
                }
                break;

              case "KeyU":
                {
                  // keyboardIntegration.infiniteCanvas.addNewTouchSlot();
                  keyboardIntegration.infiniteCanvas.addNewGMOperator();
                }
                break;

              case "Digit8":
                {
                  // keyboardIntegration.infiniteCanvas.addNewTouchSlot();
                  keyboardIntegration.infiniteCanvas.addNewGMTargetSlot();
                }
              break;

              case "KeyJ":
                {
                  keyboardIntegration.infiniteCanvas.addNewWell();
                }
                break;

              case "KeyN":
                {
                  keyboardIntegration.infiniteCanvas.addNewComposite();
                  // keyboardIntegration.infiniteCanvas.addNewGreenMouseWell();
                }
                break;

              case "Quote":
                {
                  const tex = '\\frac{1}{x^2-1}';
                  // const svgEl = TexHelper.toSvgEl(tex);
                  // keyboardIntegration.infiniteCanvas.addNewSvg(svgEl);

                  // keyboardIntegration.infiniteCanvas.addNewTex(tex);

                  const expression = new algebra.Expression("x");
                  keyboardIntegration.infiniteCanvas.addNewExpr(expression);
                }
                break;




              case "KeyG":
                {
                  //group
                  fabricIntegration.groupSelectedObjects();
                }
                break;

              case "KeyB":
                {
                  //ungroup
                  fabricIntegration.ungroupSelectedObject();
                }
                break;




              case "Digit0":
              case "Numpad0":
                keyboardIntegration.infiniteCanvas.move_to_initial_position();
                break;

              case "BackQuote":
                keyboardIntegration.infiniteCanvas.move_to_pov__animation(pov_debug, animationConfig__default);
                break;



                // case "KeyW":
                //   {
                //     const scaleAmount = -0.1;
                //     keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
                //   }
                //   break;
                //
                // case "KeyE":
                //   {
                //     const scaleAmount = 0.1;
                //     keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
                //   }
                //   break;


              // case "KeyM":
              case "Semicolon":
                if(keyboardIntegration.keyDownToggles.r.isActive) {
                  keyboardIntegration.infiniteCanvas.manageCenterRotation(-10);
                } else {
                  keyboardIntegration.infiniteCanvas.updateWithDOrientation(-10);
                }
                break;

              case "KeyP":
                if(keyboardIntegration.keyDownToggles.r.isActive) {
                  keyboardIntegration.infiniteCanvas.manageCenterRotation(+10);
                } else {
                  keyboardIntegration.infiniteCanvas.updateWithDOrientation(+10);
                }
                break;

              case "KeyK":
                {
                  function openUrlInNewTab(url){
                    var win = window.open(url, '_blank');
                  }
                  openUrlInNewTab("https://www.qwant.com/?l=fr");
                }
                break;


              // case "AltLeft":
              // case "AltRight":
              //   keyboardIntegration.altKeyDown = false;
              //   break;

              case "Delete":
                fabricIntegration.deleteSelection();
                break;


              case "Space":
                fabricIntegration.deselectAll();
                break;


              default:
                break;
            }
          }

          function handleKeyDown(e) {
            //console.log("handleKeyDown", "e.code", e.code);

            if(fabricIntegration.shouldIgnoreShortcutInput()) {
              return;
            }

            updateKeyDownToggles(e, true);
            updateKeyDownTimeouts(e, true);


            switch(e.code) {
              /*
              // case "ShiftLeft":
              case "KeyZ":
                handleKey_Shift(e);
                break;
              // case "ControlLeft":
              case "KeyX":
                handleKey_Ctrl(e);
                break;
              */

              // case "AltLeft":
              // case "AltRight":
              //   keyboardIntegration.altKeyDown = true;
              //   break;

              default:
                break;
            }
          }



          // function handleKeyUp_A(e) {
          //   //console.log("handleKeyUp_A", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const zimage_scream = this.createScreamZimage(canvasBoundingTrueRect);
          //   this.addZimage(zimage_scream);
          //
          //   this.redrawCanvas();
          // }

          // function handleKeyUp_F(e) {
          //   //console.log("handleKeyUp_F", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const fObj = this.createFabricSampleObjectWithCanvasBoundingRect(canvasBoundingTrueRect);
          //   this.addFabricObject(fObj);
          //
          //   this.redrawCanvas();
          // }

          // function handleKeyUp_T(e) {
          //   //console.log("handleKeyUp_T", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const fObj = this.createFabricSampleTextObjectWithCanvasBoundingRect(canvasBoundingTrueRect);
          //   this.addFabricObject(fObj);
          //
          //   this.redrawCanvas();
          // }

          //scroll fast/slow

          /*
                  $(document).keydown(function(event) {
                  if (event.ctrlKey==true && (event.which == '61' || event.which == '107' || event.which == '173' || event.which == '109'  || event.which == '187'  || event.which == '189'  ) ) {
                          event.preventDefault();
                       }
                      // 107 Num Key  +
                      // 109 Num Key  -
                      // 173 Min Key  hyphen/underscor Hey
                      // 61 Plus key  +/= key
                  });

                  $(window).bind('mousewheel DOMMouseScroll', function (event) {
                         if (event.ctrlKey == true) {
                         event.preventDefault();
                         }
                  });
          */



          function handleKey_Shift(e) {
            switch(e.type) {
              case "keydown":
                this.setScrollStep(scroll_step__fast);
                this.setMoveMultiplier(move_multiplier__fast);
                break;
              case "keyup":
                this.setScrollStep(scroll_step__default);
                this.setMoveMultiplier(move_multiplier__default);
                break;
              default:
                break;
            }
          }

          function handleKey_Ctrl(e) {
            switch(e.type) {
              case "keydown":
                this.setScrollStep(scroll_step__slow);
                this.setMoveMultiplier(move_multiplier__slow);
                break;
              case "keyup":
                this.setScrollStep(scroll_step__default);
                this.setMoveMultiplier(move_multiplier__default);
                break;
              default:
                break;
            }
          }

        }


      }



      class MouseIntegration {

        constructor(canvasContainer, infiniteCanvas, inputProperties, keyboardIntegration) {

          this.infiniteCanvas  = infiniteCanvas;
          this.inputProperties = inputProperties;

          this.leftMouseDown  = false;
          this.rightMouseDown = false;

          this.keyboardIntegration = keyboardIntegration;

          this.configureMouseEventHandlers(canvasContainer);
        }

        // Mouse Event Handlers
        configureMouseEventHandlers(canvasContainer) {
          const mouseIntegration = this;

          const keyboardIntegration = this.keyboardIntegration;
          const inputProperties     = this.inputProperties;


          canvasContainer.addEventListener('mousedown', onMouseDown);
          canvasContainer.addEventListener('mouseup',   onMouseUp, false);
          canvasContainer.addEventListener('mouseout',  onMouseUp, false);
          canvasContainer.addEventListener('mousemove', onMouseMove, false);
          canvasContainer.addEventListener('wheel',     onMouseWheel, false);

          // mouse functions
          function onMouseDown(event) {

              /*
              // update the cursor coordinates
              const cursor = {
                x: event.pageX,
                y: event.pageY,
              };

              this.infiniteCanvas.updateCursor(cursor);
              */

              // detect left clicks
              if (event.button == 0) {
                  mouseIntegration.leftMouseDown = true;
                  mouseIntegration.rightMouseDown = false;
              }
              // detect right clicks
              if (event.button == 2) {
                  mouseIntegration.rightMouseDown = true;
                  mouseIntegration.leftMouseDown = false;
              }
          }

          function onMouseMove(event) {
              // //console.log("onMouseMove", "event", event);

              // update cursor with mouse position
              const cursor = {
                x: event.pageX,
                y: event.pageY,
              };
              mouseIntegration.infiniteCanvas.updateCursor(cursor);


              if (mouseIntegration.leftMouseDown) {
                mouseIntegration.infiniteCanvas.manageCursorMove_line();
              }
              else if (mouseIntegration.rightMouseDown) {
                //console.log("onMouseMove", "rightMouseDown", "event", event);

                // console.log("keyboardIntegration.altKeyDown", keyboardIntegration.altKeyDown);
                // if(keyboardIntegration.keyDownToggles.r.isActive) {
                //   mouseIntegration.infiniteCanvas.manageCursorMove_rotate();
                // } else {
                //   mouseIntegration.infiniteCanvas.manageCursorMove_offset();
                // }
                mouseIntegration.infiniteCanvas.manageCursorMove_offset();

              } else if(keyboardIntegration.keyDownToggles.r.isActive) {
                mouseIntegration.infiniteCanvas.manageCursorMove_rotate();
              }

          }

          function onMouseUp() {
              mouseIntegration.leftMouseDown  = false;
              mouseIntegration.rightMouseDown = false;

              mouseIntegration.infiniteCanvas.logCursor();
          }

          function onMouseWheel(event) {

            if(keyboardIntegration.keyDownToggles.c.isActive) {
              colorScroll();
            } else if(keyboardIntegration.keyDownToggles.v.isActive) {
              opacityScroll();
            } else {
              zoomScroll();
            }

            function colorScroll() {
              const deltaY   = event.deltaY;
              const screment = deltaY > 0 ? 1 : -1;
              inputProperties.setNextColor(screment);
            }

            function opacityScroll() {
              const deltaY   = event.deltaY;
              const screment = deltaY > 0 ? 1 : -1;
              inputProperties.setNextOpacity(screment);
            }

            function zoomScroll() {
              const deltaY = event.deltaY;
              // const scaleAmount = -deltaY / 500;
              const scroll_step = mouseIntegration.inputProperties.scrollProperties.step;
              //console.log("onMouseWheel", "scroll_step", scroll_step);
              const scaleAmount = -deltaY * scroll_step;

              const scaleAmount_max =  0.99;
              const scaleAmount_min = -0.99;
              const scaleAmount_bounded = Math.min(scaleAmount_max, Math.max(scaleAmount_min, scaleAmount));

              mouseIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount_bounded);

              /*
              var zoom = canvas.getZoom();
              zoom *= 0.999 ** deltaY;
              // if (zoom > 20) zoom = 20;
              // if (zoom < 0.01) zoom = 0.01;
              canvas.setZoom(zoom);
              event.preventDefault();
              event.stopPropagation();
              */



              // const scale_new = scale * (1 + scaleAmount);

              /*
              // zoom the page based on where the cursor is
              var distX = event.pageX / canvas.clientWidth;
              var distY = event.pageY / canvas.clientHeight;

              // calculate how much we need to zoom
              const unitsZoomedX = trueWidth() * scaleAmount;
              const unitsZoomedY = trueHeight() * scaleAmount;

              const unitsAddLeft = unitsZoomedX * distX;
              const unitsAddTop = unitsZoomedY * distY;

              const dOffsetX = unitsAddLeft;
              const dOffsetY = unitsAddTop;

              const dOffset = {
                dx: dOffsetX,
                dy: dOffsetY,
              };

              updateScaleAndDOffset(scale_new, dOffset);
              */
            }


          }

          // function onMouseWheel(event) {
          //   const deltaY = event.deltaY;
          //   const scaleAmount = -deltaY / 500;
          //   scale = scale * (1 + scaleAmount);
          //
          //   // zoom the page based on where the cursor is
          //   var distX = event.pageX / canvas.clientWidth;
          //   var distY = event.pageY / canvas.clientHeight;
          //
          //   // calculate how much we need to zoom
          //   const unitsZoomedX = trueWidth() * scaleAmount;
          //   const unitsZoomedY = trueHeight() * scaleAmount;
          //
          //   const unitsAddLeft = unitsZoomedX * distX;
          //   const unitsAddTop = unitsZoomedY * distY;
          //
          //   offsetX -= unitsAddLeft;
          //   offsetY -= unitsAddTop;
          // }

        }

      }

      class TouchIntegration {

        constructor(canvasContainer, infiniteCanvas, inputProperties) {
          // touch functions
          this.prevTouches = [null, null]; // up to 2 touches
          this.singleTouch = false;
          this.doubleTouch = false;

          this.configureTouchEventHandlers(canvasContainer);
        }

        configureTouchEventHandlers(canvasContainer) {
          // Touch Event Handlers
          canvasContainer.addEventListener('touchstart',  onTouchStart);
          canvasContainer.addEventListener('touchend',    onTouchEnd);
          canvasContainer.addEventListener('touchcancel', onTouchEnd);
          canvasContainer.addEventListener('touchmove',   onTouchMove);


          function onTouchStart(event) {
              if (event.touches.length == 1) {
                  this.singleTouch = true;
                  this.doubleTouch = false;
              }
              if (event.touches.length >= 2) {
                  this.singleTouch = false;
                  this.doubleTouch = true;
              }

              // store the last touches
              this.prevTouches[0] = event.touches[0];
              this.prevTouches[1] = event.touches[1];

          }

          function onTouchMove(event) {
              // get first touch coordinates
              const touch0X = event.touches[0].pageX;
              const touch0Y = event.touches[0].pageY;
              const prevTouch0X = this.prevTouches[0].pageX;
              const prevTouch0Y = this.prevTouches[0].pageY;

              const pointTouch0 = {

              };

              const pointPrevTouch0 = {

              };

              const scaledX = toTrueX(pointTouch0);
              const scaledY = toTrueY(pointTouch0);
              const prevScaledX = toTrueX(pointPrevTouch0);
              const prevScaledY = toTrueY(pointPrevTouch0);

              if (singleTouch) {
                  // add to history
                  drawings.push({
                      x0: prevScaledX,
                      y0: prevScaledY,
                      x1: scaledX,
                      y1: scaledY
                  })
                  drawLine(prevTouch0X, prevTouch0Y, touch0X, touch0Y);
              }

              if (doubleTouch) {
                  // get second touch coordinates
                  const touch1X = event.touches[1].pageX;
                  const touch1Y = event.touches[1].pageY;
                  const prevTouch1X = prevTouches[1].pageX;
                  const prevTouch1Y = prevTouches[1].pageY;

                  // get midpoints
                  const midX = (touch0X + touch1X) / 2;
                  const midY = (touch0Y + touch1Y) / 2;
                  const prevMidX = (prevTouch0X + prevTouch1X) / 2;
                  const prevMidY = (prevTouch0Y + prevTouch1Y) / 2;

                  // calculate the distances between the touches
                  const hypot = Math.sqrt(Math.pow((touch0X - touch1X), 2) + Math.pow((touch0Y - touch1Y), 2));
                  const prevHypot = Math.sqrt(Math.pow((prevTouch0X - prevTouch1X), 2) + Math.pow((prevTouch0Y - prevTouch1Y), 2));

                  // calculate the screen scale change
                  var zoomAmount = hypot / prevHypot;
                  scale = scale * zoomAmount;
                  const scaleAmount = 1 - zoomAmount;

                  // calculate how many pixels the midpoints have moved in the x and y direction
                  const panX = midX - prevMidX;
                  const panY = midY - prevMidY;
                  // scale this movement based on the zoom level
                  offsetX += (panX / scale);
                  offsetY += (panY / scale);

                  // Get the relative position of the middle of the zoom.
                  // 0, 0 would be top left.
                  // 0, 1 would be top right etc.
                  var zoomRatioX = midX / canvas.clientWidth;
                  var zoomRatioY = midY / canvas.clientHeight;

                  // calculate the amounts zoomed from each edge of the screen
                  const unitsZoomedX = trueWidth() * scaleAmount;
                  const unitsZoomedY = trueHeight() * scaleAmount;

                  const unitsAddLeft = unitsZoomedX * zoomRatioX;
                  const unitsAddTop = unitsZoomedY * zoomRatioY;

                  offsetX += unitsAddLeft;
                  offsetY += unitsAddTop;

                  redrawCanvas();
              }
              prevTouches[0] = event.touches[0];
              prevTouches[1] = event.touches[1];
          }

          function onTouchEnd(event) {
              singleTouch = false;
              doubleTouch = false;
          }

        }



      }


    </script>





    <script>
      // disable right clicking
      document.oncontextmenu = function () {
          return false;
      }

      class State {

      }

      const inputProperties      = new InputProperties();

      const clipboardIntegration = new ClipboardIntegration();
      const fileIntegration      = new FileIntegration(clipboardIntegration);


      const infiniteCanvas      = new InfiniteCanvas(canvas, inputProperties);
      clipboardIntegration.rx_mixedPaste.subscribe({
        next: (icObj) => {
          infiniteCanvas.addPastedIcObject(icObj);
        },
      });




      // const canvas = document.getElementById("myCanvas");
      const fabricIntegration   = new FabricIntegration(infiniteCanvas, inputProperties);
      fabricIntegration.clipboardIntegration = clipboardIntegration;
      infiniteCanvas.redrawCanvasListeners.push((redrawOccasion) => {
        fabricIntegration.redrawCanvas(redrawOccasion);
      });
      // infiniteCanvas.didAddObjectListeners.push((icObj) => {
      //   const icObj_free = icObj.r_free();
      //   fabricIntegration.addFabricObjectWithIcObj(icObj_free);
      // });
      infiniteCanvas.didAddRepresentationListeners.push((icObj_represented, icObj_representation) => {
        console.log("infiniteCanvas.didAddRepresentationListeners", icObj_represented, icObj_representation);

        const rep_official = icObj_represented.r_official();
        const rep_free     = icObj_represented.r_free();

        //debug
        if(icObj_representation == rep_free) {

            if(rep_official.type == "sparkle") {

              // const homeScale_sparkle = {
              //   X: rep_official.homeScale.X,
              //   Y: rep_official.homeScale.Y,
              // };
              const home_properties = {
                // homeScale: {
                  X: rep_official.homeScale.X,
                  Y: rep_official.homeScale.Y,
                // },
                orientation: rep_official.orientation,
              };



              var animation = null;

              // var homeScale_animated = {
              //   X: rep_official.homeScale.X,
              //   Y: rep_official.homeScale.Y,
              // };
              var animated_properties = {
                X: home_properties.X,
                Y: home_properties.Y,
                orientation: home_properties.orientation,
              };

              const duration_one_way    = 777;
              var   moment              = 0;

              var   timestamp_animStart = -1;

              var from = null;
              var to   = null;


              function animationUpdateFunc() {
                // rep_free.homeScale = homeScale_animated;
                rep_free.homeScale   = {
                  X: animated_properties.X,
                  Y: animated_properties.Y,
                };
                rep_free.orientation = animated_properties.orientation;
              }

              function createNewSparkleAnimation(old1, current, old2, new2, new1) {
                console.log("createNewSparkleAnimation");

                const duration_complement = duration_one_way - moment;

                // anime.set(homeScale_animated, current);
                anime.set(animated_properties, current);


                const animation_seam = anime({
                  // targets: homeScale_animated,
                  targets: animated_properties,
                  X: new2.X,
                  Y: new2.Y,
                  orientation: new2.orientation,

                  duration: duration_complement,
                  easing: 'easeOutSine',

                  update:   animationUpdateFunc,

                  changeBegin: () => {
                    from = new1;
                    to   = new2;

                    timestamp_animStart = Date.now() - moment;
                  },

                  complete: (anim) => {
                    console.log("@@@ completed");

                    //SHU: un peu sale mais comment faire autrement
                    animation = createAnimation_endless();
                    // setTimeout(() => {
                    //   animation = createAnimation_endless();
                    // }, 0);
                  },

                  autoplay: false,
                });

                function createAnimation_endless() {

                  var isForward = true;

                  const animation_endless = anime({
                    // targets: homeScale_animated,
                    // X: new1.X,
                    // Y: new1.Y,
                    targets: animated_properties,
                    X: new1.X,
                    Y: new1.Y,
                    orientation: new1.orientation,

                    direction: 'alternate',
                    easing: 'easeInOutSine',
                    loop:true,


                    autoplay: true,


                    duration: duration_one_way,
                    update:   (anim) => {
                      animationUpdateFunc();
                    },

                    loopBegin: function(anim) {

                      if(isForward) {
                        from = new2;
                        to   = new1;
                      } else {
                        from = new1;
                        to   = new2;
                      }

                      timestamp_animStart = Date.now();
                      moment = 0;

                      isForward = !isForward;
                    },
                    // loopComplete: function(anim) {
                    //
                    // },

                  });

                  return animation_endless;
                }

                return animation_seam;
              }

              function startAnimation() {
                // animation = createNewSparkleAnimationTimeline(homeScale_sparkle, homeScale_sparkle, infiniteCanvas.scale, infiniteCanvas.scale, homeScale_sparkle);
                // animation = createNewSparkleAnimation(homeScale_sparkle, homeScale_sparkle, infiniteCanvas.scale, infiniteCanvas.scale, homeScale_sparkle);

                const from = {
                  X: home_properties.X,
                  Y: home_properties.Y,
                  orientation: home_properties.orientation,
                };
                const to = {
                  X: infiniteCanvas.scale.X,
                  Y: infiniteCanvas.scale.Y,
                  // orientation: home_properties.orientation + 180,
                  orientation: home_properties.orientation + 180 * (home_properties.X / infiniteCanvas.scale.X),
                };
                animation = createNewSparkleAnimation(from, from, to, to, from);

                rep_free.animation = animation;

                animation.play();
                // timestamp_animStart = Date.now() - moment;

              }

              function updateAnimationSeamlessly() {
                console.log("updateAnimationSeamlessly");

                if(animation != null) {
                  // console.log("animation before:", animation);

                  animation.pause();
                  // const homeScale_animated__when_paused = {
                  //   X: homeScale_animated.X,
                  //   Y: homeScale_animated.Y,
                  // };
                  // console.log("homeScale_animated__when_paused.X  ", homeScale_animated__when_paused.X);
                  const animated_properties_when_paused = {
                    X: animated_properties.X,
                    Y: animated_properties.Y,
                    orientation: animated_properties.orientation,
                  };
                  console.log("animated_properties_when_paused.X  ", animated_properties_when_paused.X);

                  const timestamp_animStop = Date.now();

                  moment = (timestamp_animStop - timestamp_animStart);
                  console.log("@@@ timestamp_animStart", timestamp_animStart);
                  console.log("@@@ timestamp_animStop ", timestamp_animStop);

                  console.log("@@@ moment", moment);


                  animation.reset();
                  animation = null;

                  // anime.set(homeScale_animated, homeScale_animated__when_paused);
                  // homeScale_animated = homeScale_animated__when_paused;
                  anime.set(animated_properties, animated_properties_when_paused);
                  animated_properties = animated_properties_when_paused;

                  const old1 = from;
                  const old2 = to;
                  var   new1;
                  var   new2;

                  const A = home_properties;
                  const B = {
                    X: infiniteCanvas.scale.X,
                    Y: infiniteCanvas.scale.Y,
                    // orientation: home_properties.orientation + 180,
                    orientation: home_properties.orientation + 3.6 * (home_properties.X / infiniteCanvas.scale.X),
                  };

                  if(old1 == home_properties) {
                    new1 = A;
                    new2 = B;
                  } else {
                    new1 = B;
                    new2 = A;
                  }

                  // animation = createNewSparkleAnimation(old1, homeScale_animated__when_paused, old2, new2, new1);
                  animation = createNewSparkleAnimation(old1, animated_properties_when_paused, old2, new2, new1);
                  rep_free.animation = animation;

                  animation.play();
                  // timestamp_animStart = Date.now() - moment;

                  // console.log("animation after:", animation);
                }
              }




              startAnimation();

              //listen to infiniteCanvas.scale
              infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
                // console.log("infiniteCanvas.scale.X", infiniteCanvas.scale.X);
                // console.log("infiniteCanvas.scale.Y", infiniteCanvas.scale.Y);

                const isPovTooCloseToSparkle = (home_properties.X < infiniteCanvas.scale.X);

                if(isPovTooCloseToSparkle) {
                  if(animation != null) {
                    animation.reset();
                    animation = null;
                  }
                } else {
                  if(animation != null) {
                    updateAnimationSeamlessly();
                  } else {
                    startAnimation();
                  }
                }

              });


            }
        }

        fabricIntegration.addFabricObjectWithIcObj(icObj_representation);
      });

      infiniteCanvas.didAddPureObjectListeners.push((icObj) => {
        fabricIntegration.addFabricObjectWithPureIcObj(icObj);
      });

      infiniteCanvas.onAddRepresented((represented) => {
        console.log("onAddRepresented", represented);

        if(represented.r_official().type == "composite") {
          // console.log("---here---");

          const icComposite = represented.r_official();
          icComposite.engine.initialize();
          icComposite.engine.start();
        }

      })

      // infiniteCanvas.requestSyncWithIcObjListeners.push((icObj) => {
      //   fabricIntegration.syncWithIcObj(icObj);
      // });


      // const clipboardIntegration = new ClipboardIntegration(fileIntegration, fabricIntegration);

      const keyboardIntegration = new KeyboardIntegration(infiniteCanvas, inputProperties, fileIntegration, fabricIntegration);

      const canvasContainer     = document.getElementsByClassName("canvas-container")[0];
      const mouseIntegration    = new MouseIntegration(canvasContainer, infiniteCanvas, inputProperties, keyboardIntegration);
      // const touchIntegration    = new TouchIntegration(canvasContainer, infiniteCanvas, inputProperties);
      fabricIntegration.mouseIntegration = mouseIntegration;

    </script>

    <script>

      class Xylophone {

        constructor(infiniteCanvas, base = 10, exponent_min = -5, exponent_max = +5) {
          this.infiniteCanvas = infiniteCanvas;

          this.base         = base;
          this.exponent_min = exponent_min;
          this.exponent_max = exponent_max;

          this.xyloZones    = {};

          this.activeNumber       = 0;
          this.activeNumberString = "0";  //to avoid decimal <-> binary conversion issues  (0.7 != 0.7000000000000001)

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xylophone      = this;
          const infiniteCanvas = this.infiniteCanvas;

          const base         = this.base;
          const exponent_min = this.exponent_min;
          const exponent_max = this.exponent_max;

          const arr_exponent = [...Array(exponent_max - exponent_min + 1).keys()].map(i => (exponent_min + i));

          arr_exponent.forEach((exponent, i) => {

            const xyloZone = new XyloZone(infiniteCanvas, base, exponent);

            this.xyloZones[xyloZone.id] = xyloZone;
            xyloZone.didUpdateListeners.push((xyloZone) => {
              this.updateActiveNumber();
            });
          });

        }

        updateActiveNumber() {
          this.activeNumber = Object.values(this.xyloZones)
                              .map(xyloZone => xyloZone.activeNumber)
                              // .reduce((acc, x) => (acc + x), 0);
                              .reduce((acc, x) => (acc.plus(x)), new Decimal(0));
          // console.log("xylophone::updateActiveNumber", this.activeNumber;
          console.log("xylophone::updateActiveNumber", this.activeNumber.toFixed());

          this.didUpdate();
        }

        didUpdate() {
          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }


        getArr_exponent() {
            return Object.values(this.xyloZones).map(xyloZone => xyloZone.exponent);
        }

        getExponent_min() {
          return Math.min(...this.getArr_exponent());
        }

        getExponent_max() {
          return Math.max(...this.getArr_exponent());
        }

      }

      class XyloZone {

        constructor(infiniteCanvas, base, exponent) {
          this.infiniteCanvas = infiniteCanvas;

          const exponentString = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
          const numberString   = "" + base + "^" + exponentString;

          this.id       = numberString;

          this.base     = base;
          this.exponent = exponent;

          this.xylophoneTowers = {};

          this.icObjects = {};

          // this.activeNumber       = 0;
          this.activeNumber = new Decimal(0);
          this.activeNumberString = "" + this.activeNumber;

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xyloZone = this;

          const infiniteCanvas = this.infiniteCanvas;

          function activeCfgForTower(xylophoneTower) {
            var outCfg;

            outCfg = {
              fill: xylophoneTower.color,
              opacity: 1.0,
            };

            return outCfg;
          }

          function inactiveCfgForTower(xylophoneTower) {
            var outCfg;

            if(xylophoneTower.mantissa == 0) {
              outCfg = {
                fill: '',
                opacity: 1.0,
              };
            } else {
              outCfg = {
                fill: xylophoneTower.color,
                opacity: 0.3,
              };
            }

            return outCfg;
          }

          function createCanvasToggleRectForXylophoneTower(xylophoneTower) {
            const trueRect  = xylophoneTower.trueRect;

            const activeCfg   = activeCfgForTower(xylophoneTower);
            const inactiveCfg = inactiveCfgForTower(xylophoneTower);

            const isActive = false;

            const icToggleRect = infiniteCanvas.createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive);
            icToggleRect.canBeMoved    = false;
            icToggleRect.canBeRotated  = false;
            icToggleRect.canBeResized  = false;
            icToggleRect.canBeSelected = true;

            return icToggleRect;
          }


          const exponent = this.exponent;
          const base     = this.base;

          //zero tower
          {
            const xylophoneTower = new XylophoneTower(0, exponent, base);
            xyloZone.xylophoneTowers[xylophoneTower.mantissa] = xylophoneTower;
            xylophoneTower.didUpdateListeners.push((xylophoneTower, source) => {

              switch(source) {
                // case "view":
                //   //no sync needed
                //   xyloZone.updateWithXylophoneTowerViewUpdate(xylophoneTower);
                //   break;
                case "model":
                  //sync needed
                  xylophoneTower.icObj.isActive = xylophoneTower.isActive;
                  infiniteCanvas.requestViewUpdateForIcObj(xylophoneTower.icObj);
                  break;
              }

            });


            const icToggleRect = createCanvasToggleRectForXylophoneTower(xylophoneTower);
            icToggleRect.canBeSelected = false;

            xylophoneTower.icObj = icToggleRect;

            infiniteCanvas.addIcObject(icToggleRect);

            xylophoneTower.updateIsActive(true, "model");
          }

          //other towers
          [...Array(base - 1).keys()].forEach((item, j) => {
            const mantissa = j + 1;

            const xylophoneTower = new XylophoneTower(mantissa, exponent, base);
            xyloZone.xylophoneTowers[xylophoneTower.mantissa] = xylophoneTower;
            xylophoneTower.didUpdateListeners.push((xylophoneTower, source) => {

              switch(source) {
                case "view":
                  //no sync needed
                  xyloZone.updateWithXylophoneTowerViewUpdate(xylophoneTower);
                  break;
                case "model":
                  //sync needed
                  xylophoneTower.icObj.isActive = xylophoneTower.isActive;
                  infiniteCanvas.requestViewUpdateForIcObj(xylophoneTower.icObj);
                  break;
              }

            });

            const icToggleRect = createCanvasToggleRectForXylophoneTower(xylophoneTower);
            xylophoneTower.icObj = icToggleRect;

            infiniteCanvas.addIcObject(icToggleRect);

            icToggleRect.didUpdateListeners.push((icToggleRect) => {
              xylophoneTower.updateIsActive(icToggleRect.isActive, "view");
            });
          });




          //zone-dedicated objects

          //number text
          {
            const trueRect = this.xylophoneTowers[0].trueRect;

            const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "lol");
            icText.canBeMoved    = false;
            icText.canBeRotated  = false;
            icText.canBeResized  = false;
            icText.canBeSelected = false;

            const scaleFactor = (this.base ** this.exponent);
            console.log("number text, scaleFactor", scaleFactor);

            icText.homeScale = {
              X: icText.homeScale.X / scaleFactor     * 50,
              Y: icText.homeScale.Y / scaleFactor     * 50,
            };

            icText.fill = "yellow";

            this.icObjects["numberDisplay"] = icText;

            infiniteCanvas.addIcObject(icText);


            this.didUpdateListeners.push((xyloZone) => {
              const activeNumberString = xyloZone.activeNumber.toFixed();
              icText.text = activeNumberString;
              // infiniteCanvas.requestViewUpdateForIcObj(icText); //SHU666
            });
          }


        }

        setActiveMantissa(mantissa) {
          const chosenXylophoneTower = this.xylophoneTowers[mantissa];
          chosenXylophoneTower.updateIsActive(true, "model");

          const towers_to_deactivate = Object.values(this.xylophoneTowers).filter(xylophoneTower => xylophoneTower != chosenXylophoneTower);
          towers_to_deactivate.forEach((xylophoneTower, i) => {
            xylophoneTower.updateIsActive(false, "model");
          });

          this.updateActiveNumber();

          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }

        updateWithXylophoneTowerViewUpdate(chosenXylophoneTower) {
          console.log("updateWithXylophoneTowerViewUpdate", chosenXylophoneTower.mantissa);

          //deactivate all others
          const towers_to_deactivate = Object.values(this.xylophoneTowers).filter(xylophoneTower => xylophoneTower != chosenXylophoneTower);
          towers_to_deactivate.forEach((xylophoneTower, i) => {
            xylophoneTower.updateIsActive(false, "model");
          });

          if(chosenXylophoneTower.isActive) {

          } else {
            const zeroXylophoneTower = this.xylophoneTowers[0];
            zeroXylophoneTower.updateIsActive(true, "model");
          }

          this.updateActiveNumber();
        }

        updateActiveNumber() {
          this.activeNumber = Object.values(this.xylophoneTowers)
                              .filter(xylophoneTower => xylophoneTower.isActive)
                              .map(xylophoneTower => xylophoneTower.number)
                              // .reduce((acc, x) => (acc + x), 0);
                              .reduce((acc, x) => (acc.plus(x)), new Decimal(0));
          // console.log("xyloZone::updateActiveNumber", this.activeNumber);
          console.log("xyloZone::updateActiveNumber", this.activeNumber.toFixed());

          this.didUpdate();
        }

        didUpdate() {
          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }

        getTrueRect() {
          const zeroXylophoneTower = this.xylophoneTowers[0];
          return zeroXylophoneTower.trueRect;
        }

      }

      class XylophoneTower {

          constructor(mantissa, exponent, base) {
            const exponentString = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
            const numberString   = "" + mantissa + " x " + base + "^" + exponentString;

            this.id       = numberString;

            this.mantissa = mantissa;
            this.base     = base;
            this.exponent = exponent;

            this.xyloBrickNumber = new XyloBrickNumber(mantissa, exponent, base);

            this.unreliable_number = mantissa * (base ** exponent);
            this.number = null;
            if(base == 10) {
              //'sharp' number (==arbitrary-precision number)
              const decimalNumberFormatString = "" + mantissa + "e" + exponent;
              this.decimal_decimalNumber = new Decimal(decimalNumberFormatString);
              // console.log("this.decimal_decimalNumber", this.decimal_decimalNumber);
              console.log("this.decimal_decimalNumber.toFixed()", this.decimal_decimalNumber.toFixed());


              this.number = this.decimal_decimalNumber;
            } else {
              //SHU TODO: 'sharp management' when base != 10 ...
              //this seems to be linked to the halting problem
              this.number = this.unreliable_number;
            }

            this.successor     = (mantissa + 1) * (base ** exponent);
            // this.successorXyloBrickNumber = ;

            this.trueRect = XylophoneTower.trueRectForTower(this);
            this.color    = XylophoneTower.colorForMantissa(mantissa);

            this.isActive = false;

            this.didUpdateListeners = [];
          }

          updateIsActive(isActive, source) {
            this.isActive = isActive;

            this.didUpdateListeners.forEach((listener, i) => {
              listener(this, source);
            });

          }

          static trueRectForTower(xylophoneTower) {
            var outTrueRect;

            // const BL = {
            //   x: xylophoneTower.number,
            //   y: 0,
            // };
            // const TR = {
            //   x: xylophoneTower.successor,
            //   y: xylophoneTower.number,
            // }

            if(xylophoneTower.mantissa == 0) {
              const mantissa1_number = (xylophoneTower.base ** xylophoneTower.exponent);
              const nextPower_number = (xylophoneTower.base ** (xylophoneTower.exponent + 1));
              const mantissaN_number = nextPower_number - mantissa1_number;

              outTrueRect = {
                x: mantissa1_number,
                width:  nextPower_number - mantissa1_number,

                // y: -nextPower_number,
                // height: nextPower_number,

                y: - mantissaN_number,
                height: mantissaN_number,
              };
            } else {
              outTrueRect = {
                x: xylophoneTower.unreliable_number,
                y: -xylophoneTower.unreliable_number,
                width: (xylophoneTower.base ** xylophoneTower.exponent),
                height: xylophoneTower.unreliable_number,
              };
            }

            return outTrueRect;
          }

          static colorForMantissa(mantissa) {
            var outColor = null;

            switch(mantissa) {
              case 0:
                outColor = "#000000";
                break;

              case 1:
                outColor = "#FF7F0E";
                break;
              case 2:
                outColor = "#2CA02C";
                break;
              case 3:
                outColor = "#D62728";
                break;
              case 4:
                outColor = "#9467BD";
                break;
              case 5:
                outColor = "#8C564B";
                break;
              case 6:
                outColor = "#E377C2";
                break;
              case 7:
                outColor = "#7F7F7F";
                break;
              case 8:
                outColor = "#BCBD22";
                break;
              case 9:
                outColor = "#17BECF";
                break;

              //SHU TODO: colors or patterns for those:
              case 10:  //A
                outColor = "#000000";
                break;
              case 11:  //B
                outColor = "#000000";
                break;
              case 12:  //C
                outColor = "#000000";
                break;
              case 13:  //D
                outColor = "#000000";
                break;
              case 14:  //E
                outColor = "#000000";
                break;
              case 15:  //F
                outColor = "#000000";
                break;

              default:
                throw new Error("unsupported mantissa: " + mantissa);
            }

            return outColor;
          }


      }


      class XyloZonePerception {
      // class XyloZoneDecoration {

        constructor(infiniteCanvas, xyloZone) {
          this.infiniteCanvas = infiniteCanvas;
          this.xyloZone = xyloZone;

          this.trueRect = null;

          this.icObjects = {};

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xyloZonePerception = this;

          const infiniteCanvas = this.infiniteCanvas;

          const xyloZone_trueRect = xyloZonePerception.xyloZone.getTrueRect();

          //listen to xyloZone
          xyloZonePerception.xyloZone.didUpdateListeners.push((xyloZone) => {

          });

        }

        createInfiniteCanvasObjects() {

          function createCanvasToggleRectForXylophonePerception(xylophoneTower) {
            const trueRect  = xylophoneTower.trueRect;

            const activeCfg   = activeCfgForTower(xylophoneTower);
            const inactiveCfg = inactiveCfgForTower(xylophoneTower);

            const isActive = false;

            const icToggleRect = infiniteCanvas.createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive);
            icToggleRect.canBeMoved    = false;
            icToggleRect.canBeRotated  = false;
            icToggleRect.canBeResized  = false;
            icToggleRect.canBeSelected = true;

            return icToggleRect;
          }

        }

        update(xyloZone) {

        }

      }


      class NumberUtils {

        static randomXylophoneNumber(base, exponent_min, exponent_max) {

          const arr_exponent = [...Array(exponent_max - exponent_min + 1).keys()].map(i => (exponent_min + i));

          const arr_xyloBrickNumber = arr_exponent.map(exponent => {
            const mantissa = Math.floor(Math.random() * 10); // returns a random integer from 0 to 9
            const xyloBrickNumber = new XyloBrickNumber(mantissa, base, exponent);
            return xyloBrickNumber;
          });

          const xylophoneNumber = new XylophoneNumber(arr_xyloBrickNumber);

          return xylophoneNumber;
        }

      }

      class XyloBrickNumber {

        constructor(mantissa, base, exponent) {
          this.mantissa = mantissa;
          this.base     = base;
          this.exponent = exponent;

          this.unreliable_number  = mantissa * (base ** exponent);

          // const exponentString  = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
          // const sciNumberString = "" + mantissa + " x " + base + "^" + exponentString;
          // this.sciNumberString  = numberString;
          //
          // this.decimalNumberString = DecimalBrickNumber.decimalNumberString(mantissa, base, exponent);
        }

        toDecimalNumber() {
          var outDecimal;

          if(this.base == 10) {
            //'sharp' number (==arbitrary-precision number)
            const decimalNumberFormatString = "" + this.mantissa + "e" + this.exponent;
            const decimalNumber = new Decimal(decimalNumberFormatString);

            outDecimal = decimalNumber;
          } else {
            //SHU TODO: 'sharp management' when base != 10 ...
            //this seems to be linked to the halting problem
            throw new Error("unsupported for now");
          }

          return outDecimal;
        }

        // static decimalNumberString(mantissa, base, exponent) {
        //
        // }

      }

      class XylophoneNumber {

        constructor(arr_xyloBrickNumber) {

          //check not empty
          const isEmpty = (arr_xyloBrickNumber.length == 0);

          if(isEmpty) {
            throw new Error("arr_xyloBrickNumber.length == 0");
          }

          //check same base for all
          const base       = arr_xyloBrickNumber.find(e => true).base;
          const isSameBase = arr_xyloBrickNumber.every(xyloBrickNumber => (xyloBrickNumber.base == base));

          if(!isSameBase) {
            console.log("arr_xyloBrickNumber", arr_xyloBrickNumber);
            throw new Error("xyloBrickNumbers have different bases");
          }

          this.base = base;
          this.xyloBrickNumbers = arr_xyloBrickNumber.reduce((acc, xyloBrickNumber) => {
            acc[xyloBrickNumber.exponent] = xyloBrickNumber;
            // acc[xyloBrickNumber.exponent] = xyloBrickNumber.mantissa;
            return acc;
          }, {});

          this.unreliable_number = arr_xyloBrickNumber.reduce((acc, x) => (acc + x.unreliable_number), 0);
        }

        toDecimalNumber() {
          return Object.values(this.xyloBrickNumbers).reduce((acc, x) => {
            const xyloBrickDecimal = x.toDecimalNumber();
            return acc.plus(xyloBrickDecimal);
          }, new Decimal(0));
        }

        // filledToUnit() {
        //
        //   function fillNegative() {
        //     const
        //
        //   }
        //
        //   function fillPositive() {
        //
        //   }
        //
        //
        // }

        // toString() {
        //   const str = Object.keys(this.xyloBrickNumbers).reduce((acc, exponent) => {
        //
        //   }, "");
        //   return str;
        // }

        // isEqual(xylophoneNumber2) {
        //   const xylophoneNumber1 = this;
        //   const areEqual = XylophoneNumber.compare(xylophoneNumber1, xylophoneNumber2) == 0;
        //   return areEqual;
        // }
        //
        // static compare(xylophoneNumber1, xylophoneNumber2) {
        //   var outNumber;
        //
        //   const arr_keys_1 = Object.keys(xylophoneNumber1.xyloBrickNumbers);
        //
        //
        //   return outNumber;
        // }

      }




      // const xylophone = new Xylophone(infiniteCanvas, 10);
      const xylophone = null;
      // const xylophone = new Xylophone(infiniteCanvas, 2);    //always a bit confusing

    </script>

    <!-- debug -->
    <div id="xyloGame_container" style="position:absolute; left:0; bottom: 0; font-size: 60px; pointer-events: none;">
      <div>
        <div style="display: inline-block;">current number: </div>
        <div style="display: inline-block;" id="xyloGame_currentNumber"></div>
      </div>
      <div>
        <div style="display: inline-block;">target number: </div>
        <div style="display: inline-block;" id="xyloGame_targetNumber"></div>
      </div>
      <div>
        <div style="display: inline-block;"></div>
        <div style="display: inline-block;" id="xyloGame_completed"></div>
      </div>
    </div>

    <script>
      class XyloGameHUD {
        constructor (eltsDict) {
          this.eltsDict = eltsDict;
        }

        setCurrentNumberString(numberString) {
          this.eltsDict["currentNumber"].innerHTML = numberString;
        }
        setTargetNumberString(numberString) {
          this.eltsDict["targetNumber"].innerHTML = numberString;
        }
        setCompleted(completed) {
          this.eltsDict["completed"].innerHTML = completed ? "Well done !" : "";
        }
      }

      const xyloGameHUD_eltsDict = {
        currentNumber:  document.getElementById("xyloGame_currentNumber"),
        targetNumber:   document.getElementById("xyloGame_targetNumber"),
        completed:      document.getElementById("xyloGame_completed"),
      };
      const xyloGameHUD = new XyloGameHUD(xyloGameHUD_eltsDict);
    </script>


    <script>

    class XylophoneGame1_xyloWrite {

      constructor(xylophone, xyloGameHUD) {
        this.xylophone    = xylophone;
        this.xyloGameHUD  = xyloGameHUD;

        this.targetXylophoneNumber = null;
        this.targetNumber          = null;

        this.initialize();
      }

      initialize() {
        const xylophone   = this.xylophone;
        const xyloGameHUD = this.xyloGameHUD;

        const base         = xylophone.base;
        const exponent_min = xylophone.getExponent_min();
        const exponent_max = xylophone.getExponent_max();
        const targetXylophoneNumber = NumberUtils.randomXylophoneNumber(base, exponent_min, exponent_max);
        // console.log("targetXylophoneNumber", targetXylophoneNumber.toDecimalNumber().toFixed());

        this.targetXylophoneNumber = targetXylophoneNumber;
        this.targetNumber          = targetXylophoneNumber.toDecimalNumber();

        const targetNumberString = this.targetNumber.toFixed();
        xyloGameHUD.setTargetNumberString(targetNumberString);

        const xylophoneNumberString = xylophone.activeNumber.toFixed();
        xyloGameHUD.setCurrentNumberString(xylophoneNumberString);


        xylophone.didUpdateListeners.push((xylophone) => {
          console.log("XylophoneGame1_xyloWrite", "xylophone did update", xylophone);

          // const xylophoneNumberString = xylophone.getActiveNumberString();
          const xylophoneNumberString = xylophone.activeNumber.toFixed();
          console.log("xylophoneNumberString", xylophoneNumberString);
          xyloGameHUD.setCurrentNumberString(xylophoneNumberString);

          const numbersAreEqual = (targetNumberString == xylophoneNumberString);
          xyloGameHUD.setCompleted(numbersAreEqual);
        });
      }

    }

    class XylophoneGame2_xyloRead {

      constructor(infiniteCanvas) {

      }

    }

    if(xylophone != null) {
      const xyloWrite = new XylophoneGame1_xyloWrite(xylophone, xyloGameHUD);
    }

    </script>



    <script>
        class SandBox_doubleObjects {
          constructor(infiniteCanvas) {
            this.infiniteCanvas = infiniteCanvas;

            this.doubleObjects = {};

            this.initialize();
          }

          initialize() {
            const infiniteCanvas = this.infiniteCanvas;

            this.initialize_doubleObjects(infiniteCanvas);

            const arr_doubleObject = Object.values(this.doubleObjects);
            arr_doubleObject.forEach((doubleObject, i) => {
              this.materialize_doubleObject(doubleObject, infiniteCanvas);
            });

          }

          initialize_doubleObjects(infiniteCanvas) {

            //double object #1
            {
              const dO_id        = "dO#1"
              const dO_homeScale = {
                X:2.0,
                Y:2.0,
              };

              const icRect_front = infiniteCanvas.createIcRect_withLTWH(0, 0, 100, 100);
              icRect_front.fill  = "red";
              icRect_front.homeScale = dO_homeScale;

              const icRect_back = infiniteCanvas.createIcRect_withLTWH(0, 0, 100, 100);
              icRect_back.fill = "blue";
              icRect_back.homeScale = dO_homeScale;

              const doubleObject = new DoubleObject(dO_id, icRect_front, icRect_back);

              this.doubleObjects[doubleObject.id] = doubleObject;
            }

            //double object #2
            {
              const dO_id        = "dO#2"
              const dO_homeScale = {
                X:2.0,
                Y:2.0,
              };

              const img_front_p = FileIntegration.imageFromImgSrc_p("");
              const img_back_p  = FileIntegration.imageFromImgSrc_p("");

              const icObj_front = infiniteCanvas.createIcImage(500, 500, img_front);
              icObj_front.homeScale = dO_homeScale;

              const icObj_back = infiniteCanvas.createIcRect_withLTWH(500, 500, 100, 100);
              icObj_back.homeScale = dO_homeScale;

              const doubleObject = new DoubleObject(dO_id, icObj_front, icObj_back);

              this.doubleObjects[doubleObject.id] = doubleObject;
            }

          }

          materialize_doubleObject(doubleObject, infiniteCanvas) {
            const icObj_active = doubleObject.getActiveIcObject();
            infiniteCanvas.addIcObject(icObj_active);

            infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
              doubleObject.updateWithObservationScale(infiniteCanvas.scale);
            });

            doubleObject.didUpdateListeners.push((icObj_old, icObj_new) => {
              // infiniteCanvas.requestViewUpdateForIcObj(icObj);
              infiniteCanvas.removeIcObject(icObj_old);
              infiniteCanvas.addIcObject(icObj_new);
            });

          }

        }

        class DoubleObject {

          constructor(id, icObj_front, icObj_back) {
            this.id = id;

            this.icObj_front = icObj_front;
            this.icObj_back  = icObj_back;

            const factor_scaleToggle = 0.90;
            this.scale_toggle = {
              X: icObj_front.homeScale.X * factor_scaleToggle,
              Y: icObj_front.homeScale.Y * factor_scaleToggle,
            };

            // this.icObj_active = null;
            this.icObj_active = icObj_front;

            this.didUpdateListeners = [];
          }

          getActiveIcObject() {
            return this.icObj_active;
          }

          updateWithObservationScale(scale_obs) {
            console.log("updateWithObservationScale", scale_obs);

            const icObj_active = this.getIcObjectForObservationScale(scale_obs);

            this.setActiveIcObject(icObj_active);
          }

          getIcObjectForObservationScale(scale_obs) {
            var outIcObj;

            const isFar = scale_obs.X < this.scale_toggle.X && scale_obs.Y < this.scale_toggle.Y;

            if(isFar) {
              outIcObj = this.icObj_front;
            } else {
              outIcObj = this.icObj_back;
            }

            return outIcObj;
          }

          setActiveIcObject(icObj_new) {

            const icObj_old = this.icObj_active;

            if(icObj_new != icObj_old) {
              this.icObj_active = icObj_new;

              this.didUpdateListeners.forEach((listener, i) => {
                listener(icObj_old, icObj_new);
              });
            }

          }

          // didUpdate() {
          //
          // }



        }

        class ManyAnObject {

        }

        // const sandBox_doubleObjects = new SandBox_doubleObjects(infiniteCanvas);

    </script>


    <script>
        class SandBox_sparkles {
          constructor(infiniteCanvas) {
            this.infiniteCanvas = infiniteCanvas;

            this.objects = {};

            this.initialize();
          }

          initialize() {
            const infiniteCanvas = this.infiniteCanvas;

            this.initialize_objects(infiniteCanvas);

            const arr_objects = Object.values(this.objects);
            arr_objects.forEach((object, i) => {
              this.materialize_object(object, infiniteCanvas);
            });

          }

          initialize_objects(infiniteCanvas) {

            //sparkle #1
            {
              const dO_id        = "dO#1"
              const dO_homeScale = {
                X:20.0,
                Y:20.0,
              };

              const img_sparkle = "lol";
              const icObj = infiniteCanvas.createIcImage(500, 500, img_sparkle);  //SHU: formally, sparkle could hold any icObject or even more complicated type
              icObj.homeScale = dO_homeScale;                                     //     sparkle can hold any "representable" object

              const sparkle = new Sparkle(dO_id, icObj);
              sparkle.obsScale = infiniteCanvas.scale;

              this.sparkles[sparkle.id] = sparkle;
            }

          }

          materialize_object(object, infiniteCanvas) {

            const sparkle = object;

            const icObj = sparkle.icObj;
            infiniteCanvas.addIcObject(icObj);

            infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
              sparkle.updateWithObservationScale(infiniteCanvas.scale);
            });

            sparkle.didUpdateListeners.push((sparkle) => {
              const icObj = sparkle.icObj;
              infiniteCanvas.requestViewUpdateForIcObj(icObj);
            });

          }

        }

        class Sparkle {

          constructor(id, icObj) {
            this.id = id;

            this.icObj = icObj;

            this.homeScale = Object.assign({}, icObj.homeScale);
            this.obsScale  = null;

            this.didUpdateListeners = [];
          }

          updateWithObservationScale(scale_obs) {
            console.log("updateWithObservationScale", scale_obs);
            icObj.homeScale = scale_obs;
          }

          static default_sparkleImage_p() {
            const imageName = "sparkle_gradient.png";



          }

        }

        // const sandBox_sparkles = new SandBox_sparkles(infiniteCanvas);

    </script>

    <script>
        class ZPuzzle {
          constructor(infiniteCanvas) {
            this.infiniteCanvas = infiniteCanvas;

            this.objects = {
              slots:  {},
              pieces: {},
            };

            this.initialize();
          }

          initialize() {
            const infiniteCanvas = this.infiniteCanvas;

            this.initialize_objects(infiniteCanvas);

            const arr_slots = Object.values(this.objects.slots);
            arr_slots.forEach((slot, i) => {
              this.materialize_slot(slot, infiniteCanvas);
            });

            const arr_pieces = Object.values(this.objects.pieces);
            arr_pieces.forEach((piece, i) => {
              this.materialize_piece(piece, infiniteCanvas);

              const slot = this.objects.slots[piece.id];
              this.bindSlotAndPiece(slot, piece);
            });

          }

          initialize_objects(infiniteCanvas) {

            //s/p #1
            {
              const id = "id_sp1";
              const icObj = infiniteCanvas.createIcRect_withLTWH(500, 500, 500 , 500);
              icObj.fill = ZPuzzle.colorForNumber(1);

              const slotAndPiece = ZPuzzle.debugSlotAndPiece(id, icObj);
              this.objects.slots[id]  = slotAndPiece.slot;
              this.objects.pieces[id] = slotAndPiece.piece;
              slotAndPiece.piece.icObj.position = {
                x: slotAndPiece.piece.icObj.position.x + 600,
                y: slotAndPiece.piece.icObj.position.x + 100,
              };
            }

          }



          materialize_slot(slot, infiniteCanvas) {

            const icObj = slot.icObj;
            infiniteCanvas.addIcObject(icObj);

            // infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
            //   sparkle.updateWithObservationScale(infiniteCanvas.scale);
            // });

            // sparkle.didUpdateListeners.push((sparkle) => {
            //   const icObj = sparkle.icObj;
            //   infiniteCanvas.requestViewUpdateForIcObj(icObj);
            // });

          }

          materialize_piece(piece, infiniteCanvas) {

            const icObj = piece.icObj;
            infiniteCanvas.addIcObject(icObj);

            // infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
            //   sparkle.updateWithObservationScale(infiniteCanvas.scale);
            // });

            // sparkle.didUpdateListeners.push((sparkle) => {
            //   const icObj = sparkle.icObj;
            //   infiniteCanvas.requestViewUpdateForIcObj(icObj);
            // });

          }

          bindSlotAndPiece(slot, piece) {
            piece.didUpdateListeners.push((piece) => {
              console.log("piece, didUpdate");

              console.log("piece.isSnapped:", piece.isSnapped);

              if(!piece.isSnapped) {
                slot.attemptSnapping(piece);
              } else {
                // slot.attemptUnsnapping(piece);
              }

            });
          }


          static debugSlotAndPiece(spid, icObj) {
            // const icObj_slot  = icObj.clone();


            // const icObj_slot = backingObj.inner;
            // const backingObj = BackingObject.fromObject(icObj);
            // const icObj_slot = backingObj.getNewRepresentation();
            const icObj_slot = RepresentationFactory.initial(icObj);
            icObj_slot.addOnOuterUpdate((icObj_slot) => {
              console.log("icObj_slot","onOuterUpdate", icObj_slot);

            });

            icObj_slot.opacity = 0.2;
            const slot = new ZPuzzleSlot(spid, icObj_slot);

            // const icObj_piece = icObj.clone();
            // const icObj_piece = backingObj.getNewRepresentation();
            const icObj_piece = RepresentationFactory.initial(icObj);
            icObj_piece.addOnOuterUpdate((icObj_piece) => {
              console.log("icObj_piece","onOuterUpdate", icObj_piece);

            });


            //debug
            ///////////////////////
            // icObj_piece.createSisterRepresentation().addOnOuterUpdate((icObj_piece) => {
            //   console.log("icObj_piece sister rep","onOuterUpdate", icObj_piece);
            //
            // });
            //
            // setTimeout(() => {
            //   console.log("setTimeout", "update icObj_piece.position");
            //   icObj_piece.position = {
            //     x: icObj_piece.position.x + 100,
            //     y: icObj_piece.position.y + 100,
            //   };
            // }, 3000);
            //
            // setTimeout(() => {
            //   console.log("setTimeout", "update icObj_piece.position");
            //   icObj_piece.position = {
            //     x: icObj_piece.position.x + 100,
            //     y: icObj_piece.position.y + 100,
            //   };
            // }, 8000);
            ////////////////////////


            const piece = new ZPuzzlePiece(spid, icObj_piece);

            const slotAndPiece = {
              slot: slot,
              piece: piece,
            };

            return slotAndPiece;
          }

          static colorForNumber(number) {
            var outColor;

            switch(number) {
              case 1:
                outColor = "#FF7F0E";
                break;
              case 2:
                outColor = "#2CA02C";
                break;
              case 3:
                outColor = "#D62728";
                break;
              case 4:
                outColor = "#9467BD";
                break;
              case 5:
                outColor = "#8C564B";
                break;
              case 6:
                outColor = "#E377C2";
                break;
              case 7:
                outColor = "#7F7F7F";
                break;
              case 8:
                outColor = "#BCBD22";
                break;
              case 9:
                outColor = "#17BECF";
                break;

              default:
                outColor = "#000000";
                break;
            }

            return outColor;
          }

        }

        class ZPuzzleSlot {

          constructor(id, icObj) {
            this.id = id;

            // this.type = "typeA";

            this.icObj = icObj;

            // this.didUpdateListeners = [];
          }

          attemptSnapping(piece) {
            console.log("attemptSnapping", piece);

            const canSnap = this.checkCanSnap(piece);

            if(canSnap) {
              console.log("can snap");
              this.snap(piece);
            } else {
              console.log("can't snap");
            }

          }

          checkCanSnap(piece) {
            var outBool;

            const slot = this;

            // const isSameType = (piece.type == slot.type);
            // if(!isSameType) {
            //   return false;
            // }

            const isSlotAllowedForPiece = piece.isAllowedSlot(slot);
            if(!isSlotAllowedForPiece) {
              return false;
            }

            const icObj_slot  = slot.icObj;
            const icObj_piece = piece.icObj;

            outBool = Snap.canSnap(icObj_piece, icObj_slot);

            return outBool;
          }

          snap(piece) {
            console.log("Zslot", "snap", piece);

            piece.isSnapped = true;


            const icObj_slot  = this.icObj;
            const icObj_piece = piece.icObj;

            const icObj_new = Object.assign({}, icObj_piece);
            icObj_new.position     = Object.assign({}, icObj_slot.position);
            icObj_new.homeScale    = Object.assign({}, icObj_slot.homeScale);
            icObj_new.scale        = Object.assign({}, icObj_slot.scale);
            icObj_new.orientation  = icObj_slot.orientation;

            icObj_piece.update(icObj_new, "model");
          }

        }

        class ZPuzzlePiece {

          constructor(id, icObj) {
            this.id = id;

            this.icObj = icObj;

            this.isSnapped = false;

            this.didUpdateListeners = [];

            icObj.didUpdateListeners.push((icObj) => {
              console.log("ZPuzzlePiece", "icObj didUpdate", icObj);
              this.didUpdate();
            })
          }

          didUpdate() {
            this.didUpdateListeners.forEach((listener, i) => {
              listener(this);
            });
          }

          isAllowedSlot(slot) {
            var outBool;
            const piece = this;

            const isSameId = (slot.id == piece.id);
            outBool = isSameId;

            return outBool;
          }

        }






        // const zPuzzle_4pieces = ZPuzzle.default_4pieces(infiniteCanvas);
        // const zPuzzle_4pieces = new ZPuzzle(infiniteCanvas);

    </script>



</body>

</html>
