<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Canvas</title>

    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;

            /* Prevent document pinch-zoom & touch-hold-to-highlight */
            touch-action: none;

            -webkit-touch-callout: none;
            /* iOS Safari */
            -webkit-user-select: none;
            /* Safari */
            -khtml-user-select: none;
            /* Konqueror HTML */
            -moz-user-select: none;
            /* Old versions of Firefox */
            -ms-user-select: none;
            /* Internet Explorer/Edge */
            user-select: none;
            /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
        }
    </style>

</head>

<body>

    <!-- <script src='lib/base64.js' type='text/javascript'></script> -->
    <script src='lib/fabric.min.js' type='text/javascript'></script>

    <script src='lib/decimal.min.js' type='text/javascript'></script>



    <canvas id="myCanvas">Your browser does not support HTML5 canvas</canvas>
    <script>
      const canvas = document.getElementById("myCanvas");
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
    </script>


    <!-- debug -->
    <div id="debug_container" style="position:absolute; left:0; top: 0; font-size: 60px; pointer-events: none;">
      <div>
        <div style="display: inline-block;">current scale: </div>
        <div style="display: inline-block;"id="debug_scale"></div>
      </div>
      <div>
        <div style="display: inline-block;">offset: </div>
        <div style="display: inline-block;" id="debug_offset"></div>
      </div>
      <div>
        <div style="display: inline-block;">nb objects: </div>
        <div style="display: inline-block;" id="debug_nbObjects"></div>
      </div>
      <div>
        <div style="display: inline-block;">current object rect: </div>
        <div style="display: inline-block;" id="debug_currObjRect"></div>
      </div>
      <div>
        <div style="display: inline-block;">activeColor: </div>
        <div style="display: inline-block;" id="debug_activeColor">"   "</div>
      </div>
    </div>

    <script>
      class Debug {
        constructor (eltsDict) {
          this.eltsDict = eltsDict;
        }

        setScale(scale) {
          this.eltsDict["scale"].innerHTML = JSON.stringify(scale);
        }
        setOffset(offset) {
          this.eltsDict["offset"].innerHTML = JSON.stringify(offset);
        }
        setNbObjects(nb_objects) {
          this.eltsDict["nb_objects"].innerHTML = nb_objects;
        }
        setCurrentObjectRect(current_object_rect) {
          this.eltsDict["current_object_rect"].innerHTML = JSON.stringify(current_object_rect);
        }

        setActiveColor(color) {
          this.eltsDict["active_color"].style.backgroundColor = color;
        }
      }

      const debugEltsDict = {
        scale:                document.getElementById("debug_scale"),
        offset:               document.getElementById("debug_offset"),
        nb_objects:           document.getElementById("debug_nbObjects"),
        current_object_rect:  document.getElementById("debug_currObjRect"),

        active_color:         document.getElementById("debug_activeColor"),
      };
      const debug = new Debug(debugEltsDict);

    </script>




    <script>

/**** model  ****/

    const RedrawOccasion = {
      // "forceRedraw"   : 0,
      "forceRedraw"   : "forceRedraw",


      // "offsetChanged" : 10,
      "offsetChanged"       : "offsetChanged",
      // "scaleChanged"  : 11,
      "scaleChanged"        : "scaleChanged",
      "orientationChanged"  : "orientationChanged",


      // "objectAdded"   : 20,
      "objectAdded"     : "objectAdded",
      "pureObjectAdded" : "pureObjectAdded",

      "objectRemoved"     : "objectRemoved",



      // "windowResize"  : 100,
      "windowResize"  : "windowResize",
    };


    class InfiniteCanvas {

      constructor(canvas, inputProperties) {

        this.canvas          = canvas;
        this.inputProperties = inputProperties;

        this.coords_initial = {
          scale: {
            X:1,
            Y:1,
          },
          offset: {
            dx: 0,
            dy: 0,
          },
          orientation: 0,
        };

        // coordinates of our cursor
        this.cursor = {
          x: 0,
          y: 0,
        };
        this.previousCursor = Object.assign({}, this.cursor);


        // distance from origin
        this.offset         = Object.assign({}, this.coords_initial.offset);
        this.previousOffset = Object.assign({}, this.offset);
        this.dOffset = {
          dx: 0,
          dy: 0,
        };

        // zoom amount
        this.scale = Object.assign({}, this.coords_initial.scale);

        this.orientation = this.coords_initial.orientation;


        this.icObjects = {
          any: [],
        };
        this.didAddObjectListeners = [];

        this.pure_icObjects = {
          any: [],
        };
        this.didAddPureObjectListeners = [];

        this.didUpdateListenersDict = {
          // "objectAdded": [],
          "scaleChanged": [],
        };

        this.requestSyncWithIcObjListeners = [];



        this.redrawCanvasListeners = [];
        this.setupRedrawConditions();

        this.counter = 0;


        this.configureInitialIcObjects();



        //  track changes //

        // this.lastChangeTimestamp = null;
        this.changed            = false;



        var mySaveTimeout = null;

        const infiniteCanvas = this;
        window.addEventListener("beforeunload", (e) => {
          console.log("beforeunload", e);

          if(infiniteCanvas.changed /*&& !infiniteCanvas.leaveWithoutSaving*/) {

            const infiniteCanvas = this;
            const infinishute_p  = this.createInfinishute_p();

            function userStaysOnPage() {
              infiniteCanvas.manageSaveInfinishute_p_2(infinishute_p);
            }

            setTimeout(function() {                   //the nested setTimeout is the working way :)
              mySaveTimeout = setTimeout( () => {
                userStaysOnPage();
              }, 100 );
            },1);

          }

        });

        window.addEventListener('unload', function onUnload(e) {
          console.log("onUnload", e);
          clearTimeout(mySaveTimeout);
        });

      }

      setChanged(changed) {
              //uncomment for promptWhenUnsavedChanges
        // this.changed = changed;
        this.changed = false;


        if(this.changed) {
          window.onbeforeunload = () => {
            return "You have unsaved changes;";
          };

        } else {
          window.onbeforeunload = null;
        }

      }

      //objects
        //creation

      generateIcObjectId() {
        const id = this.counter;
        this.counter += 1;
        return id;
      }

      createIcObject(type, position, size, homeScale) {

        const id = this.generateIcObjectId();

        const icObj = new IcObject(id, type, position, size, homeScale);

        return icObj;
      }

      tetherIcObject(icObj) {
        const infiniteCanvas = this;
        icObj.didUpdateListeners.push((icObj, requestCanvasRedraw) => {
          infiniteCanvas.manageIcObjUpdate(icObj, requestCanvasRedraw);
        });
      }

      createIcRect_withLTWH(left, top, width, height) {

        const type      = "rect";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icRect_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,
        };

        const icRect = Object.assign(icObj, icRect_spec);

        return icRect;
      }

      createIcRect_withLTRB(left, top, right, bottom) {
        const width  = right - left;
        const height = bottom - top;
        const icRect = this.createRect_withLTWH(left, top, width, height);

        return icRect;
      }

      createIcPoint(point) {

        const type      = "point";
        const position  = Geometry.createPoint(point.x, point.y);
        const size      = Geometry.createSize(0, 0);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icPoint_spec = {
          "color"   : "blue",
          "name"    : "A",
        };

        const icPoint = Object.assign(icObj, icPoint_spec);

        return icPoint;

      }

      createIcCircle(left, top, width, height, fillColor = '') {

        const type      = "circle";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(width, height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const radius = width / 2;

        const icCircle_spec = {
          // left: left,
          // top:  top,
          // width: width,
          // height: height,

          radius   : radius,

          "stroke" : "blue",
          "fill"   : fillColor,
        };

        const icCircle = Object.assign(icObj, icCircle_spec);

        return icCircle;
      }


      createIcText(left, top, text) {

        const type      = "text";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(0, 0);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);


        // const text     = "icText";
        const fontSize = 100;

        const icText_spec = {
          text:      text,
          fontSize:  fontSize,
        };

        const icText = Object.assign(icObj, icText_spec);

        return icText;
      }

      createIcImage(left, top, img) {
        const type      = "image";
        const position  = Geometry.createPoint(left, top);
        const size      = Geometry.createSize(img.width, img.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icImage_spec = {
          img : img,
        };

        const icImage = Object.assign(icObj, icImage_spec);

        return icImage;
      }

      createIcFreeDrawing_from_freeDrawingFObj(fObj) {
        console.log("createIcFreeDrawing_from_freeDrawingFObj", fObj);

        const type      = "freeDrawing";


        const trueRect  = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size     = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icFreeDrawing_spec = {
          // img : img,
          path: fObj.path,
        };

        const icFreeDrawing = Object.assign(icObj, icFreeDrawing_spec);

        return icFreeDrawing;
      }

      createIcGroupWithChildIcObjects(arr_icObjs) {
        console.log("createIcGroupWithChildIcObjects", arr_icObjs);

        const type      = "group";

        const trueRect  = this.toTrueRect(fObj);
        const position = Geometry.getPointTL(trueRect);
        const size     = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icGroup_spec = {
          children: children,
        };

        const icGroup = Object.assign(icObj, icGroup_spec);

        return icGroup;
      }

      createIcGroup_from_groupFObj(fObj) {
        console.log("createIcGroup_from_groupFObj", fObj);

        const type      = "group";

        const trueRect  = this.toTrueRect(fObj);
        const position  = Geometry.getPointTL(trueRect);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const fChildren  = fObj.getObjects();
        const icChildren = fChildren.map(fObj => {
          const icObj = fObj.icObj;

          //?add position wrt group
          return icObj;
        });

        const icGroup_spec = {
          children: icChildren,
        };

        const icGroup = Object.assign(icObj, icGroup_spec);

        return icGroup;
      }

      createIcActiveSelection_from_activeSelectionFObj(fObj) {
        console.log("createIcActiveSelection_from_activeSelectionFObj", fObj);

        const type      = "activeSelection";

        const trueRect  = this.toTrueRect(fObj);
        const position  = Geometry.getPointTL(trueRect);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);

        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const fChildren  = fObj.getObjects();
        const icChildren = fChildren.map(fObj => {
          const icObj = fObj.icObj;

          //add position wrt group

        });

        const icActiveSelection_spec = {
          children: icChildren,
        };

        const icActiveSelection = Object.assign(icObj, icActiveSelection_spec);

        return icActiveSelection;

      }




      createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive) {

        const type      = "toggleRect";
        const position  = Geometry.createPoint(trueRect.x, trueRect.y);
        const size      = Geometry.createSize(trueRect.width, trueRect.height);
        const homeScale = Object.assign({}, this.scale);

        const icObj = this.createIcObject(type, position, size, homeScale);

        const icToggleRect_spec = {
          activeCfg:   activeCfg,
          inactiveCfg: inactiveCfg,

          isActive:    isActive,
        };

        const icToggleRect = Object.assign(icObj, icToggleRect_spec);

        return icToggleRect;

      }





        //add
      addIcObject(icObj) {
        console.log("addIcObject", icObj);

        this.icObjects["any"].push(icObj);

        this.tetherIcObject(icObj);   //== track icObj updates


        if(this.icObjects[icObj.type] == null) {
          this.icObjects[icObj.type] = [];
        }
        this.icObjects[icObj.type].push(icObj);


        console.log("this.icObjects['any'].length",      this.icObjects['any'].length);
        console.log("this.icObjects[icObj.type].length", this.icObjects[icObj.type].length);


        this.didAddObject(icObj);
      }

      didAddObject(icObj) {
        this.setChanged(true);

        this.didAddObjectListeners.forEach((listener, i) => {
          listener(icObj);
        });

        this.redrawCanvas(RedrawOccasion.objectAdded);
      }

      addPureIcObject(icObj) {

        this.pure_icObjects["any"].push(icObj);


        if(this.pure_icObjects[icObj.type] == null) {
          this.pure_icObjects[icObj.type] = [];
        }
        this.pure_icObjects[icObj.type].push(icObj);

        this.didAddPureObject(icObj);
      }

      didAddPureObject(icObj) {
        this.didAddPureObjectListeners.forEach((listener, i) => {
          listener(icObj);
        });

        this.redrawCanvas(RedrawOccasion.pureObjectAdded);
      }


      removeIcObject(icObj) {
        console.log("removeIcObject", icObj);

        console.log("this.icObjects['any'].length",      this.icObjects['any'].length);
        console.log("this.icObjects[icObj.type].length", this.icObjects[icObj.type].length);

        // this.icObjects["any"]      = Utils.arrayByRemovingElement(this.icObjects["any"], icObj);
        this.icObjects.any         = Utils.arrayByRemovingElement(this.icObjects.any, icObj);

        this.icObjects[icObj.type] = Utils.arrayByRemovingElement(this.icObjects[icObj.type], icObj);

        console.log("this.icObjects['any'].length",      this.icObjects['any'].length);
        console.log("this.icObjects[icObj.type].length", this.icObjects[icObj.type].length);


        this.didRemoveObject_p(icObj);
      }

      didRemoveObject_p(icObj) {
        this.setChanged(true);

        // this.didAddObjectListeners.forEach((listener, i) => {
        //   listener(icObj);
        // });
        //
        // this.redrawCanvas(RedrawOccasion.objectRemoved);
      }

      manageIcObjUpdate(icObj, requestCanvasRedraw = false) {
        console.log("manageIcObjUpdate");

        if(icObj.toBeDeleted) {
          console.log("this", this);
          this.removeIcObject(icObj);
        }

        this.setChanged(true);
      }


      //convenience

      addNewIcObject(icObj) {

        icObj.orientation = this.orientation;

        const activeColor = this.inputProperties.getActiveColor();
        switch(icObj.type) {
          case "rect":
          case "text":
          case "point":
            icObj.fill = activeColor;
            break;
          case "circle":
            icObj.stroke = activeColor;
            break;
        }

        this.addIcObject(icObj);
      }

      addNewRect() {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const width  = 100;   //"information" size
        const height = 100;

        const icRect = this.createIcRect_withLTWH(left, top, width, height);
        this.addNewIcObject(icRect);
      }

      addNewText(text = "icText") {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icText = this.createIcText(left, top, text);
        this.addNewIcObject(icText);
      }


      addNewImage(img) {

        const true_cursor = this.getTrueCursor();

        const left = true_cursor.x;
        const top  = true_cursor.y;

        const icImage = this.createIcImage(left, top, img);
        this.addNewIcObject(icImage);
      }

      addNewCircle() {
        const true_cursor = this.getTrueCursor();
        const radius = 100;

        const left   = true_cursor.x;
        const top    = true_cursor.y;
        const width  = 100;   //"information" size
        const height = 100;

        const icCircle = this.createIcCircle(left, top, width, height);
        this.addNewIcObject(icCircle);
      }

      addNewPoint() {
        const true_cursor = this.getTrueCursor();

        const icPoint = this.createIcPoint(true_cursor);
        this.addNewIcObject(icPoint);


        /*
        //debug
        const point_from = this.cursor;
        const center     = this.getScreenCenterPoint();

        [10,20,30,70,80,90,  270,300, -85].forEach((angleInDegrees, i) => {

          const screenPoint = Geometry.pointWithRotation(point_from, center, angleInDegrees);
          // console.log("screenPoint", screenPoint);

          this.addPoint(this.toTruePoint(screenPoint));
        });
        */

        // function debugRotation(point_from, center) {
        //
        //   [10,20,30,70,80,90].forEach((angleInDegrees, i) => {
        //
        //     const screenPoint = Geometry.pointWithRotation(point_from, center, angleInDegrees);
        //     this.addPoint(screenPoint);
        //   });
        //
        // }
        //
        // debugRotation(this.cursor, screenCenterPoint);


      }

      // addPurePoint(point) {
      //   const icPoint = this.createIcPoint(point);
      //   this.addPureIcObject(icPoint);
      // }
      //
      // addPureCircle(center, radius) {
      //
      //   const icCircle = this.createIcCircle(center, radius);
      //   this.addPureIcObject(icCircle);
      //
      // }




      configureInitialIcObjects() {

        // this.addAxes();

      }

      addAxes() {

        const icRectX = this.createIcRect_withLTWH(0, 0, 1000, 10);
        icRectX.fill = "red";
        this.addIcObject(icRectX);

        const icRectY = this.createIcRect_withLTWH(0, 0, 10, 1000);
        icRectY.fill = "blue";
        this.addIcObject(icRectY);

      }





      setupRedrawConditions() {
        // if the window changes size, redraw the canvas
        window.addEventListener("resize", (event) => {
            this.redrawCanvas(RedrawOccasion.windowResize);
        });
      }



      redrawCanvas(redrawOccasion) {

        debug.setScale(this.scale);
        debug.setOffset(this.offset);
        debug.setNbObjects(Object.values(this.icObjects.any).length);

        this.redrawCanvasListeners.forEach((listener, i) => {
          listener(redrawOccasion);
        });
      }




      // convert coordinates
      toScreenX(xTrue) {
          return (xTrue + this.offset.dx) * this.scale;
      }
      toScreenY(yTrue) {
          return (yTrue + this.offset.dy) * this.scale;
      }
      toScreenPoint(truePoint) {
        return Geometry.createPoint(this.toScreenX(truePoint.x), this.toScreenY(truePoint.y));
      }
      toScreenRect(trueRect) {
        const truePointTL = Geometry.createPoint(trueRect.left, trueRect.top);
        const truePointBR = Geometry.createPoint(trueRect.left + trueRect.width, trueRect.top + trueRect.height);

        const screen_pointTL = this.toScreenPoint(truePointTL);
        const screen_pointBR = this.toScreenPoint(truePointBR);

        const screen_w = screen_pointBR.x - screen_pointTL.x;
        const screen_h = screen_pointBR.y - screen_pointTL.y;

        const screenRect = Geometry.createRect(screen_pointTL.x, screen_pointTL.y, screen_w, screen_h);

        return screenRect;
      }
      toScreenSize(trueSize) {
        const screen_w  = trueSize.width  / this.scale.X;
        const screen_h  = trueSize.height / this.scale.Y;
        return Geometry.createSize(screen_w, screen_h);
      }
      // toScreenLength(trueLength) {
      //   return trueLength * this.scale;
      // }




      getOrientationBaseVectors() {
        return this.getRotationBaseVectors(this.orientation);
      }

      getStdBaseVectors() {
        return this.getRotationBaseVectors(-this.orientation);
      }

      getRotationBaseVectors(angle) {

        const cosTheta = Math.cos(angle * (Math.PI / 180));
        const sinTheta = Math.sin(angle * (Math.PI / 180));

        const orientation_vector_u = {
          x: cosTheta,
          y: sinTheta,
        };

        const orientation_vector_v = {
          x: -sinTheta,
          y: cosTheta,
        };

        const baseVectors = {
          u: orientation_vector_u,
          v: orientation_vector_v,
        };

        return baseVectors;

      }


      // toTrueX(xScreen) {
      //     return (xScreen / this.scale.X) - this.offset.dx;
      // }
      // toTrueY(yScreen) {
      //     return (yScreen / this.scale.Y) - this.offset.dy;
      // }
      toTrueX(screenPoint) {
          // console.log("toTrueX", "screenPoint", screenPoint);
          //
          // console.log("screenPoint.x", screenPoint.x);
          // console.log("this.scale.X", this.scale.X);
          // console.log("this.offset.dx", this.offset.dx);
          // console.log("this.offset", this.offset);


          const v = this.toNoOrPoint(screenPoint);

          const stdBaseVectors = this.getStdBaseVectors();
          // console.log("stdBaseVectors", stdBaseVectors);

          const trueX = Geometry.dotProduct_2d(v, stdBaseVectors.u);

          return trueX;
      }
      toTrueY(screenPoint) {
        const v = this.toNoOrPoint(screenPoint);

        const stdBaseVectors = this.getStdBaseVectors();

        return Geometry.dotProduct_2d(v, stdBaseVectors.v);
      }

      trueWidth() {
          // return canvas.clientWidth / scale;
          return this.canvas.width / this.scale.X;
      }
      trueHeight() {
          // return canvas.clientHeight / scale;
          return this.canvas.height / this.scale.Y;
      }

      toTruePoint(point) {
        const trueX = this.toTrueX(point);
        // console.log("trueX", trueX);

        const trueY = this.toTrueY(point);
        const truePoint = Geometry.createPoint(trueX, trueY);
        // console.log("truePoint", truePoint);
        return truePoint;
      }

      toTrueRect(rect) {
        const pointTL = Geometry.createPoint(rect.left, rect.top);
        const pointBR = Geometry.createPoint(rect.left + rect.width, rect.left + rect.height);

        const true_pointTL = this.toTruePoint(pointTL);
        const true_pointBR = this.toTruePoint(pointBR);

        const true_w = true_pointBR.x - true_pointTL.x;
        const true_h = true_pointBR.y - true_pointTL.y;

        const trueRect = Geometry.createRect(true_pointTL.x, true_pointTL.y, true_w, true_h);

        return trueRect;
      }

      getTrueCursor() {
        return this.toTruePoint(this.cursor);
      }

      truePointFromNoOrPoint(noOrPoint) {

        const stdBaseVectors = this.getStdBaseVectors();
        // console.log("stdBaseVectors", stdBaseVectors);

        const trueX = Geometry.dotProduct_2d(noOrPoint, stdBaseVectors.u);
        const trueY = Geometry.dotProduct_2d(noOrPoint, stdBaseVectors.v);

        const truePoint = Geometry.createPoint(trueX, trueY);

        return truePoint;
      }



      //noOr == no orientation == almost true point (wrong axes orientation)
      toNoOrX(screenX) {
        const noOrX = (screenX / this.scale.X) - this.offset.dx;
        return noOrX;
      }

      toNoOrY(screenY) {
        const noOrY = (screenY / this.scale.Y) - this.offset.dy;
        return noOrY;
      }

      toNoOrPoint(screenPoint) {
        return Geometry.createPoint(this.toNoOrX(screenPoint.x), this.toNoOrY(screenPoint.y));
      }

      toNoOrRect(screenRect) {
        const noOrTL = this.toNoOrPoint(Geometry.getPointTL(screenRect));
        const noOrBR = this.toNoOrPoint(Geometry.getPointBR(screenRect));
        const w = noOrBR.x - noOrTL.x;
        const h = noOrBR.y - noOrTL.y;
        return Geometry.createRect(noOrTL.x, noOrTL.y, w, h);
      }



      getCanvasBoundingRect() {
        // return canvas.getBoundingClientRect();
        return this.canvas.getBoundingClientRect();
      }

      getCanvasBoundingTrueRect() {
        const canvasBoundingRect = this.getCanvasBoundingRect();

        const trueRect = this.toTrueRect(canvasBoundingRect);

        return trueRect;
      }


      getScreenRect() {
        return this.getCanvasBoundingRect();
      }

      getScreenCenterPoint() {
        return Geometry.getCenterPoint(this.getCanvasBoundingRect());
      }

      getTrueCenterPoint() {
        const centerPoint_screen = this.getScreenCenterPoint();
        // console.log("centerPoint_screen", centerPoint_screen);
        const centerPoint_true   = this.toTruePoint(centerPoint_screen);
        return centerPoint_true;
      }

      getNoOrCenterPoint() {
        const centerPoint_screen = this.getScreenCenterPoint();
        // console.log("centerPoint_screen", centerPoint_screen);
        const centerPoint_noOr   = this.toNoOrPoint(centerPoint_screen);
        return centerPoint_noOr;
      }



      //"entry points"

      manageCursorMove_line() {

        /*
        //create line
        const line = {
            x0: prevScaledX,
            y0: prevScaledY,
            x1: scaledX,
            y1: scaledY
        };

        //console.log("line", line);

        // add the line to our drawing history
        drawings.push(line);

        // draw a line
        drawLine(prevCursorX, prevCursorY, cursorX, cursorY);
        */

      }

      manageCursorMove_offset() {

        const noOr_cursor         = this.toNoOrPoint(this.cursor);
        const noOr_previousCursor = this.toNoOrPoint(this.previousCursor);

        // move the screen
        const dOffsetX = (noOr_cursor.x - noOr_previousCursor.x) * this.inputProperties.moveProperties.moveMultiplier;
        const dOffsetY = (noOr_cursor.y - noOr_previousCursor.y) * this.inputProperties.moveProperties.moveMultiplier;

        const dOffset = {
          dx: dOffsetX,
          dy: dOffsetY,
        };

        //console.log("offset", offset);
        this.updateDOffset(dOffset);
        this.redrawCanvas(RedrawOccasion.offsetChanged);
      }

      manageCursorMove_rotate() {

        // console.log("this.cursor",         this.cursor);
        // console.log("this.previousCursor", this.previousCursor);

        // const screenRect   = this.getScreenRect();
        // console.log("screenRect", screenRect);
        const screenCenterPoint = this.getScreenCenterPoint();
        // console.log("screenCenterPoint", screenCenterPoint);


        // get rotation angle
        const v1 = {
          x: this.cursor.x - screenCenterPoint.x,
          y: this.cursor.y - screenCenterPoint.y,
        };
        const v2 = {
          x: this.previousCursor.x - screenCenterPoint.x,
          y: this.previousCursor.y - screenCenterPoint.y,
        };

        const norm_v1 = Geometry.norm_2d(v1);
        const norm_v2 = Geometry.norm_2d(v2);

        //angle = arccos[(xa * xb + ya * yb) / (√(xa2 + ya2) * √(xb2 + yb2))]
        const angle_abs = Math.acos( Geometry.dotProduct_2d(v1,v2) / (norm_v1 * norm_v2) );
        console.log("mcr", "angle_abs", angle_abs);

        if(isNaN(angle_abs)) {
          //ignore
          console.log("ignore", "isNaN(angle_abs) == true");
          // console.log("norm_v1", norm_v1);
          // console.log("norm_v2", norm_v2);
          return;
        }

        // * this.inputProperties.moveProperties.moveMultiplier

        //get the right sign
        const v1_3d = Geometry.vector_3d(v1);
        const v2_3d = Geometry.vector_3d(v2);
        const vn = {
          x:0,
          y:0,
          z:1,
        };

        const cross = Geometry.crossProduct_3d(v1_3d, v2_3d);
        // console.log("cross", cross);
        const sign = Geometry.dotProduct_3d(vn, cross) < 0 ? +1 : -1;

        const angleInRadians = sign * angle_abs;

        const angleInDegrees = angleInRadians * 180 / Math.PI;
        console.log("mcr", "angleInDegrees", angleInDegrees);

        const rotationCenter = this.getNoOrCenterPoint();
        // console.log("rotationCenter", rotationCenter);

        this.updateWithDRotation(angleInDegrees, rotationCenter);

        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }

      manageCenterRotation(angleInDegrees) {
        const rotationCenter = this.getNoOrCenterPoint();
        // console.log("rotationCenter", rotationCenter);

        this.updateWithDRotation(angleInDegrees, rotationCenter);

        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }

      logCursor() {

        console.log("this.cursor",         this.cursor);
        const true_cursor         = this.toTruePoint(this.cursor);
        console.log("true_cursor", true_cursor);


        const screenCenterPoint = this.getScreenCenterPoint();
        console.log("screenCenterPoint", screenCenterPoint);

      }




      //   // zoom the page based on where the cursor is
      //   var distX = event.pageX / canvas.clientWidth;
      //   var distY = event.pageY / canvas.clientHeight;
      //
      //   // calculate how much we need to zoom
      //   const unitsZoomedX = trueWidth() * scaleAmount;
      //   const unitsZoomedY = trueHeight() * scaleAmount;
      //
      //   const unitsAddLeft = unitsZoomedX * distX;
      //   const unitsAddTop = unitsZoomedY * distY;
      //
      //   offsetX -= unitsAddLeft;
      //   offsetY -= unitsAddTop;

      manageScaleUpdateWithScaleAmount(scaleAmount) {
        console.log("manageScaleUpdateWithScaleAmount", scaleAmount);

        const scale_new = {
          X: this.scale.X * (1 + scaleAmount),
          Y: this.scale.Y * (1 + scaleAmount),
        };


        // zoom the page based on where the cursor is
        const cursor            = this.cursor;
        const screenCenterPoint = this.getScreenCenterPoint();
        const screenRect        = this.getScreenRect();

        const cursorRatio = {
          X: cursor.x / screenRect.width,
          Y: cursor.y / screenRect.height,
        };
        console.log("cursorRatio", cursorRatio);

        const noOrRect = this.toNoOrRect(screenRect);

        const unitsZoomed = {
          X: noOrRect.width  * scaleAmount,
          Y: noOrRect.height * scaleAmount,
        };
        console.log("unitsZoomed", unitsZoomed);


        // const unitsZoomed = {
        //   X: this.trueWidth()  * scaleAmount,
        //   Y: this.trueHeight() * scaleAmount,
        // };

        // const sign = scaleAmount > 0 ? -1 : +1;

        const dOffset = {
          dx: - unitsZoomed.X * cursorRatio.X,
          dy: - unitsZoomed.Y * cursorRatio.Y,
        };
        console.log("dOffset", dOffset);

        this.updateScaleAndDOffset(scale_new, dOffset);

        this.redrawCanvas(RedrawOccasion.scaleChanged);
      }








      //save/load

      createInfinishute_p() {

        const counter = this.counter;
        const offset  = this.offset;
        const scale   = this.scale;
        const orientation = this.orientation;

        const arr_icObjects_serial_p = this.icObjects.any.map(icObj => icObj.toSerial_p());
        console.log("this.icObjects['any'].length", this.icObjects['any'].length);
        console.log("this.icObjects.any.length",    this.icObjects.any.length);



        const all_icObjects_serial_p = Promise.all(arr_icObjects_serial_p);

        const infinishute_p = all_icObjects_serial_p.then((arr_icObject_serial) => {
          const infinishute = {};

          infinishute.offset      = offset;
          infinishute.scale       = scale;
          infinishute.orientation = orientation;

          infinishute.counter     = counter;

          infinishute.icObjects = {
            any: arr_icObject_serial,
          };

          return infinishute;
        });

        return infinishute_p;
      }

      manageSaveInfinishute_p() {

        const infiniteCanvas = this;
        const infinishute_p = this.createInfinishute_p();

        return infinishute_p
               .then(infinishute => {
                 return FileIntegration.saveInfinishute_p(infinishute);
               })
               .then(success => {
                 console.log("saveInfinishute_p", "success", success);
                 infiniteCanvas.setChanged(!success);
               });
      }

      manageSaveInfinishute_p_2(infinishute_p) {

        return infinishute_p
               .then(infinishute => {
                 return FileIntegration.saveInfinishute_p(infinishute);
               })
               .then(success => {
                 console.log("saveInfinishute_p", "success", success);
                 infiniteCanvas.setChanged(!success);
               });

      }


      manageLoadInfinishute(json) {
        console.log("manageLoadInfinishute", json);

        this.offset      = json.offset;
        this.scale       = json.scale;
        this.orientation = json.orientation;

        this.counter = json.counter;

        const infiniteCanvas = this;

        const arr_icObj_p = json.icObjects.any.map((json_icObject, i) => {
          const icObj_p = IcObject.fromJson_p(json_icObject);
          return icObj_p;
        });

        Promise.all(arr_icObj_p)
        .then(arr_icObj => {
          console.log("manageLoadInfinishute", "arr_icObj", arr_icObj);

          arr_icObj.forEach((icObj, i) => {
            console.log("manageLoadInfinishute", "icObj", icObj);



            infiniteCanvas.addIcObject(icObj);
          });

        });

      }


      //core mutators

      updateCursor(cursor) {
        this.previousCursor = Object.assign({}, this.cursor);
        this.cursor         = Object.assign({}, cursor);
      }


      updateOffset(offset_new) {
        console.log("updateOffset", offset_new);

        this.previousOffset = Object.assign({}, this.offset);

        this.offset = Object.assign({}, offset_new);

        this.dOffset.dx = this.offset.dx - this.previousOffset.dx;
        this.dOffset.dy = this.offset.dy - this.previousOffset.dy;

        // this.redrawCanvas(RedrawOccasion.offsetChanged);
      }

      updateScale(scale_new) {
        this.scale = Object.assign({}, scale_new);

        this.didUpdateListenersDict["scaleChanged"].forEach((listener, i) => {
          listener(this);
        });
      }


      updateDOffset(dOffset_new) {
        const offset_new = {
          dx: this.offset.dx + dOffset_new.dx,
          dy: this.offset.dy + dOffset_new.dy,
        };
        this.updateOffset(offset_new);
      }

      updateScaleAndDOffset(scale_new, dOffset) {
        //console.log("updateScaleAndDOffset", scale_new, dOffset);
        this.updateScale(scale_new);
        this.updateDOffset(dOffset);
      }

      updateScaleAndOffset(scale_new, offset) {
        console.log("updateScaleAndOffset", scale_new, offset);
        this.updateScale(scale_new);
        this.updateOffset(offset);
      }

      updateOrientation(orientation_new) {
        console.log("updateOrientation", orientation_new);
        var orientation_bounded = Geometry.boundedAngleInDegrees(orientation_new);
        console.log("orientation_bounded", orientation_bounded);
        this.orientation = orientation_bounded;
      }

      updateWithDRotation(angleInDegrees, noOrCenterPoint) {
        console.log("updateWithDRotation", angleInDegrees, noOrCenterPoint);

        console.log("angleInDegrees", angleInDegrees);

        const radius = Geometry.norm_2d(noOrCenterPoint);

        // this.addPurePoint(centerPoint);
        // this.addPureCircle(centerPoint, radius);

        // this.addPoint(noOrCenterPoint);
        // this.addCircle(noOrCenterPoint, radius);

        const orientation_new = this.orientation - angleInDegrees;
        this.updateOrientation(orientation_new);


        const v = {
          x: noOrCenterPoint.x,
          y: noOrCenterPoint.y,
        };
        // console.log("v.x", v.x);
        // console.log("v.y", v.y);

        const angleInRadians = angleInDegrees / 180 * Math.PI;

        const ddx = Math.cos(angleInRadians) * v.x - Math.sin(angleInRadians) * v.y;
        const ddy = Math.sin(angleInRadians) * v.x + Math.cos(angleInRadians) * v.y;
        // console.log("ddx", ddx);
        // console.log("ddy", ddy);

        const dx = v.x - ddx
        const dy = v.y - ddy;
        // console.log("dx", dx);
        // console.log("dy", dy);


        const doffset_new = {
          dx: dx,
          dy: dy,
        };
        // console.log("doffset_new", doffset_new);

        this.updateDOffset(doffset_new);


      }


      updateWithDOrientation(dOrientation) {
        const orientation_new = this.orientation + dOrientation;
        this.updateOrientation(orientation_new);

        this.redrawCanvas(RedrawOccasion.orientationChanged);
      }


      move_to_initial_position() {
        console.log("move_to_initial_position");
        this.updateScaleAndOffset(this.coords_initial.scale, this.coords_initial.offset);
      }

      getCurrentPov() {
        const scale  = this.scale;
        const offset = this.offset;

        const pov = new POV(scale, offset);
        return pov;
      }

      set_pov(pov) {
        this.updateScaleAndOffset(pov.scale, pov.offset);
      }



      manageImageImport(img) {
        this.addNewImage(img);
      }

      manageTextImport(text) {
        this.addNewText(text);
      }





      //top down request
      requestViewUpdateForIcObj(icObj) {
        console.log("requestViewUpdateForIcObj", icObj);
        this.requestSyncWithIcObjListeners.forEach((listener, i) => {
          listener(icObj);
        });
      }


    }


    class IcObject {

      constructor(id, type, position, size, homeScale) {
        this.id   = id;
        this.type = type;

        this.position = position;
        this.size     = size;       //"information" size    //gives an idea of the sharpness/heavyness of the object

        this.homeScale = homeScale;


        this.orientation = 0;
        this.scale     = {
          X:1,
          Y:1,
        };
        this.flip = {
          X:false,
          Y:false,
        };


        this.fill   = "";
        this.stroke = "";
        // this.colors = {};

        this.opacity = 1.0;


        // this.hotState = {
        //   toBeDeleted: false,
        //
        //   perceptionScale: {
        //     X:1,
        //    Y:1,
        //   },
        // };

        this.canBeMoved    = true;
        this.canBeRotated  = true;
        this.canBeResized  = true;
        this.canBeSelected = true;

        this.didUpdateListeners = [];
      }

      static fromJson_p(json_icObject) {
        console.log("fromJson_p", json_icObject);

        const id   = json_icObject.id;
        const type = json_icObject.type;

        const position = json_icObject.position;
        const size     = json_icObject.size;

        const homeScale = json_icObject.homeScale;


        const icObj = new IcObject(id, type, position, size, homeScale);


        const scale = json_icObject.scale;
        icObj.scale = scale;

        const orientation = json_icObject.orientation;
        icObj.orientation = orientation;

        const flip = json_icObject.flip;
        icObj.flip = flip;


        const fill   = json_icObject.fill;
        icObj.fill = fill;
        const stroke = json_icObject.stroke;
        icObj.stroke = stroke;

        const opacity = json_icObject.opacity;
        icObj.opacity = opacity;

        var icObj_p = Promise.resolve(icObj);

        switch(icObj.type) {
          case "text":
            const text     = json_icObject.text;
            const fontSize = json_icObject.fontSize;

            icObj.text     = text;
            icObj.fontSize = fontSize;

            break;
          case "image":
            const img_serial = json_icObject.img;
            const img_p = FileIntegration.imageFromImgSrc_p(img_serial);

            const arr_p = [icObj_p, img_p];

            icObj_p = Promise.all(arr_p)
                      .then(([icObj, img]) => {

                        icObj.img = img;

                        return icObj;
                      });
            break;
          case "circle":
            const radius   = json_icObject.radius;

            icObj.radius = radius;
            break;

          case "group":
            {
              const children = json_icObject.children;

              const arr_p = children.map(json_children => {
                const icObj = IcObject.fromJson_p(json_children);
                return icObj;
              });

              Promise.all(arr_p)
              .then((arr_icObj) => {
                icObj.children = arr_icObj;
              });
            }
            break;

          default:
            break;
        }

        return icObj_p;
      }

      toSerial_p() {
        const icObj = this;

        const icObj_serial = Object.assign({}, icObj);

        var icObj_serial_p = Promise.resolve(icObj_serial);

        switch(icObj.type) {
          // case "text":
          //   const text     = icObj.text;
          //   const fontSize = icObj.fontSize;
          //
          //   icObj_serial.text     = text;
          //   icObj_serial.fontSize = fontSize;
          //
          //   break;
          case "image":
            const img = icObj.img;
            const img_serial_p = FileIntegration.dataUrlForImgViaCanvas_p(img);

            const arr_p = [icObj_serial_p, img_serial_p];

            icObj_serial_p = Promise.all(arr_p)
                                    .then(([icObj_serial, img_serial]) => {

                                      icObj_serial.img = img_serial;
                                      return icObj_serial;
                                    });

          // case "circle":
          //   const radius     = icObj.radius;
          //   icObj_serial.radius = radius;
          //
          //   break;

          // case "group":
          //   const children = icObj.children;
          //   icObj_serial.children = children;
          //
          //   break;

          default:
            break;
        }

        return icObj_serial_p;
      }




      getScreenPositionWithoutOffset() {
        const screenX = this.position.x * this.homeScale.X;
        const screenY = this.position.y * this.homeScale.Y;
        return Geometry.createPoint(screenX, screenY);
      }

      getHomeScreenSize() {
        return this.size;
      }

      getTrueSize() {
        // const homeScreenSize = this.getHomeScreenSize();
        const trueSize = {
          width:    this.size.width / this.homeScale.X * this.scale.X,
          height:   this.size.width / this.homeScale.Y * this.scale.Y,
        }
        return trueSize;
      }



      update(icObj_new, requestCanvasRedraw) {
        // console.log("icObj.update", "icObj_new", icObj_new);

        const icObj = this;

        if(icObj_new.type != icObj.type) {
          // console.log("invalid type for icObj_new", "icObj", icObj, "icObj_new", icObj_new);
          throw new Error("invalid type for icObj_new" + "icObj" + icObj + "icObj_new" + icObj_new);
        }

        this.position = Object.assign({}, icObj_new.position);
        this.size     = Object.assign({}, icObj_new.size);

        this.homeScale = Object.assign({}, icObj_new.homeScale);

        this.scale       = Object.assign({}, icObj_new.scale);
        this.orientation = icObj_new.orientation;
        this.flip        = Object.assign({}, icObj_new.flip);

        // this.fill        = icObj_new.fill;
        // this.stroke      = icObj_new.stroke;


        // this.perceptionScale = Object.assign({}, icObj_new.perceptionScale);

        if(this.type == "text") {
          this.text     = icObj_new.text;
          this.fontSize = icObj_new.fontSize;
        }

        if(this.type == "toggleRect") {
          this.isActive = icObj_new.isActive;
        }

        this.didUpdate(requestCanvasRedraw);
      }


      didUpdate(requestCanvasRedraw) {
        const icObj = this;
        this.didUpdateListeners.forEach((listener, i) => {      //SHU: todo: "everything is promised"
          listener(icObj, requestCanvasRedraw);
        });
      }

      delete_p() {
        return new Promise((resolve, reject) => {

          this.toBeDeleted = true;

          this.didUpdate(false);

          resolve(this);
        });
      }

      clone() {
        const id   = this.id;
        const type = this.type;

        const position = this.position;
        const size     = this.size;

        const homeScale = this.homeScale;

        const icObj_clone = new IcObject(id, type, position, size, homeScale);

        Object.assign(icObj_clone, this);
        console.log("icObj_clone", icObj_clone);

        return icObj_clone;
      }

      deepClone() { //SHU TODO: pour l'instant j'ai la flemme, mais il faudra des deep copy
        const id   = this.id;
        const type = this.type;

        const position = this.position;
        const size     = this.size;

        const homeScale = this.homeScale;

        const icObj_clone = new IcObject(id, type, position, size, homeScale);

        // Object.assign(icObj_clone, this);

        return icObj_clone;
      }


    }

    /* POVs */

    class POV {

      constructor(scale, offset) {

      }

      static debug() {
        const scale  = 5;
        const offset = {
          dx:+100,
          dy:+100,
        };
        return new POV(scale, offset);
      }


    }



    class Animation {

      constructor() {
        const animationConfig__default = {
          duration: 5000,  //duration == 0 => instant teleport, 'blink'
          /*
          animation : linear,
          */
        }
      }

      move_to_pov__animation(pov_to, animationConfig) {
        console.log("move_to_initial_position");

        const pov_from = getCurrentPov();
        console.log("pov_from", pov_from);

        const duration = animationConfig.duration;

        const time_start = Date.now();

        const frame_duration = 17; //17 ms <-> 60 Hz
        const myIntervalLoop = setInterval(function () {

          const time_curr = Date.now();
          const elapsed   = time_curr - time_start;

          const progress   = getProgress(elapsed, duration);

          // console.log("progress", progress);
          if (progress < 1.0) {
            const pov_target = getPovForProgress(pov_from, pov_to, progress);
            // console.log("pov_target", pov_target);
            set_pov(pov_target);
          } else {
            set_pov(pov_to);
            clearInterval(myIntervalLoop);
          }
        }, frame_duration);

        updateScaleAndOffset(coords_initial.scale, coords_initial.offset);
      }

      getPovForProgress(pov_from, pov_to, progress) {
        const arr_propPaths = [
          "scale",
          "offset.dx",
          "offset.dy",
        ];
        function getPropForPropPath(obj, propPath) {
          const arr_path = propPath.split(".");
          return arr_path.reduce((acc, pathElt) => {
            return acc[pathElt];
          }, obj);
        }
        function setPropAtPropPath(obj, propPath, value) {
          const arr_path = propPath.split(".");
          const arr__all_but_last = arr_path.slice(0, -1);
          const penultimate = arr__all_but_last.reduce((acc, pathElt) => {

            //create if not found
            if(acc[pathElt] == null) {
              acc[pathElt] = {};
            }

            return acc[pathElt];
          }, obj);

          const [lastPathElt] = arr_path.slice(-1);
          penultimate[lastPathElt] = value;
        }
        const pov_progress = arr_propPaths.reduce((acc, propPath) => {
          const prop_from = getPropForPropPath(pov_from, propPath);
          const prop_to   = getPropForPropPath(pov_to, propPath);

          //linear progress
          const prop_progress = prop_from + (prop_to - prop_from) * progress;

          setPropAtPropPath(acc, propPath, prop_progress);

          return acc;
        }, {});

        return pov_progress;
      }

      getProgress(curr, total) {
        return curr/total;
      }

    }







    /*****
      REPRESENTATIONS / BACKING OBJECT
    *//////

    var ID = () => {
      let arr = new Uint32Array(8);
      window.crypto.getRandomValues(arr);
      let str = '';
      for (let i = 0; i < arr.length; i++) {
        str += (i < 2 || i > 5 ? '' : '-') + arr[i].toString(16).slice(-4);
      }
      return str;
    };

    class BackingSchema {

      constructor(propsDict) {
        const arr_entries = Object.entries(propsDict).map(([propName, prop]) => {
          const propType = prop.constructor;
          return [propName, propType];
        });
        const propConstructorsDict = Object.fromEntries(arr_entries);

        Object.assign(this, propConstructorsDict);
      }

      static fromObject(obj) {
        return new BackingSchema(obj);
      }
    }

    class BackingObject {

      constructor(repClass, backingSchema, obj = null) {
        this.id = ID();

        /**/
        //pour la forme
        this.repClass      = repClass;
        this.backingSchema = backingSchema;
        /**/

        // this.counter = 0;
        this.representations = {};

        // this.inner = new repClass();                                                 //}
        //this.inner = {};                                                              //} SHU: ça se discute
        this.innerRep = createRepresentation(obj, "id_inner_rep" + "__" + this.id, []);    //}
        this.addRepresentation(this.innerRep);
      }

      static fromBackingSchemaAndObject(backingSchema, obj) {
        const repClass = obj.constructor;

        const backingObject = new BackingObject(repClass, backingSchema, obj);
        return backingObject;
      }

      static fromObject(obj) {
        const repClass      = obj.constructor;
        const backingSchema = BackingSchema.fromObject(obj);

        const backingObject = new BackingObject(repClass, backingSchema, obj);
        return backingObject;
      }

      generateNewRepId() {
        // const id = this.counter;
        // this.counter += 1;
        // return id;

        const id_rep = ID();
        return id_rep;
      }

      getNewRepresentation() {
        const backingObj = this;

        const id_rep = backingObj.generateNewRepId();

        const target         = backingObj.innerRep;
        console.log("target", target);

        const arr_backingObj = [backingObj];
        const rep = createRepresentation(target, id_rep, arr_backingObj);

        backingObj.addRepresentation(rep);

        return rep;
      }

      // updateWithRepresentation(rep__update) {
      //
      //   const arr_affected = Object.values(this.representations).filter(rep => rep.id != rep__update.id);
      //
      //   arr_affected.forEach((rep, i) => {
      //     rep.syncWith(rep__update);
      //   });
      //
      // }

      updateWithPropFromRepresentation(propName, setValue, rep__update) {
        // console.log("updateWithPropFromRepresentation", propName, setValue, rep__update);
        // console.log("rep__update.id_rep", rep__update.id_rep);

        const arr_affected = Object.values(this.representations).filter(rep => rep.id_rep != rep__update.id_rep);
        // console.log("arr_affected", arr_affected.map(rep => rep.id_rep));

        arr_affected.forEach((rep, i) => {
          rep.updateFromOuter(propName, setValue);
        });

      }

      addRepresentation(representation) {
        this.representations[representation.id_rep] = representation;
      }

    }

    function createRepresentation(target, id_rep, arr_backingObj) {
        // console.log("createRepresentation", "target", target);
        // console.log("createRepresentation", JSON.stringify(target));

        // const targetClass = target.constructor;

        const broadcaster = {}; //--> push to backingObject(s)
        broadcaster.id_rep = id_rep;
        broadcaster.arr_backingObj = arr_backingObj;
        broadcaster.addBackingObject = function(backingObj) {
          broadcaster.arr_backingObj.push(backingObj);
          backingObj.addRepresentation(broadcaster.representation);
        };

        broadcaster.createSisterRepresentation = function(backingObj = null) {
          var targetBackingObj = backingObj;
          if(targetBackingObj == null) {
            const backingObj_first = broadcaster.arr_backingObj.find(e => true);
            targetBackingObj = backingObj_first;
          }
          return targetBackingObj.getNewRepresentation();
        };

        const receiver  = {}; //<-- receive updates from backingObject(s)
        receiver.id_rep = id_rep;


        const inner = target.clone();
        // console.log("inner", inner);

        const representation = new Proxy({}, {
            get: function (obj, propName) {
              // console.log("representation.get", propName);
              var outProp;

              if(propName in broadcaster) {
                outProp = broadcaster[propName];//.bind(broadcaster);
              } else if(propName in receiver) {
                outProp = receiver[propName];//.bind(receiver);
              }

              else if(propName in inner) {
                outProp = inner[propName];//.bind(inner);
              }

              // else {
              //   console.log("representation", obj);
              //   throw new Error("unknown propName" + "(" + propName + ")" + " for representation: " + obj);
              // }

              return outProp;
            },
            set: function (obj, propName, setValue) {
              // console.log("representation.set", propName, setValue);

              updateInternals(propName,setValue);
              broadcaster.arr_backingObj.forEach((backingObj, i) => {
                // console.log("broadcasting to", backingObj);
                backingObj.updateWithPropFromRepresentation(propName, setValue, broadcaster.representation);
              });
              return true;
            },
        });

        function updateInternals(propName, value) {
          // console.log("updateInternals", propName, value);

          inner[propName] = value;
        }






        receiver.updateFromOuter = (propName,value) => {
          // console.log("updateFromOuter", propName, value);

          updateInternals(propName,value);

          // receiver.didUpdateProp(prop,value);

          //timeout to avoid calling didUpdate for every updated prop
          if(receiver.didUpdateTimeout == null) {
            const timeout_delayInMs = 17;
            receiver.didUpdateTimeout = setTimeout(() => {
              // console.log("didUpdateTimeout", "triggering");
              receiver.didUpdate();
              receiver.didUpdateTimeout = null;
            }, timeout_delayInMs);
          }
        };

        // receiver.didUpdatePropListeners = [];
        // receiver.didUpdateProp = (prop,value) => {
        //   receiver.didUpdatePropListeners.forEach((listener, i) => {
        //     listener(prop,value);
        //   });
        // }

        receiver.didUpdateTimeout   = null;
        receiver.didUpdateListeners = [];
        receiver.didUpdate = () => {
          // console.log("receiver", "didUpdate");
          receiver.didUpdateListeners.forEach((listener, i) => {
            listener(receiver);
          });
        };

        receiver.addOnOuterUpdate = (listener) => {
          receiver.didUpdateListeners.push(listener);
        };




        const glassFacade = new Proxy(inner, {
          get: function (obj, propName) {
            // console.log("glassFacade.get", propName);
            var outProp;

            if (propName === 'toJSON') {
				      return function() { return obj; }
            }

            if(propName in inner)	{	//Be careful! The in operator matches all object keys, including those in the object's prototype chain.
              outProp = inner[propName];
            } else {
              outProp = representation[propName];
            }

            return outProp;
          },
          set: function (obj, propName, setValue) {
              //console.log("glassFacade.set", propName /*,setValue*/ );
              representation[propName] = setValue;
              return true;
          },
        });

        broadcaster.representation = glassFacade;

        return glassFacade;
      }

      class Representation {
        static initial(obj) {
            return BackingObject.fromObject(obj).getNewRepresentation();
        }
      }

      /*//////
      *********/














/**** view  / controller ****/



      class FabricIntegration {

        constructor(infiniteCanvas, inputProperties) {

          //initialize fabric properties
          fabric.Object.prototype.transparentCorners = false;
          fabric.Object.prototype.cornerStyle = 'circle';
          fabric.Object.prototype.cornerColor = 'black';
          fabric.Object.prototype.borderColor = 'black';
          fabric.Object.prototype.padding     = 10;

          // // fabricjs group - always show border
          // fabric.Group.prototype.initialize = (function (initialize) {
          //     return function () {
          //         initialize.apply(this, arguments)
          //         // prepend rect before=behind group objects
          //         this._objects = [
          //         new fabric.Rect({
          //             // position from group center
          //             left: -0.5*this.width,
          //             top: -0.5*this.height,
          //             width: this.width,
          //             height: this.height,
          //
          //             stroke: '#00f',
          //             strokeWidth: 2,
          //             fill: false,
          //         })]
          //         .concat(this._objects)
          //
          //         // TODO repaint border on group resize event
          //
          //         // TODO remove border on group destroy
          //     };
          // })(fabric.Group.prototype.initialize);





          this.infiniteCanvas  = infiniteCanvas;
          this.inputProperties = inputProperties;

          const fabricCanvas = new fabric.Canvas(infiniteCanvas.canvas.id, {

            // backgroundColor: 'rgb(100,200,100)',
            // backgroundColor: 'rgb(100,100,100)',
            // backgroundColor: 'rgb(200,200,200)',      //it is important to choose a nice bgColor to stay motivated during dev
            backgroundColor: 'rgb(230,240,240)',

            selectionColor:  'blue',
            selectionLineWidth: 2,

            width:  canvas.width,
            height: canvas.height,


            imageSmoothingEnabled: true,
          });

          this.fabricCanvas = fabricCanvas;
          this.context      = fabricCanvas.getContext("2d");
          //console.log("fabricCanvas", fabricCanvas);

          this.fabric_objects = [];
          // this.inner_fabric_objects = [];
          // this.outer_fabric_objects = [];

          this.fabric_objects__pure = [];


          this.fabric_objects__hud = [];


          this.fObjForIcObj_dict = {};



          // this.debugFabric();
          this.synchronizeWithIcObjects(infiniteCanvas.icObjects);

          // this.debugOriginalAxes();

          this.initializeFreeDrawing();

          this.initializeFabricObjectCopyPaste();

          this.configureActiveSelectionListeners();
        }

        setFabricObjects(fabric_objects__new) {
          this.fabric_objects = fabric_objects__new;
        }

        getFabricObjects() {
          return this.fabric_objects;
        }




        // debugOriginalAxes() {
        //
        //   this.debugOriginalAxis_X();
        //   this.debugOriginalAxis_Y();
        // }
        //
        // debugOriginalAxis_X() {
        //
        //   // const line = new fabric.Line([0, -100, 0, +100], {
        //   //   left: 0,
        //   //   top: 0,
        //   //   stroke: 'red'
        //   // });
        //   //
        //   // this.addInnerFabricObject(line);
        //
        //   const rect = new fabric.Rect({
        //     left: 0,
        //     top: 0,
        //     width: 1000,
        //     height: 10,
        //     fill: 'blue',
        //   });
        //
        //   this.addInnerFabricObject(rect);
        //
        //
        //
        // }
        //
        // debugOriginalAxis_Y() {
        //
        //   // const line = new fabric.Line([-100, 0, 100, 0], {
        //   //   left: 0,
        //   //   top: 0,
        //   //   stroke: 'red'
        //   // });
        //   //
        //   // this.addInnerFabricObject(line);
        //
        //   const rect = new fabric.Rect({
        //     left: 0,
        //     top: 0,
        //     width: 10,
        //     height: 1000,
        //     fill: 'red',
        //   });
        //
        //   this.addInnerFabricObject(rect);
        //
        // }



        redrawCanvas(redrawOccasion) {
          console.log("redrawCanvas", redrawOccasion);

          switch(redrawOccasion) {

            case RedrawOccasion.offsetChanged:
              this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.scaleChanged: //order is important here
              this.updateFabricObjectsSize(redrawOccasion);
              this.updateFabricObjectsPosition(redrawOccasion);
              break;

            case RedrawOccasion.orientationChanged:
              this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.objectAdded:
              this.updateFabricObjectsPosition(redrawOccasion);
              this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.pureObjectAdded:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            case RedrawOccasion.objectRemoved:
              this.updateFabricObjectsPosition(redrawOccasion);
              this.updateFabricObjectsSize(redrawOccasion);
              break;


            case RedrawOccasion.windowResize:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;


            case RedrawOccasion.forceRedraw:
              // this.updateFabricObjectsPosition(redrawOccasion);
              // this.updateFabricObjectsSize(redrawOccasion);
              break;

            default:
              throw new Error("unknown redraw occasion:" + redrawOccasion);
              break;
          }

          this.fabricCanvas.renderAll(); //SHU: render only what is visible (is fabric smart enough ?)
        }


        synchronizeWithIcObjects(icObjects) {

          icObjects.any.forEach((icObj, i) => {
            this.addFabricObjectWithIcObj(icObj);
          });

        }


        addFabricObjectWithIcObj(icObj) {
          console.log("addFabricObjectWithIcObj", "icObj", icObj);

          // const fObj = this.createFabricObjectWithIcObj(icObj);

          var icObj_fRep;
          if(icObj.createSisterRepresentation != null) {
            icObj_fRep = icObj.createSisterRepresentation();

            icObj_fRep.addOnOuterUpdate((icObj_fRep) => {
              console.log("icObj_fRep","onOuterUpdate");

            });

          } else {
            icObj_fRep = icObj;
          }

          const fObj = this.createFabricObjectWithIcObj(icObj_fRep);

          if(fObj) {
            this.addOuterFabricObject(fObj);
          }

        }


        addFabricObjectWithPureIcObj(icObj) {

          const fObj = this.createFabricObjectWithIcObj(icObj);

          if(fObj) {
            this.addPureOuterFabricObject(fObj);
          }

        }

        createFabricObjectWithIcObj(icObj) {

          var fObj = null;

          switch(icObj.type) {
            case "rect":
              fObj = this.createFabricRectWithIcObj(icObj);
              break;
            case "text":
              fObj = this.createFabricITextWithIcObj(icObj);
              break;
            case "image":
              fObj = this.createFabricImageWithIcObj(icObj);
              break;


            case "circle":
              fObj = this.createFabricCircleWithIcObj(icObj);
              break;
            case "point":
              fObj = this.createFabricCircleWithIcPoint(icObj);
              // fObj = this.createFabricCompositeWithIcObj__point(icObj);
              break;

            case "freeDrawing":
              fObj = this.createFabricPolylineWithIcFreeDrawing(icObj);
              // fObj = this.createFabricCompositeWithIcObj__point(icObj);
              break;

            case "group":
              fObj = this.createFabricGroupWithIcObj(icObj);
              break;





            case "toggleRect":
              fObj = this.createFabricToggleRectWithIcObj(icObj);
              break;



            default:
              throw new Error("addFabricObjectWithIcObj " + "unsupported type: " + icObj.type);
              break;
          }

          //common props
          fObj.opacity = icObj.opacity;

          return fObj;

        }


        createFabricRectWithIcObj(icObj) {
          console.log("createFabricRectWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,


            // fill: '#f55',
            // fill: 'red',
            fill: icObj.fill,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj : icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          //debug
          fObj.setControlsVisibility({
             mt: false,
             mb: false,
             ml: false,
             mr: false,

             tl: true,
             tr: false,
             br: false,
             bl: false,

             mtr: true,
          });

          // fObj.hasControls = false;
          fObj.hasBorders  = true;


          return fObj;

        }


        createFabricITextWithIcObj(icObj) {
          // console.log("createFabricITextWithIcObj", icObj);

          const scale  = this.infiniteCanvas.scale;

          var fObj = new fabric.IText(icObj.text);
          fObj.set({
            left:   icObj.position.x,
            top:    icObj.position.y,
            // width:  100,
            // height: 100,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,


            fontSize: icObj.fontSize,

            // scaleX: scale,
            // scaleY: scale,

            // fill: '#f55',
            // fill: 'black',
            fill: icObj.fill,

            // opacity: 0.7,


            //~'persistent'
            // birth_scale : birth_scale,

            // trueRect : trueRect,
            // true_fontSize : true_fontSize,
            icObj : icObj,

          });

          //event listeners
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          this.addInteraction_editText(fObj);

          return fObj;
        }

        createFabricImageWithIcObj(icObj) {

          // const scale  = infiniteCanvas.scale;

          var fObj = new fabric.Image(icObj.img);

          fObj.set({
            left:   icObj.position.x,
            top:    icObj.position.y,
            width:  icObj.img.width,
            height: icObj.img.height,

            scaleX: icObj.scale.X,
            scaleY: icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            icObj: icObj,
          });


          //event listeners
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;
        }


        createFabricCircleWithIcObj(icObj) {
          // console.log("createFabricCircleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Circle();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            // width:  homeSize_screen.width,
            // height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            radius: icObj.radius,

            // fill: '#f55',
            // fill: 'red',
            // fill: '',
            fill: icObj.fill,

            // stroke: 'blue',
            stroke: icObj.stroke,
            strokeWidth : 5,

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj : icObj,
          });

          //event listeners
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }

        createFabricCircleWithIcPoint(icObj) {

          const fabricIntegration = this;

          // console.log("createFabricCircleWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Circle();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,


            radius: 10,

            // fill: '#f55',
            // fill: 'blue',
            fill: icObj.fill,

            stroke: '',

            // opacity: 0.7,

            // icObjId  : icObj.id,
            // trueRect : trueRect,
            icObj : icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          // if(icObj.canBeResized) {
          //   this.addInteraction_resize2(fObj);
          // }
          // if(icObj.canBeRotated) {
          //   this.addInteraction_rotate(fObj);
          // }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;

        }

        createFabricSvgWithIcFreeDrawing(icObj) {
          console.log("createFabricSvgWithIcFreeDrawing", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,



            fill: icObj.fill,

            // opacity: 0.7,

            icObj : icObj,
          });

          // console.log("----", "fObj", fObj);

          //event listeners
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);

          return fObj;

        }

          //group

        createFabricGroupWithIcObj(icObj) {
          console.log("createFabricGroupWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Group();

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);

          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,

            angle :  icObj.orientation,

            fill:    icObj.fill,

            // opacity: 0.7,

            icObj : icObj,
          });


          //create inner objects
          const fGroup = fObj;
          const childFObjs = icObj.children.map(icObj => {
            return this.createFabricGroupContentForFabricGroup(icObj, fGroup);
          });

          //add inner objects
          fObj.add(...childFObjs);



          //event listeners
          if(icObj.canBeMoved) {
            this.addInteraction_move(fObj);
          }
          if(icObj.canBeResized) {
            this.addInteraction_resize2(fObj);
          }
          if(icObj.canBeRotated) {
            this.addInteraction_rotate(fObj);
          }


          this.addInteraction_select(fObj);
          // this.addListeners(fObj);


          return fObj;

        }

        createFabricGroupContentForFabricGroup(icObj, fGroup) {
          const icGroup = fGroup.icObj;

          var fObj = this.createFabricObjectWithIcObj(icObj);

          //set the right coordinates:
          const icGroup_rect = Geometry.createRect(icGroup.position.x, icGroup.position.y, icGroup.size.width, icGroup.size.height);
          const  fGroup_rect = Geometry.createRect(fGroup.left, fGroup.top, fGroup.width, fGroup.height);

          const position = Geometry.getPointFromRectToRect(icObj.position, icGroup_rect, fGroup_rect);

          // const offsetFromCenterToTL = {
          //   dx: -fGroup.width,
          //   dy: -fGroup.height,
          // };

          const offsetFromCenterToTL = {
            dx: -fGroup.width/2,
            dy: -fGroup.height/2,
          };

          fObj.set({
            left: position.x + offsetFromCenterToTL.dx,
            top:  position.y + offsetFromCenterToTL.dy,
          });

          return fObj;

        }








        createFabricToggleRectWithIcObj(icObj) {
          console.log("createFabricToggleRectWithIcObj", icObj);

          const infiniteCanvas = this.infiniteCanvas;

          var fObj = new fabric.Rect();

          // const position_screen = this.infiniteCanvas.toScreenPoint(icObj.position);
          // console.log("position_screen", position_screen);
          // const size_screen     = this.infiniteCanvas.toScreenSize(icObj.size);
          // console.log("size_screen", size_screen);

          const position_screen = icObj.getScreenPositionWithoutOffset();
          // console.log("position_screen", position_screen);
          const homeSize_screen = icObj.getHomeScreenSize();
          // console.log("homeSize_screen", homeSize_screen);


          fObj.set({
            left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
            top:    position_screen.y,

            width:  homeSize_screen.width,
            height: homeSize_screen.height,

            scaleX:  icObj.scale.X,
            scaleY:  icObj.scale.Y,

            flipX:   icObj.flip.X,
            flipY:   icObj.flip.Y,


            angle :  icObj.orientation,

            //to avoid overlapping when clicking
            padding:     0,
            strokeWidth: 0,

            icObj : icObj,
          });

          configureWithIsActive(fObj, icObj.isActive);

          function configureWithIsActive(fObj, isActive) {

            const cfg = isActive ? fObj.icObj.activeCfg : fObj.icObj.inactiveCfg;

            fObj.set({
              fill:    cfg.fill,
              opacity: cfg.opacity,
            });

          }

          fObj.hasControls = false;
          fObj.hasBorders  = true;


          //event listeners
          if(icObj.canBeSelected) {

            this.addInteraction_select(fObj);

            if(icObj.canBeMoved) {
              this.addInteraction_move(fObj);
            }
            if(icObj.canBeResized) {
              this.addInteraction_resize2(fObj);
            }
            if(icObj.canBeRotated) {
              this.addInteraction_rotate(fObj);
            }


            const fabricCanvas = this.fabricCanvas;

            fObj.on('mouseup', function(options) {
              console.log("mouseup", "options", options);

              const icObj = fObj.icObj;

              const isActive_update = !icObj.isActive;

              const icObj_new = Object.assign({}, icObj);
              icObj_new.isActive = isActive_update;

              icObj.update(icObj_new, false);

              configureWithIsActive(fObj, isActive_update);

              fabricCanvas.renderAll();

            });


          } else {
            fObj.selectable = false;
          }

          // this.addListeners(fObj);



          return fObj;

        }
















        addInteraction_move(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          fObj.on('moving', function(options) {
            // console.log("moving", "options", options);

            const target = options.target;

            const offset = infiniteCanvas.offset;
            const scale  = infiniteCanvas.scale;

            // const trueRect_left__new = (target.left / scale - offset.dx);
            // const trueRect_top__new  = (target.top  / scale - offset.dy);
            //
            // const trueRect_update = {
            //   left: trueRect_left__new,
            //   top:  trueRect_top__new,
            // };
            // Object.assign(target.trueRect, trueRect_update);



            const icObj = fObj.icObj;

            const screenPoint = {
              x: target.left,
              y: target.top,
            };

            const position_update = infiniteCanvas.toTruePoint(screenPoint);

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new.position, position_update);

            icObj.update(icObj_new, false);
          });

        }

        // addInteraction_resize(fObj) {
        //
        //   const infiniteCanvas = this.infiniteCanvas;
        //   const fabricCanvas   = this.fabricCanvas;
        //
        //   var isScaling = false;
        //   var original_trueRect = null;
        //   fObj.on('scaling', function(options) {
        //     console.log("scaling", "options", options);
        //     const original = options.transform.original;
        //
        //     const target   = options.transform.target;
        //
        //     if(!isScaling) {
        //       original_trueRect = Geometry.createRect(target.icObj.position.x, target.icObj.position.y, target.icObj.size.width, target.icObj.size.height);
        //       console.log("original_trueRect", original_trueRect);
        //       isScaling = true;
        //     }
        //
        //     const scaleFactorX = target.scaleX / original.scaleX;
        //     const scaleFactorY = target.scaleY / original.scaleY;
        //
        //     console.log("scaleFactorX", scaleFactorX);
        //
        //     const trueRect_width__new  = (original_trueRect.width  * scaleFactorX);
        //     const trueRect_height__new = (original_trueRect.height * scaleFactorY);
        //
        //     console.log("trueRect_width__new", trueRect_width__new);
        //
        //
        //
        //     const offset = infiniteCanvas.offset;
        //     const scale  = infiniteCanvas.scale;
        //
        //     // const trueRect_update = {
        //     //   width:  trueRect_width__new,
        //     //   height: trueRect_height__new,
        //     // };
        //     //
        //     // // Object.assign(target.trueRect, trueRect_update);
        //     // Object.assign(fObj.trueRect, trueRect_update);
        //
        //     const trueRect_update = {
        //       left:  target.left / scale.X - offset.dx,
        //       top:   target.top  / scale.Y - offset.dy,
        //
        //       width:  (original_trueRect.width  * scaleFactorX),
        //       height: (original_trueRect.height * scaleFactorY),
        //     };
        //
        //     const icObj_update = {
        //       position: Geometry.createPoint(trueRect_update.left, trueRect_update.top),
        //       size:     Geometry.createSize(trueRect_update.width, trueRect_update.height),
        //     };
        //
        //     const icObj = fObj.icObj;
        //
        //     const icObj_new = Object.assign({}, icObj);
        //     Object.assign(icObj_new, icObj_update);
        //
        //     icObj.update(icObj_new, false);
        //
        //   });
        //   fObj.on('scaled', function(options) {
        //     console.log("scaled", "options", options);
        //     isScaling = false;
        //     original_trueRect = null;
        //
        //     const original = options.transform.original;
        //     const target   = options.transform.target;
        //
        //     target.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //
        //       //not used:
        //       // width:  target.trueRect.width  * scale,
        //       // height: target.trueRect.height * scale,
        //
        //       //used instead:
        //       // width:  target.trueRect.width,
        //       // height: target.trueRect.height,
        //       width:  target.icObj.size.width,
        //       height: target.icObj.size.height,
        //
        //       scaleX : original.scaleX,
        //       scaleY : original.scaleY,
        //     });
        //     target.setCoords();
        //   });
        //
        // }

        addInteraction_resize2(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          var isScaling = false;
          var original_homeScale = null;
          var original_scale     = null;
          fObj.on('scaling', function(options) {
            console.log("scaling", "options", options);


            const original = options.transform.original;
            const target   = options.transform.target;

            if(!isScaling) {
              original_homeScale = Object.assign({}, target.icObj.homeScale);
              // console.log("original_homeScale", original_homeScale);
              original_scale = Object.assign({}, target.icObj.scale);

              isScaling = true;
            }



            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);

            switch(options.transform.action) {

              case "scale":
                handle_proportionnal_scale();
                break;

              case "scaleX":
              case "scaleY":
                handle_axis_scale();
                // handle_proportionnal_scale();


                break;
            }

            function handle_proportionnal_scale() {

              const icObj = fObj.icObj;

              var homeScale_new;

              // if(fObj instanceof fabric.Text) {

                // const fontSize_fObj = fObj.fontSize;
                // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
                //
                // homeScale_new = {
                //   X: original_homeScale.X,
                //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
                // };

              // } else {

                homeScale_new = {
                  X: original_homeScale.X / scaleFactor.X,
                  Y: original_homeScale.Y / scaleFactor.Y,
                };

              // }
              console.log("homeScale_new", homeScale_new);

              const icObj_update = {
                homeScale: homeScale_new,
              };

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new, icObj_update);

              icObj.update(icObj_new, false);



              //update position
              {

                const fObj_pos = {
                  x: fObj.left,
                  y: fObj.top,
                };

                const position_update = infiniteCanvas.toTruePoint(fObj_pos);

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.position, position_update);

                icObj.update(icObj_new, false);

              }

              // //update flipX
              // {
              //   const flipX_update = fObj.flipX;
              //
              //   const icObj_new = Object.assign({}, icObj);
              //   Object.assign(icObj_new.flipX, flipX_update);
              //
              //   icObj.update(icObj_new, false);
              // }


            }

            function handle_axis_scale() {

              const icObj = fObj.icObj;

              var scale_new;

              // if(fObj instanceof fabric.Text) {

                // const fontSize_fObj = fObj.fontSize;
                // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
                //
                // homeScale_new = {
                //   X: original_homeScale.X,
                //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
                // };

              // } else {

                scale_new = {
                  X: original_scale.X * scaleFactor.X,
                  Y: original_scale.Y * scaleFactor.Y,
                };

              // }
              console.log("scale_new", scale_new);

              const icObj_update = {
                scale: scale_new,
              };

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new, icObj_update);

              icObj.update(icObj_new, false);




              //update position
              {

                const fObj_pos = {
                  x: fObj.left,
                  y: fObj.top,
                };

                const position_update = infiniteCanvas.toTruePoint(fObj_pos);

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.position, position_update);

                icObj.update(icObj_new, false);

              }

              //update flipX
              {
                const flip_update = {
                  X: (fObj.flipX != null) ? fObj.flipX : false,
                  Y: (fObj.flipY != null) ? fObj.flipY : false,
                };

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new.flip, flip_update);

                icObj.update(icObj_new, false);
              }



            }




          });
          fObj.on('scaled', function(options) {
            console.log("scaled", "options", options);
            isScaling = false;

            /*
            const original = options.transform.original;
            const target   = options.transform.target;

            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);


            const icObj = fObj.icObj;

            var homeScale_new;

            if(fObj instanceof fabric.Text) {

              // const fontSize_fObj = fObj.fontSize;
              // const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;
              //
              // homeScale_new = {
              //   X: scale.X / scale_fObj.X / scaleFactor__fontSize,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

            } else {

              homeScale_new = {
                X: original_homeScale.X / scaleFactor.X,
                Y: original_homeScale.Y / scaleFactor.Y,
              };

            }
            console.log("homeScale_new", homeScale_new);


            const icObj_update = {
              homeScale: homeScale_new,
            };

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);

            icObj.update(icObj_new, false);
            */

            original_homeScale = null;

          });

        }


        addInteraction_rotate(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          // const fabricCanvas   = this.fabricCanvas;

          // var isRotating = false;

          fObj.on('rotating', function(options) {
            // console.log("rotating", "options", options);

            // if(!isRotating) {
            //   isRotating = true;
            //
            //
            // }

            const original = options.transform.original;


            const target = options.transform.target;

            const icObj = fObj.icObj;

            // const orientation_update = target.angle + infiniteCanvas.orientation;
            const orientation_update = Geometry.boundedAngleInDegrees(target.angle + infiniteCanvas.orientation);
            // console.log("orientation_update", orientation_update);




            // console.log("target.angle",     target.angle);
            // console.log("original.angle", original.angle);
            //
            // const rotationAngle = target.angle - original.angle;
            // const rotationAngle_bounded = Geometry.boundedAngleInDegrees(rotationAngle);
            // console.log("rotationAngle", rotationAngle);
            //
            // const originalRect   = Geometry.createRect(original.left, original.top, target.width, target.height);
            // const originalTL     = Geometry.getPointTL(originalRect);
            // const originalCenter = Geometry.getCenterPoint(originalRect);
            // console.log("originalTL",     originalTL);
            // console.log("originalCenter", originalCenter);
            //
            // const screenTL_new = Geometry.pointWithRotation(originalTL, originalCenter, rotationAngle_bounded);
            // console.log("screenTL_new", screenTL_new);
            //
            //
            //
            //
            //
            //
            // const position_update = infiniteCanvas.toTruePoint(screenTL_new);



            const screenPoint = {
              x: target.left,
              y: target.top,
            };

            const position_update = infiniteCanvas.toTruePoint(screenPoint);


            const icObj_new = Object.assign({}, icObj);
            // Object.assign(icObj_new.orientation, orientation_update);

            icObj_new.orientation = orientation_update;

            Object.assign(icObj_new.position, position_update);

            icObj.update(icObj_new, false);
          });

        }


        addInteraction_select(fObj) {

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          fObj.on('selected', function(options) {
            console.log("selected", "options", options);

            // const activeGroup = fabricCanvas.getActiveGroup();


            /*
            const activeObject   = fabricCanvas.getActiveObject();

            // console.log("activeObject", activeObject);

            const icObj = activeObject.icObj;

            console.log("icObj.size.width",  icObj.size.width);
            console.log("icObj.homeScale.X", icObj.homeScale.X);
            console.log("icObj.scale.X",     icObj.scale.X);

            console.log("icObj.getTrueSize()", activeObject.icObj.getTrueSize());

            console.log("activeObject.scaleX", activeObject.scaleX);
            console.log("activeObject.scaleY", activeObject.scaleY);

            console.log("infiniteCanvas.scale.X", infiniteCanvas.scale.X);

            if(fObj instanceof fabric.Text) {
              console.log("icObj.fontSize", icObj.fontSize);
              console.log(" fObj.fontSize",  fObj.fontSize);
            }
            */

          });

        }


        addInteraction_editText(fObj) {

          // fObj.on('changed', function(options) {
          //
          // });

          fObj.on('changed', function(options) {
            console.log("changed", "options", options);

            console.log("fObj.text", fObj.text);

            const text_new = fObj.text;

            const icObj = fObj.icObj;

            const icObj_update = {
              text: text_new,
            };

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);

            icObj.update(icObj_new, false);

          });

        }


        configureActiveSelectionListeners() {
          // object:moving
          // object:scaling
          // object:rotating
          // object:skewing
          // object:moved
          // object:scaled
          // object:rotated
          // object:skewed

          const fabricIntegration = this;

          const infiniteCanvas = this.infiniteCanvas;
          const fabricCanvas   = this.fabricCanvas;

          //creation
          this.fabricCanvas.on("selection:created", (options) => {
            // console.log("selection:created", event);

            const activeObject = this.fabricCanvas.getActiveObject();

            if(activeObject instanceof fabric.ActiveSelection) {
              const activeSelection = activeObject;
              // console.log("activeSelection", activeSelection);

              //inject 'initial' props
              activeSelection.icObj = infiniteCanvas.createIcActiveSelection_from_activeSelectionFObj(activeSelection);
            }

          });


          //move
          this.fabricCanvas.on("object:moving", (options) => {
            // console.log("object:moving", event);

            const target = options.target;
            if(target.type == "activeSelection") {
              activeSelection_moving(target);
            }

          });

          //scale
          this.fabricCanvas.on("object:scaling", (options) => {
            // console.log("object:scaling", options);

            const target = options.target;
            if(target.type == "activeSelection") {
              activeSelection_scaling(options);
            }

          });
          this.fabricCanvas.on("object:scaled", (options) => {
            // console.log("object:scaling", event);

            const target = options.target;
            if(target.type == "activeSelection") {
              activeSelection_scaled(target);
            }

          });


          //rotate
          this.fabricCanvas.on("object:rotating", (options) => {
            // console.log("object:rotating", event);

            const target = options.target;
            if(target.type == "activeSelection") {
              activeSelection_rotating(options);
            }

          });







          function activeSelection_moving(activeSelection) {
            console.log("activeSelection moving");

            //update activeSelection position
            {
              const fObj = activeSelection;

              const icObj = fObj.icObj;

              const fObj_screenPos = {
                x: fObj.left,
                y: fObj.top,
              };

              const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new.position, position_update);

              icObj.update(icObj_new, false);
            }

            //update children position

            const activeSelectionCL = activeSelection.left + activeSelection.width  / 2;
            const activeSelectionCT = activeSelection.top  + activeSelection.height / 2;

            function updateChildFObj_position(fObj) {

              const icObj = fObj.icObj;

              const screenPoint = {
                x: activeSelectionCL + fObj.left,
                y: activeSelectionCT + fObj.top,
              };

              const position_update = infiniteCanvas.toTruePoint(screenPoint);

              const icObj_new = Object.assign({}, icObj);
              Object.assign(icObj_new.position, position_update);

              icObj.update(icObj_new, false);
            }

            activeSelection.forEachObject((fObj, index, arr_fObj) => {
              updateChildFObj_position(fObj);
            }, fabricIntegration.fabricCanvas.context);


          }



          var isScaling = false;
          var original_props = {};
          function activeSelection_scaling(options) {
            console.log("activeSelection scaling", options);

            const target   = options.target;
            const original = options.transform.original;

            const activeSelection = target;

            if(!isScaling) {

              //store original props
              const activeSelection_icObj_propDict = {
                homeScale:  Object.assign({}, activeSelection.icObj.homeScale),
                scale:      Object.assign({}, activeSelection.icObj.scale),
              };

              original_props["activeSelection_icObj"] = activeSelection_icObj_propDict;

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                const propDict = {
                  homeScale:  Object.assign({}, icObj.homeScale),
                  scale:      Object.assign({}, icObj.scale),
                };

                original_props[icObj.id] = propDict;

              }, fabricIntegration.fabricCanvas.context);

              isScaling = true;
            }



            const scaleFactorX = target.scaleX / original.scaleX;
            const scaleFactorY = target.scaleY / original.scaleY;

            const scaleFactor = {
              X: scaleFactorX,
              Y: scaleFactorY,
            };
            console.log("scaleFactor", scaleFactor);

            switch(options.transform.action) {

              case "scale":
                handle_proportionnal_scale(activeSelection);
                break;

              case "scaleX":
              case "scaleY":
                handle_axis_scale(activeSelection);

                break;
            }

            function handle_proportionnal_scale(activeSelection) {

              //update activeSelection icObj
              {
                const icObj = activeSelection.icObj;

                var homeScale_new;

                const original_homeScale = original_props["activeSelection_icObj"].homeScale;

                homeScale_new = {
                  X: original_homeScale.X / scaleFactor.X,
                  Y: original_homeScale.Y / scaleFactor.Y,
                };

                console.log("homeScale_new", homeScale_new);

                const icObj_update = {
                  homeScale: homeScale_new,
                };

                const icObj_new = Object.assign({}, icObj);
                Object.assign(icObj_new, icObj_update);

                icObj.update(icObj_new, false);
              }


              //update children

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                //update scale
                {
                  var homeScale_new;

                  const original_homeScale = original_props[icObj.id].homeScale;

                  homeScale_new = {
                    X: original_homeScale.X / scaleFactor.X,
                    Y: original_homeScale.Y / scaleFactor.Y,
                  };

                  console.log("homeScale_new", homeScale_new);

                  const icObj_update = {
                    homeScale: homeScale_new,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new, icObj_update);

                  icObj.update(icObj_new, false);
                }


                //update position
                {

                  const activeSelectionCenterX = activeSelection.width / 2;
                  const activeSelectionCenterY = activeSelection.height / 2;

                  const fObj_pos_wrt_ASTL = {
                    left: activeSelectionCenterX + fObj.left,
                    top:  activeSelectionCenterY + fObj.top,
                  };

                  const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

                  const fObj_screenPos = {
                    x: activeSelection.left + scaleFactor.X * (Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left - Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
                    y: activeSelection.top  + scaleFactor.Y * (Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
                  };

                  const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.position, position_update);

                  icObj.update(icObj_new, false);

                }
              });

            }

            function handle_axis_scale(activeSelection) {

              activeSelection.forEachObject((fObj, index, arr_fObj) => {
                const icObj = fObj.icObj;

                //update scale
                {
                  var scale_new;

                  const original_scale = original_props[icObj.id].scale;

                  scale_new = {
                    X: original_scale.X * scaleFactor.X,
                    Y: original_scale.Y * scaleFactor.Y,
                  };

                  console.log("scale_new", scale_new);

                  const icObj_update = {
                    scale: scale_new,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new, icObj_update);

                  icObj.update(icObj_new, false);
                }


                var fObj_sign = {
                  X:+1,
                  Y:+1
                };
                switch(options.originX) {
                  case "left":
                    fObj_sign.X = +1;
                    break;
                  case "right":
                    fObj_sign.X = -1;
                    break;
                }

                switch(options.originY) {
                  case "top":
                    fObj_sign.Y = +1;
                    break;
                  case "bottom":
                    fObj_sign.Y = -1;
                    break;
                }


                //update position
                {

                  const activeSelectionCenterX = fObj_sign.X * activeSelection.width / 2;
                  const activeSelectionCenterY = fObj_sign.Y * activeSelection.height / 2;

                  const fObj_pos_wrt_ASTL = {
                    left: activeSelectionCenterX + fObj_sign.X * fObj.left,
                    top:  activeSelectionCenterY + fObj_sign.Y * fObj.top,
                  };

                  const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

                  const fObj_screenPos = {
                    x: activeSelection.left + scaleFactor.X * (Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left - Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
                    y: activeSelection.top  + scaleFactor.Y * (Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
                  };

                  const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.position, position_update);

                  icObj.update(icObj_new, false);

                }

                //update flip
                {
                  const flip_update = {
                    X: (activeSelection.flipX != null) ? activeSelection.flipX : false,
                    Y: (activeSelection.flipY != null) ? activeSelection.flipY : false,
                  };

                  const icObj_new = Object.assign({}, icObj);
                  Object.assign(icObj_new.flip, flip_update);

                  icObj.update(icObj_new, false);
                }

              });

            }


          }

          function activeSelection_scaled(activeSelection) {
            isScaling = false;
            original_props = {};
          }





          function activeSelection_rotating(options) {
            console.log("activeSelection rotating", options);

            const target   = options.transform.target;
            // const original = options.transform.original;

            const activeSelection = target;

            activeSelection.forEachObject((fObj, index, arr_fObj) => {
              const icObj = fObj.icObj;

              const activeSelectionCenterX = activeSelection.width / 2;
              const activeSelectionCenterY = activeSelection.height / 2;

              const fObj_pos_wrt_ASTL = {
                left: activeSelectionCenterX + fObj.left,
                top:  activeSelectionCenterY + fObj.top,
              };

              const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

              const fObj_screenPos = {
                x: activeSelection.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left - Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top,
                y: activeSelection.top  + Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top,
              };

              const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);




              const fObj_angle = target.angle + fObj.angle;
              const orientation_update = Geometry.boundedAngleInDegrees(fObj_angle + infiniteCanvas.orientation);

              const icObj_new = Object.assign({}, icObj);

              Object.assign(icObj_new.position, position_update);
              icObj_new.orientation = orientation_update;

              icObj.update(icObj_new, false);
            });

          }


        }







        addListeners(fObj) {

          fObj.on('modified', function(options) {
            console.log("modified", "options", options);
          });

        }



        // createFabricSampleObjectWithCanvasBoundingRect(canvasBoundingTrueRect) {
        //
        //   const trueRect = {
        //     left: canvasBoundingTrueRect.left,
        //     top:  canvasBoundingTrueRect.top,
        //     width:  50,
        //     height: 50,
        //   };
        //
        //   var fObj = new fabric.Rect();
        //   fObj.set({
        //     left:   trueRect.left,
        //     top:    trueRect.top,
        //     width:  trueRect.width,
        //     height: trueRect.height,
        //
        //     // fill: '#f55',
        //     fill: 'red',
        //     // opacity: 0.7,
        //
        //     trueRect : trueRect,
        //   });
        //
        //   //event listeners
        //
        //   fObj.on('moving', function(options) {
        //     console.log("moving", "options", options);
        //
        //     const target = options.target;
        //
        //     const trueRect_left__new = (target.left / scale - offset.dx);
        //     const trueRect_top__new  = (target.top  / scale - offset.dy);
        //
        //     const trueRect_update = {
        //       left: trueRect_left__new,
        //       top:  trueRect_top__new,
        //     };
        //
        //     Object.assign(target.trueRect, trueRect_update);
        //     Object.assign(.trueRect, trueRect_update);
        //
        //   });
        //
        //
        //   var isScaling = false;
        //   var original_trueRect = null;
        //   fObj.on('scaling', function(options) {
        //     console.log("scaling", "options", options);
        //     const original = options.transform.original;
        //
        //     const target   = options.transform.target;
        //
        //     if(!isScaling) {
        //       original_trueRect = Object.assign({}, target.trueRect);
        //       console.log("original_trueRect", original_trueRect);
        //       isScaling = true;
        //     }
        //
        //     const scaleFactorX = target.scaleX / original.scaleX;
        //     const scaleFactorY = target.scaleY / original.scaleY;
        //
        //     console.log("scaleFactorX", scaleFactorX);
        //
        //
        //     const trueRect_width__new  = (original_trueRect.width  * scaleFactorX);
        //     const trueRect_height__new = (original_trueRect.height * scaleFactorY);
        //
        //     console.log("trueRect_width__new", trueRect_width__new);
        //
        //     const trueRect_update = {
        //       width:  trueRect_width__new,
        //       height: trueRect_height__new,
        //     };
        //
        //     // Object.assign(target.trueRect, trueRect_update);
        //     Object.assign(fObj.trueRect, trueRect_update);
        //   });
        //   fObj.on('scaled', function(options) {
        //     console.log("scaled", "options", options);
        //     isScaling = false;
        //     original_trueRect = null;
        //
        //     const original = options.transform.original;
        //     const target   = options.transform.target;
        //
        //     target.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //
        //       //not used:
        //       // width:  target.trueRect.width  * scale,
        //       // height: target.trueRect.height * scale,
        //
        //       //used instead:
        //       width:  target.trueRect.width,
        //       height: target.trueRect.height,
        //
        //       scaleX : original.scaleX,
        //       scaleY : original.scaleY,
        //     });
        //     target.setCoords();
        //   });
        //
        //
        //   fObj.on('modified', function(options) {
        //     console.log("modified", "options", options);
        //   });
        //
        //   fObj.on('selected', function(options) {
        //     console.log("selected", "options", options);
        //     const activeObject   = this.infiniteCanvas.canvas.getActiveObject();
        //
        //     console.log("activeObject.trueRect", activeObject.trueRect);
        //     console.log("activeObject.scaleX", activeObject.scaleX);
        //     console.log("activeObject.scaleY", activeObject.scaleY);
        //
        //
        //   });
        //
        //   // fabric.util.addListener(canvas, 'object:modified', function (event, self) {
        //   //   console.log('object:modified', "event", event);
        //   //
        //   // });
        //
        //   return fObj;
        // }



        addOuterFabricObject(fObj) {
          console.log("addOuterFabricObject", fObj);

          // this.outer_fabric_objects.push(fObj);
          this.fabric_objects.push(fObj);

          const icObj = fObj.icObj;
          this.fObjForIcObj_dict[icObj.id] = fObj;

          this.fabricCanvas.add(fObj);
        }

        // addPureOuterFabricObject(fObj) {
        //   console.log("addPureOuterFabricObject", fObj);
        //
        //   // this.outer_fabric_objects.push(fObj);
        //   this.fabric_objects__pure.push(fObj);
        //
        //   this.fabricCanvas.add(fObj);
        // }

        addInnerFabricObject(fObj) {
          console.log("addInnerFabricObject", fObj);

          // this.inner_fabric_objects.push(fObj);
          this.fabric_objects.push(fObj);

          this.fabricCanvas.add(fObj);
        }


        removeFabricObject(fObj) {
          console.log("removeFabricObject", fObj);

          /*
          //nuke
          // this.fabricCanvas.remove(...this.fabricCanvas.getObjects());
          this.fabricCanvas.remove(...this.fabric_objects);
          */

          console.log("this.fabric_objects.length", this.fabric_objects.length);
          {
            const fabric_objects_new =  Utils.arrayByRemovingElement(this.fabric_objects, fObj);

            this.setFabricObjects(fabric_objects_new);
          }
          console.log("this.fabric_objects.length", this.fabric_objects.length);


          console.log("this.fabric_objects", this.fabric_objects);


          // fObj.remove();
          this.fabricCanvas.remove(fObj);

          /*
          //antinuke
          this.fabricCanvas.add(...this.fabric_objects);
          */

          // console.log("this.fabricCanvas", this.fabricCanvas);
          // this.fabricCanvas.requestRenderAll();
        }


        deselectAll() {
          // this.fabricCanvas.deactivateAll();

          // this.fabricCanvas.discardActiveGroup();
          this.fabricCanvas.discardActiveObject();
          this.fabricCanvas.renderAll();
        }





        // debugFabric() {
        //
        //   const trueRect = {
        //     top:  100,
        //     left: 100,
        //     width: 20,
        //     height: 20,
        //   };
        //
        //   // create a rectangle object
        //   var fObj = new fabric.Rect({
        //     left: trueRect.left,
        //     top: trueRect.top,
        //     fill: 'red',
        //     width: trueRect.width,
        //     height: trueRect.height,
        //     trueRect : trueRect,
        //   });
        //
        //   this.addFabricObject(fObj);
        // }

        // updateFabricObjectsPosition(redrawOccasion) {
        //   console.log("updateFabricObjectsPosition", redrawOccasion);
        //
        //   const offset      = this.infiniteCanvas.offset;
        //   const scale       = this.infiniteCanvas.scale;
        //
        //   this.fabric_objects.forEach((fObj, i) => {
        //     //console.log("fObj A", fObj);
        //
        //     const icObj = fObj.icObj;
        //
        //     const truePos = {
        //       x: icObj.position.x  + offset.dx,
        //       y: icObj.position.y  + offset.dy,
        //     };
        //
        //     fObj.set({
        //       // x: x + offsetX,
        //       // y: y + offsetY,
        //       left: truePos.x * scale.X,
        //       top:  truePos.y * scale.Y,
        //     });
        //
        //     // Object.assign(fObj.trueRect, truePos);
        //     fObj.setCoords();
        //
        //     //console.log("fObj B", fObj);
        //
        //   });
        // }

        updateFabricObjectsPosition(redrawOccasion) {

          switch(redrawOccasion) {
            case RedrawOccasion.scaleChanged:
              this.updateFabricObjectsPosition_zScroll(redrawOccasion);
              break;

            // case RedrawOccasion.orientationChanged:
            //   this.updateFabricObjectsPosition_rScroll();
            //   break;

            default:
              this.updateFabricObjectsPosition_default(redrawOccasion);
              break;
          }

        }

        updateFabricObjectsPosition_zScroll(redrawOccasion) {

          const activeObject = this.fabricCanvas.getActiveObject();

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          if(activeObject instanceof fabric.ActiveSelection) {

            const activeSelection = activeObject;

            this.updateFabricObject_position_zScroll__container(activeSelection);

            const arr_affected   = activeSelection.getObjects()
                                                  .filter(fObj => fObj.icObj.canBeMoved);

            const arr1 = fabric_objects;
            const arr2 = arr_affected;

            let difference = arr1.filter(x => !arr2.includes(x));
            const arr_unaffected = difference;

            arr_affected.forEach((fObj, i) => {
              this.updateFabricObject_position_zScroll__contained(activeSelection, fObj);
            });

            arr_unaffected.forEach((fObj, i) => {
              this.updateFabricObject_position_default(fObj);
            });

          } else {
            fabric_objects.forEach((fObj, i) => {

              if(fObj == activeObject) {
                this.updateFabricObject_position_zScroll__container(fObj);
              } else {
                this.updateFabricObject_position_default(fObj);
              }

            });
          }

        }

        // updateFabricObjectsPosition_rScroll(redrawOccasion) {
        //
        //   const activeObject = this.fabricCanvas.getActiveObject();
        //
        //   // const fabric_objects = this.fabric_objects;
        //   const fabric_objects = this.getFabricObjects();
        //
        //   fabric_objects.forEach((fObj, i) => {
        //
        //     if(fObj == activeObject) {
        //       this.updateFabricObject_position_rScroll(fObj);
        //     } else {
        //       this.updateFabricObject_position_default(fObj);
        //     }
        //
        //   });
        //
        // }


        updateFabricObjectsPosition_default(redrawOccasion) {

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          var fObjs_to_move = [];

          const activeObject = this.fabricCanvas.getActiveObject();
          if(activeObject instanceof fabric.ActiveSelection) {
            const activeSelection = activeObject;

            fObjs_to_move = [activeSelection];

            const arr_affected   = activeSelection.getObjects();

            const arr1 = fabric_objects;
            const arr2 = arr_affected;

            let difference = arr1.filter(x => !arr2.includes(x));
            const arr_unaffected = difference;

            fObjs_to_move.push(...arr_unaffected);

          } else {
            fObjs_to_move = [...fabric_objects];
          }

          fObjs_to_move.forEach((fObj, i) => {
            this.updateFabricObject_position_default(fObj);
          });

        }

        // updateFabricObject_position_rScroll(fObj) {
        //
        //   const infiniteCanvas = this.infiniteCanvas;
        //
        //   const offset      = infiniteCanvas.offset;
        //   const scale       = infiniteCanvas.scale;
        //
        //   const orientation = 0;
        //
        //   const orientationBaseVectors = infiniteCanvas.getOrientationBaseVectors();
        //
        //   // const origin = {
        //   //   x:0,
        //   //   y:0,
        //   // };
        //
        //   // const centerPoint = infiniteCanvas.getTrueCenterPoint();
        //   // console.log("centerPoint", centerPoint);
        //
        //   function compute_fObj_position_vector(icObj) {
        //
        //     const v1_no_orientation = {
        //       x: icObj.position.x,
        //       y: icObj.position.y,
        //     }
        //
        //     const v1_with_orientation = {
        //       x: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.u),
        //       y: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.v),
        //     };
        //
        //     const v1_with_orientation__with_offset = {
        //       x: v1_with_orientation.x + offset.dx,
        //       y: v1_with_orientation.y + offset.dy,
        //     };
        //
        //     const v1_with_orientation__with_offset__scaled = {
        //       x: v1_with_orientation__with_offset.x * scale.X,
        //       y: v1_with_orientation__with_offset.y * scale.Y,
        //     };
        //
        //     return v1_with_orientation__with_offset__scaled;
        //
        //   }
        //
        //
        //
        //   const icObj = fObj.icObj;
        //
        //   const v = compute_fObj_position_vector(icObj);
        //
        //   fObj.set({
        //     // x: x + offsetX,
        //     // y: y + offsetY,
        //     left: v.x,
        //     top:  v.y,
        //
        //     angle: icObj.orientation - orientation,
        //   });
        //
        //   // Object.assign(fObj.trueRect, truePos);
        //   fObj.setCoords();
        //
        // }

        updateFabricObject_position_zScroll__container(fObj) {
          console.log("updateFabricObject_position_zScroll__container", fObj);

          const icObj = fObj.icObj;

          const fObj_screenPos = {
            x: fObj.left,
            y: fObj.top,
          };

          const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);

          const icObj_new = Object.assign({}, icObj);
          Object.assign(icObj_new.position, position_update);

          icObj.update(icObj_new, false);

        }

        updateFabricObject_position_zScroll__contained(activeSelection, fObj) {
          console.log("updateFabricObject_position_zScroll", fObj);

          const scaleFactor = {
            X: activeSelection.scaleX,
            Y: activeSelection.scaleY,
          };

          //update position
          {
            const icObj = fObj.icObj;

            const activeSelectionCenterX = activeSelection.width / 2;
            const activeSelectionCenterY = activeSelection.height / 2;

            const fObj_pos_wrt_ASTL = {
              left: activeSelectionCenterX + fObj.left,
              top:  activeSelectionCenterY + fObj.top,
            };

            const activeSelection_angleInRadians = fabric.util.degreesToRadians(activeSelection.angle);

            const fObj_screenPos = {
              x: activeSelection.left + scaleFactor.X * (Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left - Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
              y: activeSelection.top  + scaleFactor.Y * (Math.sin( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.left + Math.cos( activeSelection_angleInRadians ) * fObj_pos_wrt_ASTL.top),
            };

            const position_update    = infiniteCanvas.toTruePoint(fObj_screenPos);

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new.position, position_update);

            icObj.update(icObj_new, false);

          }

        }


        updateFabricObject_position_default(fObj) {
          console.log("updateFabricObject_position_default", fObj);

          const infiniteCanvas = this.infiniteCanvas;

          const offset      = infiniteCanvas.offset;
          const scale       = infiniteCanvas.scale;

          const orientation = infiniteCanvas.orientation;

          const orientationBaseVectors = infiniteCanvas.getOrientationBaseVectors();

          // const origin = {
          //   x:0,
          //   y:0,
          // };

          // const centerPoint = infiniteCanvas.getTrueCenterPoint();
          // console.log("centerPoint", centerPoint);

          function compute_fObj_position_vector(icObj) {

            const v1_no_orientation = {
              x: icObj.position.x,
              y: icObj.position.y,
            }

            const v1_with_orientation = {
              x: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.u),
              y: Geometry.dotProduct_2d(v1_no_orientation, orientationBaseVectors.v),
            };

            const v1_with_orientation__with_offset = {
              x: v1_with_orientation.x + offset.dx,
              y: v1_with_orientation.y + offset.dy,
            };

            const v1_with_orientation__with_offset__scaled = {
              x: v1_with_orientation__with_offset.x * scale.X,
              y: v1_with_orientation__with_offset.y * scale.Y,
            };

            return v1_with_orientation__with_offset__scaled;

          }



          const icObj = fObj.icObj;

          const v = compute_fObj_position_vector(icObj);

          fObj.set({
            // x: x + offsetX,
            // y: y + offsetY,
            left: v.x,
            top:  v.y,

            angle: icObj.orientation - orientation,
          });

          // Object.assign(fObj.trueRect, truePos);
          fObj.setCoords();
        }






        updateFabricObjectsSize(redrawOccasion) {
          console.log("updateFabricObjectsSize", redrawOccasion);

          switch(redrawOccasion) {
            case RedrawOccasion.scaleChanged:
              this.updateFabricObjectsSize_zScroll();
              break;

            default:
              this.updateFabricObjectsSize_default();
              break;
          }

          // canvas.renderAll();
        }


        updateFabricObjectsSize_zScroll() {

          const activeObject = this.fabricCanvas.getActiveObject();

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          if(activeObject instanceof fabric.ActiveSelection) {

            const activeSelection = activeObject;

            this.updateFabricObject_size_zScroll(activeSelection);

            const arr_affected   = activeSelection.getObjects()
                                                  .filter(fObj => fObj.icObj.canBeMoved);


            const arr1 = fabric_objects;
            const arr2 = arr_affected;

            let difference = arr1.filter(x => !arr2.includes(x));
            const arr_unaffected = difference;

            arr_affected.forEach((fObj, i) => {
              this.updateFabricObject_size_zScroll(fObj);
            });

            arr_unaffected.forEach((fObj, i) => {
              this.updateFabricObject_size_default(fObj);
            });

          } else {
            fabric_objects.forEach((fObj, i) => {

              if(fObj == activeObject) {
                this.updateFabricObject_size_zScroll(fObj);
              } else {
                this.updateFabricObject_size_default(fObj);
              }

            });
          }



        }

        updateFabricObjectsSize_default() {
          console.log("updateFabricObjectsSize_default");

          // const fabric_objects = this.fabric_objects;
          const fabric_objects = this.getFabricObjects();

          fabric_objects.forEach((fObj, i) => {
            this.updateFabricObject_size_default(fObj);
          });

        }



        updateFabricObject_size_zScroll(fObj) {
          console.log("updateFabricObject_size_zScroll", fObj);
          console.log("fObj.icObj", fObj.icObj);

          const scale  = this.infiniteCanvas.scale;

          // if(fObj instanceof fabric.ActiveSelection) {
            // updateActiveSelectionFObj_size_zScroll(fObj);
          // } else {
            updateStdFObj_size_zScroll(fObj);
          // }



          function updateStdFObj_size_zScroll(fObj) {
            console.log("updateFabricObject_size_zScroll", fObj);

            const scale_fObj = {
              X: fObj.scaleX,
              Y: fObj.scaleY,
            };
            console.log("scale_fObj", scale_fObj);

            const icObj = fObj.icObj;


            var homeScale_new;

            if(fObj instanceof fabric.Text) {

              const fontSize_fObj = fObj.fontSize;
              const scaleFactor__fontSize = fObj.fontSize / icObj.fontSize;

              // homeScale_new = {
              //   X: scale.X / scale_fObj.X / scaleFactor__fontSize,
              //   Y: scale.Y / scale_fObj.Y / scaleFactor__fontSize,
              // };

              homeScale_new = {
                X: scale.X / (scale_fObj.X / icObj.scale.X) / scaleFactor__fontSize,
                Y: scale.Y / (scale_fObj.Y / icObj.scale.Y) / scaleFactor__fontSize,
              };

            } else {

              // homeScale_new = {
              //   X: scale.X / scale_fObj.X,
              //   Y: scale.Y / scale_fObj.Y,
              // };

              homeScale_new = {
                X: scale.X / (scale_fObj.X / icObj.scale.X),
                Y: scale.Y / (scale_fObj.Y / icObj.scale.Y),
              };

            }
            console.log("homeScale_new", homeScale_new);

            const icObj_update = {
              homeScale: homeScale_new,
            };

            const icObj_new = Object.assign({}, icObj);
            Object.assign(icObj_new, icObj_update);

            icObj.update(icObj_new, false);

            // fObj.setCoords();

          }

          function updateActiveSelectionFObj_size_zScroll(activeSelection) {

            activeSelection.getObjects().forEach((fObj, i) => {
              updateStdFObj_size_zScroll(fObj);
            });


          }






        }

        updateIcObjWithFObj(fObj) {
          console.log("updateIcObjWithFObj", fObj);

          const offset = this.infiniteCanvas.offset;
          const scale  = this.infiniteCanvas.scale;
          console.log("scale", scale);


          const trueRect_update = {
            left:  fObj.left / scale.X - offset.dx,
            top:   fObj.top  / scale.Y - offset.dy,

            width:  fObj.width  / scale.X,
            height: fObj.height / scale.Y,
          };

          const icObj_update = {
            position: Geometry.createPoint(trueRect_update.left, trueRect_update.top),
            size:     Geometry.createSize(trueRect_update.width, trueRect_update.height),
          };

          const icObj = fObj.icObj;

          const icObj_new = Object.assign({}, icObj);
          Object.assign(icObj_new, icObj_update);

          console.log("icObj_new", icObj_new);

          icObj.update(icObj_new, false);

        }

        updateFabricObject_size_default(fObj) {
          console.log("updateFabricObject_size_default", fObj);


          const scale  = this.infiniteCanvas.scale;
          console.log("scale", scale);

          console.log("scale.X", scale.X);
          console.log("fObj.icObj.homeScale.X", fObj.icObj.homeScale.X);

          const scaleFactorX = scale.X / fObj.icObj.homeScale.X;
          const scaleFactorY = scale.Y / fObj.icObj.homeScale.Y;

          const scaleFactor = {
            X: scaleFactorX,
            Y: scaleFactorY,
          };

          console.log("scaleFactorX", scaleFactorX);



          if(fObj instanceof fabric.Text) {

            // const fontSize = fObj.true_fontSize * scale;
            // const fontSize = fObj.icObj.fontSize * scale.X;
            const fontSize = fObj.icObj.fontSize * scaleFactor.X;

            console.log("fontSize", fontSize);
            // fObj.set({
            //   fontSize: fontSize,
            // });

            const fontSize_max = 10000;
            // if(fontSize > fontSize_max) {
            //
            //   const scaleAmount_fix = (fontSize - fontSize_max) / fontSize_max;
            //   const scale_fix = 1.0 * (1 + scaleAmount_fix);
            //   console.log("scale_fix", scale_fix);
            //
            //   fObj.set({
            //     fontSize: fontSize_max,
            //
            //     scaleX: scale_fix,
            //     scaleY: scale_fix,
            //   });
            //
            // } else {
            //   fObj.set({
            //     fontSize: fontSize,
            //
            //     scaleX: 1,
            //     scaleY: 1,
            //   });
            // }

            function scaleWithTargetFontSize(targetFontSize) {

              const scaleAmount_fix = (fontSize - targetFontSize) / targetFontSize;
              const scale_fix = {
                X: fObj.icObj.scale.X * (1 + scaleAmount_fix),
                Y: fObj.icObj.scale.Y * (1 + scaleAmount_fix),
              };
              console.log("scale_fix", scale_fix);

              fObj.set({
                fontSize: targetFontSize,

                scaleX: scale_fix.X,
                scaleY: scale_fix.Y,
              });

            }

            if(fontSize > fontSize_max) {

              scaleWithTargetFontSize(fontSize_max);

            } else {
              // fObj.set({
              //   fontSize: fontSize,
              //
              //   scaleX: fObj.icObj.scale.X,
              //   scaleY: fObj.icObj.scale.Y,
              // });

              const closestIntegerFontSize = Math.max(1, Math.floor(fontSize));

              scaleWithTargetFontSize(closestIntegerFontSize);

            }



          }
          // else if(fObj instanceof fabric.Image) {
          //
          //   // fObj.scale(scale);
          //
          //   const width  = fObj.icObj.img.width  * scale.X;
          //   const height = fObj.icObj.img.height * scale.Y;
          //
          //   fObj.scaleToWidth(width);
          //   fObj.scaleToHeight(height);
          //
          // } else if(fObj instanceof fabric.Rect) {
          else {

            console.log("fObj", fObj);
            fObj.set({
              scaleX: fObj.icObj.scale.X * scaleFactor.X,
              scaleY: fObj.icObj.scale.Y * scaleFactor.Y,
            });

          }
          // else {
          //   console.log("unknown instance type");
          // }

          fObj.setCoords();

        }







        //free drawing

        initializeFreeDrawing() {

          // this.fabricCanvas.isDrawingMode = true;

          if (fabric.PatternBrush) {
              var vLinePatternBrush = new fabric.PatternBrush(canvas);
              vLinePatternBrush.getPatternSrc = function() {

                var patternCanvas = fabric.document.createElement('canvas');
                patternCanvas.width = patternCanvas.height = 10;
                var ctx = patternCanvas.getContext('2d');

                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(0, 5);
                ctx.lineTo(10, 5);
                ctx.closePath();
                ctx.stroke();

                return patternCanvas;
              };

              var hLinePatternBrush = new fabric.PatternBrush(canvas);
              hLinePatternBrush.getPatternSrc = function() {

                var patternCanvas = fabric.document.createElement('canvas');
                patternCanvas.width = patternCanvas.height = 10;
                var ctx = patternCanvas.getContext('2d');

                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(5, 0);
                ctx.lineTo(5, 10);
                ctx.closePath();
                ctx.stroke();

                return patternCanvas;
              };

              var squarePatternBrush = new fabric.PatternBrush(canvas);
              squarePatternBrush.getPatternSrc = function() {

                var squareWidth = 10, squareDistance = 2;

                var patternCanvas = fabric.document.createElement('canvas');
                patternCanvas.width = patternCanvas.height = squareWidth + squareDistance;
                var ctx = patternCanvas.getContext('2d');

                ctx.fillStyle = this.color;
                ctx.fillRect(0, 0, squareWidth, squareWidth);

                return patternCanvas;
              };

              var diamondPatternBrush = new fabric.PatternBrush(canvas);
              diamondPatternBrush.getPatternSrc = function() {

                var squareWidth = 10, squareDistance = 5;
                var patternCanvas = fabric.document.createElement('canvas');
                var rect = new fabric.Rect({
                  width: squareWidth,
                  height: squareWidth,
                  angle: 45,
                  fill: this.color
                });

                var canvasWidth = rect.getBoundingRect().width;

                patternCanvas.width = patternCanvas.height = canvasWidth + squareDistance;
                rect.set({ left: canvasWidth / 2, top: canvasWidth / 2 });

                var ctx = patternCanvas.getContext('2d');
                rect.render(ctx);

                return patternCanvas;
              };

              var img = new Image();
              img.src = '../assets/honey_im_subtle.png';

              var texturePatternBrush = new fabric.PatternBrush(canvas);
              texturePatternBrush.source = img;
            }

        }


        enterFreeDrawing() {
          const fabricIntegration = this;

          const brush = this.fabricCanvas.freeDrawingBrush;

          brush.width = 20;
          brush.color = this.inputProperties.getActiveColor();



          this.fabricCanvas.isDrawingMode = true;

          this.current_freeDrawing_objects = [];
          function freeDrawing_objectAdded(e) {
            console.log("freeDrawing_objectAdded",e);
            fabricIntegration.current_freeDrawing_objects.push(e.target);
            // console.log("fabricIntegration.current_freeDrawing_objects", fabricIntegration.current_freeDrawing_objects);
          }

          this.freeDrawing_objectAdded = freeDrawing_objectAdded;
          this.fabricCanvas.on('object:added', this.freeDrawing_objectAdded);

        }

        leaveFreeDrawing() {
          this.fabricCanvas.isDrawingMode = false;
          this.fabricCanvas.off('object:added', this.freeDrawing_objectAdded);

          //get newly created fabric objects
          // var last = canvas_objects[canvas_objects.length -1]; //Get last object
          const freeDrawing_objects_created = [...this.current_freeDrawing_objects];
          this.current_freeDrawing_objects = [];

          this.manageCreatedFreeDrawingObjects(freeDrawing_objects_created);

        }

        manageCreatedFreeDrawingObjects(arr_fObj) {
          console.log("manageCreatedFreeDrawingObjects", arr_fObj);

          //group newly created fabric objects (or not (for easy delete))

          //create icObj from fObj
          arr_fObj.forEach((fObj) => {
            const icObj = this.infiniteCanvas.createIcFreeDrawing_from_freeDrawingFObj(fObj);
            fObj.icObj = icObj;

            //add inner fabric object
            this.fabric_objects.push(fObj);
            this.infiniteCanvas.addNewIcObject(icObj);
          });

        }






        deleteSelection() {
          const fabricIntegration = this;

          const fObj = this.fabricCanvas.getActiveObject();

          function deleteFObj(fObj_to_delete) {
            fObj_to_delete.icObj.delete_p()
            .then(() => {
              fabricIntegration.removeFabricObject(fObj_to_delete);
            })
            .catch(err => {
              console.log("fObj.icObj.delete_p", "error", err);
            });
          }

          if(fObj instanceof fabric.ActiveSelection) {

            fObj.getObjects().forEach((fObj, i) => {
              deleteFObj(fObj);
            });

            this.fabricCanvas.discardActiveObject();
            this.fabricCanvas.requestRenderAll();

          } else {

            deleteFObj(fObj);

          }


        }


        shouldIgnoreShortcutInput() {
          var outBool;

          const fObj = this.fabricCanvas.getActiveObject();
          if(fObj) {
            outBool = fObj.isEditing;
          } else {
            outBool = false;
          }

          return outBool;
        }




        initializeFabricObjectCopyPaste() {
          const fabricIntegration = this;

          const legacyOnCopyFunc = document.oncopy;
          document.oncopy = function(event) {

            if(legacyOnCopyFunc) {
              legacyOnCopyFunc(event);
            }

            fabricIntegration.copySelection(event);
            // copy();
          };

          // const legacyOnPasteFunc = document.onpaste;
          // document.onpaste = function(event) {
          //
          //   if(false) {
          //     if(legacyOnPasteFunc) {
          //       legacyOnPasteFunc(event);
          //     }
          //   } else {
          //     fabricIntegration.pasteFabricObjects(event);
          //     // paste();
          //   }
          // };


          // const fabricCanvas = this.fabricCanvas;
          // var _clipboard;
          // function copy() {
          // 	// clone what are you copying since you
          // 	// may want copy and paste on different moment.
          // 	// and you do not want the changes happened
          // 	// later to reflect on the copy.
          // 	fabricCanvas.getActiveObject().clone(function(cloned) {
          // 		_clipboard = cloned;
          // 	});
          // }

          // function paste() {
          // 	// clone again, so you can do multiple copies.
          // 	_clipboard.clone(function(clonedObj) {
          // 		fabricCanvas.discardActiveObject();
          // 		clonedObj.set({
          // 			left: clonedObj.left + 10,
          // 			top: clonedObj.top + 10,
          // 			evented: true,
          // 		});
          // 		if (clonedObj.type === 'activeSelection') {
          // 			// active selection needs a reference to the canvas.
          // 			clonedObj.canvas = fabricCanvas;
          // 			clonedObj.forEachObject(function(obj) {
          // 				fabricCanvas.add(obj);
          // 			});
          // 			// this should solve the unselectability
          // 			clonedObj.setCoords();
          // 		} else {
          // 			fabricCanvas.add(clonedObj);
          // 		}
          //
          // 		_clipboard.top += 10;
          // 		_clipboard.left += 10;
          //
          // 		fabricCanvas.setActiveObject(clonedObj);
          // 		fabricCanvas.requestRenderAll();
          // 	});
          // }

        }

        copySelection(event) {
          console.log("copySelection", event);

          this.fabricCanvas.getActiveObject().clone(function(cloned) {
            // _clipboard = cloned;
            navigator.clipboard.write(cloned).then(function() {
              /* success */
              console.log("success");
            }, function() {
              /* failure */
              console.log("failure");
            });

          });
        }

        pasteFabricObjects(event) {
          console.log("pasteFabricObjects", event);

          const clipboardData = event.clipboardData;
          // _clipboard.clone(function(clonedObj) {
          navigator.clipboard.read()
          .then((items) => {
            console.log("items", items);
          })
          .catch((err) => {
            console.log("err", err);
          });


          clipboardData.clone(function(clonedObj) {
            fabricCanvas.discardActiveObject();
            clonedObj.set({
              left: clonedObj.left + 10,
              top: clonedObj.top + 10,
              evented: true,
            });
            if (clonedObj.type === 'activeSelection') {
              // active selection needs a reference to the canvas.
              clonedObj.canvas = fabricCanvas;
              clonedObj.forEachObject(function(obj) {
                fabricCanvas.add(obj);
              });
              // this should solve the unselectability
              clonedObj.setCoords();
            } else {
              fabricCanvas.add(clonedObj);
            }

            _clipboard.top += 10;
            _clipboard.left += 10;

            fabricCanvas.setActiveObject(clonedObj);
            fabricCanvas.requestRenderAll();
          });
        }

        setAntiAliasEnabled(enabled) {
          console.log("setAntiAliasEnabled", enabled);
          this.fabricCanvas.imageSmoothingEnabled = enabled;
          this.fabricCanvas.requestRenderAll();
        }




        //Groups

        groupSelectedObjects() {

          //get selected objects
          const canvas = this.fabricCanvas;

          if (!canvas.getActiveObject()) {
            return;
          }
          if (canvas.getActiveObject().type !== 'activeSelection') {
            return;
          }

          const activeSelection = canvas.getActiveObject();
          console.log("activeSelection to create group", activeSelection);

          const fObj = canvas.getActiveObject().toGroup();
          console.log("fabric created group", fObj);

          // const fObj_childObjects = fObj.getObjects();
          // console.log("fObj_childObjects", fObj_childObjects);

          const icObj = infiniteCanvas.createIcGroup_from_groupFObj(fObj);
          fObj.icObj = icObj;

          //debug
          // const fRect = new fabric.Rect();
          // fRect.set({
          //   left:   fObj.left,
          //   top:    fObj.top,
          //   width:  fObj.width,
          //   height: fObj.height,
          //
          //   fill: 'red',
          // });
          // this.fabricCanvas.add(fRect);

          {
            const fRect = new fabric.Rect();

            const trueRect  = infiniteCanvas.toTrueRect(fObj);
            const position  = Geometry.getPointTL(trueRect);
            const size      = Geometry.createSize(trueRect.width, trueRect.height);

            const homeScale = Object.assign({}, infiniteCanvas.scale);

            const type = "rect";
            const icObj = infiniteCanvas.createIcObject(type, position, size, homeScale);

            const position_screen = icObj.getScreenPositionWithoutOffset();
            // console.log("position_screen", position_screen);
            const homeSize_screen = icObj.getHomeScreenSize();
            // console.log("homeSize_screen", homeSize_screen);

            fRect.set({
              left:   position_screen.x,    //SHU: ??? where is infiniteCanvas.offset taking part ???
              top:    position_screen.y,

              width:  homeSize_screen.width,
              height: homeSize_screen.height,

              fill: 'red',
            });

            this.fabricCanvas.add(fRect);
          }



          //test pour le moment
          // this.fabricCanvas.remove(fObj);



          icObj.children.forEach((child_icObj, i) => {
            infiniteCanvas.removeIcObject(child_icObj);
          });
          infiniteCanvas.addIcObject(icObj);


          canvas.requestRenderAll();

        }

        ungroupSelectedObject() {

          const canvas = this.fabricCanvas;

          if (!canvas.getActiveObject()) {
            return;
          }
          if (canvas.getActiveObject().type !== 'group') {
            return;
          }
          canvas.getActiveObject().toActiveSelection();
          canvas.requestRenderAll();

        }





        syncWithIcObj(icObj) {
          const fObj = this.getFObjForIcObj(icObj);
          this.updateFObjWithIcObj(fObj, icObj);

          this.fabricCanvas.requestRenderAll();
          // this.fabricCanvas.renderAll();
        }

        getFObjForIcObj(icObj) {
          const fObj = this.fObjForIcObj_dict[icObj.id];

          if(!fObj) {
            console.log("icObj", icObj);
            console.log("this.fObjForIcObj_dict", this.fObjForIcObj_dict);
            throw new Error("fObj not found for icObj.id: "+ icObj.id);
          }

          return fObj;
        }

        updateFObjWithIcObj(fObj, icObj) {
          console.log("updateFObjWithIcObj", fObj, icObj);

          function configureWithIsActive(fObj, isActive) {

            const cfg = isActive ? fObj.icObj.activeCfg : fObj.icObj.inactiveCfg;

            fObj.set({
              fill:    cfg.fill,
              opacity: cfg.opacity,
            });

            fObj.set("dirty", true);
          }

          configureWithIsActive(fObj, icObj.isActive);

          // fObj.setCoords();
        }


      }


















/*******************/
/** utils  **/


      class Utils {

        static arrayByRemovingElement(src_arr, elt) {

          const index = src_arr.indexOf(elt);

          return this.arrayByRemovingElementAtIndex(src_arr, index);
        }

        static arrayByRemovingElementAtIndex(src_arr, index) {

          const arr = [...src_arr]; //create shallow copy of src_arr

          const arr_removed = arr.splice(index, 1);   //starting at index, remove 1 element
          const arr_new     = arr;                    //array is mutated in place

          return arr;
        }
      }

      class Geometry {

        static createPoint(x, y) {
          const point = {
            x : x,
            y : y,
          };
          return point;
        }

        static createRect(x,y,w,h) {
          const rect = {
            left: x,
            top: y,
            width: w,
            height: h,
          };
          return rect;
        }



        static createLine(point0, point1) {
          const line = {
            x0 : point0.x,
            y0 : point0.y,

            x1 : point1.x,
            y1 : point1.y,
          }
          return line;
        }

        static createTriangle() {
          const pointA = Geometry.createPoint(100,100);
          const pointB = Geometry.createPoint(0,300);
          const pointC = Geometry.createPoint(-100, -200);

          const lineAB = Geometry.createLine(pointA, pointB);
          const lineAC = Geometry.createLine(pointA, pointC);
          const lineBC = Geometry.createLine(pointB, pointC);

          const lines = [lineAB, lineAC, lineBC];
          return lines;
        }

        static createAxes() {
          const length = 10000;

          const pointX0 = Geometry.createPoint(     0,0);
          const pointX1 = Geometry.createPoint(length,0);
          const lineX   = Geometry.createLine(pointX0, pointX1);

          const pointY0 = Geometry.createPoint(0,0);
          const pointY1 = Geometry.createPoint(0,length);
          const lineY   = Geometry.createLine(pointY0, pointY1);

          const lines = [lineX, lineY];
          return lines;
        }



        static createSize(width, height) {
          const size = {
            width  : width,
            height : height,
          };
          return size;
        }






        static containedRect(containerRect, size) {
          var outRect;

          const containerSize = {
            width:  containerRect.width,
            height: containerRect.height,
          };
          const containedSize_ = Geometry.containedSize(containerSize, size);


          const center  = Geometry.getCenterPoint(containerRect);
          const offset  = {
            dx: - containedSize_.width /2,
            dy: - containedSize_.height /2,
          };
          const pointTL = Geometry.createPointWithOffset(center, offset);


          outRect = createRect(pointTL.x, pointTL.y, containedSize_.width, containedSize_.height);
          return outRect;
        }

        static getPointTL(rect) {
          const pointTL = Geometry.createPoint(rect.left, rect.top);
          return pointTL;
        }

        static getPointBR(rect) {
          const pointBR = Geometry.createPoint(rect.left + rect.width, rect.top + rect.height);
          return pointBR;
        }

        static getCenterPoint(rect) {
          const pointTL = Geometry.getPointTL(rect);
          const offset = {
            dx: rect.width /2,
            dy: rect.height /2,
          };
          return Geometry.createPointWithOffset(pointTL, offset);
        }

        static createPointWithOffset(point, offset) {
          return Geometry.createPoint(point.x + offset.dx, point.y + offset.dy);
        }

        static containedSize(containerSize, size) {
          var outSize;

          const size_ratio__container = containerSize.width / containerSize.height;
          const size_ratio__rect      = size.width / size.height;

          //console.log("size_ratio__container", size_ratio__container);
          //console.log("size_ratio__rect", size_ratio__rect);


          var scaleFactor;
          if(size_ratio__container > size_ratio__rect) {
            scaleFactor = containerSize.height / size.height;
          } else {
            scaleFactor = containerSize.width / size.width;
          }

          //console.log("scaleFactor", scaleFactor);


          outSize = {
            width:  size.width  * scaleFactor,
            height: size.height * scaleFactor,
          }

          return outSize;
        }



        static dotProduct_2d(v1,v2) {
        	return v1.x * v2.x + v1.y * v2.y;
        }

        static norm_2d(v1) {
          return Math.sqrt(Geometry.dotProduct_2d(v1,v1));
        }

        static vector_3d(v1, z = 0) {
          return {
            x: v1.x,
            y: v1.y,
            z: z,
          };
        }

        static dotProduct_3d(v1,v2) {
        	return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
        }

        static crossProduct_3d(v1,v2) {
        	return {
        		x: v1.y * v2.z - v1.z * v2.y,
        		y: v1.z * v2.x - v1.x * v2.z,
        		z: v1.x * v2.y - v1.y * v2.x,
        	};
        }

        static boundedAngleInDegrees(angleInDegrees) {

          var angleInDegrees_bounded = angleInDegrees;

          angleInDegrees_bounded = angleInDegrees_bounded % 360;
          if(angleInDegrees_bounded < 0) {
            angleInDegrees_bounded += 360;
          }

          return angleInDegrees_bounded;
        }

        static pointWithRotation(point_from, point_center, angleInDegrees) {
          console.log("pointWithRotation", point_from, point_center, angleInDegrees);

          const v = {
            x: point_from.x - point_center.x,
            y: point_from.y - point_center.y,
          };
          console.log("v.x", v.x);
          console.log("v.y", v.y);

          // const radius = Geometry.norm_2d(v);

          const angleInRadians = angleInDegrees / 180 * Math.PI;

          const dx = Math.cos(angleInRadians) * v.x - Math.sin(angleInRadians) * v.y;
          const dy = Math.sin(angleInRadians) * v.x + Math.cos(angleInRadians) * v.y;
          console.log("dx", dx);
          console.log("dy", dy);


          const point_to = {
            x: point_center.x + dx,
            y: point_center.y + dy,
          };


          return point_to;
        }

        static getPointFromRectToRect(point_from, rect_from, rect_to) {
          const point_to = {
            x: point_from.x * ( rect_to.width /  rect_from.width),
            y: point_from.y * (rect_to.height / rect_from.height),
          };

          return point_to;
        }


      }






//I/O

      class FileIntegration {

        constructor() {

          this.onPasteImageListeners = [];
          this.onPasteTextListeners  = [];
          // this.onPastePdfListeners = [];

          const fileIntegration = this;
          document.onpaste = function(event) {
            console.log("onpaste", "event", event);

            // get text representation of clipboard
            var text = (event.originalEvent || event).clipboardData.getData('text/plain');
            if(text) {
              console.log("text", text);
              fileIntegration.onPasteTextListeners.forEach((listener, i) => {
                listener(text);
              });
            } else {
              console.log("not a text");

              FileIntegration.getPastedFile_p(event)
              .then(FileIntegration.createImage_p)
              .then(img => {
                fileIntegration.onPasteImageListeners.forEach((listener, i) => {
                  listener(img);
                });
              });

            }


          };

          // document.oncopy = function(event) {
          //
          // };

        }

        static openFileDialog (accept, callback) {

            // Create an input element
            var inputElement = document.createElement("input");

            // Set its type to file
            inputElement.type = "file";

            // Set accept to the file types you want the user to select.
            // Include both the file extension and the mime type
            inputElement.accept = accept;

            // set onchange event to call callback when user has selected file
            inputElement.addEventListener("change", callback)

            // dispatch a click event to open the file dialog
            inputElement.dispatchEvent(new MouseEvent("click"));

        }

        static openFile_p(accept) {

          return new Promise((resolve, reject) => {

            FileIntegration.openFileDialog(accept, event => {
              const fileList = event.target.files;
              ////console.log("fileList:", fileList);

              const file = fileList[0];
              //console.log("file", file);

              resolve(file);
            });
          });

        }




        // static addImageFromFile_p(file) {
        //
        //   function addZimageForImg(img) {
        //     //console.log("img", img);
        //
        //     // const zimage = createZimageWithCurrentBoundingRect(img);
        //
        //     const canvasBoundingTrueRect = getCanvasBoundingTrueRect();
        //
        //     // object-fit : contain
        //     const img_size = {
        //       width: img.width,
        //       height: img.height
        //     };
        //     const trueRect = containedRect(canvasBoundingTrueRect, img_size);
        //
        //     const zimage = createZimage(img, trueRect);
        //
        //     addZimage(zimage);
        //
        //     redrawCanvas();
        //   }
        //
        //   function addFabricImageForImg(img) {
        //     //console.log("img", img);
        //
        //     // const zimage = createZimageWithCurrentBoundingRect(img);
        //
        //     const canvasBoundingTrueRect = getCanvasBoundingTrueRect();
        //
        //     // object-fit : contain
        //     const img_size = {
        //       width: img.width,
        //       height: img.height
        //     };
        //     const trueRect = containedRect(canvasBoundingTrueRect, img_size);
        //
        //     const fabricImage = createFabricImage(img, trueRect);
        //     addFabricObject(fabricImage);
        //
        //     redrawCanvas();
        //   }
        //
        //   return createImage_p(file)
        //         .then(img => {
        //           // addZimageForImg(img);
        //           addFabricImageForImg(img);
        //         });
        //
        // }



        //IMPORT image

        static importImage_p() {
          const accept = ".jpg, .jpeg, .png";
          return FileIntegration.openFile_p(accept)
                .then(FileIntegration.createImage_p);
        }


        static createImage_p(file) {
          return FileIntegration.getFileData_p(file)
                .then(FileIntegration.dataToImgSrc_p)
                .then(FileIntegration.imageFromImgSrc_p);
        }

        static imageFromImgSrc_p(imgSrc) {
          //console.log('imgSrc', imgSrc);
          // return new Promise(r => img.onload=r, img.src=imgSrc)
          return new Promise((resolve, reject) => {
            const img   = new Image();
            img.onload  =      () => resolve(img);
            img.onerror = (error) => reject(error);

            img.src = imgSrc;
          });
        }

        static dataToImgSrc_p(data) {
          var imgSrc_p;

          if(data.startsWith("data:image")) {
            imgSrc_p = Promise.resolve(data);
          } else {
            imgSrc_p = FileIntegration.dataToBlob_p(data)
                  .then(blob1 => {
                    //change blob type
                    const blob2 = new Blob([blob1], {type: 'image/png'})
                    return blob2;
                  })
                  .then(FileIntegration.getFileData_p);
                  // .then(blob2 => {
                  //   const imgSrc = URL.createObjectURL(blob2);
                  //   ////console.log("converted imgSrc:", imgSrc);
                  //   //>>converted imgSrc: blob:http://localhost:8080/7243f1de-493f-412b-b1ec-b042b0cbcac4
                  //   return imgSrc;
                  // });
          }

          return imgSrc_p;
        }

        static dataToBlob_p(data) {
          return fetch(data)
                 .then(res => res.blob());
        }


        //file utils

        static getFileData_p(file) {
          ////console.log("getFileData_p", file);

          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function(evt) {
               const file_url = evt.target.result; //<=> var file_url = reader.result;
               ////console.log("file_url:", file_url);
               resolve(file_url);
            };
            reader.readAsDataURL(file);
          });

        }

        static getFileText_p(file) {
          ////console.log("getFileText_p", file);

          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function(evt) {
               const file_url = evt.target.result; //<=> var file_url = reader.result;
               ////console.log("file_url:", file_url);
               resolve(file_url);
            };
            reader.readAsText(file);
          });

        }







        //PASTE image


        static getPastedFile_p(event) {
          var outPromise;

          var items = (event.clipboardData || event.originalEvent.clipboardData).items;
          //console.log(JSON.stringify(items)); // will give you the mime types

          const arr_files = Object.values(items)
                                .filter(item => item.kind == 'file')
                                .map(item => item.getAsFile());

          if(arr_files.length == 1) {
            const file = arr_files.find(e => true);
            outPromise = Promise.resolve(file);
          } else {
            const error = new Error("arr_files.length != 1");
            outPromise = Promise.reject(error);
          }

          return outPromise;
        }





        //SAVE / LOAD

        static save_to_file(obj) {

          const json = JSON.stringify(obj);

          const filename = "infinishute.json";
          FileIntegration.download(json, filename, 'text/json');
        }

        static download(content, fileName, contentType) {
          var a = document.createElement("a");
          var file = new Blob([content], {type: contentType});
          a.href = URL.createObjectURL(file);
          a.download = fileName;
          a.click();
        }


        // static objByConvertingImagesToBase64_p(obj) {
        //
        //   const zimages_raw = obj.zimages;
        //
        //   const arr__zimages_serial_p = zimages_raw.map(zimage => {
        //
        //     //console.log("zimage", zimage);
        //     const imgSrc_base64_p = FileIntegration.dataUrlForImgViaCanvas_p(zimage.img);
        //
        //     return imgSrc_base64_p
        //            .then(imgSrc_base64 => {
        //
        //              const zimage_serial = {
        //                imgSrc_base64:  imgSrc_base64,
        //                trueRect:       zimage.trueRect,
        //              };
        //
        //              return zimage_serial;
        //            });
        //
        //   });
        //
        //   return Promise.all(arr__zimages_serial_p)
        //          .then(arr__zimages_serial => {
        //
        //            const obj2 = {};
        //
        //            obj2.zimages  = arr__zimages_serial;
        //            obj2.drawings = obj.drawings;
        //
        //            return obj2;
        //          });
        // }

        static objByConvertingImagesToBase64_p(obj) {

          const zimages_raw = obj.zimages;

          const arr__zimages_serial_p = zimages_raw.map(zimage => {

            //console.log("zimage", zimage);
            const imgSrc_base64_p = FileIntegration.dataUrlForImgViaCanvas_p(zimage.img);

            return imgSrc_base64_p
                   .then(imgSrc_base64 => {

                     const zimage_serial = {
                       imgSrc_base64:  imgSrc_base64,
                       trueRect:       zimage.trueRect,
                     };

                     return zimage_serial;
                   });

          });

          return Promise.all(arr__zimages_serial_p)
                 .then(arr__zimages_serial => {

                   const obj2 = {};

                   obj2.zimages  = arr__zimages_serial;
                   obj2.drawings = obj.drawings;

                   return obj2;
                 });
        }



        static saveInfinishute_p(infiniShute) {

          // const obj = {
          //   // zimages  : zimages,
          //   // drawings : drawings,
          //
          //   infiniteCanvas: infiniteCanvas,
          // };
          // //console.log("obj", obj);
          //
          // FileIntegration.objByConvertingImagesToBase64_p(obj)
          // .then(obj2 => {
          //   //console.log("obj2", obj2);
          //   FileIntegration.save_to_file(obj2);
          // });

          FileIntegration.save_to_file(infiniShute);

          //?
          return Promise.resolve(true);
        }

        static loadInfinishute_p() {
          const accept = ".json";
          return FileIntegration.openFile_p(accept)
                .then(FileIntegration.createJson_p)
                // .then(FileIntegration.createInfinishute_p);
                // .then(infinishute => {
                //   configureWithInfinishute(infinishute);
                // });
        }

        static createJson_p(file) {
          return FileIntegration.getFileText_p(file)
                .then(text => {
                  //console.log("text:", text);

                  const json = JSON.parse(text);
                  //console.log("json:", json);
                  return json;
                });

        }

        // static createInfinishute_p(json) {
        //   const infinishute = {};
        //
        //   infinishute.drawings = json.drawings;
        //
        //   const zimages_serial = json.zimages;
        //   const arr__zimage_p = zimages_serial.map(zimage_serial => {
        //
        //     const imgSrc = zimage_serial.imgSrc_base64;
        //     return FileIntegration.imageFromImgSrc_p(imgSrc)
        //            .then(image => {
        //              const zimage = {
        //                img: image,
        //                trueRect: zimage_serial.trueRect,
        //              };
        //
        //              return zimage;
        //            });
        //   })
        //
        //   return Promise.all(arr__zimage_p)
        //                 .then(zimages => {
        //                   infinishute.zimages = zimages;
        //
        //                   return infinishute;
        //                 });
        //
        // }

        // static createInfinishute_p(json) {
        //   const infinishute = {};
        //
        //   return json;
        // }


        static dataUrlForImgViaCanvas_p(img) {

          const src = img.src;

          const outputFormat = "image/png";

          return new Promise((resolve, reject) => {
            var imgAux = new Image();

            imgAux.crossOrigin = 'Anonymous';
            imgAux.onload = function() {
              var canvasAux = document.createElement('CANVAS');
              var ctxAux    = canvasAux.getContext('2d');
              var dataURL;
              canvasAux.height = this.naturalHeight;
              canvasAux.width  = this.naturalWidth;
              ctxAux.drawImage(this, 0, 0);
              dataURL = canvasAux.toDataURL(outputFormat);
              resolve(dataURL);
            };
            imgAux.onerror = (error) => reject(error);

            imgAux.src = src;
          });

        }

      }



      //SHU: need rxjs to do it cleanly
      class ClipboardObject {
        constructor(source, content) {
          this.source  = source;
          this.content = content;
        }
      }

      class ClipboardIntegration {

        constructor(arr_sources) {
          this.arr_sources = arr_sources;
          // this.fileIntegration   = fileIntegration;
          // this.fabricIntegration = fabricIntegration;

          this.arr_paste_p = arr_sources.map(source => source.paste_p);

          this.myClipboardObj = null;
        }

        manageCopy(source, content) {

          const cbObj = new ClipboardObject(source, content);

          this.myClipboardObj = cbObj;
        }

        managePaste() {

          if(false) {

          }

          if(source == fileIntegration) {

          } else if(source == fabricIntegration) {

          }

        }



      }










//User Input

      class InputProperties {
        constructor() {
          this.scroll_step__default = 1.0 / 500;
          this.scrollProperties = {
            step: this.scroll_step__default,
          };



          this.scroll_step__slow = this.scroll_step__default / 10;
          this.scroll_step__fast = this.scroll_step__default * 10;


          this.move_multiplier__default = 1.0;
          this.moveProperties = {
            moveMultiplier: this.move_multiplier__default,
          };

          this.move_multiplier__slow = this.move_multiplier__default / 10;
          this.move_multiplier__fast = this.move_multiplier__default * 10;


          this.colorProperties = {
            activeIndex : 0,
            list: [
              "lime",

              "red",
              "green",
              "blue",

              "white",
              "black",

              "orange",
              "purple",
              "yellow",
            ],
          };

          this.setNextColor(0);

        }

        setScrollStep(value) {
          //console.log("setScrollStep", value);
          this.scrollProperties.step = value;
        }

        setMoveMultiplier(value) {
          //console.log("setMoveMultiplier", value);
          this.moveProperties.moveMultiplier = value;
        }



        getActiveColor() {
          return this.colorProperties.list[this.colorProperties.activeIndex];
        }

        setNextColor(screment) {
          console.log("setNextColor", screment);

          var index = this.colorProperties.activeIndex;
          index += screment;
          if(index >= this.colorProperties.list.length) {
            index -= this.colorProperties.list.length;
          } else if(index < 0) {
            index += this.colorProperties.list.length;
          }

          this.colorProperties.activeIndex = index;

          //debug
          debug.setActiveColor(this.getActiveColor());
        }

      }





      class KeyDownToggle {

        constructor(name, keyDownFunc, keyDownToggleFunc = null) {
          this.name        = name;
          this.keyDownFunc = keyDownFunc;
          this.isActive    = false;

          this.keyDownToggleFunc = keyDownToggleFunc;
          if(keyDownToggleFunc == null) {
            this.keyDownToggleFunc = KeyDownToggle.keyDownToggleFunc();
          }
        }

        update(e, down) {
          const updateValue = this.keyDownFunc(e, down);
          if(updateValue != null) {
            if(this.isActive != updateValue) {
              this.isActive = updateValue;
              this.keyDownToggleFunc(this.isActive);
            }
          }
        }

        static defaultKeyDownFunc(arr_keyCode) {
          const keyDownFunc = (e, down) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if(keyCode == e.code) {
                acc = down;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyDownFunc;
        }

        static keyDownToggleFunc() {
          return (isActive) => {
            console.log("KeyDownToggle::update", this.name, this.isActive);
          };
        }

      }

      class KeyDownTimeout {

        constructor(name, keyDownFunc, triggeredFunc, delayInMs) {
          this.name          = name;
          this.keyDownFunc   = keyDownFunc;
          this.triggeredFunc = triggeredFunc;
          this.delayInMs     = delayInMs;

          this.isActive    = false;
        }

        update(e, down) {
          const updateValue = this.keyDownFunc(e, down);
          if(updateValue != null) {
            if(this.isActive != updateValue) {
              this.isActive = updateValue;
              console.log("KeyDownTimeout::update", this.name, this.isActive);

              const keyDownTimeout = this;

              function theFunc() {
                console.log("KeyDownTimeout", "call triggeredFunc()");
                keyDownTimeout.triggeredFunc();
              }

              function mayRepeat(theFunc) {

                setTimeout(function(){
                  if(keyDownTimeout.isActive) {
                    theFunc();
                    mayRepeat(theFunc);
                  }
                }, keyDownTimeout.delayInMs);
              }

              theFunc();
              mayRepeat(theFunc);

            }
          }
        }

        static defaultKeyDownFunc(arr_keyCode) {
          const keyDownFunc = (e, down) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if(keyCode == e.code) {
                acc = down;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyDownFunc;
        }

      }

      class KeyUpABToggle {

        constructor(name, keyUpFunc, triggeredFunc) {
          this.name          = name;
          this.keyUpFunc     = keyUpFunc;
          this.triggeredFunc = triggeredFunc;

          this.isModeA     = true;
        }

        update(e) {
          const updateValue = this.keyUpFunc(e);
          console.log("updateValue", updateValue);
          if(updateValue) {
            this.isModeA = !this.isModeA;
            console.log("KeyUpABToggle::update", this.name, this.isModeA);

            this.triggeredFunc(this.isModeA);
          }
        }

        static defaultKeyUpFunc(arr_keyCode) {
          const keyUpFunc = (e) => {
            var updateValue;

            updateValue = arr_keyCode.reduce((acc, keyCode) => {
              if(keyCode == e.code) {
                acc = true;
              }
              return acc;
            }, null);

            return updateValue;
          };

          return keyUpFunc;
        }

      }

      class KeyboardIntegration {

        constructor(infiniteCanvas, inputProperties, fileIntegration, fabricIntegration) {
          this.infiniteCanvas  = infiniteCanvas;
          this.inputProperties = inputProperties;

          this.fileIntegration = fileIntegration;

          this.fabricIntegration = fabricIntegration;


          // this.altKeyDown = false;
          this.keyDownToggles  = {};
          this.keyDownTimeouts = {};

          this.keyUpABToggles  = {};


          this.configureKeyboardEventHandlers();
        }

        configureKeyboardEventHandlers() {
          const keyboardIntegration = this;
          const infiniteCanvas      = this.infiniteCanvas;

          const fabricIntegration   = this.fabricIntegration;

          document.addEventListener('keyup',   logKey);
          document.addEventListener('keyup',   handleKeyUp);
          document.addEventListener('keydown', handleKeyDown);


          function configureKeyDownToggles() {

            keyboardIntegration.keyDownToggles = {
              // alt: new KeyDownToggle("alt", KeyDownToggle.defaultKeyDownFunc(["AltLeft", "AltRight"])),   //do not use alt, alt is kind of a system key
              r: new KeyDownToggle("r", KeyDownToggle.defaultKeyDownFunc(["KeyR"])),
              c: new KeyDownToggle("c", KeyDownToggle.defaultKeyDownFunc(["KeyC"])),

              shiftLeft: new KeyDownToggle("shiftLeft", KeyDownToggle.defaultKeyDownFunc(["ShiftLeft"]), (isActive) => {
                if(isActive) {
                  fabricIntegration.enterFreeDrawing();
                } else {
                  fabricIntegration.leaveFreeDrawing();
                }
              }),

            };

          }
          configureKeyDownToggles();


          function configureKeyDownTimeouts() {

            const default_timeout_delayInMs = 17; //17 ms == 60 fps
            keyboardIntegration.keyDownTimeouts = {

              a: new KeyDownTimeout("a", KeyDownToggle.defaultKeyDownFunc(["KeyQ"]), () => {
                var scaleAmount_for_100ms;

                if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  scaleAmount_for_100ms = -0.3;
                } else {
                  scaleAmount_for_100ms = -0.1;
                }

                const scaleAmount = default_timeout_delayInMs / 100 * scaleAmount_for_100ms;
                keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
              }, default_timeout_delayInMs),

              z: new KeyDownTimeout("z", KeyDownToggle.defaultKeyDownFunc(["KeyW"]), () => {
                var scaleAmount_for_100ms;

                if(keyboardIntegration.keyDownToggles.shiftLeft.isActive) {
                  scaleAmount_for_100ms = +0.3;
                } else {
                  scaleAmount_for_100ms = +0.1;
                }

                const scaleAmount = default_timeout_delayInMs / 100 * scaleAmount_for_100ms;
                keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
              }, default_timeout_delayInMs),
            };

          }
          configureKeyDownTimeouts();


          function configureKeyUpABToggles() {

            keyboardIntegration.keyUpABToggles = {
              ":": new KeyUpABToggle(":", KeyUpABToggle.defaultKeyUpFunc(["Period"]), (isModeA) => {
                  keyboardIntegration.fabricIntegration.setAntiAliasEnabled(isModeA);
              }),
            };

          }
          configureKeyUpABToggles();



          function updateKeyDownToggles(e, down) {
            const arr_keyDownToggles = Object.values(keyboardIntegration.keyDownToggles);
            arr_keyDownToggles.forEach((keyDownToggle, i) => {
              keyDownToggle.update(e, down);
            });
          }

          function updateKeyDownTimeouts(e, down) {
            const arr_keyDownTimeouts = Object.values(keyboardIntegration.keyDownTimeouts);
            arr_keyDownTimeouts.forEach((keyDownTimeout, i) => {
              keyDownTimeout.update(e, down);
            });
          }

          function updateKeyUpABToggles(e) {
            const arr_keyUpABToggles = Object.values(keyboardIntegration.keyUpABToggles);
            arr_keyUpABToggles.forEach((keyUpABToggle, i) => {
              keyUpABToggle.update(e);
            });
          }


          function logKey(e) {
            //console.log("logKey", "e.code", e.code);
          }

          function handleKeyUp(e) {
            console.log("handleKeyUp", "e", e);

            if(fabricIntegration.shouldIgnoreShortcutInput()) {
              return;
            }

            updateKeyDownToggles(e, false);
            updateKeyDownTimeouts(e, false);
            updateKeyUpABToggles(e);



            switch(e.code) {
              case "KeyA":
                // handleKeyUp_A(e);
                break;

              case "KeyI":
                FileIntegration.importImage_p()
                .then(img => {
                  infiniteCanvas.manageImageImport(img);
                });
                break;

              case "KeyS":
                infiniteCanvas.manageSaveInfinishute_p()
                .then((success) => {
                  console.log("success", success);
                });
                break;
              case "KeyL":
                FileIntegration.loadInfinishute_p()
                .then(infinishute => {
                  infiniteCanvas.manageLoadInfinishute(infinishute);
                });
                break;

              // case "ShiftLeft":
              case "KeyZ":
                handleKey_Shift(e);
                break;
              // case "ControlLeft":
              case "KeyX":
                handleKey_Ctrl(e);
                break;



              case "KeyE":
                {
                  const cursor =
                  fabricIntegration.activateObjectAtCursor();
                }
                break;


              case "KeyF":
                {
                  keyboardIntegration.infiniteCanvas.addNewRect();
                }
                break;


              // case "KeyF":
              //   handleKeyUp_F(e);
              //   break;

              // case "KeyT":
              //   handleKeyUp_T(e);
              //   break;
              case "KeyT":
                {
                  keyboardIntegration.infiniteCanvas.addNewText();
                }
                break;

              case "KeyA":
                {
                  keyboardIntegration.infiniteCanvas.addNewCircle();
                }
                break;

              case "KeyD":
                {
                  keyboardIntegration.infiniteCanvas.addNewPoint();
                }
                break;


              case "KeyG":
                {
                  //group
                  fabricIntegration.groupSelectedObjects();
                }
                break;

              case "KeyB":
                {
                  //ungroup
                  fabricIntegration.ungroupSelectedObject();
                }
                break;




              case "Digit0":
              case "Numpad0":
                keyboardIntegration.infiniteCanvas.move_to_initial_position();
                break;

              case "BackQuote":
                keyboardIntegration.infiniteCanvas.move_to_pov__animation(pov_debug, animationConfig__default);
                break;



                // case "KeyW":
                //   {
                //     const scaleAmount = -0.1;
                //     keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
                //   }
                //   break;
                //
                // case "KeyE":
                //   {
                //     const scaleAmount = 0.1;
                //     keyboardIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount);
                //   }
                //   break;


              // case "KeyM":
              case "Semicolon":
                if(keyboardIntegration.keyDownToggles.r.isActive) {
                  keyboardIntegration.infiniteCanvas.manageCenterRotation(-10);
                } else {
                  keyboardIntegration.infiniteCanvas.updateWithDOrientation(-10);
                }
                break;

              case "KeyP":
                if(keyboardIntegration.keyDownToggles.r.isActive) {
                  keyboardIntegration.infiniteCanvas.manageCenterRotation(+10);
                } else {
                  keyboardIntegration.infiniteCanvas.updateWithDOrientation(+10);
                }
                break;

              case "KeyK":
                {
                  function openUrlInNewTab(url){
                    var win = window.open(url, '_blank');
                  }
                  openUrlInNewTab("https://www.qwant.com/?l=fr");
                }
                break;


              // case "AltLeft":
              // case "AltRight":
              //   keyboardIntegration.altKeyDown = false;
              //   break;

              case "Delete":
                fabricIntegration.deleteSelection();
                break;


              case "Space":
                fabricIntegration.deselectAll();
                break;


              default:
                break;
            }
          }

          function handleKeyDown(e) {
            //console.log("handleKeyDown", "e.code", e.code);

            if(fabricIntegration.shouldIgnoreShortcutInput()) {
              return;
            }

            updateKeyDownToggles(e, true);
            updateKeyDownTimeouts(e, true);


            switch(e.code) {
              // case "ShiftLeft":
              case "KeyZ":
                handleKey_Shift(e);
                break;
              // case "ControlLeft":
              case "KeyX":
                handleKey_Ctrl(e);
                break;

              // case "AltLeft":
              // case "AltRight":
              //   keyboardIntegration.altKeyDown = true;
              //   break;

              default:
                break;
            }
          }



          // function handleKeyUp_A(e) {
          //   //console.log("handleKeyUp_A", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const zimage_scream = this.createScreamZimage(canvasBoundingTrueRect);
          //   this.addZimage(zimage_scream);
          //
          //   this.redrawCanvas();
          // }

          // function handleKeyUp_F(e) {
          //   //console.log("handleKeyUp_F", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const fObj = this.createFabricSampleObjectWithCanvasBoundingRect(canvasBoundingTrueRect);
          //   this.addFabricObject(fObj);
          //
          //   this.redrawCanvas();
          // }

          // function handleKeyUp_T(e) {
          //   //console.log("handleKeyUp_T", "e.code", e.code);
          //
          //   const canvasBoundingTrueRect = this.getCanvasBoundingTrueRect();
          //   //console.log("canvasBoundingTrueRect", canvasBoundingTrueRect);
          //
          //   const fObj = this.createFabricSampleTextObjectWithCanvasBoundingRect(canvasBoundingTrueRect);
          //   this.addFabricObject(fObj);
          //
          //   this.redrawCanvas();
          // }

          //scroll fast/slow

          /*
                  $(document).keydown(function(event) {
                  if (event.ctrlKey==true && (event.which == '61' || event.which == '107' || event.which == '173' || event.which == '109'  || event.which == '187'  || event.which == '189'  ) ) {
                          event.preventDefault();
                       }
                      // 107 Num Key  +
                      // 109 Num Key  -
                      // 173 Min Key  hyphen/underscor Hey
                      // 61 Plus key  +/= key
                  });

                  $(window).bind('mousewheel DOMMouseScroll', function (event) {
                         if (event.ctrlKey == true) {
                         event.preventDefault();
                         }
                  });
          */



          function handleKey_Shift(e) {
            switch(e.type) {
              case "keydown":
                this.setScrollStep(scroll_step__fast);
                this.setMoveMultiplier(move_multiplier__fast);
                break;
              case "keyup":
                this.setScrollStep(scroll_step__default);
                this.setMoveMultiplier(move_multiplier__default);
                break;
              default:
                break;
            }
          }

          function handleKey_Ctrl(e) {
            switch(e.type) {
              case "keydown":
                this.setScrollStep(scroll_step__slow);
                this.setMoveMultiplier(move_multiplier__slow);
                break;
              case "keyup":
                this.setScrollStep(scroll_step__default);
                this.setMoveMultiplier(move_multiplier__default);
                break;
              default:
                break;
            }
          }

        }


      }



      class MouseIntegration {

        constructor(canvasContainer, infiniteCanvas, inputProperties, keyboardIntegration) {

          this.infiniteCanvas  = infiniteCanvas;
          this.inputProperties = inputProperties;

          this.leftMouseDown  = false;
          this.rightMouseDown = false;

          this.keyboardIntegration = keyboardIntegration;

          this.configureMouseEventHandlers(canvasContainer);
        }

        // Mouse Event Handlers
        configureMouseEventHandlers(canvasContainer) {
          const mouseIntegration = this;

          const keyboardIntegration = this.keyboardIntegration;
          const inputProperties     = this.inputProperties;


          canvasContainer.addEventListener('mousedown', onMouseDown);
          canvasContainer.addEventListener('mouseup',   onMouseUp, false);
          canvasContainer.addEventListener('mouseout',  onMouseUp, false);
          canvasContainer.addEventListener('mousemove', onMouseMove, false);
          canvasContainer.addEventListener('wheel',     onMouseWheel, false);

          // mouse functions
          function onMouseDown(event) {

              /*
              // update the cursor coordinates
              const cursor = {
                x: event.pageX,
                y: event.pageY,
              };

              this.infiniteCanvas.updateCursor(cursor);
              */

              // detect left clicks
              if (event.button == 0) {
                  mouseIntegration.leftMouseDown = true;
                  mouseIntegration.rightMouseDown = false;
              }
              // detect right clicks
              if (event.button == 2) {
                  mouseIntegration.rightMouseDown = true;
                  mouseIntegration.leftMouseDown = false;
              }
          }

          function onMouseMove(event) {
              // //console.log("onMouseMove", "event", event);

              // update cursor with mouse position
              const cursor = {
                x: event.pageX,
                y: event.pageY,
              };
              mouseIntegration.infiniteCanvas.updateCursor(cursor);


              if (mouseIntegration.leftMouseDown) {
                mouseIntegration.infiniteCanvas.manageCursorMove_line();
              }
              else if (mouseIntegration.rightMouseDown) {
                //console.log("onMouseMove", "rightMouseDown", "event", event);

                // console.log("keyboardIntegration.altKeyDown", keyboardIntegration.altKeyDown);
                // if(keyboardIntegration.keyDownToggles.r.isActive) {
                //   mouseIntegration.infiniteCanvas.manageCursorMove_rotate();
                // } else {
                //   mouseIntegration.infiniteCanvas.manageCursorMove_offset();
                // }
                mouseIntegration.infiniteCanvas.manageCursorMove_offset();

              } else if(keyboardIntegration.keyDownToggles.r.isActive) {
                mouseIntegration.infiniteCanvas.manageCursorMove_rotate();
              }

          }

          function onMouseUp() {
              mouseIntegration.leftMouseDown  = false;
              mouseIntegration.rightMouseDown = false;

              mouseIntegration.infiniteCanvas.logCursor();
          }

          function onMouseWheel(event) {

            if(keyboardIntegration.keyDownToggles.c.isActive) {
              colorScroll();
            } else {
              zoomScroll();
            }

            function colorScroll() {
              const deltaY   = event.deltaY;
              const screment = deltaY > 0 ? 1 : -1;
              inputProperties.setNextColor(screment);
            }

            function zoomScroll() {
              const deltaY = event.deltaY;
              // const scaleAmount = -deltaY / 500;
              const scroll_step = mouseIntegration.inputProperties.scrollProperties.step;
              //console.log("onMouseWheel", "scroll_step", scroll_step);
              const scaleAmount = -deltaY * scroll_step;

              const scaleAmount_max =  0.99;
              const scaleAmount_min = -0.99;
              const scaleAmount_bounded = Math.min(scaleAmount_max, Math.max(scaleAmount_min, scaleAmount));

              mouseIntegration.infiniteCanvas.manageScaleUpdateWithScaleAmount(scaleAmount_bounded);

              /*
              var zoom = canvas.getZoom();
              zoom *= 0.999 ** deltaY;
              // if (zoom > 20) zoom = 20;
              // if (zoom < 0.01) zoom = 0.01;
              canvas.setZoom(zoom);
              event.preventDefault();
              event.stopPropagation();
              */



              // const scale_new = scale * (1 + scaleAmount);

              /*
              // zoom the page based on where the cursor is
              var distX = event.pageX / canvas.clientWidth;
              var distY = event.pageY / canvas.clientHeight;

              // calculate how much we need to zoom
              const unitsZoomedX = trueWidth() * scaleAmount;
              const unitsZoomedY = trueHeight() * scaleAmount;

              const unitsAddLeft = unitsZoomedX * distX;
              const unitsAddTop = unitsZoomedY * distY;

              const dOffsetX = unitsAddLeft;
              const dOffsetY = unitsAddTop;

              const dOffset = {
                dx: dOffsetX,
                dy: dOffsetY,
              };

              updateScaleAndDOffset(scale_new, dOffset);
              */
            }


          }

          // function onMouseWheel(event) {
          //   const deltaY = event.deltaY;
          //   const scaleAmount = -deltaY / 500;
          //   scale = scale * (1 + scaleAmount);
          //
          //   // zoom the page based on where the cursor is
          //   var distX = event.pageX / canvas.clientWidth;
          //   var distY = event.pageY / canvas.clientHeight;
          //
          //   // calculate how much we need to zoom
          //   const unitsZoomedX = trueWidth() * scaleAmount;
          //   const unitsZoomedY = trueHeight() * scaleAmount;
          //
          //   const unitsAddLeft = unitsZoomedX * distX;
          //   const unitsAddTop = unitsZoomedY * distY;
          //
          //   offsetX -= unitsAddLeft;
          //   offsetY -= unitsAddTop;
          // }

        }

      }

      class TouchIntegration {

        constructor(canvasContainer, infiniteCanvas, inputProperties) {
          // touch functions
          this.prevTouches = [null, null]; // up to 2 touches
          this.singleTouch = false;
          this.doubleTouch = false;

          this.configureTouchEventHandlers(canvasContainer);
        }

        configureTouchEventHandlers(canvasContainer) {
          // Touch Event Handlers
          canvasContainer.addEventListener('touchstart',  onTouchStart);
          canvasContainer.addEventListener('touchend',    onTouchEnd);
          canvasContainer.addEventListener('touchcancel', onTouchEnd);
          canvasContainer.addEventListener('touchmove',   onTouchMove);


          function onTouchStart(event) {
              if (event.touches.length == 1) {
                  this.singleTouch = true;
                  this.doubleTouch = false;
              }
              if (event.touches.length >= 2) {
                  this.singleTouch = false;
                  this.doubleTouch = true;
              }

              // store the last touches
              this.prevTouches[0] = event.touches[0];
              this.prevTouches[1] = event.touches[1];

          }

          function onTouchMove(event) {
              // get first touch coordinates
              const touch0X = event.touches[0].pageX;
              const touch0Y = event.touches[0].pageY;
              const prevTouch0X = this.prevTouches[0].pageX;
              const prevTouch0Y = this.prevTouches[0].pageY;

              const pointTouch0 = {

              };

              const pointPrevTouch0 = {

              };

              const scaledX = toTrueX(pointTouch0);
              const scaledY = toTrueY(pointTouch0);
              const prevScaledX = toTrueX(pointPrevTouch0);
              const prevScaledY = toTrueY(pointPrevTouch0);

              if (singleTouch) {
                  // add to history
                  drawings.push({
                      x0: prevScaledX,
                      y0: prevScaledY,
                      x1: scaledX,
                      y1: scaledY
                  })
                  drawLine(prevTouch0X, prevTouch0Y, touch0X, touch0Y);
              }

              if (doubleTouch) {
                  // get second touch coordinates
                  const touch1X = event.touches[1].pageX;
                  const touch1Y = event.touches[1].pageY;
                  const prevTouch1X = prevTouches[1].pageX;
                  const prevTouch1Y = prevTouches[1].pageY;

                  // get midpoints
                  const midX = (touch0X + touch1X) / 2;
                  const midY = (touch0Y + touch1Y) / 2;
                  const prevMidX = (prevTouch0X + prevTouch1X) / 2;
                  const prevMidY = (prevTouch0Y + prevTouch1Y) / 2;

                  // calculate the distances between the touches
                  const hypot = Math.sqrt(Math.pow((touch0X - touch1X), 2) + Math.pow((touch0Y - touch1Y), 2));
                  const prevHypot = Math.sqrt(Math.pow((prevTouch0X - prevTouch1X), 2) + Math.pow((prevTouch0Y - prevTouch1Y), 2));

                  // calculate the screen scale change
                  var zoomAmount = hypot / prevHypot;
                  scale = scale * zoomAmount;
                  const scaleAmount = 1 - zoomAmount;

                  // calculate how many pixels the midpoints have moved in the x and y direction
                  const panX = midX - prevMidX;
                  const panY = midY - prevMidY;
                  // scale this movement based on the zoom level
                  offsetX += (panX / scale);
                  offsetY += (panY / scale);

                  // Get the relative position of the middle of the zoom.
                  // 0, 0 would be top left.
                  // 0, 1 would be top right etc.
                  var zoomRatioX = midX / canvas.clientWidth;
                  var zoomRatioY = midY / canvas.clientHeight;

                  // calculate the amounts zoomed from each edge of the screen
                  const unitsZoomedX = trueWidth() * scaleAmount;
                  const unitsZoomedY = trueHeight() * scaleAmount;

                  const unitsAddLeft = unitsZoomedX * zoomRatioX;
                  const unitsAddTop = unitsZoomedY * zoomRatioY;

                  offsetX += unitsAddLeft;
                  offsetY += unitsAddTop;

                  redrawCanvas();
              }
              prevTouches[0] = event.touches[0];
              prevTouches[1] = event.touches[1];
          }

          function onTouchEnd(event) {
              singleTouch = false;
              doubleTouch = false;
          }

        }



      }


    </script>





    <script>
      // disable right clicking
      document.oncontextmenu = function () {
          return false;
      }

      class State {

      }

      const inputProperties     = new InputProperties();
      const fileIntegration     = new FileIntegration();


      const infiniteCanvas      = new InfiniteCanvas(canvas, inputProperties);

      fileIntegration.onPasteImageListeners.push((img) => {
        infiniteCanvas.manageImageImport(img);
      });
      fileIntegration.onPasteTextListeners.push((text) => {
        infiniteCanvas.manageTextImport(text);
      });



      // const canvas = document.getElementById("myCanvas");
      const fabricIntegration   = new FabricIntegration(infiniteCanvas, inputProperties);
      infiniteCanvas.redrawCanvasListeners.push((redrawOccasion) => {
        fabricIntegration.redrawCanvas(redrawOccasion);
      });
      infiniteCanvas.didAddObjectListeners.push((icObj) => {
        fabricIntegration.addFabricObjectWithIcObj(icObj);
      });
      infiniteCanvas.didAddPureObjectListeners.push((icObj) => {
        fabricIntegration.addFabricObjectWithPureIcObj(icObj);
      });

      // infiniteCanvas.requestSyncWithIcObjListeners.push((icObj) => {
      //   fabricIntegration.syncWithIcObj(icObj);
      // });


      // const clipboardIntegration = new ClipboardIntegration(fileIntegration, fabricIntegration);

      const keyboardIntegration = new KeyboardIntegration(infiniteCanvas, inputProperties, fileIntegration, fabricIntegration);

      const canvasContainer     = document.getElementsByClassName("canvas-container")[0];
      const mouseIntegration    = new MouseIntegration(canvasContainer, infiniteCanvas, inputProperties, keyboardIntegration);
      // const touchIntegration    = new TouchIntegration(canvasContainer, infiniteCanvas, inputProperties);


    </script>

    <script>

      class Xylophone {

        constructor(infiniteCanvas, base = 10, exponent_min = -5, exponent_max = +5) {
          this.infiniteCanvas = infiniteCanvas;

          this.base         = base;
          this.exponent_min = exponent_min;
          this.exponent_max = exponent_max;

          this.xyloZones    = {};

          this.activeNumber       = 0;
          this.activeNumberString = "0";  //to avoid decimal <-> binary conversion issues  (0.7 != 0.7000000000000001)

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xylophone      = this;
          const infiniteCanvas = this.infiniteCanvas;

          const base         = this.base;
          const exponent_min = this.exponent_min;
          const exponent_max = this.exponent_max;

          const arr_exponent = [...Array(exponent_max - exponent_min + 1).keys()].map(i => (exponent_min + i));

          arr_exponent.forEach((exponent, i) => {

            const xyloZone = new XyloZone(infiniteCanvas, base, exponent);

            this.xyloZones[xyloZone.id] = xyloZone;
            xyloZone.didUpdateListeners.push((xyloZone) => {
              this.updateActiveNumber();
            });
          });

        }

        updateActiveNumber() {
          this.activeNumber = Object.values(this.xyloZones)
                              .map(xyloZone => xyloZone.activeNumber)
                              // .reduce((acc, x) => (acc + x), 0);
                              .reduce((acc, x) => (acc.plus(x)), new Decimal(0));
          // console.log("xylophone::updateActiveNumber", this.activeNumber;
          console.log("xylophone::updateActiveNumber", this.activeNumber.toFixed());

          this.didUpdate();
        }

        didUpdate() {
          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });

        }


        getArr_exponent() {
            return Object.values(this.xyloZones).map(xyloZone => xyloZone.exponent);
        }

        getExponent_min() {
          return Math.min(...this.getArr_exponent());
        }

        getExponent_max() {
          return Math.max(...this.getArr_exponent());
        }

      }

      class XyloZone {

        constructor(infiniteCanvas, base, exponent) {
          this.infiniteCanvas = infiniteCanvas;

          const exponentString = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
          const numberString   = "" + base + "^" + exponentString;

          this.id       = numberString;

          this.base     = base;
          this.exponent = exponent;

          this.xylophoneTowers = {};

          this.icObjects = {};

          // this.activeNumber       = 0;
          this.activeNumber = new Decimal(0);
          this.activeNumberString = "" + this.activeNumber;

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xyloZone = this;

          const infiniteCanvas = this.infiniteCanvas;

          function activeCfgForTower(xylophoneTower) {
            var outCfg;

            outCfg = {
              fill: xylophoneTower.color,
              opacity: 1.0,
            };

            return outCfg;
          }

          function inactiveCfgForTower(xylophoneTower) {
            var outCfg;

            if(xylophoneTower.mantissa == 0) {
              outCfg = {
                fill: '',
                opacity: 1.0,
              };
            } else {
              outCfg = {
                fill: xylophoneTower.color,
                opacity: 0.3,
              };
            }

            return outCfg;
          }

          function createCanvasToggleRectForXylophoneTower(xylophoneTower) {
            const trueRect  = xylophoneTower.trueRect;

            const activeCfg   = activeCfgForTower(xylophoneTower);
            const inactiveCfg = inactiveCfgForTower(xylophoneTower);

            const isActive = false;

            const icToggleRect = infiniteCanvas.createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive);
            icToggleRect.canBeMoved    = false;
            icToggleRect.canBeRotated  = false;
            icToggleRect.canBeResized  = false;
            icToggleRect.canBeSelected = true;

            return icToggleRect;
          }


          const exponent = this.exponent;
          const base     = this.base;

          //zero tower
          {
            const xylophoneTower = new XylophoneTower(0, exponent, base);
            xyloZone.xylophoneTowers[xylophoneTower.mantissa] = xylophoneTower;
            xylophoneTower.didUpdateListeners.push((xylophoneTower, source) => {

              switch(source) {
                // case "view":
                //   //no sync needed
                //   xyloZone.updateWithXylophoneTowerViewUpdate(xylophoneTower);
                //   break;
                case "model":
                  //sync needed
                  xylophoneTower.icObj.isActive = xylophoneTower.isActive;
                  infiniteCanvas.requestViewUpdateForIcObj(xylophoneTower.icObj);
                  break;
              }

            });


            const icToggleRect = createCanvasToggleRectForXylophoneTower(xylophoneTower);
            icToggleRect.canBeSelected = false;

            xylophoneTower.icObj = icToggleRect;

            infiniteCanvas.addIcObject(icToggleRect);

            xylophoneTower.updateIsActive(true, "model");
          }

          //other towers
          [...Array(base - 1).keys()].forEach((item, j) => {
            const mantissa = j + 1;

            const xylophoneTower = new XylophoneTower(mantissa, exponent, base);
            xyloZone.xylophoneTowers[xylophoneTower.mantissa] = xylophoneTower;
            xylophoneTower.didUpdateListeners.push((xylophoneTower, source) => {

              switch(source) {
                case "view":
                  //no sync needed
                  xyloZone.updateWithXylophoneTowerViewUpdate(xylophoneTower);
                  break;
                case "model":
                  //sync needed
                  xylophoneTower.icObj.isActive = xylophoneTower.isActive;
                  infiniteCanvas.requestViewUpdateForIcObj(xylophoneTower.icObj);
                  break;
              }

            });

            const icToggleRect = createCanvasToggleRectForXylophoneTower(xylophoneTower);
            xylophoneTower.icObj = icToggleRect;

            infiniteCanvas.addIcObject(icToggleRect);

            icToggleRect.didUpdateListeners.push((icToggleRect) => {
              xylophoneTower.updateIsActive(icToggleRect.isActive, "view");
            });
          });




          //zone-dedicated objects

          //number text
          {
            const trueRect = this.xylophoneTowers[0].trueRect;

            const icText = infiniteCanvas.createIcText(trueRect.x, trueRect.y, "lol");
            icText.canBeMoved    = false;
            icText.canBeRotated  = false;
            icText.canBeResized  = false;
            icText.canBeSelected = false;

            const scaleFactor = (this.base ** this.exponent);
            console.log("number text, scaleFactor", scaleFactor);

            icText.homeScale = {
              X: icText.homeScale.X / scaleFactor     * 50,
              Y: icText.homeScale.Y / scaleFactor     * 50,
            };

            icText.fill = "yellow";

            this.icObjects["numberDisplay"] = icText;

            infiniteCanvas.addIcObject(icText);


            this.didUpdateListeners.push((xyloZone) => {
              const activeNumberString = xyloZone.activeNumber.toFixed();
              icText.text = activeNumberString;
              // infiniteCanvas.requestViewUpdateForIcObj(icText); //SHU666
            });
          }


        }

        setActiveMantissa(mantissa) {
          const chosenXylophoneTower = this.xylophoneTowers[mantissa];
          chosenXylophoneTower.updateIsActive(true, "model");

          const towers_to_deactivate = Object.values(this.xylophoneTowers).filter(xylophoneTower => xylophoneTower != chosenXylophoneTower);
          towers_to_deactivate.forEach((xylophoneTower, i) => {
            xylophoneTower.updateIsActive(false, "model");
          });

          this.updateActiveNumber();

          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }

        updateWithXylophoneTowerViewUpdate(chosenXylophoneTower) {
          console.log("updateWithXylophoneTowerViewUpdate", chosenXylophoneTower.mantissa);

          //deactivate all others
          const towers_to_deactivate = Object.values(this.xylophoneTowers).filter(xylophoneTower => xylophoneTower != chosenXylophoneTower);
          towers_to_deactivate.forEach((xylophoneTower, i) => {
            xylophoneTower.updateIsActive(false, "model");
          });

          if(chosenXylophoneTower.isActive) {

          } else {
            const zeroXylophoneTower = this.xylophoneTowers[0];
            zeroXylophoneTower.updateIsActive(true, "model");
          }

          this.updateActiveNumber();
        }

        updateActiveNumber() {
          this.activeNumber = Object.values(this.xylophoneTowers)
                              .filter(xylophoneTower => xylophoneTower.isActive)
                              .map(xylophoneTower => xylophoneTower.number)
                              // .reduce((acc, x) => (acc + x), 0);
                              .reduce((acc, x) => (acc.plus(x)), new Decimal(0));
          // console.log("xyloZone::updateActiveNumber", this.activeNumber);
          console.log("xyloZone::updateActiveNumber", this.activeNumber.toFixed());

          this.didUpdate();
        }

        didUpdate() {
          this.didUpdateListeners.forEach((listener, i) => {
            listener(this);
          });
        }

        getTrueRect() {
          const zeroXylophoneTower = this.xylophoneTowers[0];
          return zeroXylophoneTower.trueRect;
        }

      }

      class XylophoneTower {

          constructor(mantissa, exponent, base) {
            const exponentString = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
            const numberString   = "" + mantissa + " x " + base + "^" + exponentString;

            this.id       = numberString;

            this.mantissa = mantissa;
            this.base     = base;
            this.exponent = exponent;

            this.xyloBrickNumber = new XyloBrickNumber(mantissa, exponent, base);

            this.unreliable_number = mantissa * (base ** exponent);
            this.number = null;
            if(base == 10) {
              //'sharp' number (==arbitrary-precision number)
              const decimalNumberFormatString = "" + mantissa + "e" + exponent;
              this.decimal_decimalNumber = new Decimal(decimalNumberFormatString);
              // console.log("this.decimal_decimalNumber", this.decimal_decimalNumber);
              console.log("this.decimal_decimalNumber.toFixed()", this.decimal_decimalNumber.toFixed());


              this.number = this.decimal_decimalNumber;
            } else {
              //SHU TODO: 'sharp management' when base != 10 ...
              //this seems to be linked to the halting problem
              this.number = this.unreliable_number;
            }

            this.successor     = (mantissa + 1) * (base ** exponent);
            // this.successorXyloBrickNumber = ;

            this.trueRect = XylophoneTower.trueRectForTower(this);
            this.color    = XylophoneTower.colorForMantissa(mantissa);

            this.isActive = false;

            this.didUpdateListeners = [];
          }

          updateIsActive(isActive, source) {
            this.isActive = isActive;

            this.didUpdateListeners.forEach((listener, i) => {
              listener(this, source);
            });

          }

          static trueRectForTower(xylophoneTower) {
            var outTrueRect;

            // const BL = {
            //   x: xylophoneTower.number,
            //   y: 0,
            // };
            // const TR = {
            //   x: xylophoneTower.successor,
            //   y: xylophoneTower.number,
            // }

            if(xylophoneTower.mantissa == 0) {
              const mantissa1_number = (xylophoneTower.base ** xylophoneTower.exponent);
              const nextPower_number = (xylophoneTower.base ** (xylophoneTower.exponent + 1));
              const mantissaN_number = nextPower_number - mantissa1_number;

              outTrueRect = {
                x: mantissa1_number,
                width:  nextPower_number - mantissa1_number,

                // y: -nextPower_number,
                // height: nextPower_number,

                y: - mantissaN_number,
                height: mantissaN_number,
              };
            } else {
              outTrueRect = {
                x: xylophoneTower.unreliable_number,
                y: -xylophoneTower.unreliable_number,
                width: (xylophoneTower.base ** xylophoneTower.exponent),
                height: xylophoneTower.unreliable_number,
              };
            }

            return outTrueRect;
          }

          static colorForMantissa(mantissa) {
            var outColor = null;

            switch(mantissa) {
              case 0:
                outColor = "#000000";
                break;

              case 1:
                outColor = "#FF7F0E";
                break;
              case 2:
                outColor = "#2CA02C";
                break;
              case 3:
                outColor = "#D62728";
                break;
              case 4:
                outColor = "#9467BD";
                break;
              case 5:
                outColor = "#8C564B";
                break;
              case 6:
                outColor = "#E377C2";
                break;
              case 7:
                outColor = "#7F7F7F";
                break;
              case 8:
                outColor = "#BCBD22";
                break;
              case 9:
                outColor = "#17BECF";
                break;

              //SHU TODO: colors or patterns for those:
              case 10:  //A
                outColor = "#000000";
                break;
              case 11:  //B
                outColor = "#000000";
                break;
              case 12:  //C
                outColor = "#000000";
                break;
              case 13:  //D
                outColor = "#000000";
                break;
              case 14:  //E
                outColor = "#000000";
                break;
              case 15:  //F
                outColor = "#000000";
                break;

              default:
                throw new Error("unsupported mantissa: " + mantissa);
            }

            return outColor;
          }


      }


      class XyloZonePerception {
      // class XyloZoneDecoration {

        constructor(infiniteCanvas, xyloZone) {
          this.infiniteCanvas = infiniteCanvas;
          this.xyloZone = xyloZone;

          this.trueRect = null;

          this.icObjects = {};

          this.didUpdateListeners = [];

          this.initialize();
        }

        initialize() {
          const xyloZonePerception = this;

          const infiniteCanvas = this.infiniteCanvas;

          const xyloZone_trueRect = xyloZonePerception.xyloZone.getTrueRect();

          //listen to xyloZone
          xyloZonePerception.xyloZone.didUpdateListeners.push((xyloZone) => {

          });

        }

        createInfiniteCanvasObjects() {

          function createCanvasToggleRectForXylophonePerception(xylophoneTower) {
            const trueRect  = xylophoneTower.trueRect;

            const activeCfg   = activeCfgForTower(xylophoneTower);
            const inactiveCfg = inactiveCfgForTower(xylophoneTower);

            const isActive = false;

            const icToggleRect = infiniteCanvas.createIcToggleRect(trueRect, activeCfg, inactiveCfg, isActive);
            icToggleRect.canBeMoved    = false;
            icToggleRect.canBeRotated  = false;
            icToggleRect.canBeResized  = false;
            icToggleRect.canBeSelected = true;

            return icToggleRect;
          }

        }

        update(xyloZone) {

        }

      }


      class NumberUtils {

        static randomXylophoneNumber(base, exponent_min, exponent_max) {

          const arr_exponent = [...Array(exponent_max - exponent_min + 1).keys()].map(i => (exponent_min + i));

          const arr_xyloBrickNumber = arr_exponent.map(exponent => {
            const mantissa = Math.floor(Math.random() * 10); // returns a random integer from 0 to 9
            const xyloBrickNumber = new XyloBrickNumber(mantissa, base, exponent);
            return xyloBrickNumber;
          });

          const xylophoneNumber = new XylophoneNumber(arr_xyloBrickNumber);

          return xylophoneNumber;
        }

      }

      class XyloBrickNumber {

        constructor(mantissa, base, exponent) {
          this.mantissa = mantissa;
          this.base     = base;
          this.exponent = exponent;

          this.unreliable_number  = mantissa * (base ** exponent);

          // const exponentString  = (exponent < 0 ? "(" : "") + exponent + (exponent < 0 ? ")" : "");
          // const sciNumberString = "" + mantissa + " x " + base + "^" + exponentString;
          // this.sciNumberString  = numberString;
          //
          // this.decimalNumberString = DecimalBrickNumber.decimalNumberString(mantissa, base, exponent);
        }

        toDecimalNumber() {
          var outDecimal;

          if(this.base == 10) {
            //'sharp' number (==arbitrary-precision number)
            const decimalNumberFormatString = "" + this.mantissa + "e" + this.exponent;
            const decimalNumber = new Decimal(decimalNumberFormatString);

            outDecimal = decimalNumber;
          } else {
            //SHU TODO: 'sharp management' when base != 10 ...
            //this seems to be linked to the halting problem
            throw new Error("unsupported for now");
          }

          return outDecimal;
        }

        // static decimalNumberString(mantissa, base, exponent) {
        //
        // }

      }

      class XylophoneNumber {

        constructor(arr_xyloBrickNumber) {

          //check not empty
          const isEmpty = (arr_xyloBrickNumber.length == 0);

          if(isEmpty) {
            throw new Error("arr_xyloBrickNumber.length == 0");
          }

          //check same base for all
          const base       = arr_xyloBrickNumber.find(e => true).base;
          const isSameBase = arr_xyloBrickNumber.every(xyloBrickNumber => (xyloBrickNumber.base == base));

          if(!isSameBase) {
            console.log("arr_xyloBrickNumber", arr_xyloBrickNumber);
            throw new Error("xyloBrickNumbers have different bases");
          }

          this.base = base;
          this.xyloBrickNumbers = arr_xyloBrickNumber.reduce((acc, xyloBrickNumber) => {
            acc[xyloBrickNumber.exponent] = xyloBrickNumber;
            // acc[xyloBrickNumber.exponent] = xyloBrickNumber.mantissa;
            return acc;
          }, {});

          this.unreliable_number = arr_xyloBrickNumber.reduce((acc, x) => (acc + x.unreliable_number), 0);
        }

        toDecimalNumber() {
          return Object.values(this.xyloBrickNumbers).reduce((acc, x) => {
            const xyloBrickDecimal = x.toDecimalNumber();
            return acc.plus(xyloBrickDecimal);
          }, new Decimal(0));
        }

        // filledToUnit() {
        //
        //   function fillNegative() {
        //     const
        //
        //   }
        //
        //   function fillPositive() {
        //
        //   }
        //
        //
        // }

        // toString() {
        //   const str = Object.keys(this.xyloBrickNumbers).reduce((acc, exponent) => {
        //
        //   }, "");
        //   return str;
        // }

        // isEqual(xylophoneNumber2) {
        //   const xylophoneNumber1 = this;
        //   const areEqual = XylophoneNumber.compare(xylophoneNumber1, xylophoneNumber2) == 0;
        //   return areEqual;
        // }
        //
        // static compare(xylophoneNumber1, xylophoneNumber2) {
        //   var outNumber;
        //
        //   const arr_keys_1 = Object.keys(xylophoneNumber1.xyloBrickNumbers);
        //
        //
        //   return outNumber;
        // }

      }




      const xylophone = new Xylophone(infiniteCanvas, 10);
      // const xylophone = new Xylophone(infiniteCanvas, 2);    //always a bit confusing


    </script>

    <!-- debug -->
    <div id="xyloGame_container" style="position:absolute; left:0; bottom: 0; font-size: 60px; pointer-events: none;">
      <div>
        <div style="display: inline-block;">current number: </div>
        <div style="display: inline-block;" id="xyloGame_currentNumber"></div>
      </div>
      <div>
        <div style="display: inline-block;">target number: </div>
        <div style="display: inline-block;" id="xyloGame_targetNumber"></div>
      </div>
      <div>
        <div style="display: inline-block;"></div>
        <div style="display: inline-block;" id="xyloGame_completed"></div>
      </div>
    </div>

    <script>
      class XyloGameHUD {
        constructor (eltsDict) {
          this.eltsDict = eltsDict;
        }

        setCurrentNumberString(numberString) {
          this.eltsDict["currentNumber"].innerHTML = numberString;
        }
        setTargetNumberString(numberString) {
          this.eltsDict["targetNumber"].innerHTML = numberString;
        }
        setCompleted(completed) {
          this.eltsDict["completed"].innerHTML = completed ? "Well done !" : "";
        }
      }

      const xyloGameHUD_eltsDict = {
        currentNumber:  document.getElementById("xyloGame_currentNumber"),
        targetNumber:   document.getElementById("xyloGame_targetNumber"),
        completed:      document.getElementById("xyloGame_completed"),
      };
      const xyloGameHUD = new XyloGameHUD(xyloGameHUD_eltsDict);
    </script>


    <script>

    class XylophoneGame1_xyloWrite {

      constructor(xylophone, xyloGameHUD) {
        this.xylophone    = xylophone;
        this.xyloGameHUD  = xyloGameHUD;

        this.targetXylophoneNumber = null;
        this.targetNumber          = null;

        this.initialize();
      }

      initialize() {
        const xylophone   = this.xylophone;
        const xyloGameHUD = this.xyloGameHUD;

        const base         = xylophone.base;
        const exponent_min = xylophone.getExponent_min();
        const exponent_max = xylophone.getExponent_max();
        const targetXylophoneNumber = NumberUtils.randomXylophoneNumber(base, exponent_min, exponent_max);
        // console.log("targetXylophoneNumber", targetXylophoneNumber.toDecimalNumber().toFixed());

        this.targetXylophoneNumber = targetXylophoneNumber;
        this.targetNumber          = targetXylophoneNumber.toDecimalNumber();

        const targetNumberString = this.targetNumber.toFixed();
        xyloGameHUD.setTargetNumberString(targetNumberString);

        const xylophoneNumberString = xylophone.activeNumber.toFixed();
        xyloGameHUD.setCurrentNumberString(xylophoneNumberString);


        xylophone.didUpdateListeners.push((xylophone) => {
          console.log("XylophoneGame1_xyloWrite", "xylophone did update", xylophone);

          // const xylophoneNumberString = xylophone.getActiveNumberString();
          const xylophoneNumberString = xylophone.activeNumber.toFixed();
          console.log("xylophoneNumberString", xylophoneNumberString);
          xyloGameHUD.setCurrentNumberString(xylophoneNumberString);

          const numbersAreEqual = (targetNumberString == xylophoneNumberString);
          xyloGameHUD.setCompleted(numbersAreEqual);
        });
      }

    }

    class XylophoneGame2_xyloRead {

      constructor(infiniteCanvas) {

      }

    }

    const xyloWrite = new XylophoneGame1_xyloWrite(xylophone, xyloGameHUD);

    </script>



    <script>
        class SandBox_doubleObjects {
          constructor(infiniteCanvas) {
            this.infiniteCanvas = infiniteCanvas;

            this.doubleObjects = {};

            this.initialize();
          }

          initialize() {
            const infiniteCanvas = this.infiniteCanvas;

            this.initialize_doubleObjects(infiniteCanvas);

            const arr_doubleObject = Object.values(this.doubleObjects);
            arr_doubleObject.forEach((doubleObject, i) => {
              this.materialize_doubleObject(doubleObject, infiniteCanvas);
            });

          }

          initialize_doubleObjects(infiniteCanvas) {

            //double object #1
            {
              const dO_id        = "dO#1"
              const dO_homeScale = {
                X:2.0,
                Y:2.0,
              };

              const icRect_front = infiniteCanvas.createIcRect_withLTWH(0, 0, 100, 100);
              icRect_front.fill  = "red";
              icRect_front.homeScale = dO_homeScale;

              const icRect_back = infiniteCanvas.createIcRect_withLTWH(0, 0, 100, 100);
              icRect_back.fill = "blue";
              icRect_back.homeScale = dO_homeScale;

              const doubleObject = new DoubleObject(dO_id, icRect_front, icRect_back);

              this.doubleObjects[doubleObject.id] = doubleObject;
            }

            //double object #2
            {
              const dO_id        = "dO#2"
              const dO_homeScale = {
                X:2.0,
                Y:2.0,
              };

              const img_front_p = FileIntegration.imageFromImgSrc_p("");
              const img_back_p  = FileIntegration.imageFromImgSrc_p("");

              const icObj_front = infiniteCanvas.createIcImage(500, 500, img_front);
              icObj_front.homeScale = dO_homeScale;

              const icObj_back = infiniteCanvas.createIcRect_withLTWH(500, 500, 100, 100);
              icObj_back.homeScale = dO_homeScale;

              const doubleObject = new DoubleObject(dO_id, icObj_front, icObj_back);

              this.doubleObjects[doubleObject.id] = doubleObject;
            }

          }

          materialize_doubleObject(doubleObject, infiniteCanvas) {
            const icObj_active = doubleObject.getActiveIcObject();
            infiniteCanvas.addIcObject(icObj_active);

            infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
              doubleObject.updateWithObservationScale(infiniteCanvas.scale);
            });

            doubleObject.didUpdateListeners.push((icObj_old, icObj_new) => {
              // infiniteCanvas.requestViewUpdateForIcObj(icObj);
              infiniteCanvas.removeIcObject(icObj_old);
              infiniteCanvas.addIcObject(icObj_new);
            });

          }

        }

        class DoubleObject {

          constructor(id, icObj_front, icObj_back) {
            this.id = id;

            this.icObj_front = icObj_front;
            this.icObj_back  = icObj_back;

            const factor_scaleToggle = 0.90;
            this.scale_toggle = {
              X: icObj_front.homeScale.X * factor_scaleToggle,
              Y: icObj_front.homeScale.Y * factor_scaleToggle,
            };

            // this.icObj_active = null;
            this.icObj_active = icObj_front;

            this.didUpdateListeners = [];
          }

          getActiveIcObject() {
            return this.icObj_active;
          }

          updateWithObservationScale(scale_obs) {
            console.log("updateWithObservationScale", scale_obs);

            const icObj_active = this.getIcObjectForObservationScale(scale_obs);

            this.setActiveIcObject(icObj_active);
          }

          getIcObjectForObservationScale(scale_obs) {
            var outIcObj;

            const isFar = scale_obs.X < this.scale_toggle.X && scale_obs.Y < this.scale_toggle.Y;

            if(isFar) {
              outIcObj = this.icObj_front;
            } else {
              outIcObj = this.icObj_back;
            }

            return outIcObj;
          }

          setActiveIcObject(icObj_new) {

            const icObj_old = this.icObj_active;

            if(icObj_new != icObj_old) {
              this.icObj_active = icObj_new;

              this.didUpdateListeners.forEach((listener, i) => {
                listener(icObj_old, icObj_new);
              });
            }

          }

          // didUpdate() {
          //
          // }



        }

        class ManyAnObject {

        }

        // const sandBox_doubleObjects = new SandBox_doubleObjects(infiniteCanvas);

    </script>


    <script>
        class SandBox_sparkles {
          constructor(infiniteCanvas) {
            this.infiniteCanvas = infiniteCanvas;

            this.objects = {};

            this.initialize();
          }

          initialize() {
            const infiniteCanvas = this.infiniteCanvas;

            this.initialize_objects(infiniteCanvas);

            const arr_objects = Object.values(this.objects);
            arr_objects.forEach((object, i) => {
              this.materialize_object(object, infiniteCanvas);
            });

          }

          initialize_objects(infiniteCanvas) {

            //sparkle #1
            {
              const dO_id        = "dO#1"
              const dO_homeScale = {
                X:20.0,
                Y:20.0,
              };

              const img_sparkle = "lol";
              const icObj = infiniteCanvas.createIcImage(500, 500, img_sparkle);  //SHU: formally, sparkle could hold any icObject or even more complicated type
              icObj.homeScale = dO_homeScale;                                     //     sparkle can hold any "representable" object

              const sparkle = new Sparkle(dO_id, icObj);
              sparkle.obsScale = infiniteCanvas.scale;

              this.sparkles[sparkle.id] = sparkle;
            }

          }

          materialize_object(object, infiniteCanvas) {

            const sparkle = object;

            const icObj = sparkle.icObj;
            infiniteCanvas.addIcObject(icObj);

            infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
              sparkle.updateWithObservationScale(infiniteCanvas.scale);
            });

            sparkle.didUpdateListeners.push((sparkle) => {
              const icObj = sparkle.icObj;
              infiniteCanvas.requestViewUpdateForIcObj(icObj);
            });

          }

        }

        class Sparkle {

          constructor(id, icObj) {
            this.id = id;

            this.icObj = icObj;

            this.homeScale = Object.assign({}, icObj.homeScale);
            this.obsScale  = null;

            this.didUpdateListeners = [];
          }

          updateWithObservationScale(scale_obs) {
            console.log("updateWithObservationScale", scale_obs);
            icObj.homeScale = scale_obs;
          }



        }

        // const sandBox_sparkles = new SandBox_sparkles(infiniteCanvas);

    </script>

    <script>
        class ZPuzzle {
          constructor(infiniteCanvas) {
            this.infiniteCanvas = infiniteCanvas;

            this.objects = {
              slots:  {},
              pieces: {},
            };

            this.initialize();
          }

          initialize() {
            const infiniteCanvas = this.infiniteCanvas;

            this.initialize_objects(infiniteCanvas);

            const arr_slots = Object.values(this.objects.slots);
            arr_slots.forEach((slot, i) => {
              this.materialize_slot(slot, infiniteCanvas);
            });

            const arr_pieces = Object.values(this.objects.pieces);
            arr_pieces.forEach((piece, i) => {
              this.materialize_piece(piece, infiniteCanvas);

              const slot = this.objects.slots[piece.id];
              this.bindSlotAndPiece(slot, piece);
            });

          }

          initialize_objects(infiniteCanvas) {

            //s/p #1
            {
              const id = "id_sp1";
              const icObj = infiniteCanvas.createIcRect_withLTWH(500, 500, 500 , 500);
              icObj.fill = ZPuzzle.colorForNumber(1);

              const slotAndPiece = ZPuzzle.debugSlotAndPiece(id, icObj);
              this.objects.slots[id]  = slotAndPiece.slot;
              this.objects.pieces[id] = slotAndPiece.piece;
              slotAndPiece.piece.icObj.position = {
                x: slotAndPiece.piece.icObj.position.x + 600,
                y: slotAndPiece.piece.icObj.position.x + 100,
              };
            }

          }



          materialize_slot(slot, infiniteCanvas) {

            const icObj = slot.icObj;
            infiniteCanvas.addIcObject(icObj);

            // infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
            //   sparkle.updateWithObservationScale(infiniteCanvas.scale);
            // });

            // sparkle.didUpdateListeners.push((sparkle) => {
            //   const icObj = sparkle.icObj;
            //   infiniteCanvas.requestViewUpdateForIcObj(icObj);
            // });

          }

          materialize_piece(piece, infiniteCanvas) {

            const icObj = piece.icObj;
            infiniteCanvas.addIcObject(icObj);

            // infiniteCanvas.didUpdateListenersDict["scaleChanged"].push((infiniteCanvas) => {
            //   sparkle.updateWithObservationScale(infiniteCanvas.scale);
            // });

            // sparkle.didUpdateListeners.push((sparkle) => {
            //   const icObj = sparkle.icObj;
            //   infiniteCanvas.requestViewUpdateForIcObj(icObj);
            // });

          }

          bindSlotAndPiece(slot, piece) {
            piece.didUpdateListeners.push((piece) => {

              if(!piece.isSnapped) {
                slot.attemptSnapping(piece);
              }

            });
          }


          static debugSlotAndPiece(spid, icObj) {
            // const icObj_slot  = icObj.clone();


            // const icObj_slot = backingObj.inner;
            // const backingObj = BackingObject.fromObject(icObj);
            // const icObj_slot = backingObj.getNewRepresentation();
            const icObj_slot = Representation.initial(icObj);
            icObj_slot.addOnOuterUpdate((icObj_slot) => {
              console.log("icObj_slot","onOuterUpdate", icObj_slot);

            });

            icObj_slot.opacity = 0.2;
            const slot = new ZPuzzleSlot(spid, icObj_slot);

            // const icObj_piece = icObj.clone();
            // const icObj_piece = backingObj.getNewRepresentation();
            const icObj_piece = Representation.initial(icObj);
            icObj_piece.addOnOuterUpdate((icObj_piece) => {
              console.log("icObj_piece","onOuterUpdate", icObj_piece);

            });

            //debug
            icObj_piece.createSisterRepresentation().addOnOuterUpdate((icObj_piece) => {
              console.log("icObj_piece sister rep","onOuterUpdate", icObj_piece);

            });

            setTimeout(() => {
              console.log("setTimeout", "update icObj_piece.position");
              icObj_piece.position = {
                x: icObj_piece.position.x + 100,
                y: icObj_piece.position.y + 100,
              };
            }, 3000);



            const piece = new ZPuzzlePiece(spid, icObj_piece);

            const slotAndPiece = {
              slot: slot,
              piece: piece,
            };

            return slotAndPiece;
          }

          static colorForNumber(number) {
            var outColor;

            switch(number) {
              case 1:
                outColor = "#FF7F0E";
                break;
              case 2:
                outColor = "#2CA02C";
                break;
              case 3:
                outColor = "#D62728";
                break;
              case 4:
                outColor = "#9467BD";
                break;
              case 5:
                outColor = "#8C564B";
                break;
              case 6:
                outColor = "#E377C2";
                break;
              case 7:
                outColor = "#7F7F7F";
                break;
              case 8:
                outColor = "#BCBD22";
                break;
              case 9:
                outColor = "#17BECF";
                break;

              default:
                outColor = "#000000";
                break;
            }

            return outColor;
          }

        }

        class ZPuzzleSlot {

          constructor(id, icObj) {
            this.id = id;

            this.icObj = icObj;

            // this.didUpdateListeners = [];
          }

          attemptSnapping(piece) {
            console.log("attemptSnapping", piece);

            const canSnap = this.checkCanSnap(piece);

            if(canSnap) {
              this.snap(piece);
            }

          }

          checkCanSnap(piece) {
            var outBool;

            const icObj_slot  = this.icObj;
            const icObj_piece = piece.icObj;

            outBool = true;

            return outBool;
          }

          snap(piece) {

            piece.isSnapped = true;


            const icObj_slot  = this.icObj;
            const icObj_piece = piece.icObj;

            const icObj_new = Object.assign({}, icObj_piece);
            icObj_new.position     = Object.assign({}, icObj_slot.position);
            icObj_new.homeScale    = Object.assign({}, icObj_slot.homeScale);
            icObj_new.scale        = Object.assign({}, icObj_slot.scale);
            icObj_new.orientation  = icObj_slot.orientation;

            icObj_piece.update(icObj_new, "model");
          }

        }

        class ZPuzzlePiece {

          constructor(id, icObj) {
            this.id = id;

            this.icObj = icObj;

            this.isSnapped = false;

            this.didUpdateListeners = [];

            icObj.didUpdateListeners.push((icObj) => {
              this.didUpdate();
            })
          }

          didUpdate() {
            this.didUpdateListeners.forEach((listener, i) => {
              listener(this);
            });
          }

        }

        // const zPuzzle_4pieces = ZPuzzle.default_4pieces(infiniteCanvas);
        const zPuzzle_4pieces = new ZPuzzle(infiniteCanvas);

    </script>



</body>

</html>
