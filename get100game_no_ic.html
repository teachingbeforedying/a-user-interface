<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GET100 (no iC)</title>

  <style>
    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;

      /* Prevent document pinch-zoom & touch-hold-to-highlight */
      touch-action: none;

      -webkit-touch-callout: none;
      /* iOS Safari */
      -webkit-user-select: none;
      /* Safari */
      -khtml-user-select: none;
      /* Konqueror HTML */
      -moz-user-select: none;
      /* Old versions of Firefox */
      -ms-user-select: none;
      /* Internet Explorer/Edge */
      user-select: none;
      /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
    }
  </style>

</head>

<body>

  <!-- <video id="myVideo"></video> -->
  <!-- <button id="myButton"></button> -->
  <!-- <img id="myImage" src="https://i.stack.imgur.com/8fooU.png"></img> -->

  <!-- <script src='saves/th_nostalgie.js' type='text/javascript'> </script> -->


  <!-- <link  href="lib/video-js.min.css" rel="stylesheet"> -->
  <!-- <script src="lib/video.min.js"></script> -->

  <!-- utils -->
  <script>

    class Utils {

      static arrayByRemovingElement(src_arr, elt) {

        const index = src_arr.indexOf(elt);

        return this.arrayByRemovingElementAtIndex(src_arr, index);
      }

      static arrayByRemovingElementAtIndex(src_arr, index) {

        const arr = [...src_arr]; //create shallow copy of src_arr

        const arr_removed = arr.splice(index, 1);   //starting at index, remove 1 element
        const arr_new = arr;                    //array is mutated in place

        return arr;
      }

      static randomElementInArray(arr) {
        const elt = arr[Math.floor(Math.random() * arr.length)];

        // "~~" for a closest "int"
        // const elt = arr[~~(arr.length * Math.random())];

        // "|" for a kinda "int div"
        // const elt = arr[arr.length * Math.random() | 0];

        return elt;
      }

      static randomElementInArray__weighted(arr, arr_weight_in) {
        var i;

        const arr_weight = [...arr_weight_in];

        for (i = 0; i < arr_weight.length; i++)
          arr_weight[i] += arr_weight[i - 1] || 0;

        const random = Math.random() * arr_weight[arr_weight.length - 1];

        for (i = 0; i < arr_weight.length; i++)
          if (arr_weight[i] > random)
            break;

        return arr[i];
      }

      static early_break_reduce(arr, reduce_callback, initial, checkStopFunc) {
        const x = [...arr]                         // create copy of "array" for iterating
          .reduce((acc, x, i, arr) => {
            if (checkStopFunc(acc, x, i, arr)) {
              arr.splice(1);     // eject early by mutating iterated copy
              return acc;
            }
            return reduce_callback(acc, x, i, arr);
          }, initial);
        return x;
      }


      static randomSubArrWithArray(arr_src_in, nb) {
        var arr_src = [...arr_src_in];
        return [...Array(nb).keys()].reduce((acc, x) => {
          const arr_index = [...Array(arr_src.length).keys()]
          const index_random = Utils.randomElementInArray(arr_index);
          const elt_picked = arr_src[index_random];
          arr_src = Utils.arrayByRemovingElementAtIndex(arr_src, index_random);
          return [...acc, elt_picked];
        }, []);
      }



      /**
       * Shuffles array in place.
       * @param {Array} a items An array containing the items.
       */
      static shuffle(a) {
        var j, x, i;
        for (i = a.length - 1; i > 0; i--) {
          j = Math.floor(Math.random() * (i + 1));
          x = a[i];
          a[i] = a[j];
          a[j] = x;
        }
        return a;
      }

      static arr_progress(nb_steps) {
        var outArr;

        outArr = [...Array(nb_steps).keys()].map(index => {
          const progress = 1.0 * index / (nb_steps - 1);
          return progress;
        });
        logger.log("log1", "arr_progress", outArr);

        return outArr;
      }

      static partitionArray(arr, spacing) {
        var output = [];

        for (var i = 0; i < arr.length; i += spacing) {
          output[output.length] = arr.slice(i, i + spacing);
        }

        return output;
      }

    }


    class ColorUtils {

      static randomColor() {
        var r = 255 * Math.random() | 0,
          g = 255 * Math.random() | 0,
          b = 255 * Math.random() | 0;
        return 'rgb(' + r + ',' + g + ',' + b + ')';
      }



      static rainbow__color_with_progress(progress, nb_cycles) {
        var outString;
        const value_h = math.floor(360 * progress * nb_cycles) % 360;
        const color = new Color("hsl(" + value_h + ",80%,50%)");
        logger.log("log1", "rainbow__color_with_progress", color);

        // outString = color.toString({format: "hex"});
        function hslToHex(h, s, l) {
          l /= 100;
          const a = s * Math.min(l, 1 - l) / 100;
          const f = n => {
            const k = (n + h / 30) % 12;
            const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return Math.round(255 * color).toString(16).padStart(2, '0');   // convert to Hex and prefix "0" if needed
          };
          return `#${f(0)}${f(8)}${f(4)}`;
        }

        outString = hslToHex(color.h, color.s, color.l);

        logger.log("log1", "rainbow__color_with_progress", outString);

        return outString;
      }

      static rainbow__random_arr_of_length(length, nb_cycles) {
        var outArr;

        outArr = Utils.arr_progress(length)
          .map(progress => {
            return ColorUtils.rainbow__color_with_progress(progress, nb_cycles);
          });

        return outArr;
      }


    }


    class Logger {

      constructor() {
        this.initialize();

        // this.hush(this);
      }

      initialize() {
        this.invest(console);
        this.hush(console);
      }

      invest(obj) {
        this.log = obj.log;
        this.trace = obj.trace;
      }

      hush(obj) {
        obj.log = function () { };
        obj.trace = function () { };
      }


    }

    const logger = new Logger();

  </script>
  <!-- <script>
      //debug
      const arr_test = [1,2,3,4,5,6];
      const s = Utils.early_break_reduce(arr_test, (acc,x,i,arr) => {
        logger.log("x", x);
        return acc + x;
      }, 0, (acc, x, i, arr) => {
        return i > 2;
      });
      logger.log("s", s);
    </script> -->

  <!-- <script src='lib/base64.js' type='text/javascript'></script> -->

  <!-- <script src='lib/Queue.js' type='text/javascript'> </script> -->
  <!-- <script src='lib/PriorityQueue.js' type='text/javascript'> </script> -->


  <!-- UI -->
  <!-- <script src='lib/fabric.min.js'      type='text/javascript'></script> -->
  <!-- "tool canvas" -->
  <!-- <canvas id="canvas__tool" style="visibility:hidden;">Your browser does not support HTML5 canvas</canvas> -->
  <!-- <script>
      const canvas__tool = document.getElementById("canvas__tool");
      canvas__tool.width  = window.innerWidth;
      canvas__tool.height = window.innerHeight;
    </script> -->
  <!-- <script>
      const canvas__tool = document.createElement("canvas");
      canvas__tool.id = "canvas__tool";
      canvas__tool.width  = 1000;
      canvas__tool.height = 1000;
      // canvas__tool.style.visibility = 'hidden';
      // document.body.appendChild(canvas__tool);
    </script> -->
  <!-- <script>
      const fabricCanvas__tool = new fabric.Canvas(canvas__tool.id, {
        backgroundColor: 'rgba(0,0,0,0)',
        // backgroundColor: 'rgb(0,0,0)',

        width:  canvas__tool.width,
        height: canvas__tool.height,
      });
      logger.log("fabricCanvas__tool", fabricCanvas__tool);
    </script> -->
  <script>
    class ImageUtils {

      static boundingBox__pixelWise(imageData, w, h) {
        var outBoundingBox;

        const arr_x = [...Array(w).keys()];
        const arr_y = [...Array(h).keys()];

        const mat_xy = arr_x.map(x => {
          return arr_y.map(y => {
            const point = {
              x: x,
              y: y,
            };
            return point;
          });
        }).flat();

        outBoundingBox = mat_xy.reduce((acc, point) => {

          const x = point.x;
          const y = point.y;

          const arr_rgba = ImageUtils.getPixelArrRgba(imageData, w, h, x, y);

          const r = arr_rgba[0];
          const g = arr_rgba[1];
          const b = arr_rgba[2];
          const a = arr_rgba[3];

          const isRgbNonZero = (r != 0) || (g != 0) || (b != 0);
          const isAlphaNonZero = (a != 0);

          const isNonEmpty = isRgbNonZero && isAlphaNonZero;
          if (isNonEmpty) {
            // logger.log("x", x, "y", y);
            // logger.log("arr_rgba", arr_rgba);

            acc.x1 = Math.min(acc.x1, point.x);
            acc.y1 = Math.min(acc.y1, point.y);
            acc.x2 = Math.max(acc.x2, point.x);
            acc.y2 = Math.max(acc.y2, point.y);
          }

          return acc;
        }, {
          x1: w - 1,
          y1: h - 1,
          x2: 0,
          y2: 0,
        });

        return outBoundingBox;
      }

      static getImageDataObj(dataUrl) {

        const ctx = canvas__tool.getContext("2d");
        logger.log("ctx", ctx);
        ctx.width = canvas__tool.width;
        ctx.height = canvas__tool.height;

        //clear context
        ctx.clearRect(0, 0, ctx.width, ctx.width);

        return new Promise(function (resolve, reject) {
          if (dataUrl == null) return reject();

          var image = new Image();
          image.addEventListener('load', function () {
            const w = image.width;
            const h = image.height;

            var width__ctx_old = ctx.width;
            if (w > ctx.width) {
              ctx.width = w;
            }
            var height__ctx_old = ctx.height;
            if (h > ctx.height) {
              ctx.height = h;
            }

            ctx.drawImage(image, 0, 0, w, h);

            // const imageData = ctx.getImageData(0, 0, w, h).data.buffer;
            const imageData = ctx.getImageData(0, 0, w, h);

            const imageDataObj = {
              data: imageData,
              w: w,
              h: h,
            };

            ctx.width = width__ctx_old;
            ctx.height = height__ctx_old;

            resolve(imageDataObj, false);
          });
          image.src = dataUrl;
        });

      }

      static imageFromImageData(imagedata) {
        var ctx = canvas__tool.getContext('2d');
        canvas__tool.width = imagedata.width;
        canvas__tool.height = imagedata.height;
        ctx.putImageData(imagedata, 0, 0);

        var image = new Image();
        image.src = canvas__tool.toDataURL();
        return image;
      }

      static imageFromDataUrl_p(dataUrl) {
        const image_p = new Promise(function (resolve, reject) {
          if (dataUrl == null) return reject();

          var image = new Image();
          image.addEventListener('load', function () {
            resolve(image, false);
          });
          image.src = dataUrl;
        });
        return image_p;
      }

      static imageFromVideo_p(video) {

        canvas__tool.height = video.videoHeight;
        canvas__tool.width = video.videoWidth;

        const ctx = canvas__tool.getContext("2d");
        logger.log("ctx", ctx);

        ctx.drawImage(video, 0, 0, canvas__tool.width, canvas__tool.height);
        const dataUrl = canvas__tool.toDataURL();

        const image_p = new Promise(function (resolve, reject) {
          if (dataUrl == null) return reject();

          var image = new Image();
          image.addEventListener('load', function () {
            resolve(image, false);
          });
          image.src = dataUrl;
        });

        return image_p;

      }

      static getPixelArrRgba(imageData, w, h, x, y) {
        // logger.log("getPixel", imageData, w, h, x, y);

        // const data = new Uint32Array(imageData);
        // logger.log("data.length", data.length);
        // logger.log("w * h", w * h);

        // const index__pixel = y * w + x;
        // const value__pixel = data[index__pixel];
        // return value__pixel;

        const data = imageData.data;
        const index__pixel = y * w + x;
        const index__pixel4 = index__pixel * 4;

        const index__r = index__pixel4;
        const index__g = index__pixel4 + 1;
        const index__b = index__pixel4 + 2;
        const index__a = index__pixel4 + 3;

        const r = data[index__r];
        const g = data[index__g];
        const b = data[index__b];
        const a = data[index__a];

        return [r, g, b, a];
      }

      static getPixelRgbaColorString(imageData, w, h, x, y) {
        const arr_rgba = ImageUtils.getPixelArrRgba(imageData, w, h, x, y);

        const rgbaColorString = "rgba(" + arr_rgba.join(",") + ")";

        return rgbaColorString;
      }

      // static qrcode__decode_image(img) {
      //   const imageData = ImageUtils.getImageDataObj(img);
      //   return ImageUtils.qrcode__decode_imageData(imageData);
      // }


      // static qrcode__decode_image_p__zxing(img) {
      //   const codeReader = new ZXing.BrowserMultiFormatReader();
      //   // logger.log("codeReader", codeReader);
      //   return codeReader.decodeFromImage(img);
      // }

      // static qrcode__decode_imageData__zxing(imageData) {
      //   logger.log("log1", "qrcode__decode_imageData", imageData);
      //
      //   const BarcodeFormat      = ZXing.BarcodeFormat;
      //   const DecodeHintType     = ZXing.DecodeHintType;
      //   const MultiFormatReader  = ZXing.MultiFormatReader;
      //   const RGBLuminanceSource = ZXing.RGBLuminanceSource;
      //   const BinaryBitmap       = ZXing.BinaryBitmap;
      //   const HybridBinarizer    = ZXing.HybridBinarizer;
      //
      //
      //   const hints   = new Map();
      //   const formats = [BarcodeFormat.QR_CODE, ZXing.BarcodeFormat.DATA_MATRIX/*, ...*/];
      //
      //   hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);
      //
      //   const reader = new MultiFormatReader();
      //
      //   const imgByteArray = imageData.data;
      //   const imgWidth     = imageData.width;
      //   const imgHeight    = imageData.height;
      //
      //   const luminanceSource = new RGBLuminanceSource(imgByteArray, imgWidth, imgHeight);
      //   const binaryBitmap    = new BinaryBitmap(new HybridBinarizer(luminanceSource));
      //
      //   return reader.decode(binaryBitmap, hints);
      // }




      static qrcode__decode_image_p(img, shouldTryWithFilters = true) {

        //create
        const id__reader = "reader";

        const readerElt = document.createElement("div");
        logger.log("readerElt", readerElt);
        readerElt.setAttribute("id", id__reader);
        readerElt.setAttribute("width", "600px");
        // readerElt.setAttribute("width","100px"); //test

        document.body.appendChild(readerElt);

        const reader = new Html5Qrcode(id__reader, { formatsToSupport: [Html5QrcodeSupportedFormats.QR_CODE] });
        logger.log("reader", reader);

        const file = FileIntegration.fileForImg(img);

        const result_p = reader.scanFile(file, true)
          .then(decodedText => {
            logger.log("decodedText", decodedText);
            return decodedText;
          })
          .catch(err => {
            // failure, handle it.
            logger.log(`Error scanning file. Reason: ${err}`);

            if (shouldTryWithFilters) {
              //retry with different brightness and contrast
              const value__brightness = 0.10;
              const value__contrast = 0.30;

              const img__filtered_p = ImageUtils.image_filtered_p(img, value__brightness, value__contrast);
              const decodedText__filtered_p = img__filtered_p.then(image_filtered => {
                return ImageUtils.qrcode__decode_image_p(img__filtered, false);
              });

              return decodedText__filtered_p;
            }

          })
          .finally(() => {
            readerElt.remove();
          });

        return result_p;
      }


      //filters

      static image_filtered_p(img, value_brightness, value_contrast) {
        const fObj = new fabric.Image(img);
        const filter__brightness = new fabric.Image.filters.Brightness({
          brightness: value_brightness,
        });
        const filter__contrast = new fabric.Image.filters.Contrast({
          contrast: value_contrast,
        });
        fObj.filters.push(filter__brightness);
        fObj.filters.push(filter__contrast);
        fObj.applyFilters();

        //get image from fObj
        const dataUrl = fObj.toDataURL();
        const img__filtered_p = ImageUtils.imageFromDataUrl_p(dataUrl);
        return img__filtered_p;
      }

    }

  </script>


  <!-- <script src='lib/anime.min.js'          type='text/javascript'></script> -->

  <script src='lib/color.global.min.js' type='text/javascript'></script>


  <!-- QRCODE -->
  <!-- <script src='lib/instascan.browserified.bundle.js' type='text/javascript'></script>
  <script>
    const Instascan = Bundle_IS.Instascan;
    logger.log("log1", "Instascan", Instascan);
  </script> -->
  <!-- debug -->
  <!-- <video id="preview" style="width: 300px; height: 300px;"></video> -->
  <!-- <script>
      let scanner = new Instascan.Scanner({ video: document.getElementById('preview') });
      scanner.addListener('scan', function (content) {
        alert(content);
      });
      Instascan.Camera.getCameras().then(function (cameras) {
        if (cameras.length > 0) {
          scanner.start(cameras[0]);
        } else {
          console.error('No cameras found.');
        }
      }).catch(function (e) {
        console.error(e);
      });
  </script> -->

  <script src='lib/zxingjs.browserified.bundle.js' type='text/javascript'></script>
  <script>
    const ZXing = Bundle_ZX.ZXing;
    // logger.log("log1", "ZXing", ZXing);
  </script>

  <script src="lib/html5-qrcode.min.js" type="text/javascript"></script>
  <!-- <script>
      logger.log("log1", "Html5Qrcode", Html5Qrcode);
    </script> -->

  <script src='lib/nodeqrcode.browserified.bundle.js' type='text/javascript'></script>
  <script>
    const NodeQRCode = Bundle_NQ.NodeQRCode;
      // logger.log("log1", "NodeQRCode", NodeQRCode);
  </script>
  <!-- convenience -->
  <script>
    function qrcodeImg_p(str_in) {
      const dataURL_p = NodeQRCode.toDataURL(str_in);
      const img_p = dataURL_p.then((dataURL) => {
        logger.log("log1", "qrcodeImg_p, dataURL", dataURL);
        return FileIntegration.imageFromImgSrc_p(dataURL);
      });
      return img_p;
    }
  </script>


  <!-- MathJax -->
  <!-- <script>
      //setup
      MathJax = {
        loader: {
          load: [
            '[tex]/color',
            '[tex]/newcommand',
          ],
        },
        tex: {
          packages: {
            '[+]': [
              'color',
              'newcommand'
            ],
          },
        },
        startup: {
          ready: () => {
            logger.log('MathJax is loaded, but not yet initialized');
            MathJax.startup.defaultReady();
            logger.log('MathJax is initialized, and the initial typeset is queued');
            // logger.log("MathJax", MathJax);

            //newcommand
              //discovery
            MathJax.tex2svg("\\newcommand{\\braket}[1]{\\langle #1 \\rangle}");

              //centernot / fsl(Feynman slash)
            // MathJax.tex2svg("\\newcommand{\\fsl}[1]{\\ensuremath{\\mathrlap{\\!\\not{\\phantom{#1}}}#1}}");
            // MathJax.tex2svg("\\newcommand{\\fsl}[1]{{\\ooalign{\\(#1\\)\\cr\\hidewidth\\(/\\)\\hidewidth\\cr}}");
            // MathJax.tex2svg("\\newcommand{\\fsl}[1]{{\\centernot{#1}}}");

              //colored operation
            MathJax.tex2svg("\\newcommand{\\redbraket}[1]{\\color{red}{\\langle} \\color{black}{#1} \\color{red}{\\rangle}}");
            // MathJax.tex2svg("\\newcommand{\\colorbraket}[2]{\\color{#1}{\\langle} #2 \\color{#1}{\\rangle}}");
            // MathJax.tex2svg("\\newcommand{\\blueoline}[1]{\\colorlet{temp}{.}\\color{blue}\\overline{\\color{temp}#1}\\color{temp}}");
            // MathJax.tex2svg("\\newcommand{\\colorbraket}[2]{\\colorlet{temp}{.} \\color{#1}{\\langle} \\color{temp}{#2} \\color{#1}{\\rangle} \\color{temp}}");

            const mathJaxContainer_svg = MathJax.tex2svg("{\\color{red} 13}");
            logger.log("mathJaxContainer_svg", mathJaxContainer_svg);
          },
        },
      };

      // MathJax = {
      //   tex: {
      //     autoload: {
      //       color: ['color', 'definecolor', 'textcolor', 'colorbox', 'fcolorbox'],
      //     },
      //   },
      // };
    </script> -->
  <!-- <script src='lib/mathjax.tex-mml-chtml.js' type='text/javascript'></script> -->
  <!-- <script src='lib/mathjax.tex-svg.js' type='text/javascript'></script>
    <script>
      //test
      logger.log("MathJax", MathJax);
      logger.log("MathJax.tex2svg", MathJax.tex2svg);
      // MathJax.tex2svg("{\\color(red) 13}");
    </script> -->

  <!-- <script>
      //integration
      class TexHelper {
        static toSvgEl(tex, color = "red") {
          const mathJaxContainer_svg = MathJax.tex2svg(tex);

          const htmlCollection = mathJaxContainer_svg.children;
          const svgEl = htmlCollection.item(0);
          console.log("svgEl", svgEl);

          svgEl.style.color = color;
          // svgEl.style.color2 = "blue";

          return svgEl;
        }
      }

      class SvgHelper {
        static toDataURL(svgEl) {
          var outDataUrl;

          // const svgSource = svgEl.outerHTML;

          const serializer = new XMLSerializer();
          const svgSource  = serializer.serializeToString(svgEl);

          // svgSource = svgSource.replaceAll('http://', 'https://');
          console.log("svgSource", svgSource);

          const dataUrl   = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svgSource)));

          outDataUrl = dataUrl;

          return outDataUrl;
        }
      }
    </script> -->
  <!-- <script>
      //discovery
      console.log("MathJax", MathJax);
      // const mathJaxContainer_svg = MathJax.tex2svg('\\frac{1}{x^2-1}', {display: true});
      const mathJaxContainer_svg = MathJax.tex2svg('\\frac{1}{x^2-1}');
      console.log("mathJaxContainer_svg", mathJaxContainer_svg);
    </script> -->

  <!-- <script src='lib/countdown.min.js' type='text/javascript'></script> -->
  <!-- <script>
      //discovery
      var timerId =
        countdown(
          new Date(),
          function(ts) {
            console.log("countdown::ts", ts);
            if(ts.value > 3000) {
              stop();
            }
          },
          countdown.HOURS|countdown.MINUTES|countdown.SECONDS);
      console.log("countdown::timerId", timerId);

      function stop() {
        clearInterval(timerId);
      }
    </script> -->
  <!-- <script src='lib/html2canvas.min.js' type='text/javascript'></script> -->
  <!-- <div id="lolilol" style="width: 100px; height: 100px; background-color:yellow">123456789</div>
    <script>
      //discovery
      html2canvas(document.getElementById("lolilol")).then(function(canvas) {
        // document.body.appendChild(canvas);
        console.log("html2canvas, canvas", canvas);
      });
    </script> -->
  <!-- <link rel="stylesheet" href="lib/mathquill/mathquill.css"/>
    <script src='lib/mathquill/jquery-3.5.1.min.js' type='text/javascript'></script>
    <script src='lib/mathquill/mathquill.min.js' type='text/javascript'></script>
    <script>
      const MQ = MathQuill.getInterface(2);
      console.log("MQ", MQ);

      function createMathField() {
        var outMathField;

        const span = document.createElement("span");

        if(span.style == null) {span.style = {};}
        span.style.backgroundColor = "yellow";
        // span.style.width  = "100px";
        // span.style.height = "100px";
        span.style.color = "purple";


        span.style.textAlign     = "center";
        span.style.verticalAlign = "middle";

        const mathField = MQ.MathField(span, {
          handlers: {
            edit: function() {
              var tex = mathField.latex(); // Get entered math in LaTeX format
              console.log("tex", tex);
            }
          }
        });
        console.log("mathField", mathField);

        outMathField = mathField;

        return outMathField;
      }

    </script> -->


  <!-- <p><span id="answer">x=</span></p>
    <script>
      var answerSpan = document.getElementById('answer');
      var answerMathField = MQ.MathField(answerSpan, {
        handlers: {
          edit: function() {
            var enteredMath = answerMathField.latex(); // Get entered math in LaTeX format
            // checkAnswer(enteredMath);
            console.log("enteredMath", enteredMath);
          }
        }
      });
    </script> -->


  <!-- Maths -->
  <script src='lib/decimal.min.js' type='text/javascript'></script>

  <script src='lib/math.js' type='text/javascript'></script>
  <script>
    //customization

    class MySummerNode extends math.ConstantNode {

      // toTex() {
      //   if(this.value == 1) {
      //     // return "un";
      //     return "\\not{1}";
      //   }
      //   return super.toTex();
      // }

      toTex() {
        var outTex;

        const tex__legacy = super.toTex();

        if (this.isSlashed) {
          return "\\not{" + tex__legacy + "}";
        } else {
          outTex = tex__legacy;
        }

        return outTex;
      }

    }
  </script>


  <!-- <script src='lib/algebra-0.2.6.min.js' type='text/javascript'></script> -->
  <!-- <script>

      //discovery
      {
        // const chain = math.chain(1);
        //OR
        const chain = math.chain();
        chain.value = 1;
        console.log("debug::chain, initial", chain);

        const step1 = chain.add(8);
        const r1    = step1.done();
        // const r1 = chain.valueOf();
        console.log("debug::chain, r1", r1);

        const step2 = step1.multiply(100);
        const r2    = step2.done();
        console.log("debug::chain, r2", r2);

        console.log("debug::chain is not mutated in place");     //which is nice and not surprising from a functional programming pov
        console.log("debug::chain.done()", chain.done());
      }

      //chaining on expression
      /*
      { //SHU: THE DREAM
        const math_with_algebra = math.create(math.all);
        math_with_algebra.import(algebra, {wrap: true, silent: true});
        // math_with_algebra.import(algebra, {override: true, wrap: true, silent: true});

        const chain = math_with_algebra.chain();

        // const expr   = new algebra.Expression("x");
        const expr   = new math_with_algebra.Expression("x");
        // const expr = "x";

        console.log("expr", expr);
        chain.value = expr;                                             //SHU TODO: make this possible
        console.log("debug::chain, initial", chain);

        // const step1 = chain.add(8);                                      //SHU: en fait c'est peut-être juste un problème de coercion.
        const step1 = chain.add(new math_with_algebra.Expression(8));    //SHU: Ah non. Dommage.

        const r1    = step1.done();
        // const r1 = chain.valueOf();
        console.log("debug::chain, r1", r1);

        const step2 = chain.multiply(100);
        const r2    = step2.done();
        console.log("debug::chain, r2", r2);
      }
      */

      /*
      { //SHU: THE WORKAROUND
        var expr   = new algebra.Expression("x");
        expr = expr.multiply(2);
        expr = expr.multiply("x");
        expr = expr.multiply(new algebra.Expression("x"));
        expr = expr.add("y");
        expr = expr.add(new algebra.Fraction(1, 3));
        expr = expr.add("y");                                       //SHU: oh, no. There is automatic reducing.
        console.log("expr", expr.toString());

        //Simplification
        //All expression operations accept a simplify argument that will yield an unsimplified expression when set to false.
        //You can then get a simplified expression with Expression.simplify.

        var expr   = new algebra.Expression("x");
        expr = expr.multiply(2,false);
        expr = expr.multiply("x",false);
        expr = expr.multiply(new algebra.Expression("x"),false);
        expr = expr.add("y",false);
        expr = expr.add(new algebra.Fraction(1, 3),false);
        expr = expr.add(new algebra.Expression("y"),false);
        console.log("expr", expr.toString());                       //SHU: unsimplified expression terms order is wrong
        expr = expr.simplify();                                     //SHU TODO: show correct terms order
        console.log("expr", expr.toString());
      }
      */

    </script> -->

  <!-- <script src='lib/math-expressions.js' type='text/javascript'></script> -->
  <!-- <script src='lib/math-expressions_umd.js' type='text/javascript'></script> -->
  <script src='lib/math-expressions.browserified.bundle.js' type='text/javascript'></script>
  <script>
    const MathExpression = Bundle_ME.MathExpression;
  </script>
  <!-- <script>
      //discovery
      const mathExpression1      = MathExpression.fromText("sin^2 (x^3)");
      const tex__mathExpression1 = mathExpression1.tex();
      console.log("MathExpression, tex__mathExpression1", tex__mathExpression1);

      const mathExpression2       = MathExpression.fromTex("5 \\times 3");
      const text__mathExpression2 = mathExpression2.toString();
      console.log("MathExpression, text__mathExpression2", text__mathExpression2);
    </script> -->



  <!-- <script src='lib/ngraph.graph.min.js' type='text/javascript'></script> -->
  <!-- <script>
      //discovery
      const g = createGraph();

      g.addNode('hello');
      g.addNode('world');
      //Now graph g contains two nodes: hello and world. You can also use addLink() method to grow a graph. Calling this method with nodes which are not present in the graph creates them:

      g.addLink('space', 'bar'); // now graph 'g' has two new nodes: 'space' and 'bar'
      //If nodes already present in the graph 'addLink()' makes them connected:

      // Only a link between 'hello' and 'world' is created. No new nodes.
      g.addLink('hello', 'world');

      console.log("g", g);
    </script> -->


  <script src='lib/algebrite.bundle-for-browser.js' type='text/javascript'></script>
  <script>

    //discovery
    const equality_1 = Algebrite.run('x + y + x == y + 2x');
    logger.log("equality_1", equality_1);

    const equality_2 = Algebrite.run('4(x + y) - x == 4y + 3x');
    logger.log("equality_2", equality_2);


    const equality_3 = Algebrite.run('4z(x + y) - zx == 4yz + 3xz');    //SHU: software is dumb and intelligent: a priori, xz != zx ( or maybe it's something else ... )
    logger.log("equality_3", equality_3);

    const equality_4 = Algebrite.run('4z(x + y) - zx == 4zy + 3zx');
    logger.log("equality_4", equality_4);

  </script>

  <!-- custom maths stuff -->
  <script>

    const dict_opConfig = {
      1: {
        minus: {
          arity: 1,
          symbol: "-",
          name: "unaryMinus",
          precedence: 6,
        },
        inverse: {
          arity: 1,
          symbol: "/",
          name: "inverse",
          precedence: "?",
        },
      },
      2: {
        plus: {
          arity: 2,
          symbol: "+",
          // name: "plus",
          name: "add",
          precedence: 9,

          inverse: "minus",
        },
        minus: {
          arity: 2,
          symbol: "-",
          // name: "minus",
          name: "subtract",
          precedence: 9,

          inverse: "plus",
        },
        multiply: {
          arity: 2,
          symbol: "×",

          name: "multiply",
          precedence: 8,

          inverse: "divide",
        },
        divide: {
          arity: 2,
          symbol: "/",
          name: "divide",
          precedence: 8,

          inverse: "multiply",
        },
        // pow: {
        //   op: "^",
        //   name: "pow",
        // },
      },
      n: {
        plus: {
          arity: "n",
          symbol: "+",
          // name: "plus",
          name: "add",
          precedence: 9,

          inverse: "minus",
        },
        multiply: {
          arity: "n",
          symbol: "×",
          name: "multiply",
          precedence: 8,

          inverse: "divide",
        },
      },
    };


    // (...) [...] {...}		            1
    // x(...) x[...] obj.prop :		    2
    // '		                            3
    // !		                            4
    // ^, .^		                        5
    // +, -, ~, not		                6
    // See section below		            7
    // *, /, .*, ./, %, mod		        8
    // +, -		                        9
    // :		                           10
    // to, in		                     11
    // <<, >>, >>>		                 12
    // Err :501		                   13
    // &		                           14
    // ^|		                         15
    // |		                           16
    // and		                         17
    // xor		                         18
    // or		                         19
    // ?, :		                       20
    // =		                           21
    // ,		                           22
    // ;		                           23
    // \n, ;		                       24
    const precedenceDict = {
      "unaryPlus": 6,
      "unaryMinus": 6,

      "multiply": 8,
      "divide": 8,

      "add": 9,
      "subtract": 9,
    };


    class Operator {

      constructor(arity, easyName, symbol, name, inverseName = null) {
        this.arity = arity;
        this.easyName = easyName;

        this.op = symbol;
        this.symbol = symbol;

        this.name = name;

        this.inverseName = inverseName;
      }

      static fromConfig(opConfig) {
        const op = new Operator(opConfig.arity, "lolilol", opConfig.symbol, opConfig.name, opConfig.inverse);
        return op;
      }

      static randomInstance(arity) {

        const arr_opConfig = Object.values(dict_opConfig[arity]);
        const opConfig__random = Utils.randomElementInArray(arr_opConfig);

        const op__random = Operator.fromConfig(opConfig__random);
        return op__random;
      }


      inverse() {   //what did you expect ?
        const arity = this.arity;
        const inverseName = this.inverseName;

        const opConfig__inverse = dict_opConfig[arity][inverseName];

        const op__inverse = Operator.fromConfig(opConfig__inverse);
        return op__inverse;
      }


      static multiply() {
        var outOp;

        const opConfig = dict_opConfig[2]["multiply"];
        outOp = Operator.fromConfig(opConfig);

        return outOp;
      }

      static divide() {
        var outOp;

        const opConfig = dict_opConfig[2]["divide"];
        outOp = Operator.fromConfig(opConfig);

        return outOp;
      }

      static fromString_binary(opString) {
        var outOp;

        function fnString_for_opString(opString) {
          var outString;

          switch (opString) {
            case "+":
              outString = "plus";
              break;
            case "-":
              outString = "minus";
              break;
            case "x":
              outString = "multiply";
              break;
            case "/":
              outString = "divide";
              break;
          }

          return outString;
        }

        const fnString = fnString_for_opString(opString);

        const opConfig = dict_opConfig[2][fnString];
        outOp = Operator.fromConfig(opConfig);

        return outOp;
      }


    }

    class Operation {

      constructor(transformationFunc) {
        this.transformationFunc = transformationFunc;
      }

    }





    function random_op(arity) {
      const op = Operator.randomInstance(arity);
      return op;
    }
    // console.log("random_op", random_op(2));

    function random_number(range) {
      const span = range.max - range.min;
      const number = Math.floor(range.min + Math.random() * span);
      return number;
    }

    const arr_symbols = ["x", "y"];
    // const arr_symbols = ["x", "y", "z", "t", "a", "b"];

    function random_symbol() {
      const symbol = Utils.randomElementInArray(arr_symbols);
      return symbol;
    }

    function arityForArr(arr) {
      var outArity;

      switch (arr.length) {
        // case 0:
        //   outArity = 0;     //everything or nothing
        // break;
        case 1:
          outArity = 1;
          break;
        case 2:
          outArity = 2;
          break;
        default:
          outArity = "n";
          break;
      }

      return outArity;
    }

    //////////////////////

    function random_constantNode(range = { min: 0, max: 100, step: 1 }) {
      const number = random_number(range);
      const constantNode = new math.ConstantNode(number);
      return constantNode;
    }

    function random_symbolNode() {
      const symbol = random_symbol();
      const symbolNode = new math.SymbolNode(symbol);
      return symbolNode;
    }

    function random_terminal_mathNode_withType(type) {
      var outMathNode;

      switch (type) {
        case "ConstantNode":
          outMathNode = random_constantNode();
          break;
        case "SymbolNode":
          outMathNode = random_symbolNode();
          break;
        // case "operator":
        // break;
      }

      return outMathNode;
    }

    function random_terminal_mathNode_withType_inArr(arr_type) {
      const type = Utils.randomElementInArray(arr_type);
      const mathNode = random_terminal_mathNode_withType(type);
      return mathNode;
    }

    function random_terminal_mathNode_withType_inArr_and_isEnvelopped(arr_type, isEnvelopped) {

      var mathNode = random_terminal_mathNode_withType_inArr(arr_type);
      if (isEnvelopped) {
        mathNode = new math.ParenthesisNode(mathNode);
      }

      return mathNode;
    }

    function random_operatorNode(/*arity,*/ arr_node) {
      const arity = arityForArr(arr_node);
      const op = random_op(arity);
      const operatorNode = new math.OperatorNode(op.op, op.name, arr_node);
      return operatorNode;
    }

    function random_operatorNodeFactoryFunc_binary(arr_type) {
      var outFunc;

      const arity = 2
      const op = random_op(arity);

      const node_b = random_terminal_mathNode_withType_inArr(arr_type);

      outFunc = (node_a) => {
        const arr_node = [node_a, node_b];
        const operatorNode = new math.OperatorNode(op.op, op.name, arr_node);
        return operatorNode;
      };

      return outFunc;
    }

    function createMathNodeTransformationFunc_binary(mathOperatorSymbol_in, mathOperatorFuncName_in, node_b_in, isShuffled = false) {
      return (node_a) => {
        var outNode;

        const mathOperatorSymbol = mathOperatorSymbol_in;
        const mathOperatorFuncName = mathOperatorFuncName_in;
        const node_b = node_b_in;

        function standardOperation(node_in) {
          var outNode;

          // const node_b        = new math.ConstantNode(mathValue);

          var arr_child = [node_in, node_b];
          // logger.log("arr_child, before", arr_child);
          if (isShuffled) {
            switch (mathOperatorFuncName) {
              case "add":
              case "multiply":
                {
                  const shuffle = arr =>
                    [...arr].reduceRight((res, _, __, s) =>
                      (res.push(s.splice(0 | Math.random() * s.length, 1)[0]), res), []);

                  arr_child = shuffle(arr_child);
                  // logger.log("arr_child, after", arr_child);
                }
                break;
              default:
                //do nothing
                break;
            }
          }

          const node_operator = new math.OperatorNode(mathOperatorSymbol, mathOperatorFuncName, arr_child);

          const node_unsimplified = node_operator;

          if (node_in.autoSimplify) {
            // const node_simplified = math.simplify(node_unsimplified);
            const node_simplified = Simplifier.simplify_top_layer(node_unsimplified);
            outNode = node_simplified;
          } else {
            outNode = node_unsimplified;
          }

          outNode.autoSimplify = node_in.autoSimplify;

          return outNode;
        }

        // logger.log("node_a", node_a);
        if (node_a.isEquation) {
          console.log("node_a", node_a);
          const node_left = standardOperation(node_a.params[0]);
          const node_right = standardOperation(node_a.params[1]);
          const node_equation = new math.RelationalNode(["equal"], [node_left, node_right]);
          node_equation.isEquation = true;

          outNode = node_equation;
        } else {
          outNode = standardOperation(node_a);
        }

        // outNode.autoSimplify = node_a.autoSimplify;

        return outNode;
      };
    };

    function random_operatorNodeFactoryFuncWrapper_binary(operatorParams, arr_op = null) {
      var outFuncWrapper;

      const arr_type__node_b = operatorParams.node_b.types;
      const range__node_b = operatorParams.node_b.range;
      const arr__node_b = operatorParams.node_b.arr;

      const isShuffled = (operatorParams.isShuffled != null) ? operatorParams.isShuffled : false;


      const arity = 2
      var op;
      if (arr_op != null) {
        op = Utils.randomElementInArray(arr_op);
      } else {
        op = random_op(arity);
      }

      var node_b = random_terminal_mathNode_withType_inArr(arr_type__node_b);
      // logger.log("random_operatorNodeFactoryFuncWrapper_binary, node_b", node_b);
      if (node_b.type == "ConstantNode") {

        function randomValue() {
          return math.randomInt(range__node_b.min, range__node_b.max);
        }

        var value;
        if (arr__node_b != null) {
          value = Utils.randomElementInArray(arr__node_b);
        } else {
          value = randomValue();
        }
        // logger.log("value:", value);
        if (op.name == "divide") {
          while (value == 0) {
            value = randomValue();
          }
        }


        node_b = new math.ConstantNode(value);

        if (node_b.value < 0) {
          node_b = new math.ParenthesisNode(node_b);
        }

      }

      outFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b, isShuffled);

      return outFuncWrapper;
    }

    function operatorNodeFactoryFuncWrapper_binary(op, node_b, isShuffled = false) {
      var outFuncWrapper;

      const func = createMathNodeTransformationFunc_binary(op.op, op.name, node_b, isShuffled);

      const op__inverse = op.inverse();
      const func__inverse = createMathNodeTransformationFunc_binary(op__inverse.op, op__inverse.name, node_b, isShuffled);

      function createFuncWrapper(op, node_b, func) {

        const simpleName = op.op + " " + node_b.toString();

        const funcWrapper = {
          semantics: {
            operator: op,
            node_b: node_b.cloneDeep(),
            name: simpleName,
          },
          func: func,
          inverse: null,  //set later
        };

        return funcWrapper;
      }

      const funcWrapper = createFuncWrapper(op, node_b, func);
      const funcWrapper__inverse = createFuncWrapper(op__inverse, node_b, func__inverse);
      funcWrapper.inverse = funcWrapper__inverse;

      outFuncWrapper = funcWrapper;

      return outFuncWrapper;
    }


    function random_operatorNode_debug() {
      const arr_nodes = [
        random_symbolNode(),
        random_constantNode(),
      ];
      const operatorNode = random_operatorNode(arr_nodes);
      return operatorNode;
    }
    console.log("random_operatorNode_debug", random_operatorNode_debug());



    function random_operatorNode_binary_withDepth(depth) {
      if (depth < 2) {
        throw new Error("operatorNode is has min depth: 2");
      } else if (depth == 2) {
        const arr_node = [0, 1].map(index => random_terminal_mathNode_withType_inArr(["ConstantNode", "SymbolNode"]));
        const operatorNode = random_operatorNode(arr_node);
        return operatorNode;
      } else {
        const arr_node = [0, 1].map(index => random_operatorNode_binary_withDepth(depth - 1));
        const operatorNode = random_operatorNode(arr_node);
        return operatorNode;
      }
    }

    function random_mathNode_withDepth(depth) {
      var outMathNode;

      if (depth < 1) {
        throw new Error("mathNode is has min depth: 1");
      } else if (depth == 1) {
        const terminalNode = random_terminal_mathNode_withType_inArr(["ConstantNode", "SymbolNode"]);
        outMathNode = terminalNode;
      } else {
        const operatorNode = random_operatorNode_binary_withDepth(depth);
        outMathNode = operatorNode;
      }

      return outMathNode;
    }
    console.log("random_mathNode_withDepth", random_mathNode_withDepth(4));





    //only n symbols

    function getNbSymbolNodes(mathNode) {
      var outInt = 0;

      switch (mathNode.type) {
        case "SymbolNode":
          outInt = 1;
          break;
        case "OperatorNode":
          outInt = operator.params.reduce((acc, x) => acc + getNbSymbolNodes(x), 0);
      }

      return outInt;
    }

    function arr_terminalTypes_for_nbSymbols(nb_symbols) {
      const arr_terminalTypes = ["ConstantNode"];
      if (nb_symbols > 0) {
        arr_terminalTypes.push("SymbolNode");
      }
      return arr_terminalTypes;
    }

    function random_reduceObj__operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols) {   //SHU: it's nb_symbols_remaining
      var outObj;
      var outNode;
      var outNbSymbols;

      const depth_min = 2;

      if (depth < depth_min) {
        throw new Error("operatorNode is has min depth: 2");
      };

      var nb_symbols_curr = nb_symbols;
      if (depth == 2) {

        const arity = 2;
        const arr_nodeIndex = [...new Array(arity).keys()];

        const reducedObj2 = arr_nodeIndex.reduce((acc2, nodeIndex) => {
          const arr_terminalTypes = arr_terminalTypes_for_nbSymbols(acc2.nb_symbols);
          const mathNode = random_terminal_mathNode_withType_inArr(arr_terminalTypes);

          if (mathNode.type == "SymbolNode") {
            acc2.nb_symbols -= 1;
          }

          acc2.arr_mathNode.push(mathNode);

          return acc2;
        }, {
          nb_symbols: nb_symbols_curr,
          arr_mathNode: [],
        });

        outNbSymbols = reducedObj2.nb_symbols;

        const operatorNode = random_operatorNode(reducedObj2.arr_mathNode);
        outNode = operatorNode;
      } else {

        const arity = 2;
        const arr_nodeIndex = [...new Array(arity).keys()];

        const reducedObj2 = arr_nodeIndex.reduce((acc2, nodeIndex) => {
          const reducedObj_ = random_reduceObj__operatorNode_binary_withDepth_and_nbSymbols(depth - 1, acc2.nb_symbols);

          acc2.nb_symbols = reducedObj_.nb_symbols;

          const mathNode = reducedObj_.mathNode;
          acc2.arr_mathNode.push(mathNode);

          return acc2;
        }, {
          nb_symbols: nb_symbols_curr,
          arr_mathNode: [],
        });

        outNbSymbols = reducedObj2.nb_symbols;

        const operatorNode = random_operatorNode(reducedObj2.arr_mathNode);
        outNode = operatorNode;
      }

      outObj = {
        nb_symbols: outNbSymbols,
        mathNode: outNode,
      };
      console.log("depth", depth, "outNbSymbols", outNbSymbols);

      return outObj;
    }

    function random_operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols = 1) {
      const reduceObj = random_reduceObj__operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols);
      return reduceObj.mathNode;
    }

    function random_mathNode_withDepth_and_nbSymbols(depth, nb_symbols = 1) {
      var outMathNode;

      if (depth < 1) {
        throw new Error("mathNode is has min depth: 1");
      } else if (depth == 1) {
        const terminalNode = random_terminal_mathNode_withType_inArr(["ConstantNode", "SymbolNode"]);
        outMathNode = terminalNode;
      } else {
        const operatorNode = random_operatorNode_binary_withDepth_and_nbSymbols(depth, nb_symbols);
        outMathNode = operatorNode;
      }

      return outMathNode;
    }

    function random_onion_mathNode(depth, isWithExplicitationParentheses = true, isWithRandomParentheses = false) {
      var outMathNode;

      if (depth < 1) {
        throw new Error("mathNode is has min depth: 1");
      } else if (depth == 1) {

        const random_boolean = Math.random() < 0.5;
        const isEnvelopped = random_boolean;

        const terminalNode = random_terminal_mathNode_withType_inArr_and_isEnvelopped(["SymbolNode"], isEnvelopped);

        outMathNode = terminalNode;
      } else {
        const innerOnionNode = random_onion_mathNode(depth - 1, isWithExplicitationParentheses);

        const layerTerminalNode = random_terminal_mathNode_withType_inArr(["ConstantNode"]);

        const layerNode = random_operatorNode([innerOnionNode, layerTerminalNode]);
        console.log("layerNode", layerNode);

        outMathNode = layerNode;

        if (isWithExplicitationParentheses) {
          if (innerOnionNode.type == "OperatorNode") {
            console.log("innerOnionNode", innerOnionNode);

            const opFuncName__innerOnionNode = innerOnionNode.fn;
            const opFuncName__layerNode = layerNode.fn;

            const precedence__innerOnionNode = precedenceDict[opFuncName__innerOnionNode];
            const precedence__layerNode = precedenceDict[opFuncName__layerNode];

            const isSamePrecedence = (precedence__innerOnionNode == precedence__layerNode);

            if (isSamePrecedence) {
              var enveloppedInnerOnionNode;
              if (innerOnionNode.type == "ParenthesisNode") {    //already envelopped
                enveloppedInnerOnionNode = innerOnionNode;
              } else {
                enveloppedInnerOnionNode = new math.ParenthesisNode(innerOnionNode);
              }

              const layerNode_explicit = new math.OperatorNode(layerNode.op, layerNode.fn, [enveloppedInnerOnionNode, layerTerminalNode]);

              outMathNode = layerNode_explicit;
            }

          }

        }

      }

      return outMathNode;
    }

    // //debug
    // {
    //   const debugNode = random_mathNode_withDepth_and_nbSymbols(4, 2);
    //   console.log("debugNode(4,2)", debugNode);
    //   console.log("getDepth(debugNode)", getDepth(debugNode));
    // }





    function random_operatorNode_consumePool(pool) {

    }





    /*UTILS*/

    function getDepth(mathNode) {
      var outInt;

      switch (mathNode.type) {
        case "OperatorNode":
          {
            const arr_child_node = mathNode.args;
            const arr_child_node_depth = arr_child_node.map(node => getDepth(node));
            const max_child_depth = Math.max(...arr_child_node_depth);
            outInt = 1 + max_child_depth;
          }
          break;
        default:
          outInt = 1;
          break;
      }

      console.log("outInt", outInt);
      return outInt;
    }

    function getArr_all_leaves__node(mathNode) {
      var outArray;

      switch (mathNode.type) {
        case "OperatorNode":
          {
            const depth = getDepth(mathNode);
            if (depth == 2) {
              const arr_child = mathNode.args;
              outArray = arr_child;
            } else {
              outArray = mathNode.args.reduce((acc, child) => {
                const arr_grandChild = child.args;

                var arr_grandChild_sorted_by_decreasing_depth = arr_grandChild.slice();
                arr_grandChild_sorted_by_decreasing_depth.sort(function (a, b) {
                  const depth_a = getDepth(a);
                  const depth_b = getDepth(b);

                  if (depth_a > depth_b) {
                    return 1;
                  }
                  if (depth_a < depth_b) {
                    return -1;
                  }
                  return 0;
                });

                arr_grandChild_sorted_by_decreasing_depth.forEach((grandChild, i) => {
                  const arr_sub = getArr_all_leaves__node(grandChild);
                  console.log("arr_sub", arr_sub);
                  acc.push(...arr_sub);
                });

                return acc;

              }, []);
            }
          }
          break;
        default:
          outArray = [mathNode];
          break;
      }

      return outArray;
    }

    function getArr_all_leaves__treeObj(mathNode, parentPath = []) {
      var outArray;

      switch (mathNode.type) {
        case "OperatorNode":
          {
            const depth = getDepth(mathNode);
            if (depth == 2) {
              const arr_child = mathNode.args;
              outArray = arr_child.map((child, childIndex) => {
                const treeObj = {
                  node: child,
                  path: parentPath.concat([childIndex]),
                };
                return treeObj;
              });
            } else {
              outArray = mathNode.args.reduce((acc, child, childIndex) => {
                const arr_grandChild = child.args;

                var arr_grandChild_sorted_by_decreasing_depth = arr_grandChild.slice();
                arr_grandChild_sorted_by_decreasing_depth.sort(function (a, b) {
                  const depth_a = getDepth(a);
                  const depth_b = getDepth(b);

                  if (depth_a > depth_b) {
                    return 1;
                  }
                  if (depth_a < depth_b) {
                    return -1;
                  }
                  return 0;
                });

                arr_grandChild_sorted_by_decreasing_depth.forEach((grandChild, grandChildIndex) => {
                  const path = parentPath.concat([childIndex, grandChildIndex]);
                  const arr_sub = getArr_all_leaves__treeObj(grandChild, path);
                  console.log("arr_sub", arr_sub);
                  acc.push(...arr_sub);
                });

                return acc;

              }, []);
            }
          }
          break;
        default:
          const treeObj = {
            node: mathNode,
            path: parentPath/*.concat([0])*/,
          };
          outArray = [treeObj];
          break;
      }

      return outArray;
    }

    function getArr_all_nodes_at_depth(mathNode, depth) {
      var outArray;

      if (depth < 1) {
        throw new Error("depth must be > 1");
      } else if (depth == 1) {
        outArray = [mathNode];
      } else {
        const arr_child = mathNode.args;

        outArray = arr_child.reduce((acc, child) => {
          const arr_nodes__one_deeper = getArr_all_nodes_at_depth(child, depth - 1);

          acc.push(...arr_nodes__one_deeper);

          return acc;
        }, []);
      }

      return outArray;
    }

    function getArr_deep_first__treeObj(mathNode, parentPath = []) {
      var outArray;

      const depth = getDepth(mathNode);
      const arr_depth__increasing = [...new Array(depth).keys()].map(i => i + 1);
      const arr_depth__decreasing = arr_depth__increasing.slice().reverse();

      outArray = arr_depth__decreasing.reduce((acc, depth) => {

        const arr_all_treeObj_at_depth = getArr_all_treeObj_at_depth(mathNode, depth, parentPath);
        acc.push(...arr_all_treeObj_at_depth);

        return acc;
      }, []);

      return outArray;
    }

    function getArr_all_treeObj_at_depth(mathNode, depth, parentPath = []) {
      var outArray;

      if (depth < 1) {
        throw new Error("depth must be > 1");
      } else if (depth == 1) {
        const treeObj = {
          node: mathNode,
          path: parentPath,
        };
        outArray = [treeObj];
      } else {
        var arr_child = mathNode.args;

        if (arr_child == null) {
          arr_child = [];
        }

        outArray = arr_child.reduce((acc, child, childIndex) => {
          const child_path = parentPath.concat(childIndex);
          const arr_treeObj__one_deeper = getArr_all_treeObj_at_depth(child, depth - 1, child_path);

          acc.push(...arr_treeObj__one_deeper);

          return acc;
        }, []);

      }

      return outArray;
    }


    function getArr_deep_first__treeObj(mathNode, parentPath = []) {
      var outArray;

      const depth = getDepth(mathNode);
      const arr_depth__increasing = [...new Array(depth).keys()].map(i => i + 1);
      const arr_depth__decreasing = arr_depth__increasing.slice().reverse();

      outArray = arr_depth__decreasing.reduce((acc, depth) => {

        const arr_all_treeObj_at_depth = getArr_all_treeObj_at_depth(mathNode, depth);
        acc.push(...arr_all_treeObj_at_depth);

        return acc;
      }, []);

      return outArray;
    }





    function operatorNodeBySettingNodeAtPath(operatorNode_in, node_l, path) {
      var outOperatorNode;

      const operatorNode_cloned = operatorNode_in.clone();
      // const operatorNode_cloned = operatorNode_in.cloneDeep();

      //get target inner parentNode
      const path__all_but_last = path.slice(0, -1);
      const targetParentNode = path__all_but_last.reduce((acc, x) => {
        return acc.args[x];
      }, operatorNode_cloned);

      //mutate target inner parentNode
      const path__last = path[path.length - 1];
      targetParentNode.args[path__last] = node_l;

      outOperatorNode = operatorNode_cloned;

      return outOperatorNode;
    }

      // //debug
      // {
      //   const debugNode = random_mathNode_withDepth_and_nbSymbols(4, 2);
      //   console.log("debugNode(4,2)", debugNode);
      //   console.log("getDepth(debugNode)", getDepth(debugNode));
      //   console.log("getArr_all_leaves__node(debugNode)", getArr_all_leaves__node(debugNode));
      // }

  </script>
  <script>
    /*
    class InverseNode extends math.Node {   //ClassicInverseNode
      constructor(node_in) {

      }
    }
    math.InverseNode = InverseNode;                 //SHU: pas obligé mais pourquoi pas
    */

    class Inverser {
      static inverse(mathNode) {
        var outMathNode;

        switch (mathNode.type) {
          case "ConstantNode":
          case "SymbolNode":
            {
              const mathNode_ONE = new math.ConstantNode(1);
              const mathNode_clone = mathNode.cloneDeep();
              outMathNode = new math.OperatorNode("/", "divide", [mathNode_ONE, mathNode_clone]);
            }
            break;

          case "OperatorNode":
            {
              const operatorNode = mathNode;
              switch (operatorNode.fn) {
                case "divide":
                  {
                    const mathNode_firstArg = operatorNode.args[0];
                    if (mathNode_firstArg.type == "ConstantNode" && mathNode_firstArg.value == 1) {
                      //'simplification'
                      const mathNode_secondArg_clone = operatorNode.args[1].cloneDeep();
                      outMathNode = mathNode_secondArg_clone;
                    } else {
                      const mathNode_clone = mathNode.cloneDeep();
                      mathNode_clone.args = mathNode_clone.args.slice().reverse();
                      outMathNode = mathNode_clone;
                    }
                  }
                  break;
                default:
                  {
                    const mathNode_ONE = new math.ConstantNode(1);
                    const mathNode_clone = mathNode.cloneDeep();
                    outMathNode = new math.OperatorNode("/", "divide", [mathNode_ONE, mathNode_clone]);
                  }
                  break;
              }
            }
            break;
          case "ParenthesisNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;


          //maybe one day
          case "BlockNode":
          case "ObjectNode":
          case "ConditionalNode":
          case "FunctionNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;

          case "ArrayNode":
          case "AssignmentNode":
          case "FunctionAssignmentNode":
          case "RelationalNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;

          default:
            throw new Error("unsupported type: " + mathNode.type);
            break;
        }

        return outMathNode;
      }


      static opposite(mathNode) {
        var outMathNode;

        switch (mathNode.type) {
          case "ConstantNode":
          case "SymbolNode":
            {
              const mathNode_ZERO = new math.ConstantNode(0);
              const mathNode_clone = mathNode.cloneDeep();
              outMathNode = new math.OperatorNode("-", "subtract", [mathNode_ZERO, mathNode_clone]);
            }
            break;

          case "OperatorNode":
            {
              const operatorNode = mathNode;
              switch (operatorNode.fn) {
                case "subtract":
                  {
                    const mathNode_firstArg = operatorNode.args[0];
                    if (mathNode_firstArg.type == "ConstantNode" && mathNode_firstArg.value == 0) {
                      //'simplification'
                      const mathNode_secondArg_clone = operatorNode.args[1].cloneDeep();
                      outMathNode = mathNode_secondArg_clone;
                    } else {
                      const mathNode_clone = mathNode.cloneDeep();
                      mathNode_clone.args = mathNode_clone.args.slice().reverse();
                      outMathNode = mathNode_clone;
                    }
                  }
                  break;
                default:
                  {
                    const mathNode_ZERO = new math.ConstantNode(0);
                    const mathNode_clone = mathNode.cloneDeep();
                    outMathNode = new math.OperatorNode("-", "subtract", [mathNode_ZERO, mathNode_clone]);
                  }
                  break;
              }
            }
            break;
          case "ParenthesisNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;


          //maybe one day
          case "BlockNode":
          case "ObjectNode":
          case "ConditionalNode":
          case "FunctionNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;

          case "ArrayNode":
          case "AssignmentNode":
          case "FunctionAssignmentNode":
          case "RelationalNode":
            throw new Error("unsupported type: " + mathNode.type);
            break;

          default:
            throw new Error("unsupported type: " + mathNode.type);
            break;
        }

        return outMathNode;
      }

    }

    /*
    class GeneralInverseOperatorDuo extends math.OperatorNode {
      constructor(, )
    }
    math.GeneralInverseNode = GeneralInverseNode;


    class GeneralInverseNode extends math.OperatorNode {
      constructor(operatorDuo, node) {

      }
    }
    math.GeneralInverseNode = GeneralInverseNode;
    */


    class Simplifier {

      constructor() {

      }

      static simplify_top_layer(node_in) {
        var outNode;

        if (node_in.type == "OperatorNode") {

          const depth = getDepth(node_in);

          if (depth > 2) {
            console.log("___st A");

            //'outermost first' simplify

            const operator__layerN = node_in;
            const arr_child__layerN = operator__layerN.args;
            var terminal__layerN = arr_child__layerN.filter(child => Simplifier.isTerminalType(child)).find(e => true);
            terminal__layerN = Simplifier.getTerminalMathNode(terminal__layerN);

            const operator__layerN_minus_1 = arr_child__layerN.filter(child => (child.type == "OperatorNode")).find(e => true);
            const arr_child__layerN_minus_1 = operator__layerN_minus_1.args;
            // const terminal__layerN_minus_1      = arr_child__layerN_minus_1.filter(child => isTerminalType(child)).find(e => true);
            var arr_terminal__layerN_minus_1 = arr_child__layerN_minus_1.filter(child => Simplifier.isTerminalType(child));
            arr_terminal__layerN_minus_1 = arr_terminal__layerN_minus_1.map(mathNode => Simplifier.getTerminalMathNode(mathNode));

            const sameTerminal = arr_terminal__layerN_minus_1.find(term__layerN_minus_1 => Simplifier.isSameTerminal(terminal__layerN, term__layerN_minus_1));
            if (!sameTerminal) {
              return node_in;
            }

            const isInverseOperators_ = Simplifier.isInverseOperators(operator__layerN_minus_1, operator__layerN);
            console.log("isInverseOperators_", isInverseOperators_);
            if (!isInverseOperators_) {
              return node_in;
            }

            const node__layerN_minus_2 = arr_child__layerN_minus_1.filter(child => child != sameTerminal).find(e => true);

            //remove parentheses if any
            // if(node__layerN_minus_2.type == "ParenthesisNode") {
            //   const contentNode = node__layerN_minus_2.content;
            //   outNode = contentNode;
            // } else {
            //   outNode = node__layerN_minus_2;
            // }

            outNode = node__layerN_minus_2;

          } else {
            console.log("___st B");

            //simple simplify

            const node_unsimplified = node_in;

            const node_simplified = math.simplify(node_unsimplified);
            node_simplified.isSimplified = true;

            outNode = node_simplified;

          }

        } else {
          console.log("___st C");
          logger.log("node_in", node_in);

          //simple simplify

          const node_unsimplified = node_in;

          const node_simplified = math.simplify(node_unsimplified);   //SHU: boom
          node_simplified.isSimplified = true;

          outNode = node_simplified;

        }

        outNode.autoSimplify = node_in.autoSimplify;

        return outNode;
      }

      static isOne(mathNode) {
        return Simplifier.isOne_strict(mathNode) || Simplifier.isOne_wide(mathNode);
      }

      static isOne_strict(mathNode) {
        return (mathNode.type == "ConstantNode") && (mathNode.value == 1);
      }

      static isOne_wide(mathNode) {
        // return (mathNode.type == "ConstantNode") && (mathNode.value == 1);
        return false;
      }

      static isZero_strict(mathNode) {
        return (mathNode.type == "ConstantNode") && (mathNode.value == 0);
      }

      static simplify_singleOperatorize_topPriorityShell(mathNode) {
        var outMathNode;

        logger.log("simplify_singleOperatorize_topPriorityShell", mathNode);

        switch (mathNode.type) {
          case "OperatorNode":
            {
              const operatorNode = mathNode;

              // if(operatorFn == "multiply") {
              switch (operatorNode.fn) {
                case "multiply":
                  {
                    //1. transform children
                    const arr_child = operatorNode.args.map(mathNode_child => Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_child));

                    //2. merge (~aggregate, ~flatten)
                    const arr_child2 = arr_child.reduce((acc, x) => {

                      switch (x.type) {
                        case "OperatorNode":
                          {
                            switch (x.fn) {
                              case "multiply":
                                {
                                  acc.push(...x.args);
                                }
                                break;
                              default:
                                acc.push(x);
                                break;
                            }
                          }
                          break;
                        default:
                          acc.push(x);
                          break;
                      }

                      return acc;
                    }, []);

                    //3. filter out ONEs
                    const arr_child3 = arr_child2.filter(mathNode => {
                      const isOne = Simplifier.isOne(mathNode);
                      return !isOne;
                    });

                    if (arr_child3.length > 1) {
                      outMathNode = new math.OperatorNode("x", "multiply", arr_child3);
                    } else {
                      outMathNode = arr_child3.find(e => true);
                    }

                  }
                  break;
                case "divide":
                  {
                    // const mathNode_firstArg = operatorNode.args[0];
                    // if(mathNode_firstArg.type == "ConstantNode" && mathNode_firstArg.value == 1) {
                    //   //'simplification'
                    //   const mathNode_secondArg_clone = operatorNode.args[1].cloneDeep();
                    //   outMathNode = mathNode_secondArg_clone;
                    // } else {
                    //   const mathNode_clone = mathNode.cloneDeep();
                    //   mathNode_clone.args = mathNode_clone.args.slice().reverse();
                    //   outMathNode = mathNode_clone;
                    // }


                    //1. transform children
                    //transform numerator   (left side)
                    const mathNode_numerator = operatorNode.args[0];
                    const mathNode_numerator_transformed = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_numerator);
                    //transform denominator (right side)
                    const mathNode_denominator = operatorNode.args[1];
                    const mathNode_denominator_transformed = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_denominator);

                    //2.transform into multiplication
                    var arr_mathNode_denominator;
                    switch (mathNode_denominator_transformed.type) {
                      case "OperatorNode":
                        {
                          const operatorNode = mathNode_denominator_transformed;
                          switch (operatorNode.fn) {
                            case "multiply":
                              {
                                arr_mathNode_denominator = operatorNode.args;
                              }
                              break;
                            default:
                              {
                                arr_mathNode_denominator = [mathNode_denominator_transformed];
                              }
                              break;
                          }
                        }
                        break;
                      default:
                        {
                          arr_mathNode_denominator = [mathNode_denominator_transformed];
                        }
                        break;
                    }

                    const arr_factor = [mathNode_numerator_transformed, ...arr_mathNode_denominator.map(Inverser.inverse)];

                    outMathNode = new math.OperatorNode("x", "multiply", arr_factor);

                  }
                  break;

                case "add":
                  {
                    //1. transform children
                    const arr_child = operatorNode.args.map(mathNode_child => Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_child));

                    //2. merge (~aggregate, ~flatten)
                    const arr_child2 = arr_child.reduce((acc, x) => {

                      switch (x.type) {
                        case "OperatorNode":
                          {
                            switch (x.fn) {
                              case "add":
                                {
                                  acc.push(...x.args);
                                }
                                break;
                              default:
                                acc.push(x);
                                break;
                            }
                          }
                          break;
                        default:
                          acc.push(x);
                          break;
                      }

                      return acc;
                    }, []);

                    //3. filter out ZEROs
                    const arr_child3 = arr_child2.filter(mathNode => {
                      const isZero = Simplifier.isZero_strict(mathNode);
                      return !isZero;
                    });

                    if (arr_child3.length > 1) {
                      outMathNode = new math.OperatorNode("+", "add", arr_child3);
                    } else {
                      outMathNode = arr_child3.find(e => true);
                    }
                  }
                  break;

                case "subtract":
                  {
                    //1. transform children
                    //transform diminuend (left side)
                    const mathNode_diminuend = operatorNode.args[0];
                    const mathNode_diminuend_transformed = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_diminuend);
                    //transform diminutor (right side)
                    const mathNode_diminutor = operatorNode.args[1];
                    const mathNode_diminutor_transformed = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode_diminutor);

                    //2.transform into addition
                    var arr_mathNode_diminutor;
                    switch (mathNode_diminutor_transformed.type) {
                      case "OperatorNode":
                        {
                          const operatorNode = mathNode_diminutor_transformed;
                          switch (operatorNode.fn) {
                            case "add":
                              {
                                arr_mathNode_diminutor = operatorNode.args;
                              }
                              break;
                            default:
                              {
                                arr_mathNode_diminutor = [mathNode_diminutor_transformed];
                              }
                              break;
                          }
                        }
                        break;
                      default:
                        {
                          arr_mathNode_diminutor = [mathNode_diminutor_transformed];
                        }
                        break;
                    }

                    const arr_actor = [mathNode_diminuend_transformed, ...arr_mathNode_diminutor.map(Inverser.opposite)];

                    outMathNode = new math.OperatorNode("+", "add", arr_actor);
                  }
                  break;

                default:
                  outMathNode = mathNode;
                  break;
              }
              // } else {
              //   throw new Error("unsupported operatorFn: " + operatorFn);
              // }

            }
            break;
          case "ParenthesisNode":
            {
              const parenthesisNode = mathNode;
              //check content
              const mathNode__content = parenthesisNode.content;
              outMathNode = Simplifier.simplify_singleOperatorize_topPriorityShell(mathNode__content);
            }
            break;
          default:
            outMathNode = mathNode;
            break;
        }

        return outMathNode;
      }


      static isConstant(mathNode) {
        return (mathNode.type == "ConstantNode");
      }

      static isConstantOrInverse(mathNode) {
        return Simplifier.isConstant(mathNode) || Simplifier.isInverse(mathNode);
      }

      static isInverse(mathNode) {
        var outBool;

        const isDivide = (mathNode.type == "OperatorNode") && (mathNode.fn == "divide");
        if (isDivide) {
          const mathNode_numerator = mathNode.args[0];
          const isNumeratorOne = Simplifier.isOne_strict(mathNode_numerator);

          const mathNode_denominator = mathNode.args[1];
          const isDenominatorConstant = Simplifier.isConstant(mathNode_denominator);

          outBool = isNumeratorOne && isDenominatorConstant;
        } else {
          outBool = false;
        }

        return outBool;
      }

      static isConstantOrOpposite(mathNode) {
        return Simplifier.isConstant(mathNode) || Simplifier.isOpposite(mathNode);
      }

      static isOpposite(mathNode) {
        var outBool;

        const isSubtract = (mathNode.type == "OperatorNode") && (mathNode.fn == "subtract");
        if (isSubtract) {
          const mathNode_diminuend = mathNode.args[0];
          const isDiminuendZero = Simplifier.isZero_strict(mathNode_diminuend);

          const mathNode_diminutor = mathNode.args[1];
          const isDiminutorConstant = Simplifier.isConstant(mathNode_diminutor);

          outBool = isDiminuendZero && isDiminutorConstant;
        } else {
          outBool = false;
        }

        return outBool;
      }


      static simplify_top_priorityShell(node_in) {
        var outNode;

        logger.log("simplify_top_priorityShell", node_in);

        const mathNode = node_in;

        //1. singleOperatorize
        const node_singleOperatorized = Simplifier.simplify_singleOperatorize_topPriorityShell(node_in);
        logger.log("node_singleOperatorized", node_singleOperatorized);

        switch (node_singleOperatorized.type) {
          case "OperatorNode":
            {
              // const depth = getDepth(node_w);
              // if(depth > 2) {

              switch (node_singleOperatorized.fn) {
                case "multiply":
                  {

                    //2. look for inverse matches : count plus and minus
                    const arr_mathNode_factor_all = node_singleOperatorized.args;
                    logger.log("arr_mathNode_factor_all", arr_mathNode_factor_all);

                    if (arr_mathNode_factor_all == null) {     //SHU: the downfall
                      return mathNode;
                    }
                    if (arr_mathNode_factor_all.length < 2) {
                      return mathNode;
                    }

                    const obj_factors = arr_mathNode_factor_all.reduce((acc, mathNode_factor, index) => {

                      var value;
                      var multiplicity;

                      const isConstantOrInverse = Simplifier.isConstantOrInverse(mathNode_factor);
                      if (isConstantOrInverse) {

                        const isInverse = (mathNode_factor.type == "OperatorNode") && (mathNode_factor.fn == "divide");
                        if (isInverse) {
                          const mathNode_inverse = mathNode_factor;
                          const mathNode_denominator = mathNode_inverse.args[1];
                          const mathNode_averse = mathNode_denominator;
                          value = mathNode_averse.value;
                          multiplicity = -1;
                        } else {
                          const mathNode_averse = mathNode_factor;
                          value = mathNode_averse.value;
                          multiplicity = +1;
                        }

                        const valueStr = "" + value;

                        if (acc.portion_valued[valueStr] == null) {
                          acc.portion_valued[valueStr] = 0;
                        }

                        acc.portion_valued[valueStr] += multiplicity;

                      } else {
                        acc.portion_indexed[index] = mathNode_factor;
                      }

                      return acc;
                    }, {
                      portion_valued: {},
                      portion_indexed: {},
                    });
                    logger.log("obj_factors", obj_factors);   //SHU: acc[value] stringifies value

                    const arr_mathNode_factor_simplified = Object.entries(obj_factors.portion_valued)
                      .filter(([valueStr, multiplicity]) => multiplicity != 0)
                      .map(([valueStr, multiplicity]) => {
                        var outArr;

                        logger.log("valueStr, multiplicity", valueStr, multiplicity);

                        const value = Number(valueStr);

                        const multiplicity_abs = math.abs(multiplicity);

                        if (multiplicity > 0) {
                          outArr = [...Array(multiplicity_abs).keys()].map(index => {
                            const mathNode_averse = new math.ConstantNode(value);
                            return mathNode_averse;
                          });
                        } else {
                          outArr = [...Array(multiplicity_abs).keys()].map(index => {
                            const mathNode_averse = new math.ConstantNode(value);
                            const mathNode_inverse = Inverser.inverse(mathNode_averse);
                            return mathNode_inverse;
                          });
                        }

                        return outArr;
                      })
                      .flat();
                    logger.log("arr_mathNode_factor_simplified", arr_mathNode_factor_simplified);


                    const arr_mathNode_factor_simplified_merged = [...arr_mathNode_factor_simplified, ...Object.values(obj_factors.portion_indexed)];
                    logger.log("arr_mathNode_factor_simplified_merged", arr_mathNode_factor_simplified_merged);


                    const nb_factors = arr_mathNode_factor_simplified_merged.length;
                    if (nb_factors == 0) {
                      outNode = new math.ConstantNode(1);
                    } else if (nb_factors == 1) {
                      const mathNode_a = arr_mathNode_factor_simplified_merged.find(e => true);
                      outNode = mathNode_a;
                    } else {
                      outNode = new math.OperatorNode("x", "multiply", arr_mathNode_factor_simplified_merged);
                    }

                  }
                  break;

                case "add":
                  {

                    //2. look for inverse matches : count plus and minus
                    const arr_mathNode_actor_all = node_singleOperatorized.args;
                    logger.log("arr_mathNode_actor_all", arr_mathNode_actor_all);

                    if (arr_mathNode_actor_all == null) {
                      return mathNode;
                    }
                    if (arr_mathNode_actor_all.length < 2) {
                      return mathNode;
                    }

                    const obj_actors = arr_mathNode_actor_all.reduce((acc, mathNode_actor, index) => {

                      var value;
                      var multiplicity;

                      const isConstantOrOpposite = Simplifier.isConstantOrOpposite(mathNode_actor);
                      if (isConstantOrOpposite) {

                        const isOpposite = (mathNode_actor.type == "OperatorNode") && (mathNode_actor.fn == "subtract");
                        if (isOpposite) {
                          const mathNode_opposite = mathNode_actor;
                          const mathNode_diminutor = mathNode_opposite.args[1];
                          const mathNode_averse = mathNode_diminutor;
                          value = mathNode_averse.value;
                          multiplicity = -1;
                        } else {
                          const mathNode_averse = mathNode_actor;
                          value = mathNode_averse.value;
                          multiplicity = +1;
                        }

                        const valueStr = "" + value;

                        if (acc.portion_valued[valueStr] == null) {
                          acc.portion_valued[valueStr] = 0;
                        }

                        acc.portion_valued[valueStr] += multiplicity;

                      } else {
                        acc.portion_indexed[index] = mathNode_actor;
                      }

                      return acc;
                    }, {
                      portion_valued: {},
                      portion_indexed: {},
                    });
                    logger.log("obj_actors", obj_actors);   //SHU: acc[value] stringifies value

                    const arr_mathNode_actor_simplified = Object.entries(obj_actors.portion_valued)
                      .filter(([valueStr, multiplicity]) => multiplicity != 0)
                      .map(([valueStr, multiplicity]) => {
                        var outArr;

                        logger.log("valueStr, multiplicity", valueStr, multiplicity);

                        const value = Number(valueStr);

                        const multiplicity_abs = math.abs(multiplicity);

                        if (multiplicity > 0) {
                          outArr = [...Array(multiplicity_abs).keys()].map(index => {
                            const mathNode_averse = new math.ConstantNode(value);
                            return mathNode_averse;
                          });
                        } else {
                          outArr = [...Array(multiplicity_abs).keys()].map(index => {
                            const mathNode_averse = new math.ConstantNode(value);
                            const mathNode_opposite = Inverser.opposite(mathNode_averse);
                            return mathNode_opposite;
                          });
                        }

                        return outArr;
                      })
                      .flat();
                    logger.log("arr_mathNode_actor_simplified", arr_mathNode_actor_simplified);


                    const arr_mathNode_actor_simplified_merged = [...arr_mathNode_actor_simplified, ...Object.values(obj_actors.portion_indexed)];
                    logger.log("arr_mathNode_actor_simplified_merged", arr_mathNode_actor_simplified_merged);


                    const nb_actors = arr_mathNode_actor_simplified_merged.length;
                    if (nb_actors == 0) {
                      outNode = new math.ConstantNode(0);
                    } else if (nb_actors == 1) {
                      const mathNode_a = arr_mathNode_actor_simplified_merged.find(e => true);
                      outNode = mathNode_a;
                    } else {
                      outNode = new math.OperatorNode("+", "add", arr_mathNode_actor_simplified_merged);
                    }

                  }
                  break;

                default:
                  outNode = node_singleOperatorized;
                  break;

                // } else {
                //   // throw new Error("depth <= 2");
                //   outNode = node_singleOperatorized;
                // }
              }

            }
            break;
          case "ParenthesisNode":
            {
              const parenthesisNode = mathNode;
              const contentNode = parenthesisNode.content;
              outNode = Simplifier.simplify_top_priorityShell(contentNode);
            }
            break;
          default:
            outNode = mathNode;
            break;
        }

        outNode.autoSimplify = node_in.autoSimplify;

        return outNode;
      }

      static simplify_fraction_into_product(mathNode_fraction) {
        var outMathNode;

        outMathNode = Rewriter.decomposition_product_primes(mathNode_fraction);
        outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);

        return outMathNode;
      }

      static simplify_fraction(mathNode_fraction) {
        var outMathNode;

        // outMathNode = Rewriter.decomposition_product_primes(mathNode_fraction);
        // outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);
        // outMathNode = math.simplify(outMathNode);

        //SHU: ou plus simplement ---___---
        outMathNode = math.simplify(mathNode_fraction);

        return outMathNode;
      }

      static simplify_litexp(mathNode_litexp) {
        var outMathNode;

        outMathNode = mathNode_litexp;

        // outMathNode = Rewriter.decomposition_product_primes_and_symbols(outMathNode);
        // outMathNode = Simplifier.simplify_fraction(outMathNode);
        // outMathNode = Simplifier.simplify_singleOperatorize_topPriorityShell(outMathNode);

        var isSimplifiedFully = false;
        while (!isSimplifiedFully) {
          const mathNode__prev = outMathNode;
          outMathNode = Simplifier.simplify_top_priorityShell(outMathNode);
          const mathNode__new = outMathNode;
          const str__prev = mathNode__prev.toString();
          const str__new = mathNode__new.toString();
          isSimplifiedFully = (str__prev == str__new);
        }

        outMathNode = Rewriter.removeUnnecessaryOnesInLitexp(outMathNode);
        outMathNode = math.simplify(outMathNode);

        return outMathNode;
      }

      static simplify_equation(mathNode_equation) {
        var outMathNode;

        logger.log("math.simplify.rules", math.simplify.rules);
        logger.log("math.simplify.rules[0].toString()", math.simplify.rules[0].toString());
        logger.log("math.simplify.rules[16].toString()", math.simplify.rules[16].toString());

        function simplify_child(mathNode_child) {
          return Simplifier.simplify_litexp(mathNode_child);
        }

        outMathNode = mathNode_equation.clone();
        outMathNode.params = outMathNode.params.map((mathNode_child, i) => {
          return simplify_child(mathNode_child);
        });

        return outMathNode;
      }


      static simplify_full(mathNode) { //SHU: TODO
        var outMathNode;

        //1. transform was is likely to be a binary tree into a nary tree with [+] and [x] as nary operators and [opposite] and [inverse] as unary operators (([0 -] and [1 /]))

        //2. simplify (== look for opposite matches) from bottom to top, as much as needed

        throw new Error("Not implemented yet");
        return outMathNode;
      }

      static isTerminalType(mathNode) {
        var outBool;

        const type = mathNode.type;

        switch (type) {
          case "ConstantNode":
          case "SymbolNode":
            outBool = true;
            break;
          case "ParenthesisNode":
            {
              //check content
              const mathNode__content = mathNode.content;
              outBool = isTerminalType(mathNode__content);
            }
            break;
          default:
            outBool = false;
            break;
        }

        return outBool;
      }

      static getTerminalMathNode(mathNode) {
        var outMathNode;

        const type = mathNode.type;

        switch (type) {
          case "ConstantNode":
          case "SymbolNode":
            outMathNode = mathNode;
            break;
          case "ParenthesisNode":
            {
              //check content
              const mathNode__content = mathNode.content;
              outMathNode = getTerminalMathNode(mathNode__content);
            }
            break;
          default:
            // outMathNode = null;
            throw new Error("no terminal node to fetch");
            break;
        }

        return outMathNode;
      }

      static isSameTerminal(termNode1, termNode2) {
        var outBool;

        function isSameTerminalType(termNode1, termNode2) {
          return (termNode1.type == termNode2.type);
        }

        const isSameTerminalType_ = isSameTerminalType(termNode1, termNode2);
        console.log("isSameTerminalType_", isSameTerminalType_);

        if (!isSameTerminalType_) {
          return false;                 //j'aime pas trop ça mais bon...
        }

        function isSameTerminalContent(termNode1, termNode2) {
          console.log("isSameTerminal", termNode1, termNode2);
          var outBool;

          switch (termNode1.type) {
            case "SymbolNode":
              outBool = (termNode1.name == termNode2.name);
              break;
            case "ConstantNode":
              outBool = (termNode1.value == termNode2.value);
              break;
            default:
              throw new Error("unsupported type", termNode1.type);
              break;
          }

          return outBool;
        }

        outBool = isSameTerminalContent(termNode1, termNode2);

        return outBool;
      }

      static isInverseOperators(opNode1, opNode2) {
        console.log("isInverseOperators", opNode1, opNode2);
        var outBool;

        const set_opFunc = new Set([opNode1.fn, opNode2.fn]);
        console.log("set_opFunc", set_opFunc);

        /*Set utils*/
        function eqSet(as, bs) {
          return as.size === bs.size && all(isIn(bs), as);
        }

        function all(pred, as) {
          for (var a of as) if (!pred(a)) return false;
          return true;
        }

        function isIn(as) {
          return function (a) {
            return as.has(a);
          };
        }
        /**/



        const arr_set_inverse = [
          new Set(["multiply", "divide"]),
          new Set(["add", "subtract"]),
        ];

        outBool = arr_set_inverse.reduce((acc, x) => {
          if (eqSet(set_opFunc, x)) {
            acc = true;
          }
          return acc;
        }, false);

        return outBool;
      }


      static simplify_level1(mathNode) {
        var outMathNode;

        //0. check if candidate (== legitimate operand)
        switch (mathNode) {
          case "OperatorNode":
            break;
          case "ParenthesisNode":
            const mathNode__content = mathNode.content;
            const mathNode__result = Simplifier.simplify_level1(mathNode__content);
            const mathNode__paren = mathNode.clone();
            mathNode__paren.content = mathNode__result;
            return mathNode__paren;
          default:
            //ignore
            return mathNode;        //SHU: un return dans un switch ! hahaha
        }

        const operatorNode = mathNode;

        //1. get level1 node(s) with lower depth
        const dict_arrForDepth = operatorNode.args.reduce((acc, mathNode_child) => {
          const depth = getDepth(mathNode_child);
          if (acc[depth] == null) {
            acc[depth] = [];
          }
          acc[depth].push(mathNode_child);
          return acc;
        }, {});

        //temporarily: work only with depth 1
        const arr_depth1 = dict_arrForDepth[1];
        if (arr_depth1 == null) {
          return mathNode;
        }

        //2. try to find inverse wrt mathNode fn
        const mathNode_slasher = null;
        const mathNode_victim = null;

        return outMathNode;
      }

      static simplify_level1_recursively(mathNode) {
        var outMathNode;



        return outMathNode;
      }

    }





  </script>
  <script>
    class Rewriter {

      constructor() {

      }

      static decomposition_product_primes(mathNode) {
        var outNode;

        switch (mathNode.type) {
          case "ConstantNode":
            const value = mathNode.value;
            const arr_values = MathUtils.primeFactorization(value);

            // const joinreduce = function(joinFunc, )
            const value_first = arr_values[0];
            const arr_butfirst = arr_values.slice(1);
            const mathNode_initial = new math.ConstantNode(value_first);
            outNode = arr_butfirst.reduce((acc, x) => {
              const mathNode_arg2 = new math.ConstantNode(x);
              return new math.OperatorNode("×lol×", "multiply", [acc, mathNode_arg2]);
            }, mathNode_initial);

            break;
          case "OperatorNode":
            const operatorNode = mathNode;
            logger.log("operatorNode", operatorNode);
            // switch(operatorNode.op) {
            //   case "/":
            //   break;
            // }
            outNode = new math.OperatorNode(operatorNode.op, operatorNode.fn, operatorNode.args.map(Rewriter.decomposition_product_primes));
            break;
          default:
            throw new Error("unsupported type: " + mathNode.type);
            break;
        }

        return outNode;
      }


      static decomposition_product_primes_and_symbols(mathNode) {
        var outNode;

        switch (mathNode.type) {
          case "ConstantNode":
            const value = mathNode.value;
            const arr_values = MathUtils.primeFactorization(value);

            // const joinreduce = function(joinFunc, )
            const value_first = arr_values[0];
            const arr_butfirst = arr_values.slice(1);
            const mathNode_initial = new math.ConstantNode(value_first);
            outNode = arr_butfirst.reduce((acc, x) => {
              const mathNode_arg2 = new math.ConstantNode(x);
              return new math.OperatorNode("×lol×", "multiply", [acc, mathNode_arg2]);
            }, mathNode_initial);

            break;
          case "OperatorNode":
            const operatorNode = mathNode;
            logger.log("operatorNode", operatorNode);
            // switch(operatorNode.op) {
            //   case "/":
            //   break;
            // }
            outNode = new math.OperatorNode(operatorNode.op, operatorNode.fn, operatorNode.args.map(Rewriter.decomposition_product_primes_and_symbols));

            break;
          case "SymbolNode":
            outNode = mathNode;
            break;

          default:
            throw new Error("unsupported type: " + mathNode.type);
            break;
        }

        return outNode;
      }

      static removeUnnecessaryOnesInLitexp(mathNode_litexp) {
        var outMathNode;

        const rules = [
          "1 * n1 -> n1",
          "n1 * 1 -> n1",
        ];

        outMathNode = math.simplify(mathNode_litexp, rules);

        return outMathNode;
      }

    }
  </script>



  <script>
    class Splitter {

      constructor() {

      }

      static split_top_layer(mathNode) {
        var outArr;

        switch (mathNode.type) {
          case "OperatorNode":
            {
              const arr_args = mathNode.args;

              // const operatorNode__nude = mathNode.clone();
              // operatorNode__nude.args = [];
              //
              // outArr = [...arr_args, operatorNode__nude];

              const symbolNode__operator = new math.SymbolNode(mathNode.op);
              outArr = [symbolNode__operator, ...arr_args];
            }
            break;
          case "ParenthesisNode":
            {
              const symbolNode__operator = new math.SymbolNode("()");
              outArr = [symbolNode__operator, mathNode.content];

              // const symbolNode__operatorOpen  = new math.SymbolNode("(");
              // const symbolNode__operatorClose = new math.SymbolNode(")");
              // outArr = [symbolNode__operatorOpen, mathNode.content, symbolNode__operatorClose];
            }
            break;
          default:
            outArr = [mathNode];
            break;
        }

        return outArr;
      }

      static split_full(mathNode) {
        var outArr;

        const arr_components = Splitter.split_top_layer(mathNode);
        if (arr_components.length > 1) {
          outArr = arr_components.reduce((acc, x) => {
            const arr_mathNode = Splitter.split_full(x);
            acc.push(...arr_mathNode);
            return acc;
          }, []);
        } else {
          outArr = arr_components;
        }

        return outArr;
      }

      static geometry__fireworks(center, nb_sparks) {
        var outGeometryObj;


        return outGeometryObj;
      }



      static split_string(str_in) {
        var outArr;

        outArr = str_in.split("");

        return outArr;
      }

    }

  </script>
  <script>
    class Joiner {
      constructor() {

      }

      /**
      *   create a mathNode using all mathNodes in arr_mathNode
      */
      static random_join(arr_mathNode) {
        var outMathNode;

        const nb_max_try = 1000;

        var found = false;
        var nb_try = 0;
        //ugly brute            //SHU: sometimes, one can be proud of one's hideousness
        while (!found && nb_try < nb_max_try) {
          try {
            const join_workz = Joiner.random_join_workz(arr_mathNode, true);
            outMathNode = join_workz.output;
            found = true;
          }
          catch (e) {
            logger.log(e);
            found = false;
          }
          nb_try += 1;
        }

        if (!found) {
          outMathNode = new math.SymbolNode("error");
        }

        // logger.log("outMathNode", outMathNode);

        return outMathNode;
      }

      // static random_join_workz(arr_mathNode, isExhaustive = false) {
      //   logger.log("random_join_workz", arr_mathNode);
      //   var outWorkz;
      //
      //   outWorkz = {
      //     output:   null,
      //     arr_rest: [],
      //   };
      //
      //   var isTerminal;
      //   if(isExhaustive) {
      //     const isOneNodeArray = (arr_mathNode.length == 1);
      //     isTerminal = isOneNodeArray;
      //   } else {
      //     //randomly terminal
      //     const random_boolean = Math.random() < 0.5;
      //     isTerminal = random_boolean;
      //   }
      //
      //
      //   if(isTerminal) {
      //     //get a terminal node
      //     const arr_terminalNode     = arr_mathNode.filter(mathNode => {
      //       const isConstantNode       = (mathNode.type == "ConstantNode");
      //       const isTerminalSymbolNode = (mathNode.type == "SymbolNode") && (Joiner.filter_operatorSymbols([mathNode]).length == 0);
      //       return isConstantNode || isTerminalSymbolNode;
      //     });
      //     Utils.shuffle(arr_terminalNode);
      //
      //     const terminalNode = arr_terminalNode.find(e => true);
      //
      //     outWorkz.output   = terminalNode;
      //     outWorkz.arr_rest = arr_mathNode.filter(mathNode => mathNode != terminalNode);
      //
      //   } else {
      //     //1. get an operator
      //     const arr_symbolNode       = Joiner.filter_operatorSymbols(arr_mathNode);
      //     Utils.shuffle(arr_symbolNode);
      //
      //     const symbolNode__operator = arr_symbolNode.find(e => true);
      //     logger.log("symbolNode__operator", symbolNode__operator);
      //
      //     const arr_mathNode_rest    = arr_mathNode.filter(mathNode => mathNode != symbolNode__operator);
      //
      //     //2. get operands
      //     const nb_operands = 2;
      //     const obj_operands = [...new Array(nb_operands).keys()].reduce((acc, x, index) => {
      //       const arr_component__before = acc.arr_component;
      //
      //       const isExhaustive = (index == (nb_operands - 1));
      //       const join_workz = Joiner.random_join_workz(arr_component__before, isExhaustive);
      //
      //       acc.arr_component = join_workz.arr_rest;
      //       const mathNode__operand = join_workz.output;
      //       acc.arr_out.push(mathNode__operand);
      //
      //       return acc;
      //     }, {
      //       arr_component: arr_mathNode_rest,
      //       arr_out: [],
      //     });
      //
      //     const operatorNode = Joiner.operatorNodeForOperatorSymbolNode(symbolNode__operator);
      //     operatorNode.args = obj_operands.arr_out;
      //     logger.log("operatorNode")
      //
      //     outWorkz.output   = operatorNode;
      //     outWorkz.arr_rest = obj_operands.arr_component;
      //   }
      //
      //   return outWorkz;
      // }

      static random_join_workz(arr_mathNode, isExhaustive = false) {
        logger.log("random_join_workz", arr_mathNode);
        var outWorkz;

        outWorkz = {
          output: null,
          arr_rest: [],
        };

        var isTerminal;
        if (isExhaustive) {
          const isOneNodeArray = (arr_mathNode.length == 1);
          isTerminal = isOneNodeArray;
        } else {
          //randomly terminal
          const random_boolean = Math.random() < 0.5;
          isTerminal = random_boolean;
        }


        if (isTerminal) {
          //get a terminal node
          const arr_terminalNode = arr_mathNode.filter(mathNode => {
            const isConstantNode = (mathNode.type == "ConstantNode");
            const isTerminalSymbolNode = (mathNode.type == "SymbolNode") && (Joiner.filter_operatorSymbols([mathNode]).length == 0);
            return isConstantNode || isTerminalSymbolNode;
          });
          Utils.shuffle(arr_terminalNode);

          const terminalNode = arr_terminalNode.find(e => true);

          outWorkz.output = terminalNode;
          outWorkz.arr_rest = arr_mathNode.filter(mathNode => mathNode != terminalNode);

        } else {
          //1. get an operator
          const arr_symbolNode = Joiner.filter_operatorSymbols(arr_mathNode);
          Utils.shuffle(arr_symbolNode);

          const symbolNode__operator = arr_symbolNode.find(e => true);
          logger.log("symbolNode__operator", symbolNode__operator);

          const arr_mathNode_rest = arr_mathNode.filter(mathNode => mathNode != symbolNode__operator);

          const specializedNode = Joiner.specializedNodeForSymbolNode(symbolNode__operator);

          //2. get operands
          const nb_operands = Joiner.arityForSymbolNode(symbolNode__operator);
          const obj_operands = [...new Array(nb_operands).keys()].reduce((acc, x, index) => {
            const arr_component__before = acc.arr_component;

            const isExhaustive = (index == (nb_operands - 1));
            const join_workz = Joiner.random_join_workz(arr_component__before, isExhaustive);

            acc.arr_component = join_workz.arr_rest;
            const mathNode__operand = join_workz.output;
            acc.arr_out.push(mathNode__operand);

            return acc;
          }, {
            arr_component: arr_mathNode_rest,
            arr_out: [],
          });

          const arr_operands = obj_operands.arr_out;

          switch (specializedNode.type) {
            case "ParenthesisNode":
              const parenthesisNode = specializedNode;
              const contentNode = arr_operands.find(e => true);
              parenthesisNode.content = contentNode;
              break;
            case "OperatorNode":
              const operatorNode = specializedNode;
              operatorNode.args = arr_operands;
              break;
            default:
              throw new Error("unsupported specializedNode type : " + specializedNode.type);
              break;
          }

          logger.log("operatorNode")

          outWorkz.output = specializedNode;
          outWorkz.arr_rest = obj_operands.arr_component;
        }

        return outWorkz;
      }


      static filter_operatorSymbols(arr_mathNode) {
        var outArr;

        function isOperatorSymbolNode(symbolNode) {
          var outBool;

          switch (symbolNode.name) {
            case "+":
            case "-":
            case "×":
            case "/":
              outBool = true;
              break;

            case "()":
              outBool = true;
              break;

            default:
              outBool = false;
              break;
          }

          return outBool;
        }

        outArr = arr_mathNode
          .filter(mathNode => (mathNode.type == "SymbolNode"))
          .filter(isOperatorSymbolNode);

        return outArr;
      }

      static operatorNodeForOperatorSymbolNode(symbolNode) {
        var outOperatorNode;

        const op = symbolNode.name;

        var funcName;
        switch (op) {
          case "+":
            funcName = "add";
            break;
          case "-":
            funcName = "subtract";
            break;
          case "×":
            funcName = "multiply";
            break;
          case "/":
            funcName = "divide";
            break;
          default:
            throw new Error("unsupported op symbol : " + op);
            break;
        }

        outOperatorNode = new math.OperatorNode(op, funcName, []);

        return outOperatorNode;
      }

      static specializedNodeForSymbolNode(symbolNode) {
        var outSpecializedNode;

        const op = symbolNode.name;

        var funcName;
        switch (op) {
          case "+":
            funcName = "add";
            outSpecializedNode = new math.OperatorNode(op, funcName, []);
            break;
          case "-":
            funcName = "subtract";
            outSpecializedNode = new math.OperatorNode(op, funcName, []);
            break;
          case "×":
            funcName = "multiply";
            outSpecializedNode = new math.OperatorNode(op, funcName, []);
            break;
          case "/":
            funcName = "divide";
            outSpecializedNode = new math.OperatorNode(op, funcName, []);
            break;

          case "()":
            const mathNode__placeholder = new math.SymbolNode("placeholder");
            outSpecializedNode = new math.ParenthesisNode(mathNode__placeholder);   //SHU: ni propre, ni sale. Juste un peu dérangeant.
            break;

          default:
            throw new Error("unsupported op symbol : " + op);
            break;
        }

        return outSpecializedNode;
      }

      static arityForSymbolNode(symbolNode) {
        var outInt;

        const op = symbolNode.name;

        var funcName;
        switch (op) {
          case "+":
          case "-":
          case "×":
          case "/":
            outInt = 2;
            break;
          case "()":
            outInt = 1;
            break;
          default:
            throw new Error("unsupported op symbol : " + op);
            break;
        }

        return outInt;
      }

    }
  </script>
  <script>
    class MathUtils {

      static primeFactorization(number, result) {
        var result = (result || []);
        var root = Math.sqrt(number);
        var x = 2;

        if (number % x) {
          x = 3;

          while ((number % x) && ((x = (x + 2)) < root)) { }
        }

        x = (x <= root) ? x : number;

        result.push(x);

        return (x === number) ? result : MathUtils.primeFactorization((number / x), result);
      }

      static arr_prime(length) {
        var outArr = [];

        // return [...Array(length).keys()].map(index => )

        var nb_remaining = length;
        var running = 2;
        while (nb_remaining > 0) {
          if (math.isPrime(running)) {
            outArr.push(running);
            nb_remaining -= 1;
          }
          running += 1;
        }

        return outArr;
      }

      static arr_prime_in_range(range) {
        const span = range.max - range.min;
        return [...Array(span).keys()].map(index => index + range.min).filter(math.isPrime);
      }

      static randomPrimeInRange(range) {
        return;
      }

      static isFraction(mathNode) {
        var outBool;

        if (mathNode.type == "OperatorNode" && mathNode.fn == "divide") {

          const operatorNode = mathNode;

          const mathNode__numerator = operatorNode.args[0];
          const isTerminalNode__numerator = Simplifier.isTerminalType(mathNode__numerator);

          const mathNode__denominator = operatorNode.args[1];
          const isTerminalNode__denominator = Simplifier.isTerminalType(mathNode__denominator);

          outBool = isTerminalNode__numerator && isTerminalNode__denominator;

        } else {
          outBool = false;
        }

        return outBool;
      }

      static randomCartDictFromArr(arr_elts, nb, min_nb_families_in = 1, max_nb_families_in = -1) {
        var outDict;

        var min_nb_families = min_nb_families_in;
        if (min_nb_families <= 0) { min_nb_families = 1 };

        var max_nb_families = max_nb_families_in;
        if (max_nb_families == -1) {
          max_nb_families = arr_elts.length
        } else if (max_nb_families > arr_elts.length) {
          max_nb_families = arr_elts.length
        };

        const nb_families = math.randomInt(min_nb_families, max_nb_families + 1);
        const arr_families = Utils.randomSubArrWithArray(arr_elts, nb_families);
        // logger.log("arr_families", arr_families);

        outDict = [...Array(nb).keys()].reduce((acc, index) => {
          var currDict = acc;

          const index_random = Utils.randomElementInArray([...arr_families.keys()]);
          const elt = arr_families[index_random];
          // logger.log("elt", elt);

          var id;
          // if(elt.id != null) {
          //   id = elt.id;
          // } else {
          id = "obj_" + index_random;
          // }
          if (currDict[id] == null) {
            const miniDict = {
              obj: elt,
              nb: 0,
            };
            currDict[id] = miniDict;
          }

          currDict[id].nb += 1;

          return currDict;
        }, {});

        return outDict;
      }

      static randomCartArrFromArr(arr_elts, nb, min_families = -1, max_families = -1, isShuffled = false) {
        var outArr;

        const dict_cart = MathUtils.randomCartDictFromArr(arr_elts, nb, min_families, max_families);
        outArr = MathUtils.arrFromOccurenceDict(dict_cart);

        if (isShuffled) {
          const arr_cart__shuffled = Utils.shuffle([...outArr]);
          outArr = arr_cart__shuffled;
        }

        return outArr;
      }

      static arrFromOccurenceDict(dict_occurence) {
        var outArr;

        outArr = Object.entries(dict_occurence).reduce((acc, entry) => {
          const id = entry[0];

          const obj = entry[1].obj;
          const nb = entry[1].nb;

          return [...acc, ...([...Array(nb)].map(e => obj))];
        }, []);

        return outArr;
      }

      static arrOfPairs(arr) {
        var outArr;

        outArr = arr.reduce((acc, x, index) => {
          var outArr;
          const arr_index__tail = [...Array(arr.length).keys()].slice(index + 1);
          const arr_pairs = arr_index__tail.map(index_tail => [arr[index], arr[index_tail]]);
          outArr = [...acc, ...arr_pairs];
          return outArr;
        }, []);

        return outArr;
      }

      static arrOfPairs__indexes(arr) {
        var outArr;

        outArr = arr.reduce((acc, x, index) => {
          const arr_index__tail = [...Array(arr.length).keys()].slice(index + 1);
          const arr_pairs = arr_index__tail.map(index_tail => [index, index_tail]);
          return [...acc, ...arr_pairs];
        }, []);

        return outArr;
      }

    }
  </script>
  <!-- <script>
      //debug
      const arr_src   = [...Array(20).keys()];

      const dict_cart = MathUtils.randomCartDictFromArr(arr_src, 10, 3, 6);
      logger.log("log1", "dict_cart", dict_cart);
      const arr_cart  = MathUtils.randomCartArrFromArr(arr_src, 10, 3, 6);
      logger.log("log1", "arr_cart", arr_cart);

    </script> -->


  <!-- icObj transformation stuff -->
  <script>
    class Combiner {
      constructor() {

      }

      static combine(arr_icObj) {
        var outIcObj;


        return outIcObj;
      }

    }
  </script>
  <script>
    class TransformationOutput {

      constructor(type, value, from) {
        this.type = type;
        this.value = value;
        this.from = from;
      }

    }
  </script>
  <script>

    class RichMathNode {

      constructor(mathNode) {
        this.mathNode = mathNode;
        this.rich = {};
      }

      configure(config) {
        this.rich.colorMode = config.colorMode;
        this.rich.color = config.color;
      }

      toTex() {
        var outString;

        const colorMode = this.rich.colorMode;

        switch (colorMode) {
          case "xylophone":
            {
              if (this.mathNode.type == "ConstantNode") {
                const positionalNumber = new PositionalNumber(this.mathNode.value);
                outString = positionalNumber.toTex("xylophone");
              } else {
                throw new Error("colorMode:xylophone only compatible with ConstantNode");
              }
            }
            break;
          case "fullplain":
            {
              const color = this.rich.color;
              if (this.mathNode.type == "ConstantNode") {
                const positionalNumber = new PositionalNumber(this.mathNode.value);
                outString = positionalNumber.toTex(color);
              } else {
                throw new Error("colorMode:xylophone only compatible with ConstantNode");
              }
            }
            break;
          case "evenodd":
            {
              const color__even = "#FFFFFF";
              const color__odd = "#000000";

              var color;
              if (this.rich.isEven) {
                color = color__even;
              } else {
                color = color__odd;
              }

              const tex__mathNode = this.mathNode.toTex();
              outString = TexEnricher.color(tex__mathNode, color);
            }
            break;
          case "plain":
            {
              const tex__mathNode = this.mathNode.toTex();

              //color
              if (this.rich.color != null) {
                const color = this.rich.color;
                outString = TexEnricher.color(tex__mathNode, color);
              } else {
                throw new Error("no color specified for colorMode: " + colorMode);
              }

            }
            break;
          default:
            {
              const tex__mathNode = this.mathNode.toTex();
              outString = tex__mathNode;
            }
            // throw new Error("unknown colorMode: " + colorMode);
            break;
        }

        return outString;
      }

      clone() {
        return;
      }

    }

    class TexEnricher {

      static color(tex_in, color_in) {
        var outString;

        outString = "{\\color{" + color_in + "} " + tex_in + " }";

        return outString;
      }

      // static font(tex_in, font_in) {
      //   var outString;
      //
      //   outString = "{\\fontfamily{pag}\\selectfont " + tex_in  + "}";
      //
      //   return outString;
      // }

    }

    // class UnfoldedNumber {
    class PositionalNumber {

      constructor(number, base = 10) {
        this.arr_digit = ("" + number).split("").map(digitStr => parseInt(digitStr));
        this.base = base;
      }

      toTex(color) {
        var outString;

        outString = this.arr_digit.reduce((acc, x) => {
          acc += PositionalNumber.texForDigit(x, color);
          return acc;
        }, "");

        return outString;
      }

      static texForDigit(digit, color_in) {

        var outString;

        outString = "" + digit;

        var color = color_in;
        if (color == "xylophone") {


          if (digit == 0) {
            // outString = "{\\fbox {}}";
            // outString = "{\\fbox {?}}";
            // outString = "\\enspace";

            // outString = "{\\mbox {0}}";

            // outString = "▢";
            // outString = "▫";
            // outString = "☐";
            // outString = "𖡄";
            outString = "?";


            ///not working
            // outString = "{\\fbox {\\hspace{1cm}} }";

          } else {
            color = PositionalNumber.colorForDigit(digit);
          }

          outString = TexEnricher.color(outString, color);

        } else {
          outString = TexEnricher.color(outString, color);
        }

        return outString;
      }

      static colorForDigit(digit) {
        var outColor = null;

        switch (digit) {
          case 0:
            outColor = "#000000";
            break;

          case 1:
            outColor = "#FF7F0E";
            break;
          case 2:
            outColor = "#2CA02C";
            break;
          case 3:
            outColor = "#D62728";
            break;
          case 4:
            outColor = "#9467BD";
            break;
          case 5:
            outColor = "#8C564B";
            break;
          case 6:
            outColor = "#E377C2";
            break;
          case 7:
            outColor = "#7F7F7F";
            break;
          case 8:
            outColor = "#BCBD22";
            break;
          case 9:
            outColor = "#17BECF";
            break;

          //SHU TODO: colors or patterns for those:
          case 10:  //A
            outColor = "#000000";
            break;
          case 11:  //B
            outColor = "#000000";
            break;
          case 12:  //C
            outColor = "#000000";
            break;
          case 13:  //D
            outColor = "#000000";
            break;
          case 14:  //E
            outColor = "#000000";
            break;
          case 15:  //F
            outColor = "#000000";
            break;

          default:
            throw new Error("unsupported digit: " + digit);
        }

        return outColor;
      }



    }

  </script>






  <!-- UX -->
  <script type="text/javascript" src="lib/rxjs.umd.min.js"></script> <!-- for easy inner/outer copy|paste -->
  <script>
    const Rx = rxjs;
    const Rx_operators = rxjs.operators;

    const Subject = Rx.Subject;
    const ReplaySubject = Rx.ReplaySubject;
  </script>
  <!-- <script>
      //discovery
      const rx_debug__subject    = new Subject();
      const rx_debug__observable = rx_debug__subject.asObservable();
      const rx_debug__sub        = rx_debug__observable.subscribe({
        next: (value) => {
          console.log("value", value);
        },
      });
      rx_debug__subject.next(10);
      rx_debug__subject.next(100);
      rx_debug__subject.next(1000);
    </script> -->
  <script>//for easy html element observation

    function mutationCallback__debug(mutationsList, observer) {
      console.log(mutationsList);
      console.log(observer);
      for (const mutation of mutationsList) {
        if (mutation.type === 'childList') {
          console.log('A child node has been added or removed.');
        } else if (mutation.type === 'attributes') {
          console.log('The ' + mutation.attributeName + ' attribute was modified.');
        } else {
          console.log('mutation.type: ' + mutation.type);
          console.log('New value ' + JSON.stringify(mutation.target.data));
        }
      }
    }

    function createHtmlEltObserver(htmlElt) {

      // Observation medium
      const rx_subject__mutation = new Subject();

      function mutationCallback(mutationsList, observer) {
        console.log(mutationsList);
        console.log(observer);

        const mutation = mutationsList.find(e => true);

        switch (mutation.type) {
          case "childList":
            rx_subject__mutation.next(htmlElt);
            break;
          case "attributes":
            // /!\ .attr() != .prop()
            break;
          default:
            console.log('mutation.type: ' + mutation.type);
            console.log('New value ' + JSON.stringify(mutation.target.data));
            break;
        }

        // rx_subject__mutation.next(htmlElt);
      }

      // Create an observer instance linked to the callback function
      const observer = new MutationObserver(mutationCallback);
      observer.rx_observable__mutation = rx_subject__mutation.asObservable();

      // What to observe
      const mutationConfig = { attributes: true, childList: true, subtree: true, characterData: true };

      // Start observation
      observer.observe(htmlElt, mutationConfig);

      return observer;
    }

  </script>
  <!-- <script>
      //discovery

      document.addEventListener("DOMContentLoaded", function () {
        const htmlElt = document.getElementById("debug_nbObjects");
        const observer = createObserver(htmlElt);

        setTimeout(() => {
          htmlElt.innerHTML = 123456;
        }, 5000);

      });

    </script> -->



  <!-- information -->
  <!-- <script type="text/javascript" src="lib/serialize-javascript.browserified.main.js"></script> -->
  <!-- <script type="text/javascript" src="lib/serialize-javascript.browserified.bundle.js"></script>
    <script>
      // console.log("Bundle_SJ", Bundle_SJ);
      const serialize   = Bundle_SJ.serialize;
      const deserialize = Bundle_SJ.deserialize;
    </script> -->
  <!-- <script>
      //discovery
      const sj__obj = {
        myFunc: (x) => x + 1,
      };
      const sj__serialized = serialize(sj__obj);
      console.log("serialize-javascript::sj__serialized", sj__serialized);
      const sj__deserialized = deserialize(sj__serialized);
      console.log("serialize-javascript::sj__deserialized", sj__deserialized);
      const sj__myFunc_result = sj__deserialized.myFunc(0);
      console.log("serialize-javascript::sj__myFunc_result", sj__myFunc_result);
    </script> -->

  <!-- <script type="text/javascript" src="lib/eventstore/eventstore.browserified.bundle.js"></script>
    <script>
      logger.log("Bundle_ES", Bundle_ES);
      const eventstore = Bundle_ES.eventstore;

      const es_options = {
        emitStoreEvents: false,
      };
      const es         = eventstore(es_options);
      logger.log("es", es);

      es.init(function (err) {
        // this callback is called when all is ready...
        logger.log("es.init", "done", es);
      });
    </script>
    <script>
      //discovery
      setTimeout(() => {

        es.defineEventMappings({
          id:             'id',
          commitId:       'commitId',
          commitSequence: 'commitSequence',
          commitStamp:    'commitStamp',
          streamRevision: 'streamRevision'
        });

        // es.commit({lol : "lol"});
        const event__0 = {
          id: 0,
        };
        const eventStream = [event__0];

        // const eventStream = new EventStream();
        // eventStream.addEvent(event__0);

        // es.addEventStream(eventStream);

        es.store.addEvents([event__0], (err) => {
          if(err != null) {
            logger.log("err", err);
          }
        });

      }, 1000);

    </script>
    <script type="text/javascript" src="lib/eventstore/eventstore-client.browserified.bundle.js"></script>
    <script>
      logger.log("Bundle_ESC", Bundle_ESC);
      const eventstoreClient = Bundle_ESC.eventstoreClient;

      const esc_options = {

      };
      const esc         = eventstoreClient(esc_options);
      logger.log("esc", esc);


    </script> -->


  <!-- <script type="text/javascript" src="lib/js-event-sourcing-example/bundle.js"></script>
    <script>

    </script>
    <script>
      //discovery


    </script> -->

  <!-- <script type="text/javascript" src="lib/coriolis/coriolis.browserified.bundle.js"></script>
    <script>
      logger.log("Bundle_CORIO", Bundle_CORIO);
      const coriolis = Bundle_CORIO.coriolis;

      // const eventStore = coriolis.createStore({});

    </script>
    <script>
      //discovery

      const projection__currentCount = ({ useState, useEvent }) => (
        useState(0),
        useEvent(),
        (state, event) => {
          switch (event.type) {
            case 'incremented':
              return state + 1

            case 'decremented':
              return state - 1

            default:
              return state
          }
        }
      );

      const eventStore = coriolis.createStore(({ withProjection, dispatch }) => {

        withProjection(projection__currentCount).subscribe((count) => logger.log(count));
        // 0

        dispatch({ type: 'incremented' });
        // 1

        dispatch({ type: 'incremented' });
        // 2

        dispatch({ type: 'decremented' });
        // 1
      });

      logger.log("eventStore", eventStore);

    </script> -->

  <script type="text/javascript" src="lib/uuid.browserified.bundle.js"></script>
  <script>
    logger.log("Bundle_UUID", Bundle_UUID);

    const uuidv4 = Bundle_UUID.uuidv4;
    const id__test = uuidv4();

    logger.log("id__test", id__test);

  </script>


  <script type="text/javascript" src="lib/jwt.browserified.bundle.js"></script>
  <script>
    logger.log("Bundle_JWT", Bundle_JWT);

    var counter__jwt = 0;
    const string__private = "lolilol";
    const getJwt = () => {
      counter__jwt = counter__jwt + 1;
      const token = Bundle_JWT.jwt.sign({ counter__jwt: counter__jwt }, string__private);
      return token;
    };

  </script>
  <!-- <script>
      //discovery
      const token = getJwt();
      logger.log("token", token);

      logger.log("getJwt()", getJwt());
      logger.log("getJwt()", getJwt());
    </script> -->

  <!-- <script type="text/javascript" src="lib/wolkenkit-eventstore/wolkenkit-eventstore.browserified.bundle.edited.js"></script> -->
  <script type="text/javascript" src="lib/wolkenkit-eventstore/wolkenkit-eventstore.browserified.bundle.js"></script>
  <script>
    logger.log("Bundle_WKES", Bundle_WKES);
    const Eventstore = Bundle_WKES.eventstore.Eventstore;
    const Event = Bundle_WKES.eventstore.Event;
    const Command = Bundle_WKES.eventstore.Command;
    // const EventEmitter = Bundle_WKES.eventstore.EventEmitter;

    const eventstore__global = new Eventstore();
    eventstore__global.initialize();
    logger.log("eventstore__global", eventstore__global);

    // const eventPublisher = new EventEmitter();
    const uuid__unknown = '123e4567-e89b-42d3-a456-426614174000';

    function readEventStream_p(eventStream) {
      logger.log("readEventStream_p", eventStream);

      return new Promise((resolve, reject) => {

        var arr_event = [];

        eventStream.on('readable', function () {
          // logger.log("eventStream.on('readable')");
          while ((evt = eventStream.read()) != null) {
            arr_event.push(evt);
          }
        });

        eventStream.on('end', function () {
          // logger.log("eventStream.on('end')");
          resolve(arr_event);
        });

      });

    };

  </script>
  <!-- <script>
      //discovery
      // eventstore__global.destroy();

      //create commands and events
      {
        const command = new Command({
          context: {
            name: 'network'
          },
          aggregate: {
            name: 'node',
            id: '85932442-bf87-472d-8b5a-b0eac3aa8be9'
          },
          name: 'ping',
          data: {
            ttl: 10 * 1000
          },
          custom: {
            sourceIp: '127.0.0.1'
          }
        });
        logger.log("command", command);

        const token = getJwt();
        logger.log("token.sub", token.sub());
        const initiator = {
          id: token.sub(),
        };
        command.addInitiator(initiator);

        const event = new Event({
          context: {
            name: 'network'
          },
          aggregate: {
            name: 'node',
            id: '85932442-bf87-472d-8b5a-b0eac3aa8be9'
          },
          name: 'pinged',
          data: {
            ttl: 10 * 1000
          },
          custom: {
            sourceIp: '127.0.0.1'
          },
          metadata: {
            correlationId: '13505cab-0ca2-4502-b8c9-8f3ce63ae390',
            causationId: '124885f3-d35e-43a6-84eb-e28c70b5be66'
          }
        });

        event.addInitiator(command.initiator);

      }

      //store event
      {

        const id__aggregate = '85932442-bf87-472d-8b5a-b0eac3aa8be9';

        const event__1 = new Event({
          context: {
            name: 'network'
          },
          aggregate: {
            name: 'node',
            id: id__aggregate,
          },
          name: 'pinged',
          data: {
            ttl: 10 * 1000
          },
          custom: {
            sourceIp: '127.0.0.1'
          },
          metadata: {
            correlationId: '13505cab-0ca2-4502-b8c9-8f3ce63ae390',
            causationId: '124885f3-d35e-43a6-84eb-e28c70b5be66'
          }
        });
        event__1.metadata.revision = 1;

        const event__2 = new Event({
          context: {
            name: 'network'
          },
          aggregate: {
            name: 'node',
            id: id__aggregate,
          },
          name: 'lolilol',
          data: {
            ttl: 10 * 1000
          },
          custom: {
            sourceIp: '127.0.0.1'
          },
          metadata: {
            correlationId: '13505cab-0ca2-4502-b8c9-8f3ce63ae390',
            causationId: '124885f3-d35e-43a6-84eb-e28c70b5be66'
          }
        });
        event__2.metadata.revision = 2;


        const arr_event__saved = eventstore__global.saveEvents({
          uncommittedEvents: [
            { event: event__1, state: {desc: "state1"} },
            { event: event__2, state: {desc: "state2"} }
          ]
        });

        const arr_event__stored = eventstore__global.getStoredEvents();
        logger.log("arr_event__stored", arr_event__stored);

        eventstore__global.getLastEvent(id__aggregate).then(event__last => {
          logger.log("event__last", event__last);
        });

        const eventStream_p = eventstore__global.getEventStream({aggregateId: id__aggregate});
        eventStream_p.then(readEventStream_p)
        .then(arr_event__eventStream => {
          logger.log("arr_event__eventStream", arr_event__eventStream);
        });

      }

      //store event again
      {

        const id__aggregate = uuidv4();
        // const id__aggregate = uuid__unknown;

        const id__correlation = uuidv4();
        const id__causation   = uuidv4();

        const event__3 = new Event({
          context: {
            name: 'ux'
          },
          aggregate: {
            name: 'node',
            id: id__aggregate,
          },
          name: 'grabbed',
          data: {},
          custom: {},
          metadata: {
            correlationId: id__correlation,
            causationId:   id__causation,
          }
        });
        event__3.metadata.revision = 1;

        const event__4 = new Event({
          context: {
            name: 'ux'
          },
          aggregate: {
            name: 'node',
            id: id__aggregate,
          },
          name: 'moved',
          data: {},
          custom: {},
          metadata: {
            correlationId: id__correlation,
            causationId:   id__causation
          }
        });
        event__4.metadata.revision = 2;


        const arr_event__saved = eventstore__global.saveEvents({
          uncommittedEvents: [
            { event: event__3, state: {desc: "state3"} },
            { event: event__4, state: {desc: "state4"} }
          ]
        });

        const arr_event__stored = eventstore__global.getStoredEvents();
        logger.log("arr_event__stored", arr_event__stored);

        eventstore__global.getLastEvent(id__aggregate).then(event__last => {
          logger.log("event__last", event__last);
        });

        const eventStream_p = eventstore__global.getEventStream({aggregateId: id__aggregate});
        eventStream_p.then(readEventStream_p)
        .then(arr_event__eventStream => {
          logger.log("arr_event__eventStream", arr_event__eventStream);
        });

      }



      //replay
      {
        const replayStream_p = eventstore__global.getReplay({
          // fromPosition: 7,
          // toPosition: 23
        });

        replayStream_p.then(readEventStream_p)
        .then(arr_event__replay => {
          logger.log("arr_event__replay", arr_event__replay);
        });

      }

    </script> -->

  <!-- <script type="text/javascript" src="lib/bluebird.min.js"></script> -->
  <script type="text/javascript" src="lib/bluebird.browserified.bundle.js"></script>
  <script>
    logger.log("Bundle_BBIRD", Bundle_BBIRD);

    const bluebird = Bundle_BBIRD.bluebird;
  </script>
  <!-- <script>
      //discovery
      const arr_promise = [...Array(10).keys()].map(index => {
        return bluebird.delay(index * 1000, index);
      });

      const sum_p = bluebird.reduce(arr_promise, (acc,x) => {
        logger.log("acc", acc);
        return acc + x;
      }, 0);

      sum_p.then(value => {
        logger.log("sum_p", value);
      });
    </script> -->


  <!-- <canvas id="myCanvas">Your browser does not support HTML5 canvas</canvas> -->
  <!-- <script>
      const canvas = document.getElementById("myCanvas");
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
    </script> -->

  <video id="myVideo" width="200px" height="200px"></video>
  <div>
    <div style="display: inline-block;">current: </div>
    <div style="display: inline-block;" id="get100__current"></div>
  </div>
  <div>
    <div style="display: inline-block;">target: </div>
    <div style="display: inline-block;" id="get100__target"></div>
  </div>


  <!-- debug -->
  <!-- <div id="debug_container" style="position:absolute; left:0; top: 0; font-size: 60px; pointer-events: none;">
      <div>
        <div style="display: inline-block;">current scale: </div>
        <div style="display: inline-block;"id="debug_scale"></div>
      </div>
      <div>
        <div style="display: inline-block;">offset: </div>
        <div style="display: inline-block;" id="debug_offset"></div>
      </div>
      <div>
        <div style="display: inline-block;">nb objects: </div>
        <div style="display: inline-block;" id="debug_nbObjects"></div>
      </div>
      <div>
        <div style="display: inline-block;">current object rect: </div>
        <div style="display: inline-block;" id="debug_currObjRect"></div>
      </div>
      <div>
        <div style="display: inline-block;">activeColor: </div>
        <div style="display: inline-block;" id="debug_activeColor">"   "</div>
      </div>
    </div> -->

  <!-- <script>
      class Debug {
        constructor (eltsDict) {
          this.eltsDict = eltsDict;

          this.eltsDict["container"].style.visibility = "hidden";
        }

        setScale(scale) {
          this.eltsDict["scale"].innerHTML = JSON.stringify(scale);
        }
        setOffset(offset) {
          this.eltsDict["offset"].innerHTML = JSON.stringify(offset);
        }
        setNbObjects(nb_objects) {
          this.eltsDict["nb_objects"].innerHTML = nb_objects;
        }
        setCurrentObjectRect(current_object_rect) {
          this.eltsDict["current_object_rect"].innerHTML = JSON.stringify(current_object_rect);
        }

        setActiveColor(color) {
          this.eltsDict["active_color"].style.backgroundColor = color;
        }

      }

      const debugEltsDict = {
        container:            document.getElementById("debug_container"),

        scale:                document.getElementById("debug_scale"),
        offset:               document.getElementById("debug_offset"),
        nb_objects:           document.getElementById("debug_nbObjects"),
        current_object_rect:  document.getElementById("debug_currObjRect"),

        active_color:         document.getElementById("debug_activeColor"),
      };
      const debug = new Debug(debugEltsDict);

    </script> -->








  <script>
    class GET100_Game {

      constructor(dict_view) {
        this.dict_view = dict_view;

        //config
        const value__initial = 0;
        const value__target = 100;

        this.isUsingIcCards = false;



        //model
        this.gameState = new GET100_GameState(value__initial, value__target);
        this.rx_subject__gameState = new Subject();
        this.rx_observable__gameState = this.rx_subject__gameState.asObservable();

        this.gameInput = new GET100_GameInput();

        this.cardCollection = new GET100_CardCollection();
        Object.defineProperty(this, "dict_card", {
          get() {
            return this.cardCollection.dict_card;
          }
        });
        Object.defineProperty(this, "arr_card", {
          get() {
            return this.cardCollection.arr_card;
          }
        });

        //view
        this.bindToView__state_and_input(dict_view);

        //"outer" view
        this.bindToView__webcam(dict_view);


        this.start();
      }



      bindToView__state_and_input(dict_view) {
        const game = this;


        function func_validInput() {
          func_gameInputColorBlink("lime", 300);
        }
        this.dict_view["func_validInput"] = func_validInput;

        function func_invalidInput() {
          func_gameInputColorBlink("red", 300);
        }
        this.dict_view["func_invalidInput"] = func_invalidInput;


        function func_gameInputColorBlink(colorName, duration_in_milliseconds) {

          function changeColor(color) {
            // dict_view["video"].style.border =
            dict_view["div_current"].style.backgroundColor = color;
          }

          const fColor__fill = new fabric.Color(colorName);
          fColor__fill.setAlpha(0.5);
          const color_temp = fColor__fill.toRgba();
          changeColor(color_temp);
          setTimeout(function () {
            // rep_free.fill = "transparent";
            changeColor("transparent");
          }, duration_in_milliseconds);

        }


        //--control--

        //forward gameState updates
        this.rx_observable__gameState.subscribe({
          next: (gameState) => {
            logger.log("rx_observable__gameState", "next", gameState.value__current);

            function changeState__current(value) {
              dict_view["div__current"].innerHTML = "" + value;
            }

            function changeState__target(value) {
              dict_view["div__target"].innerHTML = "" + value;
            }

            changeState__current(gameState.value__current);
            changeState__target(gameState.value__target);

          },
        });


      }

      bindToView__webcam(dict_view) {
        const game = this;

        // //analyze image 
        // rep_free.onInnerUpdate((rep_free, propName, oldValue, newValue) => {

        //   if (propName == "img") {

        //   }

        // });

        // function attemptDecoding(img) {

        //   if (img != null) {
        //     ImageUtils.qrcode__decode_image_p(img)
        //       .then((result) => {
        //         logger.log("result", result);
        //         if (result != null) {
        //           // const str__result = result.text;
        //           const str__result = result;

        //           const rawInput = str__result;
        //           game.manageGameInput__rawInput(rawInput);
        //         }
        //       }).catch((err) => {
        //         // console.error(err);
        //       });
        //   }
        // }





        // let scanner = new Instascan.Scanner({ video: dict_view["video"] });
        // scanner.addListener('scan', function (content) {
        //   alert(content);
        // });
        // Instascan.Camera.getCameras().then(function (cameras) {
        //   if (cameras.length > 0) {
        //     scanner.start(cameras[0]);
        //   } else {
        //     console.error('No cameras found.');
        //   }
        // }).catch(function (e) {
        //   console.error(e);
        // });






        // function onScanSuccess(decodedText, decodedResult) {
        //   // handle the scanned code as you like, for example:
        //   console.log(`Code matched = ${decodedText}`, decodedResult);
        // }

        // function onScanFailure(error) {
        //   // handle scan failure, usually better to ignore and keep scanning.
        //   // for example:
        //   console.warn(`Code scan error = ${error}`);
        // }

        // let html5QrcodeScanner = new Html5QrcodeScanner(
        //   "myVideo",
        //   { fps: 10, qrbox: { width: 250, height: 250 } },
        //   /* verbose= */ false);
        // html5QrcodeScanner.render(onScanSuccess, onScanFailure);


        // Html5Qrcode.getCameras().then(devices => {
        //   logger.log("devices", devices);
        //   /**
        //    * devices would be an array of objects of type:
        //    * { id: "id", label: "label" }
        //    */
        //   if (devices && devices.length) {
        //     var cameraId = devices[0].id;
        //     // .. use this to start scanning.

        //     const html5QrCode = new Html5Qrcode(/* element id */ "myVideo");
        //     html5QrCode.start(
        //       cameraId,
        //       {
        //         fps: 10,    // Optional, frame per seconds for qr code scanning
        //         // qrbox: { width: 250, height: 250 }  // Optional, if you want bounded box UI
        //       },
        //       (decodedText, decodedResult) => {
        //         // do something when code is read
        //         logger.log("decodedText", decodedText);
        //       },
        //       (errorMessage) => {
        //         // parse error, ignore it.
        //         logger.log("errorMessage", errorMessage);

        //       })
        //       .catch((err) => {
        //         // Start failed, handle it.
        //         logger.log("Start failed", err);

        //       });

        //   }
        // }).catch(err => {
        //   // handle err
        //   logger.log(err);
        // });


        // const html5QrCode = new Html5Qrcode(/* element id */ "myVideo");

        // html5QrCode.start(
        //   { facingMode: "user" },
        //   // { facingMode: { exact: "user"} },
        //   {
        //     fps: 10,    // Optional, frame per seconds for qr code scanning
        //     // qrbox: { width: 250, height: 250 }  // Optional, if you want bounded box UI
        //   },
        //   (decodedText, decodedResult) => {
        //     // do something when code is read
        //     logger.log("decodedText", decodedText);
        //   },
        //   (errorMessage) => {
        //     // parse error, ignore it.
        //     logger.log("errorMessage", errorMessage);
        //   })
        //   .catch((err) => {
        //     // Start failed, handle it.
        //     logger.log("Start failed", err);
        //   });





        function decodeContinuously(codeReader, selectedDeviceId) {
          codeReader.decodeFromInputVideoDeviceContinuously(selectedDeviceId, 'myVideo', (result, err) => {
            if (result) {
              // properly decoded qr code
              logger.log('Found QR code!', result)
              // document.getElementById('result').textContent = result.text;

              const rawInput = result.text;
              game.manageGameInput__rawInput(rawInput);
            }

            if (err) {
              // As long as this error belongs into one of the following categories
              // the code reader is going to continue as excepted. Any other error
              // will stop the decoding loop.
              //
              // Excepted Exceptions:
              //
              //  - NotFoundException
              //  - ChecksumException
              //  - FormatException

              if (err instanceof ZXing.NotFoundException) {
                console.log('No QR code found.')
              }

              if (err instanceof ZXing.ChecksumException) {
                console.log('A code was found, but it\'s read value was not valid.')
              }

              if (err instanceof ZXing.FormatException) {
                console.log('A code was found, but it was in a invalid format.')
              }
            }
          })
        }

        const codeReader = new ZXing.BrowserQRCodeReader();

        codeReader.getVideoInputDevices()
          .then((videoInputDevices) => {
            const selectedDeviceId = videoInputDevices[0].deviceId;
            if (videoInputDevices.length >= 1) {
              decodeContinuously(codeReader, selectedDeviceId);
            }
          })
          .catch((err) => {
            logger.error(err);
          });


      }

      didPlayCard(card) {
        logger.log("didPlayCard", "card.getIdentifier()", card.getIdentifier());

        const game = this;

        //destroy model
        const opSimpleName = card.get100Operator.getSimpleName();
        const index_card   = card.index;
        delete game.dict_card[opSimpleName][index_card];

      }



      start() {
        const game = this;

        this.gameInput.rx_observable__gameInput.subscribe({
          next: (card) => {
            GET100_Game.manageGameAction__playCard(game, card);
          },
        });

        this.rx_observable__gameState.subscribe({
          next: (gameState) => {
            const value__current = gameState.value__current;
            if (value__current == gameState.value__target) {
              gameState.value__target = 100 - value__current;

              //notify update
              game.rx_subject__gameState.next(game.gameState);   //SHU: un peu cracra
            }
          },
        });

      }


      manageGameInput__rawInput(rawInput) {
        const card = this.cardCollection.getCardWithIdentifier(rawInput);
        if (card != null) {
          this.gameInput.rx_subject__gameInput.next(card);
        } else {
          throw new Error("no card found for input: " + rawInput);
        }
      }


      static manageGameAction__playCard(game, card) {
        logger.log("manageGameAction__playCard", game, card);

        //green blink
        // game.dict_view.func_validInput();

        //force card single use
        game.didPlayCard(card);


        const value__current = game.gameState.value__current;
        const mathNode__current = new math.ConstantNode(value__current);
        mathNode__current.autoSimplify = true;

        const get100Operator = card.get100Operator;
        const func = get100Operator.operatorNodeFactoryFuncWrapper.func;
        const mathNode__result = func(mathNode__current);

        game.gameState.value__current = mathNode__result.value;

        //notify update
        game.rx_subject__gameState.next(game.gameState);
      }

    }

    class GET100_GameState {

      constructor(value__initial, value__target) {
        this.value__initial = value__initial;
        this.value__current = this.value__initial;

        this.value__target = value__target;
      }

    }

    class GET100_GameInput {

      constructor() {
        this.rx_subject__gameInput = new Subject();
        this.rx_observable__gameInput = this.rx_subject__gameInput.asObservable();
      }

    }

    class GET100_Operator {

      constructor(operatorNodeFactoryFuncWrapper) {
        this.operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper;
      }

      getSimpleName() {
        return GET100_Operator.operatorSimpleName(this.operatorNodeFactoryFuncWrapper);
      }

      static operatorSimpleName(operatorNodeFactoryFuncWrapper) {
        return operatorNodeFactoryFuncWrapper.semantics.name;
      }

    }

    class GET100_Card {

      constructor(get100Operator, index) {
        this.get100Operator = get100Operator;
        this.index = index;
      }

      getIdentifier() {
        const str__id = "GET100__" + this.get100Operator.getSimpleName();
        const str__index = "#" + this.index;
        const str__full = str__id + "" + str__index;
        return str__full;
      }

    }

    class GET100_CardCollection {

      constructor() {
        const arr_operator = this.createArrOperator();  //may contain an operator multiple times

        this.dict_card = this.createDictCard(arr_operator); //example of use: dict.operator[opSimpleName].arr_instance[2]
        this.arr_card = this.createArrCard(this.dict_card);
      }

      createDictCard(arr_operator) {
        var outDict;

        outDict = arr_operator.reduce((acc, op) => {
          const str__opSimpleName = op.getSimpleName();

          if (acc[str__opSimpleName] == null) {
            acc[str__opSimpleName] = {};
          }

          const index_card = [...Object.values(acc[str__opSimpleName])].length;
          const card = new GET100_Card(op, index_card);
          acc[str__opSimpleName][index_card] = card;

          return acc;
        }, {});

        return outDict;
      }

      createArrCard(dict_card) {
        var outArr;

        const arr_card = [...Object.values(dict_card)].reduce((acc, x) => {
          return acc.concat([...Object.values(x)]);
        }, []);

        const arr_card__shuffled = Utils.shuffle([...arr_card]);
        outArr = arr_card__shuffled;
        return outArr;
      }

      createArrOperator() {
        var outArr;

        const arr_operatorNodeFactoryFuncWrapper = this.createArrOperatorNodeFactoryFuncWrapper();

        outArr = arr_operatorNodeFactoryFuncWrapper.map(operatorNodeFactoryFuncWrapper => {
          return new GET100_Operator(operatorNodeFactoryFuncWrapper);
        });

        return outArr;
      }

      createArrOperatorNodeFactoryFuncWrapper() {
        var outArr;

        // const arr_opSymbol = ["+", "-", "x", "/"];
        // const arr_opSymbol = ["+", "x"];
        // const arr_value_b  = [0,1,2,3,4,5,6,7,8,9];

        // const arr_opSymbol = ["+", "+"];
        // const arr_value_b  = [0,1,2,3,0,1,2,3];

        // const arr_opSymbol = ["+"];
        // const arr_value_b  = [100];
        // const arr_opSymbol_valueb =  [["+", 100]];

        const arr_add = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15].map(value_b => ["+", value_b]);
        // const arr_add      = [0,1,2,3,4,5,6,7,8,9,10].map(value_b => ["+", value_b]);
        const arr_subtract = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(value_b => ["-", value_b]);
        const arr_multiply = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(value_b => ["x", value_b]);
        const arr_divide = [1, 2, 3, 4, 5, 6, 7, 8, 9].map(value_b => ["/", value_b]);

        const arr_opSymbol_valueb = [...arr_add,
        ...arr_add,
        ...arr_subtract,
        ...arr_subtract,
        ...arr_multiply,
        ...arr_divide];

        // const arr_opSymbol_valueb =  [...arr_add];

        outArr = arr_opSymbol_valueb.map(([string__opSymbol, value_b]) => {
          const op = Operator.fromString_binary(string__opSymbol);
          const node_b = new math.ConstantNode(value_b);
          const operatorNodeFactoryFuncWrapper = operatorNodeFactoryFuncWrapper_binary(op, node_b);
          return operatorNodeFactoryFuncWrapper;
        });

        return outArr;
      }

      getCardWithIdentifier(identifier__card) {
        logger.log("getCardWithIdentifier", identifier__card);

        //parsing
        const arr_elt = identifier__card.split("#");
        const index = arr_elt[1];
        // logger.log("index", index);

        const opSimpleName = arr_elt[0].split("__")[1];
        // logger.log("opSimpleName", opSimpleName);

        const card = this.dict_card[opSimpleName][index];
        // logger.log("card", card);

        return card;
      }

    }

  </script>
  <script>

    const dict_view = {
      "video": document.getElementById("video"),

      "div__current": document.getElementById("get100__current"),
      "div__target": document.getElementById("get100__target"),
    };

    //launch game
    const game__GET100 = new GET100_Game(dict_view);

  </script>




</body>

</html>