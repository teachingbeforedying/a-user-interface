une page toujours blanche

Une Interface Utilisateur(A User Interface)

Utiliser un canevas infini donne, à mesure que l'on se l'approprie,
des idées de création qui demandent une interface utilisateur adaptée.
L'interface présentée ici découle des principes suivants:
    - pas de menus: à l'écran, il y a le contenu et le curseur, et c'est tout
    - le clavier et la souris sont des instruments très satisfaisants pour les mains humaines, car ils sont de bons conducteurs de subtilité
    - l'interface est une collection imbriquée et grandissante de concepts autour du canevas infini
      Les raccourcis clavier/souris pourront changer, les couleurs, le style pourront changer mais la formalisation perdurera.
      Cette formalisation permet:
        -de créer des liens entre les différents concepts mis au jour
        -au développeur de commencer à réaliser ce qu'il a imaginé (bien qu'il en découvre encore _en faisant les choses_)
        -de construire un langage commun pour les utilisateurs/développeurs
            par exemple, les concepts, une fois appropriés, peuvent être invoqués en classe sur _papier_
        
Cette interface va à contre-courant de (ou au moins vient en décalage par rapport à l') évolution de l'utilisation des ordinateurs.
Depuis les écrans tactiles, on fait comme si l'utilisateur n'avait que 2 doigts (ou au mieux 4).
Avec Une Interface Utilisateur, les mains des utilisateurs -ces merveilles qu'il serait grossier de dénigrer- leurs permettent, au fur et à mesure, 
    d'être comme des joueurs de violon, de plus en plus proche de leur instrument, jouant avec leur propre style,
    comme chacun a sa propre graphie avec un stylo sur le papier.
Pas besoin de matériel coûteux: on revient au clavier/souris basiques, avec des ordinateurs normaux (pas besoin de surpuissance), 
    et un navigateur internet standard (qui fait office de machine virtuelle avec un affichage),
    et sans obligatoirement avoir besoin d'être connecté à Internet. 

Le caractère fondamental des concepts découle du caractère fondamental de la manipulation/transformation d'objets (c'est de la "chimie virtuelle").
Par conséquent, c'est très probable que les découvertes présentées soient les découvertes "faciles". 
Au fur et à mesure, les nouvelles découvertes seront plus sophistiquées et sûrement moins fondamentales.
Les raccourcis clavier/souris pourront être transposés à des appareillages techniques plus modernes quand ceux-ci verront le jour.   

La portée éducative du logiciel est sa raison d'être.
Premièrement,
Elle permet au professeur de présenter de manière interactive et animée des concepts, sans avoir recours aux vidéos, bien trop monolithiques, 
    en suivant son propre style.
Elle permet à l'élève de découvrir des concepts, en autonomie, par des expériences "sans conséquence". On essaie, on verra bien ce que ça donne.
Deuxièmement,
Elle pourrait enfin permettre à des groupes d'élèves de travailler en coopération sur des projets divers (pas forcément mathématiques),
    en continuant à utiliser l'interface qu'ils se seront appropriée,
    voire de créer leurs petits mondes (comme quand les enfants jouent aux Lego et aux PlayMobil, ou a Minecraft).
Elle permet aux professeurs d'exprimer facilement leurs idées, puis de les transmettre dans un format générique, pour éventuellement laisser les devs les réaliser ultérieurement.

Les concepts les plus forts vont être présentés.
    Infinite Canvas (iC)
    0. icObj, icComposite, engine
        tout est objet
        la taille n'a pas d'importance (puisque tout ce qui est de taille fini peut être ramené à une taille "opérable")
        les moteurs permettent d'ajouter de la vie aux objets "minéraux"
        les objets composites permettent de fabriquer des structures complexes
    1. zScroll, et tous les autres scrolls
        zScroll (le retour d'une vieille idée)
    2. opérateurs, formalisme
    3. pathmade: vers la programmation par le dessin
    4. freeDraw: adhere, comb, ..., vDraw
    5. povRect/printPovRect
    6. ic+3dRoom
    Green Mouse (gm)/edu
    7.  gm/touchSlot
        les malédictions
        la forme canonique
        l'aléatoire comme principe de base
    8.  icArray (l'influence d'APL)
        il faut rendre hommage à Iverson, qui a vraiment essayé de trouver un moyen de transmettre les maths différemment
    9.  galaxies d'apprentissage (plus on zoome, plus on se spécialise) (dans iC et dans 3dRoom)  
    10. get100/aliceInjection: autre modes d'interaction: laisser pour un temps le clavier et la souris

-Clavier/souris ? Sérieux ?!
-C'est une étape de transition avant que l'on puisse manipuler sans les mains ("psynipuler")
    Pour l'instant, de la même façon que l'on utilise, depuis quelques siècles, le couteau et la fourchette pour manger,
    ce sont des instruments suffisament conviviaux pour qu'ils soient utilisés comme des prises en escalade, pour se hisser techniquement

zScroll:
    expliquer le zScroll sur la page avec le même texte sous plusieurs formes Géant, normal, minuscule,...


L'interface utilisateur étant principalement visuelle, des illustrations vont naturellement accompagner les concepts.


Les concepts présentés semblent aller de soi ("Pourquoi parler de choses si évidentes ?"),
mais ils constituent une nouvelle façon de véhiculer les intentions des utilisateurs (qu'ils soient devant ou "derrière" l'écran).


------------

InfiniteCanvas (iC)

0. icObj, icComposite, engine
    tout est objet
        Dans Misocroft PoperWoint, il y a des zones de texte, des images, etc.
        Dans iC, c'est la même chose, sauf qu'il y a aussi des objets mathématiques.
        L'exemple type est iCMathNode, qui pour faire simple, représente un nombre.
        Autrement dit, comme dans un langage de programmation classique, on fait la différence entre les nombres et les chaînes de caractères.
        iCImage est une image.
        iCText est du texte.
        iCRect est un rectangle.
        iCSegment est un segment.
        Toutes les sortes d'objets peuvent exister dans iC (il y a même iCInfiniteCanvas...)
        On peut saisir un objet et le déplacer en cliquant dessus et glisser la souris tout en restant cliqué.
    infiniteCanvas
        Jusque là, c'est comme dans PoperWoint.
        Toute la différence vient maintenant: 
            il y a de la place pour tout le monde : puisque l'espace est infini, quelle que soit la taille de l'objet que l'on veut insérer, on pourra toujours le faire.
        Dans un canevas infini, la zone qui est affichée à l'écran est un point de vue.
        On regarde juste un morceau d'un espace 2D infini.
        On peut zoomer et voir des objets qui étaient tellement minuscules qu'ils n'occupaient même pas un pixel sur l'écran de l'ordinateur.
        On peut dézoomer et voir que l'on était en fait "à l'intérieur" d'un objet très grand.
    Objets motorisés:
        Les objets présentés jusque là, les nombres, les images, les textes, n'ont pas de comportements autonomes.
        Ils sont juste des conteneurs de données.
        On peut les qualifier de "minéraux".                
        Les moteurs permettent d'ajouter de la vie aux objets "minéraux".
        Exemple:
            Avec un moteur de bouton, on peut transformer un objet texte, en un bouton, de telle sorte qu'à chaque fois que l'on va cliquer dessus,
            on va ajouter le caractère '.' à la fin. On passera donc par exemple de "abc" à "abc." puis "abc.." puis "abc..." etc.
        Un même objet peut avoir plusieurs moteurs (tant qu'ils sont compatibles).
    Composites:
        Les objets composites représentent des arbres, enfin des arbres en maths, 
        c'est à dire qu'un composite peut contenir d'autres objets, qui peuvent être des composites, ...
        On peut facilement s'imaginer cela avec des cartons:
            dans un carton, on peut mettre des objets "normaux" (ballon de basket, banane, rouleau de scotch),
                                        et d'autres cartons (avec des choses dedans).
        Les composites qui contiennent un objet sont ses composites parents (il y a sa mère, sa grand-mère, etc.).
        Le composite qui n'est contenu dans rien est le composite racine.
        En pratique, un objet composite est un rectangle (icRect) équipé d'un moteur "composite".
        Un composite peut avoir des parties mobiles, c'est à dire des parties que l'on peut déplacer librement par rapport aux autres,
        et des parties fixes, qui entraînent le déplacement "en bloc" de tout le composite racine.
        Ces objets sont très utiles pour créer des structures (structures de données mais également dispositions visuelles).
            Exemples:
                On prend un nom, un prénom, un âge, une photo et on l'on crée une structure "Elève".
                Lorsque l'on déplace le composite élève, nom, prénom, âge et photo se déplacent en même temps.
                Autrement dit, c'est un objet en soi, de la même manière qu'une voiture, avec ses passagers et son chargement, peut être considérée comme un seul objet.
    
1. zScroll, et tous les autres scrolls
    De la bonne utilisation de la molette de souris
        Quand la molette de souris est apparue dans les années 1990, 
        c'était, originellement, pour faciliter la navigation des comptables et des gestionnaires sur des feuilles de calcul avec beaucoup de cellules,
        via des zooms et des dézooms.
        Malheureusement, cette vision n'a pas vraiment été réalisée. La molette a surtout servi à faire défiler ("scroller") verticalement et horizontalement.
        Il a fallu attendre l'apparition des cartes virtuelles pour que la molette retrouve enfin sa mission principale: zoomer et dézoomer.

        L'interface utilisateur est optimale, quand la souris est utilisée de manière optimale.
        Pour une utilisation optimale, il est préférable d'utiliser la molette avec l'index.
        Il s'en suit qu'il est préférable d'interchanger le clic droit et le clic gauche.
        Par la suite, on continuera d'appeler "clic gauche" le clic standard (qui se situera maintenant à droite sur la souris).
            "Clic droit" désignera le clic alternatif (on le fera avec l'index, sur le bouton gauche de la souris).
    zScroll (le retour d'une vieille idée)
        Pour être tout à fait précis, la vision initiale pour la molette de souris n'était pas seulement de zoomer et dézoomer.
        C'était zoomer et dézoomer _pour déplacer_ une valeur d'une cellule à une autre sur la feuille de calcul.
            Autrement dit, ne pas seulement changer le point de vue, mais faire voyager de la donnée.
        Le "zScroll" c'est cette idée, appliquée au canevas infini:
            On attrape un objet, et, alors qu'on zoome et qu'on dézoome, cet objet reste avec nous.
            Le zScroll est tellement facile(on clique, on roule la molette), que l'utilisateur l'utilise rapidement de façon naturelle.
            L'utilisateur prend également conscience que la taille n'a plus vraiment d'importance, 
            puisque tout ce qui est de taille finie peut être ramené à une taille "opérable", en utilisant le zScroll.
        Pour augmenter la vitesse de zoom/dézoom, on peut rester appuyé sur la touche Shift du clavier (touche souvent associée au sprint dans les jeux vidéo),
            et effectuer le mouvement de zScroll classique.
    les autres scrolls
        Une fois que l'on a compris à quel point le zScroll était agréable, on a envie de tirer le meilleur parti de la molette de souris.
        En appuyant sur une touche du clavier, on peut indiquer que l'on souhaite faire autre chose que le comportement standard, le zScroll.
        En voici quelques uns.
    valueScroll (touche N + molette)
        On saisit un objet nombre, on appuye sur la touche N du clavier et on scrolle: la valeur est incrémentée.
        Pour faire simple, si la valeur était 4, elle devient 5. Si on continue de scroller vers le haut, elle devient 6, etc.
        Si on scrolle vers le bas, la valeur est diminuée.
        C'est une façon de créer le nombre que l'on souhaite.
    opacityScroll (touche V + molette)
        On saisit un objet, on appuye sur la touche V du clavier et on scrolle: son opacité est modifiée.
        On peut facilement créer des objets "un peu transparents".
    colorScroll: on change la couleur de l'objet
    zIndexScroll: on fait passer l'objet au premier plan, ou un peu derrière un autre objet, ou tout au fond, etc.

2. opérateurs, formalisme
    Il n'y a pas de menu : la transformation des objets se fait sur place.
    Il y a une catégorie d'objets dédiée aux transformations, on les appelle les opérateurs.
    opérateurs standard:
        Pour transformer un objet:
            on se saisit de l'objet, 
            on lui fait toucher un opérateur 
                et l'opérateur s'applique alors à l'objet. 
            Tout simplement.
    Formalisme basique:
        Les objets sont indiqués par des doubles crochets.
            Exemple:
                [[4]] désigne l'icMathNode de valeur 4.
                [["abc123"]] désigne l'icText contenant la chaîne de caractères "abc123"
        Les opérateurs sont indiqués par des simples crochets.
            Exemple:
                [+ 2] désigne l'opérateur qui ajoute 2.
                [EnMajuscules] désigne l'opérateur qui 
        L'interaction entre un objet et un opérateur est indiquée par le symbole '*' et le résultat suit le symbole '='
            Exemples:
                [[4]]        * [+ 2]          = [[6]]
                [["abc123"]] * [EnMajuscules] = ["ABC123"]
            C'est une réaction de chimie virtuelle (* et = correspondent respectivement à + et → dans une réaction chimique).
    opérateurs applicables:
        Il ne se passe rien quand on touche un opérateur applicable avec un objet à transformer.
        Pour l'actionner, pendant que l'objet saisi touche l'opérateur, on fait un clic droit.
        Ces opérateurs sont symbolisés entre parenthèses.
        Exemple:
            (+ 2)
        Ces opérateurs ajoutent une petite couche de protection par rapport aux opérateurs classiques.
    Comment créer des opérateurs ?
        Une première façon de faire est d'entrer en mode "Saisie de Nombre"(en appuyant sur la touche W du clavier) et de taper, par exemple, "+ 2".
        Attention, "+2" fera apparaître l'objet [[2]] alors que "+ 2" fera apparaître l'opérateur [+ 2].
    Remarque en lien avec la programmation:
        Dans un but pédagogique, et pour insister sur les transformations, 
            la valeur que retourne la fonction est directement assignée à l'objet en entrée.
            L'objet entrant subi une mutation.
        Il est tout à fait envisageable, dans une évolution ultérieure, et pour former un public spécifique en informatique,
            de réaliser des fonctions pures pour lesquelles l'objet d'entrée et l'objet de sortie seront bien distincts.

3. pathmade: vers la programmation par le dessin
    De la même façon que l'on peut créer des objets complexes en utilisant les composites,
    on peut créer des opérateurs complexes en utilisant les pathmade.
    Voici le principe : 
        en dessinant un tapis roulant dont le trajet passe par des opérateurs, on arrive à transformer l'objet de départ selon une séquence bien précise.
    Structures de contrôle:
        switch
            on dessine des branchements
        if
            on dessine des branchements
        boucle
            on dessine une boucle       pour faire une boucle
        clonage
            on dessine des branchements
    Autres développements:
        fonctions avec plongements

4. freeDraw: adhere, comb, ..., vDraw
5. povRect/printPovRect
6. ic+3dRoom


------------

Green Mouse (gm)/edu

7.  gm/touchSlot
    les malédictions
    la forme canonique
    l'aléatoire comme principe de base
8.  icArray (l'influence d'APL)
    il faut rendre hommage à Iverson, qui a vraiment essayé de trouver un moyen de transmettre les maths différemment
9.  galaxies d'apprentissage (plus on zoome, plus on se spécialise) (dans iC et dans 3dRoom)  
10. get100/aliceInjection: autre modes d'interaction: laisser pour un temps le clavier et la souris




1600-2000 lignes c'est déjà bien
    20 lignes par page, 100 pages